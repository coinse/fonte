{"sha": "094f6223deb7ed5b09c2b15435bd13ade282993e", "log": "Merge branch '2.4' into 2.5  Conflicts: \tpom.xml \trelease-notes/VERSION", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n import java.lang.annotation.Annotation;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonInclude;\n-\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.core.Versioned;\n-\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.Converter;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n     \n     /*\n     /**********************************************************\n-    /* Class annotations for Polymorphic type handling (1.5+)\n+    /* Class annotations for Polymorphic type handling\n     /**********************************************************\n     */\n     \n      * @since 2.1\n      */\n     public PropertyName findWrapperName(Annotated ann) { return null; }\n+\n+    /**\n+     * Method for finding suggested default value (as simple textual serialization)\n+     * for the property. While core databind does not make any use of it, it is exposed\n+     * for extension modules to use: an expected use is generation of schema representations\n+     * and documentation.\n+     *\n+     * @since 2.5\n+     */\n+    public String findPropertyDefaultValue(Annotated ann) { return null; }\n \n     /**\n      * Method used to check whether specified property member (accessor\n      * @since 2.4\n      */\n     public String findImplicitPropertyName(AnnotatedMember member) { return null; }\n-    \n+\n     /*\n     /**********************************************************\n     /* Serialization: general annotations\n      * field) defines which Bean/Map properties are to be included in\n      * serialization.\n      * If no annotation is found, method should return given second\n-     * argument; otherwise value indicated by the annotation\n+     * argument; otherwise value indicated by the annotation.\n+     *<p>\n+     * Note that meaning of inclusion value depends on whether it is for\n+     * a Class or property (field/method/constructor): in former case,\n+     * it is the default for all properties; in latter case it is specific\n+     * override for annotated property.\n      *\n      * @return Enumerated value indicating which properties to include\n      *   in serialization\n      */\n     public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) {\n+        return defValue;\n+    }\n+\n+    /**\n+     * Method for checking whether content (entries) of a {@link java.util.Map} property\n+     * are to be included during serialization or not.\n+     * \n+     * @since 2.5\n+     */\n+    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue) {\n         return defValue;\n     }\n \n     public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n         return null;\n     }\n+\n+    /**\n+     * Method for adding possible virtual properties to be serialized along\n+     * with regular properties.\n+     * \n+     * @since 2.5\n+     */\n+    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n+            List<BeanPropertyWriter> properties) { }\n     \n     /*\n     /**********************************************************\n     public boolean hasCreatorAnnotation(Annotated a) {\n         return false;\n     }\n+\n+    /**\n+     * Method for finding indication of creator binding mode for\n+     * a creator (something for which {@link #hasCreatorAnnotation} returns\n+     * true), for cases where there may be ambiguity (currently: single-argument\n+     * creator with implicit but no explicit name for the argument).\n+     * \n+     * @since 2.5\n+     */\n+    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridable methods: may be used as low-level extension\n+    /* points.\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that should be used by sub-classes for ALL\n+     * annotation access;\n+     * overridable so \n+     * that sub-classes may, if they choose to, mangle actual access to\n+     * block access (\"hide\" annotations) or perhaps change it.\n+     *<p>\n+     * Default implementation is simply:\n+     *<code>\n+     *  return annotated.getAnnotation(annoClass);\n+     *</code>\n+     * \n+     * @since 2.5\n+     */\n+    protected <A extends Annotation> A _findAnnotation(Annotated annotated,\n+            Class<A> annoClass) {\n+        return annotated.getAnnotation(annoClass);\n+    }\n+\n+    /**\n+     * Method that should be used by sub-classes for ALL\n+     * annotation existence access;\n+     * overridable so  that sub-classes may, if they choose to, mangle actual access to\n+     * block access (\"hide\" annotations) or perhaps change value seen.\n+     *<p>\n+     * Default implementation is simply:\n+     *<code>\n+     *  return annotated.hasAnnotation(annoClass);\n+     *</code>\n+     * \n+     * @since 2.5\n+     */\n+    protected boolean _hasAnnotation(Annotated annotated, Class<? extends Annotation> annoClass) {\n+        return annotated.hasAnnotation(annoClass);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n     /* Basic API for finding properties\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * @return Ordered Map with logical property name as key, and\n      *    matching getter method as value.\n      */\n     public abstract List<BeanPropertyDefinition> findProperties();\n-    \n+\n     /**\n      * Method for locating all back-reference properties (setters, fields) bean has\n      */\n     public abstract Map<String,AnnotatedMember> findBackReferenceProperties();\n \n     public abstract Set<String> getIgnoredPropertyNames();\n-    \n+\n     /*\n     /**********************************************************\n     /* Basic API for finding creator members\n     /**********************************************************\n      */\n-    \n+\n     public abstract List<AnnotatedConstructor> getConstructors();\n-    \n+\n     public abstract List<AnnotatedMethod> getFactoryMethods();\n-    \n+\n     /**\n      * Method that will locate the no-arg constructor for this class,\n      * if it has one, and that constructor has not been marked as\n     public abstract JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue);\n \n     /**\n+     * @since 2.5\n+     */\n+    public abstract JsonInclude.Include findSerializationInclusionForContent(JsonInclude.Include defValue);\n+    \n+    /**\n      * Method for checking what is the expected format for POJO, as\n      * defined by defaults and possible annotations.\n      * Note that this may be further refined by per-property annotations.\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n     /**\n      * Whether value for property is marked as required using\n      * annotations or associated schema.\n+     * Equivalent to:\n+     *<code>\n+     *  getMetadata().isRequired()\n+     *</code>\n      * \n      * @since 2.2\n      */\n         @Override public AnnotatedMember getMember() { return _member; }\n \n         /**\n+         *<p>\n+         * TODO: move to {@link BeanProperty} in near future, once all standard\n+         * implementations define it.\n+         * \n+         * @since 2.5\n+         */\n+        public boolean isVirtual() { return false; }\n+\n+        /**\n          * Implementation of this method throws\n          * {@link UnsupportedOperationException}, since instances of this\n          * implementation should not be used as part of actual structure\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n  * \"fluent factory\" methods.\n  * Note also that unlike with Jackson 1, these instances can not be\n  * assigned to {@link ObjectMapper}; in fact, application code should\n- * rarely interact directly with these instance (unlike core Jackson code)\n+ * rarely interact directly with these instances.\n  */\n public final class DeserializationConfig\n     extends MapperConfigBase<DeserializationFeature, DeserializationConfig>\n     implements java.io.Serializable // since 2.1\n {\n-    // for 2.1.0\n-    private static final long serialVersionUID = -4227480407273773599L;\n-\n-    /**\n-     * Set of features enabled; actual type (kind of features)\n-     * depends on sub-classes.\n+    // since 2.5\n+    private static final long serialVersionUID = 1;\n+\n+    /**\n+     * Set of {@link DeserializationFeature}s enabled.\n      */\n     protected final int _deserFeatures;\n \n      * Factory used for constructing {@link com.fasterxml.jackson.databind.JsonNode} instances.\n      */\n     protected final JsonNodeFactory _nodeFactory;\n-    \n+\n+    /**\n+     * States of {@link com.fasterxml.jackson.core.JsonParser.Feature}s to enable/disable.\n+     */\n+    protected final int _parserFeatures;\n+\n+    /**\n+     * Bitflag of {@link com.fasterxml.jackson.core.JsonParser.Feature}s to enable/disable\n+     */\n+    protected final int _parserFeaturesToChange;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle, constructors\n         _deserFeatures = collectFeatureDefaults(DeserializationFeature.class);\n         _nodeFactory = JsonNodeFactory.instance;\n         _problemHandlers = null;\n-    }\n-\n+        _parserFeatures = 0;\n+        _parserFeaturesToChange = 0;\n+    }\n+\n+    private DeserializationConfig(DeserializationConfig src,\n+            int mapperFeatures, int deserFeatures,\n+            int parserFeatures, int parserFeatureMask)\n+    {\n+        super(src, mapperFeatures);\n+        _deserFeatures = deserFeatures;\n+        _nodeFactory = src._nodeFactory;\n+        _problemHandlers = src._problemHandlers;\n+        _parserFeatures = parserFeatures;\n+        _parserFeaturesToChange = parserFeatureMask;\n+    }\n+    \n     /**\n      * Copy constructor used to create a non-shared instance with given mix-in\n      * annotation definitions and subtype resolver.\n         _deserFeatures = src._deserFeatures;\n         _nodeFactory = src._nodeFactory;\n         _problemHandlers = src._problemHandlers;\n-    }\n-\n-    private DeserializationConfig(DeserializationConfig src,\n-            int mapperFeatures, int deserFeatures)\n-    {\n-        super(src, mapperFeatures);\n-        _deserFeatures = deserFeatures;\n-        _nodeFactory = src._nodeFactory;\n-        _problemHandlers = src._problemHandlers;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n     \n     private DeserializationConfig(DeserializationConfig src, BaseSettings base)\n         _deserFeatures = src._deserFeatures;\n         _nodeFactory = src._nodeFactory;\n         _problemHandlers = src._problemHandlers;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n     \n     private DeserializationConfig(DeserializationConfig src, JsonNodeFactory f)\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = f;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     private DeserializationConfig(DeserializationConfig src,\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     private DeserializationConfig(DeserializationConfig src, String rootName)\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     private DeserializationConfig(DeserializationConfig src, Class<?> view)\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     /**\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     /**\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n     \n     // for unit tests only:\n             newMapperFlags |= f.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this :\n-            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+                    \n     }\n \n     @Override\n              newMapperFlags &= ~f.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this :\n-            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n     }\n \n     @Override\n             newMapperFlags = _mapperFeatures & ~feature.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this :\n-            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n     }\n \n     @Override\n     private final DeserializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new DeserializationConfig(this, newBase);\n     }\n-    \n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, DeserializationFeature-based factory methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig with(DeserializationFeature feature)\n+    {\n+        int newDeserFeatures = (_deserFeatures | feature.getMask());\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig with(DeserializationFeature first,\n+            DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures | first.getMask();\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures |= f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig withFeatures(DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures;\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures |= f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature disabled.\n+     */\n+    public DeserializationConfig without(DeserializationFeature feature)\n+    {\n+        int newDeserFeatures = _deserFeatures & ~feature.getMask();\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public DeserializationConfig without(DeserializationFeature first,\n+            DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures & ~first.getMask();\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures &= ~f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public DeserializationConfig withoutFeatures(DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures;\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures &= ~f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, JsonParser.Feature-based factory methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     *\n+     * @since 2.5\n+     */\n+    public DeserializationConfig with(JsonParser.Feature feature)\n+    {\n+        int newSet = _parserFeatures | feature.getMask();\n+        int newMask = _parserFeaturesToChange | feature.getMask();\n+        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n+            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     *\n+     * @since 2.5\n+     */\n+    public DeserializationConfig withFeatures(JsonParser.Feature... features)\n+    {\n+        int newSet = _parserFeatures;\n+        int newMask = _parserFeaturesToChange;\n+        for (JsonParser.Feature f : features) {\n+            int mask = f.getMask();\n+            newSet |= mask;\n+            newMask |= mask;\n+        }\n+        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n+            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n+                    newSet, newMask);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature disabled.\n+     *\n+     * @since 2.5\n+     */\n+    public DeserializationConfig without(JsonParser.Feature feature)\n+    {\n+        int newSet = _parserFeatures & ~feature.getMask();\n+        int newMask = _parserFeaturesToChange | feature.getMask();\n+        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n+            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     *\n+     * @since 2.5\n+     */\n+    public DeserializationConfig withoutFeatures(JsonParser.Feature... features)\n+    {\n+        int newSet = _parserFeatures;\n+        int newMask = _parserFeaturesToChange;\n+        for (JsonParser.Feature f : features) {\n+            int mask = f.getMask();\n+            newSet &= ~mask;\n+            newMask |= mask;\n+        }\n+        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n+            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n+                    newSet, newMask);\n+    }    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle, deserialization-specific factory methods\n                 (LinkedNode<DeserializationProblemHandler>) null);\n     }\n \n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features enabled.\n-     */\n-    public DeserializationConfig with(DeserializationFeature feature)\n-    {\n-        int newDeserFeatures = (_deserFeatures | feature.getMask());\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-\n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features enabled.\n-     */\n-    public DeserializationConfig with(DeserializationFeature first,\n-            DeserializationFeature... features)\n-    {\n-        int newDeserFeatures = _deserFeatures | first.getMask();\n-        for (DeserializationFeature f : features) {\n-            newDeserFeatures |= f.getMask();\n-        }\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-\n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features enabled.\n-     */\n-    public DeserializationConfig withFeatures(DeserializationFeature... features)\n-    {\n-        int newDeserFeatures = _deserFeatures;\n-        for (DeserializationFeature f : features) {\n-            newDeserFeatures |= f.getMask();\n-        }\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-    \n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified feature disabled.\n-     */\n-    public DeserializationConfig without(DeserializationFeature feature)\n-    {\n-        int newDeserFeatures = _deserFeatures & ~feature.getMask();\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-\n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features disabled.\n-     */\n-    public DeserializationConfig without(DeserializationFeature first,\n-            DeserializationFeature... features)\n-    {\n-        int newDeserFeatures = _deserFeatures & ~first.getMask();\n-        for (DeserializationFeature f : features) {\n-            newDeserFeatures &= ~f.getMask();\n-        }\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-\n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features disabled.\n-     */\n-    public DeserializationConfig withoutFeatures(DeserializationFeature... features)\n-    {\n-        int newDeserFeatures = _deserFeatures;\n-        for (DeserializationFeature f : features) {\n-            newDeserFeatures &= ~f.getMask();\n-        }\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    /*\n+    /**********************************************************\n+    /* JsonParser initialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called by {@link ObjectMapper} and {@link ObjectReader}\n+     * to modify those {@link com.fasterxml.jackson.core.JsonParser.Feature} settings\n+     * that have been configured via this config instance.\n+     * \n+     * @since 2.5\n+     */\n+    public void initialize(JsonParser p) {\n+        if (_parserFeaturesToChange != 0) {\n+            int orig = p.getFeatureMask();\n+            int newFlags = (orig & ~_parserFeaturesToChange) | _parserFeatures;\n+            if (orig != newFlags) {\n+                p.setFeatureMask(newFlags);\n+            }\n+        }\n     }\n     \n     /*\n         return (_deserFeatures & f.getMask()) != 0;\n     }\n \n+    public final boolean isEnabled(JsonParser.Feature f, JsonFactory factory) {\n+        int mask = f.getMask();\n+        if ((_parserFeaturesToChange & mask) != 0) {\n+            return (_parserFeatures & f.getMask()) != 0;\n+        }\n+        return factory.isEnabled(f);\n+    }\n+\n     /**\n      * \"Bulk\" access method for checking that all features specified by\n      * mask are enabled.\n     /* Other configuration\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Method for getting head of the problem handler chain. May be null,\n      * if no handlers have been added.\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n      * @since 2.3\n      */\n     protected transient ContextAttributes _attributes;\n+\n+    /**\n+     * Type of {@link JsonDeserializer} (or, more specifically,\n+     *   {@link ContextualizableDeserializer}) that is being\n+     *   contextualized currently.\n+     *\n+     * @since 2.5\n+     */\n+    protected LinkedNode<JavaType> _currentType;\n     \n     /*\n     /**********************************************************\n \n     /*\n     /**********************************************************\n-    /* Generic attributes (2.3+)\n+    /* Access to per-call state, like generic attributes (2.3+)\n     /**********************************************************\n      */\n \n         _attributes = _attributes.withPerCallAttribute(key, value);\n         return this;\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Public API, accessors\n+\n+    /**\n+     * Accessor to {@link JavaType} of currently contextualized\n+     * {@link ContextualDeserializer}, if any.\n+     * This is sometimes useful for generic {@link JsonDeserializer}s that\n+     * do not get passed (or do not retain) type information when being\n+     * constructed: happens for example for deserializers constructed\n+     * from annotations.\n+     * \n+     * @since 2.5\n+     *\n+     * @return Type of {@link ContextualDeserializer} being contextualized,\n+     *   if process is on-going; null if not.\n+     */\n+    public JavaType getContextualType() {\n+        return (_currentType == null) ? null : _currentType.value();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, config setting accessors\n     /**********************************************************\n      */\n \n     /**\n      * Method for checking whether we could find a deserializer\n      * for given type.\n-     * \n+     *\n      * @param type\n      * @since 2.3\n      */\n     {\n         JsonDeserializer<Object> deser = _cache.findValueDeserializer(this, _factory, type);\n         if (deser != null) {\n-            deser = (JsonDeserializer<Object>) handleSecondaryContextualization(deser, prop);\n+            deser = (JsonDeserializer<Object>) handleSecondaryContextualization(deser, prop, type);\n         }\n         return deser;\n     }\n \n+    /**\n+     * Variant that will try to locate deserializer for current type, but without\n+     * performing any contextualization (unlike {@link #findContextualValueDeserializer})\n+     * or checking for need to create a {@link TypeDeserializer} (unlike\n+     * {@link #findRootValueDeserializer(JavaType)}.\n+     * This method is usually called from within {@link ResolvableDeserializer#resolve},\n+     * and expectation is that caller then calls either\n+     * {@link #handlePrimaryContextualization(JsonDeserializer, BeanProperty, JavaType)} or\n+     * {@link #handleSecondaryContextualization(JsonDeserializer, BeanProperty, JavaType)} at a\n+     * later point, as necessary.\n+     *\n+     * @since 2.5\n+     */\n+    public final JsonDeserializer<Object> findNonContextualValueDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        return _cache.findValueDeserializer(this, _factory, type);\n+    }\n+    \n     /**\n      * Method for finding a deserializer for root-level value.\n      */\n         if (deser == null) { // can this occur?\n             return null;\n         }\n-        deser = (JsonDeserializer<Object>) handleSecondaryContextualization(deser, null);\n+        deser = (JsonDeserializer<Object>) handleSecondaryContextualization(deser, null, type);\n         TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type);\n         if (typeDeser != null) {\n             // important: contextualize to indicate this is for root value\n      * \n      * @param prop Property for which the given primary deserializer is used; never null.\n      * \n-     * @since 2.3\n-     */\n+     * @since 2.5\n+     */\n+    public JsonDeserializer<?> handlePrimaryContextualization(JsonDeserializer<?> deser,\n+            BeanProperty prop, JavaType type)\n+        throws JsonMappingException\n+    {\n+        if (deser instanceof ContextualDeserializer) {\n+            _currentType = new LinkedNode<JavaType>(type, _currentType);\n+            try {\n+                deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n+            } finally {\n+                _currentType = _currentType.next();\n+            }\n+        }\n+        return deser;\n+    }\n+\n+    @Deprecated // since 2.5; remove from 2.6\n     public JsonDeserializer<?> handlePrimaryContextualization(JsonDeserializer<?> deser,\n             BeanProperty prop)\n         throws JsonMappingException\n     {\n-        if (deser != null) {\n-            if (deser instanceof ContextualDeserializer) {\n-                deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n-            }\n-        }\n-        return deser;\n-    }\n-\n+        return handlePrimaryContextualization(deser, prop, TypeFactory.unknownType());\n+    }\n+    \n     /**\n      * Method called for secondary property deserializers (ones\n      * NOT directly created to deal with an annotatable POJO property,\n      * @param prop Property for which deserializer is used, if any; null\n      *    when deserializing root values\n      * \n-     * @since 2.3\n-     */\n+     * @since 2.5\n+     */\n+    public JsonDeserializer<?> handleSecondaryContextualization(JsonDeserializer<?> deser,\n+            BeanProperty prop, JavaType type)\n+        throws JsonMappingException\n+    {\n+        if (deser instanceof ContextualDeserializer) {\n+            _currentType = new LinkedNode<JavaType>(type, _currentType);\n+            try {\n+                deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n+            } finally {\n+                _currentType = _currentType.next();\n+            }\n+        }\n+        return deser;\n+    }\n+\n+    @Deprecated // since 2.5; remove from 2.6\n     public JsonDeserializer<?> handleSecondaryContextualization(JsonDeserializer<?> deser,\n             BeanProperty prop)\n-        throws JsonMappingException {\n-        if (deser != null && (deser instanceof ContextualDeserializer)) {\n+        throws JsonMappingException\n+    {\n+        if (deser instanceof ContextualDeserializer) {\n             deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n         }\n         return deser;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Parsing methods that may use reusable/-cyclable objects\n      * Helper method for constructing exception to indicate that given\n      * type id (parsed from JSON) could not be converted to a Java type.\n      */\n+    @Deprecated // since 2.5, use overloaded variant\n     public JsonMappingException unknownTypeException(JavaType type, String id) {\n         return JsonMappingException.from(_parser, \"Could not resolve type id '\"+id+\"' into a subtype of \"+type);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public JsonMappingException unknownTypeException(JavaType type, String id,\n+            String extraDesc) {\n+        String msg = \"Could not resolve type id '\"+id+\"' into a subtype of \"+type;\n+        if (extraDesc != null) {\n+            msg = msg + \": \"+extraDesc;\n+        }\n+        return JsonMappingException.from(_parser, msg);\n     }\n \n     public JsonMappingException endOfInputException(Class<?> instClass) {\n         return JsonMappingException.from(_parser, \"Unexpected end-of-input when trying to deserialize a \"\n                 +instClass.getName());\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Overridable internal methods\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n     FAIL_ON_IGNORED_PROPERTIES(false),\n \n     /**\n+     * Feature that determines what happens if an Object Id reference is encountered\n+     * that does not refer to an actual Object with that id (\"unresolved Object Id\"):\n+     * either an exception is thrown (<code>true</code>), or a null object is used\n+     * instead (<code>false</code>).\n+     * Note that if this is set to <code>false</code>, no further processing is done;\n+     * specifically, if reference is defined via setter method, that method will NOT\n+     * be called.\n+     *<p>\n+     * Feature is enabled by default, so that unknown Object Ids will result in an\n+     * exception being thrown, at the end of deserialization.\n+     * \n+     * @since 2.5\n+     */\n+    FAIL_ON_UNRESOLVED_OBJECT_IDS(true),\n+\n+    /**\n      * Feature that determines whether Jackson code should catch\n      * and wrap {@link Exception}s (but never {@link Error}s!)\n      * to add additional information about\n      * Feature is enabled by default.\n      */\n     WRAP_EXCEPTIONS(true),\n-    \n+\n     /*\n     /******************************************************\n     /* Structural conversion features\n      * If disabled, standard POJOs can only be bound from JSON null or\n      * JSON Object (standard meaning that no custom deserializers or\n      * constructors are defined; both of which can add support for other\n-     * kinds of JSON values); if enable, empty JSON String can be taken\n+     * kinds of JSON values); if enabled, empty JSON String can be taken\n      * to be equivalent of JSON null.\n      *<p>\n      * Feature is disabled by default.\n      */\n     ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false),\n+\n+    /**\n+     * Feature that can be enabled to allow empty JSON Array\n+     * value (that is, <code>[ ]</code>) to be bound to POJOs as null.\n+     * If disabled, standard POJOs can only be bound from JSON null or\n+     * JSON Object (standard meaning that no custom deserializers or\n+     * constructors are defined; both of which can add support for other\n+     * kinds of JSON values); if enabled, empty JSON Array will be taken\n+     * to be equivalent of JSON null.\n+     *<p>\n+     * Feature is disabled by default.\n+     * \n+     * @since 2.5\n+     */\n+    ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT(false),\n     \n     /**\n      * Feature that allows unknown Enum values to be parsed as null values. \n     ;\n \n     private final boolean _defaultState;\n+    private final int _mask;\n     \n     private DeserializationFeature(boolean defaultState) {\n         _defaultState = defaultState;\n+        _mask = (1 << ordinal());\n     }\n \n     @Override\n     public boolean enabledByDefault() { return _defaultState; }\n \n     @Override\n-    public int getMask() { return (1 << ordinal()); }\n+    public int getMask() { return _mask; }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n import java.lang.reflect.Modifier;\n \n import com.fasterxml.jackson.core.type.ResolvedType;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Base class for type token classes used both to contain information\n  * and as keys for deserializers.\n  *<p>\n  * Instances can (only) be constructed by\n- * <code>com.fasterxml.jackson.databind.TypeFactory</code>.\n+ * <code>com.fasterxml.jackson.databind.type.TypeFactory</code>.\n  *<p>\n  * Since 2.2 this implements {@link java.lang.reflect.Type} to allow\n  * it to be pushed through interfaces that only expose that type.\n \n     @Override\n     public JavaType containedType(int index) { return null; }\n-\n+       \n     @Override\n     public String containedTypeName(int index) { return null; }\n+\n+    @Override\n+    public abstract Class<?> getParameterSource();\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API beyond ResolvedType\n+    /**********************************************************\n+     */\n+    \n+    // NOTE: not defined in Resolved type\n+    /**\n+     * Convenience method that is functionally same as:\n+     *<code>\n+     * JavaType t = containedType(index);\n+     * if (t == null) {\n+     *    t = TypeFactory.unknownType();\n+     * }\n+     *</code>\n+     * and typically used to eliminate need for null checks for common case\n+     * where we just want to check if containedType is available first; and\n+     * if not, use \"unknown type\" (which translates to <code>java.lang.Object</code>\n+     * basically).\n+     *\n+     * @since 2.5\n+     */\n+    public JavaType containedTypeOrUnknown(int index) {\n+        JavaType t = containedType(index);\n+        return (t == null)  ? TypeFactory.unknownType() : t;\n+    }\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n      * Note that this method is never called for JSON null literal,\n      * and thus deserializers need (and should) not check for it.\n      *\n-     * @param jp Parsed used for reading JSON content\n+     * @param p Parsed used for reading JSON content\n      * @param ctxt Context that can be used to access information about\n      *   this deserialization activity.\n      *\n      * @return Deserialized value\n      */\n-    public abstract T deserialize(JsonParser jp, DeserializationContext ctxt)\n+    public abstract T deserialize(JsonParser p, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException;\n \n     /**\n      * that do not explicitly add support do not necessarily support\n      * update-existing-value operation (esp. immutable types)\n      */\n-    public T deserialize(JsonParser jp, DeserializationContext ctxt,\n+    public T deserialize(JsonParser p, DeserializationContext ctxt,\n             T intoValue)\n         throws IOException, JsonProcessingException\n     {\n      * \n      * @param typeDeserializer Deserializer to use for handling type information\n      */\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // We could try calling \n-        return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n+        return typeDeserializer.deserializeTypedFromAny(p, ctxt);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n import java.math.BigInteger;\n import java.util.*;\n \n-import com.fasterxml.jackson.core.JsonPointer;\n-import com.fasterxml.jackson.core.TreeNode;\n+import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.node.JsonNodeType;\n import com.fasterxml.jackson.databind.node.MissingNode;\n import com.fasterxml.jackson.databind.util.EmptyIterator;\n  *<p>\n  * Actual concrete sub-classes can be found from package\n  * {@link com.fasterxml.jackson.databind.node}.\n+ *<p>\n+ * Note that it is possible to \"read\" from nodes, using\n+ * method {@link TreeNode#traverse(ObjectCodec)}, which will result in\n+ * a {@link JsonParser} being constructed. This can be used for (relatively)\n+ * efficient conversations between different representations; and it is what\n+ * core databind uses for methods like {@link ObjectMapper#treeToValue(TreeNode, Class)}\n+ * and {@link ObjectMapper#treeAsTokens(TreeNode)}\n  */\n public abstract class JsonNode\n-    implements TreeNode, Iterable<JsonNode>\n+    implements TreeNode, Iterable<JsonNode>,\n+        JsonSerializable // since 2.5; bit tricky if anyone is sub-classing but...\n {\n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-//    public abstract JsonToken asToken();\n-\n-//    public abstract JsonParser.NumberType numberType();\n-\n-//    public abstract JsonParser traverse();\n+//  public abstract JsonToken asToken();\n+//  public abstract JsonToken traverse();\n+//  public abstract JsonToken traverse(ObjectCodec codec);\n+//  public abstract JsonParser.NumberType numberType();\n \n     @Override\n     public int size() { return 0; }\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonSerializable.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializable.java\n      * Serialization method called when no additional type information is\n      * to be included in serialization.\n      */\n-    public void serialize(JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonProcessingException;\n+    public void serialize(JsonGenerator gen, SerializerProvider serializers) throws IOException;\n \n     /**\n      * Serialization method called when additional type information is\n      * Note that some types (most notably, \"natural\" types: String, Integer,\n      * Double and Boolean) never include type information.\n      */\n-    public void serializeWithType(JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonProcessingException;\n+    public void serializeWithType(JsonGenerator gen, SerializerProvider serializers,\n+            TypeSerializer typeSer) throws IOException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n      * values of type this serializer handles.\n      *\n      * @param value Value to serialize; can <b>not</b> be null.\n-     * @param jgen Generator used to output resulting Json content\n-     * @param provider Provider that can be used to get serializers for\n+     * @param gen Generator used to output resulting Json content\n+     * @param serializers Provider that can be used to get serializers for\n      *   serializing Objects value contains, if any.\n      */\n-    public abstract void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n+    public abstract void serialize(T value, JsonGenerator gen, SerializerProvider serializers)\n         throws IOException, JsonProcessingException;\n \n     /**\n      * implementation would look like:\n      *<pre>\n      *  // note: method to call depends on whether this type is serialized as JSON scalar, object or Array!\n-     *  typeSer.writeTypePrefixForScalar(value, jgen);\n-     *  serialize(value, jgen, provider);\n-     *  typeSer.writeTypeSuffixForScalar(value, jgen);\n+     *  typeSer.writeTypePrefixForScalar(value, gen);\n+     *  serialize(value, gen, provider);\n+     *  typeSer.writeTypeSuffixForScalar(value, gen);\n      *</pre>\n      * and implementations for type serialized as JSON Arrays or Objects would differ slightly,\n      * as <code>START-ARRAY>/<code>END-ARRAY</code> and\n      * need to be properly handled with respect to serializing of contents.\n      *\n      * @param value Value to serialize; can <b>not</b> be null.\n-     * @param jgen Generator used to output resulting Json content\n-     * @param provider Provider that can be used to get serializers for\n+     * @param gen Generator used to output resulting Json content\n+     * @param serializers Provider that can be used to get serializers for\n      *   serializing Objects value contains, if any.\n      * @param typeSer Type serializer to use for including type information\n      */\n-    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+    public void serializeWithType(T value, JsonGenerator gen, SerializerProvider serializers,\n             TypeSerializer typeSer)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         Class<?> clz = handledType();\n         if (clz == null) {\n      * Default implementation will consider only null values to be empty.\n      * \n      * @since 2.0\n-     */\n+     * \n+     * @deprecated Since 2.5 Use {@link #isEmpty(SerializerProvider, Object)} instead\n+     */\n+    @Deprecated\n     public boolean isEmpty(T value) {\n         return (value == null);\n     }\n \n+    /**\n+     * Method called to check whether given serializable value is\n+     * considered \"empty\" value (for purposes of suppressing serialization\n+     * of empty values).\n+     *<p>\n+     * Default implementation will consider only null values to be empty.\n+     *<p>\n+     * NOTE: replaces {@link #isEmpty(Object)}, deprecated in 2.5\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isEmpty(SerializerProvider provider, T value) {\n+        // replace with implementation in 2.6 or later\n+        return isEmpty(value);\n+    }\n+    \n     /**\n      * Method that can be called to see whether this serializer instance\n      * will use Object Id to handle cyclic references.\n--- a/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n      AUTO_DETECT_FIELDS(true),\n     \n     /**\n-     * Feature that determines whether regualr \"getter\" methods are\n+     * Feature that determines whether regular \"getter\" methods are\n      * automatically detected based on standard Bean naming convention\n      * or not. If yes, then all public zero-argument methods that\n      * start with prefix \"get\" \n      * explicitly annotated for such use.\n      *<p>\n      * Feature is enabled by default, for backwards compatibility reasons.\n+     * \n+     * @since 2.2\n      */\n     ALLOW_FINAL_FIELDS_AS_MUTATORS(true),\n     \n      * us, which may be declaration order, but is not guaranteed).\n      *<p>\n      * Note that this is just the default behavior, and can be overridden by\n-     * explicit overrides in classes.\n+     * explicit overrides in classes (for example with\n+     * {@link com.fasterxml.jackson.annotation.JsonPropertyOrder} annotation)\n      *<p>\n      * Feature is disabled by default.\n      */\n     /* Name-related features\n     /******************************************************\n      */\n-\n+    /**\n+     * Feature that will allow for more forgiving deserialization of incoming JSON.\n+     * If enabled, the bean properties will be matched using their lower-case equivalents,\n+     * meaning that any case-combination (incoming and matching names are canonicalized\n+     * by lower-casing) should work.\n+     *<p>\n+     * Note that there is additional performance overhead since incoming property\n+     * names need to be lower-cased before comparison, for cases where there are upper-case\n+     * letters. Overhead for names that are already lower-case should be negligible however.\n+     *<p>\n+     * Feature is disabled by default.\n+     * \n+     * @since 2.5\n+     */\n+    ACCEPT_CASE_INSENSITIVE_PROPERTIES(false),\n+    \n     /**\n      * Feature that can be enabled to make property names be\n      * overridden by wrapper name (usually detected with annotations\n      * \n      * @since 2.1\n      */\n-    USE_WRAPPER_NAME_AS_PROPERTY_NAME(false)\n+    USE_WRAPPER_NAME_AS_PROPERTY_NAME(false),\n+\n+    /**\n+     * Feature that may be enabled to enforce strict compatibility with\n+     * Bean name introspection, instead of slightly different mechanism\n+     * Jackson defaults to.\n+     * Specific difference is that Jackson always lower cases leading upper-case\n+     * letters, so \"getURL()\" becomes \"url\" property; whereas standard Bean\n+     * naming <b>only</b> lower-cases the first letter if it is NOT followed by\n+     * another upper-case letter (so \"getURL()\" would result in \"URL\" property).\n+     *<p>\n+     * Feature is disabled by default for backwards compatibility purposes: earlier\n+     * Jackson versions used Jackson's own mechanism.\n+     *\n+     * @since 2.5\n+     */\n+    USE_STD_BEAN_NAMING(false),\n+\n+    /*\n+    /******************************************************\n+    /* Other features\n+    /******************************************************\n+     */\n+\n+    /**\n+     * Feature that determines whether multiple registrations of same module\n+     * should be ignored or not; if enabled, only the first registration call\n+     * results in module being called, and possible duplicate calls are silently\n+     * ignored; if disabled, no checking is done and all registration calls are\n+     * dispatched to module.\n+     *<p>\n+     * Definition of \"same module\" is based on using {@link Module#getTypeId()};\n+     * modules with same non-null <code>type id</code> are considered same for\n+     * purposes of duplicate registration. This also avoids having to keep track\n+     * of actual module instances; only ids will be kept track of (and only if\n+     * this feature is enabled).\n+     *<p>\n+     * Feature is enabled by default.\n+     *\n+     * @since 2.5\n+     */\n+    IGNORE_DUPLICATE_MODULE_REGISTRATIONS(true)\n+    \n     ;\n \n     private final boolean _defaultState;\n+    private final int _mask;\n     \n     private MapperFeature(boolean defaultState) {\n         _defaultState = defaultState;\n+        _mask = (1 << ordinal());\n     }\n     \n     @Override\n     public boolean enabledByDefault() { return _defaultState; }\n \n     @Override\n-    public int getMask() { return (1 << ordinal()); }\n-}\n+    public int getMask() { return _mask; }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n      */\n     @Deprecated\n     protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt,\n-            JsonDeserializer<?> deser)\n-    {\n+            JsonDeserializer<?> deser) {\n         this(type, jp, ctxt, deser, true, null);\n     }\n \n         try {\n             return hasNextValue();\n         } catch (JsonMappingException e) {\n-            throw new RuntimeJsonMappingException(e.getMessage(), e);\n+            return (Boolean) _handleMappingException(e);\n         } catch (IOException e) {\n-            throw new RuntimeException(e.getMessage(), e);\n-        }\n-    }\n-\n+            return (Boolean) _handleIOException(e);\n+        }\n+    }\n+    \n     @Override\n     public T next()\n     {\n     \n     @Override\n     public void close() throws IOException{\n-        if(_parser != null) {\n+        if (_parser != null) {\n             _parser.close();\n         }\n     }\n         // caller should always call 'hasNext[Value]' first; but let's ensure:\n         if (!_hasNextChecked) {\n             if (!hasNextValue()) {\n-                throw new NoSuchElementException();\n+                return _throwNoSuchElement();\n             }\n         }\n         if (_parser == null) {\n-            throw new NoSuchElementException();\n+            return _throwNoSuchElement();\n         }\n         _hasNextChecked = false;\n         T result;\n \n     /**\n      * Convenience method for reading all entries accessible via\n-     * this iterator\n+     * this iterator; resulting container will be a {@link java.util.ArrayList}.\n      * \n      * @return List of entries read\n      * \n      * \n      * @since 2.2\n      */\n-    public List<T> readAll(List<T> resultList) throws IOException\n+    public <L extends List<? super T>> L readAll(L resultList) throws IOException\n     {\n         while (hasNextValue()) {\n-    \t\t    resultList.add(nextValue());\n+            resultList.add(nextValue());\n         }\n         return resultList;\n+    }\n+\n+    /**\n+     * Convenience method for reading all entries accessible via\n+     * this iterator\n+     * \n+     * @since 2.5\n+     */\n+    public <C extends Collection<? super T>> C readAll(C results) throws IOException\n+    {\n+        while (hasNextValue()) {\n+            results.add(nextValue());\n+        }\n+        return results;\n     }\n     \n     /*\n     public JsonLocation getCurrentLocation() {\n         return _parser.getCurrentLocation();\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected <R> R _throwNoSuchElement() {\n+        throw new NoSuchElementException();\n+    }\n+    \n+    protected <R> R _handleMappingException(JsonMappingException e) {\n+        throw new RuntimeJsonMappingException(e.getMessage(), e);\n+    }\n+\n+    protected <R> R _handleIOException(IOException e) {\n+        throw new RuntimeException(e.getMessage(), e);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/Module.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/Module.java\n      */\n     \n     /**\n-     * Method that returns identifier for module; this can be used by Jackson\n+     * Method that returns a display that can be used by Jackson\n      * for informational purposes, as well as in associating extensions with\n      * module that provides them.\n      */\n     @Override\n     public abstract Version version();\n \n+    /**\n+     * Method that returns an id that may be used to determine if two {@link Module}\n+     * instances are considered to be of same type, for purpose of preventing\n+     * multiple registrations of \"same type of\" module\n+     * (see {@link com.fasterxml.jackson.databind.MapperFeature#IGNORE_DUPLICATE_MODULE_REGISTRATIONS})\n+     * If `null` is returned, every instance is considered unique.\n+     * If non-null value is returned, equality of id Objects is used to check whether\n+     * modules should be considered to be \"of same type\"\n+     *<p>\n+     * Default implementation returns value of class name ({@link Class#getName}).\n+     *\n+     * @since 2.5\n+     */\n+    public Object getTypeId() {\n+        return getClass().getName();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle: registration\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     // Quick little shortcut, to avoid having to use global TypeFactory instance...\n     private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n \n-    /* !!! 03-Apr-2009, tatu: Should try to avoid direct reference... but not\n-     *   sure what'd be simple and elegant way. So until then:\n-     */\n-    protected final static ClassIntrospector DEFAULT_INTROSPECTOR = BasicClassIntrospector.instance;\n-\n     // 16-May-2009, tatu: Ditto ^^^\n     protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector();\n \n      * Base settings contain defaults used for all {@link ObjectMapper}\n      * instances.\n      */\n-    protected final static BaseSettings DEFAULT_BASE = new BaseSettings(DEFAULT_INTROSPECTOR,\n-            DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n+    protected final static BaseSettings DEFAULT_BASE = new BaseSettings(\n+            null, // can not share global ClassIntrospector any more (2.5+)\n+            DEFAULT_ANNOTATION_INTROSPECTOR,\n+            STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n             null, StdDateFormat.instance, null,\n             Locale.getDefault(),\n //            TimeZone.getDefault()\n \n     /*\n     /**********************************************************\n+    /* Module-related\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Set of module types (as per {@link Module#getTypeId()} that have been\n+     * registered; kept track of iff {@link MapperFeature#IGNORE_DUPLICATE_MODULE_REGISTRATIONS}\n+     * is enabled, so that duplicate registration calls can be ignored\n+     * (to avoid adding same handlers multiple times, mostly).\n+     * \n+     * @since 2.5\n+     */\n+    protected Set<Object> _registeredModuleTypes;\n+    \n+    /*\n+    /**********************************************************\n     /* Caching\n     /**********************************************************\n      */\n \n     /**\n      * We will use a separate main-level Map for keeping track\n-     * of root-level deserializers. This is where most succesful\n+     * of root-level deserializers. This is where most successful\n      * cache lookups get resolved.\n      * Map will contain resolvers for all kinds of types, including\n      * container types: this is different from the component cache\n      * Java Beans (based on method names and Jackson-specific annotations),\n      * but does not support JAXB annotations.\n      */\n-    public ObjectMapper()\n-    {\n+    public ObjectMapper() {\n         this(null, null, null);\n     }\n \n      * for constructing necessary {@link JsonParser}s and/or\n      * {@link JsonGenerator}s.\n      */\n-    public ObjectMapper(JsonFactory jf)\n-    {\n+    public ObjectMapper(JsonFactory jf) {\n         this(jf, null, null);\n     }\n \n \n         HashMap<ClassKey,Class<?>> mixins = new HashMap<ClassKey,Class<?>>();\n         _mixInAnnotations = mixins;\n-        _serializationConfig = new SerializationConfig(DEFAULT_BASE,\n+\n+        BaseSettings base = DEFAULT_BASE.withClassIntrospector(defaultClassIntrospector());\n+        _serializationConfig = new SerializationConfig(base,\n                     _subtypeResolver, mixins);\n-        _deserializationConfig = new DeserializationConfig(DEFAULT_BASE,\n+        _deserializationConfig = new DeserializationConfig(base,\n                     _subtypeResolver, mixins);\n \n         // Some overrides we may need\n         _serializerFactory = BeanSerializerFactory.instance;\n     }\n \n+    /**\n+     * Overridable helper method used to construct default {@link ClassIntrospector}\n+     * to use.\n+     * \n+     * @since 2.5\n+     */\n+    protected ClassIntrospector defaultClassIntrospector() {\n+        return new BasicClassIntrospector();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Methods sub-classes MUST override\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Method for creating a new {@link ObjectMapper} instance that\n      * has same initial configuration as this instance. Note that this\n      * \n      * @since 2.1\n      */\n-    public ObjectMapper copy()\n-    {\n+    public ObjectMapper copy() {\n         _checkInvalidCopy(ObjectMapper.class);\n         return new ObjectMapper(this);\n     }\n \n     /**\n      * @since 2.1\n-     * @param exp\n      */\n     protected void _checkInvalidCopy(Class<?> exp)\n     {\n                     +\" (version: \"+version()+\") does not override copy(); it has to\");\n         }\n     }\n-    \n+\n+    /*\n+    /**********************************************************\n+    /* Methods sub-classes MUST override if providing custom\n+    /* ObjectReader/ObjectWriter implementations\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectReader}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _newReader(DeserializationConfig config) {\n+        return new ObjectReader(this, config);\n+    }\n+\n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectReader}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _newReader(DeserializationConfig config,\n+            JavaType valueType, Object valueToUpdate,\n+            FormatSchema schema, InjectableValues injectableValues) {\n+        return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues);\n+    }\n+\n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _newWriter(SerializationConfig config) {\n+        return new ObjectWriter(this, config);\n+    }\n+\n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) {\n+        return new ObjectWriter(this, config, schema);\n+    }\n+    \n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _newWriter(SerializationConfig config,\n+            JavaType rootType, PrettyPrinter pp) {\n+        return new ObjectWriter(this, config, rootType, pp);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Versioned impl\n     public Version version() {\n         return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Module registration, discovery\n      */\n     public ObjectMapper registerModule(Module module)\n     {\n+        if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {\n+            Object typeId = module.getTypeId();\n+            if (typeId != null) {\n+                if (_registeredModuleTypes == null) {\n+                    _registeredModuleTypes = new HashSet<Object>();\n+                }\n+                // try adding; if already had it, should skip\n+                if (!_registeredModuleTypes.add(typeId)) {\n+                    return this;\n+                }\n+            }\n+        }\n+        \n         /* Let's ensure we have access to name and version information, \n          * even if we do not have immediate use for either. This way we know\n          * that they will be available from beginning\n             \n             @Override\n             public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n-                mapper.addMixInAnnotations(target, mixinSource);\n+                mapper.addMixIn(target, mixinSource);\n             }\n             \n             @Override\n     /* Configuration: mix-in annotations\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Method to use for defining mix-in annotations to use for augmenting\n      * annotations that processable (serializable / deserializable)\n      * Annotations from source classes (and their supertypes)\n      * will <b>override</b>\n      * annotations that target classes (and their super-types) have.\n-     */\n-    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins)\n     {\n         _mixInAnnotations.clear();\n         if (sourceMixins != null && sourceMixins.size() > 0) {\n                 _mixInAnnotations.put(new ClassKey(en.getKey()), en.getValue());\n             }\n         }\n+        return this;\n     }\n \n     /**\n      * @param target Class (or interface) whose annotations to effectively override\n      * @param mixinSource Class (or interface) whose annotations are to\n      *   be \"added\" to target's annotations, overriding as necessary\n-     */\n-    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)\n     {\n         _mixInAnnotations.put(new ClassKey(target), mixinSource);\n-    }\n-\n-    /**\n-     * Method to use for adding mix-in annotations to use for augmenting\n-     * specified class or interface. All annotations from\n-     * <code>mixinSource</code> are taken to override annotations\n-     * that <code>target</code> (or its supertypes) has.\n-     *\n-     * @param target Class (or interface) whose annotations to effectively override\n-     * @param mixinSource Class (or interface) whose annotations are to\n-     *   be \"added\" to target's annotations, overriding as necessary\n-     */\n-    public final ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)\n-    {\n-        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n-        return this;\n-    }\n-\n-    public final Class<?> findMixInClassFor(Class<?> cls) {\n+        return this;\n+    }\n+\n+    public Class<?> findMixInClassFor(Class<?> cls) {\n         return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n     }\n \n-    public final int mixInCount() {\n+    public int mixInCount() {\n         return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n+    }\n+\n+\n+    /**\n+     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #setMixIns}.\n+     */\n+    @Deprecated\n+    public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) {\n+        setMixIns(sourceMixins);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #addMixIn(Class, Class)}.\n+     */\n+    @Deprecated\n+    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n+        addMixIn(target, mixinSource);\n     }\n     \n     /*\n     }\n \n     /**\n+     * @since 2.5\n+     */\n+    public PropertyNamingStrategy getPropertyNamingStrategy() {\n+        // arbitrary choice but let's do:\n+        return _serializationConfig.getPropertyNamingStrategy();\n+    }\n+    \n+    /**\n      * Method for setting defalt POJO property inclusion strategy for serialization.\n      */\n     public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n      * Method for enabling automatic inclusion of type information, needed\n      * for proper deserialization of polymorphic types (unless types\n      * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).\n+     *<P>\n+     * NOTE: use of <code>JsonTypeInfo.As#EXTERNAL_PROPERTY</code> <b>NOT SUPPORTED</b>;\n+     * and attempts of do so will throw an {@link IllegalArgumentException} to make\n+     * this limitation explicit.\n      * \n      * @param applicability Defines kinds of types for which additional type information\n      *    is added; see {@link DefaultTyping} for more information.\n      */\n     public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)\n     {\n+        /* 18-Sep-2014, tatu: Let's add explicit check to ensure no one tries to\n+         *   use \"As.EXTERNAL_PROPERTY\", since that will not work (with 2.5+)\n+         */\n+        if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n+            throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs);\n+        }\n+        \n         TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n         // we'll always use full class name, when using defaulting\n         typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n     /* Configuration, deserialization\n     /**********************************************************\n      */\n+\n+    /**\n+     * Method that can be used to get hold of {@link JsonNodeFactory}\n+     * that this mapper will use when directly constructing\n+     * root {@link JsonNode} instances for Trees.\n+     *<p>\n+     * Note: this is just a shortcut for calling\n+     *<pre>\n+     *   getDeserializationConfig().getNodeFactory()\n+     *</pre>\n+     */\n+    public JsonNodeFactory getNodeFactory() {\n+        return _deserializationConfig.getNodeFactory();\n+    }\n     \n     /**\n      * Method for specifying {@link JsonNodeFactory} to use for\n      * @since 2.4\n      */\n     public ObjectMapper setConfig(SerializationConfig config) {\n-    \t_serializationConfig = config;\n-    \treturn this;\n+        _serializationConfig = config;\n+        return this;\n     }\n     \n     /*\n     }\n \n     /**\n+     * @since 2.5\n+     */\n+    public DateFormat getDateFormat() {\n+        // arbitrary choice but let's do:\n+        return _serializationConfig.getDateFormat();\n+    }\n+    \n+    /**\n      * Method for configuring {@link HandlerInstantiator} to use for creating\n      * instances of handlers (such as serializers, deserializers, type and type\n      * id resolvers), given a class.\n     \n     /*\n     /**********************************************************\n-    /* Configuration, simple features\n-    /**********************************************************\n-     */\n-\n+    /* Configuration, simple features: MapperFeature\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given {@link MapperFeature} is enabled.\n+     */\n+    public boolean isEnabled(MapperFeature f) {\n+        // ok to use either one, should be kept in sync\n+        return _serializationConfig.isEnabled(f);\n+    }\n+    \n     /**\n      * Method for changing state of an on/off mapper feature for\n      * this mapper instance.\n                 _deserializationConfig.with(f) : _deserializationConfig.without(f);\n         return this;\n     }\n-    \n+\n+    /**\n+     * Method for enabling specified {@link MapperConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper enable(MapperFeature... f) {\n+        _deserializationConfig = _deserializationConfig.with(f);\n+        _serializationConfig = _serializationConfig.with(f);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper disable(MapperFeature... f) {\n+        _deserializationConfig = _deserializationConfig.without(f);\n+        _serializationConfig = _serializationConfig.without(f);\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: SerializationFeature\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given serialization-specific\n+     * feature is enabled.\n+     */\n+    public boolean isEnabled(SerializationFeature f) {\n+        return _serializationConfig.isEnabled(f);\n+    }\n+\n     /**\n      * Method for changing state of an on/off serialization feature for\n      * this object mapper.\n     }\n \n     /**\n+     * Method for enabling specified {@link DeserializationConfig} feature.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper enable(SerializationFeature f) {\n+        _serializationConfig = _serializationConfig.with(f);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper enable(SerializationFeature first,\n+            SerializationFeature... f) {\n+        _serializationConfig = _serializationConfig.with(first, f);\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper disable(SerializationFeature f) {\n+        _serializationConfig = _serializationConfig.without(f);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper disable(SerializationFeature first,\n+            SerializationFeature... f) {\n+        _serializationConfig = _serializationConfig.without(first, f);\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: DeserializationFeature\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given deserialization-specific\n+     * feature is enabled.\n+     */\n+    public boolean isEnabled(DeserializationFeature f) {\n+        return _deserializationConfig.isEnabled(f);\n+    }\n+\n+    /**\n      * Method for changing state of an on/off deserialization feature for\n      * this object mapper.\n      */\n     }\n \n     /**\n-     * Method for changing state of an on/off {@link JsonParser} feature for\n-     * {@link JsonFactory} instance this object mapper uses.\n-     *<p>\n-     * This is method is basically a shortcut method for calling\n-     * {@link JsonFactory#enable} on the shared\n-     * {@link JsonFactory} this mapper uses (which is accessible\n-     * using {@link #getJsonFactory}).\n-     */\n-    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n-        _jsonFactory.configure(f, state);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for changing state of an on/off {@link JsonGenerator} feature for\n-     * {@link JsonFactory} instance this object mapper uses.\n-     *<p>\n-     * This is method is basically a shortcut method for calling\n-     * {@link JsonFactory#enable} on the shared\n-     * {@link JsonFactory} this mapper uses (which is accessible\n-     * using {@link #getJsonFactory}).\n-     */\n-    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n-        _jsonFactory.configure(f, state);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for enabling specified {@link MapperConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper enable(MapperFeature... f) {\n-        _deserializationConfig = _deserializationConfig.with(f);\n-        _serializationConfig = _serializationConfig.with(f);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper disable(MapperFeature... f) {\n-        _deserializationConfig = _deserializationConfig.without(f);\n-        _serializationConfig = _serializationConfig.without(f);\n-        return this;\n-    }\n-    \n-    /**\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n         return this;\n     }\n     \n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} feature.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper enable(SerializationFeature f) {\n-        _serializationConfig = _serializationConfig.with(f);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper enable(SerializationFeature first,\n-            SerializationFeature... f) {\n-        _serializationConfig = _serializationConfig.with(first, f);\n-        return this;\n-    }\n-    \n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper disable(SerializationFeature f) {\n-        _serializationConfig = _serializationConfig.without(f);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper disable(SerializationFeature first,\n-            SerializationFeature... f) {\n-        _serializationConfig = _serializationConfig.without(first, f);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for checking whether given Mapper\n-     * feature is enabled.\n-     */\n-    public boolean isEnabled(MapperFeature f) {\n-        // ok to use either one, should be kept in sync\n-        return _serializationConfig.isEnabled(f);\n-    }\n-\n-    /**\n-     * Method for checking whether given serialization-specific\n-     * feature is enabled.\n-     */\n-    public boolean isEnabled(SerializationFeature f) {\n-        return _serializationConfig.isEnabled(f);\n-    }\n-    \n-    /**\n-     * Method for checking whether given deserialization-specific\n-     * feature is enabled.\n-     */\n-    public boolean isEnabled(DeserializationFeature f) {\n-        return _deserializationConfig.isEnabled(f);\n-    }\n-\n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: JsonParser.Feature\n+    /**********************************************************\n+     */\n+\n+    public boolean isEnabled(JsonParser.Feature f) {\n+        return _deserializationConfig.isEnabled(f, _jsonFactory);\n+    }\n+\n+    /**\n+     * Method for changing state of specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method\n+     * on {@link #getFactory}.\n+     */\n+    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n+        _jsonFactory.configure(f, state);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper enable(JsonParser.Feature... features) {\n+        for (JsonParser.Feature f : features) {\n+            _jsonFactory.enable(f);\n+        }\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for disabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper disable(JsonParser.Feature... features) {\n+        for (JsonParser.Feature f : features) {\n+            _jsonFactory.disable(f);\n+        }\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: JsonGenerator.Feature\n+    /**********************************************************\n+     */\n+\n+    public boolean isEnabled(JsonGenerator.Feature f) {\n+        return _serializationConfig.isEnabled(f, _jsonFactory);\n+    }\n+\n+    /**\n+     * Method for changing state of an on/off {@link JsonGenerator} feature for\n+     * generator instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method\n+     * on {@link #getFactory}.\n+     */\n+    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n+        _jsonFactory.configure(f,  state);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper enable(JsonGenerator.Feature... features) {\n+        for (JsonGenerator.Feature f : features) {\n+            _jsonFactory.enable(f);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for disabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper disable(JsonGenerator.Feature... features) {\n+        for (JsonGenerator.Feature f : features) {\n+            _jsonFactory.disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: JsonFactory.Feature\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Convenience method, equivalent to:\n      *<pre>\n         return _jsonFactory.isEnabled(f);\n     }\n \n-    /**\n-     * Convenience method, equivalent to:\n-     *<pre>\n-     *  getJsonFactory().isEnabled(f);\n-     *</pre>\n-     */\n-    public boolean isEnabled(JsonParser.Feature f) {\n-        return _jsonFactory.isEnabled(f);\n-    }\n-    \n-    /**\n-     * Convenience method, equivalent to:\n-     *<pre>\n-     *  getJsonFactory().isEnabled(f);\n-     *</pre>\n-     */\n-    public boolean isEnabled(JsonGenerator.Feature f) {\n-        return _jsonFactory.isEnabled(f);\n-    }\n-    \n-    /**\n-     * Method that can be used to get hold of {@link JsonNodeFactory}\n-     * that this mapper will use when directly constructing\n-     * root {@link JsonNode} instances for Trees.\n-     *<p>\n-     * Note: this is just a shortcut for calling\n-     *<pre>\n-     *   getDeserializationConfig().getNodeFactory()\n-     *</pre>\n-     */\n-    public JsonNodeFactory getNodeFactory() {\n-        return _deserializationConfig.getNodeFactory();\n-    }\n-\n     /*\n     /**********************************************************\n     /* Public API (from ObjectCodec): deserialization\n      * container ({@link java.util.Collection} or {@link java.util.Map}.\n      * The reason is that due to type erasure, key and value types\n      * can not be introspected when using this method.\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n+     * @throws JsonMappingException if the input JSON structure does not match structure\n+     *   expected for result type (or has other mismatch issues)\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n      * \"super type token\" (see )\n      * and specifically needs to be used if the root type is a \n      * parameterized (generic) container type.\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n+     * @throws JsonMappingException if the input JSON structure does not match structure\n+     *   expected for result type (or has other mismatch issues)\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n      * to which is passed as argument. Type is passed using \n      * Jackson specific type; instance of which can be constructed using\n      * {@link TypeFactory}.\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n+     * @throws JsonMappingException if the input JSON structure does not match structure\n+     *   expected for result type (or has other mismatch issues)\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     }\n \n     /**\n-     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, ResolvedType)}.\n+     * Type-safe overloaded method, basically alias for {@link #readValue(JsonParser, Class)}.\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n+     * @throws JsonMappingException if the input JSON structure does not match structure\n+     *   expected for result type (or has other mismatch issues)\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(JsonParser jp, JavaType valueType)\n      * root of the resulting tree (where root can consist\n      * of just a single node if the current event is a\n      * value event, not container).\n+     * \n+     * @return a {@link JsonNode}, if valid JSON content found; null\n+     *   if input has no content to bind -- note, however, that if\n+     *   JSON <code>null</code> token is found, it will be represented\n+     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n+     *   for {@link JsonNode#isNull()}\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n      */\n     @Override\n     public <T extends TreeNode> T readTree(JsonParser jp)\n      * Returns root of the resulting tree (where root can consist\n      * of just a single node if the current event is a\n      * value event, not container).\n-     *\n+     *<p>\n+     * If a low-level I/O problem (missing input, network error) occurs,\n+     * a {@link IOException} will be thrown.\n+     * If a parsing problem occurs (invalid JSON),\n+     * {@link JsonParseException} will be thrown.\n+     * If no content is found from input (end-of-input), Java\n+     * <code>null</code> will be returned.\n+     * \n      * @param in Input stream used to read JSON content\n      *   for building the JSON tree.\n+     * \n+     * @return a {@link JsonNode}, if valid JSON content found; null\n+     *   if input has no content to bind -- note, however, that if\n+     *   JSON <code>null</code> token is found, it will be represented\n+     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n+     *   for {@link JsonNode#isNull()}\n+     *   \n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n      */\n     public JsonNode readTree(InputStream in)\n         throws IOException, JsonProcessingException\n      * Returns root of the resulting tree (where root can consist\n      * of just a single node if the current event is a\n      * value event, not container).\n+     *<p>\n+     * If a low-level I/O problem (missing input, network error) occurs,\n+     * a {@link IOException} will be thrown.\n+     * If a parsing problem occurs (invalid JSON),\n+     * {@link JsonParseException} will be thrown.\n+     * If no content is found from input (end-of-input), Java\n+     * <code>null</code> will be returned.\n      *\n      * @param r Reader used to read JSON content\n      *   for building the JSON tree.\n+     * \n+     * @return a {@link JsonNode}, if valid JSON content found; null\n+     *   if input has no content to bind -- note, however, that if\n+     *   JSON <code>null</code> token is found, it will be represented\n+     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n+     *   for {@link JsonNode#isNull()}\n      */\n     public JsonNode readTree(Reader r)\n         throws IOException, JsonProcessingException\n     {\n         JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(r), JSON_NODE_TYPE);\n+        return (n == null) ? NullNode.instance : n;\n+    }\n+\n+    /**\n+     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n+     * Returns root of the resulting tree (where root can consist of just a single node if the current\n+     * event is a value event, not container).\n+     *<p>\n+     * If a low-level I/O problem (missing input, network error) occurs,\n+     * a {@link IOException} will be thrown.\n+     * If a parsing problem occurs (invalid JSON),\n+     * {@link JsonParseException} will be thrown.\n+     * If no content is found from input (end-of-input), Java\n+     * <code>null</code> will be returned.\n+     *\n+     * @param content JSON content to parse to build the JSON tree.\n+     * \n+     * @return a {@link JsonNode}, if valid JSON content found; null\n+     *   if input has no content to bind -- note, however, that if\n+     *   JSON <code>null</code> token is found, it will be represented\n+     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n+     *   for {@link JsonNode#isNull()}\n+     *\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n+     */\n+    public JsonNode readTree(String content)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n         return (n == null) ? NullNode.instance : n;\n     }\n \n      * event is a value event, not container).\n      *\n      * @param content JSON content to parse to build the JSON tree.\n-     */\n-    public JsonNode readTree(String content)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createParser(content), JSON_NODE_TYPE);\n-        return (n == null) ? NullNode.instance : n;\n-    }\n-\n-    /**\n-     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n-     * Returns root of the resulting tree (where root can consist of just a single node if the current\n-     * event is a value event, not container).\n+     * \n+     * @return a {@link JsonNode}, if valid JSON content found; null\n+     *   if input has no content to bind -- note, however, that if\n+     *   JSON <code>null</code> token is found, it will be represented\n+     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n+     *   for {@link JsonNode#isNull()}\n      *\n-     * @param content JSON content to parse to build the JSON tree.\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n      */\n     public JsonNode readTree(byte[] content)\n         throws IOException, JsonProcessingException\n      * event is a value event, not container).\n      *\n      * @param file File of which contents to parse as JSON for building a tree instance\n+     * \n+     * @return a {@link JsonNode}, if valid JSON content found; null\n+     *   if input has no content to bind -- note, however, that if\n+     *   JSON <code>null</code> token is found, it will be represented\n+     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n+     *   for {@link JsonNode#isNull()}\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n      */\n     public JsonNode readTree(File file)\n         throws IOException, JsonProcessingException\n      * event is a value event, not container).\n      *\n      * @param source URL to use for fetching contents to parse as JSON for building a tree instance\n+     * \n+     * @return a {@link JsonNode}, if valid JSON content found; null\n+     *   if input has no content to bind -- note, however, that if\n+     *   JSON <code>null</code> token is found, it will be represented\n+     *   as a non-null {@link JsonNode} (one that returns <code>true</code>\n+     *   for {@link JsonNode#isNull()}\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n      */\n     public JsonNode readTree(URL source)\n         throws IOException, JsonProcessingException\n      * @param n Root node of the tree that resulting parser will read from\n      */\n     @Override\n-    public JsonParser treeAsTokens(TreeNode n)\n-    {\n+    public JsonParser treeAsTokens(TreeNode n) {\n         return new TreeTraversingParser((JsonNode) n, this);\n     }\n \n      *<p>\n      * NOTE: since this method does NOT throw exceptions, but internal\n      * processing may, caller usually has little information as to why\n-     * serialization would fail.\n+     * serialization would fail. If you want access to internal {@link Exception},\n+     * call {@link #canSerialize(Class, AtomicReference)} instead.\n      *\n      * @return True if mapper can find a serializer for instances of\n      *  given class (potentially serializable), false otherwise (not\n     /**\n      * Method that can be called to check whether mapper thinks\n      * it could deserialize an Object of given type.\n-     * Check is done\n-     * by checking whether a deserializer can be found for the type.\n+     * Check is done by checking whether a registered deserializer can\n+     * be found or built for the type; if not (either by no mapping being\n+     * found, or through an <code>Exception</code> being thrown, false\n+     * is returned.\n+     *<p>\n+     * <b>NOTE</b>: in case an exception is thrown during course of trying\n+     * co construct matching deserializer, it will be effectively swallowed.\n+     * If you want access to that exception, call\n+     * {@link #canDeserialize(JavaType, AtomicReference)} instead.\n      *\n      * @return True if mapper can find a serializer for instances of\n      *  given class (potentially serializable), false otherwise (not\n     /**********************************************************\n      */\n \n+    /**\n+     * Method to deserialize JSON content from given file into given Java type.\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n+     * @throws JsonMappingException if the input JSON structure does not match structure\n+     *   expected for result type (or has other mismatch issues)\n+     */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(File src, Class<T> valueType)\n         throws IOException, JsonParseException, JsonMappingException\n         return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n     } \n \n+    /**\n+     * Method to deserialize JSON content from given file into given Java type.\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n+     * @throws JsonMappingException if the input JSON structure does not match structure\n+     *   expected for result type (or has other mismatch issues)\n+     */\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     public <T> T readValue(File src, TypeReference valueTypeRef)\n         throws IOException, JsonParseException, JsonMappingException\n         return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueTypeRef));\n     } \n \n+    /**\n+     * Method to deserialize JSON content from given file into given Java type.\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n+     * @throws JsonMappingException if the input JSON structure does not match structure\n+     *   expected for result type (or has other mismatch issues)\n+     */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(File src, JavaType valueType)\n         throws IOException, JsonParseException, JsonMappingException\n     {\n         return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n-    } \n-\n+    }\n+\n+    /**\n+     * Method to deserialize JSON content from given resource into given Java type.\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n+     * @throws JsonMappingException if the input JSON structure does not match structure\n+     *   expected for result type (or has other mismatch issues)\n+     */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(URL src, Class<T> valueType)\n         throws IOException, JsonParseException, JsonMappingException\n         return (T) _readMapAndClose(_jsonFactory.createParser(src), _typeFactory.constructType(valueType));\n     } \n \n+    /**\n+     * Method to deserialize JSON content from given resource into given Java type.\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n+     * @throws JsonMappingException if the input JSON structure does not match structure\n+     *   expected for result type (or has other mismatch issues)\n+     */\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     public <T> T readValue(URL src, TypeReference valueTypeRef)\n         throws IOException, JsonParseException, JsonMappingException\n         return (T) _readMapAndClose(_jsonFactory.createParser(src), valueType);\n     } \n \n+    /**\n+     * Method to deserialize JSON content from given JSON content String.\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n+     * @throws JsonMappingException if the input JSON structure does not match structure\n+     *   expected for result type (or has other mismatch issues)\n+     */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(String content, Class<T> valueType)\n         throws IOException, JsonParseException, JsonMappingException\n         return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueType));\n     } \n \n+    /**\n+     * Method to deserialize JSON content from given JSON content String.\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n+     * @throws JsonMappingException if the input JSON structure does not match structure\n+     *   expected for result type (or has other mismatch issues)\n+     */\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     public <T> T readValue(String content, TypeReference valueTypeRef)\n         throws IOException, JsonParseException, JsonMappingException\n         return (T) _readMapAndClose(_jsonFactory.createParser(content), _typeFactory.constructType(valueTypeRef));\n     } \n \n+    /**\n+     * Method to deserialize JSON content from given JSON content String.\n+     * \n+     * @throws IOException if a low-level I/O problem (unexpected end-of-input,\n+     *   network error) occurs (passed through as-is without additional wrapping -- note\n+     *   that this is one case where {@link DeserializationFeature#WRAP_EXCEPTIONS}\n+     *   does NOT result in wrapping of exception even if enabled)\n+     * @throws JsonParseException if underlying input contains invalid content\n+     *    of type {@link JsonParser} supports (JSON for default case)\n+     * @throws JsonMappingException if the input JSON structure does not match structure\n+     *   expected for result type (or has other mismatch issues)\n+     */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(String content, JavaType valueType)\n         throws IOException, JsonParseException, JsonMappingException\n      * Convenience method for constructing {@link ObjectWriter}\n      * with default settings.\n      */\n-    public ObjectWriter writer() {\n-        return new ObjectWriter(this, getSerializationConfig());\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer() {\n+        return (W) _newWriter(getSerializationConfig());\n     }\n \n     /**\n      * specified feature enabled (compared to settings that this\n      * mapper instance has).\n      */\n-    public ObjectWriter writer(SerializationFeature feature) {\n-        return new ObjectWriter(this, getSerializationConfig().with(feature));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(SerializationFeature feature) {\n+        return (W) _newWriter(getSerializationConfig().with(feature));\n     }\n \n     /**\n      * specified features enabled (compared to settings that this\n      * mapper instance has).\n      */\n-    public ObjectWriter writer(SerializationFeature first,\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(SerializationFeature first,\n             SerializationFeature... other) {\n-        return new ObjectWriter(this, getSerializationConfig().with(first, other));\n+        return (W) _newWriter(getSerializationConfig().with(first, other));\n     }\n     \n     /**\n      * serialize objects using specified {@link DateFormat}; or, if\n      * null passed, using timestamp (64-bit number.\n      */\n-    public ObjectWriter writer(DateFormat df) {\n-        return new ObjectWriter(this, getSerializationConfig().with(df));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(DateFormat df) {\n+        return (W) _newWriter(getSerializationConfig().with(df));\n     }\n     \n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified JSON View (filter).\n      */\n-    public ObjectWriter writerWithView(Class<?> serializationView) {\n-        return new ObjectWriter(this, getSerializationConfig().withView(serializationView));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerWithView(Class<?> serializationView) {\n+        return (W) _newWriter(getSerializationConfig().withView(serializationView));\n     }\n     \n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified root type, instead of actual\n-     * runtime type of value. Type must be a super-type of runtime\n-     * type.\n-     */\n-    public ObjectWriter writerWithType(Class<?> rootType) {\n-        return new ObjectWriter(this, getSerializationConfig(),\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     *<p>\n+     * Main reason for using this method is performance, as writer is able\n+     * to pre-fetch serializer to use before write, and if writer is used\n+     * more than once this avoids addition per-value serializer lookups.\n+     * \n+     * @since 2.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerFor(Class<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n+                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n+                /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified root type, instead of actual\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     *<p>\n+     * Main reason for using this method is performance, as writer is able\n+     * to pre-fetch serializer to use before write, and if writer is used\n+     * more than once this avoids addition per-value serializer lookups.\n+     * \n+     * @since 2.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerFor(TypeReference<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n+                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n+                /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified root type, instead of actual\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     *<p>\n+     * Main reason for using this method is performance, as writer is able\n+     * to pre-fetch serializer to use before write, and if writer is used\n+     * more than once this avoids addition per-value serializer lookups.\n+     * \n+     * @since 2.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerFor(JavaType rootType) {\n+        return (W) _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5, use {@link #writerFor(Class)} instead\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n+    public <W extends ObjectWriter> W writerWithType(Class<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                 ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                 /*PrettyPrinter*/null);\n     }\n \n     /**\n-     * Factory method for constructing {@link ObjectWriter} that will\n-     * serialize objects using specified root type, instead of actual\n-     * runtime type of value. Type must be a super-type of runtime type.\n-     */\n-    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n-        return new ObjectWriter(this, getSerializationConfig(),\n+     * @deprecated Since 2.5, use {@link #writerFor(TypeReference)} instead\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n+    public <W extends ObjectWriter> W writerWithType(TypeReference<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                 ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                 /*PrettyPrinter*/null);\n     }\n \n     /**\n-     * Factory method for constructing {@link ObjectWriter} that will\n-     * serialize objects using specified root type, instead of actual\n-     * runtime type of value. Type must be a super-type of runtime type.\n-     */\n-    public ObjectWriter writerWithType(JavaType rootType) {\n-        return new ObjectWriter(this, getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n+     * @deprecated Since 2.5, use {@link #writerFor(JavaType)} instead\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n+    public <W extends ObjectWriter> W writerWithType(JavaType rootType) {\n+        return (W) _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n     }\n     \n     /**\n      * serialize objects using specified pretty printer for indentation\n      * (or if null, no pretty printer)\n      */\n-    public ObjectWriter writer(PrettyPrinter pp) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(PrettyPrinter pp) {\n         if (pp == null) { // need to use a marker to indicate explicit disabling of pp\n             pp = ObjectWriter.NULL_PRETTY_PRINTER;\n         }\n-        return new ObjectWriter(this, getSerializationConfig(), /*root type*/ null, pp);\n+        return (W) _newWriter(getSerializationConfig(), /*root type*/ null, pp);\n     }\n     \n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using the default pretty printer for indentation\n      */\n-    public ObjectWriter writerWithDefaultPrettyPrinter() {\n-        return new ObjectWriter(this, getSerializationConfig(),\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerWithDefaultPrettyPrinter() {\n+        return (W) _newWriter(getSerializationConfig(),\n                 /*root type*/ null, _defaultPrettyPrinter());\n     }\n     \n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified filter provider.\n      */\n-    public ObjectWriter writer(FilterProvider filterProvider) {\n-        return new ObjectWriter(this,\n-                getSerializationConfig().withFilters(filterProvider));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(FilterProvider filterProvider) {\n+        return (W) _newWriter(getSerializationConfig().withFilters(filterProvider));\n     }\n     \n     /**\n      * \n      * @param schema Schema to pass to generator\n      */\n-    public ObjectWriter writer(FormatSchema schema) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(FormatSchema schema) {\n         _verifySchemaType(schema);\n-        return new ObjectWriter(this, getSerializationConfig(), schema);\n+        return (W) _newWriter(getSerializationConfig(), schema);\n     }\n \n     /**\n      * \n      * @since 2.1\n      */\n-    public ObjectWriter writer(Base64Variant defaultBase64) {\n-        return new ObjectWriter(this, getSerializationConfig().with(defaultBase64));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(Base64Variant defaultBase64) {\n+        return (W) _newWriter(getSerializationConfig().with(defaultBase64));\n     }\n \n     /**\n      * \n      * @since 2.3\n      */\n-    public ObjectWriter writer(CharacterEscapes escapes) {\n-        return writer().with(escapes);\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(CharacterEscapes escapes) {\n+        return (W) _newWriter(getSerializationConfig()).with(escapes);\n     }\n \n     /**\n      * \n      * @since 2.3\n      */\n-    public ObjectWriter writer(ContextAttributes attrs) {\n-        return new ObjectWriter(this, getSerializationConfig().with(attrs));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(ContextAttributes attrs) {\n+        return (W) _newWriter(getSerializationConfig().with(attrs));\n     }\n     \n     /*\n      * default settings. Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader() {\n-        return new ObjectReader(this, getDeserializationConfig())\n-            .with(_injectableValues);\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader() {\n+        return (T) _newReader(getDeserializationConfig()).with(_injectableValues);\n     }\n \n     /**\n      * Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader(DeserializationFeature feature) {\n-        return new ObjectReader(this, getDeserializationConfig().with(feature));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(DeserializationFeature feature) {\n+        return (T) _newReader(getDeserializationConfig().with(feature));\n     }\n \n     /**\n      * Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader(DeserializationFeature first,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(DeserializationFeature first,\n             DeserializationFeature... other) {\n-        return new ObjectReader(this, getDeserializationConfig().with(first, other));\n+        return (T) _newReader(getDeserializationConfig().with(first, other));\n     }\n     \n     /**\n      * Runtime type of value object is used for locating deserializer,\n      * unless overridden by other factory methods of {@link ObjectReader}\n      */\n-    public ObjectReader readerForUpdating(Object valueToUpdate)\n-    {\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T readerForUpdating(Object valueToUpdate) {\n         JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n-        return new ObjectReader(this, getDeserializationConfig(), t, valueToUpdate,\n+        return (T) _newReader(getDeserializationConfig(), t, valueToUpdate,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(JavaType type)\n-    {\n-        return new ObjectReader(this, getDeserializationConfig(), type, null,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(JavaType type) {\n+        return (T) _newReader(getDeserializationConfig(), type, null,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(Class<?> type)\n-    {\n-        return reader(_typeFactory.constructType(type));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(Class<?> type) {\n+        return (T) _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n+                null, _injectableValues);\n     }\n \n     /**\n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(TypeReference<?> type)\n-    {\n-        return reader(_typeFactory.constructType(type));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(TypeReference<?> type) {\n+        return (T)_newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n+                null, _injectableValues);\n     }\n \n     /**\n      * Factory method for constructing {@link ObjectReader} that will\n      * use specified {@link JsonNodeFactory} for constructing JSON trees.\n      */\n-    public ObjectReader reader(JsonNodeFactory f)\n-    {\n-        return new ObjectReader(this, getDeserializationConfig()).with(f);\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(JsonNodeFactory f) {\n+        return (T) _newReader(getDeserializationConfig()).with(f);\n     }\n \n     /**\n      * \n      * @param schema Schema to pass to parser\n      */\n-    public ObjectReader reader(FormatSchema schema) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(FormatSchema schema) {\n         _verifySchemaType(schema);\n-        return new ObjectReader(this, getDeserializationConfig(), null, null,\n+        return (T)_newReader(getDeserializationConfig(), null, null,\n                 schema, _injectableValues);\n     }\n \n      * \n      * @param injectableValues Injectable values to use\n      */\n-    public ObjectReader reader(InjectableValues injectableValues) {\n-        return new ObjectReader(this, getDeserializationConfig(), null, null,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(InjectableValues injectableValues) {\n+        return (T)_newReader(getDeserializationConfig(), null, null,\n                 null, injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * deserialize objects using specified JSON View (filter).\n      */\n-    public ObjectReader readerWithView(Class<?> view) {\n-        return new ObjectReader(this, getDeserializationConfig().withView(view));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T readerWithView(Class<?> view) {\n+        return (T) _newReader(getDeserializationConfig().withView(view));\n     }\n \n     /**\n      * \n      * @since 2.1\n      */\n-    public ObjectReader reader(Base64Variant defaultBase64) {\n-        return new ObjectReader(this, getDeserializationConfig().with(defaultBase64));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(Base64Variant defaultBase64) {\n+        return (T) _newReader(getDeserializationConfig().with(defaultBase64));\n     }\n \n     /**\n      * \n      * @since 2.3\n      */\n-    public ObjectReader reader(ContextAttributes attrs) {\n-        return new ObjectReader(this, getDeserializationConfig().with(attrs));\n-    }\n-    \n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(ContextAttributes attrs) {\n+        return (T) _newReader(getDeserializationConfig().with(attrs));\n+    }\n+\n     /*\n     /**********************************************************\n     /* Extended Public API: convenience type conversion\n     /**********************************************************\n      */\n-   \n+\n     /**\n      * Convenience method for doing two-step conversion from given value, into\n      * instance of given value type. This is functionality equivalent to first\n      * call write functionality\n      */\n     protected final void _configAndWriteValue(JsonGenerator jgen, Object value)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+        throws IOException\n     {\n         SerializationConfig cfg = getSerializationConfig();\n-        // [JACKSON-96]: allow enabling pretty printing for ObjectMapper directly\n-        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n-            jgen.useDefaultPrettyPrinter();\n-        }\n-        // [Issue#232]\n-        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n-            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n-        }\n-        // [JACKSON-282]: consider Closeable\n+        cfg.initialize(jgen); // since 2.5\n         if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _configAndWriteCloseable(jgen, value, cfg);\n             return;\n     }\n \n     protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+        throws IOException\n     {\n         SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n-        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n-            jgen.useDefaultPrettyPrinter();\n-        }\n-        // [Issue#232]\n-        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n-            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n-        }\n+        cfg.initialize(jgen); // since 2.5\n \n         // [JACKSON-282]: consider Closeable\n         if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             }\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Internal methods for deserialization, overridable\n      * Can be overridden if a custom context is needed.\n      */\n     protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n-            DeserializationConfig cfg)\n-    {\n-        return _deserializationContext.createInstance(cfg,\n-                jp, _injectableValues);\n+            DeserializationConfig cfg) {\n+        return _deserializationContext.createInstance(cfg, jp, _injectableValues);\n     }\n     \n     /**\n      *   content to map (note: Json \"null\" value is considered content;\n      *   enf-of-stream not)\n      */\n-    protected JsonToken _initForReading(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n+    protected JsonToken _initForReading(JsonParser p) throws IOException\n+    {\n+        _deserializationConfig.initialize(p); // since 2.5\n+\n         /* First: must point to a token; if not pointing to one, advance.\n          * This occurs before first read from JsonParser, as well as\n          * after clearing of current token.\n          */\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n         if (t == null) {\n             // and then we must get something...\n-            t = jp.nextToken();\n+            t = p.nextToken();\n             if (t == null) {\n                 /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n                  *   not an actual parsing problem\n                  */\n-                throw JsonMappingException.from(jp, \"No content to map due to end-of-input\");\n+                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n             }\n         }\n         return t;\n     }\n \n-    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, \n+    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, \n             DeserializationConfig config,\n             JavaType rootType, JsonDeserializer<Object> deser)\n-        throws IOException, JsonParseException, JsonMappingException\n+        throws IOException\n     {\n         String expName = config.getRootName();\n         if (expName == null) {\n             PropertyName pname = _rootNames.findRootName(rootType, config);\n             expName = pname.getSimpleName();\n         }\n-        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n-            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        String actualName = jp.getCurrentName();\n+        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n+            throw JsonMappingException.from(p, \"Current token not START_OBJECT (needed to unwrap root name '\"\n+                    +expName+\"'), but \"+p.getCurrentToken());\n+        }\n+        if (p.nextToken() != JsonToken.FIELD_NAME) {\n+            throw JsonMappingException.from(p, \"Current token not FIELD_NAME (to contain expected root name '\"\n+                    +expName+\"'), but \"+p.getCurrentToken());\n+        }\n+        String actualName = p.getCurrentName();\n         if (!expName.equals(actualName)) {\n-            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n+            throw JsonMappingException.from(p, \"Root name '\"+actualName+\"' does not match expected ('\"\n                     +expName+\"') for type \"+rootType);\n         }\n         // ok, then move to value itself....\n-        jp.nextToken();\n-        Object result = deser.deserialize(jp, ctxt);\n+        p.nextToken();\n+        Object result = deser.deserialize(p, ctxt);\n         // and last, verify that we now get matching END_OBJECT\n-        if (jp.nextToken() != JsonToken.END_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n+        if (p.nextToken() != JsonToken.END_OBJECT) {\n+            throw JsonMappingException.from(p, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n+                    +expName+\"'), but \"+p.getCurrentToken());\n         }\n         return result;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n     extends ObjectCodec\n     implements Versioned, java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = -4251443320039569153L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n \n     /**\n      * Constructor used by {@link ObjectMapper} for initial instantiation\n      */\n-    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config)\n-    {\n+    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) {\n         this(mapper, config, null, null, null, null);\n     }\n \n         _unwrapRoot = config.useRootWrapping();\n         _dataFormatReaders = base._dataFormatReaders;\n     }\n-\n+    \n     protected ObjectReader(ObjectReader base, JsonFactory f)\n     {\n         // may need to override ordering, based on data format capabilities\n \n     /*\n     /**********************************************************\n-    /* Life-cycle, fluent factory methods\n+    /* Methods sub-classes MUST override, used for constructing\n+    /* reader instances, (re)configuring parser instances\n+    /* Added in 2.5\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _new(ObjectReader base, JsonFactory f) {\n+        return new ObjectReader(base, f);\n+    }\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _new(ObjectReader base, DeserializationConfig config) {\n+        return new ObjectReader(base, config);\n+    }\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _new(ObjectReader base, DeserializationConfig config,\n+            JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n+            FormatSchema schema, InjectableValues injectableValues,\n+            DataFormatReaders dataFormatReaders) {\n+        return new ObjectReader(base, config, valueType, rootDeser,  valueToUpdate,\n+                 schema,  injectableValues, dataFormatReaders);\n+    }\n+\n+    /**\n+     * Factory method used to create {@link MappingIterator} instances;\n+     * either default, or custom subtype.\n+     * \n+     * @since 2.5\n+     */\n+    protected <T> MappingIterator<T> _newIterator(JavaType valueType,\n+            JsonParser parser, DeserializationContext ctxt,\n+            JsonDeserializer<?> deser, boolean parserManaged, Object valueToUpdate)\n+    {\n+            return new MappingIterator<T>(valueType, parser, ctxt,\n+                    deser, parserManaged, valueToUpdate);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Methods sub-classes may choose to override, if customized\n+    /* initialization is needed.\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * NOTE: changed from static to non-static in 2.5; unfortunate but\n+     * necessary change to support overridability\n+     */\n+    protected JsonToken _initForReading(JsonParser p) throws IOException\n+    {\n+        if (_schema != null) {\n+            p.setSchema(_schema);\n+        }\n+        _config.initialize(p); // since 2.5\n+\n+        /* First: must point to a token; if not pointing to one, advance.\n+         * This occurs before first read from JsonParser, as well as\n+         * after clearing of current token.\n+         */\n+        JsonToken t = p.getCurrentToken();\n+        if (t == null) { // and then we must get something...\n+            t = p.nextToken();\n+            if (t == null) {\n+                // Throw mapping exception, since it's failure to map, not an actual parsing problem\n+                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    /**\n+     * Alternative to {@link #_initForReading(JsonParser)} used in cases where reading\n+     * of multiple values means that we may or may not want to advance the stream,\n+     * but need to do other initialization.\n+     *<p>\n+     * Base implementation only sets configured {@link FormatSchema}, if any, on parser.\n+     * \n+     * @since 2.5\n+     */\n+    protected void _initForMultiRead(JsonParser p) throws IOException {\n+        if (_schema != null) {\n+            p.setSchema(_schema);\n+        }\n+        _config.initialize(p); // since 2.5\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factory methods for DeserializationFeatures\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified feature enabled.\n+     */\n+    public ObjectReader with(DeserializationFeature feature) {\n+        return _with(_config.with(feature));\n+    }\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features enabled.\n+     */\n+    public ObjectReader with(DeserializationFeature first,\n+            DeserializationFeature... other)\n+    {\n+        return _with(_config.with(first, other));\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features enabled.\n+     */\n+    public ObjectReader withFeatures(DeserializationFeature... features) {\n+        return _with(_config.withFeatures(features));\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified feature disabled.\n+     */\n+    public ObjectReader without(DeserializationFeature feature) {\n+        return _with(_config.without(feature)); \n+    }\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features disabled.\n+     */\n+    public ObjectReader without(DeserializationFeature first,\n+            DeserializationFeature... other) {\n+        return _with(_config.without(first, other));\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features disabled.\n+     */\n+    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n+        return _with(_config.withoutFeatures(features));\n+    }    \n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factory methods for JsonParser.Features\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified feature enabled.\n+     */\n+    public ObjectReader with(JsonParser.Feature feature) {\n+        return _with(_config.with(feature));\n+    }\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features enabled.\n+     */\n+    public ObjectReader withFeatures(JsonParser.Feature... features) {\n+        return _with(_config.withFeatures(features));\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified feature disabled.\n+     */\n+    public ObjectReader without(JsonParser.Feature feature) {\n+        return _with(_config.without(feature)); \n+    }\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features disabled.\n+     */\n+    public ObjectReader withoutFeatures(JsonParser.Feature... features) {\n+        return _with(_config.withoutFeatures(features));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factory methods, other\n     /**********************************************************\n      */\n \n     public ObjectReader with(DeserializationConfig config) {\n         return _with(config);\n     }    \n-    \n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * with specified feature enabled.\n-     */\n-    public ObjectReader with(DeserializationFeature feature) {\n-        return _with(_config.with(feature));\n-    }    \n-\n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * with specified features enabled.\n-     */\n-    public ObjectReader with(DeserializationFeature first,\n-            DeserializationFeature... other)\n-    {\n-        return _with(_config.with(first, other));\n-    }    \n-\n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * with specified features enabled.\n-     */\n-    public ObjectReader withFeatures(DeserializationFeature... features) {\n-        return _with(_config.withFeatures(features));\n-    }    \n-    \n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * with specified feature disabled.\n-     */\n-    public ObjectReader without(DeserializationFeature feature) {\n-        return _with(_config.without(feature)); \n-    }    \n-\n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * with specified features disabled.\n-     */\n-    public ObjectReader without(DeserializationFeature first,\n-            DeserializationFeature... other)\n-    {\n-        return _with(_config.without(first, other));\n-    }    \n-\n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * with specified features disabled.\n-     */\n-    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n-        return _with(_config.withoutFeatures(features));\n-    }    \n-    \n+\n     /**\n      * Method for constructing a new instance with configuration that uses\n      * passed {@link InjectableValues} to provide injectable values.\n         if (_injectableValues == injectableValues) {\n             return this;\n         }\n-        return new ObjectReader(this, _config,\n+        return _new(this, _config,\n                 _valueType, _rootDeserializer, _valueToUpdate,\n                 _schema, injectableValues, _dataFormatReaders);\n     }\n         if (f == _parserFactory) {\n             return this;\n         }\n-        ObjectReader r = new ObjectReader(this, f);\n+        ObjectReader r = _new(this, f);\n         // Also, try re-linking, if possible...\n         if (f.getCodec() == null) {\n             f.setCodec(r);\n             return this;\n         }\n         _verifySchemaType(schema);\n-        return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n+        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                 schema, _injectableValues, _dataFormatReaders);\n     }\n \n      *<p>\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n-     */\n-    public ObjectReader withType(JavaType valueType)\n+     * \n+     * @since 2.5\n+     */\n+    public ObjectReader forType(JavaType valueType)\n     {\n         if (valueType != null && valueType.equals(_valueType)) {\n             return this;\n         if (det != null) {\n             det = det.withType(valueType);\n         }\n-        return new ObjectReader(this, _config, valueType, rootDeser,\n+        return _new(this, _config, valueType, rootDeser,\n                 _valueToUpdate, _schema, _injectableValues, det);\n     }    \n \n      *<p>\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n-     */\n-    public ObjectReader withType(Class<?> valueType) {\n-        return withType(_config.constructType(valueType));\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectReader forType(Class<?> valueType) {\n+        return forType(_config.constructType(valueType));\n     }    \n \n     /**\n      *<p>\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n-     */\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectReader forType(TypeReference<?> valueTypeRef) {\n+        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n+    }    \n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(JavaType)} instead\n+     */\n+    @Deprecated\n+    public ObjectReader withType(JavaType valueType) {\n+        return forType(valueType);\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n+     */\n+    @Deprecated\n+    public ObjectReader withType(Class<?> valueType) {\n+        return forType(_config.constructType(valueType));\n+    }    \n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n+     */\n+    @Deprecated\n     public ObjectReader withType(java.lang.reflect.Type valueType) {\n-        return withType(_config.getTypeFactory().constructType(valueType));\n-    }    \n-\n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * to data bind into specified type.\n-     *<p>\n-     * Note that the method does NOT change state of this reader, but\n-     * rather construct and returns a newly configured instance.\n-     */\n+        return forType(_config.getTypeFactory().constructType(valueType));\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(TypeReference)} instead\n+     */\n+    @Deprecated\n     public ObjectReader withType(TypeReference<?> valueTypeRef) {\n-        return withType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n+        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n     }    \n \n     /**\n         } else {\n             t = _valueType;\n         }\n-        return new ObjectReader(this, _config, t, _rootDeserializer, value,\n+        return _new(this, _config, t, _rootDeserializer, value,\n                 _schema, _injectableValues, _dataFormatReaders);\n     }\n \n      * \n      * @since 2.1\n      */\n-    public ObjectReader withFormatDetection(ObjectReader... readers)\n-    {\n+    public ObjectReader withFormatDetection(ObjectReader... readers) {\n         return withFormatDetection(new DataFormatReaders(readers));\n     }\n \n      * \n      * @since 2.1\n      */\n-    public ObjectReader withFormatDetection(DataFormatReaders readers)\n-    {\n-        return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n+    public ObjectReader withFormatDetection(DataFormatReaders readers) {\n+        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                 _schema, _injectableValues, readers);\n     }\n \n      * @since 2.3\n      */\n     public ObjectReader with(ContextAttributes attrs) {\n-        DeserializationConfig newConfig = _config.with(attrs);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.with(attrs));\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectReader withAttributes(Map<Object,Object> attrs) {\n-        DeserializationConfig newConfig = _config.withAttributes(attrs);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.withAttributes(attrs));\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectReader withAttribute(Object key, Object value) {\n-        DeserializationConfig newConfig = _config.withAttribute(key, value);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with( _config.withAttribute(key, value));\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectReader withoutAttribute(Object key) {\n-        DeserializationConfig newConfig = _config.withoutAttribute(key);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.withoutAttribute(key));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable factory methods may override\n+    /**********************************************************\n+     */\n+    \n+    protected ObjectReader _with(DeserializationConfig newConfig) {\n+        if (newConfig == _config) {\n+            return this;\n+        }\n+        ObjectReader r = _new(this, newConfig);\n+        if (_dataFormatReaders != null) {\n+            r  = r.withFormatDetection(_dataFormatReaders.with(newConfig));\n+        }\n+        return r;\n     }\n     \n     /*\n     public JsonParser treeAsTokens(TreeNode n) {\n         return new TreeTraversingParser((JsonNode) n, this);\n     }\n-     /**\n-      * Convenience method that binds content read using given parser, using\n-      * configuration of this reader, except that content is bound as\n-      * JSON tree instead of configured root value type.\n-      *<p>\n-      * Note: if an object was specified with {@link #withValueToUpdate}, it\n-      * will be ignored.\n-      *<p>\n-      * NOTE: this method never tries to auto-detect format, since actual\n-      * (data-format specific) parser is given.\n-      */\n-     @SuppressWarnings(\"unchecked\")\n-     @Override\n-     public <T extends TreeNode> T readTree(JsonParser jp)\n-         throws IOException, JsonProcessingException\n-     {\n-         return (T) _bindAsTree(jp);\n-     }\n+\n+    /**\n+     * Convenience method that binds content read using given parser, using\n+     * configuration of this reader, except that content is bound as\n+     * JSON tree instead of configured root value type.\n+     *<p>\n+     * Note: if an object was specified with {@link #withValueToUpdate}, it\n+     * will be ignored.\n+     *<p>\n+     * NOTE: this method never tries to auto-detect format, since actual\n+     * (data-format specific) parser is given.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends TreeNode> T readTree(JsonParser jp)\n+            throws IOException, JsonProcessingException\n+    {\n+        return (T) _bindAsTree(jp);\n+    }\n      \n     @Override\n     public void writeTree(JsonGenerator jgen, TreeNode rootNode) {\n     {\n         DeserializationContext ctxt = createDeserializationContext(jp, _config);\n         // false -> do not close as caller gave parser instance\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n+        return _newIterator(_valueType, jp, ctxt,\n                 _findRootDeserializer(ctxt, _valueType),\n                 false, _valueToUpdate);\n     }\n         if (_dataFormatReaders != null) {\n             _reportUndetectableSource(src);\n         }\n-        JsonParser jp = _parserFactory.createParser(src);\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        jp.nextToken();\n-        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n+        JsonParser p = _parserFactory.createParser(src);\n+        _initForMultiRead(p);\n+        p.nextToken();\n+        DeserializationContext ctxt = createDeserializationContext(p, _config);\n+        return _newIterator(_valueType, p, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n     \n         if (_dataFormatReaders != null) {\n             _reportUndetectableSource(json);\n         }\n-        JsonParser jp = _parserFactory.createParser(json);\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        jp.nextToken();\n-        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n+        JsonParser p = _parserFactory.createParser(json);\n+        _initForMultiRead(p);\n+        p.nextToken();\n+        DeserializationContext ctxt = createDeserializationContext(p, _config);\n+        return _newIterator(_valueType, p, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n \n      */\n \n     @Override\n-    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n-        throws JsonProcessingException\n+    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException\n     {\n         try {\n             return readValue(treeAsTokens(n), valueType);\n     }    \n     \n     @Override\n-    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException\n-    {\n+    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException {\n         throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n     }\n \n     /**\n      * Actual implementation of value reading+binding operation.\n      */\n-    protected Object _bind(JsonParser jp, Object valueToUpdate)\n-        throws IOException, JsonParseException, JsonMappingException\n+    protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException\n     {\n         /* First: may need to read the next token, to initialize state (either\n          * before first read from parser, or after previous token has been cleared)\n         return result;\n     }\n     \n-    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n+    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException\n+    {\n         try {\n             Object result;\n             JsonToken t = _initForReading(jp);\n         }\n     }\n \n-    protected JsonNode _bindAsTree(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n+    protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException {\n+        try {\n+            return _bindAsTree(jp);\n+        } finally {\n+            try {\n+                jp.close();\n+            } catch (IOException ioe) { }\n+        }\n+    }\n+    \n+    protected JsonNode _bindAsTree(JsonParser jp) throws IOException\n     {\n         JsonNode result;\n         JsonToken t = _initForReading(jp);\n         return result;\n     }\n     \n-    protected JsonNode _bindAndCloseAsTree(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        try {\n-            return _bindAsTree(jp);\n-        } finally {\n-            try {\n-                jp.close();\n-            } catch (IOException ioe) { }\n-        }\n-    }\n-    \n     /**\n      * @since 2.1\n      */\n-    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p,\n-            Object valueToUpdate)\n-        throws IOException, JsonProcessingException\n-    {\n-        if (_schema != null) {\n-            p.setSchema(_schema);\n-        }\n+    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p, Object valueToUpdate) throws IOException\n+    {\n+        _initForMultiRead(p);\n         p.nextToken();\n         DeserializationContext ctxt = createDeserializationContext(p, _config);\n-        return new MappingIterator<T>(_valueType, p, ctxt, \n-                _findRootDeserializer(ctxt, _valueType),\n-                true, _valueToUpdate);\n-    }\n-    \n-    protected static JsonToken _initForReading(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        /* First: must point to a token; if not pointing to one, advance.\n-         * This occurs before first read from JsonParser, as well as\n-         * after clearing of current token.\n-         */\n-        JsonToken t = jp.getCurrentToken();\n-        if (t == null) { // and then we must get something...\n-            t = jp.nextToken();\n-            if (t == null) {\n-                /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n-                 *   not an actual parsing problem\n-                 */\n-                throw JsonMappingException.from(jp, \"No content to map due to end-of-input\");\n-            }\n-        }\n-        return t;\n-    }\n-\n+        return _newIterator(_valueType, p, ctxt, \n+                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n+    }\n+\n+    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n+            JavaType rootType, JsonDeserializer<Object> deser) throws IOException\n+    {\n+        String expName = _config.getRootName();\n+        if (expName == null) {\n+            PropertyName pname = _rootNames.findRootName(rootType, _config);\n+            expName = pname.getSimpleName();\n+        }\n+        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n+            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n+            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        String actualName = jp.getCurrentName();\n+        if (!expName.equals(actualName)) {\n+            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n+                    +expName+\"') for type \"+rootType);\n+        }\n+        // ok, then move to value itself....\n+        jp.nextToken();\n+        Object result;\n+        if (_valueToUpdate == null) {\n+            result = deser.deserialize(jp, ctxt);\n+        } else {\n+            deser.deserialize(jp, ctxt, _valueToUpdate);\n+            result = _valueToUpdate;                    \n+        }\n+        // and last, verify that we now get matching END_OBJECT\n+        if (jp.nextToken() != JsonToken.END_OBJECT) {\n+            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        return result;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, locating deserializers etc\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Method called to locate deserializer for the passed root-level value.\n      */\n      * by configuration. Method also is NOT to throw an exception if\n      * access fails.\n      */\n-    protected JsonDeserializer<Object> _prefetchRootDeserializer(\n-            DeserializationConfig config, JavaType valueType)\n+    protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType)\n     {\n         if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n             return null;\n         }\n         return deser;\n     }\n-    \n-    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n-            JavaType rootType, JsonDeserializer<Object> deser)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        String expName = _config.getRootName();\n-        if (expName == null) {\n-            PropertyName pname = _rootNames.findRootName(rootType, _config);\n-            expName = pname.getSimpleName();\n-        }\n-        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n-            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        String actualName = jp.getCurrentName();\n-        if (!expName.equals(actualName)) {\n-            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n-                    +expName+\"') for type \"+rootType);\n-        }\n-        // ok, then move to value itself....\n-        jp.nextToken();\n-        Object result;\n-        if (_valueToUpdate == null) {\n-            result = deser.deserialize(jp, ctxt);\n-        } else {\n-            deser.deserialize(jp, ctxt, _valueToUpdate);\n-            result = _valueToUpdate;                    \n-        }\n-        // and last, verify that we now get matching END_OBJECT\n-        if (jp.nextToken() != JsonToken.END_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        return result;\n-    }\n \n     /*\n     /**********************************************************\n         // 04-Jan-2010, tatu: we do actually need the provider too... (for polymorphic deser)\n         return _context.createInstance(cfg, jp, _injectableValues);\n     }\n-    \n-    protected ObjectReader _with(DeserializationConfig newConfig) {\n-        if (newConfig == _config) {\n-            return this;\n-        }\n-        if (_dataFormatReaders != null) {\n-            return new ObjectReader(this, newConfig)\n-                .withFormatDetection(_dataFormatReaders.with(newConfig));\n-        }\n-        return new ObjectReader(this, newConfig);\n-    }\n \n     protected void _reportUndetectableSource(Object src) throws JsonProcessingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n package com.fasterxml.jackson.databind;\n \n import java.io.*;\n-import java.text.DateFormat;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.TimeZone;\n+import java.text.*;\n+import java.util.*;\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.CharacterEscapes;\n import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n+import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.core.type.TypeReference;\n-import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n-import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n-import com.fasterxml.jackson.core.util.Instantiatable;\n-import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n+import com.fasterxml.jackson.core.util.*;\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n-import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n-import com.fasterxml.jackson.databind.ser.FilterProvider;\n-import com.fasterxml.jackson.databind.ser.SerializerFactory;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.databind.ser.impl.TypeWrappedSerializer;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n     implements Versioned,\n         java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = -7040667122552707164L;\n+    private static final long serialVersionUID = 1; // since 2.5\n \n     /**\n      * We need to keep track of explicit disabling of pretty printing;\n      */\n \n     /**\n-     * Specified root serialization type to use; can be same\n-     * as runtime type, but usually one of its super types\n-     */\n-    protected final JavaType _rootType;\n+     * Container for settings that need to be passed to {@link JsonGenerator}\n+     * constructed for serializing values.\n+     *\n+     * @since 2.5\n+     */\n+    protected final GeneratorSettings _generatorSettings;\n \n     /**\n      * We may pre-fetch serializer if {@link #_rootType}\n      * is known, and if so, reuse it afterwards.\n      * This allows avoiding further serializer lookups and increases\n      * performance a bit on cases where readers are reused.\n-     * \n-     * @since 2.1\n-     */\n-    protected final JsonSerializer<Object> _rootSerializer;\n+     *\n+     * @since 2.5\n+     */\n+    protected final Prefetch _prefetch;\n     \n-    /**\n-     * To allow for dynamic enabling/disabling of pretty printing,\n-     * pretty printer can be optionally configured for writer\n-     * as well\n-     */\n-    protected final PrettyPrinter _prettyPrinter;\n-    \n-    /**\n-     * When using data format that uses a schema, schema is passed\n-     * to generator.\n-     */\n-    protected final FormatSchema _schema;\n-    \n-    /**\n-     * Caller may want to specify character escaping details, either as\n-     * defaults, or on call-by-call basis.\n-     * \n-     * @since 2.3\n-     */\n-    protected final CharacterEscapes _characterEscapes;\n-\n-    /*\n-    /**********************************************************\n-    /* Derived settings\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * @since 2.3\n-     */\n-    protected final boolean  _cfgBigDecimalAsPlain;\n-\n     /*\n     /**********************************************************\n     /* Life-cycle, constructors\n             JavaType rootType, PrettyPrinter pp)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n-\n         _serializerProvider = mapper._serializerProvider;\n         _serializerFactory = mapper._serializerFactory;\n         _generatorFactory = mapper._jsonFactory;\n-        _prettyPrinter = pp;\n-        _schema = null;\n-        _characterEscapes = null;\n+        _generatorSettings = (pp == null) ? GeneratorSettings.empty\n+                : new GeneratorSettings(pp, null, null, null);\n \n         // 29-Apr-2014, tatu: There is no \"untyped serializer\", so:\n         if (rootType == null || rootType.hasRawClass(Object.class)) {\n-            _rootType = null;\n-            _rootSerializer = null;\n+            _prefetch = Prefetch.empty;\n         } else {\n-            _rootType = rootType.withStaticTyping();\n-            _rootSerializer = _prefetchRootSerializer(config, _rootType);\n+            rootType = rootType.withStaticTyping();\n+            _prefetch = _prefetchRootSerializer(config, rootType);\n         }\n     }\n \n     protected ObjectWriter(ObjectMapper mapper, SerializationConfig config)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n-\n         _serializerProvider = mapper._serializerProvider;\n         _serializerFactory = mapper._serializerFactory;\n         _generatorFactory = mapper._jsonFactory;\n \n-        _rootType = null;\n-        _rootSerializer = null;\n-        _prettyPrinter = null;\n-        _schema = null;\n-        _characterEscapes = null;\n+        _prefetch = Prefetch.empty;\n+        _generatorSettings = GeneratorSettings.empty;\n     }\n \n     /**\n             FormatSchema s)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n \n         _serializerProvider = mapper._serializerProvider;\n         _serializerFactory = mapper._serializerFactory;\n         _generatorFactory = mapper._jsonFactory;\n \n-        _rootType = null;\n-        _rootSerializer = null;\n-        _prettyPrinter = null;\n-        _schema = s;\n-        _characterEscapes = null;\n+        _prefetch = Prefetch.empty;\n+        _generatorSettings = (s == null) ? GeneratorSettings.empty\n+                : new GeneratorSettings(null, s, null, null);\n     }\n     \n     /**\n      * Copy constructor used for building variations.\n      */\n     protected ObjectWriter(ObjectWriter base, SerializationConfig config,\n-            JavaType rootType, JsonSerializer<Object> rootSer,\n-            PrettyPrinter pp, FormatSchema s, CharacterEscapes escapes)\n+            GeneratorSettings genSettings, Prefetch prefetch)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n \n         _serializerProvider = base._serializerProvider;\n         _serializerFactory = base._serializerFactory;\n         _generatorFactory = base._generatorFactory;\n \n-        _rootType = rootType;\n-        _rootSerializer = rootSer;\n-        _prettyPrinter = pp;\n-        _schema = s;\n-        _characterEscapes = escapes;\n+        _generatorSettings = genSettings;\n+        _prefetch = prefetch;\n     }\n \n     /**\n     protected ObjectWriter(ObjectWriter base, SerializationConfig config)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n \n         _serializerProvider = base._serializerProvider;\n         _serializerFactory = base._serializerFactory;\n         _generatorFactory = base._generatorFactory;\n-        _schema = base._schema;\n-        _characterEscapes = base._characterEscapes;\n-\n-        _rootType = base._rootType;\n-        _rootSerializer = base._rootSerializer;\n-        _prettyPrinter = base._prettyPrinter;\n+        _generatorSettings = base._generatorSettings;\n+        _prefetch = base._prefetch;\n     }\n \n     /**\n         // may need to override ordering, based on data format capabilities\n         _config = base._config\n             .with(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, f.requiresPropertyOrdering());\n-        _cfgBigDecimalAsPlain = base._cfgBigDecimalAsPlain;\n \n         _serializerProvider = base._serializerProvider;\n         _serializerFactory = base._serializerFactory;\n         _generatorFactory = base._generatorFactory;\n-        _schema = base._schema;\n-        _characterEscapes = base._characterEscapes;\n-\n-        _rootType = base._rootType;\n-        _rootSerializer = base._rootSerializer;\n-        _prettyPrinter = base._prettyPrinter;\n-    }\n-    \n+        _generatorSettings = base._generatorSettings;\n+        _prefetch = base._prefetch;\n+    }\n+\n     /**\n      * Method that will return version information stored in and read from jar\n      * that contains this class.\n     public Version version() {\n         return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Life-cycle, fluent factories\n+\n+    /*\n+    /**********************************************************\n+    /* Methods sub-classes MUST override, used for constructing\n+    /* writer instances, (re)configuring parser instances.\n+    /* Added in 2.5\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _new(ObjectWriter base, JsonFactory f) {\n+        return new ObjectWriter(base, f);\n+    }\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _new(ObjectWriter base, SerializationConfig config) {\n+        return new ObjectWriter(base, config);\n+    }\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods.\n+     * It assumes `this` as base for settings other than those directly\n+     * passed in.\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _new(GeneratorSettings genSettings, Prefetch prefetch) {\n+        return new ObjectWriter(this, _config, genSettings, prefetch);\n+    }\n+\n+    /**\n+     * Overridable factory method called by {@link #createSequenceWriter(JsonGenerator)}\n+     * method (and its various overrides), and initializes it as necessary.\n+     * \n+     * @since 2.5\n+     */\n+    @SuppressWarnings(\"resource\")\n+    protected SequenceWriter _newSequenceWriter(boolean wrapInArray,\n+            JsonGenerator gen, boolean managedInput)\n+        throws IOException\n+    {\n+        return new SequenceWriter(_serializerProvider(_config),\n+                _configureGenerator(gen), managedInput, _prefetch)\n+            .init(wrapInArray);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factories for SerializationFeature\n     /**********************************************************\n      */\n \n      */\n     public ObjectWriter with(SerializationFeature feature)  {\n         SerializationConfig newConfig = _config.with(feature);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter with(SerializationFeature first, SerializationFeature... other) {\n         SerializationConfig newConfig = _config.with(first, other);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }    \n \n     /**\n      */\n     public ObjectWriter withFeatures(SerializationFeature... features) {\n         SerializationConfig newConfig = _config.withFeatures(features);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }    \n     \n     /**\n      */\n     public ObjectWriter without(SerializationFeature feature) {\n         SerializationConfig newConfig = _config.without(feature);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }    \n \n     /**\n      */\n     public ObjectWriter without(SerializationFeature first, SerializationFeature... other) {\n         SerializationConfig newConfig = _config.without(first, other);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }    \n \n     /**\n      */\n     public ObjectWriter withoutFeatures(SerializationFeature... features) {\n         SerializationConfig newConfig = _config.withoutFeatures(features);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n-    }    \n-    \n+        return (newConfig == _config) ? this : _new(this, newConfig);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factories for JsonGenerator.Feature\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter with(JsonGenerator.Feature feature)  {\n+        SerializationConfig newConfig = _config.with(feature);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter withFeatures(JsonGenerator.Feature... features) {\n+        SerializationConfig newConfig = _config.withFeatures(features);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter without(JsonGenerator.Feature feature) {\n+        SerializationConfig newConfig = _config.without(feature);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter withoutFeatures(JsonGenerator.Feature... features) {\n+        SerializationConfig newConfig = _config.withoutFeatures(features);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factories, other\n+    /**********************************************************\n+     */\n+\n     /**\n      * Fluent factory method that will construct a new writer instance that will\n      * use specified date format for serializing dates; or if null passed, one\n      */\n     public ObjectWriter with(DateFormat df) {\n         SerializationConfig newConfig = _config.with(df);\n-        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this : _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter with(FilterProvider filterProvider) {\n         return (filterProvider == _config.getFilterProvider()) ? this\n-                 : new ObjectWriter(this, _config.withFilters(filterProvider));\n+                 : _new(this, _config.withFilters(filterProvider));\n     }\n \n     /**\n      * printer (or, if null, will not do any pretty-printing)\n      */\n     public ObjectWriter with(PrettyPrinter pp) {\n-        if (pp == _prettyPrinter) {\n+        GeneratorSettings genSet = _generatorSettings.with(pp);\n+        if (genSet == _generatorSettings) {\n             return this;\n         }\n-        // since null would mean \"don't care\", need to use placeholder to indicate \"disable\"\n-        if (pp == null) {\n-            pp = NULL_PRETTY_PRINTER;\n-        }\n-        return new ObjectWriter(this, _config, _rootType, _rootSerializer,\n-                pp, _schema, _characterEscapes);\n+        return _new(genSet, _prefetch);\n     }\n \n     /**\n      */\n     public ObjectWriter withRootName(String rootName) {\n         SerializationConfig newConfig = _config.withRootName(rootName);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     /**\n      * Note that method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    \n+    public ObjectWriter with(FormatSchema schema) {\n+        GeneratorSettings genSet = _generatorSettings.with(schema);\n+        if (genSet == _generatorSettings) {\n+            return this;\n+        }\n+        _verifySchemaType(schema);\n+        return _new(genSet, _prefetch);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5 use {@link #with(FormatSchema)} instead\n+     */\n+    @Deprecated\n     public ObjectWriter withSchema(FormatSchema schema) {\n-        if (_schema == schema) {\n-            return this;\n-        }\n-        _verifySchemaType(schema);\n-        return new ObjectWriter(this, _config, _rootType, _rootSerializer,\n-                _prettyPrinter, schema, _characterEscapes);\n+        return with(schema);\n     }\n \n     /**\n      *<p>\n      * Note that method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n-     */\n-    public ObjectWriter withType(JavaType rootType)\n-    {\n-        JsonSerializer<Object> rootSer;\n+     * \n+     * @since 2.5\n+     */\n+    public ObjectWriter forType(JavaType rootType)\n+    {\n+        Prefetch pf;\n         if (rootType == null || rootType.hasRawClass(Object.class)) {\n-            rootType = null;\n-            rootSer = null;\n+            pf = Prefetch.empty;\n         } else {\n             // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n             rootType = rootType.withStaticTyping();\n-            rootSer = _prefetchRootSerializer(_config, rootType);\n-        }\n-        return new ObjectWriter(this, _config, rootType, rootSer,\n-                _prettyPrinter, _schema, _characterEscapes);\n+            pf = _prefetchRootSerializer(_config, rootType);\n+        }\n+        return (pf == _prefetch) ? this : _new(_generatorSettings, pf);\n     }    \n \n     /**\n      * Method that will construct a new instance that uses specific type\n      * as the root type for serialization, instead of runtime dynamic\n      * type of the root object itself.\n-     */\n+     * \n+     * @since 2.5\n+     */\n+    public ObjectWriter forType(Class<?> rootType) {\n+        if (rootType == Object.class) {\n+            return forType((JavaType) null);\n+        }\n+        return forType(_config.constructType(rootType));\n+    }\n+\n+    public ObjectWriter forType(TypeReference<?> rootType) {\n+        return forType(_config.getTypeFactory().constructType(rootType.getType()));\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(JavaType)} instead\n+     */\n+    @Deprecated // since 2.5\n+    public ObjectWriter withType(JavaType rootType) {\n+        return forType(rootType);\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n+     */\n+    @Deprecated // since 2.5\n     public ObjectWriter withType(Class<?> rootType) {\n-        if (rootType == Object.class) {\n-            return withType((JavaType) null);\n-        }\n-        return withType(_config.constructType(rootType));\n-    }\n-\n+        return forType(rootType);\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(TypeReference)} instead\n+     */\n+    @Deprecated // since 2.5\n     public ObjectWriter withType(TypeReference<?> rootType) {\n-        return withType(_config.getTypeFactory().constructType(rootType.getType()));\n+        return forType(rootType);\n     }\n \n     /**\n      */\n     public ObjectWriter withView(Class<?> view) {\n         SerializationConfig newConfig = _config.withView(view);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }    \n \n     public ObjectWriter with(Locale l) {\n         SerializationConfig newConfig = _config.with(l);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     public ObjectWriter with(TimeZone tz) {\n         SerializationConfig newConfig = _config.with(tz);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter with(Base64Variant b64variant) {\n         SerializationConfig newConfig = _config.with(b64variant);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectWriter with(CharacterEscapes escapes) {\n-        if (_characterEscapes == escapes) {\n+        GeneratorSettings genSet = _generatorSettings.with(escapes);\n+        if (genSet == _generatorSettings) {\n             return this;\n         }\n-        return new ObjectWriter(this, _config, _rootType, _rootSerializer,\n-                _prettyPrinter, _schema, escapes);\n+        return _new(genSet, _prefetch);\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectWriter with(JsonFactory f) {\n-        return (f == _generatorFactory) ? this : new ObjectWriter(this, f);\n+        return (f == _generatorFactory) ? this : _new(this, f);\n     }    \n \n     /**\n      */\n     public ObjectWriter with(ContextAttributes attrs) {\n         SerializationConfig newConfig = _config.with(attrs);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter withAttributes(Map<Object,Object> attrs) {\n         SerializationConfig newConfig = _config.withAttributes(attrs);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter withAttribute(Object key, Object value) {\n         SerializationConfig newConfig = _config.withAttribute(key, value);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n     }\n \n     /**\n      */\n     public ObjectWriter withoutAttribute(Object key) {\n         SerializationConfig newConfig = _config.withoutAttribute(key);\n-        return (newConfig == _config) ? this :  new ObjectWriter(this, newConfig);\n-    }\n-    \n+        return (newConfig == _config) ? this :  _new(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter withRootValueSeparator(String sep) {\n+        GeneratorSettings genSet = _generatorSettings.withRootValueSeparator(sep);\n+        if (genSet == _generatorSettings) {\n+            return this;\n+        }\n+        return _new(genSet, _prefetch);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter withRootValueSeparator(SerializableString sep) {\n+        GeneratorSettings genSet = _generatorSettings.withRootValueSeparator(sep);\n+        if (genSet == _generatorSettings) {\n+            return this;\n+        }\n+        return _new(genSet, _prefetch);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods for sequence writers (2.5)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write a sequence of root\n+     * values using configuration of this {@link ObjectWriter}.\n+     * Sequence is not surrounded by JSON array; some backend types may not\n+     * support writing of such sequences as root level.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure closing of underlying generator and\n+     * output stream.\n+     *\n+     * @param out Target file to write value sequence to.\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValues(File out) throws IOException {\n+        return _newSequenceWriter(false,\n+                _generatorFactory.createGenerator(out, JsonEncoding.UTF8), true);\n+    }\n+\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write a sequence of root\n+     * values using configuration of this {@link ObjectWriter}.\n+     * Sequence is not surrounded by JSON array; some backend types may not\n+     * support writing of such sequences as root level.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure that all content gets flushed by\n+     * the generator. However, since a {@link JsonGenerator} is explicitly passed,\n+     * it will NOT be closed when {@link SequenceWriter#close()} is called.\n+     *\n+     * @param gen Low-level generator caller has already constructed that will\n+     *   be used for actual writing of token stream.\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValues(JsonGenerator gen) throws IOException {\n+        return _newSequenceWriter(false, _configureGenerator(gen), false);\n+    }\n+\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write a sequence of root\n+     * values using configuration of this {@link ObjectWriter}.\n+     * Sequence is not surrounded by JSON array; some backend types may not\n+     * support writing of such sequences as root level.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure closing of underlying generator and\n+     * output stream.\n+     *\n+     * @param out Target writer to use for writing the token stream\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValues(Writer out) throws IOException {\n+        return _newSequenceWriter(false,\n+                _generatorFactory.createGenerator(out), true);\n+    }\n+\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write a sequence of root\n+     * values using configuration of this {@link ObjectWriter}.\n+     * Sequence is not surrounded by JSON array; some backend types may not\n+     * support writing of such sequences as root level.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure closing of underlying generator and\n+     * output stream.\n+     *\n+     * @param out Physical output stream to use for writing the token stream\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValues(OutputStream out) throws IOException {\n+        return _newSequenceWriter(false,\n+                _generatorFactory.createGenerator(out, JsonEncoding.UTF8), true);\n+    }\n+\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write an array of\n+     * root-level values, using configuration of this {@link ObjectWriter}.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure closing of underlying generator and\n+     * output stream.\n+     *<p>\n+     * Note that the type to use with {@link ObjectWriter#forType(Class)} needs to\n+     * be type of individual values (elements) to write and NOT matching array\n+     * or {@link java.util.Collection} type.\n+     *\n+     * @param out File to write token stream to\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValuesAsArray(File out) throws IOException {\n+        return _newSequenceWriter(true,\n+                _generatorFactory.createGenerator(out, JsonEncoding.UTF8), true);\n+    }\n+\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write an array of\n+     * root-level values, using configuration of this {@link ObjectWriter}.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure that all content gets flushed by\n+     * the generator. However, since a {@link JsonGenerator} is explicitly passed,\n+     * it will NOT be closed when {@link SequenceWriter#close()} is called.\n+     *<p>\n+     * Note that the type to use with {@link ObjectWriter#forType(Class)} needs to\n+     * be type of individual values (elements) to write and NOT matching array\n+     * or {@link java.util.Collection} type.\n+     *\n+     * @param gen Underlying generator to use for writing the token stream\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValuesAsArray(JsonGenerator gen) throws IOException {\n+        return _newSequenceWriter(true, gen, false);\n+    }\n+\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write an array of\n+     * root-level values, using configuration of this {@link ObjectWriter}.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure closing of underlying generator and\n+     * output stream.\n+     *<p>\n+     * Note that the type to use with {@link ObjectWriter#forType(Class)} needs to\n+     * be type of individual values (elements) to write and NOT matching array\n+     * or {@link java.util.Collection} type.\n+     *\n+     * @param out Writer to use for writing the token stream\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValuesAsArray(Writer out) throws IOException {\n+        return _newSequenceWriter(true, _generatorFactory.createGenerator(out), true);\n+    }\n+\n+    /**\n+     * Method for creating a {@link SequenceWriter} to write an array of\n+     * root-level values, using configuration of this {@link ObjectWriter}.\n+     * Resulting writer needs to be {@link SequenceWriter#close()}d after all\n+     * values have been written to ensure closing of underlying generator and\n+     * output stream.\n+     *<p>\n+     * Note that the type to use with {@link ObjectWriter#forType(Class)} needs to\n+     * be type of individual values (elements) to write and NOT matching array\n+     * or {@link java.util.Collection} type.\n+     *\n+     * @param out Physical output stream to use for writing the token stream\n+     *\n+     * @since 2.5\n+     */\n+    public SequenceWriter writeValuesAsArray(OutputStream out) throws IOException {\n+        return _newSequenceWriter(true,\n+                _generatorFactory.createGenerator(out, JsonEncoding.UTF8), true);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Simple accessors\n      * @since 2.2\n      */\n     public boolean hasPrefetchedSerializer() {\n-        return _rootSerializer != null;\n+        return _prefetch.hasSerializer();\n     }\n \n     /**\n      * Method that can be used to serialize any Java value as\n      * JSON output, using provided {@link JsonGenerator}.\n      */\n-    public void writeValue(JsonGenerator jgen, Object value)\n+    public void writeValue(JsonGenerator gen, Object value)\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n-        // 10-Aug-2012, tatu: As per [Issue#12], may need to force PrettyPrinter settings, so:\n-        _configureJsonGenerator(jgen);\n+        _configureGenerator(gen);\n         if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE)\n                 && (value instanceof Closeable)) {\n-            _writeCloseableValue(jgen, value, _config);\n+            _writeCloseableValue(gen, value, _config);\n         } else {\n-            if (_rootType == null) {\n-                _serializerProvider(_config).serializeValue(jgen, value);\n+            if (_prefetch.valueSerializer != null) {\n+                _serializerProvider(_config).serializeValue(gen, value, _prefetch.rootType,\n+                        _prefetch.valueSerializer);\n+            } else if (_prefetch.typeSerializer != null) {\n+                _serializerProvider(_config).serializePolymorphic(gen, value, _prefetch.typeSerializer);\n             } else {\n-                _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer);\n+                _serializerProvider(_config).serializeValue(gen, value);\n             }\n             if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n-                jgen.flush();\n+                gen.flush();\n             }\n         }\n     }\n     public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {\n         return _serializerProvider(_config).hasSerializerFor(type, cause);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Overridable helper methods\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Overridable helper method used for constructing\n      * {@link SerializerProvider} to use for serialization.\n     protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n         return _serializerProvider.createInstance(config, _serializerFactory);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Internal methods\n      * Method called to configure the generator as necessary and then\n      * call write functionality\n      */\n-    protected final void _configAndWriteValue(JsonGenerator jgen, Object value) throws IOException\n-    {\n-        _configureJsonGenerator(jgen);\n+    protected final void _configAndWriteValue(JsonGenerator gen, Object value) throws IOException\n+    {\n+        _configureGenerator(gen);\n         // [JACKSON-282]: consider Closeable\n         if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n-            _writeCloseable(jgen, value, _config);\n+            _writeCloseable(gen, value, _config);\n             return;\n         }\n         boolean closed = false;\n         try {\n-            if (_rootType == null) {\n-                _serializerProvider(_config).serializeValue(jgen, value);\n+            if (_prefetch.valueSerializer != null) {\n+                _serializerProvider(_config).serializeValue(gen, value, _prefetch.rootType,\n+                        _prefetch.valueSerializer);\n+            } else if (_prefetch.typeSerializer != null) {\n+                _serializerProvider(_config).serializePolymorphic(gen, value, _prefetch.typeSerializer);\n             } else {\n-                _serializerProvider(_config).serializeValue(jgen, value, _rootType, _rootSerializer);\n+                _serializerProvider(_config).serializeValue(gen, value);\n             }\n             closed = true;\n-            jgen.close();\n+            gen.close();\n         } finally {\n             /* won't try to close twice; also, must catch exception (so it \n              * will not mask exception that is pending)\n                 /* 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                  *    structures, which typically causes more damage.\n                  */\n-                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n+                gen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                 try {\n-                    jgen.close();\n+                    gen.close();\n                 } catch (IOException ioe) { }\n             }\n         }\n      * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n      * method is to be called right after serialization has been called\n      */\n-    private final void _writeCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+    private final void _writeCloseable(JsonGenerator gen, Object value, SerializationConfig cfg)\n+        throws IOException\n     {\n         Closeable toClose = (Closeable) value;\n         try {\n-            if (_rootType == null) {\n-                _serializerProvider(cfg).serializeValue(jgen, value);\n+            if (_prefetch.valueSerializer != null) {\n+                _serializerProvider(cfg).serializeValue(gen, value, _prefetch.rootType,\n+                        _prefetch.valueSerializer);\n+            } else if (_prefetch.typeSerializer != null) {\n+                _serializerProvider(cfg).serializePolymorphic(gen, value, _prefetch.typeSerializer);\n             } else {\n-                _serializerProvider(cfg).serializeValue(jgen, value, _rootType, _rootSerializer);\n-            }\n-            JsonGenerator tmpJgen = jgen;\n-            jgen = null;\n-            tmpJgen.close();\n+                _serializerProvider(cfg).serializeValue(gen, value);\n+            }\n+            JsonGenerator tmpGen = gen;\n+            gen = null;\n+            tmpGen.close();\n             Closeable tmpToClose = toClose;\n             toClose = null;\n             tmpToClose.close();\n             /* Need to close both generator and value, as long as they haven't yet\n              * been closed\n              */\n-            if (jgen != null) {\n+            if (gen != null) {\n                 /* 04-Mar-2014, tatu: But! Let's try to prevent auto-closing of\n                  *    structures, which typically causes more damage.\n                  */\n-                jgen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n+                gen.disable(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT);\n                 try {\n-                    jgen.close();\n+                    gen.close();\n                 } catch (IOException ioe) { }\n             }\n             if (toClose != null) {\n      * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n      * method is to be called right after serialization has been called\n      */\n-    private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+    private final void _writeCloseableValue(JsonGenerator gen, Object value, SerializationConfig cfg)\n+        throws IOException\n     {\n         Closeable toClose = (Closeable) value;\n         try {\n-            if (_rootType == null) {\n-                _serializerProvider(cfg).serializeValue(jgen, value);\n+            if (_prefetch.valueSerializer != null) {\n+                _serializerProvider(cfg).serializeValue(gen, value, _prefetch.rootType,\n+                        _prefetch.valueSerializer);\n+            } else if (_prefetch.typeSerializer != null) {\n+                _serializerProvider(cfg).serializePolymorphic(gen, value, _prefetch.typeSerializer);\n             } else {\n-                _serializerProvider(cfg).serializeValue(jgen, value, _rootType, _rootSerializer);\n+                _serializerProvider(cfg).serializeValue(gen, value);\n             }\n             if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n-                jgen.flush();\n+                gen.flush();\n             }\n             Closeable tmpToClose = toClose;\n             toClose = null;\n      * by configuration. Method also is NOT to throw an exception if\n      * access fails.\n      */\n-    protected JsonSerializer<Object> _prefetchRootSerializer(\n-            SerializationConfig config, JavaType valueType)\n-    {\n-        if (valueType == null || !_config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)) {\n-            return null;\n-        }\n-        try {\n-            return _serializerProvider(config).findTypedValueSerializer(valueType, true, null);\n-        } catch (JsonProcessingException e) {\n-            // need to swallow?\n-            return null;\n-        }\n+    protected Prefetch _prefetchRootSerializer(SerializationConfig config, JavaType valueType)\n+    {\n+        if (valueType != null && _config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)) {\n+            /* 17-Dec-2014, tatu: Need to be bit careful here; TypeSerializers are NOT cached,\n+             *   so although it'd seem like a good idea to look for those first, and avoid\n+             *   serializer for polymorphic types, it is actually more efficient to do the\n+             *   reverse here.\n+             */\n+            try {\n+                JsonSerializer<Object> ser = _serializerProvider(config).findTypedValueSerializer(valueType, true, null);\n+                // Important: for polymorphic types, \"unwrap\"...\n+                if (ser instanceof TypeWrappedSerializer) {\n+                    return Prefetch.construct(valueType, ((TypeWrappedSerializer) ser).typeSerializer());\n+                }\n+                return Prefetch.construct(valueType,  ser);\n+            } catch (JsonProcessingException e) {\n+                // need to swallow?\n+                ;\n+            }\n+        }\n+        return Prefetch.empty;\n     }\n     \n     /**\n      * {@link JsonGenerator}\n      * \n      * @since 2.1\n-     */\n-    private void _configureJsonGenerator(JsonGenerator jgen)\n-    {\n-        if (_prettyPrinter != null) {\n-            PrettyPrinter pp = _prettyPrinter;\n+     * \n+     * @deprecated Since 2.5 (to be removed from 2.6 or later)\n+     */\n+    @Deprecated\n+    protected void _configureJsonGenerator(JsonGenerator gen) {\n+        _configureGenerator(gen);\n+    }\n+\n+    /**\n+     * Helper method called to set or override settings of passed-in\n+     * {@link JsonGenerator}\n+     * \n+     * @since 2.5\n+     */\n+    protected JsonGenerator _configureGenerator(JsonGenerator gen)\n+    {\n+        GeneratorSettings genSet = _generatorSettings;\n+        PrettyPrinter pp = genSet.prettyPrinter;\n+        if (pp != null) {\n             if (pp == NULL_PRETTY_PRINTER) {\n-                jgen.setPrettyPrinter(null);\n+                gen.setPrettyPrinter(null);\n             } else {\n                 /* [JACKSON-851]: Better take care of stateful PrettyPrinters...\n                  *   like the DefaultPrettyPrinter.\n                 if (pp instanceof Instantiatable<?>) {\n                     pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance();\n                 }\n-                jgen.setPrettyPrinter(pp);\n+                gen.setPrettyPrinter(pp);\n             }\n         } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n-            jgen.useDefaultPrettyPrinter();\n-        }\n-        if (_characterEscapes != null) {\n-            jgen.setCharacterEscapes(_characterEscapes);\n-        }\n-        // [JACKSON-520]: add support for pass-through schema:\n-        if (_schema != null) {\n-            jgen.setSchema(_schema);\n-        }\n-        if (_cfgBigDecimalAsPlain) { // should only set if explicitly set; this should work for now:\n-            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n+            gen.useDefaultPrettyPrinter();\n+        }\n+        CharacterEscapes esc = genSet.characterEscapes;\n+        if (esc != null) {\n+            gen.setCharacterEscapes(esc);\n+        }\n+        FormatSchema sch = genSet.schema;\n+        if (sch != null) {\n+            gen.setSchema(sch);\n+        }\n+        SerializableString sep = genSet.rootValueSeparator;\n+        if (sep != null) {\n+            gen.setRootValueSeparator(sep);\n+        }\n+        _config.initialize(gen); // since 2.5\n+        return gen;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes for configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper class used for containing settings specifically related\n+     * to (re)configuring {@link JsonGenerator} constructed for\n+     * writing output.\n+     * \n+     * @since 2.5\n+     */\n+    public final static class GeneratorSettings\n+        implements java.io.Serializable\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        public final static GeneratorSettings empty = new GeneratorSettings(null, null, null, null);\n+\n+        /**\n+         * To allow for dynamic enabling/disabling of pretty printing,\n+         * pretty printer can be optionally configured for writer\n+         * as well\n+         */\n+        public final PrettyPrinter prettyPrinter;\n+\n+        /**\n+         * When using data format that uses a schema, schema is passed\n+         * to generator.\n+         */\n+        public final FormatSchema schema;\n+\n+        /**\n+         * Caller may want to specify character escaping details, either as\n+         * defaults, or on call-by-call basis.\n+         */\n+        public final CharacterEscapes characterEscapes;\n+\n+        /**\n+         * Caller may want to override so-called \"root value separator\",\n+         * String added (verbatim, with no quoting or escaping) between\n+         * values in root context. Default value is a single space character,\n+         * but this is often changed to linefeed.\n+         */\n+        public final SerializableString rootValueSeparator;\n+\n+        public GeneratorSettings(PrettyPrinter pp, FormatSchema sch,\n+                CharacterEscapes esc, SerializableString rootSep) {\n+            prettyPrinter = pp;\n+            schema = sch;\n+            characterEscapes = esc;\n+            rootValueSeparator = rootSep;\n+        }\n+\n+        public GeneratorSettings with(PrettyPrinter pp) {\n+            // since null would mean \"don't care\", need to use placeholder to indicate \"disable\"\n+            if (pp == null) {\n+                pp = NULL_PRETTY_PRINTER;\n+            }\n+            return (pp == prettyPrinter) ? this\n+                    : new GeneratorSettings(pp, schema, characterEscapes, rootValueSeparator);\n+        }\n+\n+        public GeneratorSettings with(FormatSchema sch) {\n+            return (schema == sch) ? this\n+                    : new GeneratorSettings(prettyPrinter, sch, characterEscapes, rootValueSeparator);\n+        }\n+\n+        public GeneratorSettings with(CharacterEscapes esc) {\n+            return (characterEscapes == esc) ? this\n+                    : new GeneratorSettings(prettyPrinter, schema, esc, rootValueSeparator);\n+        }\n+\n+        public GeneratorSettings withRootValueSeparator(String sep) {\n+            if (sep == null) {\n+                if (rootValueSeparator == null) {\n+                    return this;\n+                }\n+            } else if (sep.equals(rootValueSeparator)) {\n+                return this;\n+            }\n+            return new GeneratorSettings(prettyPrinter, schema, characterEscapes,\n+                    (sep == null) ? null : new SerializedString(sep));\n+        }\n+\n+        public GeneratorSettings withRootValueSeparator(SerializableString sep) {\n+            if (sep == null) {\n+                if (rootValueSeparator == null) {\n+                    return this;\n+                }\n+            } else {\n+                if (rootValueSeparator != null\n+                        && sep.getValue().equals(rootValueSeparator.getValue())) {\n+                    return this;\n+                }\n+            }\n+            return new GeneratorSettings(prettyPrinter, schema, characterEscapes, sep);\n+        }\n+    }\n+\n+    /**\n+     * As a minor optimization, we will make an effort to pre-fetch a serializer,\n+     * or at least relevant <code>TypeSerializer</code>, if given enough\n+     * information.\n+     * \n+     * @since 2.5\n+     */\n+    public final static class Prefetch\n+        implements java.io.Serializable\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        public final static Prefetch empty = new Prefetch(null, null, null);\n+        \n+        /**\n+         * Specified root serialization type to use; can be same\n+         * as runtime type, but usually one of its super types\n+         */\n+        public final JavaType rootType;\n+\n+        /**\n+         * We may pre-fetch serializer if {@link #rootType}\n+         * is known, and if so, reuse it afterwards.\n+         * This allows avoiding further serializer lookups and increases\n+         * performance a bit on cases where readers are reused.\n+         */\n+        public final JsonSerializer<Object> valueSerializer;\n+\n+        /**\n+         * When dealing with polymorphic types, we can not pre-fetch\n+         * serializer, but we can pre-fetch {@link TypeSerializer}.\n+         */\n+        public final TypeSerializer typeSerializer;\n+        \n+        private Prefetch(JavaType type, JsonSerializer<Object> ser, TypeSerializer typeSer)\n+        {\n+            rootType = type;\n+            valueSerializer = ser;\n+            typeSerializer = typeSer;\n+        }\n+\n+        public static Prefetch construct(JavaType type, JsonSerializer<Object> ser) {\n+            if (type == null && ser == null) {\n+                return empty;\n+            }\n+            return new Prefetch(type, ser, null);\n+        }\n+        \n+        public static Prefetch construct(JavaType type, TypeSerializer typeSer) {\n+            if (type == null && typeSer == null) {\n+                return empty;\n+            }\n+            return new Prefetch(type, null, typeSer);\n+        }\n+\n+        public boolean hasSerializer() {\n+            return (valueSerializer != null) || (typeSerializer != null);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/PropertyMetadata.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/PropertyMetadata.java\n {\n     private static final long serialVersionUID = -1;\n \n-    public final static PropertyMetadata STD_REQUIRED = new PropertyMetadata(Boolean.TRUE, null, null);\n+    public final static PropertyMetadata STD_REQUIRED = new PropertyMetadata(Boolean.TRUE, null, null, null);\n \n-    public final static PropertyMetadata STD_OPTIONAL = new PropertyMetadata(Boolean.FALSE, null, null);\n+    public final static PropertyMetadata STD_OPTIONAL = new PropertyMetadata(Boolean.FALSE, null, null, null);\n \n-    public final static PropertyMetadata STD_REQUIRED_OR_OPTIONAL = new PropertyMetadata(null, null, null);\n+    public final static PropertyMetadata STD_REQUIRED_OR_OPTIONAL = new PropertyMetadata(null, null, null, null);\n     \n     /**\n      * Three states: required, not required and unknown; unknown represented\n      * @since 2.4\n      */\n     protected final Integer _index;\n+\n+    /**\n+     * Optional default value, as String, for property; not used cor\n+     * any functionality by core databind, offered as metadata for\n+     * extensions.\n+     */\n+    protected final String _defaultValue;\n     \n     /*\n     /**********************************************************\n      */\n     \n     @Deprecated // since 2.4\n-    protected PropertyMetadata(Boolean req, String desc) { this(req, desc, null); }\n+    protected PropertyMetadata(Boolean req, String desc) { this(req, desc, null, null); }\n \n-    protected PropertyMetadata(Boolean req, String desc, Integer index)\n+    /**\n+     * @since 2.5\n+     */\n+    protected PropertyMetadata(Boolean req, String desc, Integer index, String def)\n     {\n         _required = req;\n         _description = desc;\n         _index = index;\n+        _defaultValue = (def == null || def.isEmpty()) ? null : def;\n     }\n \n     /**\n-     * @since 2.4 Use variant that takes three arguments.\n+     * @since 2.4 Use variant that takes more arguments.\n      */\n     @Deprecated\n     public static PropertyMetadata construct(boolean req, String desc) {\n-    \treturn construct(req, desc, null);\n+        return construct(req, desc, null, null);\n     }\n-    \n-    public static PropertyMetadata construct(boolean req, String desc, Integer index) {\n-        PropertyMetadata md = req ? STD_REQUIRED : STD_OPTIONAL;\n-        if (desc != null) {\n-            md = md.withDescription(desc);\n+\n+    public static PropertyMetadata construct(boolean req, String desc, Integer index,\n+            String defaultValue) {\n+        if (desc != null || index != null || defaultValue != null) {\n+            return new PropertyMetadata(req, desc, index, defaultValue);\n         }\n-        if (index != null) {\n-        \tmd = md.withIndex(index);\n-        }\n-        return md;\n+        return req ? STD_REQUIRED : STD_OPTIONAL;\n     }\n     \n     /**\n      */\n     protected Object readResolve()\n     {\n-        if (_description == null && _index == null) {\n+        if (_description == null && _index == null && _defaultValue == null) {\n             if (_required == null) {\n                 return STD_REQUIRED_OR_OPTIONAL;\n             }\n     }\n \n     public PropertyMetadata withDescription(String desc) {\n-        return new PropertyMetadata(_required, desc, _index);\n+        return new PropertyMetadata(_required, desc, _index, _defaultValue);\n     }\n \n+    public PropertyMetadata withDefaultValue(String def) {\n+        if ((def == null) || def.isEmpty()) {\n+            if (_defaultValue == null) {\n+                return this;\n+            }\n+            def = null;\n+        } else if (_defaultValue.equals(def)) {\n+            return this;\n+        }\n+        return new PropertyMetadata(_required, _description, _index, def);\n+    }\n+    \n     public PropertyMetadata withIndex(Integer index) {\n-        return new PropertyMetadata(_required, _description, index);\n+        return new PropertyMetadata(_required, _description, index, _defaultValue);\n     }\n     \n     public PropertyMetadata withRequired(Boolean b) {\n                 return this;\n             }\n         }\n-        return new PropertyMetadata(b, _description, _index);\n+        return new PropertyMetadata(b, _description, _index, _defaultValue);\n     }\n     \n     /*\n \n     public String getDescription() { return _description; }\n \n+    /**\n+     * @since 2.5\n+     */\n+    public String getDefaultValue() { return _defaultValue; }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public boolean hasDefuaultValue() { return hasDefaultValue(); }\n+\n+    // NOTE: officially only added in 2.6 (to replace 'hasDefuaultValue()'; actually added in 2.5.1\n+    //  for forwards-compatibility\n+    public boolean hasDefaultValue() { return (_defaultValue != null); }\n+    \n     public boolean isRequired() { return (_required != null) && _required.booleanValue(); }\n     \n     public Boolean getRequired() { return _required; }\n--- a/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n public class PropertyName\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 7930806520033045126L;\n+    private static final long serialVersionUID = 1L; // 2.5\n \n     private final static String _USE_DEFAULT = \"\";\n     private final static String _NO_NAME = \"\";\n     public SerializableString simpleAsEncoded(MapperConfig<?> config) {\n         SerializableString sstr = _encodedSimple;\n         if (sstr == null) {\n-            sstr = config.compileString(_simpleName);\n+            if (config == null) {\n+                sstr = new SerializedString(_simpleName);\n+            } else {\n+                sstr = config.compileString(_simpleName);\n+            }\n             _encodedSimple = sstr;\n         }\n         return sstr;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/SequenceWriter.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.Collection;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+import com.fasterxml.jackson.databind.ser.impl.TypeWrappedSerializer;\n+\n+/**\n+ * Writer class similar to {@link ObjectWriter}, except that it can be used\n+ * for writing sequences of values, not just a single value.\n+ * The main use case is in writing very long sequences, or sequences where\n+ * values are incrementally produced; cases where it would be impractical\n+ * or at least inconvenient to construct a wrapper container around values\n+ * (or where no JSON array is desired around values).\n+ *<p>\n+ * Differences from {@link ObjectWriter} include:\n+ *<ul>\n+ *  <li>Instances of {@link SequenceWriter} are stateful, and not thread-safe:\n+ *    if sharing, external synchronization must be used.\n+ *  <li>Explicit {@link #close} is needed after all values have been written\n+ *     ({@link ObjectWriter} can auto-close after individual value writes)\n+ *</ul>\n+ * \n+ * @since 2.5\n+ */\n+public class SequenceWriter\n+    implements Versioned, java.io.Closeable, java.io.Flushable\n+{\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    protected final DefaultSerializerProvider _provider;\n+    protected final SerializationConfig _config;\n+    protected final JsonGenerator _generator;\n+\n+    protected final JsonSerializer<Object> _rootSerializer;\n+    protected final TypeSerializer _typeSerializer;\n+    \n+    protected final boolean _closeGenerator;\n+    protected final boolean _cfgFlush;\n+    protected final boolean _cfgCloseCloseable;\n+\n+    /*\n+    /**********************************************************\n+    /* State\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * If {@link #_rootSerializer} is not defined (no root type\n+     * was used for constructing {@link ObjectWriter}), we will\n+     * use simple scheme for keeping track of serializers needed.\n+     * Assumption is that\n+     */\n+    protected PropertySerializerMap _dynamicSerializers;\n+    \n+    /**\n+     * State flag for keeping track of need to write matching END_ARRAY,\n+     * if a START_ARRAY was written during initialization\n+     */\n+    protected boolean _openArray;\n+    protected boolean _closed;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public SequenceWriter(DefaultSerializerProvider prov, JsonGenerator gen,\n+            boolean closeGenerator, ObjectWriter.Prefetch prefetch)\n+        throws IOException\n+    {\n+        _provider = prov;\n+        _generator = gen;\n+        _closeGenerator = closeGenerator;\n+        _rootSerializer = prefetch.valueSerializer;\n+        _typeSerializer = prefetch.typeSerializer;\n+\n+        _config = prov.getConfig();\n+        _cfgFlush = _config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE);\n+        _cfgCloseCloseable = _config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE);\n+        // important: need to cache \"root value\" serializers, to handle polymorphic\n+        // types properly\n+        _dynamicSerializers = PropertySerializerMap.emptyForRootValues();\n+    }\n+\n+    public SequenceWriter init(boolean wrapInArray) throws IOException\n+    {\n+        if (wrapInArray) {\n+            _generator.writeStartArray();\n+            _openArray = true;\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, basic accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will return version information stored in and read from jar\n+     * that contains this class.\n+     */\n+    @Override\n+    public Version version() {\n+        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, write operations, related\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for writing given value into output, as part of sequence\n+     * to write. If root type was specified for {@link ObjectWriter},\n+     * value must be of compatible type (same or subtype).\n+     */\n+    public SequenceWriter write(Object value) throws IOException\n+    {\n+        if (value == null) {\n+            _provider.serializeValue(_generator, null);\n+            return this;\n+        }\n+        \n+        if (_cfgCloseCloseable && (value instanceof Closeable)) {\n+            return _writeCloseableValue(value);\n+        }\n+        JsonSerializer<Object> ser = _rootSerializer;\n+        if (ser == null) {\n+            Class<?> type = value.getClass();\n+            ser = _dynamicSerializers.serializerFor(type);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(type);\n+            }\n+        }\n+        _provider.serializeValue(_generator, value, null, ser);\n+        if (_cfgFlush) {\n+            _generator.flush();\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for writing given value into output, as part of sequence\n+     * to write; further, full type (often generic, like {@link java.util.Map}\n+     * is passed in case a new\n+     * {@link JsonSerializer} needs to be fetched to handle type\n+     * \n+     * If root type was specified for {@link ObjectWriter},\n+     * value must be of compatible type (same or subtype).\n+     */\n+    public SequenceWriter write(Object value, JavaType type) throws IOException\n+    {\n+        if (value == null) {\n+            _provider.serializeValue(_generator, null);\n+            return this;\n+        }\n+        \n+        if (_cfgCloseCloseable && (value instanceof Closeable)) {\n+            return _writeCloseableValue(value, type);\n+        }\n+        /* 15-Dec-2014, tatu: I wonder if this could be come problematic. It shouldn't\n+         *   really, since trying to use differently paramterized types in a sequence\n+         *   is likely to run into other issues. But who knows; if it does become an\n+         *   issue, may need to implement alternative, JavaType-based map.\n+         */\n+        JsonSerializer<Object> ser = _dynamicSerializers.serializerFor(type.getRawClass());\n+        if (ser == null) {\n+            ser = _findAndAddDynamic(type);\n+        }\n+        _provider.serializeValue(_generator, value, type, ser);\n+        if (_cfgFlush) {\n+            _generator.flush();\n+        }\n+        return this;\n+    }\n+\n+    public SequenceWriter writeAll(Object[] value) throws IOException\n+    {\n+        for (int i = 0, len = value.length; i < len; ++i) {\n+            write(value[i]);\n+        }\n+        return this;\n+    }\n+\n+    public <C extends Collection<?>> SequenceWriter writeAll(C container) throws IOException\n+    {\n+        for (Object value : container) {\n+            write(value);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        if (!_closed) {\n+            _generator.flush();\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException\n+    {\n+        if (!_closed) {\n+            _closed = true;\n+            if (_openArray) {\n+                _openArray = false;\n+                _generator.writeEndArray();\n+            }\n+            if (_closeGenerator) {\n+                _generator.close();\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal helper methods, serializer lookups\n+    /**********************************************************\n+     */\n+\n+    protected SequenceWriter _writeCloseableValue(Object value) throws IOException\n+    {\n+        Closeable toClose = (Closeable) value;\n+        try {\n+            JsonSerializer<Object> ser = _rootSerializer;\n+            if (ser == null) {\n+                Class<?> type = value.getClass();\n+                ser = _dynamicSerializers.serializerFor(type);\n+                if (ser == null) {\n+                    ser = _findAndAddDynamic(type);\n+                }\n+            }\n+            _provider.serializeValue(_generator, value, null, ser);\n+            if (_cfgFlush) {\n+                _generator.flush();\n+            }\n+            Closeable tmpToClose = toClose;\n+            toClose = null;\n+            tmpToClose.close();\n+        } finally {\n+            if (toClose != null) {\n+                try {\n+                    toClose.close();\n+                } catch (IOException ioe) { }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    protected SequenceWriter _writeCloseableValue(Object value, JavaType type) throws IOException\n+    {\n+        Closeable toClose = (Closeable) value;\n+        try {\n+            // 15-Dec-2014, tatu: As per above, could be problem that we do not pass generic type\n+            JsonSerializer<Object> ser = _dynamicSerializers.serializerFor(type.getRawClass());\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(type);\n+            }\n+            _provider.serializeValue(_generator, value, type, ser);\n+            if (_cfgFlush) {\n+                _generator.flush();\n+            }\n+            Closeable tmpToClose = toClose;\n+            toClose = null;\n+            tmpToClose.close();\n+        } finally {\n+            if (toClose != null) {\n+                try {\n+                    toClose.close();\n+                } catch (IOException ioe) { }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    private final JsonSerializer<Object> _findAndAddDynamic(Class<?> type) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result;\n+        if (_typeSerializer == null) {\n+            result = _dynamicSerializers.findAndAddRootValueSerializer(type, _provider);\n+        } else {\n+            result = _dynamicSerializers.addSerializer(type,\n+                    new TypeWrappedSerializer(_typeSerializer, _provider.findValueSerializer(type, null)));\n+        }\n+        _dynamicSerializers = result.map;\n+        return result.serializer;\n+    }\n+\n+    private final JsonSerializer<Object> _findAndAddDynamic(JavaType type) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result;\n+        if (_typeSerializer == null) {\n+            result = _dynamicSerializers.findAndAddRootValueSerializer(type, _provider);\n+        } else {\n+            result = _dynamicSerializers.addSerializer(type,\n+                    new TypeWrappedSerializer(_typeSerializer, _provider.findValueSerializer(type, null)));\n+        }\n+        _dynamicSerializers = result.map;\n+        return result.serializer;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n-import com.fasterxml.jackson.core.Base64Variant;\n+import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n     extends MapperConfigBase<SerializationFeature, SerializationConfig>\n     implements java.io.Serializable // since 2.1\n {\n-    // Valid as of 2.4\n-    private static final long serialVersionUID = -1278867172535832879L;\n-\n-    /**\n-     * Set of features enabled; actual type (kind of features)\n-     * depends on sub-classes.\n+    // since 2.5\n+    private static final long serialVersionUID = 1;\n+\n+    /**\n+     * Set of {@link SerializationFeature}s enabled.\n      */\n     protected final int _serFeatures;\n     \n      * Non-null if explicitly defined; null by default.\n      */\n     protected final FilterProvider _filterProvider;\n+\n+    /**\n+     * States of {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s to enable/disable.\n+     */\n+    protected final int _generatorFeatures;\n+\n+    /**\n+     * Bitflag of {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s to enable/disable\n+     */\n+    protected final int _generatorFeaturesToChange;\n     \n     /*\n     /**********************************************************\n         super(base, str, mixins);\n         _serFeatures = collectFeatureDefaults(SerializationFeature.class);\n         _filterProvider = null;\n+        _generatorFeatures = 0;\n+        _generatorFeaturesToChange = 0;\n     }\n     \n     private SerializationConfig(SerializationConfig src, SubtypeResolver str)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n-    }\n-\n-    private SerializationConfig(SerializationConfig src, int mapperFeatures, int serFeatures)\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n+    }\n+\n+    private SerializationConfig(SerializationConfig src,\n+            int mapperFeatures, int serFeatures,\n+            int generatorFeatures, int generatorFeatureMask)\n     {\n         super(src, mapperFeatures);\n         _serFeatures = serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = generatorFeatures;\n+        _generatorFeaturesToChange = generatorFeatureMask;\n     }\n     \n     private SerializationConfig(SerializationConfig src, BaseSettings base)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     private SerializationConfig(SerializationConfig src, FilterProvider filters)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = filters;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     private SerializationConfig(SerializationConfig src, Class<?> view)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     private SerializationConfig(SerializationConfig src, JsonInclude.Include incl)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = incl;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     private SerializationConfig(SerializationConfig src, String rootName)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     /**\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     /**\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n     \n     /*\n             newMapperFlags |= f.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this\n-                : new SerializationConfig(this, newMapperFlags, _serFeatures);\n+                : new SerializationConfig(this, newMapperFlags, _serFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n     \n     /**\n              newMapperFlags &= ~f.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this\n-                : new SerializationConfig(this, newMapperFlags, _serFeatures);\n+                : new SerializationConfig(this, newMapperFlags, _serFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     @Override\n         } else {\n             newMapperFlags = _mapperFeatures & ~feature.getMask();\n         }\n-        return (newMapperFlags == _mapperFeatures) ? this :\n-            new SerializationConfig(this, newMapperFlags, _serFeatures);\n+        return (newMapperFlags == _mapperFeatures) ? this\n+            : new SerializationConfig(this, newMapperFlags, _serFeatures,\n+                    _generatorFeatures, _generatorFeaturesToChange);\n     }\n     \n     @Override\n     public SerializationConfig with(ClassIntrospector ci) {\n         return _withBase(_base.withClassIntrospector(ci));\n     }\n-    \n+\n     /**\n      * In addition to constructing instance with specified date format,\n      * will enable or disable <code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code>\n         }\n         return cfg;\n     }\n-    \n+\n     @Override\n     public SerializationConfig with(HandlerInstantiator hi) {\n         return _withBase(_base.withHandlerInstantiator(hi));\n     }\n-    \n+\n     @Override\n     public SerializationConfig with(PropertyNamingStrategy pns) {\n         return _withBase(_base.withPropertyNamingStrategy(pns));\n     public SerializationConfig with(TypeResolverBuilder<?> trb) {\n         return _withBase(_base.withTypeResolverBuilder(trb));\n     }\n-    \n+\n     @Override\n     public SerializationConfig withView(Class<?> view) {\n         return (_view == view) ? this : new SerializationConfig(this, view);\n     public SerializationConfig with(ContextAttributes attrs) {\n         return (attrs == _attributes) ? this : new SerializationConfig(this, attrs);\n     }\n-    \n+\n     private final SerializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new SerializationConfig(this, newBase);\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Life-cycle, SerializationConfig specific factory methods\n-    /**********************************************************\n-     */\n-        \n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods for SerializationFeature\n+    /**********************************************************\n+     */\n+\n     /**\n      * Fluent factory method that will construct and return a new configuration\n      * object instance with specified feature enabled.\n     {\n         int newSerFeatures = _serFeatures | feature.getMask();\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     /**\n             newSerFeatures |= f.getMask();\n         }\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n-    }\n-    \n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n+    }\n+\n     /**\n      * Fluent factory method that will construct and return a new configuration\n      * object instance with specified features enabled.\n             newSerFeatures |= f.getMask();\n         }\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     /**\n     {\n         int newSerFeatures = _serFeatures & ~feature.getMask();\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     /**\n             newSerFeatures &= ~f.getMask();\n         }\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     /**\n             newSerFeatures &= ~f.getMask();\n         }\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n-    }\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods for JsonGenerator.Feature\n+    /**********************************************************\n+     */\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature enabled.\n+     *\n+     * @since 2.5\n+     */\n+    public SerializationConfig with(JsonGenerator.Feature feature)\n+    {\n+        int newSet = _generatorFeatures | feature.getMask();\n+        int newMask = _generatorFeaturesToChange | feature.getMask();\n+        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n+            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     *\n+     * @since 2.5\n+     */\n+    public SerializationConfig withFeatures(JsonGenerator.Feature... features)\n+    {\n+        int newSet = _generatorFeatures;\n+        int newMask = _generatorFeaturesToChange;\n+        for (JsonGenerator.Feature f : features) {\n+            int mask = f.getMask();\n+            newSet |= mask;\n+            newMask |= mask;\n+        }\n+        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n+            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature disabled.\n+     *\n+     * @since 2.5\n+     */\n+    public SerializationConfig without(JsonGenerator.Feature feature)\n+    {\n+        int newSet = _generatorFeatures & ~feature.getMask();\n+        int newMask = _generatorFeaturesToChange | feature.getMask();\n+        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n+            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     *\n+     * @since 2.5\n+     */\n+    public SerializationConfig withoutFeatures(JsonGenerator.Feature... features)\n+    {\n+        int newSet = _generatorFeatures;\n+        int newMask = _generatorFeaturesToChange;\n+        for (JsonGenerator.Feature f : features) {\n+            int mask = f.getMask();\n+            newSet &= ~mask;\n+            newMask |= mask;\n+        }\n+        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n+            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods, other\n+    /**********************************************************\n+     */\n     \n     public SerializationConfig withFilters(FilterProvider filterProvider) {\n         return (filterProvider == _filterProvider) ? this : new SerializationConfig(this, filterProvider);\n     public SerializationConfig withSerializationInclusion(JsonInclude.Include incl) {\n         return (_serializationInclusion == incl) ? this:  new SerializationConfig(this, incl);\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonParser initialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called by {@link ObjectMapper} and {@link ObjectWriter}\n+     * to modify those {@link com.fasterxml.jackson.core.JsonGenerator.Feature} settings\n+     * that have been configured via this config instance.\n+     * \n+     * @since 2.5\n+     */\n+    public void initialize(JsonGenerator g)\n+    {\n+        if (SerializationFeature.INDENT_OUTPUT.enabledIn(_serFeatures)) {\n+            g.useDefaultPrettyPrinter();\n+        }\n+        @SuppressWarnings(\"deprecation\")\n+        boolean useBigDec = SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_serFeatures);\n+        if ((_generatorFeaturesToChange != 0) || useBigDec) {\n+            int orig = g.getFeatureMask();\n+            int newFlags = (orig & ~_generatorFeaturesToChange) | _generatorFeatures;\n+            // although deprecated, needs to be supported for now\n+            if (useBigDec) {\n+                newFlags |= JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN.getMask();\n+            }\n+            if (orig != newFlags) {\n+                g.setFeatureMask(newFlags);\n+            }\n+        }\n+    }\n     \n     /*\n     /**********************************************************\n     /* MapperConfig implementation/overrides\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public boolean useRootWrapping()\n     {\n         }\n         return isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n     }\n-    \n+\n     @Override\n     public AnnotationIntrospector getAnnotationIntrospector()\n     {\n-        /* 29-Jul-2009, tatu: it's now possible to disable use of\n-         *   annotations; can be done using \"no-op\" introspector\n-         */\n         if (isEnabled(MapperFeature.USE_ANNOTATIONS)) {\n             return super.getAnnotationIntrospector();\n         }\n     public BeanDescription introspectDirectClassAnnotations(JavaType type) {\n         return getClassIntrospector().forDirectClassAnnotations(this, type, this);\n     }\n-    \n+\n     @Override\n     public VisibilityChecker<?> getDefaultVisibilityChecker()\n     {\n         }\n         return vchecker;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Configuration: other\n         return (_serFeatures & f.getMask()) != 0;\n     }\n \n+    /**\n+     * Accessor method that first checks if we have any overrides\n+     * for feature, and only if not, checks state of passed-in\n+     * factory.\n+     * \n+     * @since 2.5\n+     */\n+    public final boolean isEnabled(JsonGenerator.Feature f, JsonFactory factory) {\n+        int mask = f.getMask();\n+        if ((_generatorFeaturesToChange & mask) != 0) {\n+            return (_generatorFeatures & f.getMask()) != 0;\n+        }\n+        return factory.isEnabled(f);\n+    }\n+    \n     /**\n      * \"Bulk\" access method for checking that all features specified by\n      * mask are enabled.\n     public final int getSerializationFeatures() {\n         return _serFeatures;\n     }\n-    \n+\n     public JsonInclude.Include getSerializationInclusion()\n     {\n         if (_serializationInclusion != null) {\n         }\n         return JsonInclude.Include.ALWAYS;\n     }\n-    \n+\n     /**\n      * Method for getting provider used for locating filters given\n      * id (which is usually provided with filter annotations).\n     public FilterProvider getFilterProvider() {\n         return _filterProvider;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Introspection methods\n     /* Debug support\n     /**********************************************************\n      */\n-    \n-    @Override public String toString()\n-    {\n+\n+    @Override\n+    public String toString() {\n         return \"[SerializationConfig: flags=0x\"+Integer.toHexString(_serFeatures)+\"]\";\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n     /* Generic output features\n     /******************************************************\n      */\n-    \n+\n     /**\n      * Feature that can be enabled to make root value (usually JSON\n      * Object but can be any type) wrapped within a single property\n      * method to use any <code>PrettyPrinter</code> instance.\n      * This feature will only allow using the default implementation.\n      *<p>\n-     * Feature is enabled by default.\n+     * Feature is disabled by default.\n      */\n     INDENT_OUTPUT(false),\n-    \n+\n     /*\n     /******************************************************\n     /* Error handling features\n     /******************************************************\n      */\n-    \n+\n     /**\n      * Feature that determines what happens when no accessors are\n      * found for a type (and there are no annotations to indicate\n      * @since 2.4\n      */\n     FAIL_ON_SELF_REFERENCES(true),\n-    \n+\n     /**\n      * Feature that determines whether Jackson code should catch\n      * and wrap {@link Exception}s (but never {@link Error}s!)\n     /* Output life cycle features\n     /******************************************************\n      */\n-    \n+\n      /**\n       * Feature that determines whether <code>close</code> method of\n       * serialized <b>root level</b> objects (ones for which <code>ObjectMapper</code>'s\n       * writeValue() (or equivalent) method is called)\n-      * that implement {@link java.io.Closeable} \n+      * that implement {@link java.io.Closeable}\n       * is called after serialization or not. If enabled, <b>close()</b> will\n       * be called after serialization completes (whether succesfully, or\n       * due to an error manifested by an exception being thrown). You can\n      * Feature is enabled by default.\n      */\n     FLUSH_AFTER_WRITE_VALUE(true),\n-     \n+\n     /*\n     /******************************************************\n     /* Datatype-specific serialization configuration\n      * Note: whether {@link java.util.Map} keys are serialized as Strings\n      * or not is controlled using {@link #WRITE_DATE_KEYS_AS_TIMESTAMPS}.\n      *<p>\n-     * Feature is enabled by default.\n+     * Feature is enabled by default, so that date/time are by default\n+     * serialized as timestamps.\n      */\n     WRITE_DATES_AS_TIMESTAMPS(true),\n+\n+    /**\n+     * Feature that determines whether time values that represents time periods\n+     * (durations, periods, ranges) are to be serialized by default using\n+     * a numeric (true) or textual (false) representations. Note that numeric\n+     * representation may mean either simple number, or an array of numbers,\n+     * depending on type.\n+     *<p>\n+     * Note: whether {@link java.util.Map} keys are serialized as Strings\n+     * or not is controlled using {@link #WRITE_DATE_KEYS_AS_TIMESTAMPS}.\n+     *<p>\n+     * Feature is enabled by default, so that period/duration are by default\n+     * serialized as timestamps.\n+     * \n+     * @since 2.5\n+     */\n+    WRITE_DURATIONS_AS_TIMESTAMPS(true),\n \n     /**\n      * Feature that determines whether {@link java.util.Date}s\n      * Feature is disabled by default.\n      */\n     WRITE_ENUMS_USING_INDEX(false),\n-    \n+\n     /**\n      * Feature that determines whether Map entries with null values are\n      * to be serialized (true) or not (false).\n      * Feature is enabled by default.\n      */\n     WRITE_EMPTY_JSON_ARRAYS(true),\n-    \n+\n     /**\n      * Feature added for interoperability, to work with oddities of\n      * so-called \"BadgerFish\" convention.\n      * support it.\n      *<p>\n      * Feature is disabled by default.\n-     */\n+     * \n+     * @deprecated Since 2.5: use {@link com.fasterxml.jackson.core.JsonGenerator.Feature#WRITE_BIGDECIMAL_AS_PLAIN} directly\n+     *    (using {@link ObjectWriter#with(com.fasterxml.jackson.core.JsonGenerator.Feature)}).\n+     */\n+    @Deprecated // since 2.5\n     WRITE_BIGDECIMAL_AS_PLAIN(false),\n-    \n+\n     /**\n      * Feature that controls whether numeric timestamp values are\n      * to be written using nanosecond timestamps (enabled) or not (disabled);\n      * This is the counterpart to {@link SerializationFeature#WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS}.\n      *<p>\n      * Feature is enabled by default, to support most accurate time values possible.\n-     * \n+     *\n      * @since 2.2\n      */\n-    WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS(true),    \n-    \n+    WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS(true),\n+\n     /**\n      * Feature that determines whether {@link java.util.Map} entries are first\n      * sorted by key before serialization or not: if enabled, additional sorting\n      * feature: only consider that if there are actual perceived problems.\n      *<p>\n      * Feature is enabled by default.\n-     * \n+     *\n      * @since 2.1\n      */\n     EAGER_SERIALIZER_FETCH(true),\n      *<p>\n      * Feature is disabled by default; meaning that strict identity is used, not\n      * <code>equals()</code>\n-     * \n+     *\n      * @since 2.3\n      */\n     USE_EQUALITY_FOR_OBJECT_ID(false)\n     ;\n \n     private final boolean _defaultState;\n+    private final int _mask;\n     \n     private SerializationFeature(boolean defaultState) {\n         _defaultState = defaultState;\n+        _mask = (1 << ordinal());\n     }\n \n     @Override\n     public boolean enabledByDefault() { return _defaultState; }\n \n+\n     @Override\n-    public int getMask() { return (1 << ordinal()); }\n+    public int getMask() { return _mask; }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n public abstract class SerializerProvider\n     extends DatabindContext\n {\n-    @Deprecated // since 2.3, not used by anything it seems\n-    protected final static JavaType TYPE_OBJECT = TypeFactory.defaultInstance().uncheckedSimpleType(Object.class);\n-\n     /**\n      * Setting for determining whether mappings for \"unknown classes\" should be\n      * cached for faster resolution. Usually this isn't needed, but maybe it\n     }\n \n     /**\n-     * Copy-constructor used when making a {@link #copy} of a blueprint\n-     * object.\n+     * Copy-constructor used when making a copy of a blueprint instance.\n      * \n      * @since 2.4.4\n      */\n      *   finding any serializer\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public JsonSerializer<Object> findValueSerializer(Class<?> valueType,\n-            BeanProperty property)\n+    public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property)\n         throws JsonMappingException\n     {\n         // Fast lookup from local lookup thingy works?\n                 if (ser == null) {\n                     // If neither, must create\n                     ser = _createAndCacheUntypedSerializer(valueType);\n-                    // Not found? Must use the unknown type serializer\n-                    /* Couldn't create? Need to return the fallback serializer, which\n-                     * most likely will report an error: but one question is whether\n-                     * we should cache it?\n-                     */\n+                    // Not found? Must use the unknown type serializer, which will report error later on\n                     if (ser == null) {\n                         ser = getUnknownTypeSerializer(valueType);\n                         // Should this be added to lookups?\n     public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property)\n         throws JsonMappingException\n     {\n-        // Fast lookup from local lookup thingy works?\n+        // (see comments from above method)\n         JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n         if (ser == null) {\n-            // If not, maybe shared map already has it?\n             ser = _serializerCache.untypedValueSerializer(valueType);\n             if (ser == null) {\n-                // If neither, must create\n                 ser = _createAndCacheUntypedSerializer(valueType);\n-                // Not found? Must use the unknown type serializer\n-                /* Couldn't create? Need to return the fallback serializer, which\n-                 * most likely will report an error: but one question is whether\n-                 * we should cache it?\n-                 */\n                 if (ser == null) {\n                     ser = getUnknownTypeSerializer(valueType.getRawClass());\n-                    // Should this be added to lookups?\n                     if (CACHE_UNKNOWN_MAPPINGS) {\n                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                     }\n         return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);\n     }\n \n+    /**\n+     * Method variant used when we do NOT want contextualization to happen; it will need\n+     * to be handled at a later point, but caller wants to be able to do that\n+     * as needed; sometimes to avoid infinite loops\n+     * \n+     * @since 2.5\n+     */\n+    public JsonSerializer<Object> findValueSerializer(Class<?> valueType) throws JsonMappingException\n+    {\n+        // (see comments from above method)\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType));\n+                if (ser == null) {\n+                    ser = _createAndCacheUntypedSerializer(valueType);\n+                    if (ser == null) {\n+                        ser = getUnknownTypeSerializer(valueType);\n+                        if (CACHE_UNKNOWN_MAPPINGS) {\n+                            _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return ser;\n+    }\n+\n+    /**\n+     * Method variant used when we do NOT want contextualization to happen; it will need\n+     * to be handled at a later point, but caller wants to be able to do that\n+     * as needed; sometimes to avoid infinite loops\n+     * \n+     * @since 2.5\n+     */\n+    public JsonSerializer<Object> findValueSerializer(JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        // (see comments from above method)\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                ser = _createAndCacheUntypedSerializer(valueType);\n+                if (ser == null) {\n+                    ser = getUnknownTypeSerializer(valueType.getRawClass());\n+                    if (CACHE_UNKNOWN_MAPPINGS) {\n+                        _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                    }\n+                }\n+            }\n+        }\n+        return ser;\n+    }\n+    \n     /**\n      * Similar to {@link #findValueSerializer(JavaType, BeanProperty)}, but used\n      * when finding \"primary\" property value serializer (one directly handling\n         return _unknownTypeSerializer;\n     }\n \n+    /**\n+     * Helper method called to see if given serializer is considered to be\n+     * something returned by {@link #getUnknownTypeSerializer}, that is, something\n+     * for which no regular serializer was found or constructed.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isUnknownTypeSerializer(JsonSerializer<?> ser) {\n+        return (ser == _unknownTypeSerializer) || (ser == null);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Methods for creating instances based on annotations\n     /**********************************************************\n      */\n \n-    /**\n-     * @deprecated Since 2.3 (and to be removed from 2.4); use\n-     *   {@link #handlePrimaryContextualization} or {@link #handleSecondaryContextualization}\n-     *   instead\n-     */\n-    @Deprecated\n-    public JsonSerializer<?> handleContextualization(JsonSerializer<?> ser,\n-            BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        return handleSecondaryContextualization(ser, property);\n-    }\n-    \n     /**\n      * Method called for primary property serializers (ones\n      * directly created to serialize values of a POJO property),\n      * @return Serializer if one can be found, null if not.\n      */\n     protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType)\n-\t\tthrows JsonMappingException\n+        throws JsonMappingException\n     {        \n         // Fast lookup from local lookup thingy works?\n         JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(runtimeType);\n-        if (ser != null) {\n-            return ser;\n-        }\n-        // If not, maybe shared map already has it?\n-        ser = _serializerCache.untypedValueSerializer(runtimeType);\n-        if (ser != null) {\n-            return ser;\n-        }\n-        return _createAndCacheUntypedSerializer(runtimeType);\n+        if (ser == null) {\n+            // If not, maybe shared map already has it?\n+            ser = _serializerCache.untypedValueSerializer(runtimeType);\n+            if (ser == null) {\n+                ser = _createAndCacheUntypedSerializer(runtimeType);\n+                /* 18-Sep-2014, tatu: This is unfortunate patch over related change\n+                 *    that pushes creation of \"unknown type\" serializer deeper down\n+                 *    in BeanSerializerFactory; as a result, we need to \"undo\" creation\n+                 *    here.\n+                 */\n+                if (isUnknownTypeSerializer(ser)) {\n+                    return null;\n+                }\n+            }\n+        }\n+        return ser;\n     }\n \n     /*\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonAppend.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n+\n+/**\n+ * Annotation that may be used to add \"virtual\" properties to be written\n+ * after regular properties (although ordering may be changed using\n+ * both standard <code>@JsonPropertyOrder</code> annotation, and\n+ * properties of this annotation).\n+ * \n+ * @since 2.5\n+ */\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.TYPE })\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonAppend\n+{\n+    /**\n+     * Set of attribute-backed properties to include when serializing\n+     * a POJO.\n+     */\n+    public Attr[] attrs() default { };\n+\n+    /**\n+     * Set of general virtual properties to include when serializing a POJO.\n+     */\n+    public Prop[] props() default { };\n+\n+    /**\n+     * Indicator used to determine whether properties defined are to be\n+     * appended before (false) or prepended before (true) regular properties.\n+     * Affects all kinds of properties defined using this annotation.\n+     */\n+    public boolean prepend() default false;\n+    \n+    /**\n+     * Definition of a single attribute-backed property.\n+     * Attribute-backed properties will be appended after regular properties\n+     * in specified order, although their placement may be further changed\n+     * by the usual property-ordering functionality (alphabetic sorting;\n+     * explicit ordering)\n+     */\n+    public @interface Attr\n+    {\n+        /**\n+         * Name of attribute of which value to serialize. Is also used as the\n+         * name of external property to write, unless overridden by\n+         * assigning a value for {@link #propName()}.\n+         */\n+        public String value();\n+\n+        /**\n+         * Name to use for serializing value of the attribute; if not defined,\n+         * {@link #value} will be used instead.\n+         */\n+        public String propName() default \"\";\n+\n+        /**\n+         * Optional namespace to use; only relevant for data formats that use\n+         * namespaces (like XML).\n+         */\n+        public String propNamespace() default \"\";\n+\n+        /**\n+         * When to include attribute-property. Default value indicates that\n+         * property should only be written if specified attribute has a non-null\n+         * value.\n+         */\n+        public JsonInclude.Include include() default JsonInclude.Include.NON_NULL;\n+\n+        /**\n+         * Metadata about property, similar to\n+         * {@link com.fasterxml.jackson.annotation.JsonProperty#required()}.\n+         */\n+        public boolean required() default false;\n+    }\n+    \n+    /**\n+     * Definition of a single general virtual property.\n+     */\n+    public @interface Prop\n+    {\n+        /**\n+         * Actual implementation class (a subtype of {@link VirtualBeanPropertyWriter})\n+         * of the property to instantiate (using the no-argument default constructor).\n+         */\n+        public Class<? extends VirtualBeanPropertyWriter> value();\n+\n+        /**\n+         * Name of the property to possibly use for serializing (although implementation\n+         * may choose to not use this information).\n+         */\n+        public String name() default \"\";\n+\n+        /**\n+         * Optional namespace to use along with {@link #name};\n+         * only relevant for data formats that use namespaces (like XML).\n+         */\n+        public String namespace() default \"\";\n+\n+        /**\n+         * When to include  value of the property. Default value indicates that\n+         * property should only be written if specified attribute has a non-null\n+         * value. As with other properties, actual property implementation may or may\n+         * not choose to use this inclusion information.\n+         */\n+        public JsonInclude.Include include() default JsonInclude.Include.NON_NULL;\n+\n+        /**\n+         * Metadata about property, similar to\n+         * {@link com.fasterxml.jackson.annotation.JsonProperty#required()}.\n+         */\n+        public boolean required() default false;\n+\n+        /**\n+         * Nominal type of the property. Passed as type information for related\n+         * virtual objects, and may (or may not be) used by implementation\n+         * for choosing serializer to use.\n+         */\n+        public Class<?> type() default Object.class;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonNaming.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonNaming.java\n @com.fasterxml.jackson.annotation.JacksonAnnotation\n public @interface JsonNaming\n {\n-    public Class<? extends PropertyNamingStrategy> value();\n+    /**\n+     * @return Type of {@link PropertyNamingStrategy} to use, if any; default value of\n+     *    <code>PropertyNamingStrategy.class</code> means \"no strategy specified\"\n+     *    (and may also be used for overriding to remove otherwise applicable\n+     *    naming strategy)\n+     */\n+    public Class<? extends PropertyNamingStrategy> value() default PropertyNamingStrategy.class;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/NoClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/NoClass.java\n  * as either default or explicit values. Hence for class values we must\n  * explicitly use a bogus placeholder to denote equivalent of\n  * \"no class\" (for which 'null' is usually the natural choice).\n- * \n- * @deprecated Since 2.4 use {@link java.lang.Void} instead as the general\n- *   \"no class specified\" marker.\n+ *<p>\n+ * Note that since 2.4, most (but not all!\n+ * {@link com.fasterxml.jackson.annotation.JsonTypeInfo#defaultImpl} is\n+ * a notable exception}) usage should start using\n+ * {@link java.lang.Void} instead as the \"not defined\" marker.\n  */\n-@Deprecated\n public final class NoClass\n {\n     private NoClass() { }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializerFactoryConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializerFactoryConfig.java\n public class DeserializerFactoryConfig\n     implements java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = 3683541151102256824L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     protected final static Deserializers[] NO_DESERIALIZERS = new Deserializers[0];\n     protected final static BeanDeserializerModifier[] NO_MODIFIERS = new BeanDeserializerModifier[0];\n      * are configured and constructed.\n      */\n     protected final BeanDeserializerModifier[] _modifiers;\n-\n \n     /**\n      * List of objects that may be able to resolve abstract types to\n      * or to support post-constructor functionality.\n      */\n     protected final ValueInstantiators[] _valueInstantiators;\n-    \n+\n     /**\n      * Constructor for creating basic configuration with no additional\n      * handlers.\n         return new DeserializerFactoryConfig(all, _additionalKeyDeserializers, _modifiers,\n                 _abstractTypeResolvers, _valueInstantiators);\n     }\n+\n     /**\n      * Fluent/factory method used to construct a configuration object that\n      * has same key deserializer providers as this instance, plus one specified\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n         return null;\n     }\n \n-    public ObjectIdResolver resolverIdGeneratorInstance(MapperConfig<?> config, Annotated annotated, Class<?> implClass)\n-    {\n+    public ObjectIdResolver resolverIdGeneratorInstance(MapperConfig<?> config, Annotated annotated, Class<?> implClass) {\n         return null;\n     }\n \n         return null;\n     }\n \n+    /**\n+     * Method called to construct a {@link VirtualBeanPropertyWriter} instance\n+     * of specified type.\n+     *\n+     * @since 2.5\n+     */\n+    public VirtualBeanPropertyWriter virtualPropertyWriterInstance(MapperConfig<?> config,\n+            Class<?> implClass) {\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n     implements ClassIntrospector.MixInResolver,\n         java.io.Serializable\n {\n-    private static final long serialVersionUID = 8891625428805876137L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     /**\n      * Set of shared mapper features enabled.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n     extends JsonDeserializer<Object>\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = -3010349050434697698L;\n+    private static final long serialVersionUID = 1L;\n \n     protected final JavaType _baseType;\n \n      * \n      * @since 2.3\n      */\n-    public static AbstractDeserializer constructForNonPOJO(BeanDescription beanDesc)\n-    {\n+    public static AbstractDeserializer constructForNonPOJO(BeanDescription beanDesc) {\n         return new AbstractDeserializer(beanDesc);\n     }\n     \n     /**********************************************************\n      */\n     \n-    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         /* As per [JACKSON-417], there is a chance we might be \"natural\" types\n          * (String, Boolean, Integer, Double), which do not include any type information...\n          * Finally, we may have to consider possibility of custom handlers for\n          * these values: but for now this should work ok.\n          */\n-        /* 21-Sep-2013, tatu: It may seem odd that I'm not using a switch here.\n-         *   But turns out that a switch on an enum generates an inner class...\n-         *   crazy! So this is to avoid that, simply since new class weighs about 1kB\n-         *   after compression.\n-         */\n-        final JsonToken t = jp.getCurrentToken();\n-        if (t.isScalarValue()) {\n-            if (t == JsonToken.VALUE_STRING) {\n-                if (_acceptString) {\n-                    return jp.getText();\n-                }\n-            } else if (t == JsonToken.VALUE_NUMBER_INT) {\n-                if (_acceptInt) {\n-                    return jp.getIntValue();\n-                }\n-            } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-                if (_acceptDouble) {\n-                    return Double.valueOf(jp.getDoubleValue());\n-                }\n-            } else if (t == JsonToken.VALUE_TRUE) {\n-                if (_acceptBoolean) {\n-                    return Boolean.TRUE;\n-                }\n-            } else if (t == JsonToken.VALUE_FALSE) {\n-                if (_acceptBoolean) {\n-                    return Boolean.FALSE;\n-                }\n-            }\n+        switch (jp.getCurrentTokenId()) {\n+        case JsonTokenId.ID_STRING:\n+            if (_acceptString) {\n+                return jp.getText();\n+            }\n+            break;\n+        case JsonTokenId.ID_NUMBER_INT:\n+            if (_acceptInt) {\n+                return jp.getIntValue();\n+            }\n+            break;\n+        case JsonTokenId.ID_NUMBER_FLOAT:\n+            if (_acceptDouble) {\n+                return Double.valueOf(jp.getDoubleValue());\n+            }\n+            break;\n+        case JsonTokenId.ID_TRUE:\n+            if (_acceptBoolean) {\n+                return Boolean.TRUE;\n+            }\n+            break;\n+        case JsonTokenId.ID_FALSE:\n+            if (_acceptBoolean) {\n+                return Boolean.FALSE;\n+            }\n+            break;\n         }\n         return null;\n     }\n      * Method called in cases where it looks like we got an Object Id\n      * to parse and use as a reference.\n      */\n-    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         Object id = _objectIdReader.readObjectReference(jp, ctxt);\n         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n import java.lang.reflect.Method;\n import java.util.*;\n import java.util.concurrent.*;\n-\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.core.JsonLocation;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n import com.fasterxml.jackson.databind.deser.std.*;\n+import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n     private final static Class<?> CLASS_STRING = String.class;\n     private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n     private final static Class<?> CLASS_ITERABLE = Iterable.class;\n+    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n \n     /**\n      * We need a placeholder for creator properties that don't have name\n         _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n         _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n \n-        /* 11-Jan-2009, tatu: Let's see if we can still add support for\n-         *    JDK 1.6 interfaces, even if we run on 1.5. Just need to be\n-         *    more careful with typos, since compiler won't notice any\n-         *    problems...\n-         */\n-        _mapFallbacks.put(\"java.util.NavigableMap\", TreeMap.class);\n-        try {\n-            Class<?> key = java.util.concurrent.ConcurrentNavigableMap.class;\n-            Class<?> value = java.util.concurrent.ConcurrentSkipListMap.class;\n-            @SuppressWarnings(\"unchecked\")\n-                Class<? extends Map<?,?>> mapValue = (Class<? extends Map<?,?>>) value;\n-            _mapFallbacks.put(key.getName(), mapValue);\n-        } catch (Throwable e) { // some class loading problems are Errors, others Exceptions\n-            System.err.println(\"Problems with (optional) types: \"+e);\n-        }\n+        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n+        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n+                java.util.concurrent.ConcurrentSkipListMap.class);\n     }\n \n     /* We do some defaulting for abstract Collection classes and\n         VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n         vchecker = intr.findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n \n+        /* 24-Sep-2014, tatu: Tricky part first; need to merge resolved property information\n+         *  (which has creator parameters sprinkled around) with actual creator\n+         *  declarations (which are needed to access creator annotation, amongst other things).\n+         *  Easiest to combine that info first, then pass it to remaining processing.\n+         */\n+        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n+                beanDesc);\n+        \n         /* Important: first add factory methods; then constructors, so\n          * latter can override former!\n          */\n-        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators);\n+        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n         // constructors only usable on concrete types:\n         if (beanDesc.getType().isConcrete()) {\n-            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators);\n+            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n         }\n         return creators.constructValueInstantiator(config);\n     }\n \n+    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt,\n+            BeanDescription beanDesc) throws JsonMappingException\n+    {\n+        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n+        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n+            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n+            while (it.hasNext()) {\n+                AnnotatedParameter param = it.next();\n+                AnnotatedWithParams owner = param.getOwner();\n+                BeanPropertyDefinition[] defs = result.get(owner);\n+                final int index = param.getIndex();\n+                \n+                if (defs == null) {\n+                    if (result.isEmpty()) {\n+                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n+                    }\n+                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n+                    result.put(owner, defs);\n+                } else {\n+                    if (defs[index] != null) {\n+                        throw new IllegalStateException(\"Conflict: parameter #\"+index+\" of \"+owner\n+                                +\" bound to more than one property; \"+defs[index]+\" vs \"+propDef);\n+                    }\n+                }\n+                defs[index] = propDef;\n+            }\n+        }\n+        return result;\n+    }\n+    \n     public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config,\n             Annotated annotated, Object instDef)\n         throws JsonMappingException\n         return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                 config.canOverrideAccessModifiers());\n     }\n+\n+    @Deprecated // since 2.5.0, removed from 2.6.0\n+    protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+            AnnotationIntrospector intr, CreatorCollector creators)\n+        throws JsonMappingException\n+    {\n+        _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators,\n+                Collections.<AnnotatedWithParams,BeanPropertyDefinition[]>emptyMap());\n+    }\n     \n     protected void _addDeserializerConstructors\n         (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n-         AnnotationIntrospector intr, CreatorCollector creators)\n-        throws JsonMappingException\n-    {\n-        /* First things first: the \"default constructor\" (zero-arg\n-         * constructor; whether implicit or explicit) is NOT included\n-         * in list of constructors, so needs to be handled separately.\n-         */\n+         AnnotationIntrospector intr, CreatorCollector creators,\n+         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n+        throws JsonMappingException\n+    {\n+        // First things first: the \"default constructor\" (zero-arg\n+        // constructor; whether implicit or explicit) is NOT included\n+        // in list of constructors, so needs to be handled separately.\n         AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n         if (defaultCtor != null) {\n             if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) {\n                 creators.setDefaultCreator(defaultCtor);\n             }\n         }\n-\n-        PropertyName[] ctorPropNames = null;\n-        AnnotatedConstructor propertyCtor = null;\n-        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n-            if (propDef.getConstructorParameter() != null) {\n-                AnnotatedParameter param = propDef.getConstructorParameter();\n-                AnnotatedWithParams owner = param.getOwner();\n-                if (owner instanceof AnnotatedConstructor) {\n-                    if (propertyCtor == null) {\n-                        propertyCtor = (AnnotatedConstructor) owner;\n-                        ctorPropNames = new PropertyName[propertyCtor.getParameterCount()];\n+        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n+            final boolean isCreator = intr.hasCreatorAnnotation(ctor);\n+            BeanPropertyDefinition[] propDefs = creatorParams.get(ctor);\n+            final int argCount = ctor.getParameterCount();\n+\n+            // some single-arg factory methods (String, number) are auto-detected\n+            if (argCount == 1) {\n+                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n+                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, argDef);\n+\n+                if (useProps) {\n+                    CreatorProperty[] properties = new CreatorProperty[1];\n+                    PropertyName name = (argDef == null) ? null : argDef.getFullName();\n+                    AnnotatedParameter arg = ctor.getParameter(0);\n+                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, arg,\n+                            intr.findInjectableValueId(arg));\n+                    creators.addPropertyCreator(ctor, isCreator, properties);\n+                } else {\n+                    /*boolean added = */ _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n+                            ctor, isCreator,\n+                            vchecker.isCreatorVisible(ctor));\n+                    // one more thing: sever link to creator property, to avoid possible later\n+                    // problems with \"unresolved\" constructor property\n+                    if (argDef != null) {\n+                        ((POJOPropertyBuilder) argDef).removeConstructors();\n                     }\n-                    ctorPropNames[param.getIndex()] = propDef.getFullName();\n-                }\n-            }\n-        }\n-\n-        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n-            int argCount = ctor.getParameterCount();\n-            boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor;\n-            boolean isVisible =  vchecker.isCreatorVisible(ctor);\n-            // some single-arg constructors (String, number) are auto-detected\n-            if (argCount == 1) {\n-                PropertyName name = (ctor == propertyCtor) ? ctorPropNames[0] : null;\n-                _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n-                        ctor, isCreator, isVisible, name);\n+                }\n+                // regardless, fully handled\n                 continue;\n             }\n-            if (!isCreator && !isVisible) {\n-                continue;\n-            }\n-\n-            // [JACKSON-541] improved handling a bit so:\n-            // 2 or more args; all params must have name annotations\n-            // ... or @JacksonInject (or equivalent)\n-            /* [JACKSON-711] One more possibility; can have 1 or more injectables, and\n-             * exactly one non-annotated parameter: if so, it's still delegating.\n-             */\n-            AnnotatedParameter nonAnnotatedParam = null;\n-            int namedCount = 0;\n-            int injectCount = 0;\n+\n+            // 2 or more args; all params must have names or be injectable\n+            AnnotatedParameter nonAnnotatedParam = null;            \n             CreatorProperty[] properties = new CreatorProperty[argCount];\n+            int explicitNameCount = 0;\n+            int implicitNameCount = 0;\n+            int injectCount = 0;            \n             for (int i = 0; i < argCount; ++i) {\n-                AnnotatedParameter param = ctor.getParameter(i);\n-                PropertyName name = null;\n-                if (ctor == propertyCtor) {\n-                    name = ctorPropNames[i];\n-                }\n-                if (name == null) {\n-                    name = _findParamName(param, intr);\n-                }\n+                final AnnotatedParameter param = ctor.getParameter(i);\n+                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                 Object injectId = intr.findInjectableValueId(param);\n-                if (name != null && name.hasSimpleName()) {\n-                    ++namedCount;\n+                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n+                if (propDef != null && propDef.isExplicitlyNamed()) {\n+                    ++explicitNameCount;\n                     properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else if (injectId != null) { // injectable\n+                    continue;\n+                }\n+                if (injectId != null) {\n                     ++injectCount;\n                     properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else {\n-                    NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n-                    if (unwrapper != null) { // [Issue#265]: allow unwrapped properties\n-                        properties[i] = constructCreatorProperty(ctxt, beanDesc,\n-                                UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n-                        ++namedCount;\n-                    } else {\n-                        if (nonAnnotatedParam == null) {\n-                            nonAnnotatedParam = param;\n-                        }\n+                    continue;\n+                }\n+                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n+                if (unwrapper != null) {\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n+                    ++explicitNameCount;\n+                    continue;\n+                }\n+                // One more thing: implicit names are ok iff ctor has creator annotation\n+                if (isCreator) {\n+                    if (name != null && !name.isEmpty()) {\n+                        ++implicitNameCount;\n+                        properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n+                        continue;\n                     }\n                 }\n-            }\n-\n+                if (nonAnnotatedParam == null) {\n+                    nonAnnotatedParam = param;\n+                }\n+            }\n+\n+            final int namedCount = explicitNameCount + implicitNameCount;\n             // Ok: if named or injectable, we have more work to do\n-            if (isCreator || namedCount > 0 || injectCount > 0) {\n+            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                 // simple case; everything covered:\n                 if ((namedCount + injectCount) == argCount) {\n-                    creators.addPropertyCreator(ctor, properties);\n-                } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) {\n+                    creators.addPropertyCreator(ctor, isCreator, properties);\n+                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                     // [712] secondary: all but one injectable, one un-annotated (un-named)\n-                    creators.addDelegatingCreator(ctor, properties);\n-                } else { // otherwise, record the incomplete parameter for later error messaging.\n-                    creators.addIncompeteParameter(nonAnnotatedParam);\n-                }\n-            }\n-        }\n-    }\n-\n+                    creators.addDelegatingCreator(ctor, isCreator, properties);\n+                } else { // otherwise, epic fail\n+                    // 28-Dec-2014, tatu: Let's consider non-static inner class as a special case...\n+                    int ix = nonAnnotatedParam.getIndex();\n+                    if ((ix == 0) && ClassUtil.isNonStaticInnerClass(ctor.getDeclaringClass())) {\n+                        throw new IllegalArgumentException(\"Non-static inner classes like \"\n+                                +ctor.getDeclaringClass().getName()+\" can not use @JsonCreator for constructors\");\n+                    }\n+                    throw new IllegalArgumentException(\"Argument #\"+ix\n+                            +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n+                }\n+            }\n+        }\n+    }\n+\n+    protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n+            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n+    {\n+        JsonCreator.Mode mode = intr.findCreatorBinding(creator);\n+\n+        if (mode == JsonCreator.Mode.PROPERTIES) {\n+            return true;\n+        }\n+        if (mode == JsonCreator.Mode.DELEGATING) {\n+            return false;\n+        }\n+        // If explicit name, or inject id, property-based\n+        if (((propDef != null) && propDef.isExplicitlyNamed())\n+                || (intr.findInjectableValueId(creator.getParameter(0)) != null)) {\n+            return true;\n+        }\n+        if (propDef != null) {\n+            // One more thing: if implicit name matches property with a getter\n+            // or field, we'll consider it property-based as well\n+            String implName = propDef.getName();\n+            if (implName != null && !implName.isEmpty()) {\n+                if (propDef.couldSerialize()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        // in absence of everything else, default to delegating\n+        return false;\n+    }\n+    \n     protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt,\n             BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n             AnnotationIntrospector intr, CreatorCollector creators,\n-            AnnotatedConstructor ctor, boolean isCreator, boolean isVisible,\n-            PropertyName name)\n-        throws JsonMappingException\n-    {\n-        // note: if we do have parameter name, it'll be \"property constructor\":\n-        AnnotatedParameter param = ctor.getParameter(0);\n-        if (name == null) {\n-            name = _findParamName(param, intr);\n-        }\n-        Object injectId = intr.findInjectableValueId(param);\n-    \n-        if ((injectId != null) || (name != null && name.hasSimpleName())) { // property-based\n-            // We know there's a name and it's only 1 parameter.\n-            CreatorProperty[] properties = new CreatorProperty[1];\n-            properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId);\n-            creators.addPropertyCreator(ctor, properties);\n-            return true;\n-        }\n-    \n+            AnnotatedConstructor ctor, boolean isCreator, boolean isVisible)\n+        throws JsonMappingException\n+    {\n         // otherwise either 'simple' number, String, or general delegate:\n         Class<?> type = ctor.getRawParameterType(0);\n-        if (type == String.class) {\n+        if (type == String.class || type == CharSequence.class) {\n             if (isCreator || isVisible) {\n-                creators.addStringCreator(ctor);\n+                creators.addStringCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         if (type == int.class || type == Integer.class) {\n             if (isCreator || isVisible) {\n-                creators.addIntCreator(ctor);\n+                creators.addIntCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         if (type == long.class || type == Long.class) {\n             if (isCreator || isVisible) {\n-                creators.addLongCreator(ctor);\n+                creators.addLongCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         if (type == double.class || type == Double.class) {\n             if (isCreator || isVisible) {\n-                creators.addDoubleCreator(ctor);\n+                creators.addDoubleCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         if (type == boolean.class || type == Boolean.class) {\n             if (isCreator || isVisible) {\n-                creators.addBooleanCreator(ctor);\n+                creators.addBooleanCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         // Delegating Creator ok iff it has @JsonCreator (etc)\n         if (isCreator) {\n-            creators.addDelegatingCreator(ctor, null);\n+            creators.addDelegatingCreator(ctor, isCreator, null);\n             return true;\n         }\n         return false;\n+    }\n+\n+    @Deprecated // since 2.5, remove from 2.6\n+    protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+            AnnotationIntrospector intr, CreatorCollector creators)\n+        throws JsonMappingException\n+    {\n+        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators,\n+                Collections.<AnnotatedWithParams,BeanPropertyDefinition[]>emptyMap());\n     }\n \n     protected void _addDeserializerFactoryMethods\n         (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n-         AnnotationIntrospector intr, CreatorCollector creators)\n+         AnnotationIntrospector intr, CreatorCollector creators,\n+         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n         throws JsonMappingException\n     {\n         final DeserializationConfig config = ctxt.getConfig();\n         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n-            boolean isCreator = intr.hasCreatorAnnotation(factory);\n-            int argCount = factory.getParameterCount();\n+            final boolean isCreator = intr.hasCreatorAnnotation(factory);\n+            final int argCount = factory.getParameterCount();\n             // zero-arg methods must be annotated; if so, are \"default creators\" [JACKSON-850]\n             if (argCount == 0) {\n                 if (isCreator) {\n                 }\n                 continue;\n             }\n+\n+            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n             // some single-arg factory methods (String, number) are auto-detected\n             if (argCount == 1) {\n-                AnnotatedParameter param = factory.getParameter(0);\n-                PropertyName pn = _findParamName(param, intr);\n-                String name = (pn == null) ? null : pn.getSimpleName();\n-                Object injectId = intr.findInjectableValueId(param);\n-\n-                if ((injectId == null) && (name == null || name.length() == 0)) { // not property based\n-                    _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n+                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n+                boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n+                if (!useProps) { // not property based but delegating\n+                    /*boolean added=*/ _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n                             factory, isCreator);\n                     // otherwise just ignored\n                     continue;\n                 }\n                 // fall through if there's name\n             } else {\n-                // more than 2 args, must be @JsonCreator\n-                if (!intr.hasCreatorAnnotation(factory)) {\n+                // more than 2 args, must have @JsonCreator\n+                if (!isCreator) {\n                     continue;\n                 }\n             }\n             // 1 or more args; all params must have name annotations\n             AnnotatedParameter nonAnnotatedParam = null;            \n             CreatorProperty[] properties = new CreatorProperty[argCount];\n-            int namedCount = 0;\n-            int injectCount = 0;            \n+            int implicitNameCount = 0;\n+            int explicitNameCount = 0;\n+            int injectCount = 0;\n+            \n             for (int i = 0; i < argCount; ++i) {\n-                AnnotatedParameter param = factory.getParameter(i);\n-                PropertyName name = _findParamName(param, intr);\n+                final AnnotatedParameter param = factory.getParameter(i);\n+                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                 Object injectId = intr.findInjectableValueId(param);\n-                if (name != null && name.hasSimpleName()) {\n-                    ++namedCount;\n+                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n+\n+                if (propDef != null && propDef.isExplicitlyNamed()) {\n+                    ++explicitNameCount;\n                     properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else if (injectId != null) {\n+                    continue;\n+                }\n+                if (injectId != null) {\n                     ++injectCount;\n                     properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else {\n-                    NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n-                    if (unwrapper != null) {\n-                        properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n-                        ++namedCount;\n-                    } else {\n-                        if (nonAnnotatedParam == null) {\n-                            nonAnnotatedParam = param;\n-                        }\n+                    continue;\n+                }\n+                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n+                if (unwrapper != null) {\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n+                    ++implicitNameCount;\n+                    continue;\n+                }\n+                // One more thing: implicit names are ok iff ctor has creator annotation\n+                if (isCreator) {\n+                    if (name != null && !name.isEmpty()) {\n+                        ++implicitNameCount;\n+                        properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n+                        continue;\n                     }\n                 }\n-            }\n-\n+                /* 25-Sep-2014, tatu: Actually, we may end up \"losing\" naming due to higher-priority constructor\n+                 *  (see TestCreators#testConstructorCreator() test). And just to avoid running into that problem,\n+                 *  let's add one more work around\n+                 */\n+                /*\n+                PropertyName name2 = _findExplicitParamName(param, intr);\n+                if (name2 != null && !name2.isEmpty()) {\n+                    // Hmmh. Ok, fine. So what are we to do with it... ?\n+                    // For now... skip. May need to revisit this, should this become problematic\n+                    continue main_loop;\n+                }\n+                */\n+                if (nonAnnotatedParam == null) {\n+                    nonAnnotatedParam = param;\n+                }\n+            }\n+            final int namedCount = explicitNameCount + implicitNameCount;\n+            \n             // Ok: if named or injectable, we have more work to do\n-            if (isCreator || namedCount > 0 || injectCount > 0) {\n+            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                 // simple case; everything covered:\n                 if ((namedCount + injectCount) == argCount) {\n-                    creators.addPropertyCreator(factory, properties);\n-                } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) {\n+                    creators.addPropertyCreator(factory, isCreator, properties);\n+                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                     // [712] secondary: all but one injectable, one un-annotated (un-named)\n-                    creators.addDelegatingCreator(factory, properties);\n+                    creators.addDelegatingCreator(factory, isCreator, properties);\n                 } else { // otherwise, epic fail\n                     throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                             +\" of factory method \"+factory+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n     {\n         Class<?> type = factory.getRawParameterType(0);\n         \n-        if (type == String.class) {\n+        if (type == String.class || type == CharSequence.class) {\n             if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addStringCreator(factory);\n+                creators.addStringCreator(factory, isCreator);\n             }\n             return true;\n         }\n         if (type == int.class || type == Integer.class) {\n             if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addIntCreator(factory);\n+                creators.addIntCreator(factory, isCreator);\n             }\n             return true;\n         }\n         if (type == long.class || type == Long.class) {\n             if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addLongCreator(factory);\n+                creators.addLongCreator(factory, isCreator);\n             }\n             return true;\n         }\n         if (type == double.class || type == Double.class) {\n             if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addDoubleCreator(factory);\n+                creators.addDoubleCreator(factory, isCreator);\n             }\n             return true;\n         }\n         if (type == boolean.class || type == Boolean.class) {\n             if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addBooleanCreator(factory);\n+                creators.addBooleanCreator(factory, isCreator);\n             }\n             return true;\n         }\n-        if (intr.hasCreatorAnnotation(factory)) {\n-            creators.addDelegatingCreator(factory, null);\n+        if (isCreator) {\n+            creators.addDelegatingCreator(factory, isCreator, null);\n             return true;\n         }\n         return false;\n         final DeserializationConfig config = ctxt.getConfig();\n         final AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n         PropertyMetadata metadata;\n-\n         {\n-            Boolean b = (intr == null) ? null : intr.hasRequiredMarker(param);\n-            boolean req = (b != null && b.booleanValue());\n-            String desc = (intr == null) ? null : intr.findPropertyDescription(param);\n-            Integer idx = (intr == null) ? null : intr.findPropertyIndex(param);\n-            metadata = PropertyMetadata.construct(req, desc, idx);\n+            if (intr == null) {\n+                metadata = PropertyMetadata.STD_REQUIRED_OR_OPTIONAL;\n+            } else {\n+                Boolean b = intr.hasRequiredMarker(param);\n+                boolean req = (b != null && b.booleanValue());\n+                String desc = intr.findPropertyDescription(param);\n+                Integer idx = intr.findPropertyIndex(param);\n+                String def = intr.findPropertyDefaultValue(param);\n+                metadata = PropertyMetadata.construct(req, desc, idx, def);\n+            }\n         }\n             \n         JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType());\n                 metadata);\n         if (deser != null) {\n             // As per [Issue#462] need to ensure we contextualize deserializer before passing it on\n-            deser = ctxt.handlePrimaryContextualization(deser, prop);\n+            deser = ctxt.handlePrimaryContextualization(deser, prop, type);\n             prop = prop.withValueDeserializer(deser);\n         }\n         return prop;\n     }\n-\n+    \n     protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n     {\n         if (param != null && intr != null) {\n         }\n         return null;\n     }\n+\n+    protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n+    {\n+        if (param != null && intr != null) {\n+            return intr.findNameForDeserialization(param);\n+        }\n+        return null;\n+    }\n+\n+    protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n+    {\n+        String str = intr.findImplicitPropertyName(param);\n+        if (str != null && !str.isEmpty()) {\n+            return new PropertyName(str);\n+        }\n+        return null;\n+    }\n+    \n+    protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n+    {\n+        if (param != null && intr != null) {\n+            PropertyName n = intr.findNameForDeserialization(param);\n+            return (n != null) && n.hasSimpleName();\n+        }\n+        return false;\n+    }\n     \n     /*\n     /**********************************************************\n         \n         // Very first thing: is deserializer hard-coded for elements?\n         JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n-        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n+        // Then optional type info: if type has been resolved, we may already know type deserializer:\n         TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n         // but if not, may still be possible to find:\n         if (elemTypeDeser == null) {\n         return deser;\n     }\n \n-    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n-                    beanDesc, elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-    \n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl: Collection(-like) deserializers\n         }\n         return (CollectionType) config.constructSpecializedType(type, collectionClass);\n     }\n-\n-    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n-                    elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n     \n     // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n     @Override\n         return deser;\n     }\n \n-    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n-                    elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-\n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl: Map(-like) deserializers\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt,\n             MapType type, BeanDescription beanDesc)\n         return deser;\n     }\n \n-    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            KeyDeserializer keyDeserializer,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n-                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            KeyDeserializer keyDeserializer,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n-                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-    \n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl: Enum deserializers\n         }\n         return deser;\n     }\n-\n-    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n     \n     /*\n     /**********************************************************\n             return custom;\n         }\n         return JsonNodeDeserializer.getDeserializer(nodeClass);\n-    }\n-\n-    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n     }\n     \n     /*\n         return b.buildTypeDeserializer(config, baseType, subtypes);\n     }\n \n+    /**\n+     * Overridable method called after checking all other types.\n+     * \n+     * @since 2.2\n+     */\n+    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt,\n+            JavaType type, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl (partial): key deserializers\n         if (rawType == CLASS_ITERABLE) {\n             // [Issue#199]: Can and should 'upgrade' to a Collection type:\n             TypeFactory tf = ctxt.getTypeFactory();\n-            JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType();\n+            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n+            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n             CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n             // Should we re-introspect beanDesc? For now let's not...\n             return createCollectionDeserializer(ctxt, ct, beanDesc);\n+        }\n+        if (rawType == CLASS_MAP_ENTRY) {\n+            final DeserializationConfig config = ctxt.getConfig();\n+            TypeFactory tf = ctxt.getTypeFactory();\n+            JavaType[] tps = tf.findTypeParameters(type, CLASS_MAP_ENTRY);\n+            JavaType kt, vt;\n+            if (tps == null || tps.length != 2) {\n+                kt = vt = TypeFactory.unknownType();\n+            } else {\n+                kt = tps[0];\n+                vt = tps[1];\n+            }\n+            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n+            if (vts == null) {\n+                vts = findTypeDeserializer(config, vt);\n+            }\n+            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n+            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n+            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n         }\n         String clsName = rawType.getName();\n         if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n         if (rawType == TokenBuffer.class) {\n             return new TokenBufferDeserializer();\n         }\n+        if (AtomicReference.class.isAssignableFrom(rawType)) {\n+            // Must find parameterization\n+            TypeFactory tf = ctxt.getTypeFactory();\n+            JavaType[] params = tf.findTypeParameters(type, AtomicReference.class);\n+            JavaType referencedType;\n+            if (params == null || params.length < 1) { // untyped (raw)\n+                referencedType = TypeFactory.unknownType();\n+            } else {\n+                referencedType = params[0];\n+            }\n+            TypeDeserializer vts = findTypeDeserializer(ctxt.getConfig(), referencedType);\n+            BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);\n+            JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());\n+            return new AtomicReferenceDeserializer(referencedType, vts, deser);\n+        }\n+        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n+        if (deser != null) {\n+            return deser;\n+        }\n         return JdkDeserializers.find(rawType, clsName);\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Helper methods, finding custom deserializers\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n+                    beanDesc, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n+            if (deser != null) {\n+                return (JsonDeserializer<Object>) deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n+                    elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n+                    elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n+                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n+                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods, value/content/key type introspection\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n     extends BeanDeserializerBase\n     implements java.io.Serializable\n {\n+    /* TODOs for future versions:\n+     * \n+     * For 2.6\n+     * \n+     * - Start using new (2.5) methods in JsonParser, like\n+     *   * 'hasTokenId(xxx)'\n+     *   * 'nextFieldName()'\n+     *   \n+     *   for slightly more efficient property lookups, handling\n+     *   (2-3% faster deserialization)\n+     *   Not done for 2.5 since it was just introduced, trying to\n+     *   keep some level of compatibility between \"adjacent\" minor\n+     *   versions.\n+     *   Also: need to ensure efficient impl of those methods for Smile, CBOR\n+     *   at least (in addition to JSON)\n+     * \n+     */\n+\n     private static final long serialVersionUID = 1L;\n \n     /*\n      * like Afterburner change definition.\n      */\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonToken t = jp.getCurrentToken();\n-        // common case first:\n-        if (t == JsonToken.START_OBJECT) {\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        JsonToken t = p.getCurrentToken();\n+        // common case first\n+        if (t == JsonToken.START_OBJECT) { // TODO: in 2.6, use 'p.hasTokenId()'\n             if (_vanillaProcessing) {\n-                return vanillaDeserialize(jp, ctxt, jp.nextToken());\n-            }\n-            jp.nextToken();\n+                return vanillaDeserialize(p, ctxt, p.nextToken());\n+            }\n+            p.nextToken();\n             if (_objectIdReader != null) {\n-                return deserializeWithObjectId(jp, ctxt);\n-            }\n-            return deserializeFromObject(jp, ctxt);\n-        }\n-        return _deserializeOther(jp, ctxt, t);\n-    }\n-\n-    protected final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt,\n+                return deserializeWithObjectId(p, ctxt);\n+            }\n+            return deserializeFromObject(p, ctxt);\n+        }\n+        return _deserializeOther(p, ctxt, t);\n+    }\n+\n+    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n             JsonToken t) throws IOException\n     {\n         // and then others, generally requiring use of @JsonCreator\n         switch (t) {\n         case VALUE_STRING:\n-            return deserializeFromString(jp, ctxt);\n+            return deserializeFromString(p, ctxt);\n         case VALUE_NUMBER_INT:\n-            return deserializeFromNumber(jp, ctxt);\n+            return deserializeFromNumber(p, ctxt);\n         case VALUE_NUMBER_FLOAT:\n-\t    return deserializeFromDouble(jp, ctxt);\n+\t    return deserializeFromDouble(p, ctxt);\n         case VALUE_EMBEDDED_OBJECT:\n-            return deserializeFromEmbedded(jp, ctxt);\n+            return deserializeFromEmbedded(p, ctxt);\n         case VALUE_TRUE:\n         case VALUE_FALSE:\n-            return deserializeFromBoolean(jp, ctxt);\n+            return deserializeFromBoolean(p, ctxt);\n         case START_ARRAY:\n             // these only work if there's a (delegating) creator...\n-            return deserializeFromArray(jp, ctxt);\n+            return deserializeFromArray(p, ctxt);\n         case FIELD_NAME:\n         case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n             if (_vanillaProcessing) {\n-                return vanillaDeserialize(jp, ctxt, t);\n+                return vanillaDeserialize(p, ctxt, t);\n             }\n             if (_objectIdReader != null) {\n-                return deserializeWithObjectId(jp, ctxt);\n-            }\n-            return deserializeFromObject(jp, ctxt);\n+                return deserializeWithObjectId(p, ctxt);\n+            }\n+            return deserializeFromObject(p, ctxt);\n         default:\n             throw ctxt.mappingException(handledType());\n         }\n     }\n \n-    protected Object _missingToken(JsonParser jp, DeserializationContext ctxt)\n+    protected Object _missingToken(JsonParser p, DeserializationContext ctxt)\n         throws JsonProcessingException\n     {\n         throw ctxt.endOfInputException(handledType());\n      * after collecting some or all of the properties to set.\n      */\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n+    {\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         if (_unwrappedPropertyHandler != null) {\n-            return deserializeWithUnwrapped(jp, ctxt, bean);\n+            return deserializeWithUnwrapped(p, ctxt, bean);\n         }\n         if (_externalTypeIdHandler != null) {\n-            return deserializeWithExternalTypeId(jp, ctxt, bean);\n-        }\n-        JsonToken t = jp.getCurrentToken();\n+            return deserializeWithExternalTypeId(p, ctxt, bean);\n+        }\n+        JsonToken t = p.getCurrentToken();\n         // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n         if (t == JsonToken.START_OBJECT) {\n-            t = jp.nextToken();\n+            t = p.nextToken();\n         }\n         if (_needViewProcesing) {\n             Class<?> view = ctxt.getActiveView();\n             if (view != null) {\n-                return deserializeWithView(jp, ctxt, bean, view);\n-            }\n-        }\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            // Skip field name:\n-            jp.nextToken();\n-            SettableBeanProperty prop = _beanProperties.find(propName);\n-            \n-            if (prop != null) { // normal case\n-                try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n-                } catch (Exception e) {\n-                    wrapAndThrow(e, bean, propName, ctxt);\n-                }\n-                continue;\n-            }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+                return deserializeWithView(p, ctxt, bean, view);\n+            }\n+        }\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken();\n+            if (!_beanProperties.findDeserializeAndSet(p, ctxt, bean, propName)) {\n+                handleUnknownVanilla(p, ctxt, bean, propName);\n+            }\n         }\n         return bean;\n     }\n      * Streamlined version that is only used when no \"special\"\n      * features are enabled.\n      */\n-    private final Object vanillaDeserialize(JsonParser jp,\n+    private final Object vanillaDeserialize(JsonParser p,\n     \t\tDeserializationContext ctxt, JsonToken t)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            // Skip field name:\n-            jp.nextToken();\n-            SettableBeanProperty prop = _beanProperties.find(propName);\n-            if (prop != null) { // normal case\n-                try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n-                } catch (Exception e) {\n-                    wrapAndThrow(e, bean, propName, ctxt);\n-                }\n-            } else {\n-                handleUnknownVanilla(jp, ctxt, bean, propName);\n-            }\n-        }\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken();\n+            if (!_beanProperties.findDeserializeAndSet(p, ctxt, bean, propName)) {\n+                handleUnknownVanilla(p, ctxt, bean, propName);\n+            }\n+        }\n+\n+        // 13-Dec-2014, tatu: For 2.6, we'll do:\n+        /*\n+        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n+            String propName = p.getCurrentName();\n+            do {\n+                p.nextToken();\n+                if (!_beanProperties.findDeserializeAndSet(p, ctxt, bean, propName)) {\n+                    handleUnknownVanilla(p, ctxt, bean, propName);\n+                }\n+            } while ((propName = p.nextFieldName()) != null);\n+        }\n+        */\n         return bean;\n     }\n \n     /**\n-     * General version used when handling needs more advanced\n-     * features.\n+     * General version used when handling needs more advanced features.\n      */\n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n+    {\n+        /* 09-Dec-2014, tatu: As per [#622], we need to allow Object Id references\n+         *   to come in as JSON Objects as well; but for now assume they will\n+         *   be simple, single-property references, which means that we can\n+         *   recognize them without having to buffer anything.\n+         *   Once again, if we must, we can do more complex handling with buffering,\n+         *   but let's only do that if and when that becomes necessary.\n+         */\n+        if (_objectIdReader != null && _objectIdReader.maySerializeAsObject()) {\n+            // TODO: in 2.6, use 'p.hasTokenId()'\n+            if ((p.getCurrentTokenId() == JsonTokenId.ID_FIELD_NAME)\n+                    && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n+                return deserializeFromObjectId(p, ctxt);\n+            }\n+        }\n         if (_nonStandardCreation) {\n             if (_unwrappedPropertyHandler != null) {\n-                return deserializeWithUnwrapped(jp, ctxt);\n+                return deserializeWithUnwrapped(p, ctxt);\n             }\n             if (_externalTypeIdHandler != null) {\n-                return deserializeWithExternalTypeId(jp, ctxt);\n-            }\n-            Object bean = deserializeFromObjectUsingNonDefault(jp, ctxt);\n+                return deserializeWithExternalTypeId(p, ctxt);\n+            }\n+            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n             if (_injectables != null) {\n                 injectValues(ctxt, bean);\n             }\n             if (_needViewProcesing) {\n                 Class<?> view = ctxt.getActiveView();\n                 if (view != null) {\n-                    return deserializeWithView(jp, ctxt, bean, view);\n+                    return deserializeWithView(p, ctxt, bean, view);\n                 }\n             }\n             */\n             return bean;\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n-        if (jp.canReadObjectId()) {\n-            Object id = jp.getObjectId();\n+        // [databind#631]: Assign current value, to be accessible by custom deserializers\n+        p.setCurrentValue(bean);\n+        if (p.canReadObjectId()) {\n+            Object id = p.getObjectId();\n             if (id != null) {\n-                _handleTypedObjectId(jp, ctxt, bean, id);\n+                _handleTypedObjectId(p, ctxt, bean, id);\n             }\n         }\n         if (_injectables != null) {\n         if (_needViewProcesing) {\n             Class<?> view = ctxt.getActiveView();\n             if (view != null) {\n-                return deserializeWithView(jp, ctxt, bean, view);\n-            }\n-        }\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            // Skip field name:\n-            jp.nextToken();\n-            SettableBeanProperty prop = _beanProperties.find(propName);\n-            if (prop != null) { // normal case\n-                try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n-                } catch (Exception e) {\n-                    wrapAndThrow(e, bean, propName, ctxt);\n-                }\n-                continue;\n-            }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n-        }\n+                return deserializeWithView(p, ctxt, bean, view);\n+            }\n+        }\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken();\n+            if (!_beanProperties.findDeserializeAndSet(p, ctxt, bean, propName)) {\n+                handleUnknownVanilla(p, ctxt, bean, propName);\n+            }\n+        }\n+        // 13-Dec-2014, tatu: For 2.6, we'll do:\n+        /*\n+        if (p.hasTokenId(JsonTokenId.ID_FIELD_NAME)) {\n+            String propName = p.getCurrentName();\n+            do {\n+                p.nextToken();\n+                if (!_beanProperties.findDeserializeAndSet(p, ctxt, bean, propName)) {\n+                    handleUnknownVanilla(p, ctxt, bean, propName);\n+                }\n+            } while ((propName = p.nextFieldName()) != null);\n+        }\n+        */\n         return bean;\n     }\n \n      */\n     @Override\n     @SuppressWarnings(\"resource\")\n-    protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    { \n+    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n+        throws IOException\n+    {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n         \n         // 04-Jan-2010, tatu: May need to collect unknown properties for polymorphic cases\n         TokenBuffer unknown = null;\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                    jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n                         bean = creator.build(ctxt, buffer);\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         bean = null; // never gets here\n                     }\n+                    if (bean == null) {\n+                        throw ctxt.instantiationException(_beanType.getRawClass(), \"JSON Creator returned null\");\n+                    }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n+\n                     //  polymorphic?\n                     if (bean.getClass() != _beanType.getRawClass()) {\n-                        return handlePolymorphic(jp, ctxt, bean, unknown);\n+                        return handlePolymorphic(p, ctxt, bean, unknown);\n                     }\n                     if (unknown != null) { // nope, just extra unknown stuff...\n                         bean = handleUnknownProperties(ctxt, bean, unknown);\n                     }\n                     // or just clean?\n-                    return deserialize(jp, ctxt, bean);\n+                    return deserialize(p, ctxt, bean);\n                 }\n                 continue;\n             }\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             // As per [JACKSON-313], things marked as ignorable should not be\n             // passed to any setter\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                 continue;\n             }\n             // Ok then, let's collect the whole field; name and value\n             if (unknown == null) {\n-                unknown = new TokenBuffer(jp);\n+                unknown = new TokenBuffer(p);\n             }\n             unknown.writeFieldName(propName);\n-            unknown.copyCurrentStructure(jp);\n-        }\n-\n+            unknown.copyCurrentStructure(p);\n+        }\n+        \n         // We hit END_OBJECT, so:\n         Object bean;\n         try {\n     /**********************************************************\n      */\n     \n-    protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt,\n+    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n             Object bean, Class<?> activeView)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+        throws IOException\n+    {\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n                 if (!prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+            handleUnknownVanilla(p, ctxt, bean, propName);\n         }\n         return bean;\n     }\n      * which need special handling\n      */\n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n-            return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt);\n-        }\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+            return deserializeUsingPropertyBasedWithUnwrapped(p, ctxt);\n+        }\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n \n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n-        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken();\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // how about any setter? We'll get copies but...\n             if (_anySetter != null) {\n                 try {\n-                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             }\n         }\n         tokens.writeEndObject();\n-        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n         return bean;\n-    }    \n+    }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonToken t = jp.getCurrentToken();\n+    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n+    {\n+        JsonToken t = p.getCurrentToken();\n         if (t == JsonToken.START_OBJECT) {\n-            t = jp.nextToken();\n-        }\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+            t = p.nextToken();\n+        }\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n-            jp.nextToken();\n+            p.nextToken();\n             if (prop != null) { // normal case\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // how about any setter? We'll get copies but...\n             if (_anySetter != null) {\n-                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n             }\n         }\n         tokens.writeEndObject();\n-        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n         return bean;\n     }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n-\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n+\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                    t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n                         bean = creator.build(ctxt, buffer);\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         continue; // never gets here\n                     }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n-                        jp.nextToken(); // to skip name\n-                        tokens.copyCurrentStructure(jp);\n-                        t = jp.nextToken();\n+                        p.nextToken(); // to skip name\n+                        tokens.copyCurrentStructure(p);\n+                        t = p.nextToken();\n                     }\n                     tokens.writeEndObject();\n                     if (bean.getClass() != _beanType.getRawClass()) {\n                         tokens.close();\n                         throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                     }\n-                    return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                 }\n                 continue;\n             }\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             /* As per [JACKSON-313], things marked as ignorable should not be\n              * passed to any setter\n              */\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n             }\n         }\n \n             wrapInstantiationProblem(e, ctxt);\n             return null; // never gets here\n         }\n-        return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n     }\n \n     /*\n     /**********************************************************\n      */\n     \n-    protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_propertyBasedCreator != null) {\n-            return deserializeUsingPropertyBasedWithExternalTypeId(jp, ctxt);\n-        }\n-        return deserializeWithExternalTypeId(jp, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n+            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n+        }\n+        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n     }\n     \n-    protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt,\n+    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n             Object bean)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n         final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken();\n+        \n+        for (JsonToken t = p.getCurrentToken(); t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            t = p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 // [JACKSON-831]: may have property AND be used as external type id:\n-                if (jp.getCurrentToken().isScalarValue()) {\n-                    ext.handleTypePropertyValue(jp, ctxt, propName, bean);\n+                if (t.isScalarValue()) {\n+                    ext.handleTypePropertyValue(p, ctxt, propName, bean);\n                 }\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but others are likely to be part of external type id thingy...\n-            if (ext.handlePropertyValue(jp, ctxt, propName, bean)) {\n+            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                 continue;\n             }\n             // if not, the usual fallback handling:\n             if (_anySetter != null) {\n                 try {\n-                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n             // Unknown: let's call handler method\n-            handleUnknownProperty(jp, ctxt, bean, propName);         \n+            handleUnknownProperty(p, ctxt, bean, propName);         \n         }\n         // and when we get this far, let's try finalizing the deal:\n-        return ext.complete(jp, ctxt, bean);\n+        return ext.complete(p, ctxt, bean);\n     }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n-\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n+\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n-                if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) {\n+                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n-                    Object value = creatorProp.deserialize(jp, ctxt);\n+                    Object value = creatorProp.deserialize(p, ctxt);\n                     if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                        t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                         Object bean;\n                         try {\n                             bean = creator.build(ctxt, buffer);\n                         }\n                         // if so, need to copy all remaining tokens into buffer\n                         while (t == JsonToken.FIELD_NAME) {\n-                            jp.nextToken(); // to skip name\n-                            tokens.copyCurrentStructure(jp);\n-                            t = jp.nextToken();\n+                            p.nextToken(); // to skip name\n+                            tokens.copyCurrentStructure(p);\n+                            t = p.nextToken();\n                         }\n                         if (bean.getClass() != _beanType.getRawClass()) {\n                             // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                             //   it's too complicated, so bail out\n                             throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                         }\n-                        return ext.complete(jp, ctxt, bean);\n+                        return ext.complete(p, ctxt, bean);\n                     }\n                 }\n                 continue;\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             // external type id (or property that depends on it)?\n-            if (ext.handlePropertyValue(jp, ctxt, propName, null)) {\n+            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                 continue;\n             }\n             /* As per [JACKSON-313], things marked as ignorable should not be\n              * passed to any setter\n              */\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n             }\n         }\n \n         // We hit END_OBJECT; resolve the pieces:\n         try {\n-            return ext.complete(jp, ctxt, buffer, creator);\n+            return ext.complete(p, ctxt, buffer, creator);\n         } catch (Exception e) {\n             wrapInstantiationProblem(e, ctxt);\n             return null; // never gets here\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n     implements ContextualDeserializer, ResolvableDeserializer,\n         java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = 2960120955735322578L;\n+    private static final long serialVersionUID = 1;\n \n     protected final static PropertyName TEMP_PROPERTY_NAME = new PropertyName(\"#temporary-name\");\n \n      * to use have been successfully resolved.\n      */\n     final protected BeanPropertyMap _beanProperties;\n-    \n+\n     /**\n      * List of {@link ValueInjector}s, if any injectable values are\n      * expected by the bean; otherwise null.\n      * and fields, but not ones passed through constructor parameters.\n      */\n     final protected ValueInjector[] _injectables;\n-    \n+\n     /**\n      * Fallback setter used for handling any properties that are not\n      * mapped to regular setters. If setter is not null, it will be\n                 ;\n     }\n \n-    protected BeanDeserializerBase(BeanDeserializerBase src)\n-    {\n+    protected BeanDeserializerBase(BeanDeserializerBase src) {\n         this(src, src._ignoreAllUnknown);\n     }\n \n                 /* Important! This is the only place where actually handle \"primary\"\n                  * property deserializers -- call is different from other places.\n                  */\n-                JsonDeserializer<?> cd = ctxt.handlePrimaryContextualization(deser, prop);\n+                JsonDeserializer<?> cd = ctxt.handlePrimaryContextualization(deser, prop,\n+                        prop.getType());\n                 if (cd != deser) {\n                     prop = prop.withValueDeserializer(cd);\n                 }\n                     unwrapped = new UnwrappedPropertyHandler();\n                 }\n                 unwrapped.addProperty(prop);\n-                // 10-Apr-2014, tatu: Looks like we should also do this? (no observed diff tho)\n-                if (prop != origProp) {\n-                    _beanProperties.replace(prop);\n-                }\n+                /* 12-Dec-2014, tatu: As per [databind#647], we will have problems if\n+                 *    the original property is left in place. So let's remove it now.\n+                 */\n+                _beanProperties.remove(prop);\n                 continue;\n             }\n             // [JACKSON-594]: non-static inner classes too:\n             }\n             JsonDeserializer<Object> dd = findDeserializer(ctxt, delegateType, property);\n             if (td != null) {\n+                td = td.forProperty(property);\n                 dd = new TypeWrappedDeserializer(td, dd);\n             }\n             _delegateDeserializer = dd;\n      * General version used when handling needs more advanced\n      * features.\n      */\n-    public abstract Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException;\n+    public abstract Object deserializeFromObject(JsonParser p, DeserializationContext ctxt)\n+        throws IOException;\n \n     @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // 16-Feb-2012, tatu: ObjectId may be used as well... need to check that first\n         if (_objectIdReader != null) {\n             // 05-Aug-2013, tatu: May use native Object Id\n-            if (jp.canReadObjectId()) {\n-                Object id = jp.getObjectId();\n+            if (p.canReadObjectId()) {\n+                Object id = p.getObjectId();\n                 if (id != null) {\n-                    Object ob = typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n-                    return _handleTypedObjectId(jp, ctxt, ob, id);\n+                    Object ob = typeDeserializer.deserializeTypedFromObject(p, ctxt);\n+                    return _handleTypedObjectId(p, ctxt, ob, id);\n                 }\n             }\n             // or, Object Ids Jackson explicitly sets\n-            JsonToken t = jp.getCurrentToken();\n-            // for now (2.2.x) we only allow scalar types (Strings, integral numbers):\n-            // NOTE: may  need to allow handling of structured values in future for JSOG\n-            if (t != null && t.isScalarValue()) {\n-                return deserializeFromObjectId(jp, ctxt);\n+            JsonToken t = p.getCurrentToken();\n+            if (t != null) {\n+                // Most commonly, a scalar (int id, uuid String, ...)\n+                if (t.isScalarValue()) {\n+                    return deserializeFromObjectId(p, ctxt);\n+                }\n+                // but, with 2.5+, a simple Object-wrapped value also legal:\n+                if (t == JsonToken.START_OBJECT) {\n+                    t = p.nextToken();\n+                }\n+                if (t == JsonToken.FIELD_NAME && _objectIdReader.maySerializeAsObject()\n+                        && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n+                    return deserializeFromObjectId(p, ctxt);\n+                }\n             }\n         }\n         // In future could check current token... for now this should be enough:\n-        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+        return typeDeserializer.deserializeTypedFromObject(p, ctxt);\n     }\n \n     /**\n      */\n     protected Object _handleTypedObjectId(JsonParser jp, DeserializationContext ctxt,\n             Object pojo, Object rawId)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         /* 07-Aug-2013, tatu: One more challenge: type of id may not be type\n          *   of property we are expecting later on; specifically, numeric ids\n      * buffering in some cases, but usually just a simple lookup to ensure\n      * that ordering is correct.\n      */\n-    protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException\n-    {\n+    protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n         return deserializeFromObject(jp, ctxt);\n     }\n-    \n+\n     /**\n      * Method called in cases where it looks like we got an Object Id\n      * to parse and use as a reference.\n \n     protected Object deserializeFromObjectUsingNonDefault(JsonParser jp,\n             DeserializationContext ctxt) throws IOException\n-    {        \n+    {\n         if (_delegateDeserializer != null) {\n             return _valueInstantiator.createUsingDelegate(ctxt,\n                     _delegateDeserializer.deserialize(jp, ctxt));\n                     +\" (need to add/enable type information?)\");\n         }\n         throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n-                +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n+                +_beanType+\": can not instantiate from JSON object (missing default constructor or creator, or perhaps need to add/enable type information?)\");\n     }\n \n     protected abstract Object _deserializeUsingPropertyBased(final JsonParser jp,\n             }\n             return bean;\n         }\n-        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON integer number\");\n-    }\n-\n-    public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        throw ctxt.instantiationException(handledType(), \"no suitable creator method found to deserialize from JSON integer number\");\n+    }\n+\n+    public Object deserializeFromString(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         // First things first: id Object Id is used, most likely that's it\n         if (_objectIdReader != null) {\n-            return deserializeFromObjectId(jp, ctxt);\n+            return deserializeFromObjectId(p, ctxt);\n         }\n         \n         /* Bit complicated if we have delegating creator; may need to use it,\n          */\n         if (_delegateDeserializer != null) {\n             if (!_valueInstantiator.canCreateFromString()) {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n                 return bean;\n             }\n         }\n-        return _valueInstantiator.createFromString(ctxt, jp.getText());\n+        return _valueInstantiator.createFromString(ctxt, p.getText());\n     }\n \n     /**\n      * number.\n      */\n     @SuppressWarnings(\"incomplete-switch\")\n-    public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException\n-    {\n-        switch (jp.getNumberType()) {\n+    public Object deserializeFromDouble(JsonParser p, DeserializationContext ctxt) throws IOException\n+    {\n+        switch (p.getNumberType()) {\n         case FLOAT: // no separate methods for taking float...\n         case DOUBLE:\n             if (_delegateDeserializer != null) {\n                 if (!_valueInstantiator.canCreateFromDouble()) {\n-                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                     if (_injectables != null) {\n                         injectValues(ctxt, bean);\n                     }\n                     return bean;\n                 }\n             }\n-            return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue());\n+            return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue());\n         }\n         // actually, could also be BigDecimal, so:\n         if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-        }\n-        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON floating-point number\");\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n+        }\n+        throw ctxt.instantiationException(handledType(), \"no suitable creator method found to deserialize from JSON floating-point number\");\n     }\n \n     /**\n      * Method called to deserialize POJO value from a JSON boolean value (true, false)\n      */\n-    public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             if (!_valueInstantiator.canCreateFromBoolean()) {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n                 return bean;\n             }\n         }\n-        boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE);\n+        boolean value = (p.getCurrentToken() == JsonToken.VALUE_TRUE);\n         return _valueInstantiator.createFromBoolean(ctxt, value);\n     }\n \n-    public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             try {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n                 wrapInstantiationProblem(e, ctxt);\n             }\n         } else if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n-            jp.nextToken();\n-            final Object value = deserialize(jp, ctxt);\n-            if (jp.nextToken() != JsonToken.END_ARRAY) {\n-                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \n+            JsonToken t = p.nextToken();\n+            if (t == JsonToken.END_ARRAY && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n+                return null;\n+            }\n+            final Object value = deserialize(p, ctxt);\n+            if (p.nextToken() != JsonToken.END_ARRAY) {\n+                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                         \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\");\n             }\n             return value;\n-        }\n-        throw ctxt.mappingException(getBeanClass());\n+        } else if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n+            JsonToken t = p.nextToken();\n+            if (t == JsonToken.END_ARRAY) {\n+                return null;\n+            }\n+            throw ctxt.mappingException(handledType(), JsonToken.START_ARRAY);\n+        }\n+        throw ctxt.mappingException(handledType());\n     }\n \n     public Object deserializeFromEmbedded(JsonParser jp, DeserializationContext ctxt) throws IOException\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n \n     final protected boolean _defaultViewInclusion;\n     \n+    final protected boolean _caseInsensitivePropertyComparison;\n+    \n     /*\n     /**********************************************************\n     /* Accumulated information about properties\n     { \n         _beanDesc = beanDesc;\n         _defaultViewInclusion = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n+        _caseInsensitivePropertyComparison = config.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);\n     }\n \n     /**\n     {\n         _beanDesc = src._beanDesc;\n         _defaultViewInclusion = src._defaultViewInclusion;\n+        _caseInsensitivePropertyComparison = src._caseInsensitivePropertyComparison;\n \n         // let's make copy of properties\n         _properties.putAll(src._properties);\n         //   For now, won't add, since it is inferred, not explicit...\n     }\n \n-    @Deprecated // since 2.3\n-    public void addInjectable(String propName, JavaType propType,\n-            Annotations contextAnnotations, AnnotatedMember member,\n-            Object valueId)\n-    {\n-        addInjectable(new PropertyName(propName), propType, contextAnnotations, member, valueId);\n-    }\n-    \n     public void addInjectable(PropertyName propName, JavaType propType,\n             Annotations contextAnnotations, AnnotatedMember member,\n             Object valueId)\n         return _properties.values().iterator();\n     }\n \n-    /**\n-     * @since 2.3\n-     */\n     public SettableBeanProperty findProperty(PropertyName propertyName) {\n         return _properties.get(propertyName.getSimpleName());\n     }\n \n-    @Deprecated // since 2.3\n-    public SettableBeanProperty findProperty(String propertyName) {\n-        return _properties.get(propertyName);\n-    }\n-\n-    /**\n-     * @since 2.3\n-     */\n     public boolean hasProperty(PropertyName propertyName) {\n         return findProperty(propertyName) != null;\n     }\n-    \n-    @Deprecated // since 2.3\n-    public boolean hasProperty(String propertyName) {\n-        return findProperty(propertyName) != null;\n-    }\n-\n-    /**\n-     * @since 2.3\n-     */\n+\n     public SettableBeanProperty removeProperty(PropertyName name) {\n         return _properties.remove(name.getSimpleName());\n-    }\n-    \n-    @Deprecated // since 2.3\n-    public SettableBeanProperty removeProperty(String name) {\n-        return _properties.remove(name);\n     }\n \n     public SettableAnyProperty getAnySetter() {\n     public JsonDeserializer<?> build()\n     {\n         Collection<SettableBeanProperty> props = _properties.values();\n-        BeanPropertyMap propertyMap = new BeanPropertyMap(props);\n+        BeanPropertyMap propertyMap = new BeanPropertyMap(props, _caseInsensitivePropertyComparison);\n         propertyMap.assignIndexes();\n \n         // view processing must be enabled if:\n      * \n      * @since 2.0\n      */\n-    public AbstractDeserializer buildAbstract()\n-    {\n+    public AbstractDeserializer buildAbstract() {\n         return new AbstractDeserializer(this, _beanDesc, _backRefProperties);\n     }\n     \n         }\n         // And if so, we can try building the deserializer\n         Collection<SettableBeanProperty> props = _properties.values();\n-        BeanPropertyMap propertyMap = new BeanPropertyMap(props);\n+        BeanPropertyMap propertyMap = new BeanPropertyMap(props, _caseInsensitivePropertyComparison);\n         propertyMap.assignIndexes();\n \n         boolean anyViews = !_defaultViewInclusion;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n \n import java.lang.reflect.Type;\n import java.util.*;\n-import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n import com.fasterxml.jackson.databind.deser.impl.*;\n-import com.fasterxml.jackson.databind.deser.std.AtomicReferenceDeserializer;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n-import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;\n     \n     /*\n     /**********************************************************\n-    /* Overrides for super-class methods used for finding\n-    /* custom deserializers\n-    /**********************************************************\n-     */\n-\n-    // Note: NOT overriding, superclass has no matching method\n-    @SuppressWarnings(\"unchecked\")\n-    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n-            if (deser != null) {\n-                return (JsonDeserializer<Object>) deser;\n-            }\n-        }\n-        return null;\n-    }\n-    \n-    /*\n-    /**********************************************************\n     /* DeserializerFactory API implementation\n     /**********************************************************\n      */\n         // note: we do NOT check for custom deserializers here, caller has already\n         // done that\n         JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n+        // Also: better ensure these are post-processable?\n         if (deser != null) {\n-            return deser;\n-        }\n-        \n-        Class<?> cls = type.getRawClass();\n-        // [JACKSON-283]: AtomicReference is a rather special type...\n-        if (AtomicReference.class.isAssignableFrom(cls)) {\n-            // Must find parameterization\n-            TypeFactory tf = ctxt.getTypeFactory();\n-            JavaType[] params = tf.findTypeParameters(type, AtomicReference.class);\n-            JavaType referencedType;\n-            if (params == null || params.length < 1) { // untyped (raw)\n-                referencedType = TypeFactory.unknownType();\n-            } else {\n-                referencedType = params[0];\n-            }\n-            TypeDeserializer valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), referencedType);\n-            BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);\n-            deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());\n-            return new AtomicReferenceDeserializer(referencedType, valueTypeDeser, deser);\n-        }\n-        return findOptionalStdDeserializer(ctxt, type, beanDesc);\n-    }\n-\n-    /**\n-     * Overridable method called after checking all other types.\n-     * \n-     * @since 2.2\n-     */\n-    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt,\n-            JavaType type, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n+            if (_factoryConfig.hasDeserializerModifiers()) {\n+                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                    deser = mod.modifyDeserializer(ctxt.getConfig(), beanDesc, deser);\n+                }\n+            }\n+        }\n+        return deser;\n     }\n     \n     protected JavaType materializeAbstractType(DeserializationContext ctxt,\n          */\n         AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n         if (am != null) { // should never be null\n-            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am, \"cause\");\n+            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n+                    new PropertyName(\"cause\"));\n             SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                     am.getGenericParameterType(0));\n             if (prop != null) {\n     {\n         final SettableBeanProperty[] creatorProps =\n                 builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n+        final boolean isConcrete = !beanDesc.getType().isAbstract();\n         \n         // Things specified as \"ok to ignore\"? [JACKSON-77]\n         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n         if (anySetter != null) {\n             builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n         }\n-        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n+        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n         // Implicit ones via @JsonIgnore and equivalent?\n         if (anySetter == null) {\n             Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n                     prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                 }\n             }\n-            if (propDef.hasConstructorParameter()) {\n+            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n+            //   (since they are never used anyway)\n+            if (isConcrete && propDef.hasConstructorParameter()) {\n                 /* [JACKSON-700] If property is passed via constructor parameter, we must\n                  *   handle things in special way. Not sure what is the most optimal way...\n                  *   for now, let's just call a (new) method in builder, which does nothing.\n         if (typeStr != null) {\n             throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n         }\n-    \treturn true;\n+        return true;\n     }\n \n     /**\n             Class<?> type, Map<Class<?>,Boolean> ignoredTypes)\n     {\n         Boolean status = ignoredTypes.get(type);\n-        if (status == null) {\n-            BeanDescription desc = config.introspectClassAnnotations(type);\n-            status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n-            // We default to 'false', ie. not ignorable\n-            if (status == null) {\n-                status = Boolean.FALSE;\n-            }\n-        }\n-        return status;\n+        if (status != null) {\n+            return status.booleanValue();\n+        }\n+        BeanDescription desc = config.introspectClassAnnotations(type);\n+        status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n+        // We default to 'false', i.e. not ignorable\n+        return (status == null) ? false : status.booleanValue(); \n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/CreatorProperty.java\n     {\n         this(new PropertyName(name), type, wrapperName, typeDeser,\n                 contextAnnotations, param, index, injectableValueId,\n-                PropertyMetadata.construct(isRequired, null, null));\n+                PropertyMetadata.construct(isRequired, null, null, null));\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DataFormatReaders.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DataFormatReaders.java\n         final int len = _readers.length;\n         ObjectReader[] r = new ObjectReader[len];\n         for (int i = 0; i < len; ++i) {\n-            r[i] = _readers[i].withType(type);\n+            r[i] = _readers[i].forType(type);\n         }\n         return new DataFormatReaders(r, _optimalMatch, _minimalMatch, _maxInputLookahead);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n     public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType)\n     {\n         final ObjectIdGenerator.IdKey key = gen.key(id);\n+\n         if (_objectIds == null) {\n             _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>();\n         } else {\n \n         if (resolver == null) {\n             resolver = resolverType.newForDeserialization(this);\n-            /* !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n-             *    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n-             */\n-            if (resolverType instanceof SimpleObjectIdResolver) {\n-               resolver = new SimpleObjectIdResolver();\n-            }\n+            // 19-Dec-2014, tatu: For final 2.5.0, remove temporary (2.4.x) work-around\n+            //   needed to clear state between calls.\n+            // !!! 18-Jun-2014, pgelinas: Temporary fix for [#490] until real\n+            //    fix (for jackson-annotations, SimpleObjectIdResolver) can be added.\n+            /*\n+            if (resolverType.getClass() == SimpleObjectIdResolver.class) {\n+                resolver = new SimpleObjectIdResolver();\n+            }\n+            */\n             _objectIdResolvers.add(resolver);\n         }\n \n         if (_objectIds == null) {\n             return;\n         }\n-\n+        // 29-Dec-2014, tatu: As per [databind#299], may also just let unresolved refs be...\n+        if (!isEnabled(DeserializationFeature.FAIL_ON_UNRESOLVED_OBJECT_IDS)) {\n+            return;\n+        }\n         UnresolvedForwardReference exception = null;\n         for (Entry<IdKey,ReadableObjectId> entry : _objectIds.entrySet()) {\n             ReadableObjectId roid = entry.getValue();\n                 if (exception == null) {\n                     exception = new UnresolvedForwardReference(\"Unresolved forward references for: \");\n                 }\n-                for (Iterator<Referring> iterator = roid.referringProperties(); iterator.hasNext();) {\n+                for (Iterator<Referring> iterator = roid.referringProperties(); iterator.hasNext(); ) {\n                     Referring referring = iterator.next();\n                     exception.addUnresolvedId(roid.getKey().key, referring.getBeanType(), referring.getLocation());\n                 }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.impl.NoClassDefFoundDeserializer;\n import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.type.*;\n     /**\n      * We will also cache some dynamically constructed deserializers;\n      * specifically, ones that are expensive to construct.\n-     * This currently means bean and Enum deserializers; array, List and Map\n-     * deserializers will not be cached.\n+     * This currently means bean and Enum deserializers; starting with\n+     * 2.5, container deserializers will also be cached.\n      *<p>\n      * Given that we don't expect much concurrency for additions\n      * (should very quickly converge to zero after startup), let's\n-     * explicitly define a low concurrency setting.\n+     * define a relatively low concurrency setting.\n      */\n     final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers\n-        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 2);\n+        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 4);\n \n     /**\n      * During deserializer construction process we may need to keep track of partially\n         if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n             type = factory.mapAbstractType(config, type);\n         }\n-        BeanDescription beanDesc = config.introspect(type);\n+        BeanDescription beanDesc;\n+        try {\n+            beanDesc = config.introspect(type);\n+        } catch (NoClassDefFoundError error) {\n+            return new NoClassDefFoundDeserializer<Object>(error);\n+        }\n         // Then: does type define explicit deserializer to use, with annotation(s)?\n         JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                 beanDesc.getClassInfo());\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n package com.fasterxml.jackson.databind.deser;\n \n import java.io.IOException;\n-import java.lang.reflect.*;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n      * information. Retained to allow contextualization of any properties.\n      */\n     protected final BeanProperty _property;\n-    \n-    /**\n-     * Physical JDK object used for assigning properties.\n-     *<p>\n-     * NOTE: must be marked transient since it is not serializable,\n-     * in case these are to be serialized\n-     */\n-    protected final transient Method _setter;\n+\n+    /**\n+     * Annotated variant is needed for JDK serialization only\n+     */\n+    final protected AnnotatedMethod _setter;\n \n     protected final JavaType _type;\n \n     /* Life-cycle\n     /**********************************************************\n      */\n-\n-    @Deprecated // since 2.3\n-    public SettableAnyProperty(BeanProperty property, AnnotatedMethod setter, JavaType type,\n-            JsonDeserializer<Object> valueDeser) {\n-        this(property, setter, type, valueDeser, null);\n-    }\n \n     public SettableAnyProperty(BeanProperty property, AnnotatedMethod setter, JavaType type,\n             JsonDeserializer<Object> valueDeser, TypeDeserializer typeDeser)\n     {\n-        this(property, setter.getAnnotated(), type, valueDeser, typeDeser);\n-    }\n-    \n-    @Deprecated // since 2.3\n-    public SettableAnyProperty(BeanProperty property, Method rawSetter, JavaType type,\n-            JsonDeserializer<Object> valueDeser) {\n-        this(property, rawSetter, type, valueDeser, null);\n-    }\n-    \n-    public SettableAnyProperty(BeanProperty property, Method rawSetter, JavaType type,\n-            JsonDeserializer<Object> valueDeser, TypeDeserializer typeDeser)\n-    {\n         _property = property;\n+        _setter = setter;\n         _type = type;\n-        _setter = rawSetter;\n         _valueDeserializer = valueDeser;\n         _valueTypeDeserializer = typeDeser;\n     }\n         return new SettableAnyProperty(_property, _setter, _type,\n                 deser, _valueTypeDeserializer);\n     }\n+\n+    /**\n+     * Constructor used for JDK Serialization when reading persisted object\n+     */\n+    protected SettableAnyProperty(SettableAnyProperty src)\n+    {\n+        _property = src._property;\n+        _setter = src._setter;\n+        _type = src._type;\n+        _valueDeserializer = src._valueDeserializer;\n+        _valueTypeDeserializer = src._valueTypeDeserializer;\n+    }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    // TODO (2.3): handle restoring of reference to any-setter method\n-    \n-/*\n+    /**\n+     * Need to define this to verify that we retain actual Method reference\n+     */\n     Object readResolve() {\n-        return new SettableAnyProperty(this, _annotated.getAnnotated());\n-    }\n-    */\n+        // sanity check...\n+        if (_setter == null || _setter.getAnnotated() == null) {\n+            throw new IllegalArgumentException(\"Missing method (broken JDK (de)serialization?)\");\n+        }\n+        return this;\n+    }\n     \n     /*\n     /**********************************************************\n     public void set(Object instance, String propName, Object value) throws IOException\n     {\n         try {\n-            _setter.invoke(instance, propName, value);\n+            // note: can not use 'setValue()' due to taking 2 args\n+            _setter.getAnnotated().invoke(instance, propName, value);\n         } catch (Exception e) {\n             _throwAsIOE(e, propName, value);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n                 contextAnnotations, propDef.getMetadata());\n     }\n \n-    @Deprecated // since 2.2\n-    protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper,\n-            TypeDeserializer typeDeser, Annotations contextAnnotations)\n-    {\n-        this(new PropertyName(propName), type, wrapper, typeDeser, contextAnnotations,\n-                PropertyMetadata.STD_OPTIONAL);\n-    }\n-\n     @Deprecated // since 2.3\n     protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper,\n             TypeDeserializer typeDeser, Annotations contextAnnotations,\n             boolean isRequired)\n     {\n         this(new PropertyName(propName), type, wrapper, typeDeser, contextAnnotations,\n-                PropertyMetadata.construct(isRequired, null, null));\n+                PropertyMetadata.construct(isRequired, null, null, null));\n     }\n     \n     protected SettableBeanProperty(PropertyName propName, JavaType type, PropertyName wrapper,\n      * that should be consumed to produce the value (the only value for\n      * scalars, multiple for Objects and Arrays).\n      */\n-    public abstract void deserializeAndSet(JsonParser jp,\n-    \t\tDeserializationContext ctxt, Object instance)\n-        throws IOException, JsonProcessingException;\n+    public abstract void deserializeAndSet(JsonParser p,\n+    \t\tDeserializationContext ctxt, Object instance) throws IOException;\n \n \t/**\n \t * Alternative to {@link #deserializeAndSet} that returns\n \t *\n \t * @since 2.0\n \t */\n-    public abstract Object deserializeSetAndReturn(JsonParser jp,\n-    \t\tDeserializationContext ctxt, Object instance)\n-        throws IOException, JsonProcessingException;\n+    public abstract Object deserializeSetAndReturn(JsonParser p,\n+    \t\tDeserializationContext ctxt, Object instance) throws IOException;\n \n     /**\n      * Method called to assign given value to this property, on\n      * implementations, creator-backed properties for example do not\n      * support this method.\n      */\n-    public abstract void set(Object instance, Object value)\n-        throws IOException;\n+    public abstract void set(Object instance, Object value) throws IOException;\n \n     /**\n      * Method called to assign given value to this property, on\n      * Note: this is an optional operation, not supported by all\n      * implementations, creator-backed properties for example do not\n      * support this method.\n-     * \n-     * @since 2.0\n-     */\n-    public abstract Object setAndReturn(Object instance, Object value)\n-            throws IOException;\n+     */\n+    public abstract Object setAndReturn(Object instance, Object value) throws IOException;\n     \n     /**\n      * This method is needed by some specialized bean deserializers,\n      * this method should also not be called directly unless you really know\n      * what you are doing (and probably not even then).\n      */\n-    public final Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonToken t = jp.getCurrentToken();\n+    public final Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n+    {\n+        JsonToken t = p.getCurrentToken();\n         \n         if (t == JsonToken.VALUE_NULL) {\n             return (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt);\n         }\n         if (_valueTypeDeserializer != null) {\n-            return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer);\n-        }\n-        return _valueDeserializer.deserialize(jp, ctxt);\n+            return _valueDeserializer.deserializeWithType(p, ctxt, _valueTypeDeserializer);\n+        }\n+        return _valueDeserializer.deserialize(p, ctxt);\n     }\n     \n     /*\n      * Method that takes in exception of any type, and casts or wraps it\n      * to an IOException or its subclass.\n      */\n-    protected void _throwAsIOE(Exception e, Object value)\n-        throws IOException\n+    protected void _throwAsIOE(Exception e, Object value) throws IOException\n     {\n         if (e instanceof IllegalArgumentException) {\n             String actType = (value == null) ? \"[NULL]\" : value.getClass().getName();\n         _throwAsIOE(e);\n     }\n \n-    protected IOException _throwAsIOE(Exception e)\n-        throws IOException\n+    protected IOException _throwAsIOE(Exception e) throws IOException\n     {\n         if (e instanceof IOException) {\n             throw (IOException) e;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n      */\n \n     protected final Object finishBuild(DeserializationContext ctxt, Object builder)\n-            throws IOException\n+        throws IOException\n     {\n         try {\n             return _buildMethod.getMember().invoke(builder);\n     }\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Let's delegate just in case we got a JSON Object (could error out, alternatively?)\n-        if (jp.getCurrentToken() != JsonToken.START_ARRAY) {\n-            return finishBuild(ctxt, _deserializeFromNonArray(jp, ctxt));\n+        if (!p.isExpectedStartArrayToken()) {\n+            return finishBuild(ctxt, _deserializeFromNonArray(p, ctxt));\n         }\n         if (!_vanillaProcessing) {\n-            return finishBuild(ctxt, _deserializeNonVanilla(jp, ctxt));\n+            return finishBuild(ctxt, _deserializeNonVanilla(p, ctxt));\n         }\n         Object builder = _valueInstantiator.createUsingDefault(ctxt);\n         final SettableBeanProperty[] props = _orderedProperties;\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return finishBuild(ctxt, builder);\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, builder, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return finishBuild(ctxt, builder);\n     }\n \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object builder)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object builder)\n+        throws IOException\n     {\n         /* No good way to verify that we have an array... although could I guess\n          * check via JsonParser. So let's assume everything is working fine, for now.\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return finishBuild(ctxt, builder);\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, builder, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return finishBuild(ctxt, builder);\n     }\n \n     // needed since 2.1\n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-    {\n-        return _deserializeFromNonArray(jp, ctxt);\n+    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n+    {\n+        return _deserializeFromNonArray(p, ctxt);\n     }\n     \n     /*\n      * \n      * @return Builder object in use.\n      */\n-    protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeNonVanilla(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_nonStandardCreation) {\n-            return _deserializeWithCreator(jp, ctxt);\n+            return _deserializeWithCreator(p, ctxt);\n         }\n         Object builder = _valueInstantiator.createUsingDefault(ctxt);\n         if (_injectables != null) {\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return builder;\n             }\n             if (i == propCount) {\n             if (prop != null) { // normal case\n                 if (activeView == null || prop.visibleInView(activeView)) {\n                     try {\n-                        prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                        prop.deserializeSetAndReturn(p, ctxt, builder);\n                     } catch (Exception e) {\n                         wrapAndThrow(e, builder, prop.getName(), ctxt);\n                     }\n                 }\n             }\n             // otherwise, skip it (view-filtered, no prop etc)\n-            jp.skipChildren();\n+            p.skipChildren();\n         }\n         // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n         if (!_ignoreAllUnknown) {\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return builder;\n     }\n     \n-    protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeWithCreator(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {        \n         if (_delegateDeserializer != null) {\n             return _valueInstantiator.createUsingDelegate(ctxt,\n-                    _delegateDeserializer.deserialize(jp, ctxt));\n+                    _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n-            return _deserializeUsingPropertyBased(jp, ctxt);\n+            return _deserializeUsingPropertyBased(p, ctxt);\n         }\n         // should only occur for abstract types...\n         if (_beanType.isAbstract()) {\n-            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+            throw JsonMappingException.from(p, \"Can not instantiate abstract type \"+_beanType\n                     +\" (need to add/enable type information?)\");\n         }\n-        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+        throw JsonMappingException.from(p, \"No suitable constructor found for type \"\n                 +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n     }\n \n      * as well.\n      */\n     @Override\n-    protected final Object _deserializeUsingPropertyBased(final JsonParser jp,\n+    protected final Object _deserializeUsingPropertyBased(final JsonParser p,\n             final DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n \n         final SettableBeanProperty[] props = _orderedProperties;\n         final int propCount = props.length;\n         int i = 0;\n         Object builder = null;\n         \n-        for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) {\n+        for (; p.nextToken() != JsonToken.END_ARRAY; ++i) {\n             SettableBeanProperty prop = (i < propCount) ? props[i] : null;\n             if (prop == null) { // we get null if there are extra elements; maybe otherwise too?\n-                jp.skipChildren();\n+                p.skipChildren();\n                 continue;\n             }\n             // if we have already constructed POJO, things are simple:\n             if (builder != null) {\n                 try {\n-                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, builder, prop.getName(), ctxt);\n                 }\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                     try {\n                         builder = creator.build(ctxt, buffer);\n                 continue;\n             }\n             // regular property? needs buffering\n-            buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n         }\n \n         // In case we didn't quite get all the creator properties, we may have to do this:\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n import java.util.HashSet;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n      */\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Let's delegate just in case we got a JSON Object (could error out, alternatively?)\n-        if (jp.getCurrentToken() != JsonToken.START_ARRAY) {\n-            return _deserializeFromNonArray(jp, ctxt);\n+        if (!p.isExpectedStartArrayToken()) {\n+            return _deserializeFromNonArray(p, ctxt);\n         }\n         if (!_vanillaProcessing) {\n-            return _deserializeNonVanilla(jp, ctxt);\n+            return _deserializeNonVanilla(p, ctxt);\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+\n         final SettableBeanProperty[] props = _orderedProperties;\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return bean;\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return bean;\n     }\n \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n+    {\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n         /* No good way to verify that we have an array... although could I guess\n          * check via JsonParser. So let's assume everything is working fine, for now.\n          */\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return bean;\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return bean;\n     }\n \n     // needed since 2.1\n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-    {\n-        return _deserializeFromNonArray(jp, ctxt);\n+    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        return _deserializeFromNonArray(p, ctxt);\n     }\n     \n     /*\n      * Alternate deserialization method that has to check many more configuration\n      * aspects than the \"vanilla\" processing.\n      */\n-    protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeNonVanilla(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_nonStandardCreation) {\n-            return _deserializeWithCreator(jp, ctxt);\n+            return _deserializeWithCreator(p, ctxt);\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return bean;\n             }\n             if (i == propCount) {\n             if (prop != null) { // normal case\n                 if (activeView == null || prop.visibleInView(activeView)) {\n                     try {\n-                        prop.deserializeAndSet(jp, ctxt, bean);\n+                        prop.deserializeAndSet(p, ctxt, bean);\n                     } catch (Exception e) {\n                         wrapAndThrow(e, bean, prop.getName(), ctxt);\n                     }\n                 }\n             }\n             // otherwise, skip it (view-filtered, no prop etc)\n-            jp.skipChildren();\n+            p.skipChildren();\n         }\n         // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n         if (!_ignoreAllUnknown) {\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return bean;\n     }\n     \n-    protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeWithCreator(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {        \n         if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n-            return _deserializeUsingPropertyBased(jp, ctxt);\n+            return _deserializeUsingPropertyBased(p, ctxt);\n         }\n         // should only occur for abstract types...\n         if (_beanType.isAbstract()) {\n-            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+            throw JsonMappingException.from(p, \"Can not instantiate abstract type \"+_beanType\n                     +\" (need to add/enable type information?)\");\n         }\n-        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+        throw JsonMappingException.from(p, \"No suitable constructor found for type \"\n                 +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n     }\n \n      * as well.\n      */\n     @Override\n-    protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected final Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n \n         final SettableBeanProperty[] props = _orderedProperties;\n         final int propCount = props.length;\n         int i = 0;\n         Object bean = null;\n         \n-        for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) {\n+        for (; p.nextToken() != JsonToken.END_ARRAY; ++i) {\n             SettableBeanProperty prop = (i < propCount) ? props[i] : null;\n             if (prop == null) { // we get null if there are extra elements; maybe otherwise too?\n-                jp.skipChildren();\n+                p.skipChildren();\n                 continue;\n             }\n             // if we have already constructed POJO, things are simple:\n             if (bean != null) {\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, prop.getName(), ctxt);\n                 }\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                     try {\n                         bean = creator.build(ctxt, buffer);\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         continue; // never gets here\n                     }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n+                    \n                     //  polymorphic?\n                     if (bean.getClass() != _beanType.getRawClass()) {\n                         /* 23-Jul-2012, tatu: Not sure if these could ever be properly\n                 continue;\n             }\n             // regular property? needs buffering\n-            buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n         }\n \n         // In case we didn't quite get all the creator properties, we may have to do this:\n     /**********************************************************\n      */\n \n-    protected Object _deserializeFromNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+    protected Object _deserializeFromNonArray(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Let's start with failure\n         throw ctxt.mappingException(\"Can not deserialize a POJO (of type \"+_beanType.getRawClass().getName()\n-                +\") from non-Array representation (token: \"+jp.getCurrentToken()\n+                +\") from non-Array representation (token: \"+p.getCurrentToken()\n                 +\"): type/property designed to be serialized as JSON Array\");\n         // in future, may allow use of \"standard\" POJO serialization as well; if so, do:\n         //return _delegate.deserialize(jp, ctxt);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n package com.fasterxml.jackson.databind.deser.impl;\n \n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n import java.util.*;\n \n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n     private final int _size;\n \n     /**\n+     * @since 2.5\n+     */\n+    private final boolean _caseInsensitive;\n+\n+    /**\n      * Counter we use to keep track of insertion order of properties\n      * (to be able to recreate insertion order when needed).\n      *<p>\n      */\n     private int _nextBucketIndex = 0;\n \n-    public BeanPropertyMap(Collection<SettableBeanProperty> properties)\n-    {\n+    public BeanPropertyMap(Collection<SettableBeanProperty> properties, boolean caseInsensitivePropertyComparison)\n+    {\n+        _caseInsensitive = caseInsensitivePropertyComparison;\n         _size = properties.size();\n         int bucketCount = findSize(_size);\n         _hashMask = bucketCount-1;\n         Bucket[] buckets = new Bucket[bucketCount];\n         for (SettableBeanProperty property : properties) {\n-            String key = property.getName();\n+            String key = getPropertyName(property);\n             int index = key.hashCode() & _hashMask;\n             buckets[index] = new Bucket(buckets[index], key, property, _nextBucketIndex++);\n         }\n         _buckets = buckets;\n     }\n \n-    private BeanPropertyMap(Bucket[] buckets, int size, int index)\n+    private BeanPropertyMap(Bucket[] buckets, int size, int index, boolean caseInsensitivePropertyComparison)\n     {\n         _buckets = buckets;\n         _size = size;\n         _hashMask = buckets.length-1;\n         _nextBucketIndex = index;\n+        _caseInsensitive = caseInsensitivePropertyComparison;\n     }\n     \n     /**\n         final int bcount = _buckets.length;\n         Bucket[] newBuckets = new Bucket[bcount];\n         System.arraycopy(_buckets, 0, newBuckets, 0, bcount);\n-        final String propName = newProperty.getName();\n+        final String propName = getPropertyName(newProperty);\n         // and then see if it's add or replace:\n-        SettableBeanProperty oldProp = find(newProperty.getName());\n+        SettableBeanProperty oldProp = find(propName);\n         if (oldProp == null) { // add\n             // first things first: add or replace?\n     \t        // can do a straight copy, since all additions are at the front\n     \t        int index = propName.hashCode() & _hashMask;\n     \t        newBuckets[index] = new Bucket(newBuckets[index],\n     \t                propName, newProperty, _nextBucketIndex++);\n-    \t        return new BeanPropertyMap(newBuckets, _size+1, _nextBucketIndex);\n+    \t        return new BeanPropertyMap(newBuckets, _size+1, _nextBucketIndex, _caseInsensitive);\n         }\n         // replace: easy, close + replace\n-        BeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex);\n+        BeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex, _caseInsensitive);\n         newMap.replace(newProperty);\n         return newMap;\n     }\n             newProps.add(prop);\n         }\n         // should we try to re-index? Ordering probably changed but called probably doesn't want changes...\n-        return new BeanPropertyMap(newProps);\n+        return new BeanPropertyMap(newProps, _caseInsensitive);\n     }\n     \n     public BeanPropertyMap assignIndexes()\n         }\n         return result;\n     }\n+    \n+    // Confining this case insensitivity to this function (and the find method) in case we want to\n+    // apply a particular locale to the lower case function.  For now, using the default.\n+    private String getPropertyName(SettableBeanProperty prop) {\n+        return _caseInsensitive ? prop.getName().toLowerCase() : prop.getName();\n+    }\n \n     /*\n     /**********************************************************\n         if (key == null) {\n             throw new IllegalArgumentException(\"Can not pass null property name\");\n         }\n+        if (_caseInsensitive) {\n+            key = key.toLowerCase();\n+        }\n         int index = key.hashCode() & _hashMask;\n         Bucket bucket = _buckets[index];\n         // Let's unroll first lookup since that is null or match in 90+% cases\n     }\n \n     /**\n+     * Convenience method that tries to find property with given name, and\n+     * if it is found, call {@link SettableBeanProperty#deserializeAndSet}\n+     * on it, and return true; or, if not found, return false.\n+     * Note, too, that if deserialization is attempted, possible exceptions\n+     * are wrapped if and as necessary, so caller need not handle those.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n+            Object bean, String key) throws IOException\n+    {\n+        if (_caseInsensitive) {\n+            key = key.toLowerCase();\n+        }\n+        int index = key.hashCode() & _hashMask;\n+        Bucket bucket = _buckets[index];\n+        // Let's unroll first lookup since that is null or match in 90+% cases\n+        if (bucket == null) {\n+            return false;\n+        }\n+        // Primarily we do just identity comparison as keys should be interned\n+        if (bucket.key == key) {\n+            try {\n+                bucket.value.deserializeAndSet(p, ctxt, bean);\n+            } catch (Exception e) {\n+                wrapAndThrow(e, bean, key, ctxt);\n+            }\n+            return true;\n+        } \n+        return _findDeserializeAndSet2(p, ctxt, bean, key, index);\n+    }\n+    \n+    private final boolean _findDeserializeAndSet2(JsonParser p, DeserializationContext ctxt,\n+            Object bean, String key, int index) throws IOException\n+    {\n+        SettableBeanProperty prop = null;\n+        Bucket bucket = _buckets[index];\n+        while (true) {\n+            if ((bucket = bucket.next) == null) {\n+                prop = _findWithEquals(key, index);\n+                if (prop == null) {\n+                    return false;\n+                }\n+                break;\n+            }\n+            if (bucket.key == key) {\n+                prop = bucket.value;\n+                break;\n+            }\n+        }\n+        try {\n+            prop.deserializeAndSet(p, ctxt, bean);\n+        } catch (Exception e) {\n+            wrapAndThrow(e, bean, key, ctxt);\n+        }\n+        return true;\n+    }\n+\n+    /**\n      * @since 2.3\n      */\n     public SettableBeanProperty find(int propertyIndex)\n      */\n     public void replace(SettableBeanProperty property)\n     {\n-        String name = property.getName();\n+        String name = getPropertyName(property);\n         int index = name.hashCode() & (_buckets.length-1);\n \n         /* This is bit tricky just because buckets themselves\n     public void remove(SettableBeanProperty property)\n     {\n         // Mostly this is the same as code with 'replace', just bit simpler...\n-        String name = property.getName();\n+        String name = getPropertyName(property);\n         int index = name.hashCode() & (_buckets.length-1);\n         Bucket tail = null;\n         boolean found = false;\n             bucket = bucket.next;\n         }\n         return null;\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected void wrapAndThrow(Throwable t, Object bean, String fieldName, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        // inlined 'throwOrReturnThrowable'\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        // StackOverflowErrors are tricky ones; need to be careful...\n+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n+        // Ditto for IOExceptions; except we may want to wrap JSON exceptions\n+        if (t instanceof IOException) {\n+            if (!wrap || !(t instanceof JsonProcessingException)) {\n+                throw (IOException) t;\n+            }\n+        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n+            if (t instanceof RuntimeException) {\n+                throw (RuntimeException) t;\n+            }\n+        }\n+        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n  */\n public class CreatorCollector\n {\n+    // Since 2.5\n+    protected final static int C_DEFAULT = 0;\n+    protected final static int C_STRING = 1;\n+    protected final static int C_INT = 2;\n+    protected final static int C_LONG = 3;\n+    protected final static int C_DOUBLE = 4;\n+    protected final static int C_BOOLEAN = 5;\n+    protected final static int C_DELEGATE = 6;\n+    protected final static int C_PROPS = 7;\n+\n+    protected final static String[] TYPE_DESCS = new String[] {\n+        \"default\",\n+        \"String\", \"int\", \"long\", \"double\", \"boolean\",\n+        \"delegate\", \"property-based\"\n+    };\n+\n     /// Type of bean being created\n     final protected BeanDescription _beanDesc;\n \n     final protected boolean _canFixAccess;\n \n     /**\n-     * Reference to the default creator (constructor or factory method).\n-     *<p>\n-     * Note: name is a misnomer, after resolving of [JACKSON-850], since this\n-     * can also point to factory method.\n-     */\n-    protected AnnotatedWithParams _defaultConstructor;\n-    \n-    protected AnnotatedWithParams _stringCreator, _intCreator, _longCreator;\n-    protected AnnotatedWithParams _doubleCreator, _booleanCreator;\n-\n-    protected AnnotatedWithParams _delegateCreator;\n+     * Set of creators we have collected so far\n+     * \n+     * @since 2.5\n+     */\n+    protected final AnnotatedWithParams[] _creators = new AnnotatedWithParams[8];\n+\n+    /**\n+     * Bitmask of creators that were explicitly marked as creators; false for auto-detected\n+     * (ones included base on naming and/or visibility, not annotation)\n+     * \n+     * @since 2.5\n+     */\n+    protected int _explicitCreators = 0;\n+    \n+    protected boolean _hasNonDefaultCreator = false;\n+    \n     // when there are injectable values along with delegate:\n     protected CreatorProperty[] _delegateArgs;\n     \n-    protected AnnotatedWithParams _propertyBasedCreator;\n-    protected CreatorProperty[] _propertyBasedArgs = null;\n+    protected CreatorProperty[] _propertyBasedArgs;\n \n     protected AnnotatedParameter _incompleteParameter;\n \n     public ValueInstantiator constructValueInstantiator(DeserializationConfig config)\n     {\n         JavaType delegateType;\n-        boolean maybeVanilla = _delegateCreator == null;\n-        \n-        if (maybeVanilla) {\n+        boolean maybeVanilla = !_hasNonDefaultCreator;\n+\n+        if (maybeVanilla || (_creators[C_DELEGATE] == null)) {\n             delegateType = null;\n         } else {\n             // need to find type...\n                 }\n             }\n             TypeBindings bindings = _beanDesc.bindingsForBeanType();\n-            delegateType = bindings.resolveType(_delegateCreator.getGenericParameterType(ix));\n+            delegateType = bindings.resolveType(_creators[C_DELEGATE].getGenericParameterType(ix));\n         }\n \n         final JavaType type = _beanDesc.getType();\n \n         // Any non-standard creator will prevent; with one exception: int-valued constructor\n         // that standard containers have can be ignored\n-        maybeVanilla &= (_propertyBasedCreator == null)\n-                && (_delegateCreator == null)\n-                && (_stringCreator == null)\n-                && (_longCreator == null)\n-                && (_doubleCreator == null)\n-                && (_booleanCreator == null)\n-                ;\n+        maybeVanilla &= !_hasNonDefaultCreator;\n \n         if (maybeVanilla) {\n             /* 10-May-2014, tatu: If we have nothing special, and we are dealing with one\n         }\n         \n         StdValueInstantiator inst = new StdValueInstantiator(config, type);\n-        inst.configureFromObjectSettings(_defaultConstructor,\n-                _delegateCreator, delegateType, _delegateArgs,\n-                _propertyBasedCreator, _propertyBasedArgs);\n-        inst.configureFromStringCreator(_stringCreator);\n-        inst.configureFromIntCreator(_intCreator);\n-        inst.configureFromLongCreator(_longCreator);\n-        inst.configureFromDoubleCreator(_doubleCreator);\n-        inst.configureFromBooleanCreator(_booleanCreator);\n+        inst.configureFromObjectSettings(_creators[C_DEFAULT],\n+                _creators[C_DELEGATE], delegateType, _delegateArgs,\n+                _creators[C_PROPS], _propertyBasedArgs);\n+        inst.configureFromStringCreator(_creators[C_STRING]);\n+        inst.configureFromIntCreator(_creators[C_INT]);\n+        inst.configureFromLongCreator(_creators[C_LONG]);\n+        inst.configureFromDoubleCreator(_creators[C_DOUBLE]);\n+        inst.configureFromBooleanCreator(_creators[C_BOOLEAN]);\n         inst.configureIncompleteParameter(_incompleteParameter);\n         return inst;\n     }\n      *   factory method.\n      */\n     public void setDefaultCreator(AnnotatedWithParams creator) {\n-        _defaultConstructor = _fixAccess(creator);\n-    }\n-    \n-    public void addStringCreator(AnnotatedWithParams creator) {\n-        _stringCreator = verifyNonDup(creator, _stringCreator, \"String\");\n-    }\n-    public void addIntCreator(AnnotatedWithParams creator) {\n-        _intCreator = verifyNonDup(creator, _intCreator, \"int\");\n-    }\n-    public void addLongCreator(AnnotatedWithParams creator) {\n-        _longCreator = verifyNonDup(creator, _longCreator, \"long\");\n-    }\n-    public void addDoubleCreator(AnnotatedWithParams creator) {\n-        _doubleCreator = verifyNonDup(creator, _doubleCreator, \"double\");\n-    }\n-    public void addBooleanCreator(AnnotatedWithParams creator) {\n-        _booleanCreator = verifyNonDup(creator, _booleanCreator, \"boolean\");\n-    }\n-\n-    public void addDelegatingCreator(AnnotatedWithParams creator,\n+        _creators[C_DEFAULT] = _fixAccess(creator);\n+    }\n+    \n+    public void addStringCreator(AnnotatedWithParams creator, boolean explicit) {\n+        verifyNonDup(creator, C_STRING, explicit);\n+    }\n+    public void addIntCreator(AnnotatedWithParams creator, boolean explicit) {\n+        verifyNonDup(creator, C_INT, explicit);\n+    }\n+    public void addLongCreator(AnnotatedWithParams creator, boolean explicit) {\n+        verifyNonDup(creator, C_LONG, explicit);\n+    }\n+    public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit) {\n+        verifyNonDup(creator, C_DOUBLE, explicit);\n+    }\n+    public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit) {\n+        verifyNonDup(creator, C_BOOLEAN, explicit);\n+    }\n+\n+    public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit,\n             CreatorProperty[] injectables)\n     {\n-        _delegateCreator = verifyNonDup(creator, _delegateCreator, \"delegate\");\n+        verifyNonDup(creator, C_DELEGATE, explicit);\n         _delegateArgs = injectables;\n     }\n     \n-    public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties)\n-    {\n-        _propertyBasedCreator = verifyNonDup(creator, _propertyBasedCreator, \"property-based\");\n+    public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,\n+            CreatorProperty[] properties)\n+    {\n+        verifyNonDup(creator, C_PROPS, explicit);\n         // [JACKSON-470] Better ensure we have no duplicate names either...\n         if (properties.length > 1) {\n             HashMap<String,Integer> names = new HashMap<String,Integer>();\n         }\n     }\n \n+    // Bunch of methods deprecated in 2.5, to be removed from 2.6 or later\n+    \n+    @Deprecated // since 2.5\n+    public void addStringCreator(AnnotatedWithParams creator) {\n+        addStringCreator(creator, false);\n+    }\n+    @Deprecated // since 2.5\n+    public void addIntCreator(AnnotatedWithParams creator) {\n+        addBooleanCreator(creator, false);\n+    }\n+    @Deprecated // since 2.5\n+    public void addLongCreator(AnnotatedWithParams creator) {\n+        addBooleanCreator(creator, false);\n+    }\n+    @Deprecated // since 2.5\n+    public void addDoubleCreator(AnnotatedWithParams creator) {\n+        addBooleanCreator(creator, false);\n+    }\n+    @Deprecated // since 2.5\n+    public void addBooleanCreator(AnnotatedWithParams creator) {\n+        addBooleanCreator(creator, false);\n+    }\n+\n+    @Deprecated // since 2.5\n+    public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables) {\n+        addDelegatingCreator(creator, false, injectables);\n+    }\n+\n+    @Deprecated // since 2.5\n+    public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) {\n+        addPropertyCreator(creator, false, properties);\n+    }\n+\n+    @Deprecated // since 2.5, remove from 2.6\n+    protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, int typeIndex) {\n+        verifyNonDup(newOne, typeIndex, false);\n+        return _creators[typeIndex];\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Accessors\n      * @since 2.1\n      */\n     public boolean hasDefaultCreator() {\n-        return _defaultConstructor != null;\n+        return _creators[C_DEFAULT] != null;\n     }\n \n     /*\n         return member;\n     }\n \n-    protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, AnnotatedWithParams oldOne,\n-            String type)\n-    {\n+    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n+    {\n+        final int mask = (1 << typeIndex);\n+        _hasNonDefaultCreator = true;\n+        AnnotatedWithParams oldOne = _creators[typeIndex];\n+        // already had an explicitly marked one?\n         if (oldOne != null) {\n-            // important: ok to override factory with constructor; but not within same type, so:\n-            if (oldOne.getClass() == newOne.getClass()) {\n-                throw new IllegalArgumentException(\"Conflicting \"+type+\" creators: already had \"+oldOne+\", encountered \"+newOne);\n-            }\n-        }\n-        return _fixAccess(newOne);\n+            boolean verify;\n+\n+            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n+                // but skip, if new one not annotated\n+                if (!explicit) {\n+                    return;\n+                }\n+                // both explicit: verify\n+                verify = true;\n+            } else {\n+                // otherwise only verify if neither explicitly annotated.\n+                verify = !explicit;\n+            }\n+\n+            // one more thing: ok to override in sub-class\n+            if (verify && (oldOne.getClass() == newOne.getClass())) {\n+                // [databind#667]: avoid one particular class of bogus problems\n+                Class<?> oldType = oldOne.getRawParameterType(0);\n+                Class<?> newType = newOne.getRawParameterType(0);\n+\n+                if (oldType == newType) {\n+                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n+                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n+                }\n+                // otherwise, which one to choose?\n+                if (newType.isAssignableFrom(oldType)) {\n+                    // new type more generic, use old\n+                    return;\n+                }\n+                // new type more specific, use it\n+            }\n+        }\n+        if (explicit) {\n+            _explicitCreators |= mask;\n+        }\n+        _creators[typeIndex] = _fixAccess(newOne);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n      */\n     public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt,\n             String propName, Object bean)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         Integer I = _nameToPropertyIndex.get(propName);\n         if (I == null) {\n      * @return True, if the given property was properly handled\n      */\n     public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt,\n-            String propName, Object bean)\n-        throws IOException, JsonProcessingException\n+            String propName, Object bean) throws IOException\n     {\n         Integer I = _nameToPropertyIndex.get(propName);\n         if (I == null) {\n     \n     @SuppressWarnings(\"resource\")\n     public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         for (int i = 0, len = _properties.length; i < len; ++i) {\n             String typeId = _typeIds[i];\n      */\n     public Object complete(JsonParser jp, DeserializationContext ctxt,\n             PropertyValueBuffer buffer, PropertyBasedCreator creator)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // first things first: deserialize all data buffered:\n         final int len = _properties.length;\n \n     @SuppressWarnings(\"resource\")\n     protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt,\n-            int index, String typeId)\n-        throws IOException, JsonProcessingException\n+            int index, String typeId) throws IOException\n     {\n         TokenBuffer merged = new TokenBuffer(jp);\n         merged.writeStartArray();\n \n     @SuppressWarnings(\"resource\")\n     protected final void _deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-            Object bean, int index, String typeId)\n-        throws IOException, JsonProcessingException\n+            Object bean, int index, String typeId) throws IOException\n     {\n         /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n          * style to ensure we can handle all kinds of JSON constructs.\n         p2.nextToken();\n         merged.copyCurrentStructure(p2);\n         merged.writeEndArray();\n-        \n         // needs to point to START_OBJECT (or whatever first token is)\n         p2 = merged.asParser(jp);\n         p2.nextToken();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java\n import java.lang.reflect.Field;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.PropertyName;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n     /**\n      * Constructor used for JDK Serialization when reading persisted object\n      */\n-    protected FieldProperty(FieldProperty src, Field f)\n+    protected FieldProperty(FieldProperty src)\n     {\n         super(src);\n         _annotated = src._annotated;\n+        Field f = _annotated.getAnnotated();\n         if (f == null) {\n-            throw new IllegalArgumentException(\"No Field passed for property '\"+src.getName()\n-                    +\"' (class \"+src.getDeclaringClass().getName()+\")\");\n+            throw new IllegalArgumentException(\"Missing field (broken JDK (de)serialization?)\");\n         }\n         _field = f;\n     }\n \n     @Override\n     public void deserializeAndSet(JsonParser jp,\n-    \t\tDeserializationContext ctxt, Object instance)\n-        throws IOException, JsonProcessingException\n+    \t\tDeserializationContext ctxt, Object instance) throws IOException\n     {\n-        set(instance, deserialize(jp, ctxt));\n+        Object value = deserialize(jp, ctxt);\n+        try {\n+            _field.set(instance, value);\n+        } catch (Exception e) {\n+            _throwAsIOE(e, value);\n+        }\n     }\n \n     @Override\n     public Object deserializeSetAndReturn(JsonParser jp,\n-    \t\tDeserializationContext ctxt, Object instance)\n-        throws IOException, JsonProcessingException\n+    \t\tDeserializationContext ctxt, Object instance) throws IOException\n     {\n-        return setAndReturn(instance, deserialize(jp, ctxt));\n+        Object value = deserialize(jp, ctxt);\n+        try {\n+            _field.set(instance, value);\n+        } catch (Exception e) {\n+            _throwAsIOE(e, value);\n+        }\n+        return instance;\n     }\n     \n     @Override\n-    public final void set(Object instance, Object value)\n-        throws IOException\n+    public final void set(Object instance, Object value) throws IOException\n     {\n         try {\n             _field.set(instance, value);\n     }\n \n     @Override\n-    public Object setAndReturn(Object instance, Object value)\n-        throws IOException\n+    public Object setAndReturn(Object instance, Object value) throws IOException\n     {\n         try {\n             _field.set(instance, value);\n      */\n \n     Object readResolve() {\n-        return new FieldProperty(this, _annotated.getAnnotated());\n+        return new FieldProperty(this);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Constructor;\n \n-import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.core.JsonToken;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.PropertyName;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n     protected final SettableBeanProperty _delegate;\n \n     /**\n-     * Single-arg constructor we use for value instantiation.\n+     * Constructor used when deserializing this property.\n+     * Transient since there is no need to persist; only needed during\n+     * construction of objects.\n      */\n-    protected final Constructor<?> _creator;\n+    final protected transient Constructor<?> _creator;\n     \n+    /**\n+     * Serializable version of single-arg constructor we use for value instantiation.\n+     */\n+    protected AnnotatedConstructor _annotated;\n+\n     public InnerClassProperty(SettableBeanProperty delegate,\n             Constructor<?> ctor)\n     {\n         _creator = ctor;\n     }\n \n+    /**\n+     * Constructor used with JDK Serialization; needed to handle transient\n+     * Constructor, wrap/unwrap in/out-of Annotated variant.\n+     */\n+    protected InnerClassProperty(InnerClassProperty src, AnnotatedConstructor ann)\n+    {\n+        super(src);\n+        _delegate = src._delegate;\n+        _annotated = ann;\n+        _creator = (_annotated == null) ? null : _annotated.getAnnotated();\n+        if (_creator == null) {\n+            throw new IllegalArgumentException(\"Missing constructor (broken JDK (de)serialization?)\");\n+        }\n+    }\n+    \n     protected InnerClassProperty(InnerClassProperty src, JsonDeserializer<?> deser)\n     {\n         super(src, deser);\n      */\n \n     @Override\n-    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-            Object bean)\n-        throws IOException, JsonProcessingException\n+    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean)\n+        throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         Object value;\n     @Override\n     public Object deserializeSetAndReturn(JsonParser jp,\n     \t\tDeserializationContext ctxt, Object instance)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         return setAndReturn(instance, deserialize(jp, ctxt));\n     }\n     \n     @Override\n-    public final void set(Object instance, Object value) throws IOException\n-    {\n+    public final void set(Object instance, Object value) throws IOException {\n         _delegate.set(instance, value);\n     }\n \n     @Override\n-    public Object setAndReturn(Object instance, Object value)\n-            throws IOException\n-    {\n-    \treturn _delegate.setAndReturn(instance, value);\n+    public Object setAndReturn(Object instance, Object value) throws IOException {\n+        return _delegate.setAndReturn(instance, value);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JDK serialization handling\n+    /**********************************************************\n+     */\n+\n+    // When reading things back, \n+    Object readResolve() {\n+        return new InnerClassProperty(this, _annotated);\n+    }\n+\n+    Object writeReplace() {\n+        // need to construct a fake instance to support serialization\n+        if (_annotated != null) {\n+            return this;\n+        }\n+        return new InnerClassProperty(this, new AnnotatedConstructor(null, _creator, null, null));\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java\n import java.lang.reflect.Method;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.PropertyName;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n     @Override\n     public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-            Object instance)\n-        throws IOException, JsonProcessingException\n+            Object instance) throws IOException\n     {\n-        set(instance, deserialize(jp, ctxt));\n+        Object value = deserialize(jp, ctxt);\n+        try {\n+            _setter.invoke(instance, value);\n+        } catch (Exception e) {\n+            _throwAsIOE(e, value);\n+        }\n     }\n \n     @Override\n     public Object deserializeSetAndReturn(JsonParser jp,\n     \t\tDeserializationContext ctxt, Object instance) throws IOException\n     {\n-        return setAndReturn(instance, deserialize(jp, ctxt));\n+        Object value = deserialize(jp, ctxt);\n+        try {\n+            Object result = _setter.invoke(instance, value);\n+            return (result == null) ? instance : result;\n+        } catch (Exception e) {\n+            _throwAsIOE(e, value);\n+            return null;\n+        }\n     }\n     \n     @Override\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/NoClassDefFoundDeserializer.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+\n+/**\n+ * A deserializer that stores a {@link NoClassDefFoundError} error\n+ * and throws the stored exception when attempting to deserialize\n+ * a value. Null and empty values can be deserialized without error.\n+ */\n+public class NoClassDefFoundDeserializer<T> extends JsonDeserializer<T>\n+{\n+    private final NoClassDefFoundError _cause;\n+\n+    public NoClassDefFoundDeserializer(NoClassDefFoundError cause)\n+    {\n+        _cause = cause;\n+    }\n+\n+    @Override\n+    public T deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        throw _cause;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.annotation.SimpleObjectIdResolver;\n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n \n      */\n     public final ObjectIdGenerator<?> generator;\n \n-    /**\n-     * \n-     */\n     public final ObjectIdResolver resolver;\n \n     /**\n         this(t,propName, gen, deser, idProp, new SimpleObjectIdResolver());\n     }\n \n-    @Deprecated // since 2.3\n-    protected ObjectIdReader(JavaType t, String propName, ObjectIdGenerator<?> gen,\n-            JsonDeserializer<?> deser, SettableBeanProperty idProp)\n-    {\n-        this(t, new PropertyName(propName), gen, deser, idProp);\n-    }\n-\n     /**\n      * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n      * with the initial information based on standard settings for the type\n     {\n         return construct(idType, propName, generator, deser, idProp, new SimpleObjectIdResolver());\n     }\n-    \n-    @Deprecated // since 2.3\n-    public static ObjectIdReader construct(JavaType idType, String propName,\n-            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n-            SettableBeanProperty idProp)\n-    {\n-        return construct(idType, new PropertyName(propName), generator, deser, idProp);\n-    }\n \n     /*\n     /**********************************************************\n     public JavaType getIdType() {\n         return _idType;\n     }\n+\n+    /**\n+     * Convenience method, equivalent to calling:\n+     *<code>\n+     *  readerInstance.generator.maySerializeAsObject();\n+     *</code>\n+     * and used to determine whether Object Ids handled by the underlying\n+     * generator may be in form of (JSON) Objects.\n+     * Used for optimizing handling in cases where method returns false.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean maySerializeAsObject() {\n+        return generator.maySerializeAsObject();\n+    }\n+\n+    /**\n+     * Convenience method, equivalent to calling:\n+     *<code>\n+     *  readerInstance.generator.isValidReferencePropertyName(name, parser);\n+     *</code>\n+     * and used to determine whether Object Ids handled by the underlying\n+     * generator may be in form of (JSON) Objects.\n+     * Used for optimizing handling in cases where method returns false.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isValidReferencePropertyName(String name, JsonParser parser) {\n+        return generator.isValidReferencePropertyName(name, parser);\n+    }\n     \n     /**\n      * Method called to read value that is expected to be an Object Reference\n      * \n      * @since 2.3\n      */\n-    public Object readObjectReference(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object readObjectReference(JsonParser jp, DeserializationContext ctxt) throws IOException {\n         return _deserializer.deserialize(jp, ctxt);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n import java.lang.annotation.Annotation;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.PropertyName;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\n import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n \n public class ObjectIdReferenceProperty extends SettableBeanProperty {\n-    private static final long serialVersionUID = 8465266677345565407L;\n-    private SettableBeanProperty _forward;\n+    private static final long serialVersionUID = 1L;\n+\n+    private final SettableBeanProperty _forward;\n \n     public ObjectIdReferenceProperty(SettableBeanProperty forward, ObjectIdInfo objectIdInfo)\n     {\n     }\n \n     @Override\n-    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance)\n-        throws IOException, JsonProcessingException\n-    {\n+    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n         deserializeSetAndReturn(jp, ctxt, instance);\n     }\n \n     @Override\n     public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n-        boolean usingIdentityInfo = (_objectIdInfo != null) || (_valueDeserializer.getObjectIdReader() != null);\n         try {\n             return setAndReturn(instance, deserialize(jp, ctxt));\n         } catch (UnresolvedForwardReference reference) {\n+            boolean usingIdentityInfo = (_objectIdInfo != null) || (_valueDeserializer.getObjectIdReader() != null);\n             if (!usingIdentityInfo) {\n                 throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n \n     protected final ObjectIdReader _objectIdReader;\n \n-    @Deprecated // since 2.2\n-    public ObjectIdValueProperty(ObjectIdReader objectIdReader) {\n-        this(objectIdReader, PropertyMetadata.STD_REQUIRED);\n-    }\n-    \n     public ObjectIdValueProperty(ObjectIdReader objectIdReader,\n             PropertyMetadata metadata)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n     /**\n      * Helper method called to handle Object Id value collected earlier, if any\n      */\n-    public Object handleIdValue(final DeserializationContext ctxt, Object bean)\n-        throws IOException\n+    public Object handleIdValue(final DeserializationContext ctxt, Object bean) throws IOException\n     {\n         if (_objectIdReader != null) {\n             if (_idValue != null) {\n                 }\n             } else {\n                 // TODO: is this an error case?\n+                throw ctxt.mappingException(\"No _idValue when handleIdValue called, on instance of \"\n+                        +bean.getClass().getName());\n             }\n         }\n         return bean;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java\n \n         // For [#501] fix we need to implement this but:\n         if (_valueTypeDeserializer != null) {\n-            throw new JsonMappingException(\"Problem deserializing 'setterless' property: no way to handle typed deser with setterless yet\");\n+            throw new JsonMappingException(\"Problem deserializing 'setterless' property (\\\"\"+getName()+\"\\\"): no way to handle typed deser with setterless yet\");\n //            return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer);\n         }\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/TypeWrappedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/TypeWrappedDeserializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n /**\n  */\n public final class TypeWrappedDeserializer\n     extends JsonDeserializer<Object>\n+    implements java.io.Serializable // since 2.5\n {\n-    final TypeDeserializer _typeDeserializer;\n-    final JsonDeserializer<Object> _deserializer;\n+    private static final long serialVersionUID = 1L;\n \n-    public TypeWrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<Object> deser)\n+    final protected TypeDeserializer _typeDeserializer;\n+    final protected JsonDeserializer<Object> _deserializer;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public TypeWrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<?> deser)\n     {\n         super();\n         _typeDeserializer = typeDeser;\n-        _deserializer = deser;\n+        _deserializer = (JsonDeserializer<Object>) deser;\n     }\n \n     @Override\n     }\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         return _deserializer.deserializeWithType(jp, ctxt, _typeDeserializer);\n     }\n \n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-        TypeDeserializer typeDeserializer)\n-            throws IOException, JsonProcessingException\n+        TypeDeserializer typeDeserializer) throws IOException\n     {\n         // should never happen? (if it can, could call on that object)\n         throw new IllegalStateException(\"Type-wrapped deserializer's deserializeWithType should never get called\");\n \n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt,\n-            Object intoValue)\n-        throws IOException, JsonProcessingException\n+            Object intoValue) throws IOException\n     {\n         /* 01-Mar-2013, tatu: Hmmh. Tough call as to what to do... need\n          *   to delegate, but will this work reliably? Let's just hope so:\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n     extends ContainerDeserializerBase<Collection<Object>>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = 3917273725180652224L;\n+    private static final long serialVersionUID = -1L; // since 2.5\n \n     // // Configuration\n \n                 (JsonDeserializer<Object>) vd, vtd,\n                 _valueInstantiator, (JsonDeserializer<Object>) dd);\n     }\n-    \n+\n+    // Important: do NOT cache if polymorphic values\n+    @Override // since 2.5\n+    public boolean isCachable() {\n+        return (_valueTypeDeserializer == null);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Validation, post-processing (ResolvableDeserializer)\n         JsonDeserializer<?> valueDeser = _valueDeserializer;\n         // #125: May have a content converter\n         valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n+        final JavaType vt = _collectionType.getContentType();\n         if (valueDeser == null) {\n-            valueDeser = ctxt.findContextualValueDeserializer(\n-                    _collectionType.getContentType(), property);\n+            valueDeser = ctxt.findContextualValueDeserializer(vt, property);\n         } else { // if directly assigned, probably not yet contextual, so:\n-            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property);\n+            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, vt);\n         }\n         // and finally, type deserializer needs context as well\n         TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n     \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt,\n-                    _delegateDeserializer.deserialize(jp, ctxt));\n+                    _delegateDeserializer.deserialize(p, ctxt));\n         }\n         /* [JACKSON-620]: empty String may be ok; bit tricky to check, however, since\n          *  there is also possibility of \"auto-wrapping\" of single-element arrays.\n          *  Hence we only accept empty String here.\n          */\n-        if (jp.getCurrentToken() == JsonToken.VALUE_STRING) {\n-            String str = jp.getText();\n+        if (p.getCurrentToken() == JsonToken.VALUE_STRING) {\n+            String str = p.getText();\n             if (str.length() == 0) {\n                 return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str);\n             }\n         }\n-        return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));\n-    }\n-\n-    @Override\n-    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+        return deserialize(p, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));\n+    }\n+\n+    @Override\n+    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt,\n             Collection<Object> result)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // Ok: must point to START_ARRAY (or equivalent)\n-        if (!jp.isExpectedStartArrayToken()) {\n-            return handleNonArray(jp, ctxt, result);\n-        }\n+        if (!p.isExpectedStartArrayToken()) {\n+            return handleNonArray(p, ctxt, result);\n+        }\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(result);\n \n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n                 new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);\n \n         JsonToken t;\n-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+        while ((t = p.nextToken()) != JsonToken.END_ARRAY) {\n             try {\n                 Object value;\n                 if (t == JsonToken.VALUE_NULL) {\n                     value = valueDes.getNullValue();\n                 } else if (typeDeser == null) {\n-                    value = valueDes.deserialize(jp, ctxt);\n+                    value = valueDes.deserialize(p, ctxt);\n                 } else {\n-                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                    value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n                 }\n                 if (referringAccumulator != null) {\n                     referringAccumulator.add(value);\n             } catch (UnresolvedForwardReference reference) {\n                 if (referringAccumulator == null) {\n                     throw JsonMappingException\n-                            .from(jp, \"Unresolved forward reference but no identity info\", reference);\n+                            .from(p, \"Unresolved forward reference but no identity info\", reference);\n                 }\n                 Referring ref = referringAccumulator.handleUnresolvedReference(reference);\n                 reference.getRoid().appendReferring(ref);\n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // In future could check current token... for now this should be enough:\n         return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n      * throw an exception, or try to handle value as if member of implicit\n      * array, depending on configuration.\n      */\n-    protected final Collection<Object> handleNonArray(JsonParser jp, DeserializationContext ctxt,\n+    protected final Collection<Object> handleNonArray(JsonParser p, DeserializationContext ctxt,\n             Collection<Object> result)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // [JACKSON-526]: implicit arrays from single values?\n         if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n         }\n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n \n         Object value;\n \n             if (t == JsonToken.VALUE_NULL) {\n                 value = valueDes.getNullValue();\n             } else if (typeDeser == null) {\n-                value = valueDes.deserialize(jp, ctxt);\n+                value = valueDes.deserialize(p, ctxt);\n             } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n             }\n         } catch (Exception e) {\n             // note: pass Object.class, not Object[].class, as we need element type for error info\n         private final CollectionReferringAccumulator _parent;\n         public final List<Object> next = new ArrayList<Object>();\n         \n-        private CollectionReferring(CollectionReferringAccumulator parent,\n+        CollectionReferring(CollectionReferringAccumulator parent,\n                 UnresolvedForwardReference reference, Class<?> contentType)\n         {\n             super(reference, contentType);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n \n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n \n /**\n      * Accesor for deserializer use for deserializing content values.\n      */\n     public abstract JsonDeserializer<Object> getContentDeserializer();\n+\n+    /*\n+    /**********************************************************\n+    /* Shared methods for sub-classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method called by various Map(-like) deserializers.\n+     */\n+    protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException\n+    {\n+        // to handle StackOverflow:\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors and \"plain\" IOExceptions to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        // ... except for mapping exceptions\n+        if (t instanceof IOException && !(t instanceof JsonMappingException)) {\n+            throw (IOException) t;\n+        }\n+        throw JsonMappingException.wrapWithPath(t, ref, key);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DelegatingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DelegatingDeserializer.java\n             BeanProperty property)\n         throws JsonMappingException\n     {\n-        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property);\n+        JavaType vt = ctxt.constructType(_delegatee.handledType());\n+        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee,\n+                property, vt);\n         if (del == _delegatee) {\n             return this;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n import java.lang.reflect.Method;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n \n public class EnumDeserializer\n     extends StdScalarDeserializer<Enum<?>>\n {\n-    private static final long serialVersionUID = -5893263645879532318L;\n+    private static final long serialVersionUID = 1L;\n \n     protected final EnumResolver<?> _resolver;\n     \n     {\n         // note: caller has verified there's just one arg; but we must verify its type\n         Class<?> paramClass = factory.getRawParameterType(0);\n-        if (paramClass == String.class) {\n-            paramClass = null;\n-        } else  if (paramClass == Integer.TYPE || paramClass == Integer.class) {\n-            paramClass = Integer.class;\n-        } else  if (paramClass == Long.TYPE || paramClass == Long.class) {\n-            paramClass = Long.class;\n-        } else {\n-            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory\n-                    +\") not suitable, must be java.lang.String or int/Integer/long/Long\");\n-        }\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(factory.getMember());\n         }\n      * for locating Enum values by String id.\n      */\n     protected static class FactoryBasedDeserializer\n-        extends StdScalarDeserializer<Object>\n-    {\n-        private static final long serialVersionUID = -7775129435872564122L;\n-\n-        protected final Class<?> _enumClass;\n+        extends StdDeserializer<Object>\n+        implements ContextualDeserializer\n+    {\n+        private static final long serialVersionUID = 1;\n+\n         // Marker type; null if String expected; otherwise numeric wrapper\n         protected final Class<?> _inputType;\n         protected final Method _factory;\n+        protected final JsonDeserializer<?> _deser;\n         \n         public FactoryBasedDeserializer(Class<?> cls, AnnotatedMethod f,\n                 Class<?> inputType)\n         {\n-            super(Enum.class);\n-            _enumClass = cls;\n+            super(cls);\n             _factory = f.getAnnotated();\n             _inputType = inputType;\n-        }\n-\n+            _deser = null;\n+        }\n+\n+        protected FactoryBasedDeserializer(FactoryBasedDeserializer base,\n+                JsonDeserializer<?> deser) {\n+            super(base._valueClass);\n+            _inputType = base._inputType;\n+            _factory = base._factory;\n+            _deser = deser;\n+        }\n+        \n         @Override\n-        public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+                BeanProperty property)\n+            throws JsonMappingException\n         {\n-            // couple of accepted types...\n+            if ((_deser == null) && (_inputType != String.class)) {\n+                return new FactoryBasedDeserializer(this,\n+                        ctxt.findContextualValueDeserializer(ctxt.constructType(_inputType), property));\n+            }\n+            return this;\n+        }\n+        \n+        @Override\n+        public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        {\n             Object value;\n-            if (_inputType == null) {\n-                value = jp.getText();\n-            } else  if (_inputType == Integer.class) {\n-                value = Integer.valueOf(jp.getValueAsInt());\n-            } else  if (_inputType == Long.class) {\n-                value = Long.valueOf(jp.getValueAsLong());\n+            if (_deser != null) {\n+                value = _deser.deserialize(jp, ctxt);\n             } else {\n-                throw ctxt.mappingException(_enumClass);\n+                value = jp.getValueAsString();\n             }\n             try {\n-                return _factory.invoke(_enumClass, value);\n+                return _factory.invoke(_valueClass, value);\n             } catch (Exception e) {\n                 Throwable t = ClassUtil.getRootCause(e);\n                 if (t instanceof IOException) {\n                     throw (IOException) t;\n                 }\n-                throw ctxt.instantiationException(_enumClass, t);\n-            }\n+                throw ctxt.instantiationException(_valueClass, t);\n+            }\n+        }\n+\n+        @Override\n+        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n+            if (_deser == null) { // String never has type info\n+                return deserialize(jp, ctxt);\n+            }\n+            return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n /**\n  * <p>\n  * Note: casting within this class is all messed up -- just could not figure out a way\n  * to properly deal with recursive definition of \"EnumMap<K extends Enum<K>, V>\n- * \n- * @author tsaloranta\n  */\n @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) \n public class EnumMapDeserializer\n-    extends StdDeserializer<EnumMap<?,?>>\n+    extends ContainerDeserializerBase<EnumMap<?,?>>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = 4564890642370311174L;\n+    private static final long serialVersionUID = 1;\n \n     protected final JavaType _mapType;\n     \n     protected final Class<?> _enumClass;\n \n-    protected JsonDeserializer<Enum<?>> _keyDeserializer;\n+    protected KeyDeserializer _keyDeserializer;\n \n     protected JsonDeserializer<Object> _valueDeserializer;\n \n     /**********************************************************\n      */\n \n-    public EnumMapDeserializer(JavaType mapType, JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser, TypeDeserializer valueTypeDeser)\n+    public EnumMapDeserializer(JavaType mapType, KeyDeserializer keyDeserializer, JsonDeserializer<?> valueDeser, TypeDeserializer valueTypeDeser)\n     {\n-        super(EnumMap.class);\n+        super(mapType);\n         _mapType = mapType;\n         _enumClass = mapType.getKeyType().getRawClass();\n-        _keyDeserializer = (JsonDeserializer<Enum<?>>) keyDeserializer;\n+        _keyDeserializer = keyDeserializer;\n         _valueDeserializer = (JsonDeserializer<Object>) valueDeser;\n         _valueTypeDeserializer = valueTypeDeser;\n     }\n \n-    public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n+    public EnumMapDeserializer withResolved(KeyDeserializer keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n     {\n         if ((keyDeserializer == _keyDeserializer) && (valueDeserializer == _valueDeserializer) && (valueTypeDeser == _valueTypeDeserializer)) {\n             return this;\n         // note: instead of finding key deserializer, with enums we actually\n         // work with regular deserializers (less code duplication; but not\n         // quite as clean as it ought to be)\n-        JsonDeserializer<?> kd = _keyDeserializer;\n+        KeyDeserializer kd = _keyDeserializer;\n         if (kd == null) {\n-            kd = ctxt.findContextualValueDeserializer(_mapType.getKeyType(), property);\n+            kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property);\n         }\n         JsonDeserializer<?> vd = _valueDeserializer;\n+        final JavaType vt = _mapType.getContentType();\n         if (vd == null) {\n-            vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property);\n+            vd = ctxt.findContextualValueDeserializer(vt, property);\n         } else { // if directly assigned, probably not yet contextual, so:\n-            vd = ctxt.handleSecondaryContextualization(vd, property);\n+            vd = ctxt.handleSecondaryContextualization(vd, property, vt);\n         }\n         TypeDeserializer vtd = _valueTypeDeserializer;\n         if (vtd != null) {\n      * let's cache instances by default.\n      */\n     @Override\n-    public boolean isCachable() { return true; }\n-    \n+    public boolean isCachable() {\n+        // Important: do NOT cache if polymorphic values\n+        return (_valueTypeDeserializer == null);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* ContainerDeserializerBase API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _mapType.getContentType();\n+    }\n+\n+    @Override\n+    public JsonDeserializer<Object> getContentDeserializer() {\n+        return _valueDeserializer;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Actual deserialization\n     /**********************************************************\n      */\n-\n+    \n     @Override\n-    public EnumMap<?,?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException\n+    public EnumMap<?,?> deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Ok: must point to START_OBJECT\n         if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.mappingException(EnumMap.class);\n+            return _deserializeFromEmpty(jp, ctxt);\n         }\n         EnumMap result = constructMap();\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n \n-        while ((jp.nextToken()) != JsonToken.END_OBJECT) {\n-            Enum<?> key = _keyDeserializer.deserialize(jp, ctxt);\n+        while ((jp.nextToken()) == JsonToken.FIELD_NAME) {\n+            String keyName = jp.getCurrentName(); // just for error message\n+            // but we need to let key deserializer handle it separately, nonetheless\n+            Enum<?> key = (Enum<?>) _keyDeserializer.deserializeKey(keyName, ctxt);\n             if (key == null) {\n                 if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-                    String value = null;\n-                    try { // bit ugly, but will have to do; works with usual scalars\n-                        if (jp.hasCurrentToken()) {\n-                            value = jp.getText();\n-                        }\n-                    } catch (Exception e) { }\n-                    throw ctxt.weirdStringException(value, _enumClass, \"value not one of declared Enum instance names\");\n+                    throw ctxt.weirdStringException(keyName, _enumClass, \"value not one of declared Enum instance names for \"\n+                            +_mapType.getKeyType());\n                 }\n                 /* 24-Mar-2012, tatu: Null won't work as a key anyway, so let's\n-                 *  just skip the entry then. But we must skip the value then.\n+                 *  just skip the entry then. But we must skip the value as well, if so.\n                  */\n                 jp.nextToken();\n                 jp.skipChildren();\n              * not handle them (and maybe fail or return bogus data)\n              */\n             Object value;\n-            \n-            if (t == JsonToken.VALUE_NULL) {\n-                value = valueDes.getNullValue();\n-            } else if (typeDeser == null) {\n-                value =  valueDes.deserialize(jp, ctxt);\n-            } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+\n+            try {\n+                if (t == JsonToken.VALUE_NULL) {\n+                    value = valueDes.getNullValue();\n+                } else if (typeDeser == null) {\n+                    value =  valueDes.deserialize(jp, ctxt);\n+                } else {\n+                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                }\n+            } catch (Exception e) {\n+                wrapAndThrow(e, result, keyName);\n+                return null;\n             }\n             result.put(key, value);\n         }\n     }\n \n     @Override\n-   public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer)\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer)\n         throws IOException, JsonProcessingException\n     {\n         // In future could check current token... for now this should be enough:\n         return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n     }\n     \n-    private EnumMap<?,?> constructMap() {\n+    protected EnumMap<?,?> constructMap() {\n         return new EnumMap(_enumClass);\n     }\n }\n+\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n     extends StdDeserializer<EnumSet<?>>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = 3479455075597887177L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     protected final JavaType _enumType;\n \n         if (deser == null) {\n             deser = ctxt.findContextualValueDeserializer(_enumType, property);\n         } else { // if directly assigned, probably not yet contextual, so:\n-            deser = ctxt.handleSecondaryContextualization(deser, property);\n+            deser = ctxt.handleSecondaryContextualization(deser, property, _enumType);\n         }\n         return withDeserializer(deser);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n     public BaseNodeDeserializer(Class<T> vc) {\n         super(vc);\n     }\n-    \n+\n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n         return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n     }\n \n+    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes\n+     *   sense to also mark this is cachable, since lookup not exactly free, and\n+     *   since it's not uncommon to \"read anything\"\n+     */\n+    @Override\n+    public boolean isCachable() { return true; }\n+\n     /*\n     /**********************************************************\n     /* Overridable methods\n     /**********************************************************\n      */\n-    \n+\n     protected void _reportProblem(JsonParser jp, String msg) throws JsonMappingException {\n         throw new JsonMappingException(msg, jp.getTokenLocation());\n     }\n-    \n+\n     /**\n      * \n      * @deprecated Since 2.3, use the overloaded variant\n         // Backwards-compatibility; call in case it's overloaded\n         _handleDuplicateField(fieldName, objectNode, oldValue, newValue);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Helper methods\n     /**********************************************************\n      */\n-    \n+\n     protected final ObjectNode deserializeObject(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)            \n-        throws IOException, JsonProcessingException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         ObjectNode node = nodeFactory.objectNode();\n         JsonToken t = jp.getCurrentToken();\n         }\n         return node;\n     }\n-    \n+\n     protected final ArrayNode deserializeArray(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)            \n-        throws IOException, JsonProcessingException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         ArrayNode node = nodeFactory.arrayNode();\n         while (true) {\n             }\n         }\n     }\n-    \n+\n     protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)            \n-        throws IOException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         switch (jp.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n     }\n \n     protected final JsonNode _fromInt(JsonParser jp, DeserializationContext ctxt,\n-            JsonNodeFactory nodeFactory)\n-        throws IOException\n+            JsonNodeFactory nodeFactory) throws IOException\n     {\n         JsonParser.NumberType nt = jp.getNumberType();\n         if (nt == JsonParser.NumberType.BIG_INTEGER\n     }\n \n     protected final JsonNode _fromFloat(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)\n-        throws IOException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         JsonParser.NumberType nt = jp.getNumberType();\n         if (nt == JsonParser.NumberType.BIG_DECIMAL\n     }\n \n     protected final JsonNode _fromEmbedded(JsonParser jp, DeserializationContext ctxt,\n-            JsonNodeFactory nodeFactory)\n-        throws IOException\n+            JsonNodeFactory nodeFactory) throws IOException\n     {\n         // [JACKSON-796]\n         Object ob = jp.getEmbeddedObject();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n package com.fasterxml.jackson.databind.deser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n     extends ContainerDeserializerBase<Map<Object,Object>>\n     implements ContextualDeserializer, ResolvableDeserializer\n {\n-    private static final long serialVersionUID = -3378654289961736240L;\n+    private static final long serialVersionUID = 1L;\n \n     // // Configuration: typing, deserializers\n \n         JsonDeserializer<?> vd = _valueDeserializer;\n         // #125: May have a content converter\n         vd = findConvertingContentDeserializer(ctxt, property, vd);\n+        final JavaType vt = _mapType.getContentType();\n         if (vd == null) {\n-            vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property);\n+            vd = ctxt.findContextualValueDeserializer(vt, property);\n         } else { // if directly assigned, probably not yet contextual, so:\n-            vd = ctxt.handleSecondaryContextualization(vd, property);\n+            vd = ctxt.handleSecondaryContextualization(vd, property, vt);\n         }\n         TypeDeserializer vtd = _valueTypeDeserializer;\n         if (vtd != null) {\n         }\n         return withResolved(kd, vtd, vd, ignored);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* ContainerDeserializerBase API\n             if (t == JsonToken.VALUE_STRING) {\n                 return (Map<Object,Object>) _valueInstantiator.createFromString(ctxt, jp.getText());\n             }\n-            throw ctxt.mappingException(getMapClass());\n+            // slightly redundant (since String was passed above), but\n+            return _deserializeFromEmpty(jp, ctxt);\n         }\n         final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n         if (_standardStringKey) {\n     }\n \n     @Override\n-    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+    public Map<Object,Object> deserialize(JsonParser p, DeserializationContext ctxt,\n             Map<Object,Object> result)\n-        throws IOException, JsonProcessingException\n-    {\n+        throws IOException\n+    {\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(result);\n+        \n         // Ok: must point to START_OBJECT or FIELD_NAME\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n         if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n             throw ctxt.mappingException(getMapClass());\n         }\n         if (_standardStringKey) {\n-            _readAndBindStringMap(jp, ctxt, result);\n+            _readAndBindStringMap(p, ctxt, result);\n             return result;\n         }\n-        _readAndBind(jp, ctxt, result);\n+        _readAndBind(p, ctxt, result);\n         return result;\n     }\n \n             }\n         }\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\") \n     public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     protected void wrapAndThrow(Throwable t, Object ref) throws IOException {\n         wrapAndThrow(t, ref, null);\n     }\n-    \n-    // note: copied from BeanDeserializer; should try to share somehow...\n-    protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException\n-    {\n-        // to handle StackOverflow:\n-        while (t instanceof InvocationTargetException && t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        // Errors and \"plain\" IOExceptions to be passed as is\n-        if (t instanceof Error) {\n-            throw (Error) t;\n-        }\n-        // ... except for mapping exceptions\n-        if (t instanceof IOException && !(t instanceof JsonMappingException)) {\n-            throw (IOException) t;\n-        }\n-        throw JsonMappingException.wrapWithPath(t, ref, key);\n-    }\n \n     private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator,\n             Object key, UnresolvedForwardReference reference)\n      * object associated with {@link #_id} comes before the values in\n      * {@link _next}.\n      */\n-    private final static class MapReferring extends Referring {\n+    final static class MapReferring extends Referring {\n         private final MapReferringAccumulator _parent;\n \n         public final Map<Object, Object> next = new LinkedHashMap<Object, Object>();\n         public final Object key;\n         \n-        protected MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n+        MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n                 Class<?> valueType, Object key)\n         {\n             super(ref, valueType);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapEntryDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+\n+/**\n+ * Basic serializer that can take JSON \"Object\" structure and\n+ * construct a {@link java.util.Map} instance, with typed contents.\n+ *<p>\n+ * Note: for untyped content (one indicated by passing Object.class\n+ * as the type), {@link UntypedObjectDeserializer} is used instead.\n+ * It can also construct {@link java.util.Map}s, but not with specific\n+ * POJO types, only other containers and primitives/wrappers.\n+ */\n+@JacksonStdImpl\n+public class MapEntryDeserializer\n+    extends ContainerDeserializerBase<Map.Entry<Object,Object>>\n+    implements ContextualDeserializer\n+{\n+    private static final long serialVersionUID = 1;\n+\n+    // // Configuration: typing, deserializers\n+\n+    protected final JavaType _type;\n+\n+    /**\n+     * Key deserializer to use; either passed via constructor\n+     * (when indicated by annotations), or resolved when\n+     * {@link #createContextual} is called;\n+     */\n+    protected final KeyDeserializer _keyDeserializer;\n+\n+    /**\n+     * Value deserializer.\n+     */\n+    protected final JsonDeserializer<Object> _valueDeserializer;\n+\n+    /**\n+     * If value instances have polymorphic type information, this\n+     * is the type deserializer that can handle it\n+     */\n+    protected final TypeDeserializer _valueTypeDeserializer;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public MapEntryDeserializer(JavaType type,\n+            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n+            TypeDeserializer valueTypeDeser)\n+    {\n+        super(type);\n+        if (type.containedTypeCount() != 2) { // sanity check\n+            throw new IllegalArgumentException(\"Missing generic type information for \"+type);\n+        }\n+        _type = type;\n+        _keyDeserializer = keyDeser;\n+        _valueDeserializer = valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n+    }\n+\n+    /**\n+     * Copy-constructor that can be used by sub-classes to allow\n+     * copy-on-write styling copying of settings of an existing instance.\n+     */\n+    protected MapEntryDeserializer(MapEntryDeserializer src)\n+    {\n+        super(src._type);\n+        _type = src._type;\n+        _keyDeserializer = src._keyDeserializer;\n+        _valueDeserializer = src._valueDeserializer;\n+        _valueTypeDeserializer = src._valueTypeDeserializer;\n+    }\n+\n+    protected MapEntryDeserializer(MapEntryDeserializer src,\n+            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n+            TypeDeserializer valueTypeDeser)\n+    {\n+        super(src._type);\n+        _type = src._type;\n+        _keyDeserializer = keyDeser;\n+        _valueDeserializer = valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n+    }\n+\n+    /**\n+     * Fluent factory method used to create a copy with slightly\n+     * different settings. When sub-classing, MUST be overridden.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected MapEntryDeserializer withResolved(KeyDeserializer keyDeser,\n+            TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser)\n+    {\n+        \n+        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser)\n+                && (_valueTypeDeserializer == valueTypeDeser)) {\n+            return this;\n+        }\n+        return new MapEntryDeserializer(this,\n+                keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Validation, post-processing (ResolvableDeserializer)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to finalize setup of this deserializer,\n+     * when it is known for which property deserializer is needed for.\n+     */\n+    @Override\n+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        KeyDeserializer kd = _keyDeserializer;\n+        if (kd == null) {\n+            kd = ctxt.findKeyDeserializer(_type.containedType(0), property);\n+        } else {\n+            if (kd instanceof ContextualKeyDeserializer) {\n+                kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property);\n+            }\n+        }\n+        JsonDeserializer<?> vd = _valueDeserializer;\n+        vd = findConvertingContentDeserializer(ctxt, property, vd);\n+        JavaType contentType = _type.containedType(1);\n+        if (vd == null) {\n+            vd = ctxt.findContextualValueDeserializer(contentType, property);\n+        } else { // if directly assigned, probably not yet contextual, so:\n+            vd = ctxt.handleSecondaryContextualization(vd, property, contentType);\n+        }\n+        TypeDeserializer vtd = _valueTypeDeserializer;\n+        if (vtd != null) {\n+            vtd = vtd.forProperty(property);\n+        }\n+        return withResolved(kd, vtd, vd);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* ContainerDeserializerBase API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _type.containedType(1);\n+    }\n+\n+    @Override\n+    public JsonDeserializer<Object> getContentDeserializer() {\n+        return _valueDeserializer;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Map.Entry<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    {\n+        // Ok: must point to START_OBJECT, FIELD_NAME or END_OBJECT\n+        JsonToken t = jp.getCurrentToken();\n+        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n+            // [JACKSON-620] (empty) String may be ok however:\n+            // slightly redundant (since String was passed above), but\n+            return _deserializeFromEmpty(jp, ctxt);\n+        }\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        }\n+        if (t != JsonToken.FIELD_NAME) {\n+            if (t == JsonToken.END_OBJECT) {\n+                throw ctxt.mappingException(\"Can not deserialize a Map.Entry out of empty JSON Object\");\n+            }\n+            throw ctxt.mappingException(handledType(), t);\n+        }\n+        \n+        final KeyDeserializer keyDes = _keyDeserializer;\n+        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n+        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+\n+        final String keyStr = jp.getCurrentName();\n+        Object key = keyDes.deserializeKey(keyStr, ctxt);\n+        Object value = null;\n+        // And then the value...\n+        t = jp.nextToken();\n+        try {\n+            // Note: must handle null explicitly here; value deserializers won't\n+            if (t == JsonToken.VALUE_NULL) {\n+                value = valueDes.getNullValue();\n+            } else if (typeDeser == null) {\n+                value = valueDes.deserialize(jp, ctxt);\n+            } else {\n+                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+            }\n+        } catch (Exception e) {\n+            wrapAndThrow(e, Map.Entry.class, keyStr);\n+        }\n+\n+        // Close, but also verify that we reached the END_OBJECT\n+        t = jp.nextToken();\n+        if (t != JsonToken.END_OBJECT) {\n+            if (t == JsonToken.FIELD_NAME) { // most likely\n+                throw ctxt.mappingException(\"Problem binding JSON into Map.Entry: more than one entry in JSON (second field: '\"+jp.getCurrentName()+\"')\");\n+            }\n+            // how would this occur?\n+            throw ctxt.mappingException(\"Problem binding JSON into Map.Entry: unexpected content after JSON Object entry: \"+t);\n+        }\n+        return new AbstractMap.SimpleEntry<Object,Object>(key, value);\n+    }\n+\n+    @Override\n+    public Map.Entry<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+            Map.Entry<Object,Object> result) throws IOException\n+    {\n+        throw new IllegalStateException(\"Can not update Map.Entry values\");\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        // In future could check current token... for now this should be enough:\n+        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Other public accessors\n+    /**********************************************************\n+     */\n+\n+    @Override public JavaType getValueType() { return _type; }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.class, Boolean.FALSE);\n-        private final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.TYPE, null);\n+        final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.class, Boolean.FALSE);\n+        final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.TYPE, null);\n         \n         public BooleanDeserializer(Class<Boolean> cls, Boolean nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0);\n-        private final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null);\n+        final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0);\n+        final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null);\n         \n         public ByteDeserializer(Class<Byte> cls, Byte nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.class, Short.valueOf((short)0));\n-        private final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.TYPE, null);\n+        final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.class, Short.valueOf((short)0));\n+        final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.TYPE, null);\n         \n         public ShortDeserializer(Class<Short> cls, Short nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.class, '\\0');\n-        private final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.TYPE, null);\n+        final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.class, '\\0');\n+        final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.TYPE, null);\n         \n         public CharacterDeserializer(Class<Character> cls, Character nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.class, 0);\n-        private final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.TYPE, null);\n+        final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.class, 0);\n+        final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.TYPE, null);\n         \n         public IntegerDeserializer(Class<Integer> cls, Integer nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static LongDeserializer primitiveInstance = new LongDeserializer(Long.class, Long.valueOf(0L));\n-        private final static LongDeserializer wrapperInstance = new LongDeserializer(Long.TYPE, null);\n+        final static LongDeserializer primitiveInstance = new LongDeserializer(Long.class, Long.valueOf(0L));\n+        final static LongDeserializer wrapperInstance = new LongDeserializer(Long.TYPE, null);\n         \n         public LongDeserializer(Class<Long> cls, Long nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.class, 0.f);\n-        private final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.TYPE, null);\n+        final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.class, 0.f);\n+        final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.TYPE, null);\n         \n         public FloatDeserializer(Class<Float> cls, Float nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.class, 0.d);\n-        private final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.TYPE, null);\n+        final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.class, 0.d);\n+        final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.TYPE, null);\n         \n         public DoubleDeserializer(Class<Double> cls, Double nvl)\n         {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n         JsonDeserializer<?> deser = _elementDeserializer;\n         // #125: May have a content converter\n         deser = findConvertingContentDeserializer(ctxt, property, deser);\n+        final JavaType vt = _arrayType.getContentType();\n         if (deser == null) {\n-            deser = ctxt.findContextualValueDeserializer(_arrayType.getContentType(), property);\n+            deser = ctxt.findContextualValueDeserializer(vt, property);\n         } else { // if directly assigned, probably not yet contextual, so:\n-            deser = ctxt.handleSecondaryContextualization(deser, property);\n+            deser = ctxt.handleSecondaryContextualization(deser, property, vt);\n         }\n         TypeDeserializer elemTypeDeser = _elementTypeDeserializer;\n         if (elemTypeDeser != null) {\n             elemTypeDeser = elemTypeDeser.forProperty(property);\n         }\n         return withDeserializer(elemTypeDeser, deser);\n+    }\n+\n+    @Override // since 2.5\n+    public boolean isCachable() {\n+        // Important: do NOT cache if polymorphic values\n+        return (_elementTypeDeserializer == null);\n     }\n     \n     /*\n                 chunk[ix++] = value;\n             }\n         } catch (Exception e) {\n-            throw JsonMappingException.wrapWithPath(e, chunk, ix);\n+            throw JsonMappingException.wrapWithPath(e, chunk, buffer.bufferedSize() + ix);\n         }\n \n         Object[] result;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n \n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+            TypeDeserializer typeDeserializer) throws IOException\n     {\n         /* Should there be separate handling for base64 stuff?\n          * for now this should be enough:\n         public CharDeser() { super(char[].class); }\n \n         @Override\n-        public char[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             /* Won't take arrays, must get a String (could also\n              * convert other tokens to Strings... but let's not bother\n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n-            }\n-            return builder.completeAndClearBuffer(chunk, ix);\n-        }\n-\n-        private final boolean[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n+            }\n+            return builder.completeAndClearBuffer(chunk, ix);\n+        }\n+\n+        private final boolean[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n         public ByteDeser() { super(byte[].class); }\n \n         @Override\n-        public byte[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             JsonToken t = jp.getCurrentToken();\n             \n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n-            }\n-            return builder.completeAndClearBuffer(chunk, ix);\n-        }\n-\n-        private final byte[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n+            }\n+            return builder.completeAndClearBuffer(chunk, ix);\n+        }\n+\n+        private final byte[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n         public ShortDeser() { super(short[].class); }\n \n         @Override\n-        public short[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             if (!jp.isExpectedStartArrayToken()) {\n                 return handleNonArray(jp, ctxt);\n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n-            }\n-            return builder.completeAndClearBuffer(chunk, ix);\n-        }\n-\n-        private final short[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n+            }\n+            return builder.completeAndClearBuffer(chunk, ix);\n+        }\n+\n+        private final short[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n         public IntDeser() { super(int[].class); }\n \n         @Override\n-        public int[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             if (!jp.isExpectedStartArrayToken()) {\n                 return handleNonArray(jp, ctxt);\n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n-            }\n-            return builder.completeAndClearBuffer(chunk, ix);\n-        }\n-\n-        private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n+            }\n+            return builder.completeAndClearBuffer(chunk, ix);\n+        }\n+\n+        private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n         public LongDeser() { super(long[].class); }\n \n         @Override\n-        public long[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             if (!jp.isExpectedStartArrayToken()) {\n                 return handleNonArray(jp, ctxt);\n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n-            }\n-            return builder.completeAndClearBuffer(chunk, ix);\n-        }\n-\n-        private final long[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n+            }\n+            return builder.completeAndClearBuffer(chunk, ix);\n+        }\n+\n+        private final long[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n         public DoubleDeser() { super(double[].class); }\n \n         @Override\n-        public double[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             if (!jp.isExpectedStartArrayToken()) {\n                 return handleNonArray(jp, ctxt);\n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n-            }\n-            return builder.completeAndClearBuffer(chunk, ix);\n-        }\n-\n-        private final double[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n+            }\n+            return builder.completeAndClearBuffer(chunk, ix);\n+        }\n+\n+        private final double[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java\n  *<p>\n  * Note that although types (delegate, target) may be related, they must not be same; trying\n  * to do this will result in an exception.\n+ *<p>\n+ * Since 2.5 There is {@link StdNodeBasedDeserializer} that is a simplified version\n+ * for cases where intermediate type is {@link JsonNode}\n  * \n  * @param <T> Target type to convert to, from delegate type\n  * \n  * @since 2.1\n+ * \n+ * @see StdNodeBasedDeserializer\n+ * @see Converter\n  */\n public class StdDelegatingDeserializer<T>\n     extends StdDeserializer<T>\n     private static final long serialVersionUID = 1L;\n \n     protected final Converter<Object,T> _converter;\n-    \n+\n     /**\n      * Fully resolved delegate type, with generic information if any available.\n      */\n     protected final JavaType _delegateType;\n-    \n+\n     /**\n      * Underlying serializer for type <code>T<.code>.\n      */\n     protected final JsonDeserializer<Object> _delegateDeserializer;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n         _delegateType = null;\n         _delegateDeserializer = null;\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public StdDelegatingDeserializer(Converter<Object,T> converter,\n             JavaType delegateType, JsonDeserializer<?> delegateDeserializer)\n     }\n \n     /**\n+     * @since 2.5\n+     */\n+    protected StdDelegatingDeserializer(StdDelegatingDeserializer<T> src)\n+    {\n+        super(src);\n+        _converter = src._converter;\n+        _delegateType = src._delegateType;\n+        _delegateDeserializer = src._delegateDeserializer;\n+    }\n+\n+    /**\n      * Method used for creating resolved contextual instances. Must be\n      * overridden when sub-classing.\n      */\n             ((ResolvableDeserializer) _delegateDeserializer).resolve(ctxt);\n         }\n     }\n-    \n+\n     @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n         throws JsonMappingException\n     {\n         // First: if already got serializer to delegate to, contextualize it:\n         if (_delegateDeserializer != null) {\n-            JsonDeserializer<?> deser = ctxt.handleSecondaryContextualization(_delegateDeserializer, property);\n+            JsonDeserializer<?> deser = ctxt.handleSecondaryContextualization(_delegateDeserializer,\n+                    property, _delegateType);\n             if (deser != _delegateDeserializer) {\n                 return withDelegate(_converter, _delegateType, deser);\n             }\n     public Class<?> handledType() {\n         return _delegateDeserializer.handledType();\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Serialization\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n         _valueClass = (valueType == null) ? null : valueType.getRawClass();\n     }\n \n+    /**\n+     * Copy-constructor for sub-classes to use, most often when creating\n+     * new instances for {@link com.fasterxml.jackson.databind.deser.ContextualDeserializer}.\n+     * \n+     * @since 2.5\n+     */\n+    protected StdDeserializer(StdDeserializer<?> src) {\n+        _valueClass = src._valueClass;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Accessors\n             }\n             throw ctxt.weirdStringException(text, _valueClass, \"only \\\"true\\\" or \\\"false\\\" recognized\");\n         }\n-        // Issue#381\n+        // [databind#381]\n         if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n             jp.nextToken();\n             final boolean parsed = _parseBooleanPrimitive(jp, ctxt);\n         throw ctxt.mappingException(String.class, jp.getCurrentToken());\n     }\n \n+    /**\n+     * Helper method that may be used to support fallback for Empty String / Empty Array\n+     * non-standard representations; usually for things serialized as JSON Objects.\n+     * \n+     * @since 2.5\n+     */\n+    protected T _deserializeFromEmpty(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.START_ARRAY) {\n+            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n+                t = jp.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    return null;\n+                }\n+                throw ctxt.mappingException(handledType(), JsonToken.START_ARRAY);\n+            }\n+        } else if (t == JsonToken.VALUE_STRING) {\n+            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                String str = jp.getText().trim();\n+                if (str.isEmpty()) {\n+                    return null;\n+                }\n+            }\n+        }\n+        throw ctxt.mappingException(handledType());\n+    }\n+    \n     /**\n      * Helper method called to determine if we are seeing String value of\n      * \"null\", and, further, that it should be coerced to null just like\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n import java.io.IOException;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URL;\n import java.util.Calendar;\n+import java.util.Currency;\n import java.util.Date;\n import java.util.Locale;\n import java.util.UUID;\n     public final static int TYPE_DATE = 10;\n     public final static int TYPE_CALENDAR = 11;\n     public final static int TYPE_UUID = 12;\n+    public final static int TYPE_URI = 13;\n+    public final static int TYPE_URL = 14;\n+    public final static int TYPE_CLASS = 15;\n+    public final static int TYPE_CURRENCY = 16;\n \n     final protected int _kind;\n     final protected Class<?> _keyClass;\n             kind = TYPE_FLOAT;\n         } else if (raw == Double.class) {\n             kind = TYPE_DOUBLE;\n+        } else if (raw == URI.class) {\n+            kind = TYPE_URI;\n+        } else if (raw == URL.class) {\n+            kind = TYPE_URL;\n+        } else if (raw == Class.class) {\n+            kind = TYPE_CLASS;\n         } else if (raw == Locale.class) {\n             FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n             return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n+        } else if (raw == Currency.class) {\n+            FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class);\n+            return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser);\n         } else {\n             return null;\n         }\n             return _parseLong(key);\n \n         case TYPE_FLOAT:\n-            /* 22-Jan-2009, tatu: Bounds/range checks would be tricky\n-             *   here, so let's not bother even trying...\n-             */\n+            // Bounds/range checks would be tricky here, so let's not bother even trying...\n             return Float.valueOf((float) _parseDouble(key));\n         case TYPE_DOUBLE:\n             return _parseDouble(key);\n             } catch (IOException e) {\n                 throw ctxt.weirdKeyException(_keyClass, key, \"unable to parse key as locale\");\n             }\n-\n+        case TYPE_CURRENCY:\n+            try {\n+                return _deser._deserialize(key, ctxt);\n+            } catch (IOException e) {\n+                throw ctxt.weirdKeyException(_keyClass, key, \"unable to parse key as currency\");\n+            }\n         case TYPE_DATE:\n             return ctxt.parseDate(key);\n         case TYPE_CALENDAR:\n             return (date == null)  ? null : ctxt.constructCalendar(date);\n         case TYPE_UUID:\n             return UUID.fromString(key);\n+        case TYPE_URI:\n+            return URI.create(key);\n+        case TYPE_URL:\n+            return new URL(key);\n+        case TYPE_CLASS:\n+            try {\n+                return ctxt.findClass(key);\n+            } catch (Exception e) {\n+                throw ctxt.weirdKeyException(_keyClass, key, \"unable to parse key as Class\");\n+            }\n         }\n         return null;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n public class StdKeyDeserializers\n     implements KeyDeserializers, java.io.Serializable\n {\n-    private static final long serialVersionUID = 923268084968181479L;\n+    private static final long serialVersionUID = 1L;\n     \n     public static KeyDeserializer constructEnumKeyDeserializer(EnumResolver<?> enumResolver) {\n         return new StdKeyDeserializer.EnumKD(enumResolver, null);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdNodeBasedDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+\n+/**\n+ * Convenience deserializer that may be used to deserialize values given an\n+ * intermediate tree representation ({@link JsonNode}).\n+ * Note that this is a slightly simplified alternative to {@link StdDelegatingDeserializer}).\n+ *\n+ * @param <T> Target type of this deserializer; that is, type of values that\n+ *   input data is deserialized into.\n+ * \n+ * @since 2.5\n+ */\n+public abstract class StdNodeBasedDeserializer<T>\n+    extends StdDeserializer<T>\n+    implements ResolvableDeserializer\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    protected JsonDeserializer<Object> _treeDeserializer;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    protected StdNodeBasedDeserializer(JavaType targetType) {\n+        super(targetType);\n+    }\n+\n+    protected StdNodeBasedDeserializer(Class<T> targetType) {\n+        super(targetType);\n+    }\n+\n+    /**\n+     * \"Copy-constructor\" used when creating a modified copies, most often\n+     * if sub-class implements {@link com.fasterxml.jackson.databind.deser.ContextualDeserializer}.\n+     */\n+    protected StdNodeBasedDeserializer(StdNodeBasedDeserializer<?> src) {\n+        super(src);\n+        _treeDeserializer = src._treeDeserializer;\n+    }\n+\n+    @Override\n+    public void resolve(DeserializationContext ctxt) throws JsonMappingException {\n+        _treeDeserializer = ctxt.findRootValueDeserializer(ctxt.constructType(JsonNode.class));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Abstract methods for sub-classes\n+    /**********************************************************\n+     */\n+\n+    public abstract T convert(JsonNode root, DeserializationContext ctxt) throws IOException;\n+\n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer impl\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n+        JsonNode n = (JsonNode) _treeDeserializer.deserialize(jp, ctxt);\n+        return convert(n, ctxt);\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer td)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* 19-Nov-2014, tatu: Quite likely we'd have some issues but... let's\n+         *   try, just in case.\n+         */\n+        JsonNode n = (JsonNode) _treeDeserializer.deserializeWithType(jp, ctxt, td);\n+        return convert(n, ctxt);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java\n \n     protected StdScalarDeserializer(Class<?> vc) { super(vc); }\n     protected StdScalarDeserializer(JavaType valueType) { super(valueType); }\n+\n+    // since 2.5\n+    protected StdScalarDeserializer(StdScalarDeserializer<?> src) { super(src); }\n     \n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.*;\n      */\n     \n     @Override\n-    public Object createUsingDefault(DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object createUsingDefault(DeserializationContext ctxt) throws IOException\n     {\n         if (_defaultCreator == null) { // sanity-check; caller should check\n             throw new IllegalStateException(\"No default constructor for \"+getValueTypeDesc());\n     }\n     \n     @Override\n-    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args)\n-        throws IOException, JsonProcessingException\n+    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException\n     {\n         if (_withArgsCreator == null) { // sanity-check; caller should check\n             throw new IllegalStateException(\"No with-args constructor for \"+getValueTypeDesc());\n     }\n \n     @Override\n-    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate)\n-        throws IOException, JsonProcessingException\n+    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException\n     {\n         if (_delegateCreator == null) { // sanity-check; caller should check\n             throw new IllegalStateException(\"No delegate constructor for \"+getValueTypeDesc());\n      */\n     \n     @Override\n-    public Object createFromString(DeserializationContext ctxt, String value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromString(DeserializationContext ctxt, String value) throws IOException\n     {\n         if (_fromStringCreator != null) {\n             try {\n     }\n     \n     @Override\n-    public Object createFromInt(DeserializationContext ctxt, int value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromInt(DeserializationContext ctxt, int value) throws IOException\n     {\n         try {\n             // First: \"native\" int methods work best:\n     }\n \n     @Override\n-    public Object createFromLong(DeserializationContext ctxt, long value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromLong(DeserializationContext ctxt, long value) throws IOException\n     {\n         try {\n             if (_fromLongCreator != null) {\n     }\n \n     @Override\n-    public Object createFromDouble(DeserializationContext ctxt, double value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException\n     {\n         try {\n             if (_fromDoubleCreator != null) {\n     }\n \n     @Override\n-    public Object createFromBoolean(DeserializationContext ctxt, boolean value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException\n     {\n         try {\n             if (_fromBooleanCreator != null) {\n     public AnnotatedParameter getIncompleteParameter() {\n         return _incompleteParameter;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Internal methods\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n     extends StdDeserializer<String[]>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = -7589512013334920693L;\n+    private static final long serialVersionUID = 1L;\n \n     public final static StringArrayDeserializer instance = new StringArrayDeserializer();\n     \n         Object[] chunk = buffer.resetAndStart();\n \n         int ix = 0;\n-        JsonToken t;\n \n         try {\n-            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-                // Ok: no need to convert Strings, but must recognize nulls\n-                String value;\n-                if (t == JsonToken.VALUE_STRING) {\n-                    value = jp.getText();\n-                } else if (t == JsonToken.VALUE_NULL) {\n-                    value = null; // since we have established that '_elementDeserializer == null' earlier\n-                } else {\n-                    value = _parseString(jp, ctxt);\n+            while (true) {\n+                String value = jp.nextTextValue();\n+                if (value == null) {\n+                    JsonToken t = jp.getCurrentToken();\n+                    if (t == JsonToken.END_ARRAY) {\n+                        break;\n+                    }\n+                    if (t != JsonToken.VALUE_NULL) {\n+                        value = _parseString(jp, ctxt);\n+                    }\n                 }\n                 if (ix >= chunk.length) {\n                     chunk = buffer.appendCompletedChunk(chunk);\n                 chunk[ix++] = value;\n             }\n         } catch (Exception e) {\n-            throw JsonMappingException.wrapWithPath(e, chunk, ix);\n+            throw JsonMappingException.wrapWithPath(e, chunk, buffer.bufferedSize() + ix);\n         }\n         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n         ctxt.returnObjectBuffer(buffer);\n         final JsonDeserializer<String> deser = _elementDeserializer;\n         \n         int ix = 0;\n-        JsonToken t;\n \n         try {\n-            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-                // Ok: no need to convert Strings, but must recognize nulls\n-                String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n+            while (true) {\n+                /* 30-Dec-2014, tatu: This may look odd, but let's actually call method\n+                 *   that suggest we are expecting a String; this helps with some formats,\n+                 *   notably XML. Note, however, that while we can get String, we can't\n+                 *   assume that's what we use due to custom deserializer\n+                 */\n+                String value;\n+                if (jp.nextTextValue() == null) {\n+                    JsonToken t = jp.getCurrentToken();\n+                    if (t == JsonToken.END_ARRAY) {\n+                        break;\n+                    }\n+                    // Ok: no need to convert Strings, but must recognize nulls\n+                    value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n+                } else {\n+                    value = deser.deserialize(jp, ctxt);\n+                }\n                 if (ix >= chunk.length) {\n                     chunk = buffer.appendCompletedChunk(chunk);\n                     ix = 0;\n         JsonDeserializer<?> deser = _elementDeserializer;\n         // #125: May have a content converter\n         deser = findConvertingContentDeserializer(ctxt, property, deser);\n+        JavaType type = ctxt.constructType(String.class);\n         if (deser == null) {\n-            deser = ctxt.findContextualValueDeserializer(ctxt.constructType(String.class), property);\n+            deser = ctxt.findContextualValueDeserializer(type, property);\n         } else { // if directly assigned, probably not yet contextual, so:\n-            deser = ctxt.handleSecondaryContextualization(deser, property);\n+            deser = ctxt.handleSecondaryContextualization(deser, property, type);\n         }\n         // Ok ok: if all we got is the default String deserializer, can just forget about it\n         if (deser != null && this.isDefaultDeserializer(deser)) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n                 _valueInstantiator, delegateDeser, valueDeser);\n     }\n \n+    @Override // since 2.5\n+    public boolean isCachable() {\n+        return true;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Validation, post-processing\n             }\n         }\n         JsonDeserializer<?> valueDeser = _valueDeserializer;\n+        final JavaType valueType = _collectionType.getContentType();\n         if (valueDeser == null) {\n             // #125: May have a content converter\n             valueDeser = findConvertingContentDeserializer(ctxt, property, valueDeser);\n             if (valueDeser == null) {\n             // And we may also need to get deserializer for String\n-                valueDeser = ctxt.findContextualValueDeserializer( _collectionType.getContentType(), property);\n+                valueDeser = ctxt.findContextualValueDeserializer(valueType, property);\n             }\n         } else { // if directly assigned, probably not yet contextual, so:\n-            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property);\n+            valueDeser = ctxt.handleSecondaryContextualization(valueDeser, property, valueType);\n         } \n         if (isDefaultDeserializer(valueDeser)) {\n             valueDeser = null;\n         if (_valueDeserializer != null) {\n             return deserializeUsingCustom(jp, ctxt, result, _valueDeserializer);\n         }\n-        JsonToken t;\n-\n         try {\n-            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-                String value;\n-                if (t == JsonToken.VALUE_STRING) {\n-                    value = jp.getText();\n-                } else if (t == JsonToken.VALUE_NULL) {\n-                    value = null;\n-                } else {\n+            while (true) {\n+                // First the common case:\n+                String value = jp.nextTextValue();\n+                if (value != null) {\n+                    result.add(value);\n+                    continue;\n+                }\n+                JsonToken t = jp.getCurrentToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    break;\n+                }\n+                if (t != JsonToken.VALUE_NULL) {\n                     value = _parseString(jp, ctxt);\n                 }\n                 result.add(value);\n     private Collection<String> deserializeUsingCustom(JsonParser jp, DeserializationContext ctxt,\n             Collection<String> result, final JsonDeserializer<String> deser) throws IOException\n     {\n-        JsonToken t;\n-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+        while (true) {\n+            /* 30-Dec-2014, tatu: This may look odd, but let's actually call method\n+             *   that suggest we are expecting a String; this helps with some formats,\n+             *   notably XML. Note, however, that while we can get String, we can't\n+             *   assume that's what we use due to custom deserializer\n+             */\n             String value;\n-\n-            if (t == JsonToken.VALUE_NULL) {\n-                value = deser.getNullValue();\n+            if (jp.nextTextValue() == null) {\n+                JsonToken t = jp.getCurrentToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    break;\n+                }\n+                // Ok: no need to convert Strings, but must recognize nulls\n+                value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n             } else {\n                 value = deser.deserialize(jp, ctxt);\n             }\n     }\n \n     /**\n-     * Helper method called when current token is no START_ARRAY. Will either\n+     * Helper method called when current token is not START_ARRAY. Will either\n      * throw an exception, or try to handle value as if member of implicit\n      * array, depending on configuration.\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n         _listDeserializer = _findCustomDeser(ctxt, tf.constructCollectionType(List.class, obType));\n         _stringDeserializer = _findCustomDeser(ctxt, stringType);\n         _numberDeserializer = _findCustomDeser(ctxt, tf.constructType(Number.class));\n+\n+        // and then do bogus contextualization, in case custom ones need to resolve dependencies of\n+        // their own\n+        JavaType unknown = TypeFactory.unknownType();\n+        _mapDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_mapDeserializer, null, unknown);\n+        _listDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_listDeserializer, null, unknown);\n+        _stringDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_stringDeserializer, null, unknown);\n+        _numberDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_numberDeserializer, null, unknown);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     protected JsonDeserializer<Object> _findCustomDeser(DeserializationContext ctxt, JavaType type)\n         throws JsonMappingException\n     {\n-        JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(type);\n+        // Since we are calling from `resolve`, we should NOT try to contextualize yet;\n+        // contextualization will only occur at a later point\n+        JsonDeserializer<?> deser = ctxt.findNonContextualValueDeserializer(type);\n         if (ClassUtil.isJacksonStdImpl(deser)) {\n             return null;\n         }\n     /* Deserializer API\n     /**********************************************************\n      */\n+\n+    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes\n+     *   sense to also mark this is cachable, since lookup not exactly free, and\n+     *   since it's not uncommon to \"read anything\"\n+     */\n+    @Override\n+    public boolean isCachable() { return true; }\n \n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n--- a/src/main/java/com/fasterxml/jackson/databind/exc/PropertyBindingException.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/exc/PropertyBindingException.java\n     /**********************************************************\n      */\n \n-    private final static int MAX_DESC_LENGTH = 200;\n-    \n+    /**\n+     * Somewhat arbitrary limit, but let's try not to create uselessly\n+     * huge error messages\n+     */\n+    private final static int MAX_DESC_LENGTH = 1000;\n+\n     @Override\n     public String getMessageSuffix()\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n package com.fasterxml.jackson.databind.ext;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n+import java.util.Calendar;\n \n import javax.xml.datatype.Duration;\n import javax.xml.datatype.XMLGregorianCalendar;\n import javax.xml.namespace.QName;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.Serializers;\n import com.fasterxml.jackson.databind.ser.std.CalendarSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n             return ToStringSerializer.instance;\n         }\n         if (XMLGregorianCalendar.class.isAssignableFrom(raw)) {\n-            return new XMLGregorianCalendarSerializer();\n+            return XMLGregorianCalendarSerializer.instance;\n         }\n         return null;\n     }\n \n-    public static class XMLGregorianCalendarSerializer extends StdSerializer<XMLGregorianCalendar>\n+    @SuppressWarnings(\"serial\")\n+    public static class XMLGregorianCalendarSerializer\n+        extends StdSerializer<XMLGregorianCalendar>\n+        implements ContextualSerializer\n     {\n+        final static XMLGregorianCalendarSerializer instance = new XMLGregorianCalendarSerializer();\n+\n+        final JsonSerializer<Object> _delegate;\n+        \n         public XMLGregorianCalendarSerializer() {\n+            this(CalendarSerializer.instance);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        protected XMLGregorianCalendarSerializer(JsonSerializer<?> del) {\n             super(XMLGregorianCalendar.class);\n+            _delegate = (JsonSerializer<Object>) del;\n+        }\n+\n+        @Override\n+        public JsonSerializer<?> getDelegatee() {\n+            return _delegate;\n+        }\n+\n+        @Deprecated\n+        @Override\n+        public boolean isEmpty(XMLGregorianCalendar value) {\n+            return _delegate.isEmpty(_convert(value));\n+        }\n+\n+        @Override\n+        public boolean isEmpty(SerializerProvider provider, XMLGregorianCalendar value) {\n+            return _delegate.isEmpty(provider, _convert(value));\n         }\n \n         @Override\n         public void serialize(XMLGregorianCalendar value, JsonGenerator jgen, SerializerProvider provider)\n-                throws IOException, JsonGenerationException {\n-            CalendarSerializer.instance.serialize(value.toGregorianCalendar(), jgen, provider);\n+                throws IOException {\n+            _delegate.serialize(_convert(value), jgen, provider);\n         }\n-        \n+\n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n-            return CalendarSerializer.instance.getSchema(provider, typeHint);\n+        public void serializeWithType(XMLGregorianCalendar value, JsonGenerator gen, SerializerProvider provider,\n+                TypeSerializer typeSer) throws IOException\n+        {\n+            _delegate.serializeWithType(_convert(value), gen, provider, typeSer);\n         }\n \n         @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n-            CalendarSerializer.instance.acceptJsonFormatVisitor(visitor, null);\n+            _delegate.acceptJsonFormatVisitor(visitor, null);\n+        }\n+\n+        @Override\n+        public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property)\n+                throws JsonMappingException {\n+            JsonSerializer<?> ser = prov.handlePrimaryContextualization(_delegate, property);\n+            if (ser != _delegate) {\n+                return new XMLGregorianCalendarSerializer(ser);\n+            }\n+            return this;\n+        }\n+\n+        protected Calendar _convert(XMLGregorianCalendar input) {\n+            return (input == null) ? null : input.toGregorianCalendar();\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/DOMSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/DOMSerializer.java\n package com.fasterxml.jackson.databind.ext;\n \n import java.io.IOException;\n+\n import org.w3c.dom.Node;\n import  org.w3c.dom.bootstrap.DOMImplementationRegistry;\n import  org.w3c.dom.ls.DOMImplementationLS;\n import  org.w3c.dom.ls.LSSerializer;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n+@SuppressWarnings(\"serial\")\n public class DOMSerializer extends StdSerializer<Node>\n {\n     protected final DOMImplementationLS _domImpl;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java\n      * not exposed to developers since instances are mutable.\n      */\n     protected abstract AnnotationMap getAllAnnotations();\n+\n+    // Also: ensure we can use #equals, #hashCode\n+    \n+    @Override\n+    public abstract boolean equals(Object o);\n+\n+    @Override\n+    public abstract int hashCode();\n+\n+    @Override\n+    public abstract String toString();\n }\n-\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n          * -- at least not yet!\n          */\n         if (_annotationIntrospector == null) { // when annotation processing is disabled\n-            return new AnnotatedMethod(m, _emptyAnnotationMap(), null);\n-        }\n-        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null);\n+            return new AnnotatedMethod(this, m, _emptyAnnotationMap(), null);\n+        }\n+        return new AnnotatedMethod(this, m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null);\n     }\n \n     protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n     {\n         if (_annotationIntrospector == null) { // when annotation processing is disabled\n-            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n+            return new AnnotatedConstructor(this, ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n         }\n         if (defaultCtor) {\n-            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n+            return new AnnotatedConstructor(this, ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n         }\n         Annotation[][] paramAnns = ctor.getParameterAnnotations();\n         int paramCount = ctor.getParameterTypes().length;\n         } else {\n             resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n         }\n-        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n-                resolvedAnnotations);\n+        return new AnnotatedConstructor(this, ctor,\n+                _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), resolvedAnnotations);\n     }\n \n     protected AnnotatedMethod _constructCreatorMethod(Method m)\n     {\n         if (_annotationIntrospector == null) { // when annotation processing is disabled\n-            return new AnnotatedMethod(m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length));\n-        }\n-        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),\n+            return new AnnotatedMethod(this, m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length));\n+        }\n+        return new AnnotatedMethod(this, m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),\n                                    _collectRelevantAnnotations(m.getParameterAnnotations()));\n     }\n \n     protected AnnotatedField _constructField(Field f)\n     {\n         if (_annotationIntrospector == null) { // when annotation processing is disabled\n-            return new AnnotatedField(f, _emptyAnnotationMap());\n-        }\n-        return new AnnotatedField(f, _collectRelevantAnnotations(f.getDeclaredAnnotations()));\n+            return new AnnotatedField(this, f, _emptyAnnotationMap());\n+        }\n+        return new AnnotatedField(this, f, _collectRelevantAnnotations(f.getDeclaredAnnotations()));\n     }\n  \n     private AnnotationMap _emptyAnnotationMap() {\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (_isAnnotationBundle(ann)) {\n+                // note: we will NOT filter out non-Jackson anns any more\n+                boolean wasNotPresent = result.addIfNotPresent(ann);\n+                if (wasNotPresent && _isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                     bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                } else { // note: we will NOT filter out non-Jackson anns any more\n-                    result.addIfNotPresent(ann);\n                 }\n             }\n             if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (_isAnnotationBundle(ann)) {\n+                // note: we will NOT filter out non-Jackson anns any more\n+                boolean wasNotPresent = target.addIfNotPresent(ann);\n+                if (wasNotPresent && _isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                     bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                } else { // note: we will NOT filter out non-Jackson anns any more\n-                    target.addIfNotPresent(ann);\n                 }\n             }\n             if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (_isAnnotationBundle(ann)) {\n+                // note: we will NOT filter out non-Jackson anns any more\n+                boolean wasModified = target.addOrOverride(ann);\n+                if (wasModified && _isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                     bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                } else { // note: no filtering by jackson-annotations\n-                    target.addOrOverride(ann);\n                 }\n             }\n             if (bundles != null) { // and then bundles, if any: important for precedence\n         _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations());\n     }\n \n-   private final boolean _isAnnotationBundle(Annotation ann)\n-   {\n+   private final boolean _isAnnotationBundle(Annotation ann) {\n        return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann);\n    }\n    \n      */\n \n     @Override\n-    public String toString()\n-    {\n+    public String toString() {\n         return \"[AnnotedClass \"+_class.getName()+\"]\";\n     }\n+\n+    @Override\n+    public int hashCode() {\n+        return _class.getName().hashCode();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        return ((AnnotatedClass) o)._class == _class;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java\n     /**********************************************************\n      */\n \n-    public AnnotatedConstructor(Constructor<?> constructor,\n+    public AnnotatedConstructor(AnnotatedClass ctxt, Constructor<?> constructor,\n             AnnotationMap classAnn, AnnotationMap[] paramAnn)\n     {\n-        super(classAnn, paramAnn);\n+        super(ctxt, classAnn, paramAnn);\n         if (constructor == null) {\n             throw new IllegalArgumentException(\"Null constructor not allowed\");\n         }\n      */\n     protected AnnotatedConstructor(Serialization ser)\n     {\n-        super(null, null);\n+        super(null, null, null);\n         _constructor = null;\n         _serialization = ser;\n     }\n     \n     @Override\n     public AnnotatedConstructor withAnnotations(AnnotationMap ann) {\n-        return new AnnotatedConstructor(_constructor, ann, _paramAnnotations);\n+        return new AnnotatedConstructor(_context, _constructor, ann, _paramAnnotations);\n     }\n     \n     /*\n         return \"[constructor for \"+getName()+\", annotations: \"+_annotations+\"]\";\n     }\n \n+    @Override\n+    public int hashCode() {\n+        return _constructor.getName().hashCode();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        return ((AnnotatedConstructor) o)._constructor == _constructor;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JDK serialization handling\n             if (!ctor.isAccessible()) {\n                 ClassUtil.checkAndFixAccess(ctor);\n             }\n-            return new AnnotatedConstructor(ctor, null, null);\n+            return new AnnotatedConstructor(null, ctor, null, null);\n         } catch (Exception e) {\n             throw new IllegalArgumentException(\"Could not find constructor with \"\n                     +_serialization.args.length+\" args from Class '\"+clazz.getName());\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java\n     extends AnnotatedMember\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 7364428299211355871L;\n+    private static final long serialVersionUID = 1L;\n \n     /**\n      * Actual {@link Field} used for access.\n      * Temporary field required for JDK serialization support\n      */\n     protected Serialization _serialization;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n     /**********************************************************\n      */\n \n-    public AnnotatedField(Field field, AnnotationMap annMap)\n+    public AnnotatedField(AnnotatedClass contextClass, Field field, AnnotationMap annMap)\n     {\n-        super(annMap);\n+        super(contextClass, annMap);\n         _field = field;\n     }\n     \n     @Override\n     public AnnotatedField withAnnotations(AnnotationMap ann) {\n-        return new AnnotatedField(_field, ann);\n+        return new AnnotatedField(_context, _field, ann);\n     }\n \n     /**\n      */\n     protected AnnotatedField(Serialization ser)\n     {\n-        super(null);\n+        super(null, null);\n         _field = null;\n         _serialization = ser;\n     }\n     public String getName() { return _field.getName(); }\n \n     @Override\n-    public <A extends Annotation> A getAnnotation(Class<A> acls)\n-    {\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n         return (_annotations == null) ? null : _annotations.get(acls);\n     }\n \n     public int getAnnotationCount() { return _annotations.size(); }\n \n     @Override\n-    public String toString()\n-    {\n+    public int hashCode() {\n+        return _field.getName().hashCode();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        return ((AnnotatedField) o)._field == _field;\n+    }\n+\n+    @Override\n+    public String toString() {\n         return \"[field \"+getFullName()+\"]\";\n     }\n \n             if (!f.isAccessible()) {\n                 ClassUtil.checkAndFixAccess(f);\n             }\n-            return new AnnotatedField(f, null);\n+            return new AnnotatedField(null, f, null);\n         } catch (Exception e) {\n             throw new IllegalArgumentException(\"Could not find method '\"+_serialization.name\n                         +\"' from Class '\"+clazz.getName());\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n  * a class; fields, methods and constructors. This is a superset\n  * of things that can represent logical properties as it contains\n  * constructors in addition to fields and methods.\n- * \n- * @author tatu\n  */\n public abstract class AnnotatedMember\n     extends Annotated\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 7364428299211355871L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n+\n+    // 19-Dec-2014, tatu: Similarly, assumed NOT to be needed in cases where\n+    //    owning object (ObjectMapper or relatives) is being JDK-serialized\n+    /**\n+     * Class that was resolved to produce this member instance; either class that declared\n+     * the member, or one of its subtypes that inherited it.\n+     * \n+     * @since 2.5\n+     */\n+    protected final transient AnnotatedClass _context;\n \n     // Transient since information not needed after construction, so\n     // no need to persist\n     protected final transient AnnotationMap _annotations;\n \n+    /*\n+    @Deprecated // since 2.5\n     protected AnnotatedMember(AnnotationMap annotations) {\n+        this(null, annotations);\n+    }\n+    */\n+\n+    protected AnnotatedMember(AnnotatedClass ctxt, AnnotationMap annotations) {\n         super();\n+        _context = ctxt;\n         _annotations = annotations;\n     }\n \n+    /**\n+     * Copy-constructor.\n+     *\n+     * @since 2.5\n+     */\n+    protected AnnotatedMember(AnnotatedMember base) {\n+        _context = base._context;\n+        _annotations = base._annotations;\n+    }\n+    \n+    /**\n+     * Actual physical class in which this memmber was declared.\n+     * Note that this may be different from what {@link #getContextClass()} returns;\n+     * \"owner\" may be a sub-type of \"declaring class\".\n+     */\n     public abstract Class<?> getDeclaringClass();\n \n     public abstract Member getMember();\n \n+    /**\n+     * Accessor for {@link AnnotatedClass} that was the type that was resolved\n+     * and that contains this member: this is either the {@link java.lang.Class}\n+     * in which member was declared, or one of its super types. If distinction\n+     * between result type, and actual class in which declaration was found matters,\n+     * you can compare return value to that of {@link #getDeclaringClass()}.\n+     * The main use for this accessor is (usually) to access class annotations.\n+     *<p>\n+     * Also note that owner property is NOT (JDK-)serialized; this should usually not\n+     * matter, but means that while it is accessible during construction of various\n+     * (de)serializers, it may not be available on per-call basis, if (but only if)\n+     * <code>ObjectMapper</code> (etc) has been serialized/deserialized.\n+     * \n+     * @since 2.5\n+     */\n+    public AnnotatedClass getContextClass() {\n+        return _context;\n+    }\n+    \n     @Override\n     public Iterable<Annotation> annotations() {\n         if (_annotations == null) {\n      * annotation masking or overriding an annotation 'real' constructor\n      * has.\n      */\n-    public final void addOrOverride(Annotation a) {\n-        _annotations.add(a);\n+    public final boolean addOrOverride(Annotation a) {\n+        return _annotations.add(a);\n     }\n \n     /**\n      * annotation if and only if it is not yet present in the\n      * annotation map we have.\n      */\n-    public final void addIfNotPresent(Annotation a) {\n-        _annotations.addIfNotPresent(a);\n+    public final boolean addIfNotPresent(Annotation a) {\n+        return _annotations.addIfNotPresent(a);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java\n     /*****************************************************\n      */\n \n-    public AnnotatedMethod(Method method, AnnotationMap classAnn, AnnotationMap[] paramAnnotations)\n-    {\n-        super(classAnn, paramAnnotations);\n+    public AnnotatedMethod(AnnotatedClass ctxt, Method method,\n+            AnnotationMap classAnn, AnnotationMap[] paramAnnotations)\n+    {\n+        super(ctxt, classAnn, paramAnnotations);\n         if (method == null) {\n             throw new IllegalArgumentException(\"Can not construct AnnotatedMethod with null Method\");\n         }\n      */\n     protected AnnotatedMethod(Serialization ser)\n     {\n-        super(null, null);\n+        super(null, null, null);\n         _method = null;\n         _serialization = ser;\n     }\n      * Method that constructs a new instance with settings (annotations, parameter annotations)\n      * of this instance, but with different physical {@link Method}.\n      */\n-    public AnnotatedMethod withMethod(Method m)\n-    {\n-        return new AnnotatedMethod(m, _annotations, _paramAnnotations);\n+    public AnnotatedMethod withMethod(Method m) {\n+        return new AnnotatedMethod(_context, m, _annotations, _paramAnnotations);\n     }\n     \n     @Override\n     public AnnotatedMethod withAnnotations(AnnotationMap ann) {\n-        return new AnnotatedMethod(_method, ann, _paramAnnotations);\n+        return new AnnotatedMethod(_context, _method, ann, _paramAnnotations);\n     }\n \n     /*\n     public Method getMember() { return _method; }\n \n     @Override\n-    public void setValue(Object pojo, Object value)\n-        throws IllegalArgumentException\n+    public void setValue(Object pojo, Object value) throws IllegalArgumentException\n     {\n         try {\n             _method.invoke(pojo, value);\n      */\n \n     @Override\n-    public String toString()\n-    {\n+    public String toString() {\n         return \"[method \"+getFullName()+\"]\";\n     }\n \n+    @Override\n+    public int hashCode() {\n+        return _method.getName().hashCode();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        return ((AnnotatedMethod) o)._method == _method;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JDK serialization handling\n             if (!m.isAccessible()) {\n                 ClassUtil.checkAndFixAccess(m);\n             }\n-            return new AnnotatedMethod(m, null, null);\n+            return new AnnotatedMethod(null, m, null, null);\n         } catch (Exception e) {\n             throw new IllegalArgumentException(\"Could not find method '\"+_serialization.name\n                         +\"' from Class '\"+clazz.getName());\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java\n import java.lang.reflect.AnnotatedElement;\n import java.lang.reflect.Member;\n import java.lang.reflect.Type;\n-\n \n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n     public AnnotatedParameter(AnnotatedWithParams owner, Type type,  AnnotationMap annotations,\n             int index)\n     {\n-        super(annotations);\n+        super((owner == null) ? null : owner.getContextClass(), annotations);\n         _owner = owner;\n         _type = type;\n         _index = index;\n      */\n     \n     @Override\n-    public String toString()\n-    {\n+    public int hashCode() {\n+        return _owner.hashCode() + _index;\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        AnnotatedParameter other = (AnnotatedParameter) o;\n+        return other._owner.equals(_owner) && (other._index == _index);\n+    }\n+    \n+    @Override\n+    public String toString() {\n         return \"[parameter #\"+getIndex()+\", annotations: \"+_annotations+\"]\";\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java\n     /**********************************************************\n      */\n \n-    protected AnnotatedWithParams(AnnotationMap annotations, AnnotationMap[] paramAnnotations)\n+    protected AnnotatedWithParams(AnnotatedClass ctxt, AnnotationMap annotations, AnnotationMap[] paramAnnotations)\n     {\n-        super(annotations);\n+        super(ctxt, annotations);\n         _paramAnnotations = paramAnnotations;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n import java.util.Collection;\n import java.util.List;\n \n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n     public JsonInclude.Include findSerializationInclusion(Annotated a,\n             JsonInclude.Include defValue)\n     {\n-        /* This is bit trickier: need to combine results in a meaningful\n-         * way. Seems like it should be a disjoint; that is, most\n-         * restrictive value should be returned.\n-         * For enumerations, comparison is done by indexes, which\n-         * works: largest value is the last one, which is the most\n-         * restrictive value as well.\n-         */\n-        /* 09-Mar-2010, tatu: Actually, as per [JACKSON-256], it is probably better to just\n-         *    use strict overriding. Simpler, easier to understand.\n-         */\n         // note: call secondary first, to give lower priority\n         defValue = _secondary.findSerializationInclusion(a, defValue);\n         defValue = _primary.findSerializationInclusion(a, defValue);\n         return defValue;\n     }\n+\n+    @Override\n+    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)\n+    {\n+        // note: call secondary first, to give lower priority\n+        defValue = _secondary.findSerializationInclusion(a, defValue);\n+        defValue = _primary.findSerializationInclusion(a, defValue);\n+        return defValue;\n+    }\n     \n     @Override\n     public Class<?> findSerializationType(Annotated a) {\n-    \tClass<?> r = _primary.findSerializationType(a);\n+        Class<?> r = _primary.findSerializationType(a);\n         return (r == null) ? _secondary.findSerializationType(a) : r;\n     }\n \n         }\n         return name;\n     }\n-    \n+\n+    @Override\n+    public String findPropertyDefaultValue(Annotated ann) {\n+        String str = _primary.findPropertyDefaultValue(ann);\n+        return (str == null || str.isEmpty()) ? _secondary.findPropertyDefaultValue(ann) : str;\n+    }\n+\n     @Override\n     public String findPropertyDescription(Annotated ann) {\n         String r = _primary.findPropertyDescription(ann);\n         Integer r = _primary.findPropertyIndex(ann);\n         return (r == null) ? _secondary.findPropertyIndex(ann) : r;\n     }\n-    \n+\n     @Override\n     public String findImplicitPropertyName(AnnotatedMember param) {\n         String r = _primary.findImplicitPropertyName(param);\n         Boolean r = _primary.findSerializationSortAlphabetically(ann);\n         return (r == null) ? _secondary.findSerializationSortAlphabetically(ann) : r;\n     }\n-    \n+\n+    @Override\n+    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n+            List<BeanPropertyWriter> properties) {\n+        // first secondary, then primary, to give proper precedence\n+        _primary.findAndAddVirtualProperties(config, ac, properties);\n+        _secondary.findAndAddVirtualProperties(config, ac, properties);\n+    }\n+\n     // // // Serialization: property annotations\n     \n     @Override\n         return _primary.hasCreatorAnnotation(a) || _secondary.hasCreatorAnnotation(a);\n     }\n \n+    @Override\n+    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n+        JsonCreator.Mode mode = _primary.findCreatorBinding(a);\n+        if (mode != null) {\n+            return mode;\n+        }\n+        return _secondary.findCreatorBinding(a);\n+    }\n+    \n     protected boolean _isExplicitClassOrOb(Object maybeCls, Class<?> implicit) {\n         if (maybeCls == null) {\n             return false;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n      * Method called to add specified annotation in the Map, but\n      * only if it didn't yet exist.\n      */\n-    public void addIfNotPresent(Annotation ann)\n+    public boolean addIfNotPresent(Annotation ann)\n     {\n         if (_annotations == null || !_annotations.containsKey(ann.annotationType())) {\n             _add(ann);\n+            return true;\n         }\n+        return false;\n     }\n \n     /**\n      * Method called to add specified annotation in the Map.\n      */\n-    public void add(Annotation ann) {\n-        _add(ann);\n+    public boolean add(Annotation ann) {\n+        return _add(ann);\n     }\n \n     @Override\n     /**********************************************************\n      */\n \n-    protected final void _add(Annotation ann) {\n+    protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n-        _annotations.put(ann.annotationType(), ann);\n+        Annotation previous = _annotations.put(ann.annotationType(), ann);\n+        return (previous != null) && previous.equals(ann);\n     }\n }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n \n     @Override\n     public ObjectIdInfo getObjectIdInfo() { return  _objectIdInfo; }\n-    \n+\n     @Override\n     public List<BeanPropertyDefinition> findProperties() {\n         return _properties;\n         }\n         return _ignoredPropertyNames;\n     }\n-    \n+\n     @Override\n     public boolean hasKnownClassAnnotations() {\n         return _classInfo.hasAnnotations();\n      * and per-class annotation (highest priority).\n      */\n     @Override\n-    public JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue)\n-    {\n+    public JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue) {\n         if (_annotationIntrospector == null) {\n             return defValue;\n         }\n         return _annotationIntrospector.findSerializationInclusion(_classInfo, defValue);\n+    }\n+\n+    @Override\n+    public JsonInclude.Include findSerializationInclusionForContent(JsonInclude.Include defValue) {\n+        if (_annotationIntrospector == null) {\n+            return defValue;\n+        }\n+        return _annotationIntrospector.findSerializationInclusionForContent(_classInfo, defValue);\n     }\n     \n     /**\n     public Map<String,AnnotatedMember> findBackReferenceProperties()\n     {\n         HashMap<String,AnnotatedMember> result = null;\n+//        boolean hasIgnored = (_ignoredPropertyNames != null);\n+\n         for (BeanPropertyDefinition property : _properties) {\n+            /* 23-Sep-2014, tatu: As per [Databind#426], we _should_ try to avoid\n+             *   calling accessor, as it triggers exception from seeming conflict.\n+             *   But the problem is that _ignoredPropertyNames here only contains\n+             *   ones ignored on per-property annotations, but NOT class annotations...\n+             *   so commented out part does not work, alas\n+             */\n+            /*\n+            if (hasIgnored && _ignoredPropertyNames.contains(property.getName())) {\n+                continue;\n+            }\n+            */\n             AnnotatedMember am = property.getMutator();\n             if (am == null) {\n                 continue;\n \n         /* Also: must be a recognized factory method, meaning:\n          * (a) marked with @JsonCreator annotation, or\n-         * (a) \"valueOf\" (at this point, need not be public)\n+         * (b) \"valueOf\" (at this point, need not be public)\n          */\n         if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n             return true;\n     }\n \n     /**\n-     * @deprecated Since 2.4, use {@link #findCreatorParameterNames()} instead.\n+     * @deprecated Since 2.4, use <code>findCreatorParameterNames()</code> instead.\n      */\n     @Deprecated\n     public List<String> findCreatorPropertyNames()\n     }\n     \n     /**\n-     * Method for getting ordered list of named Creator properties.\n-     * Returns an empty list is none found. If multiple Creator\n-     * methods are defined, order between properties from different\n-     * methods is undefined; however, properties for each such\n-     * Creator are ordered properly relative to each other.\n-     * For the usual case of just a single Creator, named properties are\n-     * thus properly ordered.\n-     * \n-     * @since 2.4\n-     */\n+     * @deprecated Since 2.5, does not seem to be used at all.\n+     */\n+    @Deprecated\n     public List<PropertyName> findCreatorParameterNames()\n     {\n         for (int i = 0; i < 2; ++i) {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n+\n+import java.util.Collection;\n+import java.util.Map;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.SimpleType;\n+import com.fasterxml.jackson.databind.util.LRUMap;\n \n public class BasicClassIntrospector\n     extends ClassIntrospector\n      * This is strictly performance optimization to reduce what is\n      * usually one-time cost, but seems useful for some cases considering\n      * simplicity.\n+     * \n+     * @since 2.4\n      */\n     \n     protected final static BasicBeanDescription STRING_DESC;\n     /**********************************************************\n      */\n \n+    @Deprecated // since 2.5: construct instance directly\n     public final static BasicClassIntrospector instance = new BasicClassIntrospector();\n \n-    public BasicClassIntrospector() { }\n+    /**\n+     * Looks like 'forClassAnnotations()' gets called so frequently that we\n+     * should consider caching to avoid some of the lookups.\n+     * \n+     * @since 2.5\n+     */\n+    protected final LRUMap<JavaType,BasicBeanDescription> _cachedFCA;\n+\n+    public BasicClassIntrospector() {\n+        // a small cache should go a long way here\n+        _cachedFCA = new LRUMap<JavaType,BasicBeanDescription>(16, 64);\n+    }\n     \n     /*\n     /**********************************************************\n     public BasicBeanDescription forSerialization(SerializationConfig cfg,\n             JavaType type, MixInResolver r)\n     {\n-        // minor optimization: for JDK types do minimal introspection\n-        BasicBeanDescription desc = _findCachedDesc(type);\n-        if (desc == null) {\n-            desc = BasicBeanDescription.forSerialization(collectProperties(cfg,\n-            \t\ttype, r, true, \"set\"));\n+        // minor optimization: for some JDK types do minimal introspection\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+            // As per [Databind#550], skip full introspection for some of standard\n+            // structured types as well\n+            desc = _findStdJdkCollectionDesc(cfg, type, r);\n+            if (desc == null) {\n+                desc = BasicBeanDescription.forSerialization(collectProperties(cfg,\n+                        type, r, true, \"set\"));\n+            }\n+            // Also: this is a superset of \"forClassAnnotations\", so may optimize by optional add:\n+            _cachedFCA.putIfAbsent(type, desc);\n         }\n         return desc;\n     }\n     public BasicBeanDescription forDeserialization(DeserializationConfig cfg,\n             JavaType type, MixInResolver r)\n     {\n-        // minor optimization: for JDK types do minimal introspection\n-        BasicBeanDescription desc = _findCachedDesc(type);\n-        if (desc == null) {\n-            desc = BasicBeanDescription.forDeserialization(collectProperties(cfg,\n-            \t\ttype, r, false, \"set\"));\n+        // minor optimization: for some JDK types do minimal introspection\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+            // As per [Databind#550], skip full introspection for some of standard\n+            // structured types as well\n+            desc = _findStdJdkCollectionDesc(cfg, type, r);\n+            if (desc == null) {\n+                desc = BasicBeanDescription.forDeserialization(collectProperties(cfg,\n+                        \t\ttype, r, false, \"set\"));\n+            }\n+            // Also: this is a superset of \"forClassAnnotations\", so may optimize by optional add:\n+            _cachedFCA.putIfAbsent(type, desc);\n         }\n         return desc;\n     }\n     public BasicBeanDescription forDeserializationWithBuilder(DeserializationConfig cfg,\n             JavaType type, MixInResolver r)\n     {\n-    \t// no caching for Builders (no standard JDK builder types):\n-    \treturn BasicBeanDescription.forDeserialization(collectPropertiesWithBuilder(cfg,\n-            \t\ttype, r, false));\n+        // no std JDK types with Builders, so:\n+\n+        BasicBeanDescription desc = BasicBeanDescription.forDeserialization(collectPropertiesWithBuilder(cfg,\n+                type, r, false));\n+        // this is still a superset of \"forClassAnnotations\", so may optimize by optional add:\n+        _cachedFCA.putIfAbsent(type, desc);\n+        return desc;\n     }\n     \n     @Override\n     public BasicBeanDescription forCreation(DeserializationConfig cfg,\n             JavaType type, MixInResolver r)\n     {\n-        BasicBeanDescription desc = _findCachedDesc(type);\n-        if (desc == null) {\n-            desc = BasicBeanDescription.forDeserialization(\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+\n+            // As per [Databind#550], skip full introspection for some of standard\n+            // structured types as well\n+            desc = _findStdJdkCollectionDesc(cfg, type, r);\n+            if (desc == null) {\n+                desc = BasicBeanDescription.forDeserialization(\n             \t\tcollectProperties(cfg, type, r, false, \"set\"));\n-        }\n+            }\n+        }\n+        // should this be cached for FCA?\n         return desc;\n     }\n \n     public BasicBeanDescription forClassAnnotations(MapperConfig<?> cfg,\n             JavaType type, MixInResolver r)\n     {\n-        boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n-        AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),\n-                (useAnnotations ? cfg.getAnnotationIntrospector() : null), r);\n-        return BasicBeanDescription.forOtherUse(cfg, type, ac);\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+            desc = _cachedFCA.get(type);\n+            if (desc == null) {\n+                boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n+                AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),\n+                        (useAnnotations ? cfg.getAnnotationIntrospector() : null), r);\n+                desc = BasicBeanDescription.forOtherUse(cfg, type, ac);\n+                _cachedFCA.put(type, desc);\n+            }\n+        }\n+        return desc;\n     }\n \n     @Override\n     public BasicBeanDescription forDirectClassAnnotations(MapperConfig<?> cfg,\n             JavaType type, MixInResolver r)\n     {\n-        boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n-        AnnotationIntrospector ai =  cfg.getAnnotationIntrospector();\n-        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(type.getRawClass(),\n-                (useAnnotations ? ai : null), r);\n-        return BasicBeanDescription.forOtherUse(cfg, type, ac);\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+            boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n+            AnnotationIntrospector ai =  cfg.getAnnotationIntrospector();\n+            AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(type.getRawClass(),\n+                    (useAnnotations ? ai : null), r);\n+            desc = BasicBeanDescription.forOtherUse(cfg, type, ac);\n+        }\n+        return desc;\n     }\n     \n     /*\n      * Method called to see if type is one of core JDK types\n      * that we have cached for efficiency.\n      */\n-    protected BasicBeanDescription _findCachedDesc(JavaType type)\n+    protected BasicBeanDescription _findStdTypeDesc(JavaType type)\n     {\n         Class<?> cls = type.getRawClass();\n-        if (cls == String.class) {\n-            return STRING_DESC;\n-        }\n-        if (cls == Boolean.TYPE) {\n-            return BOOLEAN_DESC;\n-        }\n-        if (cls == Integer.TYPE) {\n-            return INT_DESC;\n-        }\n-        if (cls == Long.TYPE) {\n-            return LONG_DESC;\n+        if (cls.isPrimitive()) {\n+            if (cls == Boolean.TYPE) {\n+                return BOOLEAN_DESC;\n+            }\n+            if (cls == Integer.TYPE) {\n+                return INT_DESC;\n+            }\n+            if (cls == Long.TYPE) {\n+                return LONG_DESC;\n+            }\n+        } else {\n+            if (cls == String.class) {\n+                return STRING_DESC;\n+            }\n         }\n         return null;\n     }\n+\n+    /**\n+     * Helper method used to decide whether we can omit introspection\n+     * for members (methods, fields, constructors); we may do so for\n+     * a limited number of container types JDK provides.\n+     */\n+    protected boolean _isStdJDKCollection(JavaType type)\n+    {\n+        if (!type.isContainerType() || type.isArrayType()) {\n+            return false;\n+        }\n+        Class<?> raw = type.getRawClass();\n+        Package pkg = raw.getPackage();\n+        if (pkg != null) {\n+            String pkgName = pkg.getName();\n+            if (pkgName.startsWith(\"java.lang\")\n+                    || pkgName.startsWith(\"java.util\")) {\n+                /* 23-Sep-2014, tatu: Should we be conservative here (minimal number\n+                 *    of matches), or ambitious? Let's do latter for now.\n+                 */\n+                if (Collection.class.isAssignableFrom(raw)\n+                        || Map.class.isAssignableFrom(raw)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected BasicBeanDescription _findStdJdkCollectionDesc(MapperConfig<?> cfg,\n+            JavaType type, MixInResolver r)\n+    {\n+        if (_isStdJDKCollection(type)) {\n+            AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),\n+                    (cfg.isAnnotationProcessingEnabled() ? cfg.getAnnotationIntrospector() : null), r);\n+            return BasicBeanDescription.forOtherUse(cfg, type, ac);\n+        }\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n package com.fasterxml.jackson.databind.introspect;\n \n-import com.fasterxml.jackson.databind.AnnotationIntrospector;\n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.PropertyMetadata;\n-import com.fasterxml.jackson.databind.PropertyName;\n+import java.util.Iterator;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.EmptyIterator;\n import com.fasterxml.jackson.databind.util.Named;\n \n /**\n \n     @Deprecated // since 2.3\n     public BeanPropertyDefinition withName(String newName) { return withSimpleName(newName); }\n-    \n+\n     /**\n      * Method that can be used to create a definition with\n      * same settings as this one, but with different\n      * @since 2.3\n      */\n     public abstract BeanPropertyDefinition withSimpleName(String newSimpleName);\n-    \n+\n     /*\n     /**********************************************************\n     /* Basic property information, name, type\n \n     /**\n      * Method for accessing additional metadata.\n-     * NOTE: will never return null, so deferencing return value\n+     * NOTE: will never return null, so de-referencing return value\n      * is safe.\n      * \n      * @since 2.3\n     public abstract AnnotatedParameter getConstructorParameter();\n \n     /**\n+     * Additional method that may be called instead of {@link #getConstructorParameter()}\n+     * to get access to all constructor parameters, not just the highest priority one.\n+     * \n+     * @since 2.5\n+     */\n+    public Iterator<AnnotatedParameter> getConstructorParameters() {\n+        return EmptyIterator.instance();\n+    }\n+    \n+    /**\n      * Method used to find accessor (getter, field to access) to use for accessing\n      * value of the property.\n      * Null if no such member exists.\n      * Method used to find the property member (getter, setter, field) that has\n      * the highest precedence in current context (getter method when serializing,\n      * if available, and so forth), if any.\n+     *<p>\n+     * Note: abstract since 2.5\n      * \n      * @since 2.1\n      */\n-    public AnnotatedMember getPrimaryMember() { return null; }\n+    public abstract AnnotatedMember getPrimaryMember();\n     \n     /*\n     /**********************************************************\n      * fail deserialization), or handled by other means (by providing default\n      * value)\n      */\n-    public final boolean isRequired() {\n+    public boolean isRequired() {\n         PropertyMetadata md = getMetadata();\n         return (md != null)  && md.isRequired();\n     }\n+\n+    /**\n+     * Method used to check if this property has specific inclusion override\n+     * associated with it or not.\n+     * \n+     * @since 2.5\n+     */\n+    public JsonInclude.Include findInclusion() {\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n \n import java.lang.annotation.Annotation;\n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter;\n import com.fasterxml.jackson.databind.ser.std.RawSerializer;\n-import com.fasterxml.jackson.databind.util.ClassUtil;\n-import com.fasterxml.jackson.databind.util.Converter;\n-import com.fasterxml.jackson.databind.util.NameTransformer;\n+import com.fasterxml.jackson.databind.util.*;\n \n /**\n  * {@link AnnotationIntrospector} implementation that handles standard\n      * are considered bundles.\n      */\n     @Override\n-    public boolean isAnnotationBundle(Annotation ann)\n-    {\n+    public boolean isAnnotationBundle(Annotation ann) {\n         return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* General annotations\n \n     // default impl is fine:\n     //public String findEnumValue(Enum<?> value) { return value.name(); }\n-    \n+\n     /*\n     /**********************************************************\n     /* General class annotations\n     @Override\n     public PropertyName findRootName(AnnotatedClass ac)\n     {\n-        JsonRootName ann = ac.getAnnotation(JsonRootName.class);\n+        JsonRootName ann = _findAnnotation(ac, JsonRootName.class);\n         if (ann == null) {\n             return null;\n         }\n \n     @Override\n     public String[] findPropertiesToIgnore(Annotated ac) {\n-        JsonIgnoreProperties ignore = ac.getAnnotation(JsonIgnoreProperties.class);\n+        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n         return (ignore == null) ? null : ignore.value();\n     }\n \n     @Override\n     public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n-        JsonIgnoreProperties ignore = ac.getAnnotation(JsonIgnoreProperties.class);\n+        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n         return (ignore == null) ? null : ignore.ignoreUnknown();\n     }\n \n     @Override\n     public Boolean isIgnorableType(AnnotatedClass ac) {\n-        JsonIgnoreType ignore = ac.getAnnotation(JsonIgnoreType.class);\n+        JsonIgnoreType ignore = _findAnnotation(ac, JsonIgnoreType.class);\n         return (ignore == null) ? null : ignore.value();\n     }\n \n \n     protected final Object _findFilterId(Annotated a)\n     {\n-        JsonFilter ann = a.getAnnotation(JsonFilter.class);\n+        JsonFilter ann = _findAnnotation(a, JsonFilter.class);\n         if (ann != null) {\n             String id = ann.value();\n             // Empty String is same as not having annotation, to allow overrides\n     @Override\n     public Object findNamingStrategy(AnnotatedClass ac)\n     {\n-        JsonNaming ann = ac.getAnnotation(JsonNaming.class);\n+        JsonNaming ann = _findAnnotation(ac, JsonNaming.class);\n         return (ann == null) ? null : ann.value();\n     } \n \n     public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n         VisibilityChecker<?> checker)\n     {\n-        JsonAutoDetect ann = ac.getAnnotation(JsonAutoDetect.class);\n+        JsonAutoDetect ann = _findAnnotation(ac, JsonAutoDetect.class);\n         return (ann == null) ? checker : checker.with(ann);\n     }\n \n     @Override        \n     public ReferenceProperty findReferenceType(AnnotatedMember member)\n     {\n-        JsonManagedReference ref1 = member.getAnnotation(JsonManagedReference.class);\n+        JsonManagedReference ref1 = _findAnnotation(member, JsonManagedReference.class);\n         if (ref1 != null) {\n             return AnnotationIntrospector.ReferenceProperty.managed(ref1.value());\n         }\n-        JsonBackReference ref2 = member.getAnnotation(JsonBackReference.class);\n+        JsonBackReference ref2 = _findAnnotation(member, JsonBackReference.class);\n         if (ref2 != null) {\n             return AnnotationIntrospector.ReferenceProperty.back(ref2.value());\n         }\n     @Override\n     public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)\n     {\n-        JsonUnwrapped ann = member.getAnnotation(JsonUnwrapped.class);\n+        JsonUnwrapped ann = _findAnnotation(member, JsonUnwrapped.class);\n         // if not enabled, just means annotation is not enabled; not necessarily\n         // that unwrapping should not be done (relevant when using chained introspectors)\n         if (ann == null || !ann.enabled()) {\n     @Override\n     public Boolean hasRequiredMarker(AnnotatedMember m)\n     {\n-        JsonProperty ann = m.getAnnotation(JsonProperty.class);\n+        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n         if (ann != null) {\n             return ann.required();\n         }\n     @Override\n     public Object findInjectableValueId(AnnotatedMember m)\n     {\n-        JacksonInject ann = m.getAnnotation(JacksonInject.class);\n+        JacksonInject ann = _findAnnotation(m, JacksonInject.class);\n         if (ann == null) {\n             return null;\n         }\n     @Override\n     public List<NamedType> findSubtypes(Annotated a)\n     {\n-        JsonSubTypes t = a.getAnnotation(JsonSubTypes.class);\n+        JsonSubTypes t = _findAnnotation(a, JsonSubTypes.class);\n         if (t == null) return null;\n         JsonSubTypes.Type[] types = t.value();\n         ArrayList<NamedType> result = new ArrayList<NamedType>(types.length);\n     @Override        \n     public String findTypeName(AnnotatedClass ac)\n     {\n-        JsonTypeName tn = ac.getAnnotation(JsonTypeName.class);\n+        JsonTypeName tn = _findAnnotation(ac, JsonTypeName.class);\n         return (tn == null) ? null : tn.value();\n     }\n \n     @Override\n     public Object findSerializer(Annotated a)\n     {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         if (ann != null) {\n             Class<? extends JsonSerializer<?>> serClass = ann.using();\n             if (serClass != JsonSerializer.None.class) {\n          *  if we need to get raw indicator from other sources need to add\n          *  separate accessor within {@link AnnotationIntrospector} interface.\n          */\n-        JsonRawValue annRaw =  a.getAnnotation(JsonRawValue.class);\n+        JsonRawValue annRaw =  _findAnnotation(a, JsonRawValue.class);\n         if ((annRaw != null) && annRaw.value()) {\n             // let's construct instance with nominal type:\n             Class<?> cls = a.getRawType();\n     @Override\n     public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a)\n     {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         if (ann != null) {\n             Class<? extends JsonSerializer<?>> serClass = ann.keyUsing();\n             if (serClass != JsonSerializer.None.class) {\n     @Override\n     public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a)\n     {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         if (ann != null) {\n             Class<? extends JsonSerializer<?>> serClass = ann.contentUsing();\n             if (serClass != JsonSerializer.None.class) {\n     @Override\n     public Object findNullSerializer(Annotated a)\n     {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         if (ann != null) {\n             Class<? extends JsonSerializer<?>> serClass = ann.nullsUsing();\n             if (serClass != JsonSerializer.None.class) {\n     @Override\n     public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue)\n     {\n-        JsonInclude inc = a.getAnnotation(JsonInclude.class);\n+        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n         if (inc != null) {\n             return inc.value();\n         }\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         if (ann != null) {\n             @SuppressWarnings(\"deprecation\")\n             JsonSerialize.Inclusion i2 = ann.include();\n     }\n \n     @Override\n+    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)\n+    {\n+        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n+        return (inc == null) ? defValue : inc.content();\n+    }\n+\n+    @Override\n     public Class<?> findSerializationType(Annotated am)\n     {\n-        JsonSerialize ann = am.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.as());\n     }\n     \n     @Override\n     public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n     {\n-        JsonSerialize ann = am.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n     }\n \n     @Override\n     public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n     {\n-        JsonSerialize ann = am.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n     }\n     \n     @Override\n     public JsonSerialize.Typing findSerializationTyping(Annotated a)\n     {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         return (ann == null) ? null : ann.typing();\n     }\n \n     @Override\n     public Object findSerializationConverter(Annotated a) {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n     }\n \n     @Override\n     public Object findSerializationContentConverter(AnnotatedMember a) {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n     }\n     \n     @Override\n     public Class<?>[] findViews(Annotated a)\n     {\n-        JsonView ann = a.getAnnotation(JsonView.class);\n+        JsonView ann = _findAnnotation(a, JsonView.class);\n         return (ann == null) ? null : ann.value();\n     }\n \n     @Override\n     public Boolean isTypeId(AnnotatedMember member) {\n-        return member.hasAnnotation(JsonTypeId.class);\n+        return _hasAnnotation(member, JsonTypeId.class);\n     }\n \n     @Override\n     public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n-        JsonIdentityInfo info = ann.getAnnotation(JsonIdentityInfo.class);\n+        JsonIdentityInfo info = _findAnnotation(ann, JsonIdentityInfo.class);\n         if (info == null || info.generator() == ObjectIdGenerators.None.class) {\n             return null;\n         }\n \n     @Override\n     public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-        JsonIdentityReference ref = ann.getAnnotation(JsonIdentityReference.class);\n+        JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n         if (ref != null) {\n             objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n         }\n     }\n     \n     @Override\n-    public JsonFormat.Value findFormat(Annotated annotated) {\n-        JsonFormat ann = annotated.getAnnotation(JsonFormat.class);\n-        return (ann == null)  ? null : new JsonFormat.Value(ann);\n-    }\n-\n-    @Override\n-    public String findPropertyDescription(Annotated annotated) {\n-        JsonPropertyDescription desc = annotated.getAnnotation(JsonPropertyDescription.class);\n+    public JsonFormat.Value findFormat(Annotated ann) {\n+        JsonFormat f = _findAnnotation(ann, JsonFormat.class);\n+        return (f == null)  ? null : new JsonFormat.Value(f);\n+    }\n+\n+    @Override\n+    public String findPropertyDefaultValue(Annotated ann) {\n+        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n+        if (prop == null) {\n+            return null;\n+        }\n+        String str = prop.defaultValue();\n+        // Since annotations do not allow nulls, need to assume empty means \"none\"\n+        return str.isEmpty() ? null : str;\n+    }\n+\n+    @Override\n+    public String findPropertyDescription(Annotated ann) {\n+        JsonPropertyDescription desc = _findAnnotation(ann, JsonPropertyDescription.class);\n         return (desc == null) ? null : desc.value();\n     }\n \n     @Override\n-    public Integer findPropertyIndex(Annotated annotated) {\n-        JsonProperty ann = annotated.getAnnotation(JsonProperty.class);\n-        if (ann != null) {\n-        \tint ix = ann.index();\n+    public Integer findPropertyIndex(Annotated ann) {\n+        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n+        if (prop != null) {\n+        \tint ix = prop.index();\n         \tif (ix != JsonProperty.INDEX_UNKNOWN) {\n         \t\treturn Integer.valueOf(ix);\n         \t}\n \n     @Override\n     public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n-        JsonPropertyOrder order = ac.getAnnotation(JsonPropertyOrder.class);\n+        JsonPropertyOrder order = _findAnnotation(ac, JsonPropertyOrder.class);\n         return (order == null) ? null : order.value();\n     }\n \n     }\n \n     private final Boolean _findSortAlpha(Annotated ann) {\n-        JsonPropertyOrder order = ann.getAnnotation(JsonPropertyOrder.class);\n+        JsonPropertyOrder order = _findAnnotation(ann, JsonPropertyOrder.class);\n         return (order == null) ? null : order.alphabetic();\n     }\n-    \n+\n+    @Override\n+    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n+            List<BeanPropertyWriter> properties) {\n+        JsonAppend ann = _findAnnotation(ac, JsonAppend.class);\n+        if (ann == null) {\n+            return;\n+        }\n+        final boolean prepend = ann.prepend();\n+        JavaType propType = null;\n+\n+        // First: any attribute-backed properties?\n+        JsonAppend.Attr[] attrs = ann.attrs();\n+        for (int i = 0, len = attrs.length; i < len; ++i) {\n+            if (propType == null) {\n+                propType = config.constructType(Object.class);\n+            }\n+            BeanPropertyWriter bpw = _constructVirtualProperty(attrs[i],\n+                    config, ac, propType);\n+            if (prepend) {\n+                properties.add(i, bpw);\n+            } else {\n+                properties.add(bpw);\n+            }\n+        }\n+\n+        // Then: general-purpose virtual properties?\n+        JsonAppend.Prop[] props = ann.props();\n+        for (int i = 0, len = props.length; i < len; ++i) {\n+            BeanPropertyWriter bpw = _constructVirtualProperty(props[i],\n+                    config, ac);\n+            if (prepend) {\n+                properties.add(i, bpw);\n+            } else {\n+                properties.add(bpw);\n+            }\n+        }\n+    }\n+\n+    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Attr attr,\n+            MapperConfig<?> config, AnnotatedClass ac, JavaType type)\n+    {\n+        PropertyMetadata metadata = attr.required() ?\n+                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n+        // could add Index, Description in future, if those matter\n+        String attrName = attr.value();\n+\n+        // allow explicit renaming; if none, default to attribute name\n+        PropertyName propName = _propertyName(attr.propName(), attr.propNamespace());\n+        if (!propName.hasSimpleName()) {\n+            propName = new PropertyName(attrName);\n+        }\n+        // now, then, we need a placeholder for member (no real Field/Method):\n+        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n+                attrName, type.getRawClass());\n+        // and with that and property definition\n+        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n+                member, propName, metadata, attr.include());\n+        // can construct the property writer\n+        return AttributePropertyWriter.construct(attrName, propDef,\n+                ac.getAnnotations(), type);\n+    }\n+\n+    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Prop prop,\n+            MapperConfig<?> config, AnnotatedClass ac)\n+    {\n+        PropertyMetadata metadata = prop.required() ?\n+                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n+        PropertyName propName = _propertyName(prop.name(), prop.namespace());\n+        JavaType type = config.constructType(prop.type());\n+        // now, then, we need a placeholder for member (no real Field/Method):\n+        AnnotatedMember member = new VirtualAnnotatedMember(ac, ac.getRawType(),\n+                propName.getSimpleName(), type.getRawClass());\n+        // and with that and property definition\n+        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n+                member, propName, metadata, prop.include());\n+\n+        Class<?> implClass = prop.value();\n+\n+        HandlerInstantiator hi = config.getHandlerInstantiator();\n+        VirtualBeanPropertyWriter bpw = (hi == null) ? null\n+                : hi.virtualPropertyWriterInstance(config, implClass);\n+        if (bpw == null) {\n+            bpw = (VirtualBeanPropertyWriter) ClassUtil.createInstance(implClass,\n+                    config.canOverrideAccessModifiers());\n+        }\n+\n+        // one more thing: give it necessary contextual information\n+        return bpw.withConfig(config, ac, propDef, type);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Serialization: property annotations\n     {\n         String name = null;\n \n-        JsonGetter jg = a.getAnnotation(JsonGetter.class);\n+        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n         if (jg != null) {\n             name = jg.value();\n         } else {\n-            JsonProperty pann = a.getAnnotation(JsonProperty.class);\n+            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n             if (pann != null) {\n                 name = pann.value();\n-            } else if (a.hasAnnotation(JsonSerialize.class) || a.hasAnnotation(JsonView.class)) {\n+            } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class)) {\n                 name = \"\";\n             } else {\n                 return null;\n \n     @Override\n     public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n-        JsonValue ann = am.getAnnotation(JsonValue.class);\n+        JsonValue ann = _findAnnotation(am, JsonValue.class);\n         // value of 'false' means disabled...\n         return (ann != null && ann.value());\n     }\n     @Override\n     public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a)\n     {\n-        JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n         if (ann != null) {\n             Class<? extends JsonDeserializer<?>> deserClass = ann.using();\n             if (deserClass != JsonDeserializer.None.class) {\n     @Override\n     public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a)\n     {\n-        JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n         if (ann != null) {\n             Class<? extends KeyDeserializer> deserClass = ann.keyUsing();\n             if (deserClass != KeyDeserializer.None.class) {\n     @Override\n     public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a)\n     {\n-        JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n         if (ann != null) {\n             Class<? extends JsonDeserializer<?>> deserClass = ann.contentUsing();\n             if (deserClass != JsonDeserializer.None.class) {\n \n     @Override\n     public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n-        JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.as());\n     }\n \n     @Override\n     public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n-        JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n     }\n \n     @Override\n     public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)\n     {\n-        JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n     }\n \n     @Override\n     public Object findDeserializationConverter(Annotated a)\n     {\n-        JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n     }\n \n     @Override\n     public Object findDeserializationContentConverter(AnnotatedMember a)\n     {\n-        JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n     }\n \n     @Override\n     public Object findValueInstantiator(AnnotatedClass ac)\n     {\n-        JsonValueInstantiator ann = ac.getAnnotation(JsonValueInstantiator.class);\n+        JsonValueInstantiator ann = _findAnnotation(ac, JsonValueInstantiator.class);\n         // no 'null' marker yet, so:\n         return (ann == null) ? null : ann.value();\n     }\n     @Override\n     public Class<?> findPOJOBuilder(AnnotatedClass ac)\n     {\n-        JsonDeserialize ann = ac.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(ac, JsonDeserialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.builder());\n     }\n \n     @Override\n     public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)\n     {\n-        JsonPOJOBuilder ann = ac.getAnnotation(JsonPOJOBuilder.class);\n+        JsonPOJOBuilder ann = _findAnnotation(ac, JsonPOJOBuilder.class);\n         return (ann == null) ? null : new JsonPOJOBuilder.Value(ann);\n     }\n     \n \n         // @JsonSetter has precedence over @JsonProperty, being more specific\n         // @JsonDeserialize implies that there is a property, but no name\n-        JsonSetter js = a.getAnnotation(JsonSetter.class);\n+        JsonSetter js = _findAnnotation(a, JsonSetter.class);\n         if (js != null) {\n             name = js.value();\n         } else {\n-            JsonProperty pann = a.getAnnotation(JsonProperty.class);\n+            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n             if (pann != null) {\n                 name = pann.value();\n                 /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n-            } else if (a.hasAnnotation(JsonDeserialize.class)\n-                    || a.hasAnnotation(JsonView.class)\n-                    || a.hasAnnotation(JsonUnwrapped.class) // [#442]\n-                    || a.hasAnnotation(JsonBackReference.class)\n-                    || a.hasAnnotation(JsonManagedReference.class)) {\n+            } else if (_hasAnnotation(a, JsonDeserialize.class)\n+                    || _hasAnnotation(a, JsonView.class)\n+                    || _hasAnnotation(a, JsonUnwrapped.class) // [#442]\n+                    || _hasAnnotation(a, JsonBackReference.class)\n+                    || _hasAnnotation(a, JsonManagedReference.class)) {\n                     name = \"\";\n             } else {\n                 return null;\n          * if needs to be ignored (and if so, is handled prior\n          * to this method getting called)\n          */\n-        return am.hasAnnotation(JsonAnySetter.class);\n+        return _hasAnnotation(am, JsonAnySetter.class);\n     }\n \n     @Override\n         /* No dedicated disabling; regular @JsonIgnore used\n          * if needs to be ignored (handled separately\n          */\n-        return am.hasAnnotation(JsonAnyGetter.class);\n-    }\n-    \n+        return _hasAnnotation(am, JsonAnyGetter.class);\n+    }\n+\n     @Override\n     public boolean hasCreatorAnnotation(Annotated a)\n     {\n          * if needs to be ignored (and if so, is handled prior\n          * to this method getting called)\n          */\n-        return a.hasAnnotation(JsonCreator.class);\n+         JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n+         return (ann != null && ann.mode() != JsonCreator.Mode.DISABLED);\n+    }\n+\n+    @Override\n+    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n+        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n+        return (ann == null) ? null : ann.mode();\n     }\n \n     /*\n \n     protected boolean _isIgnorable(Annotated a)\n     {\n-        JsonIgnore ann = a.getAnnotation(JsonIgnore.class);\n+        JsonIgnore ann = _findAnnotation(a, JsonIgnore.class);\n         return (ann != null && ann.value());\n     }\n \n         cls = _classIfExplicit(cls);\n         return (cls == null || cls == implicit) ? null : cls;\n     }\n-    \n+\n+    protected PropertyName _propertyName(String localName, String namespace) {\n+        if (localName.isEmpty()) {\n+            return PropertyName.USE_DEFAULT;\n+        }\n+        if (namespace == null || namespace.isEmpty()) {\n+            return new PropertyName(localName);\n+        }\n+        return new PropertyName(localName, namespace);\n+    }\n+\n     /**\n      * Helper method called to construct and initialize instance of {@link TypeResolverBuilder}\n      * if given annotated element indicates one is needed.\n      */\n+    @SuppressWarnings(\"deprecation\")\n     protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config,\n             Annotated ann, JavaType baseType)\n     {\n         // First: maybe we have explicit type resolver?\n         TypeResolverBuilder<?> b;\n-        JsonTypeInfo info = ann.getAnnotation(JsonTypeInfo.class);\n-        JsonTypeResolver resAnn = ann.getAnnotation(JsonTypeResolver.class);\n+        JsonTypeInfo info = _findAnnotation(ann, JsonTypeInfo.class);\n+        JsonTypeResolver resAnn = _findAnnotation(ann, JsonTypeResolver.class);\n         \n         if (resAnn != null) {\n             if (info == null) {\n             b = _constructStdTypeResolverBuilder();\n         }\n         // Does it define a custom type id resolver?\n-        JsonTypeIdResolver idResInfo = ann.getAnnotation(JsonTypeIdResolver.class);\n+        JsonTypeIdResolver idResInfo = _findAnnotation(ann, JsonTypeIdResolver.class);\n         TypeIdResolver idRes = (idResInfo == null) ? null\n                 : config.typeIdResolverInstance(ann, idResInfo.value());\n         if (idRes != null) { // [JACKSON-359]\n         b = b.inclusion(inclusion);\n         b = b.typeProperty(info.property());\n         Class<?> defaultImpl = info.defaultImpl();\n-        if (defaultImpl != JsonTypeInfo.None.class) {\n+\n+        // 08-Dec-2014, tatu: To deprecated `JsonTypeInfo.None` we need to use other placeholder(s);\n+        //   and since `java.util.Void` has other purpose (to indicate \"deser as null\"), we'll instead\n+        //   use `JsonTypeInfo.class` itself. But any annotation type will actually do, as they have no\n+        //   valid use (can not instantiate as default)\n+        if (defaultImpl != JsonTypeInfo.None.class && !defaultImpl.isAnnotation()) {\n             b = b.defaultImpl(defaultImpl);\n         }\n         b = b.typeIdVisibility(info.visible());\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n         @Override\n         public Version version() {\n             return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n-       }\n+        }\n     };\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n      *   precedence for serialization annotations), or not (false, deserialization)\n      */\n     protected final boolean _forSerialization;\n-    \n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected final boolean _stdBeanNaming;\n+\n     /**\n      * Type of POJO for which properties are being collected.\n      */\n             JavaType type, AnnotatedClass classDef, String mutatorPrefix)\n     {\n         _config = config;\n+        _stdBeanNaming = config.isEnabled(MapperFeature.USE_STD_BEAN_NAMING);\n         _forSerialization = forSerialization;\n         _type = type;\n         _classDef = classDef;\n         if (!expl) {\n             if (impl.isEmpty()) {\n                 /* Important: if neither implicit nor explicit name, can not make use\n-                 * of this creator paramter -- may or may not be a problem, verified\n+                 * of this creator parameter -- may or may not be a problem, verified\n                  * at a later point.\n                  */\n+                return;\n+            }\n+            // Also: if this occurs, there MUST be explicit annotation on creator itself\n+            if (!_annotationIntrospector.hasCreatorAnnotation(param.getOwner())) {\n                 return;\n             }\n             pn = new PropertyName(impl);\n         if (!nameExplicit) { // no explicit name; must consider implicit\n             implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n             if (implName == null) {\n-                implName = BeanUtil.okNameForRegularGetter(m, m.getName());\n+                implName = BeanUtil.okNameForRegularGetter(m, m.getName(), _stdBeanNaming);\n             }\n             if (implName == null) { // if not, must skip\n-                implName = BeanUtil.okNameForIsGetter(m, m.getName());\n+                implName = BeanUtil.okNameForIsGetter(m, m.getName(), _stdBeanNaming);\n                 if (implName == null) {\n                     return;\n                 }\n             // we still need implicit name to link with other pieces\n             implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n             if (implName == null) {\n-                implName = BeanUtil.okNameForGetter(m);\n+                implName = BeanUtil.okNameForGetter(m, _stdBeanNaming);\n             }\n             // if not regular getter name, use method name as is\n             if (implName == null) {\n         if (!nameExplicit) { // no explicit name; must follow naming convention\n             implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n             if (implName == null) {\n-                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix);\n+                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix, _stdBeanNaming);\n             }\n             if (implName == null) { // if not, must skip\n             \treturn;\n             // we still need implicit name to link with other pieces\n             implName = (ai == null) ? null : ai.findImplicitPropertyName(m);\n             if (implName == null) {\n-                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix);\n+                implName = BeanUtil.okNameForMutator(m, _mutatorPrefix, _stdBeanNaming);\n             }\n             // if not regular getter name, use method name as is\n             if (implName == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n \n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.EmptyIterator;\n \n /**\n  * Helper class used for aggregating information about a single\n \n     protected Linked<AnnotatedMethod> _setters;\n \n-    public POJOPropertyBuilder(PropertyName internalName, AnnotationIntrospector ai, boolean forSerialization) {\n+    public POJOPropertyBuilder(PropertyName internalName, AnnotationIntrospector ai,\n+            boolean forSerialization) {\n         this(internalName, internalName, ai, forSerialization);\n     }\n \n         _name = name;\n         _annotationIntrospector = annotationIntrospector;\n         _forSerialization = forSerialization;\n-    }\n-    \n-    @Deprecated // since 2.3\n-    public POJOPropertyBuilder(String simpleInternalName,\n-            AnnotationIntrospector annotationIntrospector, boolean forSerialization)\n-    {\n-        this(new PropertyName(simpleInternalName), annotationIntrospector, forSerialization);\n     }\n \n     public POJOPropertyBuilder(POJOPropertyBuilder src, PropertyName newName)\n     /* Fluent factory methods\n     /**********************************************************\n      */\n-\n-    @Deprecated // since 2.3\n-    @Override\n-    public POJOPropertyBuilder withName(String newName) {\n-        return withSimpleName(newName);\n-    }\n \n     @Override\n     public POJOPropertyBuilder withName(PropertyName newName) {\n         } while (curr != null);\n         return _ctorParameters.value;\n     }\n+\n+    @Override\n+    public Iterator<AnnotatedParameter> getConstructorParameters() {\n+        if (_ctorParameters == null) {\n+            return EmptyIterator.instance();\n+        }\n+        return new MemberIterator<AnnotatedParameter>(_ctorParameters);\n+    }\n     \n     @Override\n     public AnnotatedMember getAccessor()\n         final Boolean b = _findRequired();\n         final String desc = _findDescription();\n         final Integer idx = _findIndex();\n-        if (b == null && idx == null) {\n+        final String def = _findDefaultValue();\n+        if (b == null && idx == null && def == null) {\n             return (desc == null) ? PropertyMetadata.STD_REQUIRED_OR_OPTIONAL\n                     : PropertyMetadata.STD_REQUIRED_OR_OPTIONAL.withDescription(desc);\n         }\n-        return PropertyMetadata.construct(b.booleanValue(), desc, idx);\n+        return PropertyMetadata.construct(b.booleanValue(), desc, idx, def);\n     }\n \n     protected Boolean _findRequired() {\n             @Override\n             public Integer withMember(AnnotatedMember member) {\n                 return _annotationIntrospector.findPropertyIndex(member);\n+            }\n+        });\n+    }\n+\n+    protected String _findDefaultValue() {\n+        return fromMemberAnnotations(new WithMember<String>() {\n+            @Override\n+            public String withMember(AnnotatedMember member) {\n+                return _annotationIntrospector.findPropertyDefaultValue(member);\n             }\n         });\n     }\n             }\n         });\n     }\n-    \n+\n+    @Override\n+    public JsonInclude.Include findInclusion() {\n+        if (_annotationIntrospector == null) {\n+            return null;\n+        }\n+        AnnotatedMember am = getAccessor();\n+        return _annotationIntrospector.findSerializationInclusion(am, null);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Data aggregation\n         }\n     }\n \n+    /**\n+     * Mutator that will simply drop any constructor parameters property may have.\n+     * \n+     * @since 2.5\n+     */\n+    public void removeConstructors() {\n+        _ctorParameters = null;\n+    }\n+    \n     /**\n      * Method called to trim unnecessary entries, such as implicit\n      * getter if there is an explict one available. This is important\n     private interface WithMember<T> {\n         public T withMember(AnnotatedMember member);\n     }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected static class MemberIterator<T extends AnnotatedMember>\n+        implements Iterator<T>\n+    {\n+        private Linked<T> next;\n+        \n+        public MemberIterator(Linked<T> first) {\n+            next = first;\n+        }\n+        \n+        @Override\n+        public boolean hasNext() {\n+            return (next != null);\n+        }\n+\n+        @Override\n+        public T next() {\n+            if (next == null) throw new NoSuchElementException();\n+            T result = next.value;\n+            next = next.next;\n+            return result;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+        \n+    }\n     \n     /**\n      * Node used for creating simple linked lists to efficiently store small sets\n          * Method called to append given node(s) at the end of this\n          * node chain.\n          */\n-        private Linked<T> append(Linked<T> appendable) {\n+        protected Linked<T> append(Linked<T> appendable) {\n             if (next == null) {\n                 return withNext(appendable);\n             }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.*;\n+\n+/**\n+ * Placeholder used by virtual properties as placeholder for\n+ * underlying {@link AnnotatedMember}.\n+ * \n+ * @since 2.5\n+ */\n+public class VirtualAnnotatedMember extends AnnotatedMember\n+    implements java.io.Serializable\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    protected final Class<?> _declaringClass;\n+\n+    protected final Class<?> _rawType;\n+\n+    protected final String _name;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public VirtualAnnotatedMember(AnnotatedClass contextClass, Class<?> declaringClass,\n+            String name, Class<?> rawType)\n+    {\n+        super(contextClass, /* AnnotationMap*/ null);\n+        _declaringClass = declaringClass;\n+        _rawType = rawType;\n+        _name = name;\n+    }\n+\n+    @Override\n+    public Annotated withAnnotations(AnnotationMap fallback) {\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Annotated impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Field getAnnotated() { return null; }\n+\n+    @Override\n+    public int getModifiers() { return 0; }\n+\n+    @Override\n+    public String getName() { return _name; }\n+\n+    @Override\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Type getGenericType() {\n+        return _rawType;\n+    }\n+\n+    @Override\n+    public Class<?> getRawType() {\n+        return _rawType;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* AnnotatedMember impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Class<?> getDeclaringClass() { return _declaringClass; }\n+\n+    @Override\n+    public Member getMember() { return null; }\n+\n+    @Override\n+    public void setValue(Object pojo, Object value) throws IllegalArgumentException {\n+        throw new IllegalArgumentException(\"Can not set virtual property '\"+_name+\"'\");\n+    }\n+\n+    @Override\n+    public Object getValue(Object pojo) throws IllegalArgumentException {\n+        throw new IllegalArgumentException(\"Can not get virtual property '\"+_name+\"'\");\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API, generic\n+    /**********************************************************\n+     */\n+\n+    public String getFullName() {\n+        return getDeclaringClass().getName() + \"#\" + getName();\n+    }\n+\n+    public int getAnnotationCount() { return 0; }\n+\n+    @Override\n+    public int hashCode() {\n+        return _name.hashCode();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        VirtualAnnotatedMember other = (VirtualAnnotatedMember) o;\n+        return (other._declaringClass == _declaringClass)\n+                && other._name.equals(_name);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"[field \"+getFullName()+\"]\";\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n  *<p>\n  * Note on type declaration: funky recursive type is necessary to\n  * support builder/fluent pattern.\n- * \n- * @author tatu\n  */\n public interface VisibilityChecker<T extends VisibilityChecker<T>>\n {\n         implements VisibilityChecker<Std>,\n             java.io.Serializable\n     {\n-        private static final long serialVersionUID = -7073939237187922755L;\n+        private static final long serialVersionUID = 1;\n \n         /**\n          * This is the canonical base instance, configured with default\n         }\n \n         /**\n-         * Costructor that will assign given visibility value for all\n+         * Constructor that will assign given visibility value for all\n          * properties.\n          * \n          * @param v level to use for all property types\n         /********************************************************\n          */\n \n-    @Override\n-    public Std with(JsonAutoDetect ann)\n-    {\n-        Std curr = this;\n-        if (ann != null) {\n-    \t    curr = curr.withGetterVisibility(ann.getterVisibility());\n-    \t    curr = curr.withIsGetterVisibility(ann.isGetterVisibility());\n-                curr  = curr.withSetterVisibility(ann.setterVisibility());\n-                curr = curr.withCreatorVisibility(ann.creatorVisibility());\n-                curr = curr.withFieldVisibility(ann.fieldVisibility());\n-\t    }\n-\t    return curr;\n-\t}\n-\n-    @Override\n-    public Std with(Visibility v)\n-    {\n-        if (v == Visibility.DEFAULT) {\n-            return DEFAULT;\n-        }\n-        return new Std(v);\n-    }\n-\n-    @Override\n-    public Std withVisibility(PropertyAccessor method, Visibility v)\n-    {\n-\t    switch (method) {\n-\t    case GETTER:\n-\t        return withGetterVisibility(v);\n-\t    case SETTER:\n-\t        return withSetterVisibility(v);\n-\t    case CREATOR:\n-\t        return withCreatorVisibility(v);\n-\t    case FIELD:\n-\t        return withFieldVisibility(v);\n-\t    case IS_GETTER:\n-\t        return withIsGetterVisibility(v);\n+        @Override\n+        public Std with(JsonAutoDetect ann)\n+        {\n+            Std curr = this;\n+            if (ann != null) {\n+        \t    curr = curr.withGetterVisibility(ann.getterVisibility());\n+        \t    curr = curr.withIsGetterVisibility(ann.isGetterVisibility());\n+                    curr  = curr.withSetterVisibility(ann.setterVisibility());\n+                    curr = curr.withCreatorVisibility(ann.creatorVisibility());\n+                    curr = curr.withFieldVisibility(ann.fieldVisibility());\n+            }\n+            return curr;\n+        }\n+\n+        @Override\n+        public Std with(Visibility v)\n+        {\n+            if (v == Visibility.DEFAULT) {\n+                return DEFAULT;\n+            }\n+            return new Std(v);\n+        }\n+    \n+        @Override\n+        public Std withVisibility(PropertyAccessor method, Visibility v)\n+        {\n+            switch (method) {\n+            case GETTER:\n+                return withGetterVisibility(v);\n+            case SETTER:\n+                return withSetterVisibility(v);\n+            case CREATOR:\n+                return withCreatorVisibility(v);\n+            case FIELD:\n+                return withFieldVisibility(v);\n+            case IS_GETTER:\n+                return withIsGetterVisibility(v);\n             case ALL:\n                 return with(v);\n-        //case NONE:\n-        default:\n-            // break;\n-            return this;\n-\t    }\n-\t}\n+            //case NONE:\n+            default:\n+                // break;\n+                return this;\n+            }\n+        }\n \t\n-    @Override\n-\tpublic Std withGetterVisibility(Visibility v) {\n-\t    if (v == Visibility.DEFAULT)  v = DEFAULT._getterMinLevel;\n+        @Override\n+        public Std withGetterVisibility(Visibility v) {\n+            if (v == Visibility.DEFAULT)  v = DEFAULT._getterMinLevel;\n             if (_getterMinLevel == v) return this;\n-\t    return new Std(v, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, _fieldMinLevel);\n-\t}\n-\n-    @Override\n+            return new Std(v, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, _fieldMinLevel);\n+        }\n+\n+        @Override\n         public Std withIsGetterVisibility(Visibility v) {\n             if (v == Visibility.DEFAULT)  v = DEFAULT._isGetterMinLevel;\n             if (_isGetterMinLevel == v) return this;\n             return new Std(_getterMinLevel, v, _setterMinLevel, _creatorMinLevel, _fieldMinLevel);\n         }\n+\n+        @Override\n+        public Std withSetterVisibility(Visibility v) {\n+            if (v == Visibility.DEFAULT)  v = DEFAULT._setterMinLevel;\n+            if (_setterMinLevel == v) return this;\n+            return new Std(_getterMinLevel, _isGetterMinLevel, v, _creatorMinLevel, _fieldMinLevel);\n+        }\n+    \n+        @Override\n+        public Std withCreatorVisibility(Visibility v) {\n+            if (v == Visibility.DEFAULT)  v = DEFAULT._creatorMinLevel;\n+            if (_creatorMinLevel == v) return this;\n+            return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, v, _fieldMinLevel);\n+        }\n+    \n+        @Override\n+        public Std withFieldVisibility(Visibility v) {\n+            if (v == Visibility.DEFAULT)  v = DEFAULT._fieldMinLevel;\n+            if (_fieldMinLevel == v) return this;\n+            return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, v);\n+        }\n \t\t\n-    @Override\n-    public Std withSetterVisibility(Visibility v) {\n-        if (v == Visibility.DEFAULT)  v = DEFAULT._setterMinLevel;\n-        if (_setterMinLevel == v) return this;\n-        return new Std(_getterMinLevel, _isGetterMinLevel, v, _creatorMinLevel, _fieldMinLevel);\n-    }\n-\n-    @Override\n-    public Std withCreatorVisibility(Visibility v) {\n-        if (v == Visibility.DEFAULT)  v = DEFAULT._creatorMinLevel;\n-        if (_creatorMinLevel == v) return this;\n-        return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, v, _fieldMinLevel);\n-    }\n-\n-    @Override\n-    public Std withFieldVisibility(Visibility v) {\n-        if (v == Visibility.DEFAULT)  v = DEFAULT._fieldMinLevel;\n-        if (_fieldMinLevel == v) return this;\n-        return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, v);\n-    }\n-\t\t\n-    /*\n-    /********************************************************\n-    /* Public API impl\n-    /********************************************************\n-     */\n-\n-    @Override\n-    public boolean isCreatorVisible(Member m) {\n-        return _creatorMinLevel.isVisible(m);\n-    }\n-\t\n-    @Override\n-    public boolean isCreatorVisible(AnnotatedMember m) {\n-        return isCreatorVisible(m.getMember());\n-    }\n-    \n-    @Override\n-    public boolean isFieldVisible(Field f) {\n-        return _fieldMinLevel.isVisible(f);\n-    }\n-    \n-    @Override\n-    public boolean isFieldVisible(AnnotatedField f) {\n-        return isFieldVisible(f.getAnnotated());\n-    }\n-    \n-    @Override\n-    public boolean isGetterVisible(Method m) {\n-        return _getterMinLevel.isVisible(m);\n-    }\n-\n-    @Override\n-    public boolean isGetterVisible(AnnotatedMethod m) {\n-         return isGetterVisible(m.getAnnotated());\n-    }\n-\n-    @Override\n-    public boolean isIsGetterVisible(Method m) {\n-        return _isGetterMinLevel.isVisible(m);\n-    }    \n-\n-    @Override\n-    public boolean isIsGetterVisible(AnnotatedMethod m) {\n-        return isIsGetterVisible(m.getAnnotated());\n-    }\n-\n-    @Override\n-    public boolean isSetterVisible(Method m) {\n-        return _setterMinLevel.isVisible(m);\n-    }\n-    \n-    @Override\n-    public boolean isSetterVisible(AnnotatedMethod m) {\n-        return isSetterVisible(m.getAnnotated());\n-    }\n-\n-    /*\n-    /********************************************************\n-    /* Standard methods\n-    /********************************************************\n-     */\n-\n-    @Override\n-    public String toString() {\n-        return new StringBuilder(\"[Visibility:\")\n-        .append(\" getter: \").append(_getterMinLevel)\n-        .append(\", isGetter: \").append(_isGetterMinLevel)\n-        .append(\", setter: \").append(_setterMinLevel)\n-        .append(\", creator: \").append(_creatorMinLevel)\n-        .append(\", field: \").append(_fieldMinLevel)\n-        .append(\"]\").toString();\n-    }\n+        /*\n+        /********************************************************\n+        /* Public API impl\n+        /********************************************************\n+         */\n+\n+        @Override\n+        public boolean isCreatorVisible(Member m) {\n+            return _creatorMinLevel.isVisible(m);\n+        }\n+    \t\n+        @Override\n+        public boolean isCreatorVisible(AnnotatedMember m) {\n+            return isCreatorVisible(m.getMember());\n+        }\n+\n+        @Override\n+        public boolean isFieldVisible(Field f) {\n+            return _fieldMinLevel.isVisible(f);\n+        }\n+        \n+        @Override\n+        public boolean isFieldVisible(AnnotatedField f) {\n+            return isFieldVisible(f.getAnnotated());\n+        }\n+        \n+        @Override\n+        public boolean isGetterVisible(Method m) {\n+            return _getterMinLevel.isVisible(m);\n+        }\n+    \n+        @Override\n+        public boolean isGetterVisible(AnnotatedMethod m) {\n+             return isGetterVisible(m.getAnnotated());\n+        }\n+    \n+        @Override\n+        public boolean isIsGetterVisible(Method m) {\n+            return _isGetterMinLevel.isVisible(m);\n+        }    \n+    \n+        @Override\n+        public boolean isIsGetterVisible(AnnotatedMethod m) {\n+            return isIsGetterVisible(m.getAnnotated());\n+        }\n+    \n+        @Override\n+        public boolean isSetterVisible(Method m) {\n+            return _setterMinLevel.isVisible(m);\n+        }\n+        \n+        @Override\n+        public boolean isSetterVisible(AnnotatedMethod m) {\n+            return isSetterVisible(m.getAnnotated());\n+        }\n+\n+        /*\n+        /********************************************************\n+        /* Standard methods\n+        /********************************************************\n+         */\n+    \n+        @Override\n+        public String toString() {\n+            return new StringBuilder(\"[Visibility:\")\n+            .append(\" getter: \").append(_getterMinLevel)\n+            .append(\", isGetter: \").append(_isGetterMinLevel)\n+            .append(\", setter: \").append(_setterMinLevel)\n+            .append(\", creator: \").append(_creatorMinLevel)\n+            .append(\", field: \").append(_fieldMinLevel)\n+            .append(\"]\").toString();\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java\n package com.fasterxml.jackson.databind.jsontype;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.DatabindContext;\n import com.fasterxml.jackson.databind.JavaType;\n \n /**\n      * available for some reason.\n      */\n     public String idFromBaseType();\n-    \n+\n+    /**\n+     * @deprecated since 2.5; call {@link #typeFromId(DatabindContext, String)} instead\n+     */\n+    @Deprecated // since 2.4\n+    public JavaType typeFromId(String id);\n+\n     /**\n      * Method called to resolve type from given type identifier.\n+     * \n+     * @since 2.5 -- but since 2.3 has existed in {@link com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase}\n      */\n-    public JavaType typeFromId(String id);\n+    public JavaType typeFromId(DatabindContext context, String id);\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n     extends TypeDeserializerBase\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 5345570420394408290L;\n+    private static final long serialVersionUID = 1L;\n \n     public AsArrayTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n             String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n         String typeId = _locateTypeId(jp, ctxt);\n         JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n         // Minor complication: we may need to merge type id in?\n-        if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) {\n+        if (_typeIdVisible\n+                // 06-Oct-2014, tatu: To fix [databind#408], must distinguish between\n+                //   internal and external properties\n+                //  TODO: but does it need to be injected in external case? Why not?\n+                && !_usesExternalId()\n+                && jp.getCurrentToken() == JsonToken.START_OBJECT) {\n             // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n             TokenBuffer tb = new TokenBuffer(null, false);\n             tb.writeStartObject(); // recreate START_OBJECT\n     protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         if (!jp.isExpectedStartArrayToken()) {\n-            // [JACKSON-712] Need to allow even more customized handling, if something unexpected seen...\n+            // Need to allow even more customized handling, if something unexpected seen...\n             // but should there be a way to limit this to likely success cases?\n             if (_defaultImpl != null) {\n                 return _idResolver.idFromBaseType();\n         }\n         throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n     }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected boolean _usesExternalId() {\n+        return false;\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeSerializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type serializer used with {@link As#EXISTING_PROPERTY} inclusion mechanism.\n+ * Expects type information to be a well-defined property on all sub-classes.\n+ * \n+ * @author fleeman (modeled after code by tatus)\n+ */\n+public class AsExistingPropertyTypeSerializer\n+    extends AsPropertyTypeSerializer\n+{\n+\n+    public AsExistingPropertyTypeSerializer(TypeIdResolver idRes, BeanProperty property, String propName)\n+    {\n+        super(idRes, property, propName);\n+    }\n+\n+    @Override\n+    public AsExistingPropertyTypeSerializer forProperty(BeanProperty prop) {\n+        return (_property == prop) ? this : new AsExistingPropertyTypeSerializer(this._idResolver, prop, this._typePropertyName);\n+    }\n+    \n+    @Override\n+    public As getTypeInclusion() { return As.EXISTING_PROPERTY; }\n+    \n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException\n+    {\n+        final String typeId = idFromValue(value);\n+        if (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException\n+    {\n+        final String typeId = idFromValueAndType(value, type);\n+        if (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+    \n+    @Override\n+    public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException\n+    {\n+    \tif (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n     \n     @Override\n     public As getTypeInclusion() { return As.EXTERNAL_PROPERTY; }\n+\n+    // yes, very important distinction...\n+    @Override\n+    protected boolean _usesExternalId() {\n+        return true;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n {\n     private static final long serialVersionUID = 1L;\n \n+    protected final As _inclusion;\n+\n     public AsPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n             String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n     {\n+        this(bt, idRes, typePropertyName, typeIdVisible, defaultImpl, As.PROPERTY);\n+    }\n+    \n+    public AsPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n+            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl,\n+            As inclusion)\n+    {\n         super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl);\n+        _inclusion = inclusion;\n     }\n \n     public AsPropertyTypeDeserializer(AsPropertyTypeDeserializer src, BeanProperty property) {\n         super(src, property);\n+        _inclusion = src._inclusion;\n     }\n     \n     @Override\n     }\n     \n     @Override\n-    public As getTypeInclusion() { return As.PROPERTY; }\n+    public As getTypeInclusion() { return _inclusion; }\n \n     /**\n      * This is the trickiest thing to handle, since property we are looking\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n         }\n         return str;\n     }\n+\n+    @Override\n+    public String getDescForKnownTypeIds() {\n+        return \"class name used as type id\";\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n         return this;\n     }\n \n-    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public TypeSerializer buildTypeSerializer(SerializationConfig config,\n             JavaType baseType, Collection<NamedType> subtypes)\n         case EXTERNAL_PROPERTY:\n             return new AsExternalTypeSerializer(idRes, null,\n                     _typeProperty);\n+        case EXISTING_PROPERTY:\n+        \t// as per [#528]\n+        \treturn new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n \n-    @SuppressWarnings(\"incomplete-switch\")\n+    // as per [#368]\n+    // removed when fix [#528]\n+    //private IllegalArgumentException _noExisting() {\n+    //    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n+    //}\n+\n     @Override\n     public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n             JavaType baseType, Collection<NamedType> subtypes)\n             return new AsArrayTypeDeserializer(baseType, idRes,\n                     _typeProperty, _typeIdVisible, _defaultImpl);\n         case PROPERTY:\n+        case EXISTING_PROPERTY: // as per [#528] same class as PROPERTY\n             return new AsPropertyTypeDeserializer(baseType, idRes,\n-                    _typeProperty, _typeIdVisible, _defaultImpl);\n+                    _typeProperty, _typeIdVisible, _defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n             return new AsWrapperTypeDeserializer(baseType, idRes,\n                     _typeProperty, _typeIdVisible, _defaultImpl);\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n                  * for base class, not via interface. Later on we can add this\n                  * to the interface, assuming deprecation at base class helps.\n                  */\n-                JavaType type;\n-                if (_idResolver instanceof TypeIdResolverBase) {\n-                    type = ((TypeIdResolverBase) _idResolver).typeFromId(ctxt, typeId);\n-                } else {\n-                    type = _idResolver.typeFromId(typeId);\n-                }\n+                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n                 if (type == null) {\n                     // As per [JACKSON-614], use the default impl if no type id available:\n                     deser = _findDefaultImplDeserializer(ctxt);\n                     if (deser == null) {\n-                        throw ctxt.unknownTypeException(_baseType, typeId);\n+                        deser = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                     }\n                 } else {\n                     /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n         }\n         return deser.deserialize(jp, ctxt);\n     }\n+\n+    /**\n+     * Helper method called when given type id can not be resolved into \n+     * concrete deserializer either directly (using given {@link  TypeIdResolver}),\n+     * or using default type.\n+     * Default implementation simply throws a {@link JsonMappingException} to\n+     * indicate the problem; sub-classes may choose\n+     *\n+     * @return If it is possible to resolve type id into a {@link JsonDeserializer}\n+     *   should return that deserializer; otherwise throw an exception to indicate\n+     *   the problem.\n+     *\n+     * @since 2.5\n+     */\n+    protected JsonDeserializer<Object> _handleUnknownTypeId(DeserializationContext ctxt, String typeId,\n+            TypeIdResolver idResolver, JavaType baseType)\n+        throws IOException\n+    {\n+        String extraDesc;\n+        if (idResolver instanceof TypeIdResolverBase) {\n+            extraDesc = ((TypeIdResolverBase) idResolver).getDescForKnownTypeIds();\n+            if (extraDesc == null) {\n+                extraDesc = \"known type ids are not statically known\";\n+            } else {\n+                extraDesc = \"known type ids = \" + extraDesc;\n+            }\n+        } else {\n+            extraDesc = null;\n+        }\n+        throw ctxt.unknownTypeException(_baseType, typeId, extraDesc);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n      */\n     @Deprecated\n     @Override\n-    public abstract JavaType typeFromId(String id);\n+    public JavaType typeFromId(String id) {\n+        return typeFromId(null, id);\n+    }\n \n     /**\n      * New method, replacement for {@link #typeFromId(String)}, which is given\n      * \n      * @since 2.3\n      */\n+    @Override\n     public JavaType typeFromId(DatabindContext context, String id) {\n         return typeFromId(id);\n     }\n+\n+    /**\n+     * Helper method used to get a simple description of all known type ids,\n+     * for use in error messages.\n+     *<p>\n+     * TODO: demote down to be part of {@link TypeIdResolver} in 2.6 or 2.7\n+     */\n+    public String getDescForKnownTypeIds() {\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n          */\n         return _idToType.get(id);\n     }    \n-    \n+\n+    @Override\n+    public String getDescForKnownTypeIds() {\n+        return new TreeSet<String>(_idToType.keySet()).toString();\n+    }\n+\n     @Override\n     public String toString() {\n         StringBuilder sb = new StringBuilder();\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeSerializerBase.java\n     protected String idFromValue(Object value) {\n         String id = _idResolver.idFromValue(value);\n         if (id == null) {\n-            String typeDesc = (value == null) ? \"NULL\" : value.getClass().getName();\n-            throw new IllegalArgumentException(\"Can not resolve type id for \"\n-                    +typeDesc+\" (using \"+_idResolver.getClass().getName()+\")\");\n+            handleMissingId(value);\n         }\n         return id;\n     }\n     protected String idFromValueAndType(Object value, Class<?> type) {\n         String id = _idResolver.idFromValueAndType(value, type);\n         if (id == null) {\n-            String typeDesc = (value == null) ? \"NULL\" : value.getClass().getName();\n-            throw new IllegalArgumentException(\"Can not resolve type id for \"\n-                    +typeDesc+\" (using \"+_idResolver.getClass().getName()+\")\");\n+            handleMissingId(value);\n         }\n         return id;\n     }\n+\n+    // As per [databind#633], maybe better just not do anything...\n+    protected void handleMissingId(Object value) {\n+        /*\n+        String typeDesc = (value == null) ? \"NULL\" : value.getClass().getName();\n+        throw new IllegalArgumentException(\"Can not resolve type id for \"\n+                +typeDesc+\" (using \"+_idResolver.getClass().getName()+\")\");\n+                */\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n public class SimpleKeyDeserializers\n     implements KeyDeserializers, java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = -6786398737835438187L;\n+    private static final long serialVersionUID = 1L;\n \n     protected HashMap<ClassKey,KeyDeserializer> _classMappings = null;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n import java.util.Map;\n \n import com.fasterxml.jackson.core.Version;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n     extends Module\n     implements java.io.Serializable\n {\n-    // at 2.4.0:\n-    private static final long serialVersionUID = -8905749147637667249L;\n+    private static final long serialVersionUID = 1L; // 2.5.0\n \n     protected final String _name;\n     protected final Version _version;\n      * use actual name and version number information.\n      */\n     public SimpleModule() {\n-        // when passing 'this', can not chain constructors...\n-        _name = \"SimpleModule-\"+System.identityHashCode(this);\n+        // can't chain when making reference to 'this'\n+        // note: generate different name for direct instantiation, sub-classing\n+        _name = (getClass() == SimpleModule.class) ?\n+                \"SimpleModule-\"+System.identityHashCode(this)\n+                : getClass().getName();\n         _version = Version.unknownVersion();\n     }\n     \n             _serializers = new SimpleSerializers(serializers);\n         }\n     }\n+\n+    /**\n+     * Since instances are likely to be custom, implementation returns\n+     * <code>null</code> if (but only if!) this class is directly instantiated;\n+     * but class name (default impl) for sub-classes.\n+     */\n+    @Override\n+    public Object getTypeId() {\n+        if (getClass() == SimpleModule.class) {\n+            return null;\n+        }\n+        return super.getTypeId();\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n     protected JsonNode _at(JsonPointer ptr) {\n         return get(ptr.getMatchingIndex());\n     }\n-    \n+\n     // note: co-variant to allow caller-side type safety\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     @Override\n     public void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException\n     {\n-        jg.writeStartArray();\n-        for (JsonNode n : _children) {\n-            /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n-             *   extend BaseJsonNode? Or if not, at least implement\n-             *   JsonSerializable? Let's start with former, change if\n-             *   we must.\n-             */\n-            ((BaseJsonNode)n).serialize(jg, provider);\n+    \tfinal List<JsonNode> c = _children;\n+    \tfinal int size = c.size();\n+        jg.writeStartArray(size);\n+        for (int i = 0; i < size; ++i) { // we'll typically have array list\n+        \t// Can we trust that all nodes will always extend BaseJsonNode? Or if not,\n+        \t// at least implement JsonSerializable? Let's start with former, change if must\n+            ((BaseJsonNode) c.get(i)).serialize(jg, provider);\n         }\n         jg.writeEndArray();\n     }\n     protected boolean _childrenEqual(ArrayNode other) {\n         return _children.equals(other._children);\n     }\n-    \n+\n     @Override\n     public int hashCode() {\n         return _children.hashCode();\n     }\n-\n \n     @Override\n     public String toString()\n--- a/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n     public ValueNode numberNode(Integer value) {\n         return (value == null) ? nullNode() : IntNode.valueOf(value.intValue());\n     }\n-    \n+\n     /**\n      * Factory method for getting an instance of JSON numeric value\n      * that expresses given 64-bit integer value\n--- a/src/main/java/com/fasterxml/jackson/databind/node/NodeCursor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NodeCursor.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.JsonNode;\n \n /**\n      * Current field name\n      */\n     protected String _currentName;\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected java.lang.Object _currentValue;\n     \n     public NodeCursor(int contextType, NodeCursor p)\n     {\n     public void overrideCurrentName(String name) {\n         _currentName = name;\n     }\n+\n+    @Override\n+    public java.lang.Object getCurrentValue() {\n+        return _currentValue;\n+    }\n+\n+    @Override\n+    public void setCurrentValue(java.lang.Object v) {\n+        _currentValue = v;\n+    }\n     \n     /*\n     /**********************************************************\n         JsonNode n = currentNode();\n         if (n == null) throw new IllegalStateException(\"No current node\");\n         if (n.isArray()) { // false since we have already returned START_ARRAY\n-            return new Array(n, this);\n+            return new ArrayCursor(n, this);\n         }\n         if (n.isObject()) {\n-            return new Object(n, this);\n+            return new ObjectCursor(n, this);\n         }\n         throw new IllegalStateException(\"Current node of type \"+n.getClass().getName());\n     }\n      * than JSON Object and Array).\n      * Note that context is NOT created for leaf values.\n      */\n-    protected final static class RootValue\n+    protected final static class RootCursor\n         extends NodeCursor\n     {\n         protected JsonNode _node;\n \n         protected boolean _done = false;\n \n-        public RootValue(JsonNode n, NodeCursor p) {\n+        public RootCursor(JsonNode n, NodeCursor p) {\n             super(JsonStreamContext.TYPE_ROOT, p);\n             _node = n;\n         }\n     /**\n      * Cursor used for traversing non-empty JSON Array nodes\n      */\n-    protected final static class Array\n+    protected final static class ArrayCursor\n         extends NodeCursor\n     {\n         protected Iterator<JsonNode> _contents;\n \n         protected JsonNode _currentNode;\n \n-        public Array(JsonNode n, NodeCursor p) {\n+        public ArrayCursor(JsonNode n, NodeCursor p) {\n             super(JsonStreamContext.TYPE_ARRAY, p);\n             _contents = n.elements();\n         }\n     /**\n      * Cursor used for traversing non-empty JSON Object nodes\n      */\n-    protected final static class Object\n+    protected final static class ObjectCursor\n         extends NodeCursor\n     {\n         protected Iterator<Map.Entry<String, JsonNode>> _contents;\n \n         protected boolean _needEntry;\n         \n-        public Object(JsonNode n, NodeCursor p)\n+        public ObjectCursor(JsonNode n, NodeCursor p)\n         {\n             super(JsonStreamContext.TYPE_OBJECT, p);\n             _contents = ((ObjectNode) n).fields();\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n \n     /**\n      * Method for setting value of a field to specified numeric value.\n+     * The underlying {@link JsonNode} that will be added is constructed\n+     * using {@link JsonNodeFactory#numberNode(int)}, and may be\n+     *  \"smaller\" (like {@link ShortNode}) in cases where value fits within\n+     *  range of a smaller integral numeric value.\n      * \n      * @return This node (to allow chaining)\n      */\n     \n     /**\n      * Method for setting value of a field to specified numeric value.\n+     * The underlying {@link JsonNode} that will be added is constructed\n+     * using {@link JsonNodeFactory#numberNode(long)}, and may be\n+     *  \"smaller\" (like {@link IntNode}) in cases where value fits within\n+     *  range of a smaller integral numeric value.\n      * \n      * @return This node (to allow chaining)\n      */\n     }\n \n     /**\n-     * Alternative method that we need to avoid bumping into NPE issues\n-     * with auto-unboxing.\n+     * Method for setting value of a field to specified numeric value.\n+     * The underlying {@link JsonNode} that will be added is constructed\n+     * using {@link JsonNodeFactory#numberNode(Long)}, and may be\n+     *  \"smaller\" (like {@link IntNode}) in cases where value fits within\n+     *  range of a smaller integral numeric value.\n+     * <p>\n+     * Note that this is alternative to {@link #put(String, long)} needed to avoid\n+     * bumping into NPE issues with auto-unboxing.\n      * \n      * @return This node (to allow chaining)\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n         _objectCodec = codec;\n         if (n.isArray()) {\n             _nextToken = JsonToken.START_ARRAY;\n-            _nodeCursor = new NodeCursor.Array(n, null);\n+            _nodeCursor = new NodeCursor.ArrayCursor(n, null);\n         } else if (n.isObject()) {\n             _nextToken = JsonToken.START_OBJECT;\n-            _nodeCursor = new NodeCursor.Object(n, null);\n+            _nodeCursor = new NodeCursor.ObjectCursor(n, null);\n         } else { // value node\n-            _nodeCursor = new NodeCursor.RootValue(n, null);\n+            _nodeCursor = new NodeCursor.RootCursor(n, null);\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n                 throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n                         +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n             }\n-            _serializer.serializeFilteredFields((Map<?,?>) value, jgen, provider, filter);\n+            // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n+            _serializer.serializeFilteredFields((Map<?,?>) value, jgen, provider, filter, null);\n         }\n     \n     // Note: NOT part of ResolvableSerializer...\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\n import com.fasterxml.jackson.databind.ser.impl.*;\n import com.fasterxml.jackson.databind.ser.std.*;\n import com.fasterxml.jackson.databind.type.*;\n-import com.fasterxml.jackson.databind.util.ClassUtil;\n-import com.fasterxml.jackson.databind.util.Converter;\n-import com.fasterxml.jackson.databind.util.EnumValues;\n-import com.fasterxml.jackson.databind.util.TokenBuffer;\n+import com.fasterxml.jackson.databind.util.*;\n \n /**\n  * Factory class that can provide serializers for standard JDK classes,\n         _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));\n \n         // Other numbers, more complicated\n-        final JsonSerializer<?> ns = NumberSerializer.instance;\n-        _concrete.put(BigInteger.class.getName(), ns);\n-        _concrete.put(BigDecimal.class.getName(), ns);\n+        _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));\n+        _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));\n \n         // Other discrete non-container types:\n         // First, Date/Time zoo:\n             JavaType keyType, JsonSerializer<Object> defaultImpl)\n     {\n         // We should not need any member method info; at most class annotations for Map type\n+        // ... at least, not here.\n         BeanDescription beanDesc = config.introspectClassAnnotations(keyType.getRawClass());\n         JsonSerializer<?> ser = null;\n         // Minor optimization: to avoid constructing beanDesc, bail out if none registered\n         if (ser == null) {\n             ser = defaultImpl;\n             if (ser == null) {\n-                ser = StdKeySerializers.getStdKeySerializer(keyType);\n+                ser = StdKeySerializers.getStdKeySerializer(config, keyType.getRawClass(), false);\n+                // As per [databind#47], also need to support @JsonValue\n+                if (ser == null) {\n+                    beanDesc = config.introspect(keyType);\n+                    AnnotatedMethod am = beanDesc.findJsonValueMethod();\n+                    if (am != null) {\n+                        final Class<?> rawType = am.getRawReturnType();\n+                        JsonSerializer<?> delegate = StdKeySerializers.getStdKeySerializer(config,\n+                                rawType, true);\n+                        Method m = am.getAnnotated();\n+                        if (config.canOverrideAccessModifiers()) {\n+                            ClassUtil.checkAndFixAccess(m);\n+                        }\n+                        ser = new JsonValueSerializer(m, delegate);\n+                    } else {\n+                        ser = StdKeySerializers.getDefault();\n+                    }\n+                }\n             }\n         }\n         \n      */\n \n     protected abstract Iterable<Serializers> customSerializers();\n-    \n+\n     /*\n     /**********************************************************\n     /* Overridable secondary serializer accessor methods\n         if (java.util.Date.class.isAssignableFrom(raw)) {\n             return DateSerializer.instance;\n         }\n+        if (Map.Entry.class.isAssignableFrom(raw)) {\n+            JavaType kt, vt;\n+            JavaType[] params = prov.getTypeFactory().findTypeParameters(type, Map.Entry.class);\n+            if (params == null || params.length != 2) { // assume that if we don't get 2, they are wrong...\n+                kt = vt = TypeFactory.unknownType();\n+            } else {\n+                kt = params[0];\n+                vt = params[1];\n+            }\n+            return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt);\n+        }\n         if (ByteBuffer.class.isAssignableFrom(raw)) {\n             return new ByteBufferSerializer();\n         }\n     {\n         Class<?> type = javaType.getRawClass();\n \n-        // These need to be in decreasing order of specificity...\n         if (Iterator.class.isAssignableFrom(type)) {\n-            return buildIteratorSerializer(config, javaType, beanDesc, staticTyping);\n+            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class);\n+            JavaType vt = (params == null || params.length != 1) ?\n+                    TypeFactory.unknownType() : params[0];\n+            return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt);\n         }\n         if (Iterable.class.isAssignableFrom(type)) {\n-            return buildIterableSerializer(config, javaType, beanDesc,  staticTyping);\n+            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class);\n+            JavaType vt = (params == null || params.length != 1) ?\n+                    TypeFactory.unknownType() : params[0];\n+            return buildIterableSerializer(config, javaType, beanDesc,  staticTyping, vt);\n         }\n         if (CharSequence.class.isAssignableFrom(type)) {\n             return ToStringSerializer.instance;\n             } else {\n             */\n             Object filterId = findFilterId(config, beanDesc);\n-            ser = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()),\n+            MapSerializer mapSer = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()),\n                     type, staticTyping, elementTypeSerializer,\n                     keySerializer, elementValueSerializer, filterId);\n+            Object suppressableValue = findSuppressableContentValue(config,\n+                    type.getContentType(), beanDesc);\n+            if (suppressableValue != null) {\n+                mapSer = mapSer.withContentInclusion(suppressableValue);\n+            }\n+            ser = mapSer;\n         }\n         // [Issue#120]: Allow post-processing\n         if (_factoryConfig.hasSerializerModifiers()) {\n         return ser;\n     }\n \n+    /**\n+     * @since 2.5\n+     */\n+    protected Object findSuppressableContentValue(SerializationConfig config,\n+            JavaType contentType, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);\n+\n+        if (incl != null) {\n+            switch (incl) {\n+            case NON_DEFAULT:\n+                // 19-Oct-2014, tatu: Not sure what this'd mean; so take it to mean \"NON_EMPTY\"...\n+                incl = JsonInclude.Include.NON_EMPTY;\n+                break;\n+            default:\n+                // all other modes actually good as is, unless we'll find better ways\n+                break;\n+            }\n+            return incl;\n+        }\n+        return null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Factory methods, for Arrays\n     /**********************************************************\n      */\n \n+    /**\n+     * @since 2.5\n+     */\n     protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,\n-            JavaType type, BeanDescription beanDesc,\n-            boolean staticTyping)\n-        throws JsonMappingException\n-    {\n-        // if there's generic type, it'll be the first contained type\n-        JavaType valueType = type.containedType(0);\n-        if (valueType == null) {\n-            valueType = TypeFactory.unknownType();\n-        }\n-        TypeSerializer vts = createTypeSerializer(config, valueType);\n-        return new IteratorSerializer(valueType, staticTyping, vts, null);\n-    }\n-\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n+            JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType), null);\n+    }\n+\n+    @Deprecated // since 2.5\n+    protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException\n+    {\n+        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class);\n+        JavaType vt = (params == null || params.length != 1) ?\n+                TypeFactory.unknownType() : params[0];\n+        return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); \n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n+            JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType), null);\n+    }\n+\n+    @Deprecated // since 2.5\n     protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,\n             JavaType type, BeanDescription beanDesc,\n             boolean staticTyping)\n         throws JsonMappingException\n     {\n-        // if there's generic type, it'll be the first contained type\n-        JavaType valueType = type.containedType(0);\n-        if (valueType == null) {\n-            valueType = TypeFactory.unknownType();\n-        }\n-        TypeSerializer vts = createTypeSerializer(config, valueType);\n-        return new IterableSerializer(valueType, staticTyping, vts, null);\n-    }\n-    \n+        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class);\n+        JavaType vt = (params == null || params.length != 1) ?\n+                TypeFactory.unknownType() : params[0];\n+        return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); \n+    }\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config,\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n+            JavaType keyType, JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        return new MapEntrySerializer(valueType, keyType, valueType,\n+                staticTyping, createTypeSerializer(config, valueType), null);\n+    }\n+\n     protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config,\n             JavaType type, BeanDescription beanDesc)\n         throws JsonMappingException\n     {\n-        /* As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n+        /* As per [databind#24], may want to use alternate shape, serialize as JSON Object.\n          * Challenge here is that EnumSerializer does not know how to produce\n          * POJO style serialization, so we must handle that special case separately;\n          * otherwise pass it to EnumSerializer.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n import java.lang.reflect.Type;\n import java.util.HashMap;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.SerializableString;\n import com.fasterxml.jackson.core.io.SerializedString;\n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n      */\n-    public final static Object MARKER_FOR_EMPTY = new Object();\n-    \n+    public final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;\n+\n     /*\n     /**********************************************************\n     /* Settings for accessing property value to serialize\n      * under which value for the property is written.\n      *<p>\n      * NOTE: do NOT change name of this field; it is accessed by\n-     * Afterburner module.\n+     * Afterburner module (until 2.4; not directly from 2.5)\n      * ALSO NOTE: ... and while it really ought to be `SerializableString`,\n      * changing that is also binary-incompatible change. So nope.\n      */\n     {\n         _member = member;\n         _contextAnnotations = contextAnnotations;\n+\n         _name = new SerializedString(propDef.getName());\n         _wrapperName = propDef.getWrapperName();\n+        _metadata = propDef.getMetadata();\n+        _includeInViews = propDef.findViews();\n+\n         _declaredType = declaredType;\n         _serializer = (JsonSerializer<Object>) ser;\n-        _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null;\n+        _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyForProperties() : null;\n         _typeSerializer = typeSer;\n         _cfgSerializationType = serType;\n-        _metadata = propDef.getMetadata();\n \n         if (member instanceof AnnotatedField) {\n             _accessorMethod = null;\n             _accessorMethod = (Method) member.getMember();\n             _field = null;\n         } else {\n-            throw new IllegalArgumentException(\"Can not pass member of type \"+member.getClass().getName());\n+            // 01-Dec-2014, tatu: Used to be illegal, but now explicitly allowed for virtual props\n+            _accessorMethod = null;\n+            _field = null;\n         }\n         _suppressNulls = suppressNulls;\n         _suppressableValue = suppressableValue;\n-        _includeInViews = propDef.findViews();\n \n         // this will be resolved later on, unless nulls are to be suppressed\n         _nullSerializer = null;\n     }\n \n     /**\n+     * Constructor that may be of use to virtual properties, when there is need for\n+     * the zero-arg (\"default\") constructor, and actual initialization is done\n+     * after constructor call.\n+     * \n+     * @since 2.5\n+     */\n+    protected BeanPropertyWriter() {\n+        _member = null;\n+        _contextAnnotations = null;\n+\n+        _name = null;\n+        _wrapperName = null;\n+        _metadata = null;\n+        _includeInViews = null;\n+\n+        _declaredType = null;\n+        _serializer = null;\n+        _dynamicSerializers = null;\n+        _typeSerializer = null;\n+        _cfgSerializationType = null;\n+\n+        _accessorMethod = null;\n+        _field = null;\n+        _suppressNulls = false;\n+        _suppressableValue = null;\n+\n+        _nullSerializer = null;\n+    }\n+\n+    /**\n      * \"Copy constructor\" to be used by filtering sub-classes\n      */\n     protected BeanPropertyWriter(BeanPropertyWriter base) {\n         this(base, base._name);\n     }\n \n-    protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name) {\n-        _name = name;\n+    /**\n+     * @since 2.5\n+     */\n+    protected BeanPropertyWriter(BeanPropertyWriter base, PropertyName name)\n+    {\n+        /* 02-Dec-2014, tatu: This is a big mess, alas, what with dependency\n+         *   to MapperConfig to encode, and Afterburner having heartburn\n+         *   for SerializableString (vs SerializedString).\n+         *   Hope it can be resolved/reworker in 2.6 timeframe, if not for 2.5\n+         */\n+        _name = new SerializedString(name.getSimpleName());\n         _wrapperName = base._wrapperName;\n \n         _member = base._member;\n         _metadata = base._metadata;\n     }\n \n+    protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name) {\n+        _name = name;\n+        _wrapperName = base._wrapperName;\n+\n+        _member = base._member;\n+        _contextAnnotations = base._contextAnnotations;\n+        _declaredType = base._declaredType;\n+        _accessorMethod = base._accessorMethod;\n+        _field = base._field;\n+        _serializer = base._serializer;\n+        _nullSerializer = base._nullSerializer;\n+        // one more thing: copy internal settings, if any (since 1.7)\n+        if (base._internalSettings != null) {\n+            _internalSettings = new HashMap<Object,Object>(base._internalSettings);\n+        }\n+        _cfgSerializationType = base._cfgSerializationType;\n+        _dynamicSerializers = base._dynamicSerializers;\n+        _suppressNulls = base._suppressNulls;\n+        _suppressableValue = base._suppressableValue;\n+        _includeInViews = base._includeInViews;\n+        _typeSerializer = base._typeSerializer;\n+        _nonTrivialBaseType = base._nonTrivialBaseType;\n+        _metadata = base._metadata;\n+    }\n+\n     public BeanPropertyWriter rename(NameTransformer transformer) {\n         String newName = transformer.transform(_name.getValue());\n         if (newName.equals(_name.toString())) {\n             return this;\n         }\n-        return new BeanPropertyWriter(this, new SerializedString(newName));\n+        return new BeanPropertyWriter(this, new PropertyName(newName));\n     }\n     \n     /**\n     @Override public PropertyName getWrapperName() { return _wrapperName; }\n     @Override public boolean isRequired() { return _metadata.isRequired(); }\n     @Override public PropertyMetadata getMetadata() { return _metadata; }\n-    \n+\n+    // Note: also part of 'PropertyWriter'\n     @Override\n     public <A extends Annotation> A getAnnotation(Class<A> acls) {\n-        return _member.getAnnotation(acls);\n-    }\n-\n+        return (_member == null) ? null : _member.getAnnotation(acls);\n+    }\n+\n+    // Note: also part of 'PropertyWriter'\n     @Override\n     public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n-        return _contextAnnotations.get(acls);\n+        return (_contextAnnotations == null) ? null : _contextAnnotations.get(acls);\n     }\n \n     @Override public AnnotatedMember getMember() { return _member; }\n     protected void _depositSchemaProperty(ObjectNode propertiesNode, JsonNode schemaNode) {\n         propertiesNode.set(getName(), schemaNode);\n     }\n+\n+    /**\n+     * Note: will be defined in {@link BeanProperty}; as of now is not yet.\n+     *<p>\n+     * TODO: move to {@link BeanProperty} in near future, once all standard\n+     * implementations define it.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isVirtual() { return false; }\n     \n     /*\n     /**********************************************************\n         if (_accessorMethod != null) {\n             return _accessorMethod.getGenericReturnType();\n         }\n-        return _field.getGenericType();\n+        if (_field != null) {\n+            return _field.getGenericType();\n+        }\n+        return null;\n     }\n \n     public Class<?>[] getViews() { return _includeInViews; }\n \n-    /**\n-     *<p>\n-     * NOTE: due to introspection, this is a <b>slow</b> method to call\n-     * and should never be called during actual serialization or filtering\n-     * of the property. Rather it is needed for traversal needed for things\n-     * like constructing JSON Schema instances.\n-     * \n-     * @since 2.1\n-     * \n-     * @deprecated since 2.2, use {@link #isRequired()} instead.\n-     */\n-    @Deprecated\n-    protected boolean isRequired(AnnotationIntrospector intr) { return _metadata.isRequired(); }\n-    \n     /*\n     /**********************************************************\n     /* PropertyWriter methods (serialization)\n      * using appropriate serializer.\n      */\n     @Override\n-    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception\n+    public void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception\n     {\n         // inlined 'get()'\n         final Object value = (_accessorMethod == null) ? _field.get(bean) : _accessorMethod.invoke(bean);\n         // Null handling is bit different, check that first\n         if (value == null) {\n             if (_nullSerializer != null) {\n-                jgen.writeFieldName(_name);\n-                _nullSerializer.serialize(null, jgen, prov);\n+                gen.writeFieldName(_name);\n+                _nullSerializer.serialize(null, gen, prov);\n             }\n             return;\n         }\n         // and then see if we must suppress certain values (default, empty)\n         if (_suppressableValue != null) {\n             if (MARKER_FOR_EMPTY == _suppressableValue) {\n-                if (ser.isEmpty(value)) {\n+                if (ser.isEmpty(prov, value)) {\n                     return;\n                 }\n             } else if (_suppressableValue.equals(value)) {\n         // For non-nulls: simple check for direct cycles\n         if (value == bean) {\n             // three choices: exception; handled by call; or pass-through\n-            if (_handleSelfReference(bean, jgen, prov, ser)) {\n+            if (_handleSelfReference(bean, gen, prov, ser)) {\n                 return;\n             }\n         }\n-        jgen.writeFieldName(_name);\n+        gen.writeFieldName(_name);\n         if (_typeSerializer == null) {\n-            ser.serialize(value, jgen, prov);\n+            ser.serialize(value, gen, prov);\n         } else {\n-            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+            ser.serializeWithType(value, gen, prov, _typeSerializer);\n         }\n     }\n \n      * @since 2.3\n      */\n     @Override\n-    public void serializeAsOmittedField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception\n+    public void serializeAsOmittedField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception\n     {\n-        if (!jgen.canOmitFields()) {\n-            jgen.writeOmittedField(_name.getValue());\n+        if (!gen.canOmitFields()) {\n+            gen.writeOmittedField(_name.getValue());\n         }\n     }\n     \n      * @since 2.3\n      */\n     @Override\n-    public void serializeAsElement(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+    public void serializeAsElement(Object bean, JsonGenerator gen, SerializerProvider prov)\n         throws Exception\n     {\n         // inlined 'get()'\n         final Object value = (_accessorMethod == null) ? _field.get(bean) : _accessorMethod.invoke(bean);\n         if (value == null) { // nulls need specialized handling\n             if (_nullSerializer != null) {\n-                _nullSerializer.serialize(null, jgen, prov);\n+                _nullSerializer.serialize(null, gen, prov);\n             } else { // can NOT suppress entries in tabular output\n-                jgen.writeNull();\n+                gen.writeNull();\n             }\n             return;\n         }\n         // and then see if we must suppress certain values (default, empty)\n         if (_suppressableValue != null) {\n             if (MARKER_FOR_EMPTY == _suppressableValue) {\n-                if (ser.isEmpty(value)) { // can NOT suppress entries in tabular output\n-                    serializeAsPlaceholder(bean, jgen, prov);\n+                if (ser.isEmpty(prov, value)) { // can NOT suppress entries in tabular output\n+                    serializeAsPlaceholder(bean, gen, prov);\n                     return;\n                 }\n             } else if (_suppressableValue.equals(value)) { // can NOT suppress entries in tabular output\n-                serializeAsPlaceholder(bean, jgen, prov);\n+                serializeAsPlaceholder(bean, gen, prov);\n                 return;\n             }\n         }\n         // For non-nulls: simple check for direct cycles\n         if (value == bean) {\n-            if (_handleSelfReference(bean, jgen, prov, ser)) {\n+            if (_handleSelfReference(bean, gen, prov, ser)) {\n                 return;\n             }\n         }\n         if (_typeSerializer == null) {\n-            ser.serialize(value, jgen, prov);\n+            ser.serialize(value, gen, prov);\n         } else {\n-            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+            ser.serializeWithType(value, gen, prov, _typeSerializer);\n         }\n     }\n \n      * @since 2.1\n      */\n     @Override\n-    public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+    public void serializeAsPlaceholder(Object bean, JsonGenerator gen, SerializerProvider prov)\n         throws Exception\n     {\n         if (_nullSerializer != null) {\n-            _nullSerializer.serialize(null, jgen, prov);\n+            _nullSerializer.serialize(null, gen, prov);\n         } else {\n-            jgen.writeNull();\n+            gen.writeNull();\n         }\n     }\n     \n     }\n \n     /**\n-     * @deprecated Since 2.3 Use overloaded variants\n-     */\n-    @Deprecated\n-    protected void _handleSelfReference(Object bean, JsonSerializer<?> ser)\n-        throws JsonMappingException {\n-        _handleSelfReference(bean, null, null, ser);\n-    }\n-    \n-    /**\n      * Method called to handle a direct self-reference through this property.\n      * Method can choose to indicate an error by throwing {@link JsonMappingException};\n      * fully handle serialization (and return true); or indicate that it should be\n      * @return True if method fully handled self-referential value; false if not (caller\n      *    is to handle it) or {@link JsonMappingException} if there is no way handle it\n      */\n-    protected boolean _handleSelfReference(Object bean, JsonGenerator jgen, SerializerProvider prov, JsonSerializer<?> ser)\n+    protected boolean _handleSelfReference(Object bean, JsonGenerator gen, SerializerProvider prov, JsonSerializer<?> ser)\n             throws JsonMappingException {\n         if (prov.isEnabled(SerializationFeature.FAIL_ON_SELF_REFERENCES)\n                 && !ser.usesObjectId()) {\n         sb.append(\"property '\").append(getName()).append(\"' (\");\n         if (_accessorMethod != null) {\n             sb.append(\"via method \").append(_accessorMethod.getDeclaringClass().getName()).append(\"#\").append(_accessorMethod.getName());\n+        } else if (_field != null) {\n+            sb.append(\"field \\\"\").append(_field.getDeclaringClass().getName()).append(\"#\").append(_field.getName());\n         } else {\n-            sb.append(\"field \\\"\").append(_field.getDeclaringClass().getName()).append(\"#\").append(_field.getName());\n+            sb.append(\"virtual\");\n         }\n         if (_serializer == null) {\n             sb.append(\", no static serializer\");\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.impl.BeanAsArraySerializer;\n import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n public class BeanSerializer\n     extends BeanSerializerBase\n {\n+    private static final long serialVersionUID = -4536893235025590367L;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle: constructors\n         /* Can not:\n          * \n          * - have Object Id (may be allowed in future)\n-         * - have any getter\n-         * \n+         * - have \"any getter\"\n+         * - have per-property filters\n          */\n         if ((_objectIdWriter == null)\n                 && (_anyGetterWriter == null)\n      * {@link BeanPropertyWriter} instances.\n      */\n     @Override\n-    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public final void serialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         if (_objectIdWriter != null) {\n-            _serializeWithObjectId(bean, jgen, provider, true);\n+            _serializeWithObjectId(bean, gen, provider, true);\n             return;\n         }\n-        jgen.writeStartObject();\n+        gen.writeStartObject();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(bean);\n         if (_propertyFilterId != null) {\n-            serializeFieldsFiltered(bean, jgen, provider);\n+            serializeFieldsFiltered(bean, gen, provider);\n         } else {\n-            serializeFields(bean, jgen, provider);\n+            serializeFields(bean, gen, provider);\n         }\n-        jgen.writeEndObject();\n+        gen.writeEndObject();\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n                     // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                     if (ser == null) {\n                         ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n+                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n+                        //   'unknown' serializer assigned earlier, here, so that it gets properly\n+                        //   post-processed\n+                        if (ser == null) {\n+                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n+                        }\n                     }\n                 }\n             }\n         final SerializationConfig config = prov.getConfig();\n         BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n         builder.setConfig(config);\n-        \n+\n         // First: any detectable (auto-detect, annotations) properties to serialize?\n         List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n         if (props == null) {\n             props = new ArrayList<BeanPropertyWriter>();\n         }\n+        // [databind#638]: Allow injection of \"virtual\" properties:\n+        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n+\n         // [JACKSON-440] Need to allow modification bean properties to serialize:\n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                 props = mod.changeProperties(config, beanDesc, props);\n             }\n         }\n-        \n+\n         // Any properties to suppress?\n         props = filterBeanProperties(config, beanDesc, props);\n-        \n+\n         // [JACKSON-440] Need to allow reordering of properties to serialize\n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n         \n         JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n         \n-        /* However, after all modifications: no properties, no serializer\n-         * (note; as per [JACKSON-670], check was moved later on from an earlier location)\n-         */\n         if (ser == null) {\n-            /* 27-Nov-2009, tatu: Except that as per [JACKSON-201], we are\n-             *   ok with that as long as it has a recognized class annotation\n-             *  (which may come from a mix-in too)\n-             */\n+            // If we get this far, there were no properties found, so no regular BeanSerializer\n+            // would be constructed. But, couple of exceptions.\n+            // First: if there are known annotations, just create 'empty bean' serializer\n             if (beanDesc.hasKnownClassAnnotations()) {\n                 return builder.createDummy();\n             }\n \n     /**\n      * Method that will apply by-type limitations (as per [JACKSON-429]);\n-     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType} annotation but\n-     * can be supplied by module-provided introspectors too.\n+     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType}\n+     * annotation but can be supplied by module-provided introspectors too.\n      */\n     protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc,\n             List<BeanPropertyDefinition> properties)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n package com.fasterxml.jackson.databind.ser;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n  * etc) and {@link java.util.Map}s and iterable things\n  * ({@link java.util.Iterator}s).\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class ContainerSerializer<T>\n     extends StdSerializer<T>\n {\n \n     protected ContainerSerializer(Class<T> t) {\n         super(t);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected ContainerSerializer(JavaType fullType) {\n+        super(fullType);\n     }\n     \n     /**\n      * {@link com.fasterxml.jackson.databind.SerializerProvider#findValueSerializer}.\n      */\n     public abstract JsonSerializer<?> getContentSerializer();\n-    \n+\n     /*\n     /**********************************************************\n     /* Abstract methods for sub-classes to implement\n     /**********************************************************\n      */\n-    \n+\n     /* Overridden as abstract, to force re-implementation; necessary for all\n      * collection types.\n      */\n     @Override\n-    public abstract boolean isEmpty(T value);\n+    @Deprecated\n+    public boolean isEmpty(T value) {\n+        return isEmpty(null, value);\n+    }\n+\n+    // since 2.5: should be declared abstract in future (2.6)\n+//    @Override\n+//    public abstract boolean isEmpty(SerializerProvider prov, T value);\n \n     /**\n      * Method called to determine if the given value (of type handled by\n     {\n         if (property != null) {\n             AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n-            if (intr != null) {\n-                if (intr.findSerializationContentType(property.getMember(), property.getType()) != null) {\n+            AnnotatedMember m = property.getMember();\n+            if ((m != null) && (intr != null)) {\n+                if (intr.findSerializationContentType(m, property.getType()) != null) {\n                     return true;\n                 }\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n      * properly; specifically, that caches are cleared, but settings\n      * will otherwise remain identical; and that no sharing of state\n      * occurs.\n-     * \n-     * @since 2.4.4\n+     *\n+     * @since 2.5\n      */\n     public DefaultSerializerProvider copy() {\n         throw new IllegalStateException(\"DefaultSerializerProvider sub-class not overriding copy()\");\n      * this provider has access to (via caching and/or creating new serializers\n      * as need be).\n      */\n-    public void serializeValue(JsonGenerator jgen, Object value) throws IOException\n+    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n     {\n         if (value == null) {\n-            _serializeNull(jgen);\n+            _serializeNull(gen);\n             return;\n         }\n         Class<?> cls = value.getClass();\n             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n             if (wrap) {\n                 PropertyName pname = _rootNames.findRootName(value.getClass(), _config);\n-                jgen.writeStartObject();\n-                jgen.writeFieldName(pname.simpleAsEncoded(_config));\n+                gen.writeStartObject();\n+                gen.writeFieldName(pname.simpleAsEncoded(_config));\n             }\n         } else if (rootName.length() == 0) {\n             wrap = false;\n         } else { // [JACKSON-764]\n             // empty String means explicitly disabled; non-empty that it is enabled\n             wrap = true;\n-            jgen.writeStartObject();\n-            jgen.writeFieldName(rootName);\n+            gen.writeStartObject();\n+            gen.writeFieldName(rootName);\n         }\n         try {\n-            ser.serialize(value, jgen, this);\n-            if (wrap) {\n-                jgen.writeEndObject();\n+            ser.serialize(value, gen, this);\n+            if (wrap) {\n+                gen.writeEndObject();\n             }\n         } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n             throw ioe;\n      * @param rootType Type to use for locating serializer to use, instead of actual\n      *    runtime type. Must be actual type, or one of its super types\n      */\n-    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType) throws IOException\n+    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType) throws IOException\n     {\n         if (value == null) {\n-            _serializeNull(jgen);\n+            _serializeNull(gen);\n             return;\n         }\n         // Let's ensure types are compatible at this point\n             // [JACKSON-163]\n             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n             if (wrap) {\n-                jgen.writeStartObject();\n+                gen.writeStartObject();\n                 PropertyName pname = _rootNames.findRootName(value.getClass(), _config);\n-                jgen.writeFieldName(pname.simpleAsEncoded(_config));\n+                gen.writeFieldName(pname.simpleAsEncoded(_config));\n             }\n         } else if (rootName.length() == 0) {\n             wrap = false;\n         } else { // [JACKSON-764]\n             // empty String means explicitly disabled; non-empty that it is enabled\n             wrap = true;\n-            jgen.writeStartObject();\n-            jgen.writeFieldName(rootName);\n+            gen.writeStartObject();\n+            gen.writeFieldName(rootName);\n         }\n         try {\n-            ser.serialize(value, jgen, this);\n-            if (wrap) {\n-                jgen.writeEndObject();\n+            ser.serialize(value, gen, this);\n+            if (wrap) {\n+                gen.writeEndObject();\n             }\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n      * \n      * @since 2.1\n      */\n-    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException\n+    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException\n     {\n         if (value == null) {\n-            _serializeNull(jgen);\n+            _serializeNull(gen);\n             return;\n         }\n         // Let's ensure types are compatible at this point\n             // [JACKSON-163]\n             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n             if (wrap) {\n-                jgen.writeStartObject();\n+                gen.writeStartObject();\n                 PropertyName pname = (rootType == null)\n                         ? _rootNames.findRootName(value.getClass(), _config)\n                         : _rootNames.findRootName(rootType, _config);\n-                jgen.writeFieldName(pname.simpleAsEncoded(_config));\n+                gen.writeFieldName(pname.simpleAsEncoded(_config));\n             }\n         } else if (rootName.length() == 0) {\n             wrap = false;\n         } else { // [JACKSON-764]\n             // empty String means explicitly disabled; non-empty that it is enabled\n             wrap = true;\n-            jgen.writeStartObject();\n-            jgen.writeFieldName(rootName);\n+            gen.writeStartObject();\n+            gen.writeFieldName(rootName);\n         }\n         try {\n-            ser.serialize(value, jgen, this);\n-            if (wrap) {\n-                jgen.writeEndObject();\n+            ser.serialize(value, gen, this);\n+            if (wrap) {\n+                gen.writeEndObject();\n             }\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n     }\n \n     /**\n+     * Alternate serialization call used for polymorphic types, when {@link TypeSerializer}\n+     * is already known, but not actual value serializer.\n+     *\n+     * @since 2.5\n+     */\n+    public void serializePolymorphic(JsonGenerator gen, Object value, TypeSerializer typeSer)\n+            throws IOException\n+    {\n+        if (value == null) {\n+            _serializeNull(gen);\n+            return;\n+        }\n+        final Class<?> type = value.getClass();\n+        JsonSerializer<Object> ser = findValueSerializer(type, null);\n+\n+        final boolean wrap;\n+        String rootName = _config.getRootName();\n+        if (rootName == null) {\n+            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n+            if (wrap) {\n+                gen.writeStartObject();\n+                PropertyName pname = _rootNames.findRootName(type, _config);\n+                gen.writeFieldName(pname.simpleAsEncoded(_config));\n+            }\n+        } else if (rootName.length() == 0) {\n+            wrap = false;\n+        } else {\n+            wrap = true;\n+            gen.writeStartObject();\n+            gen.writeFieldName(rootName);\n+        }\n+        try {\n+            ser.serializeWithType(value, gen, this, typeSer);\n+            if (wrap) {\n+                gen.writeEndObject();\n+            }\n+        } catch (IOException ioe) { // no wrapping for IO (and derived)\n+            throw ioe;\n+        } catch (Exception e) { // but others do need to be, to get path etc\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+    }\n+    \n+    /**\n      * Helper method called when root value to serialize is null\n      * \n      * @since 2.3\n      */\n-    protected void _serializeNull(JsonGenerator jgen) throws IOException\n+    protected void _serializeNull(JsonGenerator gen) throws IOException\n     {\n         JsonSerializer<Object> ser = getDefaultNullValueSerializer();\n         try {\n-            ser.serialize(null, jgen, this);\n+            ser.serialize(null, gen, this);\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n         } catch (Exception e) { // but others do need to be, to get path etc\n         findValueSerializer(javaType, null).acceptJsonFormatVisitor(visitor, javaType);\n     }\n \n-    @Deprecated // since 2.3; use the overloaded variant\n-    public boolean hasSerializerFor(Class<?> cls) {\n-        return hasSerializerFor(cls, null);\n-    }\n-    \n     /**\n      * Method that can be called to see if this serializer provider\n      * can find a serializer for an instance of given class.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n {\n     final protected SerializationConfig _config;\n     final protected BeanDescription _beanDesc;\n-    final protected JsonInclude.Include _outputProps;\n+\n+    /**\n+     * Default inclusion mode for properties of the POJO for which\n+     * properties are collected; possibly overridden on\n+     * per-property basis.\n+     */\n+    final protected JsonInclude.Include _defaultInclusion;\n \n     final protected AnnotationIntrospector _annotationIntrospector;\n \n     {\n         _config = config;\n         _beanDesc = beanDesc;\n-        _outputProps = beanDesc.findSerializationInclusion(config.getSerializationInclusion());\n+        _defaultInclusion = beanDesc.findSerializationInclusion(config.getSerializationInclusion());\n         _annotationIntrospector = _config.getAnnotationIntrospector();\n     }\n \n \n     public Annotations getClassAnnotations() {\n         return _beanDesc.getClassAnnotations();\n-    }\n-\n-    /**\n-     * @deprecated Since 2.3, use variant that takes {@link SerializerProvider} as\n-     *   first argument -- to be removed from 2.4\n-     */\n-    @Deprecated\n-    protected final BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef,\n-            JavaType declaredType, JsonSerializer<?> ser,\n-            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n-            AnnotatedMember am, boolean defaultUseStaticTyping)\n-    {\n-        /* We will only retain this method until 2.4; left for now to explicitly\n-         * cause compilation/linking issue iff anyone has overridden the method\n-         * (hopefully not)\n-         */\n-        throw new IllegalStateException();\n     }\n \n     /**\n             }\n             JavaType ct = serializationType.getContentType();\n             /* 03-Sep-2010, tatu: This is somehow related to [JACKSON-356], but I don't completely\n-             *   yet understand how pieces fit together. Still, better be explicit than rely on\n+             *   yet understand how pieces fit together. Still, better to be explicit than rely on\n              *   NPE to indicate an issue...\n              */\n             if (ct == null) {\n         Object valueToSuppress = null;\n         boolean suppressNulls = false;\n \n-        JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps);\n-        if (methodProps != null) {\n-            switch (methodProps) {\n+        JsonInclude.Include inclusion = propDef.findInclusion();\n+        if (inclusion == null) {\n+            inclusion = _defaultInclusion;\n+        }\n+        if (inclusion != null) {\n+            switch (inclusion) {\n             case NON_DEFAULT:\n                 valueToSuppress = getDefaultValue(propDef.getName(), am);\n                 if (valueToSuppress == null) {\n                 am, _beanDesc.getClassAnnotations(), declaredType,\n                 ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n \n-        // 14-Oct-2013, tatu: And how about custom null serializer?\n+        // How about custom null serializer?\n         Object serDef = _annotationIntrospector.findNullSerializer(am);\n         if (serDef != null) {\n             bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n         }\n-        \n-        // [JACKSON-132]: Unwrapping\n+        // And then, handling of unwrapping\n         NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n         if (unwrapper != null) {\n             bpw = bpw.unwrappingWriter(unwrapper);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java\n package com.fasterxml.jackson.databind.ser;\n \n+import java.lang.annotation.Annotation;\n+\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n     public abstract String getName();\n \n     public abstract PropertyName getFullName();\n+\n+    /**\n+     * Convenience method for accessing annotation that may be associated\n+     * either directly on property, or, if not, via enclosing class (context).\n+     * This allows adding baseline contextual annotations, for example, by adding\n+     * an annotation for a given class and making that apply to all properties\n+     * unless overridden by per-property annotations.\n+     *<p>\n+     * This method is functionally equivalent to:\n+     *<pre>\n+     *  MyAnnotation ann = propWriter.getAnnotation(MyAnnotation.class);\n+     *  if (ann == null) {\n+     *    ann = propWriter.getContextAnnotation(MyAnnotation.class);\n+     *  }\n+     *</pre>\n+     * that is, tries to find a property annotation first, but if one is not\n+     * found, tries to find context-annotation (from enclosing class) of\n+     * same type.\n+     * \n+     * @since 2.5\n+     */\n+    public <A extends Annotation> A findAnnotation(Class<A> acls) {\n+        A ann = getAnnotation(acls);\n+        if (ann == null) {\n+            ann = getContextAnnotation(acls);\n+        }\n+        return ann;\n+    }\n     \n+    /**\n+     * Method for accessing annotations directly declared for property that this\n+     * writer is associated with.\n+     * \n+     * @since 2.5\n+     */\n+    public abstract <A extends Annotation> A getAnnotation(Class<A> acls);\n+\n+    /**\n+     * Method for accessing annotations declared in context of the property that this\n+     * writer is associated with; usually this means annotations on enclosing class\n+     * for property.\n+     * \n+     * @since 2.5\n+     */\n+    public abstract <A extends Annotation> A getContextAnnotation(Class<A> acls);\n+\n     /*\n     /**********************************************************\n     /* Serialization methods, regular output\n     /**\n      * The main serialization method called by filter when property is to be written normally.\n      */\n-    public abstract void serializeAsField(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsField(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /**\n      * filtered, but the underlying data format requires a placeholder of some kind.\n      * This is usually the case for tabular (positional) data formats such as CSV.\n      */\n-    public abstract void serializeAsOmittedField(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsOmittedField(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /*\n      * data format; so it is typically NOT called for fully tabular formats such as CSV,\n      * where logical output is still as form of POJOs.\n      */\n-    public abstract void serializeAsElement(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsElement(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /**\n      * but then value is to be omitted. This requires output of a placeholder value\n      * of some sort; often similar to {@link #serializeAsOmittedField}.\n      */\n-    public abstract void serializeAsPlaceholder(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsPlaceholder(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /*\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * {@link BeanPropertyWriter} implementation used with\n+ * {@link com.fasterxml.jackson.databind.annotation.JsonAppend}\n+ * to add \"virtual\" properties in addition to regular ones.\n+ * \n+ * @since 2.5\n+ * \n+ * @see com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter\n+ */\n+public abstract class VirtualBeanPropertyWriter\n+    extends BeanPropertyWriter\n+{\n+    /**\n+     * Constructor used by most sub-types.\n+     */\n+    protected VirtualBeanPropertyWriter(BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations, JavaType declaredType)\n+    {\n+        this(propDef, contextAnnotations, declaredType, null, null, null,\n+                propDef.findInclusion());\n+    }\n+\n+    /**\n+     * Constructor that may be used by sub-classes for constructing a \"blue-print\" instance;\n+     * one that will only become (or create) actual usable instance when its\n+     * {@link #withConfig} method is called.\n+     */\n+    protected VirtualBeanPropertyWriter() {\n+        super();\n+    }\n+\n+    /**\n+     * Pass-through constructor that may be used by sub-classes that\n+     * want full control over implementation.\n+     */\n+    protected VirtualBeanPropertyWriter(BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations, JavaType declaredType,\n+            JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType,\n+            JsonInclude.Include inclusion)\n+    {\n+        super(propDef, propDef.getPrimaryMember(), contextAnnotations, declaredType,\n+                ser, typeSer, serType,\n+                _suppressNulls(inclusion), _suppressableValue(inclusion));\n+    }\n+\n+    protected VirtualBeanPropertyWriter(VirtualBeanPropertyWriter base) {\n+        super(base);\n+    }\n+\n+    protected VirtualBeanPropertyWriter(VirtualBeanPropertyWriter base, PropertyName name) {\n+        super(base, name);\n+    }\n+\n+    protected static boolean _suppressNulls(JsonInclude.Include inclusion) {\n+        return (inclusion != JsonInclude.Include.ALWAYS);\n+    }\n+\n+    protected static Object _suppressableValue(JsonInclude.Include inclusion) {\n+        if ((inclusion == JsonInclude.Include.NON_EMPTY)\n+                || (inclusion == JsonInclude.Include.NON_EMPTY)) {\n+            return MARKER_FOR_EMPTY;\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard accessor overrides\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isVirtual() { return true; }\n+\n+    @Override\n+    public Class<?> getPropertyType() {\n+        return _declaredType.getRawClass();\n+    }\n+\n+    @Override\n+    public Type getGenericPropertyType() {\n+        return getPropertyType();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Abstract methods for sub-classes to define\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to figure out the value to serialize. For simple sub-types\n+     * (such as {@link com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter})\n+     * this may be one of few methods to define, although more advanced implementations\n+     * may choose to not even use this method (by overriding {@link #serializeAsField})\n+     * and define a bogus implementation.\n+     */\n+    protected abstract Object value(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception;\n+\n+    /**\n+     * Contextualization method called on a newly constructed virtual bean property.\n+     * Usually a new intance needs to be created due to finality of some of configuration\n+     * members; otherwise while recommended, creating a new instance is not strictly-speaking\n+     * mandatory because calls are made in thread-safe manner, as part of initialization\n+     * before use.\n+     *\n+     * @param config Currenct configuration; guaranteed to be {@link SerializationConfig}\n+     *   (just not typed since caller does not have dependency to serialization-specific types)\n+     * @param declaringClass Class that contains this property writer\n+     * @param propDef Nominal property definition to use\n+     * @param type Declared type for the property\n+     */\n+    public abstract VirtualBeanPropertyWriter withConfig(MapperConfig<?> config,\n+            AnnotatedClass declaringClass, BeanPropertyDefinition propDef, JavaType type);\n+\n+    /*\n+    /**********************************************************\n+    /* PropertyWriter serialization method overrides\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception\n+    {\n+        // NOTE: mostly copied from base class, but off-lined get() access\n+        final Object value = value(bean, gen, prov);\n+\n+        if (value == null) {\n+            if (_nullSerializer != null) {\n+                gen.writeFieldName(_name);\n+                _nullSerializer.serialize(null, gen, prov);\n+            }\n+            return;\n+        }\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap m = _dynamicSerializers;\n+            ser = m.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(m, cls, prov);\n+            }\n+        }\n+        if (_suppressableValue != null) {\n+            if (MARKER_FOR_EMPTY == _suppressableValue) {\n+                if (ser.isEmpty(prov, value)) {\n+                    return;\n+                }\n+            } else if (_suppressableValue.equals(value)) {\n+                return;\n+            }\n+        }\n+        if (value == bean) { // simple check for direct cycles\n+            // three choices: exception; handled by call; or pass-through\n+            if (_handleSelfReference(bean, gen, prov, ser)) {\n+                return;\n+            }\n+        }\n+        gen.writeFieldName(_name);\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, gen, prov);\n+        } else {\n+            ser.serializeWithType(value, gen, prov, _typeSerializer);\n+        }\n+    }\n+\n+    // This one's fine as-is from base class\n+    //public void serializeAsOmittedField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception\n+    \n+    @Override\n+    public void serializeAsElement(Object bean, JsonGenerator gen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        // NOTE: mostly copied from base class, but off-lined get() access\n+        final Object value = value(bean, gen, prov);\n+\n+        if (value == null) {\n+            if (_nullSerializer != null) {\n+                _nullSerializer.serialize(null, gen, prov);\n+            } else {\n+                gen.writeNull();\n+            }\n+            return;\n+        }\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+        if (_suppressableValue != null) {\n+            if (MARKER_FOR_EMPTY == _suppressableValue) {\n+                if (ser.isEmpty(prov, value)) {\n+                    serializeAsPlaceholder(bean, gen, prov);\n+                    return;\n+                }\n+            } else if (_suppressableValue.equals(value)) {\n+                serializeAsPlaceholder(bean, gen, prov);\n+                return;\n+            }\n+        }\n+        if (value == bean) {\n+            if (_handleSelfReference(bean, gen, prov, ser)) {\n+                return;\n+            }\n+        }\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, gen, prov);\n+        } else {\n+            ser.serializeWithType(value, gen, prov, _typeSerializer);\n+        }\n+    }\n+\n+    // This one's fine as-is from base class\n+    //public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/AttributePropertyWriter.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * {@link VirtualBeanPropertyWriter} implementation used for\n+ * {@link com.fasterxml.jackson.databind.annotation.JsonAppend},\n+ * to serialize properties backed-by dynamically assignable attribute\n+ * values.\n+ * \n+ * @since 2.5\n+ */\n+public class AttributePropertyWriter\n+    extends VirtualBeanPropertyWriter\n+{\n+    protected final String _attrName;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected AttributePropertyWriter(String attrName, BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations, JavaType declaredType) {\n+        this(attrName, propDef, contextAnnotations, declaredType, propDef.findInclusion());\n+    }\n+\n+    protected AttributePropertyWriter(String attrName, BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations, JavaType declaredType,\n+            JsonInclude.Include inclusion)\n+    {\n+        super(propDef, contextAnnotations, declaredType,\n+                /* value serializer */ null, /* type serializer */ null, /* ser type */ null,\n+                inclusion);\n+        _attrName = attrName;\n+    }\n+\n+    public static AttributePropertyWriter construct(String attrName,\n+            BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations,\n+            JavaType declaredType)\n+    {\n+        return new AttributePropertyWriter(attrName, propDef,\n+                contextAnnotations, declaredType);\n+    }\n+    \n+    protected AttributePropertyWriter(AttributePropertyWriter base) {\n+        super(base);\n+        _attrName = base._attrName;\n+    }\n+\n+    /**\n+     * Since this method should typically not be called on this sub-type,\n+     * default implementation simply throws an {@link IllegalStateException}.\n+     */\n+    @Override\n+    public VirtualBeanPropertyWriter withConfig(MapperConfig<?> config,\n+            AnnotatedClass declaringClass, BeanPropertyDefinition propDef, JavaType type) {\n+        throw new IllegalStateException(\"Should not be called on this type\");\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overrides for actual serialization, value access\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    protected Object value(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception {\n+        return prov.getAttribute(_attrName);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n public class BeanAsArraySerializer\n     extends BeanSerializerBase\n {\n+    private static final long serialVersionUID = -893701886577615846L;\n+\n     /**\n      * Serializer that would produce JSON Object version; used in\n      * cases where array output can not be used.\n     /**********************************************************\n      */\n \n-    // Re-defined from base class...\n-    @Override\n-    public void serializeWithType(Object bean, JsonGenerator jgen,\n+    // Re-defined from base class, due to differing prefixes\n+    @Override\n+    public void serializeWithType(Object bean, JsonGenerator gen,\n             SerializerProvider provider, TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n-        /* Should not even get here; but let's be nice and re-route\n-         * if need be.\n+        /* 10-Dec-2014, tatu: Not sure if this can be made to work reliably;\n+         *   but for sure delegating to default implementation will not work. So:\n          */\n-        _defaultSerializer.serializeWithType(bean, jgen, provider, typeSer);\n-    }\n-    \n+        if (_objectIdWriter != null) {\n+            _serializeWithObjectId(bean, gen, provider, typeSer);\n+            return;\n+        }\n+        String typeStr = (_typeId == null) ? null : _customTypeId(bean);\n+        if (typeStr == null) {\n+            typeSer.writeTypePrefixForArray(bean, gen);\n+        } else {\n+            typeSer.writeCustomTypePrefixForArray(bean, gen, typeStr);\n+        }\n+        serializeAsArray(bean, gen, provider);\n+        if (typeStr == null) {\n+            typeSer.writeTypeSuffixForArray(bean, gen);\n+        } else {\n+            typeSer.writeCustomTypeSuffixForArray(bean, gen, typeStr);\n+        }\n+    }\n+\n     /**\n      * Main serialization method that will delegate actual output to\n      * configured\n      * {@link BeanPropertyWriter} instances.\n      */\n     @Override\n-    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public final void serialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         // [JACKSON-805]\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(provider)) {\n-            serializeAsArray(bean, jgen, provider);\n+            serializeAsArray(bean, gen, provider);\n             return;\n         }\n         /* note: it is assumed here that limitations (type id, object id,\n          * any getter, filtering) have already been checked; so code here\n          * is trivial.\n          */\n-        jgen.writeStartArray();\n-        serializeAsArray(bean, jgen, provider);\n-        jgen.writeEndArray();\n+        gen.writeStartArray();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(bean);\n+        serializeAsArray(bean, gen, provider);\n+        gen.writeEndArray();\n     }\n \n     /*\n         return props.length == 1;\n     }\n \n-    protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    protected final void serializeAsArray(Object bean, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         final BeanPropertyWriter[] props;\n         if (_filteredProps != null && provider.getActiveView() != null) {\n             for (final int len = props.length; i < len; ++i) {\n                 BeanPropertyWriter prop = props[i];\n                 if (prop == null) { // can have nulls in filtered list; but if so, MUST write placeholders\n-                    jgen.writeNull();\n+                    gen.writeNull();\n                 } else {\n-                    prop.serializeAsElement(bean, jgen, provider);\n+                    prop.serializeAsElement(bean, gen, provider);\n                 }\n             }\n             // NOTE: any getters can not be supported either\n             //if (_anyGetterWriter != null) {\n-            //    _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+            //    _anyGetterWriter.getAndSerialize(bean, gen, provider);\n             //}\n         } catch (Exception e) {\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonNode;\n  * as well as for catching unintended usage (like trying to use null\n  * as Map/Object key).\n  */\n-public final class FailingSerializer\n+@SuppressWarnings(\"serial\")\n+public class FailingSerializer\n     extends StdSerializer<Object>\n {\n-    final String _msg;\n+    protected final String _msg;\n     \n     public FailingSerializer(String msg) {\n         super(Object.class);\n     }\n     \n     @Override\n-    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n         throw new JsonGenerationException(_msg);\n     }\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n-    {\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n         return null;\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedListSerializer.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n import java.io.IOException;\n-import java.util.LinkedList;\n-import java.util.List;\n+import java.util.*;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n public final class IndexedListSerializer\n     extends AsArraySerializerBase<List<?>>\n {\n+    private static final long serialVersionUID = 1L;\n+\n     public IndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts,\n             BeanProperty property, JsonSerializer<Object> valueSerializer)\n     {\n      */\n     \n     @Override\n-    public boolean isEmpty(List<?> value) {\n+    public boolean isEmpty(SerializerProvider prov, List<?> value) {\n         return (value == null) || value.isEmpty();\n     }\n \n     @Override\n     public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) {\n         return new IndexedListSerializer(_elementType, _staticTyping, vts, _property, _elementSerializer);\n+    }\n+\n+    @Override\n+    public final void serialize(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+    \tfinal int len = value.size();\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n     }\n     \n     @Override\n                 }\n             }\n         } catch (Exception e) {\n-            // [JACKSON-55] Need to add reference information\n             wrapAndThrow(provider, e, value, i);\n         }\n     }\n     \n     public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider,\n             JsonSerializer<Object> ser)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         final int len = value.size();\n         if (len == 0) {\n     }\n \n     public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         final int len = value.size();\n         if (len == 0) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n     extends StaticListSerializerBase<List<String>>\n     implements ContextualSerializer\n {\n+    private static final long serialVersionUID = 1L;\n+\n     public final static IndexedStringListSerializer instance = new IndexedStringListSerializer();\n     \n     protected final JsonSerializer<String> _serializer;\n             return;\n         }\n         \n-        jgen.writeStartArray();\n+        jgen.writeStartArray(len);\n         if (_serializer == null) {\n             serializeContents(value, jgen, provider, len);\n         } else {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IteratorSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IteratorSerializer.java\n import java.io.IOException;\n import java.util.Iterator;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.std.AsArraySerializerBase;\n \n+@SuppressWarnings(\"serial\")\n @JacksonStdImpl\n public class IteratorSerializer\n     extends AsArraySerializerBase<Iterator<?>>\n     }\n \n     @Override\n-    public boolean isEmpty(Iterator<?> value) {\n+    public boolean isEmpty(SerializerProvider prov, Iterator<?> value) {\n         return (value == null) || !value.hasNext();\n     }\n \n     }\n \n     @Override\n+    public final void serialize(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+        if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray();\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n+    \n+    @Override\n     public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         if (value.hasNext()) {\n             final TypeSerializer typeSer = _valueTypeSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/JsonSerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/JsonSerializerMap.java\n \n /**\n  * Specialized read-only map used for storing and accessing serializers by type.\n+ * Used for per-{@link com.fasterxml.jackson.databind.ObjectMapper} sharing\n+ * of resolved serializers; in addition, a per-call non-shared read/write\n+ * map may be needed, which will (after call) get merged to create a new\n+ * shared map of this type.\n  */\n public class JsonSerializerMap\n {\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n+\n+/**\n+ * @since 2.5\n+ */\n+@SuppressWarnings(\"serial\")\n+@JacksonStdImpl\n+public class MapEntrySerializer\n+    extends ContainerSerializer<Map.Entry<?,?>>\n+    implements ContextualSerializer\n+{\n+    /**\n+     * Map-valued property being serialized with this instance\n+     */\n+    protected final BeanProperty _property;\n+\n+    /**\n+     * Whether static types should be used for serialization of values\n+     * or not (if not, dynamic runtime type is used)\n+     */\n+    protected final boolean _valueTypeIsStatic;\n+\n+    protected final JavaType _entryType, _keyType, _valueType;\n+\n+    /**\n+     * Key serializer to use, if it can be statically determined\n+     */\n+    protected JsonSerializer<Object> _keySerializer;\n+    \n+    /**\n+     * Value serializer to use, if it can be statically determined\n+     */\n+    protected JsonSerializer<Object> _valueSerializer;\n+\n+    /**\n+     * Type identifier serializer used for values, if any.\n+     */\n+    protected final TypeSerializer _valueTypeSerializer;\n+\n+    /**\n+     * If value type can not be statically determined, mapping from\n+     * runtime value types to serializers are stored in this object.\n+     */\n+    protected PropertySerializerMap _dynamicValueSerializers;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+    \n+    public MapEntrySerializer(JavaType type, JavaType keyType, JavaType valueType,\n+            boolean staticTyping, TypeSerializer vts,\n+            BeanProperty property)\n+    {\n+        super(type);\n+        _entryType = type;\n+        _keyType = keyType;\n+        _valueType = valueType;\n+        _valueTypeIsStatic = staticTyping;\n+        _valueTypeSerializer = vts;\n+        _property = property;\n+        _dynamicValueSerializers = PropertySerializerMap.emptyForProperties();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected MapEntrySerializer(MapEntrySerializer src, BeanProperty property,\n+            TypeSerializer vts,\n+            JsonSerializer<?> keySer, JsonSerializer<?> valueSer)\n+    {\n+        super(Map.class, false);\n+        _entryType = src._entryType;\n+        _keyType = src._keyType;\n+        _valueType = src._valueType;\n+        _valueTypeIsStatic = src._valueTypeIsStatic;\n+        _valueTypeSerializer = src._valueTypeSerializer;\n+        _keySerializer = (JsonSerializer<Object>) keySer;\n+        _valueSerializer = (JsonSerializer<Object>) valueSer;\n+        _dynamicValueSerializers = src._dynamicValueSerializers;\n+        _property = src._property;\n+    }\n+\n+    @Override\n+    public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) {\n+        return new MapEntrySerializer(this, _property, vts, _keySerializer, _valueSerializer);\n+    }\n+\n+    public MapEntrySerializer withResolved(BeanProperty property,\n+            JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer) {\n+        return new MapEntrySerializer(this, property, _valueTypeSerializer, keySerializer, valueSerializer);\n+    }\n+\n+    @Override\n+    public JsonSerializer<?> createContextual(SerializerProvider provider,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        JsonSerializer<?> ser = null;\n+        JsonSerializer<?> keySer = null;\n+        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+        final AnnotatedMember propertyAcc = (property == null) ? null : property.getMember();\n+\n+        // First: if we have a property, may have property-annotation overrides\n+        if (propertyAcc != null && intr != null) {\n+            Object serDef = intr.findKeySerializer(propertyAcc);\n+            if (serDef != null) {\n+                keySer = provider.serializerInstance(propertyAcc, serDef);\n+            }\n+            serDef = intr.findContentSerializer(propertyAcc);\n+            if (serDef != null) {\n+                ser = provider.serializerInstance(propertyAcc, serDef);\n+            }\n+        }\n+        if (ser == null) {\n+            ser = _valueSerializer;\n+        }\n+        // [Issue#124]: May have a content converter\n+        ser = findConvertingContentSerializer(provider, property, ser);\n+        if (ser == null) {\n+            // 30-Sep-2012, tatu: One more thing -- if explicit content type is annotated,\n+            //   we can consider it a static case as well.\n+            // 20-Aug-2013, tatu: Need to avoid trying to access serializer for java.lang.Object tho\n+            if ((_valueTypeIsStatic && _valueType.getRawClass() != Object.class)\n+                    || hasContentTypeAnnotation(provider, property)) {\n+                ser = provider.findValueSerializer(_valueType, property);\n+            }\n+        } else {\n+            ser = provider.handleSecondaryContextualization(ser, property);\n+        }\n+        if (keySer == null) {\n+            keySer = _keySerializer;\n+        }\n+        if (keySer == null) {\n+            keySer = provider.findKeySerializer(_keyType, property);\n+        } else {\n+            keySer = provider.handleSecondaryContextualization(keySer, property);\n+        }\n+        MapEntrySerializer mser = withResolved(property, keySer, ser);\n+        // but note: no filtering, ignored entries or sorting (unlike Maps)\n+        return mser;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _valueType;\n+    }\n+\n+    @Override\n+    public JsonSerializer<?> getContentSerializer() {\n+        return _valueSerializer;\n+    }\n+\n+    @Override\n+    public boolean hasSingleElement(Map.Entry<?,?> value) {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isEmpty(SerializerProvider prov, Entry<?, ?> value) {\n+        return (value == null);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void serialize(Map.Entry<?, ?> value, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n+    {\n+        gen.writeStartObject();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        if (_valueSerializer != null) {\n+            serializeUsing(value, gen, provider, _valueSerializer);\n+        } else {\n+            serializeDynamic(value, gen, provider);\n+        }\n+        gen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(Map.Entry<?, ?> value, JsonGenerator gen, SerializerProvider provider,\n+            TypeSerializer typeSer) throws IOException\n+    {\n+        typeSer.writeTypePrefixForObject(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        if (_valueSerializer != null) {\n+            serializeUsing(value, gen, provider, _valueSerializer);\n+        } else {\n+            serializeDynamic(value, gen, provider);\n+        }\n+        typeSer.writeTypeSuffixForObject(value, gen);\n+    }\n+\n+    protected void serializeDynamic(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException\n+    {\n+        final JsonSerializer<Object> keySerializer = _keySerializer;\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n+        final TypeSerializer vts = _valueTypeSerializer;\n+\n+        PropertySerializerMap serializers = _dynamicValueSerializers;\n+\n+        Object valueElem = value.getValue();\n+        Object keyElem = value.getKey();\n+        if (keyElem == null) {\n+            provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n+        } else {\n+            // [JACKSON-314] skip entries with null values?\n+            if (skipNulls && valueElem == null) return;\n+            keySerializer.serialize(keyElem, jgen, provider);\n+        }\n+        // And then value\n+        if (valueElem == null) {\n+            provider.defaultSerializeNull(jgen);\n+        } else {\n+            Class<?> cc = valueElem.getClass();\n+            JsonSerializer<Object> ser = serializers.serializerFor(cc);\n+            if (ser == null) {\n+                if (_valueType.hasGenericTypes()) {\n+                    ser = _findAndAddDynamic(serializers,\n+                            provider.constructSpecializedType(_valueType, cc), provider);\n+                } else {\n+                    ser = _findAndAddDynamic(serializers, cc, provider);\n+                }\n+                serializers = _dynamicValueSerializers;\n+            }\n+            try {\n+                if (vts == null) {\n+                    ser.serialize(valueElem, jgen, provider);\n+                } else {\n+                    ser.serializeWithType(valueElem, jgen, provider, vts);\n+                }\n+            } catch (Exception e) {\n+                // [JACKSON-55] Need to add reference information\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method called to serialize fields, when the value type is statically known,\n+     * so that value serializer is passed and does not need to be fetched from\n+     * provider.\n+     */\n+    protected void serializeUsing(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider,\n+            JsonSerializer<Object> ser)\n+        throws IOException, JsonGenerationException\n+    {\n+        final JsonSerializer<Object> keySerializer = _keySerializer;\n+        final TypeSerializer vts = _valueTypeSerializer;\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n+\n+        Object valueElem = value.getValue();\n+        Object keyElem = value.getKey();\n+        if (keyElem == null) {\n+            provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n+        } else {\n+            // [JACKSON-314] also may need to skip entries with null values\n+            if (skipNulls && valueElem == null) return;\n+            keySerializer.serialize(keyElem, jgen, provider);\n+        }\n+        if (valueElem == null) {\n+            provider.defaultSerializeNull(jgen);\n+        } else {\n+            try {\n+                if (vts == null) {\n+                    ser.serialize(valueElem, jgen, provider);\n+                } else {\n+                    ser.serializeWithType(valueElem, jgen, provider, vts);\n+                }\n+            } catch (Exception e) {\n+                // [JACKSON-55] Need to add reference information\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            Class<?> type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSecondarySerializer(type, provider, _property);\n+        if (map != result.map) {\n+            _dynamicValueSerializers = result.map;\n+        }\n+        return result.serializer;\n+    }\n+\n+    protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            JavaType type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSecondarySerializer(type, provider, _property);\n+        if (map != result.map) {\n+            _dynamicValueSerializers = result.map;\n+        }\n+        return result.serializer;\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.util.Arrays;\n \n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-\n \n /**\n  * Helper container used for resolving serializers for dynamic (possibly but not\n public abstract class PropertySerializerMap\n {\n     /**\n+     * Configuration setting that determines what happens when maximum\n+     * size (currently 8) is reached: if true, will \"start from beginning\";\n+     * if false, will simply stop adding new entries.\n+     *\n+     * @since 2.5\n+     */\n+    protected final boolean _resetWhenFull;\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected PropertySerializerMap(boolean resetWhenFull) {\n+        _resetWhenFull = resetWhenFull;\n+    }\n+\n+    protected PropertySerializerMap(PropertySerializerMap base) {\n+        _resetWhenFull = base._resetWhenFull;\n+    }\n+\n+    /**\n      * Main lookup method. Takes a \"raw\" type since usage is always from\n      * place where parameterization is fixed such that there can not be\n      * type-parametric variations.\n      */\n     public abstract JsonSerializer<Object> serializerFor(Class<?> type);\n-\n-    /**\n-     * @deprecated Since 2.3; use either <code>findAndAddPrimarySerializer</code> or\n-     *    <code>findAndAddSecondarySerializer</code>.\n-     *    To be removed from 2.4\n-     */\n-    @Deprecated\n-    public final SerializerAndMapResult findAndAddSerializer(Class<?> type,\n-            SerializerProvider provider, BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        return findAndAddSecondarySerializer(type, provider, property);\n-    }\n-\n-    /**\n-     * @deprecated Since 2.3; use either <code>findAndAddPrimarySerializer</code> or\n-     *    <code>findAndAddSecondarySerializer</code>.\n-     *    To be removed from 2.4\n-     */\n-    @Deprecated\n-    public final SerializerAndMapResult findAndAddSerializer(JavaType type,\n-            SerializerProvider provider, BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        return findAndAddSecondarySerializer(type, provider, property);\n-    }\n \n     /**\n      * Method called if initial lookup fails, when looking for a primary\n         JsonSerializer<Object> serializer = provider.findPrimaryPropertySerializer(type, property);\n         return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));\n     }\n-    \n+\n     /**\n      * Method called if initial lookup fails, when looking for a non-primary\n      * serializer (one that is not directly attached to a property).\n         JsonSerializer<Object> serializer = provider.findValueSerializer(type, property);\n         return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));\n     }\n-    \n+\n+    /**\n+     * Method called if initial lookup fails, when looking for a root value\n+     * serializer: one that is not directly attached to a property, but needs to\n+     * have {@link com.fasterxml.jackson.databind.jsontype.TypeSerializer} wrapped\n+     * around it. Will both find the serializer\n+     * and construct new map instance if warranted, and return both.\n+     * \n+     * @since 2.5\n+     * \n+     * @throws JsonMappingException \n+     */\n+    public final SerializerAndMapResult findAndAddRootValueSerializer(Class<?> type,\n+            SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<Object> serializer = provider.findTypedValueSerializer(type, false, null);\n+        return new SerializerAndMapResult(serializer, newWith(type, serializer));\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public final SerializerAndMapResult findAndAddRootValueSerializer(JavaType type,\n+            SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<Object> serializer = provider.findTypedValueSerializer(type, false, null);\n+        return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));\n+    }\n+\n+    /**\n+     * Method that can be used to 'register' a serializer that caller has resolved\n+     * without help of this map.\n+     * \n+     * @since 2.5\n+     */\n+    public final SerializerAndMapResult addSerializer(Class<?> type, JsonSerializer<Object> serializer) {\n+        return new SerializerAndMapResult(serializer, newWith(type, serializer));\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public final SerializerAndMapResult addSerializer(JavaType type, JsonSerializer<Object> serializer) {\n+        return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));\n+    }\n+\n     public abstract PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer);\n-    \n+\n+    /**\n+     * @deprecated Since 2.5 Use {@link #emptyForProperties} instead\n+     */\n+    @Deprecated\n     public static PropertySerializerMap emptyMap() {\n-        return Empty.instance;\n-    }\n-    \n+        return emptyForProperties();\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public static PropertySerializerMap emptyForProperties() {\n+        return Empty.FOR_PROPERTIES;\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public static PropertySerializerMap emptyForRootValues() {\n+        return Empty.FOR_ROOT_VALUES;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper classes\n      */\n     private final static class Empty extends PropertySerializerMap\n     {\n-        protected final static Empty instance = new Empty();\n-\n+        // No root serializers; do not reset when full\n+        public final static Empty FOR_PROPERTIES = new Empty(false);\n+\n+        // Yes, root serializers; do reset when full\n+        public final static Empty FOR_ROOT_VALUES = new Empty(true);\n+\n+        protected Empty(boolean resetWhenFull) {\n+            super(resetWhenFull);\n+        }\n+        \n         @Override\n         public JsonSerializer<Object> serializerFor(Class<?> type) {\n             return null; // empty, nothing to find\n \n         @Override\n         public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) {\n-            return new Single(type, serializer);\n+            return new Single(this, type, serializer);\n         }\n     }\n \n         private final Class<?> _type;\n         private final JsonSerializer<Object> _serializer;\n \n-        public Single(Class<?> type, JsonSerializer<Object> serializer) {\n+        public Single(PropertySerializerMap base, Class<?> type, JsonSerializer<Object> serializer) {\n+            super(base);\n             _type = type;\n             _serializer = serializer;\n         }\n \n         @Override\n         public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) {\n-            return new Double(_type, _serializer, type, serializer);\n+            return new Double(this, _type, _serializer, type, serializer);\n         }\n     }\n \n         private final Class<?> _type1, _type2;\n         private final JsonSerializer<Object> _serializer1, _serializer2;\n \n-        public Double(Class<?> type1, JsonSerializer<Object> serializer1,\n+        public Double(PropertySerializerMap base,\n+                Class<?> type1, JsonSerializer<Object> serializer1,\n                 Class<?> type2, JsonSerializer<Object> serializer2)\n         {\n+            super(base);\n             _type1 = type1;\n             _serializer1 = serializer1;\n             _type2 = type2;\n         @Override\n         public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) {\n             // Ok: let's just create generic one\n-            TypeAndSerializer[] ts = new TypeAndSerializer[2];\n+            TypeAndSerializer[] ts = new TypeAndSerializer[3];\n             ts[0] = new TypeAndSerializer(_type1, _serializer1);\n             ts[1] = new TypeAndSerializer(_type2, _serializer2);\n-            return new Multi(ts);\n+            ts[2] = new TypeAndSerializer(type, serializer);\n+            return new Multi(this, ts);\n         }\n     }\n     \n         \n         private final TypeAndSerializer[] _entries;\n \n-        public Multi(TypeAndSerializer[] entries) {\n+        public Multi(PropertySerializerMap base, TypeAndSerializer[] entries) {\n+            super(base);\n             _entries = entries;\n         }\n \n         public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer)\n         {\n             int len = _entries.length;\n-            // Will only grow up to N entries\n+            // Will only grow up to N entries. We could consider couple of alternatives after\n+            // this if we wanted to... but for now, two main choices make most sense\n             if (len == MAX_ENTRIES) {\n+                if (_resetWhenFull) {\n+                    return new Single(this, type, serializer);\n+                }\n                 return this;\n             }\n-            // 1.6 has nice resize methods but we are still 1.5\n-            TypeAndSerializer[] entries = new TypeAndSerializer[len+1];\n-            System.arraycopy(_entries, 0, entries, 0, len);\n+            TypeAndSerializer[] entries = Arrays.copyOf(_entries, len+1);\n             entries[len] = new TypeAndSerializer(type, serializer);\n-            return new Multi(entries);\n+            return new Multi(this, entries);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n  * because it can provide default implementation for any methods that may\n  * be added in {@link PropertyFilter} (as unfortunate as additions may be).\n  */\n-public abstract class SimpleBeanPropertyFilter\n+public class SimpleBeanPropertyFilter\n     implements BeanPropertyFilter, PropertyFilter\n         // sub-classes must also implement java.io.Serializable\n {\n \n     protected SimpleBeanPropertyFilter() { }\n \n+    /**\n+     * Convenience factory method that will return a \"no-op\" filter that will\n+     * simply just serialize all properties that are given, and filter out\n+     * nothing.\n+     * \n+     * @since 2.5\n+     */\n+    public static SimpleBeanPropertyFilter serializeAll(Set<String> properties) {\n+        return new FilterExceptFilter(properties);\n+    }\n+    \n     /**\n      * Factory method to construct filter that filters out all properties <b>except</b>\n      * ones includes in set\n      * Method called to determine whether property will be included\n      * (if 'true' returned) or filtered out (if 'false' returned)\n      */\n-    protected abstract boolean include(BeanPropertyWriter writer);\n-\n-    /**\n+    protected boolean include(BeanPropertyWriter writer) {\n+        return true;\n+    }\n+\n+    /**\n+     * Method called to determine whether property will be included\n+     * (if 'true' returned) or filtered out (if 'false' returned)\n+     *\n      * @since 2.3\n      */\n-    protected abstract boolean include(PropertyWriter writer);\n-\n-    /**\n-     * Method that defines what to do with container elements;\n+    protected boolean include(PropertyWriter writer) {\n+        return true;\n+    }\n+\n+    /**\n+     * Method that defines what to do with container elements\n+     * (values contained in an array or {@link java.util.Collection}:\n      * default implementation simply writes them out.\n      * \n      * @since 2.3\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n  * Standard serializer used for <code>String[]</code> values.\n  */\n @JacksonStdImpl\n+@SuppressWarnings(\"serial\")\n public class StringArraySerializer\n     extends ArraySerializerBase<String[]>\n     implements ContextualSerializer\n     }\n     \n     @Override\n-    public boolean isEmpty(String[] value) {\n+    public boolean isEmpty(SerializerProvider prov, String[] value) {\n         return (value == null) || (value.length == 0);\n     }\n \n     /* Actual serialization\n     /**********************************************************\n      */\n+    \n+    @Override\n+    public final void serialize(String[] value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+    \tfinal int len = value.length;\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n     public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n  * String serializer.\n  */\n @JacksonStdImpl\n+@SuppressWarnings(\"serial\")\n public class StringCollectionSerializer\n     extends StaticListSerializerBase<Collection<String>>\n     implements ContextualSerializer\n         throws IOException, JsonGenerationException\n     {\n         // [JACKSON-805]\n-        if ((value.size() == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+    \tfinal int len = value.size();\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n             _serializeUnwrapped(value, jgen, provider);\n             return;\n         }      \n-        jgen.writeStartArray();\n+        jgen.writeStartArray(len);\n         if (_serializer == null) {\n             serializeContents(value, jgen, provider);\n         } else {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/TypeWrappedSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/TypeWrappedSerializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n \n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n     }\n \n     @Override\n-    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonProcessingException\n-    {\n+    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         _serializer.serializeWithType(value, jgen, provider, _typeSerializer);\n     }\n \n     @Override\n     public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonProcessingException\n+            TypeSerializer typeSer) throws IOException\n     {\n         /* Is this an erroneous call? For now, let's assume it is not, and\n          * that type serializer is just overridden if so\n     \n     @Override\n     public Class<Object> handledType() { return Object.class; }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API for other core classes\n+    /**********************************************************\n+     */\n+\n+    public JsonSerializer<Object> valueSerializer() {\n+        return _serializer;\n+    }\n+\n+    public TypeSerializer typeSerializer() {\n+        return _typeSerializer;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n+@SuppressWarnings(\"serial\")\n public class UnknownSerializer\n     extends StdSerializer<Object>\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n         }\n         if (_suppressableValue != null) {\n             if (MARKER_FOR_EMPTY == _suppressableValue) {\n-                if (ser.isEmpty(value)) {\n+                if (ser.isEmpty(prov, value)) {\n                     return;\n                 }\n             } else if (_suppressableValue.equals(value)) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n public class UnwrappingBeanSerializer\n     extends BeanSerializerBase\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /**\n      * Transformer used to add prefix and/or suffix for properties\n      * of unwrapped POJO.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.*;\n  * \n  * @param <T> Type of arrays serializer handles\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class ArraySerializerBase<T>\n     extends ContainerSerializer<T>\n {\n         super(src._handledType, false);\n         _property = property;\n     }\n-    \n+\n+    // NOTE: as of 2.5, sub-classes SHOULD override (in 2.4 and before, was final),\n+    // at least if they can provide access to actual size of value and use `writeStartArray()`\n+    // variant that passes size of array to output, which is helpful with some data formats\n     @Override\n-    public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serialize(T value, JsonGenerator gen, SerializerProvider provider) throws IOException\n     {\n-        // [JACKSON-805]\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(value)) {\n-            serializeContents(value, jgen, provider);\n+            serializeContents(value, gen, provider);\n             return;\n         }\n-        jgen.writeStartArray();\n-        serializeContents(value, jgen, provider);\n-        jgen.writeEndArray();\n+        gen.writeStartArray();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        gen.writeEndArray();\n+    }\n+\n+    @Override\n+    public final void serializeWithType(T value, JsonGenerator gen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException\n+    {\n+        // note: let's NOT consider [JACKSON-805] here; gets too complicated, and probably just won't work\n+        typeSer.writeTypePrefixForArray(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        typeSer.writeTypeSuffixForArray(value, gen);\n     }\n     \n-    @Override\n-    public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n-    {\n-        // note: let's NOT consider [JACKSON-805] here; gets too complicated, and probably just won't work\n-        typeSer.writeTypePrefixForArray(value, jgen);\n-        serializeContents(value, jgen, provider);\n-        typeSer.writeTypeSuffixForArray(value, jgen);\n-    }\n-\n     protected abstract void serializeContents(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Base class for serializers that will output contents as JSON\n  * arrays; typically serializers used for {@link java.util.Collection}\n  * and array types.\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class AsArraySerializerBase<T>\n     extends ContainerSerializer<T>\n     implements ContextualSerializer\n      * runtime type to serializer is handled using this object\n      */\n     protected PropertySerializerMap _dynamicSerializers;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n         _valueTypeSerializer = vts;\n         _property = property;\n         _elementSerializer = elementSerializer;\n-        _dynamicSerializers = PropertySerializerMap.emptyMap();\n+        _dynamicSerializers = PropertySerializerMap.emptyForProperties();\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     /* Serialization\n     /**********************************************************\n      */\n-    \n-    @Override\n-    public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n-        // [JACKSON-805]\n+\n+    // NOTE: as of 2.5, sub-classes SHOULD override (in 2.4 and before, was final),\n+    // at least if they can provide access to actual size of value and use `writeStartArray()`\n+    // variant that passes size of array to output, which is helpful with some data formats\n+    @Override\n+    public void serialize(T value, JsonGenerator gen, SerializerProvider provider) throws IOException\n+    {\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(value)) {\n-            serializeContents(value, jgen, provider);\n+            serializeContents(value, gen, provider);\n             return;\n         }\n-        jgen.writeStartArray();\n-        serializeContents(value, jgen, provider);\n-        jgen.writeEndArray();\n-    }\n-\n-    // Note: was 'final' modifier in 2.2 and before; no real need to be, removed\n-    @Override\n-    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        gen.writeStartArray();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        gen.writeEndArray();\n+    }\n+\n+    @Override\n+    public void serializeWithType(T value, JsonGenerator gen, SerializerProvider provider,\n+            TypeSerializer typeSer) throws IOException\n     {\n         // note: let's NOT consider [JACKSON-805] here; gets too complicated, and probably just won't work\n-        typeSer.writeTypePrefixForArray(value, jgen);\n-        serializeContents(value, jgen, provider);\n-        typeSer.writeTypeSuffixForArray(value, jgen);\n-    }\n-\n-    protected abstract void serializeContents(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException;\n+        typeSer.writeTypePrefixForArray(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        typeSer.writeTypeSuffixForArray(value, gen);\n+    }\n+\n+    protected abstract void serializeContents(T value, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException;\n \n     @SuppressWarnings(\"deprecation\")\n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n  * Can be used for custom bean serializers as well, although that\n  * is not the primary design goal.\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class BeanSerializerBase\n     extends StdSerializer<Object>\n     implements ContextualSerializer, ResolvableSerializer,\n      * reference to that member.\n      */\n     final protected AnnotatedMember _typeId;\n-    \n+\n     /**\n      * If this POJO can be alternatively serialized using just an object id\n      * to denote a reference to previously serialized object,\n      * Requested shape from bean class annotations.\n      */\n     final protected JsonFormat.Shape _serializationShape;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle: constructors\n     {\n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n         if (intr != null) {\n-            Object convDef = intr.findSerializationConverter(prop.getMember());\n-            if (convDef != null) {\n-                Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n-                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n-                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n-                return new StdDelegatingSerializer(conv, delegateType, ser);\n+            AnnotatedMember m = prop.getMember();\n+            if (m != null) {\n+                Object convDef = intr.findSerializationConverter(m);\n+                if (convDef != null) {\n+                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n+                    JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n+                    return new StdDelegatingSerializer(conv, delegateType, ser);\n+                }\n             }\n         }\n         return null;\n     }\n \n+    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n     {\n+        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+        final AnnotatedMember accessor = (property == null || intr == null)\n+                ? null : property.getMember();\n+        final SerializationConfig config = provider.getConfig();\n+        \n+        // Let's start with one big transmutation: Enums that are annotated\n+        // to serialize as Objects may want to revert\n+        JsonFormat.Shape shape = null;\n+        if (accessor != null) {\n+            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+\n+            if (format != null) {\n+                shape = format.getShape();\n+                // or, alternatively, asked to revert \"back to\" other representations...\n+                if (shape != _serializationShape) {\n+                    if (_handledType.isEnum()) {\n+                        switch (shape) {\n+                        case STRING:\n+                        case NUMBER:\n+                        case NUMBER_INT:\n+                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n+                            //   for now, just do class ones\n+                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n+                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType,\n+                                    provider.getConfig(), desc, format);\n+                            return provider.handlePrimaryContextualization(ser, property);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         ObjectIdWriter oiw = _objectIdWriter;\n         String[] ignorals = null;\n         Object newFilterId = null;\n-        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n-        final AnnotatedMember accessor = (property == null || intr == null)\n-                ? null : property.getMember();\n         \n-        // First: may have an override for Object Id:\n+        // Then we may have an override for Object Id\n         if (accessor != null) {\n             ignorals = intr.findPropertiesToIgnore(accessor);\n             ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n         if (newFilterId != null) {\n             contextual = contextual.withFilterId(newFilterId);\n         }\n-        \n-        // One more thing: are we asked to serialize POJO as array?\n-        JsonFormat.Shape shape = null;\n-        if (accessor != null) {\n-            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n-\n-            if (format != null) {\n-                shape = format.getShape();\n-            }\n-        }\n         if (shape == null) {\n             shape = _serializationShape;\n         }\n         if (shape == JsonFormat.Shape.ARRAY) {\n-            contextual = contextual.asArraySerializer();\n+            return contextual.asArraySerializer();\n         }\n         return contextual;\n     }\n     // Main serialization method left unimplemented\n     @Override\n     public abstract void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n \n     // Type-info-augmented case implemented as it does not usually differ between impls\n     @Override\n-    public void serializeWithType(Object bean, JsonGenerator jgen,\n+    public void serializeWithType(Object bean, JsonGenerator gen,\n             SerializerProvider provider, TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         if (_objectIdWriter != null) {\n-            _serializeWithObjectId(bean, jgen, provider, typeSer);\n+            _serializeWithObjectId(bean, gen, provider, typeSer);\n             return;\n         }\n \n-        String typeStr = (_typeId == null) ? null :_customTypeId(bean);\n+        String typeStr = (_typeId == null) ? null : _customTypeId(bean);\n         if (typeStr == null) {\n-            typeSer.writeTypePrefixForObject(bean, jgen);\n-        } else {\n-            typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr);\n+            typeSer.writeTypePrefixForObject(bean, gen);\n+        } else {\n+            typeSer.writeCustomTypePrefixForObject(bean, gen, typeStr);\n         }\n         if (_propertyFilterId != null) {\n-            serializeFieldsFiltered(bean, jgen, provider);\n-        } else {\n-            serializeFields(bean, jgen, provider);\n+            serializeFieldsFiltered(bean, gen, provider);\n+        } else {\n+            serializeFields(bean, gen, provider);\n         }\n         if (typeStr == null) {\n-            typeSer.writeTypeSuffixForObject(bean, jgen);\n-        } else {\n-            typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr);\n+            typeSer.writeTypeSuffixForObject(bean, gen);\n+        } else {\n+            typeSer.writeCustomTypeSuffixForObject(bean, gen, typeStr);\n         }\n     }\n \n         }\n     }\n     \n-    private final String _customTypeId(Object bean)\n+    protected final String _customTypeId(Object bean)\n     {\n         final Object typeId = _typeId.getValue(bean);\n         if (typeId == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BooleanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BooleanSerializer.java\n import java.io.IOException;\n import java.lang.reflect.Type;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n+\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonNode;\n public final class BooleanSerializer\n     extends NonTypedScalarSerializerBase<Boolean>\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /**\n      * Whether type serialized is primitive (boolean) or wrapper\n      * (java.lang.Boolean); if true, former, if false, latter.\n     }\n \n     @Override\n-    public void serialize(Boolean value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n+    public void serialize(Boolean value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         jgen.writeBoolean(value.booleanValue());\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteBufferSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteBufferSerializer.java\n import java.nio.ByteBuffer;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.util.ByteBufferBackedInputStream;\n \n+@SuppressWarnings(\"serial\")\n public class ByteBufferSerializer extends StdScalarSerializer<ByteBuffer>\n {\n     public ByteBufferSerializer() { super(ByteBuffer.class); }\n \n     @Override\n-    public void serialize(ByteBuffer bbuf, JsonGenerator gen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serialize(ByteBuffer bbuf, JsonGenerator gen, SerializerProvider provider) throws IOException\n     {\n         // first, simple case when wrapping an array...\n         if (bbuf.hasArray()) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n import java.util.Calendar;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n  * (standard Java 64-bit timestamp) or textual formats (usually ISO-8601).\n  */\n @JacksonStdImpl\n+@SuppressWarnings(\"serial\")\n public class CalendarSerializer\n     extends DateTimeSerializerBase<Calendar>\n {\n     }\n \n     @Override\n-    public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n         if (_asTimestamp(provider)) {\n             jgen.writeNumber(_timestamp(value));\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ClassSerializer.java\n  * Also: default bean access will not do much good with Class.class. But\n  * we can just serialize the class name and that should be enough.\n  */\n+@SuppressWarnings(\"serial\")\n public class ClassSerializer\n     extends StdScalarSerializer<Class<?>>\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n public class CollectionSerializer\n     extends AsArraySerializerBase<Collection<?>>\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n      */\n \n     @Override\n-    public boolean isEmpty(Collection<?> value) {\n+    public boolean isEmpty(SerializerProvider prov, Collection<?> value) {\n         return (value == null) || value.isEmpty();\n     }\n \n         it.next();\n         return !it.hasNext();\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Actual serialization\n     /**********************************************************\n      */\n+\n+    @Override\n+    public final void serialize(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+    \tfinal int len = value.size();\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n-    public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n         if (_elementSerializer != null) {\n             serializeContentsUsing(value, jgen, provider, _elementSerializer);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n  * potentially more readable Strings.\n  */\n @JacksonStdImpl\n+@SuppressWarnings(\"serial\")\n public class DateSerializer\n     extends DateTimeSerializerBase<Date>\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.util.StdDateFormat;\n \n+@SuppressWarnings(\"serial\")\n public abstract class DateTimeSerializerBase<T>\n     extends StdScalarSerializer<T>\n     implements ContextualSerializer\n         //todo: (ryan) add a format for the date in the schema?\n         return createSchemaNode(_asTimestamp(provider) ? \"number\" : \"string\", true);\n     }\n-    \n+\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n  * and if not, it can only be gotten from actual instance.\n  * \n  * @deprecated Since 2.4.4; standard {@link MapSerializer} works better.\n+ *   (to be removed from 2.6)\n  */\n+@SuppressWarnings(\"serial\")\n @JacksonStdImpl\n @Deprecated\n public class EnumMapSerializer\n     }\n     \n     @Override\n-    public boolean isEmpty(EnumMap<? extends Enum<?>,?> value) {\n+    public boolean isEmpty(SerializerProvider prov, EnumMap<? extends Enum<?>,?> value) {\n         return (value == null) || value.isEmpty();\n     }\n \n         }\n     }\n     \n-    @SuppressWarnings({ \"unchecked\", \"deprecation\" })\n+    @SuppressWarnings({ \"unchecked\" })\n     @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n     extends StdScalarSerializer<Enum<?>>\n     implements ContextualSerializer\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /**\n      * This map contains pre-resolved values (since there are ways\n      * to customize actual String constants to use) to use as\n      * \n      * @since 2.1\n      */\n-    public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config,\n+    @SuppressWarnings(\"unchecked\")\n+    public static EnumSerializer construct(Class<?> enumClass, SerializationConfig config,\n             BeanDescription beanDesc, JsonFormat.Value format)\n     {\n         // [JACKSON-212]: If toString() is to be used instead, leave EnumValues null\n-        EnumValues v = EnumValues.construct(config, enumClass);\n+        EnumValues v = EnumValues.construct(config, (Class<Enum<?>>) enumClass);\n         Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);\n         return new EnumSerializer(v, serializeAsIndex);\n     }\n     \n     @Override\n     public final void serialize(Enum<?> en, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         // [JACKSON-684]: serialize as index?\n         if (_serializeAsIndex(provider)) {\n         if (shape == Shape.STRING) {\n             return Boolean.FALSE;\n         }\n-        if (shape.isNumeric()) {\n+        // 01-Oct-2014, tatu: For convenience, consider \"as-array\" to also mean 'yes, use index')\n+        if (shape.isNumeric() || (shape == Shape.ARRAY)) {\n             return Boolean.TRUE;\n         }\n         throw new IllegalArgumentException(\"Unsupported serialization shape (\"+shape+\") for Enum \"+enumClass.getName()\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.util.EnumSet;\n+import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n+@SuppressWarnings(\"serial\")\n public class EnumSetSerializer\n     extends AsArraySerializerBase<EnumSet<? extends Enum<?>>>\n {\n     }\n     \n     @Override\n-    public boolean isEmpty(EnumSet<? extends Enum<?>> value) {\n+    public boolean isEmpty(SerializerProvider prov, EnumSet<? extends Enum<?>> value) {\n         return (value == null) || value.isEmpty();\n     }\n \n     @Override\n     public boolean hasSingleElement(EnumSet<? extends Enum<?>> value) {\n         return value.size() == 1;\n+    }\n+\n+    @Override\n+    public final void serialize(EnumSet<? extends Enum<?>> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+    \tfinal int len = value.size();\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/FileSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/FileSerializer.java\n import java.io.IOException;\n import java.lang.reflect.Type;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n  * For now, File objects get serialized by just outputting\n  * absolute (but not canonical) name as String value\n  */\n+@SuppressWarnings(\"serial\")\n public class FileSerializer\n     extends StdScalarSerializer<File>\n {\n     public FileSerializer() { super(File.class); }\n \n     @Override\n-    public void serialize(File value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void serialize(File value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         jgen.writeString(value.getAbsolutePath());\n     }\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-    {\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n         return createSchemaNode(\"string\", true);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/InetAddressSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/InetAddressSerializer.java\n import java.net.InetAddress;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n  * Simple serializer for {@link java.net.InetAddress}. Main complexity is\n  * with registration, since same serializer is to be used for sub-classes.\n  */\n+@SuppressWarnings(\"serial\")\n public class InetAddressSerializer\n     extends StdScalarSerializer<InetAddress>\n {\n     public InetAddressSerializer() { super(InetAddress.class); }\n \n     @Override\n-    public void serialize(InetAddress value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serialize(InetAddress value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n         // Ok: get textual description; choose \"more specific\" part\n         String str = value.toString().trim();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/InetSocketAddressSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/InetSocketAddressSerializer.java\n /**\n  * Simple serializer for {@link InetSocketAddress}.\n  */\n+@SuppressWarnings(\"serial\")\n public class InetSocketAddressSerializer\n     extends StdScalarSerializer<InetSocketAddress>\n {\n     public InetSocketAddressSerializer() { super(InetSocketAddress.class); }\n \n     @Override\n-    public void serialize(InetSocketAddress value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException\n+    public void serialize(InetSocketAddress value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n         InetAddress addr = value.getAddress();\n         String str = addr == null ? value.getHostName() : addr.toString().trim();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.util.Iterator;\n+import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n \n @JacksonStdImpl\n+@SuppressWarnings(\"serial\")\n public class IterableSerializer\n     extends AsArraySerializerBase<Iterable<?>>\n {\n     }\n     \n     @Override\n-    public boolean isEmpty(Iterable<?> value) {\n+    public boolean isEmpty(SerializerProvider prov, Iterable<?> value) {\n         // Not really good way to implement this, but has to do for now:\n         return (value == null) || !value.iterator().hasNext();\n     }\n             }\n         }\n         return false;\n+    }\n+\n+    @Override\n+    public final void serialize(Iterable<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+        if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray();\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n  *  This must be done from {@link #createContextual} method, and NOT from constructor;\n  * otherwise we could end up with an infinite loop.\n  */\n+@SuppressWarnings(\"serial\")\n @JacksonStdImpl\n public class JsonValueSerializer\n     extends StdSerializer<Object>\n      *    {@link com.fasterxml.jackson.databind.annotation.JsonSerialize#using}), otherwise\n      *    null\n      */\n-    public JsonValueSerializer(Method valueMethod, JsonSerializer<Object> ser)\n-    {\n-        super(Object.class);\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonValueSerializer(Method valueMethod, JsonSerializer<?> ser)\n+    {\n+        super(valueMethod.getReturnType(), false);\n         _accessorMethod = valueMethod;\n-        _valueSerializer = ser;\n+        _valueSerializer = (JsonSerializer<Object>) ser;\n         _property = null;\n         _forceTypeInformation = true; // gets reconsidered when we are contextualized\n     }\n                  *   to serializer factory at this point... \n                  */\n                 // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-                ser = provider.findPrimaryPropertySerializer(t, _property);\n+                ser = provider.findPrimaryPropertySerializer(t, property);\n                 /* 09-Dec-2010, tatu: Turns out we must add special handling for\n                  *   cases where \"native\" (aka \"natural\") type is being serialized,\n                  *   using standard serializer\n      */\n     \n     @Override\n-    public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov)\n-        throws IOException, JsonGenerationException\n+    public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov) throws IOException\n     {\n         try {\n             Object value = _accessorMethod.invoke(bean);\n \n     @Override\n     public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer0)\n-        throws IOException, JsonProcessingException\n+            TypeSerializer typeSer0) throws IOException\n     {\n         // Regardless of other parts, first need to find value to serialize:\n         Object value = null;\n      */\n \n     @Override\n-    public String toString()\n-    {\n+    public String toString() {\n         return \"(@JsonValue serializer for method \" + _accessorMethod.getDeclaringClass() + \"#\" + _accessorMethod.getName() + \")\";\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.annotation.Annotation;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.PropertyName;\n  */\n public class MapProperty extends PropertyWriter\n {\n-    protected TypeSerializer _typeSerializer;\n-    \n-    protected Object _key, _value;\n+    protected final TypeSerializer _typeSerializer;\n+\n+    protected final BeanProperty _property;\n+\n+    protected Object _key;\n \n     protected JsonSerializer<Object> _keySerializer, _valueSerializer;\n \n-    public MapProperty(TypeSerializer typeSer)\n+    /**\n+     * @deprecated since 2.4\n+     */\n+    @Deprecated // since 2.4\n+    public MapProperty(TypeSerializer typeSer) {\n+        this(typeSer, null);\n+    }\n+    \n+    public MapProperty(TypeSerializer typeSer, BeanProperty prop)\n     {\n         _typeSerializer = typeSer;\n+        _property = prop;\n+    }\n+\n+    /**\n+     * Deprecated method with wrong signature; value should not be assigned\n+     * to property, should be passed via proper call-through methods.\n+     * \n+     * @deprecated Since 2.5, remove in 2.6\n+     */\n+    @Deprecated // since 2.5\n+    public void reset(Object key, Object value,\n+            JsonSerializer<Object> keySer, JsonSerializer<Object> valueSer) {\n+        reset(key, keySer, valueSer);\n     }\n     \n     /**\n      * Initialization method that needs to be called before passing\n      * property to filter.\n      */\n-    public void reset(Object key, Object value,\n+    public void reset(Object key,\n             JsonSerializer<Object> keySer, JsonSerializer<Object> valueSer)\n     {\n         _key = key;\n-        _value = value;\n         _keySerializer = keySer;\n         _valueSerializer = valueSer;\n     }\n     }\n \n     @Override\n-    public void serializeAsField(Object pojo, JsonGenerator jgen,\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+        return (_property == null) ? null : _property.getAnnotation(acls);\n+    }\n+\n+    @Override\n+    public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n+        return (_property == null) ? null : _property.getContextAnnotation(acls);\n+    }\n+    \n+    @Override\n+    public void serializeAsField(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws IOException\n     {\n         _keySerializer.serialize(_key, jgen, provider);\n         if (_typeSerializer == null) {\n-            _valueSerializer.serialize(_value, jgen, provider);\n+            _valueSerializer.serialize(value, jgen, provider);\n         } else {\n-            _valueSerializer.serializeWithType(_value, jgen, provider, _typeSerializer);\n+            _valueSerializer.serializeWithType(value, jgen, provider, _typeSerializer);\n         }\n     }\n \n     @Override\n-    public void serializeAsOmittedField(Object pojo, JsonGenerator jgen,\n+    public void serializeAsOmittedField(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws Exception\n     {\n         if (!jgen.canOmitFields()) {\n     }\n \n     @Override\n-    public void serializeAsElement(Object pojo, JsonGenerator jgen,\n+    public void serializeAsElement(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws Exception\n     {\n         if (_typeSerializer == null) {\n-            _valueSerializer.serialize(_value, jgen, provider);\n+            _valueSerializer.serialize(value, jgen, provider);\n         } else {\n-            _valueSerializer.serializeWithType(_value, jgen, provider, _typeSerializer);\n+            _valueSerializer.serializeWithType(value, jgen, provider, _typeSerializer);\n         }\n     }\n     \n     @Override\n-    public void serializeAsPlaceholder(Object pojo, JsonGenerator jgen,\n+    public void serializeAsPlaceholder(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws Exception\n     {\n         jgen.writeNull();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n import java.lang.reflect.Type;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.ser.PropertyFilter;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.ArrayBuilders;\n \n /**\n  * Standard serializer implementation for serializing {link java.util.Map} types.\n     extends ContainerSerializer<Map<?,?>>\n     implements ContextualSerializer\n {\n+    private static final long serialVersionUID = -3465193297149553004L;\n+\n     protected final static JavaType UNSPECIFIED_TYPE = TypeFactory.unknownType();\n \n     /**\n      */\n     protected final boolean _sortKeys;\n \n+    /**\n+     * Value that indicates suppression mechanism to use; either one of\n+     * values of {@link com.fasterxml.jackson.annotation.JsonInclude.Include}, or actual object to compare\n+     * against (\"default value\")\n+     * \n+     * @since 2.5\n+     */\n+    protected final Object _suppressableValue;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n     /**********************************************************\n      */\n     \n+    /**\n+     * @since 2.5\n+     */\n     @SuppressWarnings(\"unchecked\")\n     protected MapSerializer(HashSet<String> ignoredEntries,\n             JavaType keyType, JavaType valueType, boolean valueTypeIsStatic,\n         _valueTypeSerializer = vts;\n         _keySerializer = (JsonSerializer<Object>) keySerializer;\n         _valueSerializer = (JsonSerializer<Object>) valueSerializer;\n-        _dynamicValueSerializers = PropertySerializerMap.emptyMap();\n+        _dynamicValueSerializers = PropertySerializerMap.emptyForProperties();\n         _property = null;\n         _filterId = null;\n         _sortKeys = false;\n-    }\n-\n+        _suppressableValue = null;\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected void _ensureOverride() {\n+        if (getClass() != MapSerializer.class) {\n+            throw new IllegalStateException(\"Missing override in class \"+getClass().getName());\n+        }\n+    }\n+    \n     @SuppressWarnings(\"unchecked\")\n     protected MapSerializer(MapSerializer src, BeanProperty property,\n             JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer,\n         _property = property;\n         _filterId = src._filterId;\n         _sortKeys = src._sortKeys;\n-    }\n-\n-    protected MapSerializer(MapSerializer src, TypeSerializer vts)\n+        _suppressableValue = src._suppressableValue;\n+    }\n+\n+    @Deprecated // since 2.5\n+    protected MapSerializer(MapSerializer src, TypeSerializer vts) {\n+        this(src, vts, src._suppressableValue);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected MapSerializer(MapSerializer src, TypeSerializer vts,\n+            Object suppressableValue)\n     {\n         super(Map.class, false);\n         _ignoredEntries = src._ignoredEntries;\n         _property = src._property;\n         _filterId = src._filterId;\n         _sortKeys = src._sortKeys;\n+        _suppressableValue = suppressableValue;\n     }\n \n     protected MapSerializer(MapSerializer src, Object filterId, boolean sortKeys)\n         _property = src._property;\n         _filterId = filterId;\n         _sortKeys = sortKeys;\n-    }\n-    \n+        _suppressableValue = src._suppressableValue;\n+    }\n+\n     @Override\n     public MapSerializer _withValueTypeSerializer(TypeSerializer vts) {\n-        return new MapSerializer(this, vts);\n-    }\n-\n-    @Deprecated // since 2.3\n-    public MapSerializer withResolved(BeanProperty property,\n-            JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored) {\n-        return withResolved(property, keySerializer, valueSerializer, ignored, _sortKeys);\n+        if (_valueTypeSerializer == vts) {\n+            return this;\n+        }\n+        _ensureOverride();\n+        return new MapSerializer(this, vts, null);\n     }\n \n     /**\n             JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer,\n             HashSet<String> ignored, boolean sortKeys)\n     {\n+        _ensureOverride();\n         MapSerializer ser = new MapSerializer(this, property, keySerializer, valueSerializer, ignored);\n         if (sortKeys != ser._sortKeys) {\n             ser = new MapSerializer(ser, _filterId, sortKeys);\n         }\n         return ser;\n     }\n-    \n+\n     /**\n      * @since 2.3\n      */\n     public MapSerializer withFilterId(Object filterId) {\n-        return (_filterId == filterId) ? this : new MapSerializer(this, filterId, _sortKeys);\n-    }\n-\n-    /**\n-     * @deprecated Since 2.3 use the method that takes `filterId`\n-     */\n-    @Deprecated\n-    public static MapSerializer construct(String[] ignoredList, JavaType mapType,\n-            boolean staticValueType, TypeSerializer vts,\n-            JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer)\n-    {\n-        return construct(ignoredList, mapType, staticValueType, vts,\n-                keySerializer, valueSerializer, null);\n-    }\n-\n+        if (_filterId == filterId) {\n+            return this;\n+        }\n+        _ensureOverride();\n+        return new MapSerializer(this, filterId, _sortKeys);\n+    }\n+\n+    /**\n+     * Mutant factory for constructing an instance with different inclusion strategy\n+     * for content (Map values).\n+     * \n+     * @since 2.5\n+     */\n+    public MapSerializer withContentInclusion(Object suppressableValue) {\n+        if (suppressableValue == _suppressableValue) {\n+            return this;\n+        }\n+        _ensureOverride();\n+        return new MapSerializer(this, _valueTypeSerializer, suppressableValue);\n+    }                \n+    \n     /**\n      * @since 2.3\n      */\n             JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer,\n             Object filterId)\n     {\n-        HashSet<String> ignoredEntries = toSet(ignoredList);\n+        HashSet<String> ignoredEntries = (ignoredList == null || ignoredList.length == 0)\n+                ? null : ArrayBuilders.arrayToSet(ignoredList);\n+\n         JavaType keyType, valueType;\n         \n         if (mapType == null) {\n             ser = ser.withFilterId(filterId);\n         }\n         return ser;\n-    }\n-\n-    private static HashSet<String> toSet(String[] ignoredEntries) {\n-        if (ignoredEntries == null || ignoredEntries.length == 0) {\n-            return null;\n-        }\n-        HashSet<String> result = new HashSet<String>(ignoredEntries.length);\n-        for (String prop : ignoredEntries) {\n-            result.add(prop);\n-        }\n-        return result;\n     }\n \n     /*\n         JsonSerializer<?> keySer = null;\n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n         final AnnotatedMember propertyAcc = (property == null) ? null : property.getMember();\n+        Object suppressableValue = _suppressableValue;\n \n         // First: if we have a property, may have property-annotation overrides\n         if (propertyAcc != null && intr != null) {\n             serDef = intr.findContentSerializer(propertyAcc);\n             if (serDef != null) {\n                 ser = provider.serializerInstance(propertyAcc, serDef);\n+            }\n+            JsonInclude.Include incl = intr.findSerializationInclusionForContent(propertyAcc, null);\n+            if (incl != null) {\n+                suppressableValue = incl;\n             }\n         }\n         if (ser == null) {\n             sortKeys = (b != null) && b.booleanValue();\n         }\n         MapSerializer mser = withResolved(property, keySer, ser, ignored, sortKeys);\n+        if (suppressableValue != _suppressableValue) {\n+            mser = mser.withContentInclusion(suppressableValue);\n+        }\n \n         // [Issue#307]: allow filtering\n         if (property != null) {\n-            Object filterId = intr.findFilterId(property.getMember());\n-            if (filterId != null) {\n-                mser = mser.withFilterId(filterId);\n+            AnnotatedMember m = property.getMember();\n+            if (m != null) {\n+                Object filterId = intr.findFilterId(m);\n+                if (filterId != null) {\n+                    mser = mser.withFilterId(filterId);\n+                }\n             }\n         }\n         return mser;\n     }\n     \n     @Override\n-    public boolean isEmpty(Map<?,?> value) {\n+    public boolean isEmpty(SerializerProvider prov, Map<?,?> value) {\n         return (value == null) || value.isEmpty();\n     }\n \n     /* JsonSerializer implementation\n     /**********************************************************\n      */\n-    \n-    @Override\n-    public void serialize(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n-        jgen.writeStartObject();\n+\n+    @Override\n+    public void serialize(Map<?,?> value, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n+    {\n+        gen.writeStartObject();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (!value.isEmpty()) {\n-            if (_filterId != null) {\n-                serializeFilteredFields(value, jgen, provider,\n-                        findPropertyFilter(provider, _filterId, value));\n-                jgen.writeEndObject();\n-                return;\n+            Object suppressableValue = _suppressableValue;\n+            if (suppressableValue == null) {\n+                if (!provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)) {\n+                    suppressableValue = JsonInclude.Include.NON_NULL;\n+                }\n+            } else if (suppressableValue == JsonInclude.Include.ALWAYS) {\n+                suppressableValue = null;\n             }\n             if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n                 value = _orderEntries(value);\n             }\n-            if (_valueSerializer != null) {\n-                serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n-            } else {\n-                serializeFields(value, jgen, provider);\n-            }\n-        }\n-        jgen.writeEndObject();\n-    }\n-\n-    @Override\n-    public void serializeWithType(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+            if (_filterId != null) {\n+                serializeFilteredFields(value, gen, provider,\n+                        findPropertyFilter(provider, _filterId, value), suppressableValue);\n+            } else if (suppressableValue != null) {\n+                serializeOptionalFields(value, gen, provider, suppressableValue);\n+            } else if (_valueSerializer != null) {\n+                serializeFieldsUsing(value, gen, provider, _valueSerializer);\n+            } else {\n+                serializeFields(value, gen, provider);\n+            }\n+        }\n+        gen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n-    {\n-        typeSer.writeTypePrefixForObject(value, jgen);\n+        throws IOException\n+    {\n+        typeSer.writeTypePrefixForObject(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (!value.isEmpty()) {\n+            Object suppressableValue = _suppressableValue;\n+            if (suppressableValue == null) {\n+                if (!provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)) {\n+                    suppressableValue = JsonInclude.Include.NON_NULL;\n+                }\n+            } else if (suppressableValue == JsonInclude.Include.ALWAYS) {\n+                suppressableValue = null;\n+            }\n             if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n                 value = _orderEntries(value);\n             }\n-            if (_valueSerializer != null) {\n-                serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n-            } else {\n-                serializeFields(value, jgen, provider);\n-            }\n-        }\n-        typeSer.writeTypeSuffixForObject(value, jgen);\n+            if (_filterId != null) {\n+                serializeFilteredFields(value, gen, provider,\n+                        findPropertyFilter(provider, _filterId, value), suppressableValue);\n+            } else if (suppressableValue != null) {\n+                serializeOptionalFields(value, gen, provider, suppressableValue);\n+            } else if (_valueSerializer != null) {\n+                serializeFieldsUsing(value, gen, provider, _valueSerializer);\n+            } else {\n+                serializeFields(value, gen, provider);\n+            }\n+        }\n+        typeSer.writeTypeSuffixForObject(value, gen);\n     }\n \n     /*\n      */\n     \n     /**\n-     * Method called to serialize fields, when the value type is not statically known.\n-     */\n-    public void serializeFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+     * Method called to serialize fields, when the value type is not statically known;\n+     * but we know that no value suppression is needed (which simplifies processing a bit)\n+     */\n+    public void serializeFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         // If value type needs polymorphic type handling, some more work needed:\n         if (_valueTypeSerializer != null) {\n-            serializeTypedFields(value, jgen, provider);\n+            serializeTypedFields(value, gen, provider, null);\n             return;\n         }\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n-        \n         final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         PropertySerializerMap serializers = _dynamicValueSerializers;\n \n             // First, serialize key\n             Object keyElem = entry.getKey();\n             if (keyElem == null) {\n-                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n-            } else {\n-                // [JACKSON-314] skip entries with null values?\n-                if (skipNulls && valueElem == null) continue;\n+                provider.findNullKeySerializer(_keyType, _property).serialize(null, gen, provider);\n+            } else {\n                 // One twist: is entry ignorable? If so, skip\n                 if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySerializer.serialize(keyElem, jgen, provider);\n+                keySerializer.serialize(keyElem, gen, provider);\n             }\n \n             // And then value\n             if (valueElem == null) {\n-                provider.defaultSerializeNull(jgen);\n+                provider.defaultSerializeNull(gen);\n             } else {\n                 Class<?> cc = valueElem.getClass();\n                 JsonSerializer<Object> serializer = serializers.serializerFor(cc);\n                     serializers = _dynamicValueSerializers;\n                 }\n                 try {\n-                    serializer.serialize(valueElem, jgen, provider);\n+                    serializer.serialize(valueElem, gen, provider);\n                 } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n+                    // Add reference information\n                     String keyDesc = \"\"+keyElem;\n                     wrapAndThrow(provider, e, value, keyDesc);\n                 }\n         }\n     }\n \n+    public void serializeOptionalFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n+            Object suppressableValue)\n+        throws IOException\n+    {\n+        // If value type needs polymorphic type handling, some more work needed:\n+        if (_valueTypeSerializer != null) {\n+            serializeTypedFields(value, gen, provider, suppressableValue);\n+            return;\n+        }\n+        final HashSet<String> ignored = _ignoredEntries;\n+        PropertySerializerMap serializers = _dynamicValueSerializers;\n+\n+        for (Map.Entry<?,?> entry : value.entrySet()) {\n+            // First find key serializer\n+            final Object keyElem = entry.getKey();\n+            JsonSerializer<Object> keySerializer;\n+            if (keyElem == null) {\n+                keySerializer = provider.findNullKeySerializer(_keyType, _property);\n+            } else {\n+                if (ignored != null && ignored.contains(keyElem)) continue;\n+                keySerializer = _keySerializer;\n+            }\n+\n+            // Then value serializer\n+            final Object valueElem = entry.getValue();\n+            JsonSerializer<Object> valueSer;\n+            if (valueElem == null) {\n+                if (suppressableValue != null) { // all suppressions include null-suppression\n+                    continue;\n+                }\n+                valueSer = provider.getDefaultNullValueSerializer();\n+            } else {\n+                valueSer = _valueSerializer;\n+                if (valueSer == null) {\n+                    Class<?> cc = valueElem.getClass();\n+                    valueSer = serializers.serializerFor(cc);\n+                    if (valueSer == null) {\n+                        if (_valueType.hasGenericTypes()) {\n+                            valueSer = _findAndAddDynamic(serializers,\n+                                    provider.constructSpecializedType(_valueType, cc), provider);\n+                        } else {\n+                            valueSer = _findAndAddDynamic(serializers, cc, provider);\n+                        }\n+                        serializers = _dynamicValueSerializers;\n+                    }\n+                }\n+                // also may need to skip non-empty values:\n+                if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n+                        && valueSer.isEmpty(provider, valueElem)) {\n+                    continue;\n+                }\n+            }\n+            // and then serialize, if all went well\n+            try {\n+                keySerializer.serialize(keyElem, gen, provider);\n+                valueSer.serialize(valueElem, gen, provider);\n+            } catch (Exception e) {\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+    \n     /**\n      * Method called to serialize fields, when the value type is statically known,\n      * so that value serializer is passed and does not need to be fetched from\n      * provider.\n      */\n-    protected void serializeFieldsUsing(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+    protected void serializeFieldsUsing(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n             JsonSerializer<Object> ser)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n         final HashSet<String> ignored = _ignoredEntries;\n         final TypeSerializer typeSer = _valueTypeSerializer;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n-            Object valueElem = entry.getValue();\n             Object keyElem = entry.getKey();\n+            if (ignored != null && ignored.contains(keyElem)) continue;\n+\n             if (keyElem == null) {\n-                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n-            } else {\n-                // [JACKSON-314] also may need to skip entries with null values\n-                if (skipNulls && valueElem == null) continue;\n-                if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySerializer.serialize(keyElem, jgen, provider);\n-            }\n+                provider.findNullKeySerializer(_keyType, _property).serialize(null, gen, provider);\n+            } else {\n+                keySerializer.serialize(keyElem, gen, provider);\n+            }\n+            final Object valueElem = entry.getValue();\n             if (valueElem == null) {\n-                provider.defaultSerializeNull(jgen);\n+                provider.defaultSerializeNull(gen);\n             } else {\n                 try {\n                     if (typeSer == null) {\n-                        ser.serialize(valueElem, jgen, provider);\n+                        ser.serialize(valueElem, gen, provider);\n                     } else {\n-                        ser.serializeWithType(valueElem, jgen, provider, typeSer);\n+                        ser.serializeWithType(valueElem, gen, provider, typeSer);\n                     }\n                 } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n                     String keyDesc = \"\"+keyElem;\n                     wrapAndThrow(provider, e, value, keyDesc);\n                 }\n     /**\n      * Helper method used when we have a JSON Filter to use for potentially\n      * filtering out Map entries.\n-     *<p>\n-     * NOTE: initially only called externally, by <code>AnyGetterWriter</code>\n      * \n-     * @since 2.3\n-     */\n-    public void serializeFilteredFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n-            PropertyFilter filter)\n-        throws IOException, JsonGenerationException\n+     * @since 2.5\n+     */\n+    public void serializeFilteredFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n+            PropertyFilter filter,\n+            Object suppressableValue) // since 2.5\n+        throws IOException\n     {\n         final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         PropertySerializerMap serializers = _dynamicValueSerializers;\n-        final MapProperty prop = new MapProperty(_valueTypeSerializer);\n+        final MapProperty prop = new MapProperty(_valueTypeSerializer, _property);\n \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n-            // First, serialize key\n+            // First, serialize key; unless ignorable by key\n             final Object keyElem = entry.getKey();\n+            if (ignored != null && ignored.contains(keyElem)) continue;\n+\n+            JsonSerializer<Object> keySerializer;\n+            if (keyElem == null) {\n+                keySerializer = provider.findNullKeySerializer(_keyType, _property);\n+            } else {\n+                keySerializer = _keySerializer;\n+            }\n+            // or by value; nulls often suppressed\n             final Object valueElem = entry.getValue();\n-            JsonSerializer<Object> keySer;\n-            if (keyElem == null) {\n-                keySer = provider.findNullKeySerializer(_keyType, _property);\n-            } else {\n-                // [JACKSON-314] skip entries with null values?\n-                if (skipNulls && valueElem == null) continue;\n-                // One twist: is entry ignorable? If so, skip\n-                if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySer = _keySerializer;\n-            }\n+\n             JsonSerializer<Object> valueSer;\n             // And then value\n             if (valueElem == null) {\n+                if (suppressableValue != null) { // all suppressions include null-suppression\n+                    continue;\n+                }\n                 valueSer = provider.getDefaultNullValueSerializer();\n             } else {\n+                valueSer = _valueSerializer;\n+                if (valueSer == null) {\n+                    Class<?> cc = valueElem.getClass();\n+                    valueSer = serializers.serializerFor(cc);\n+                    if (valueSer == null) {\n+                        if (_valueType.hasGenericTypes()) {\n+                            valueSer = _findAndAddDynamic(serializers,\n+                                    provider.constructSpecializedType(_valueType, cc), provider);\n+                        } else {\n+                            valueSer = _findAndAddDynamic(serializers, cc, provider);\n+                        }\n+                        serializers = _dynamicValueSerializers;\n+                    }\n+                }\n+                // also may need to skip non-empty values:\n+                if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n+                        && valueSer.isEmpty(provider, valueElem)) {\n+                    continue;\n+                }\n+            }\n+            // and with that, ask filter to handle it\n+            prop.reset(keyElem, keySerializer, valueSer);\n+            try {\n+                filter.serializeAsField(valueElem, gen, provider, prop);\n+            } catch (Exception e) {\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+\n+    @Deprecated // since 2.5\n+    public void serializeFilteredFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n+            PropertyFilter filter) throws IOException {\n+        serializeFilteredFields(value, gen, provider, filter,\n+                provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES) ? null : JsonInclude.Include.NON_NULL);\n+    }\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    protected void serializeTypedFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n+            Object suppressableValue) // since 2.5\n+        throws IOException\n+    {\n+        final HashSet<String> ignored = _ignoredEntries;\n+        PropertySerializerMap serializers = _dynamicValueSerializers;\n+\n+        for (Map.Entry<?,?> entry : value.entrySet()) {\n+            Object keyElem = entry.getKey();\n+            JsonSerializer<Object> keySerializer;\n+            if (keyElem == null) {\n+                keySerializer = provider.findNullKeySerializer(_keyType, _property);\n+            } else {\n+                // One twist: is entry ignorable? If so, skip\n+                if (ignored != null && ignored.contains(keyElem)) continue;\n+                keySerializer = _keySerializer;\n+            }\n+            final Object valueElem = entry.getValue();\n+    \n+            // And then value\n+            JsonSerializer<Object> valueSer;\n+            if (valueElem == null) {\n+                if (suppressableValue != null) { // all suppression include null suppression\n+                    continue;\n+                }\n+                valueSer = provider.getDefaultNullValueSerializer();\n+                keySerializer.serialize(keyElem, gen, provider);\n+                provider.defaultSerializeNull(gen);\n+            } else {\n+                valueSer = _valueSerializer;\n                 Class<?> cc = valueElem.getClass();\n                 valueSer = serializers.serializerFor(cc);\n                 if (valueSer == null) {\n                     }\n                     serializers = _dynamicValueSerializers;\n                 }\n-            }\n-            prop.reset(keyElem, valueElem, keySer, valueSer);\n+                // also may need to skip non-empty values:\n+                if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n+                        && valueSer.isEmpty(provider, valueElem)) {\n+                    continue;\n+                }\n+            }\n+            keySerializer.serialize(keyElem, gen, provider);\n             try {\n-                filter.serializeAsField(value, jgen, provider, prop);\n+                valueSer.serializeWithType(valueElem, gen, provider, _valueTypeSerializer);\n             } catch (Exception e) {\n-                // [JACKSON-55] Need to add reference information\n                 String keyDesc = \"\"+keyElem;\n                 wrapAndThrow(provider, e, value, keyDesc);\n             }\n         }\n     }\n-    \n-    protected void serializeTypedFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n-        final JsonSerializer<Object> keySerializer = _keySerializer;\n-        JsonSerializer<Object> prevValueSerializer = null;\n-        Class<?> prevValueClass = null;\n-        final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n-    \n-        for (Map.Entry<?,?> entry : value.entrySet()) {\n-            Object valueElem = entry.getValue();\n-            // First, serialize key\n-            Object keyElem = entry.getKey();\n-            if (keyElem == null) {\n-                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n-            } else {\n-                // [JACKSON-314] also may need to skip entries with null values\n-                if (skipNulls && valueElem == null) continue;\n-                // One twist: is entry ignorable? If so, skip\n-                if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySerializer.serialize(keyElem, jgen, provider);\n-            }\n-    \n-            // And then value\n-            if (valueElem == null) {\n-                provider.defaultSerializeNull(jgen);\n-            } else {\n-                Class<?> cc = valueElem.getClass();\n-                JsonSerializer<Object> currSerializer;\n-                if (cc == prevValueClass) {\n-                    currSerializer = prevValueSerializer;\n-                } else {\n-                    if (_valueType.hasGenericTypes()) {\n-                        currSerializer = provider.findValueSerializer(provider.constructSpecializedType(_valueType, cc), _property);\n-                    } else {\n-                        currSerializer = provider.findValueSerializer(cc, _property);\n-                    }\n-                    prevValueSerializer = currSerializer;\n-                    prevValueClass = cc;\n-                }\n-                try {\n-                    currSerializer.serializeWithType(valueElem, jgen, provider, _valueTypeSerializer);\n-                } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n-                    String keyDesc = \"\"+keyElem;\n-                    wrapAndThrow(provider, e, value, keyDesc);\n-                }\n-            }\n-        }\n-    }\n+\n+    @Deprecated // since 2.5\n+    protected void serializeTypedFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException {\n+        serializeTypedFields(value, gen, provider,\n+                provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES) ? null : JsonInclude.Include.NON_NULL);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Schema related functionality\n+    /**********************************************************\n+     */\n     \n     @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         // there's no way to statically determine the keys, so the \"Entries\" can't be determined.\n         return o;\n     }\n-    \n+\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n  * types: {@link java.lang.String}, {@link java.lang.Integer},\n  * {@link java.lang.Double} and {@link java.lang.Boolean}.\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class NonTypedScalarSerializerBase<T>\n     extends StdScalarSerializer<T>\n {\n \n     @Override\n     public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+            TypeSerializer typeSer) throws IOException\n     {\n         // no type info, just regular serialization\n         serialize(value, jgen, provider);            \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NullSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NullSerializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n  * more exotic types (java.lang.Void).\n  */\n @JacksonStdImpl\n+@SuppressWarnings(\"serial\")\n public class NullSerializer\n     extends StdSerializer<Object>\n {\n     private NullSerializer() { super(Object.class); }\n     \n     @Override\n-    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         jgen.writeNull();\n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n-    {\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n         return createSchemaNode(\"null\");\n     }\n     \n     @Override\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-        throws JsonMappingException\n-    {\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n         visitor.expectNullFormat(typeHint);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n \n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.JsonParser;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\n \n /**\n  * like {@link BigInteger} and {@link BigDecimal}.\n  */\n @JacksonStdImpl\n-public final class NumberSerializer\n+@SuppressWarnings(\"serial\")\n+public class NumberSerializer\n     extends StdScalarSerializer<Number>\n {\n-    public final static NumberSerializer instance = new NumberSerializer();\n+    /**\n+     * Static instance that is only to be used for {@link java.lang.Number}.\n+     */\n+    public final static NumberSerializer instance = new NumberSerializer(Number.class);\n \n-    public NumberSerializer() { super(Number.class); }\n+    protected final boolean _isInt;\n+\n+    @Deprecated // since 2.5\n+    public NumberSerializer() {\n+        super(Number.class);\n+        _isInt = false;\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public NumberSerializer(Class<? extends Number> rawType) {\n+        super(rawType, false);\n+        // since this will NOT be constructed for Integer or Long, only case is:\n+        _isInt = (rawType == BigInteger.class);\n+    }\n \n     @Override\n     public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n+        // should mostly come in as one of these two:\n         if (value instanceof BigDecimal) {\n             jgen.writeNumber((BigDecimal) value);\n         } else if (value instanceof BigInteger) {\n \n     @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-        return createSchemaNode(\"number\", true);\n+        return createSchemaNode(_isInt ? \"integer\" : \"number\", true);\n     }\n-    \n+\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n-        // Hmmh. What should it be? Ideally should probably indicate BIG_DECIMAL\n-        // to ensure no information is lost? But probably won't work that well...\n-        JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n-        if (v2 != null) {\n-            v2.numberType(JsonParser.NumberType.BIG_DECIMAL);\n+        if (_isInt) {\n+            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n+            if (v2 != null) {\n+                v2.numberType(JsonParser.NumberType.BIG_INTEGER);\n+            }\n+        } else {\n+            JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n+            if (v2 != null) {\n+                Class<?> h = handledType();\n+                if (h == BigDecimal.class) {\n+                    v2.numberType(JsonParser.NumberType.BIG_DECIMAL);\n+                } // otherwise it's for Number... anything we could do there?\n+            }\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\n /**\n  * Container class for serializers used for handling standard JDK-provided types.\n  */\n+@SuppressWarnings(\"serial\")\n public class NumberSerializers\n {\n     protected NumberSerializers() { }\n                 BeanProperty property) throws JsonMappingException\n         {\n             if (property != null) {\n-                JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(property.getMember());\n-                if (format != null) {\n-                    switch (format.getShape()) {\n-                    case STRING:\n-                        return ToStringSerializer.instance;\n-                    default:\n+                AnnotatedMember m = property.getMember();\n+                if (m != null) {\n+                    JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(m);\n+                    if (format != null) {\n+                        switch (format.getShape()) {\n+                        case STRING:\n+                            return ToStringSerializer.instance;\n+                        default:\n+                        }\n                     }\n                 }\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n  * Generic serializer for Object arrays (<code>Object[]</code>).\n  */\n @JacksonStdImpl\n+@SuppressWarnings(\"serial\")\n public class ObjectArraySerializer\n     extends ArraySerializerBase<Object[]>\n     implements ContextualSerializer\n         _elementType = elemType;\n         _staticTyping = staticTyping;\n         _valueTypeSerializer = vts;\n-        _dynamicSerializers = PropertySerializerMap.emptyMap();\n+        _dynamicSerializers = PropertySerializerMap.emptyForProperties();\n         _elementSerializer = elementSerializer;\n     }\n \n     }\n \n     @Override\n-    public boolean isEmpty(Object[] value) {\n+    public boolean isEmpty(SerializerProvider prov, Object[] value) {\n         return (value == null) || (value.length == 0);\n     }\n \n     /* Actual serialization\n     /**********************************************************\n      */\n-    \n-    @Override\n-    public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+\n+    @Override\n+    public final void serialize(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+    \tfinal int len = value.length;\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n+    \n+    @Override\n+    public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n         final int len = value.length;\n         if (len == 0) {\n     }\n \n     public void serializeContentsUsing(Object[] value, JsonGenerator jgen, SerializerProvider provider,\n-            JsonSerializer<Object> ser)\n-        throws IOException, JsonGenerationException\n+            JsonSerializer<Object> ser) throws IOException\n     {\n         final int len = value.length;\n         final TypeSerializer typeSer = _valueTypeSerializer;\n         }\n     }\n \n-    public void serializeTypedContents(Object[] value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serializeTypedContents(Object[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n         final int len = value.length;\n         final TypeSerializer typeSer = _valueTypeSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n  * This is a simple dummy serializer that will just output raw values by calling\n  * toString() on value to serialize.\n  */\n+@SuppressWarnings(\"serial\")\n public class RawSerializer<T>\n     extends StdSerializer<T>\n {\n     }\n \n     @Override\n-    public void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         jgen.writeRawValue(value.toString());\n     }\n \n     @Override\n     public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n             TypeSerializer typeSer)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         typeSer.writeTypePrefixForScalar(value, jgen);\n         serialize(value, jgen, provider);\n     }\n     \n     @Override\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-        throws JsonMappingException\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n         visitor.expectStringFormat(typeHint);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.*;\n-\n-\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonNode;\n  * interface, can not be checked for direct class equivalence.\n  */\n @JacksonStdImpl\n+@SuppressWarnings(\"serial\")\n public class SerializableSerializer\n     extends StdSerializer<JsonSerializable>\n {\n     protected SerializableSerializer() { super(JsonSerializable.class); }\n \n     @Override\n-    public void serialize(JsonSerializable value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n+    public void serialize(JsonSerializable value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         value.serialize(jgen, provider);\n     }\n \n     @Override\n     public final void serializeWithType(JsonSerializable value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n-    {\n+            TypeSerializer typeSer) throws IOException {\n         value.serializeWithType(jgen, provider, typeSer);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlDateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlDateSerializer.java\n  * that should not be used by plain SQL date.\n  */\n @JacksonStdImpl\n+@SuppressWarnings(\"serial\")\n public class SqlDateSerializer\n     extends DateTimeSerializerBase<java.sql.Date>\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java\n import java.io.IOException;\n import java.lang.reflect.Type;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonValueFormat;\n \n @JacksonStdImpl\n+@SuppressWarnings(\"serial\")\n public class SqlTimeSerializer\n     extends StdScalarSerializer<java.sql.Time>\n {\n     public SqlTimeSerializer() { super(java.sql.Time.class); }\n \n     @Override\n-    public void serialize(java.sql.Time value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serialize(java.sql.Time value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n         jgen.writeString(value.toString());\n     }\n \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-    {\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n         return createSchemaNode(\"string\", true);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n  * Intermediate base class for Lists, Collections and Arrays\n  * that contain static (non-dynamic) value types.\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class StaticListSerializerBase<T extends Collection<?>>\n     extends StdSerializer<T>\n {\n         super(cls, false);\n     }\n \n+    @Deprecated // since 2.5\n     @Override\n     public boolean isEmpty(T value) {\n+        return isEmpty(null, value);\n+    }\n+\n+    @Override\n+    public boolean isEmpty(SerializerProvider provider, T value) {\n         return (value == null) || (value.size() == 0);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n import java.util.HashMap;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n  * Dummy container class to group standard homogenous array serializer implementations\n  * (primitive arrays and String array).\n  */\n+@SuppressWarnings(\"serial\")\n public class StdArraySerializers\n {\n     protected final static HashMap<String, JsonSerializer<?>> _arraySerializers =\n      */\n \n     @JacksonStdImpl\n-    public final static class BooleanArraySerializer extends ArraySerializerBase<boolean[]>\n+    public static class BooleanArraySerializer extends ArraySerializerBase<boolean[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Boolean.class);\n         }\n         \n         @Override\n-        public boolean isEmpty(boolean[] value) {\n+        public boolean isEmpty(SerializerProvider prov, boolean[] value) {\n             return (value == null) || (value.length == 0);\n         }\n \n         @Override\n         public boolean hasSingleElement(boolean[] value) {\n             return (value.length == 1);\n+        }\n+\n+        @Override\n+        public final void serialize(boolean[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n         }\n         \n         @Override\n      * NOTE: since it is NOT serialized as an array, can not use AsArraySerializer as base\n      */\n     @JacksonStdImpl\n-    public final static class ByteArraySerializer extends StdSerializer<byte[]>\n+    public static class ByteArraySerializer extends StdSerializer<byte[]>\n     {\n         public ByteArraySerializer() {\n             super(byte[].class);\n         }\n         \n         @Override\n-        public boolean isEmpty(byte[] value) {\n+        public boolean isEmpty(SerializerProvider prov, byte[] value) {\n             return (value == null) || (value.length == 0);\n         }\n         \n         @Override\n         public void serialize(byte[] value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n+            throws IOException\n         {\n             jgen.writeBinary(provider.getConfig().getBase64Variant(),\n                     value, 0, value.length);\n         @Override\n         public void serializeWithType(byte[] value, JsonGenerator jgen, SerializerProvider provider,\n                 TypeSerializer typeSer)\n-            throws IOException, JsonGenerationException\n+            throws IOException\n         {\n             typeSer.writeTypePrefixForScalar(value, jgen);\n             jgen.writeBinary(provider.getConfig().getBase64Variant(),\n     }\n \n     @JacksonStdImpl\n-    public final static class ShortArraySerializer extends TypedPrimitiveArraySerializer<short[]>\n+    public static class ShortArraySerializer extends TypedPrimitiveArraySerializer<short[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Short.TYPE);\n         }\n         \n         @Override\n-        public boolean isEmpty(short[] value) {\n+        public boolean isEmpty(SerializerProvider prov, short[] value) {\n             return (value == null) || (value.length == 0);\n         }\n \n         @Override\n         public boolean hasSingleElement(short[] value) {\n             return (value.length == 1);\n+        }\n+\n+        @Override\n+        public final void serialize(short[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n         }\n         \n         @SuppressWarnings(\"cast\")\n      * NOTE: since it is NOT serialized as an array, can not use AsArraySerializer as base\n      */\n     @JacksonStdImpl\n-    public final static class CharArraySerializer extends StdSerializer<char[]>\n+    public static class CharArraySerializer extends StdSerializer<char[]>\n     {\n         public CharArraySerializer() { super(char[].class); }\n         \n         @Override\n-        public boolean isEmpty(char[] value) {\n+        public boolean isEmpty(SerializerProvider prov, char[] value) {\n             return (value == null) || (value.length == 0);\n         }\n         \n         {\n             // [JACKSON-289] allows serializing as 'sparse' char array too:\n             if (provider.isEnabled(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {\n-                jgen.writeStartArray();\n+                jgen.writeStartArray(value.length);\n                 _writeArrayContents(jgen, value);\n                 jgen.writeEndArray();\n             } else {\n     }\n \n     @JacksonStdImpl\n-    public final static class IntArraySerializer extends ArraySerializerBase<int[]>\n+    public static class IntArraySerializer extends ArraySerializerBase<int[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Integer.TYPE);\n         }\n         \n         @Override\n-        public boolean isEmpty(int[] value) {\n+        public boolean isEmpty(SerializerProvider prov, int[] value) {\n             return (value == null) || (value.length == 0);\n         }\n \n         }\n \n         @Override\n+        public final void serialize(int[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n+\n+        @Override\n         public void serializeContents(int[] value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n+            throws IOException\n         {\n             for (int i = 0, len = value.length; i < len; ++i) {\n                 jgen.writeNumber(value[i]);\n     }\n \n     @JacksonStdImpl\n-    public final static class LongArraySerializer extends TypedPrimitiveArraySerializer<long[]>\n+    public static class LongArraySerializer extends TypedPrimitiveArraySerializer<long[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Long.TYPE);\n         }\n         \n         @Override\n-        public boolean isEmpty(long[] value) {\n+        public boolean isEmpty(SerializerProvider prov, long[] value) {\n             return (value == null) || (value.length == 0);\n         }\n \n         public boolean hasSingleElement(long[] value) {\n             return (value.length == 1);\n         }\n+\n+        @Override\n+        public final void serialize(long[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n         \n         @Override\n         public void serializeContents(long[] value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n+            throws IOException\n         {\n             if (_valueTypeSerializer != null) {\n                 for (int i = 0, len = value.length; i < len; ++i) {\n     }\n \n     @JacksonStdImpl\n-    public final static class FloatArraySerializer extends TypedPrimitiveArraySerializer<float[]>\n+    public static class FloatArraySerializer extends TypedPrimitiveArraySerializer<float[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Float.TYPE);\n         }\n         \n         @Override\n-        public boolean isEmpty(float[] value) {\n+        public boolean isEmpty(SerializerProvider prov, float[] value) {\n             return (value == null) || (value.length == 0);\n         }\n \n         @Override\n         public boolean hasSingleElement(float[] value) {\n             return (value.length == 1);\n+        }\n+\n+        @Override\n+        public final void serialize(float[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n         }\n         \n         @Override\n     }\n \n     @JacksonStdImpl\n-    public final static class DoubleArraySerializer extends ArraySerializerBase<double[]>\n+    public static class DoubleArraySerializer extends ArraySerializerBase<double[]>\n     {\n         // as above, assuming no one re-defines primitive/wrapper types\n         private final static JavaType VALUE_TYPE = TypeFactory.defaultInstance().uncheckedSimpleType(Double.TYPE);\n         }\n         \n         @Override\n-        public boolean isEmpty(double[] value) {\n+        public boolean isEmpty(SerializerProvider prov, double[] value) {\n             return (value == null) || (value.length == 0);\n         }\n \n         public boolean hasSingleElement(double[] value) {\n             return (value.length == 1);\n         }\n-        \n-        @Override\n-        public void serializeContents(double[] value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n+\n+        @Override\n+        public final void serialize(double[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n+        \n+        @Override\n+        public void serializeContents(double[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n         {\n             for (int i = 0, len = value.length; i < len; ++i) {\n                 jgen.writeNumber(value[i]);\n         \n         @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-                throws JsonMappingException\n+            throws JsonMappingException\n         {\n             if (visitor != null) {\n                 JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n  *<p>\n  * Note that although types may be related, they must not be same; trying\n  * to do this will result in an exception.\n- * \n+ *\n  * @since 2.1\n  */\n+@SuppressWarnings(\"serial\")\n public class StdDelegatingSerializer\n     extends StdSerializer<Object>\n     implements ContextualSerializer, ResolvableSerializer,\n         JsonFormatVisitable, SchemaAware\n {\n     protected final Converter<Object,?> _converter;\n-    \n+\n     /**\n      * Fully resolved delegate type, with generic information if any available.\n      */\n     public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)\n         throws JsonMappingException\n     {\n-        // First: if already got serializer to delegate to, contextualize it:\n-        if (_delegateSerializer != null) {\n-            if (_delegateSerializer instanceof ContextualSerializer) {\n-                JsonSerializer<?> ser = provider.handleSecondaryContextualization(_delegateSerializer, property);\n-                if (ser == _delegateSerializer) {\n-                    return this;\n-                }\n-                return withDelegate(_converter, _delegateType, ser);\n+        JsonSerializer<?> delSer = _delegateSerializer;\n+        JavaType delegateType = _delegateType;\n+\n+        if (delSer == null) {\n+            // Otherwise, need to locate serializer to delegate to. For that we need type information...\n+            if (delegateType == null) {\n+                delegateType = _converter.getOutputType(provider.getTypeFactory());\n             }\n-            return this;\n-        }\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        JavaType delegateType = _delegateType;\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n-        }\n-        // and then find the thing...\n-        return withDelegate(_converter, delegateType,\n-                provider.findValueSerializer(delegateType, property));\n+            delSer = provider.findValueSerializer(delegateType);\n+        }\n+        if (delSer instanceof ContextualSerializer) {\n+            delSer = provider.handleSecondaryContextualization(delSer, property);\n+        }\n+        return (delSer == _delegateSerializer) ? this\n+                : withDelegate(_converter, delegateType, delSer);\n     }\n \n     /*\n      */\n \n     @Override\n-    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonProcessingException\n+    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider) throws IOException\n     {\n         Object delegateValue = convertValue(value);\n         // should we accept nulls?\n         if (delegateValue == null) {\n-            provider.defaultSerializeNull(jgen);\n+            provider.defaultSerializeNull(gen);\n             return;\n         }\n-        _delegateSerializer.serialize(delegateValue, jgen, provider);\n-    }\n-\n-    @Override\n-    public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonProcessingException\n+        _delegateSerializer.serialize(delegateValue, gen, provider);\n+    }\n+\n+    @Override\n+    public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,\n+            TypeSerializer typeSer) throws IOException\n     {\n         /* 03-Oct-2012, tatu: This is actually unlikely to work ok... but for now,\n          *    let's give it a chance?\n          */\n         Object delegateValue = convertValue(value);\n-        _delegateSerializer.serializeWithType(delegateValue, jgen, provider, typeSer);\n-    }\n-\n-    @Override\n+        _delegateSerializer.serializeWithType(delegateValue, gen, provider, typeSer);\n+    }\n+\n+    @Override\n+    @Deprecated // since 1.5\n     public boolean isEmpty(Object value)\n     {\n         Object delegateValue = convertValue(value);\n         return _delegateSerializer.isEmpty(delegateValue);\n     }\n-    \n+\n+    @Override\n+    public boolean isEmpty(SerializerProvider prov, Object value)\n+    {\n+        Object delegateValue = convertValue(value);\n+        return _delegateSerializer.isEmpty(prov, delegateValue);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Schema functionality\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n import java.util.concurrent.atomic.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\n  * are serializer as scalars; some using basic {@link ToStringSerializer},\n  * others explicit serializers.\n  */\n+@SuppressWarnings(\"serial\")\n public class StdJdkSerializers\n {\n     /**\n     /**********************************************************\n      */\n \n-    public final static class AtomicBooleanSerializer\n+    public static class AtomicBooleanSerializer\n         extends StdScalarSerializer<AtomicBoolean>\n     {\n         public AtomicBooleanSerializer() { super(AtomicBoolean.class, false); }\n         }\n     }\n     \n-    public final static class AtomicIntegerSerializer\n+    public static class AtomicIntegerSerializer\n         extends StdScalarSerializer<AtomicInteger>\n     {\n         public AtomicIntegerSerializer() { super(AtomicInteger.class, false); }\n         }\n     }\n \n-    public final static class AtomicLongSerializer\n+    public static class AtomicLongSerializer\n         extends StdScalarSerializer<AtomicLong>\n     {\n         public AtomicLongSerializer() { super(AtomicLong.class, false); }\n             }\n         }\n     }\n-    \n-    public final static class AtomicReferenceSerializer\n+\n+    public static class AtomicReferenceSerializer\n         extends StdSerializer<AtomicReference<?>>\n     {\n         public AtomicReferenceSerializer() { super(AtomicReference.class, false); }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\n import java.util.Date;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonNode;\n  * serializer, when serializing {@link java.util.Map}s to JSON\n  * Objects.\n  */\n+@SuppressWarnings(\"serial\")\n public class StdKeySerializer extends StdSerializer<Object>\n {\n     public StdKeySerializer() { super(Object.class); }\n-    \n+\n     @Override\n-    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n-        if (value instanceof Date) {\n+    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+        String str;\n+        Class<?> cls = value.getClass();\n+        \n+        if (cls == String.class) {\n+            str = (String) value;\n+        } else if (Date.class.isAssignableFrom(cls)) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n+            return;\n+        } else if (cls == Class.class) {\n+            str = ((Class<?>) value).getName();\n         } else {\n-            jgen.writeFieldName(value.toString());\n+            str = value.toString();\n         }\n+        jgen.writeFieldName(str);\n     }\n \n     @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n         return createSchemaNode(\"string\");\n     }\n-    \n+\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException {\n         visitor.expectStringFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n import java.util.Date;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n \n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n-\n+@SuppressWarnings(\"serial\")\n public class StdKeySerializers\n {\n     protected final static JsonSerializer<Object> DEFAULT_KEY_SERIALIZER = new StdKeySerializer();\n \n     private StdKeySerializers() { }\n \n+    /**\n+     * @param config Serialization configuration in use, may be needed in choosing\n+     *    serializer to use\n+     * @param rawKeyType Type of key values to serialize\n+     * @param useDefault If no match is found, should we return fallback deserializer\n+     *    (true), or null (false)?\n+     */\n     @SuppressWarnings(\"unchecked\")\n-    public static JsonSerializer<Object> getStdKeySerializer(JavaType keyType)\n+    public static JsonSerializer<Object> getStdKeySerializer(SerializationConfig config,\n+            Class<?> rawKeyType, boolean useDefault)\n     {\n-        if (keyType == null) {\n-            return DEFAULT_KEY_SERIALIZER;\n+        if (rawKeyType != null) {\n+            if (rawKeyType == String.class) {\n+                return DEFAULT_STRING_SERIALIZER;\n+            }\n+            if (rawKeyType == Object.class || rawKeyType.isPrimitive()\n+                    || Number.class.isAssignableFrom(rawKeyType)) {\n+                return DEFAULT_KEY_SERIALIZER;\n+            }\n+            if (rawKeyType == Class.class) {\n+                return (JsonSerializer<Object>) ClassKeySerializer.instance;\n+            }\n+            if (Date.class.isAssignableFrom(rawKeyType)) {\n+                return (JsonSerializer<Object>) DateKeySerializer.instance;\n+            }\n+            if (Calendar.class.isAssignableFrom(rawKeyType)) {\n+                return (JsonSerializer<Object>) CalendarKeySerializer.instance;\n+            }\n         }\n-        Class<?> cls = keyType.getRawClass();\n-        if (cls == String.class) {\n-            return DEFAULT_STRING_SERIALIZER;\n-        }\n-        if (cls == Object.class || cls.isPrimitive() || Number.class.isAssignableFrom(cls)) {\n-            return DEFAULT_KEY_SERIALIZER;\n-        }\n-        if (Date.class.isAssignableFrom(cls)) {\n-            return (JsonSerializer<Object>) DateKeySerializer.instance;\n-        }\n-        if (Calendar.class.isAssignableFrom(cls)) {\n-            return (JsonSerializer<Object>) CalendarKeySerializer.instance;\n-        }\n-        /* 14-Mar-2014, tatu: Should support @JsonValue, as per #47; but that\n-         *   requires extensive introspection, and passing in more information\n-         *   to this method.\n-         */\n-        // If no match, just use default one:\n+        return useDefault ? DEFAULT_KEY_SERIALIZER : null;\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5\n+     */\n+    @Deprecated\n+    public static JsonSerializer<Object> getStdKeySerializer(JavaType keyType) {\n+        return getStdKeySerializer(null, keyType.getRawClass(), true);\n+    }\n+\n+    public static JsonSerializer<Object> getDefault() {\n         return DEFAULT_KEY_SERIALIZER;\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Standard implementations\n             provider.defaultSerializeDateKey(value.getTimeInMillis(), jgen);\n         }\n     }\n+\n+    public static class ClassKeySerializer extends StdSerializer<Class<?>> {\n+        protected final static JsonSerializer<?> instance = new ClassKeySerializer();\n+\n+        public ClassKeySerializer() { super(Class.class, false); }\n+        \n+        @Override\n+        public void serialize(Class<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n+            jgen.writeFieldName(value.getName());\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n+@SuppressWarnings(\"serial\")\n public abstract class StdScalarSerializer<T>\n     extends StdSerializer<T>\n {\n      */\n     @Override\n     public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+            TypeSerializer typeSer) throws IOException\n     {\n         typeSer.writeTypePrefixForScalar(value, jgen);\n         serialize(value, jgen, provider);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n  */\n public abstract class StdSerializer<T>\n     extends JsonSerializer<T>\n-    implements JsonFormatVisitable, SchemaAware\n+    implements JsonFormatVisitable, SchemaAware, java.io.Serializable\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /**\n      * Nominal type supported, usually declared type of\n      * property for which serializer is used.\n             BeanProperty prop, JsonSerializer<?> existingSerializer)\n         throws JsonMappingException\n     {\n+        /* 19-Oct-2014, tatu: As per [databind#357], need to avoid infinite loop\n+         *   when applying contextual content converter; this is not ideal way,\n+         *   but should work for most cases.\n+         */\n+\n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n         if (intr != null && prop != null) {\n-            Object convDef = intr.findSerializationContentConverter(prop.getMember());\n-            if (convDef != null) {\n-                Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n-                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n-                if (existingSerializer == null) {\n-                    existingSerializer = provider.findValueSerializer(delegateType, prop);\n+            AnnotatedMember m = prop.getMember();\n+            if (m != null) {\n+                Object convDef = intr.findSerializationContentConverter(m);\n+                if (convDef != null) {\n+                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n+                    if (existingSerializer == null) {\n+                        existingSerializer = provider.findValueSerializer(delegateType);\n+                    }\n+                    return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n                 }\n-                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n             }\n         }\n         return existingSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n public final class StringSerializer\n     extends NonTypedScalarSerializerBase<String>\n {\n+    private static final long serialVersionUID = 1L;\n+\n     public StringSerializer() { super(String.class); }\n \n     /**\n      * For Strings, both null and Empty String qualify for emptiness.\n      */\n     @Override\n+    @Deprecated\n     public boolean isEmpty(String value) {\n+        return (value == null) || (value.length() == 0);\n+    }\n+\n+    @Override\n+    public boolean isEmpty(SerializerProvider prov, String value) {\n         return (value == null) || (value.length() == 0);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/TimeZoneSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/TimeZoneSerializer.java\n import java.util.TimeZone;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n+@SuppressWarnings(\"serial\")\n public class TimeZoneSerializer extends StdScalarSerializer<TimeZone>\n {\n     public TimeZoneSerializer() { super(TimeZone.class); }\n \n     @Override\n-    public void serialize(TimeZone value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n+    public void serialize(TimeZone value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         jgen.writeString(value.getID());\n     }\n \n     @Override\n-    public void serializeWithType(TimeZone value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException, JsonGenerationException {\n+    public void serializeWithType(TimeZone value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer) throws IOException {\n         // Better ensure we don't use specific sub-classes:\n         typeSer.writeTypePrefixForScalar(value, jgen, TimeZone.class);\n         serialize(value, jgen, provider);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonNode;\n  * value.\n  */\n @JacksonStdImpl\n+@SuppressWarnings(\"serial\")\n public class ToStringSerializer\n     extends StdSerializer<Object>\n {\n      */\n     public ToStringSerializer() { super(Object.class); }\n \n+    /**\n+     * Sometimes it may actually make sense to retain actual handled type, so...\n+     * \n+     * @since 2.5\n+     */\n+    public ToStringSerializer(Class<?> handledType) {\n+        super(handledType, false);\n+    }\n+\n     @Override\n+    @Deprecated\n     public boolean isEmpty(Object value) {\n+        return isEmpty(null, value);\n+    }\n+\n+    @Override\n+    public boolean isEmpty(SerializerProvider prov, Object value) {\n         if (value == null) {\n             return true;\n         }\n         String str = value.toString();\n-        // would use String.isEmpty(), but that's JDK 1.6\n-        return (str == null) || (str.length() == 0);\n+        return str.isEmpty();\n     }\n     \n     @Override\n-    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serialize(Object value, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n-        jgen.writeString(value.toString());\n+        gen.writeString(value.toString());\n     }\n \n     /* 01-Mar-2011, tatu: We were serializing as \"raw\" String; but generally that\n      * change this behavior.\n      */\n     @Override\n-    public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider,\n+    public void serializeWithType(Object value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n-        typeSer.writeTypePrefixForScalar(value, jgen);\n-        serialize(value, jgen, provider);\n-        typeSer.writeTypeSuffixForScalar(value, jgen);\n+        typeSer.writeTypePrefixForScalar(value, gen);\n+        serialize(value, gen, provider);\n+        typeSer.writeTypeSuffixForScalar(value, gen);\n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n-    {\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n         return createSchemaNode(\"string\", true);\n     }\n     \n     @Override\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-            throws JsonMappingException\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n         if (visitor != null) {\n             visitor.expectStringFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonNode;\n  * (which is only included in the mapper package)\n  */\n @JacksonStdImpl\n+@SuppressWarnings(\"serial\")\n public class TokenBufferSerializer\n     extends StdSerializer<TokenBuffer>\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/UUIDSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/UUIDSerializer.java\n import java.io.IOException;\n import java.util.UUID;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n  * allow serialization using raw binary output (as 16-byte block)\n  * if underlying data format has efficient means to access that.\n  */\n+@SuppressWarnings(\"serial\")\n public class UUIDSerializer\n     extends StdScalarSerializer<UUID>\n {\n     final static char[] HEX_CHARS = \"0123456789abcdef\".toCharArray();\n-    \n+\n     public UUIDSerializer() { super(UUID.class); }\n \n     @Override\n-    public boolean isEmpty(UUID value)\n+    @Deprecated // since 2.5\n+    public boolean isEmpty(UUID value) {\n+        return isEmpty(null, value);\n+    }\n+\n+    @Override\n+    public boolean isEmpty(SerializerProvider prov, UUID value)\n     {\n         if (value == null) {\n             return true;\n         }\n         return false;\n     }\n-    \n+\n     @Override\n-    public void serialize(UUID value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serialize(UUID value, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         // First: perhaps we could serialize it as raw binary data?\n-        if (jgen.canWriteBinaryNatively()) {\n+        if (gen.canWriteBinaryNatively()) {\n             /* 07-Dec-2013, tatu: One nasty case; that of TokenBuffer. While it can\n              *   technically retain binary data, we do not want to do use binary\n              *   with it, as that results in UUIDs getting converted to Base64 for\n              *   most conversions.\n              */\n-            if (!(jgen instanceof TokenBuffer)) {\n-                jgen.writeBinary(_asBytes(value));\n+            if (!(gen instanceof TokenBuffer)) {\n+                gen.writeBinary(_asBytes(value));\n                 return;\n             }\n         }\n         _appendShort((int) (lsb >>> 32), ch, 24);\n         _appendInt((int) lsb, ch, 28);\n \n-        jgen.writeString(ch, 0, 36);\n+        gen.writeString(ch, 0, 36);\n     }\n \n     private static void _appendInt(int bits, char[] ch, int offset)\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n         if (index == 0) return \"E\";\n         return null;\n     }\n+\n+    /**\n+     * No parameterization for array types themselves; element type\n+     * may obviously have parameterization.\n+     */\n+    @Override\n+    public Class<?> getParameterSource() {\n+        return null;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n         return null;\n     }\n \n+    // TODO: should allow construction of instances that do refer\n+    //  to parameterization, since it is NOT Collection\n+    @Override\n+    public Class<?> getParameterSource() {\n+        return null;\n+    }\n+    \n     @Override\n     public StringBuilder getErasedSignature(StringBuilder sb) {\n         return _classSignature(_class, sb, true);\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\n         return new CollectionType(_class, _elementType.withStaticTyping(),\n                 _valueHandler, _typeHandler, true);\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden accessors\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public Class<?> getParameterSource() {\n+        return java.util.Collection.class;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n         return null;\n     }\n \n+    // TODO: should allow construction of instances that do refer\n+    //  to parameterization, since it is NOT Map\n+    @Override\n+    public Class<?> getParameterSource() {\n+        return null;\n+    }\n+    \n     @Override\n     public StringBuilder getErasedSignature(StringBuilder sb) {\n         return _classSignature(_class, sb, true);\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n \n     /*\n     /**********************************************************\n+    /* Overridden accessors\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public Class<?> getParameterSource() {\n+        return java.util.Map.class;\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Extended API\n     /**********************************************************\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n     private static final long serialVersionUID = -800374828948534376L;\n \n     /**\n+     * In case there are resolved type parameters, this field stores reference\n+     * to that type. It must be {@link #getRawClass()} or its supertype.\n+     * \n+     * @since 2.5\n+     */\n+    protected final Class<?> _typeParametersFor;\n+    \n+    /**\n      * Generic type arguments for this type.\n      */\n     protected final JavaType[] _typeParameters;\n      */\n \n     protected SimpleType(Class<?> cls) {\n-        this(cls, null, null, null, null, false);\n-    }\n-\n+        this(cls, null, null, null, null, false, null);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5 use variant that takes one more argument\n+     */\n+    @Deprecated\n     protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams,\n             Object valueHandler, Object typeHandler, boolean asStatic)\n+    {\n+        this(cls, typeNames, typeParams, valueHandler, typeHandler, asStatic, null);\n+    }\n+\n+    /**\n+     * \n+     * @param parametersFrom Interface or abstract class implemented by this type,\n+     *   and for which type parameters apply. It may be <code>cls</code> itself,\n+     *   but more commonly it is one of its supertypes.\n+     */\n+    protected SimpleType(Class<?> cls,\n+            String[] typeNames, JavaType[] typeParams,\n+            Object valueHandler, Object typeHandler, boolean asStatic,\n+            Class<?> parametersFrom)\n     {\n         super(cls, 0, valueHandler, typeHandler, asStatic);\n         if (typeNames == null || typeNames.length == 0) {\n             _typeNames = typeNames;\n             _typeParameters = typeParams;\n         }\n+        _typeParametersFor = parametersFrom;\n     }\n \n     /**\n      * not in same package\n      */\n     public static SimpleType constructUnsafe(Class<?> raw) {\n-        return new SimpleType(raw, null, null, null, null, false);\n+        return new SimpleType(raw, null, null, null, null, false, null);\n     }\n \n     @Override\n     {\n         // Should we check that there is a sub-class relationship?\n         return new SimpleType(subclass, _typeNames, _typeParameters, _valueHandler, _typeHandler,\n-                _asStatic);\n+                _asStatic, _typeParametersFor);\n     }\n \n     @Override\n     @Override\n     public SimpleType withTypeHandler(Object h)\n     {\n-        return new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, h, _asStatic);\n+        return new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, h, _asStatic, _typeParametersFor);\n     }\n \n     @Override\n         if (h == _valueHandler) {\n             return this;\n         }\n-        return new SimpleType(_class, _typeNames, _typeParameters, h, _typeHandler, _asStatic);\n+        return new SimpleType(_class, _typeNames, _typeParameters, h, _typeHandler, _asStatic, _typeParametersFor);\n     }\n     \n     @Override\n     @Override\n     public SimpleType withStaticTyping() {\n         return _asStatic ? this : new SimpleType(_class,\n-                _typeNames, _typeParameters, _valueHandler, _typeHandler, _asStatic);\n+                _typeNames, _typeParameters, _valueHandler, _typeHandler, _asStatic, _typeParametersFor);\n     }\n \n     @Override\n         }\n         return _typeNames[index];\n     }\n+\n+    @Override\n+    public Class<?> getParameterSource() {\n+        return _typeParametersFor;\n+    }\n     \n     @Override\n     public StringBuilder getErasedSignature(StringBuilder sb) {\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n          * case actually fully works; and former mostly works. In future may need to\n          * rewrite former part, which requires changes to JavaType as well.\n          */\n-        Class<?> raw = type.getRawClass();\n-        if (raw == expType) {\n+        if (expType == type.getParameterSource()) {\n             // Direct type info; good since we can return it as is\n             int count = type.containedTypeCount();\n             if (count == 0) return null;\n          * if/when there are problems; current handling is an improvement over earlier\n          * code.\n          */\n+        Class<?> raw = type.getRawClass();\n         return findTypeParameters(raw, expType, new TypeBindings(this, type));\n     }\n \n     public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n         return findTypeParameters(clz, expType, new TypeBindings(this, clz));\n     }\n-    \n+\n     public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)\n     {\n         // First: find full inheritance chain\n \n         // simple class?\n         if (type instanceof Class<?>) {\n-            Class<?> cls = (Class<?>) type;\n-            resultType = _fromClass(cls, context);\n+            resultType = _fromClass((Class<?>) type, context);\n         }\n         // But if not, need to start resolving.\n         else if (type instanceof ParameterizedType) {\n     \n     /**\n      * Method for constructing a type instance with specified parameterization.\n-     */\n-    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes)\n+     * \n+     * @deprecated Since 2.5, use variant that takes one more argument\n+     */\n+    @Deprecated\n+    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n+        return constructSimpleType(rawType, rawType, parameterTypes);\n+    }\n+    \n+    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n+            JavaType[] parameterTypes)\n     {\n         // Quick sanity check: must match numbers of types with expected...\n-        TypeVariable<?>[] typeVars = rawType.getTypeParameters();\n+        TypeVariable<?>[] typeVars = parameterTarget.getTypeParameters();\n         if (typeVars.length != parameterTypes.length) {\n             throw new IllegalArgumentException(\"Parameter type mismatch for \"+rawType.getName()\n-                    +\": expected \"+typeVars.length+\" parameters, was given \"+parameterTypes.length);\n+                    +\" (and target \"+parameterTarget.getName()+\"): expected \"+typeVars.length\n+                    +\" parameters, was given \"+parameterTypes.length);\n         }\n         String[] names = new String[typeVars.length];\n         for (int i = 0, len = typeVars.length; i < len; ++i) {\n             names[i] = typeVars[i].getName();\n         }\n-        JavaType resultType = new SimpleType(rawType, names, parameterTypes, null, null, false);\n-        return resultType;\n+        return new SimpleType(rawType, names, parameterTypes, null, null, false, parameterTarget);\n     } \n \n     /**\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     */\n-    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses)\n+     * \n+     * @param parametrized Type-erased type of instance being constructed\n+     * @param parametersFor class or interface for which type parameters are applied; either\n+     *   <code>parametrized</code> or one of its supertypes\n+     * @param parameterClasses Type parameters to apply\n+     * \n+     * @since 2.5\n+     */\n+    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n+            Class<?>... parameterClasses)\n     {\n         int len = parameterClasses.length;\n         JavaType[] pt = new JavaType[len];\n         for (int i = 0; i < len; ++i) {\n             pt[i] = _fromClass(parameterClasses[i], null);\n         }\n-        return constructParametricType(parametrized, pt);\n+        return constructParametrizedType(parametrized, parametersFor, pt);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n+     */\n+    @Deprecated\n+    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n+        return constructParametrizedType(parametrized, parametrized, parameterClasses);\n     }\n \n     /**\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     */\n-    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes)\n+     * \n+     * \n+     * @param parametrized Actual full type\n+     * @param parametersFor class or interface for which type parameters are applied; either\n+     *   <code>parametrized</code> or one of its supertypes\n+     * @param parameterTypes Type parameters to apply\n+     * \n+     * @since 2.5\n+     */\n+    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n+            JavaType... parameterTypes)\n     {\n         JavaType resultType;\n         \n             }\n             resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);\n         } else {\n-            resultType = constructSimpleType(parametrized, parameterTypes);\n+            resultType = constructSimpleType(parametrized, parametersFor, parameterTypes);\n         }\n         return resultType;\n     }\n \n+    /**\n+     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n+     */\n+    @Deprecated\n+    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {\n+        return constructParametrizedType(parametrized, parametrized, parameterTypes);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Direct factory methods for \"raw\" variants, used when\n         } else if (Collection.class.isAssignableFrom(clz)) {\n             result =  _collectionType(clz);\n         } else {\n-            result = new SimpleType(clz);\n+            // 29-Sep-2014, tatu: We may want to pre-resolve well-known generic types\n+            if (Map.Entry.class.isAssignableFrom(clz)) {\n+                JavaType[] pts = this.findTypeParameters(clz, Map.Entry.class);\n+                JavaType kt, vt;\n+                if (pts == null || pts.length != 2) {\n+                    kt = vt = unknownType();\n+                } else {\n+                    kt = pts[0];\n+                    vt = pts[1];\n+                }\n+                result = constructSimpleType(clz, Map.Entry.class, new JavaType[] { kt, vt });\n+            } else {\n+                result = new SimpleType(clz);\n+            }\n         }\n         _typeCache.put(key, result); // cache object syncs\n         return result;\n         if (paramTypes.size() == 0) {\n             return new SimpleType(clz);\n         }\n+        // Hmmh. Does this actually occur?\n         JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);\n-        return constructSimpleType(clz, pt);\n+        return constructSimpleType(clz, clz, pt);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java\n {\n     /*\n     /**********************************************************\n-    /* Handling \"getter\" names\n-    /**********************************************************\n-     */\n-\n-    public static String okNameForGetter(AnnotatedMethod am)\n-    {\n+    /* Handling property names\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public static String okNameForGetter(AnnotatedMethod am, boolean stdNaming) {\n         String name = am.getName();\n-        String str = okNameForIsGetter(am, name);\n+        String str = okNameForIsGetter(am, name, stdNaming);\n         if (str == null) {\n-            str = okNameForRegularGetter(am, name);\n+            str = okNameForRegularGetter(am, name, stdNaming);\n         }\n         return str;\n     }\n-\n-    public static String okNameForRegularGetter(AnnotatedMethod am, String name)\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    public static String okNameForRegularGetter(AnnotatedMethod am, String name,\n+            boolean stdNaming)\n     {\n         if (name.startsWith(\"get\")) {\n             /* 16-Feb-2009, tatu: To handle [JACKSON-53], need to block\n                     return null;\n                 }\n             } else if (\"getMetaClass\".equals(name)) {\n-                /* 30-Apr-2009, tatu: [JACKSON-103], need to suppress\n-                 *    serialization of a cyclic (and useless) reference\n-                 */\n+                // 30-Apr-2009, tatu: Need to suppress serialization of a cyclic reference\n                 if (isGroovyMetaClassGetter(am)) {\n                     return null;\n                 }\n             }\n-            return manglePropertyName(name.substring(3));\n-        }\n-        return null;\n-    }\n-\n-    public static String okNameForIsGetter(AnnotatedMethod am, String name)\n-    {\n-        if (name.startsWith(\"is\")) {\n-            // plus, must return boolean...\n+            return stdNaming\n+                    ? stdManglePropertyName(name, 3)\n+                    : legacyManglePropertyName(name, 3);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public static String okNameForIsGetter(AnnotatedMethod am, String name,\n+            boolean stdNaming)\n+    {\n+        if (name.startsWith(\"is\")) { // plus, must return a boolean\n             Class<?> rt = am.getRawType();\n-            if (rt != Boolean.class && rt != Boolean.TYPE) {\n-                return null;\n-            }\n-            return manglePropertyName(name.substring(2));\n-        }\n-        // no, not a match by name\n-        return null;\n-    }\n-\n-    public static String okNameForSetter(AnnotatedMethod am)\n-    {\n-        String name = okNameForMutator(am, \"set\");\n-        if (name != null) {\n-            // 26-Nov-2009 [JACSON-103], need to suppress this internal groovy method\n-            if (\"metaClass\".equals(name)) {\n-                if (isGroovyMetaClassSetter(am)) {\n-                    return null;\n-                }\n-            }\n+            if (rt == Boolean.class || rt == Boolean.TYPE) {\n+                return stdNaming\n+                        ? stdManglePropertyName(name, 2)\n+                        : legacyManglePropertyName(name, 2);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public static String okNameForSetter(AnnotatedMethod am, boolean stdNaming) {\n+        String name = okNameForMutator(am, \"set\", stdNaming);\n+        if ((name != null) \n+            // 26-Nov-2009, tatu: need to suppress this internal groovy method\n+                && (!\"metaClass\".equals(name) || !isGroovyMetaClassSetter(am))) {\n             return name;\n         }\n         return null;\n     }\n \n-    public static String okNameForMutator(AnnotatedMethod am, String prefix)\n-    {\n+    /**\n+     * @since 2.5\n+     */\n+    public static String okNameForMutator(AnnotatedMethod am, String prefix,\n+            boolean stdNaming) {\n         String name = am.getName();\n         if (name.startsWith(prefix)) {\n-            return manglePropertyName(name.substring(prefix.length()));\n-        }\n-        return null;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper methods for bean property name handling\n+            return stdNaming\n+                    ? stdManglePropertyName(name, prefix.length())\n+                    : legacyManglePropertyName(name, prefix.length());\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Handling property names, deprecated methods\n+    /**********************************************************\n+     */\n+\n+    @Deprecated // since 2.5\n+    public static String okNameForGetter(AnnotatedMethod am) {\n+        return okNameForGetter(am, false);\n+    }\n+\n+    @Deprecated // since 2.5\n+    public static String okNameForRegularGetter(AnnotatedMethod am, String name) {\n+        return okNameForRegularGetter(am, name, false);\n+    }\n+\n+    @Deprecated // since 2.5\n+    public static String okNameForIsGetter(AnnotatedMethod am, String name) {\n+        return okNameForIsGetter(am, name, false);\n+    }\n+\n+    @Deprecated // since 2.5\n+    public static String okNameForSetter(AnnotatedMethod am) {\n+        return okNameForSetter(am, false);\n+    }\n+\n+    @Deprecated // since 2.5\n+    public static String okNameForMutator(AnnotatedMethod am, String prefix) {\n+        return okNameForMutator(am, prefix, false);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Special case handling\n     /**********************************************************\n      */\n \n      * with name \"getCallbacks\" and we need to determine if it is\n      * indeed injectect by Cglib. We do this by verifying that the\n      * result type is \"net.sf.cglib.proxy.Callback[]\"\n-     *<p>\n-     * Also, see [JACKSON-177]; Hibernate may repackage cglib\n-     * it uses, so we better catch that too\n      */\n     protected static boolean isCglibGetCallbacks(AnnotatedMethod am)\n     {\n         Package pkg = compType.getPackage();\n         if (pkg != null) {\n             String pname = pkg.getName();\n-            if (pname.startsWith(\"net.sf.cglib\")\n-                // also, as per [JACKSON-177]\n-                || pname.startsWith(\"org.hibernate.repackage.cglib\")) {\n-                return true;\n+            if (pname.contains(\".cglib\")) {\n+                if (pname.startsWith(\"net.sf.cglib\")\n+                    // also, as per [JACKSON-177]\n+                    || pname.startsWith(\"org.hibernate.repackage.cglib\")\n+                    // and [core#674]\n+                    || pname.startsWith(\"org.springframework.cglib\")\n+                        ) {\n+                    return true;\n+                }\n             }\n         }\n         return false;\n         }\n         return false;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Actual name mangling methods\n+    /**********************************************************\n+     */\n \n     /**\n      * Method called to figure out name of the property, given \n      * @param basename Name of accessor/mutator method, not including prefix\n      *  (\"get\"/\"is\"/\"set\")\n      */\n-    protected static String manglePropertyName(String basename)\n-    {\n-        int len = basename.length();\n-\n-        // First things first: empty basename is no good\n-        if (len == 0) {\n+    protected static String legacyManglePropertyName(final String basename, final int offset)\n+    {\n+        final int end = basename.length();\n+        if (end == offset) { // empty name, nope\n             return null;\n         }\n         // otherwise, lower case initial chars\n         StringBuilder sb = null;\n-        for (int i = 0; i < len; ++i) {\n+        for (int i = offset; i < end; ++i) {\n             char upper = basename.charAt(i);\n             char lower = Character.toLowerCase(upper);\n             if (upper == lower) {\n                 break;\n             }\n             if (sb == null) {\n-                sb = new StringBuilder(basename);\n-            }\n-            sb.setCharAt(i, lower);\n-        }\n-        return (sb == null) ? basename : sb.toString();\n+                int l = end-offset;\n+                sb = new StringBuilder(l);\n+                sb.append(basename, offset, end);\n+            }\n+            sb.setCharAt(i-offset, lower);\n+        }\n+        return (sb == null) ? basename.substring(offset) : sb.toString();\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected static String stdManglePropertyName(final String basename, final int offset)\n+    {\n+        final int end = basename.length();\n+        if (end == offset) { // empty name, nope\n+            return null;\n+        }\n+        // first: if it doesn't start with capital, return as-is\n+        char c0 = basename.charAt(offset);\n+        char c1 = Character.toLowerCase(c0);\n+        if (c0 == c1) {\n+            return basename.substring(offset);\n+        }\n+        // 17-Dec-2014, tatu: As per [databind#653], need to follow more\n+        //   closely Java Beans spec; specifically, if two first are upper-case,\n+        //   then no lower-casing should be done.\n+        if ((offset + 1) < end) {\n+            if (Character.isUpperCase(basename.charAt(offset+1))) {\n+                return basename.substring(offset);\n+            }\n+        }\n+        StringBuilder sb = new StringBuilder(end - offset);\n+        sb.append(c1);\n+        sb.append(basename, offset+1, end);\n+        return sb.toString();\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n         return (implClass.getAnnotation(JacksonStdImpl.class) != null);\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    public final static boolean isBogusClass(Class<?> cls) {\n+    public static boolean isBogusClass(Class<?> cls) {\n         return (cls == Void.class || cls == Void.TYPE\n                 || cls == com.fasterxml.jackson.databind.annotation.NoClass.class);\n+    }\n+\n+    public static boolean isNonStaticInnerClass(Class<?> cls) {\n+        return (cls.getEnclosingClass() != null)\n+                && !Modifier.isStatic(cls.getModifiers());\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n import java.text.ParseException;\n \n /**\n- * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than\n- * using SimpleDateFormat so highly suitable if you (un)serialize lots of date objects.\n+ * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so\n+ * highly suitable if you (un)serialize lots of date objects.\n+ * \n+ * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n+ * \n+ * @see <a href=\"http://www.w3.org/TR/NOTE-datetime\">this specification</a>\n  */\n-public class ISO8601Utils {\n-\n+public class ISO8601Utils\n+{\n     /**\n      * ID to represent the 'GMT' string\n      */\n     /* Static factories\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Accessor for static GMT timezone instance.\n      */\n-    public static TimeZone timeZoneGMT() { return TIMEZONE_GMT; }\n+    public static TimeZone timeZoneGMT() {\n+        return TIMEZONE_GMT;\n+    }\n \n     /*\n     /**********************************************************\n     /* Formatting\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (GMT timezone, no milliseconds precision)\n-     *\n+     * \n      * @param date the date to format\n      * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\n      */\n \n     /**\n      * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)\n-     *\n-     * @param date   the date to format\n+     * \n+     * @param date the date to format\n      * @param millis true to include millis precision otherwise false\n      * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'\n      */\n \n     /**\n      * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n-     *\n-     * @param date   the date to format\n+     * \n+     * @param date the date to format\n      * @param millis true to include millis precision otherwise false\n-     * @param tz     timezone to use for the formatting (GMT will produce 'Z')\n+     * @param tz timezone to use for the formatting (GMT will produce 'Z')\n      * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n      */\n     public static String format(Date date, boolean millis, TimeZone tz) {\n      */\n \n     /**\n-     * Parse a date from ISO-8601 formatted string. It expects a format yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n-     *\n+     * Parse a date from ISO-8601 formatted string. It expects a format\n+     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n+     * \n      * @param date ISO string to parse in the appropriate format.\n      * @param pos The position to start parsing from, updated to where parsing stopped.\n      * @return the parsed date\n      * @throws ParseException if the date is not in the appropriate format\n      */\n-    public static Date parse(String date, ParsePosition pos) throws ParseException\n-    {\n+    public static Date parse(String date, ParsePosition pos) throws ParseException {\n         Exception fail = null;\n         try {\n             int offset = pos.getIndex();\n \n             // extract year\n             int year = parseInt(date, offset, offset += 4);\n-            checkOffset(date, offset, '-');\n+            if (checkOffset(date, offset, '-')) {\n+                offset += 1;\n+            }\n \n             // extract month\n-            int month = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, '-');\n+            int month = parseInt(date, offset, offset += 2);\n+            if (checkOffset(date, offset, '-')) {\n+                offset += 1;\n+            }\n \n             // extract day\n-            int day = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, 'T');\n-\n-            // extract hours, minutes, seconds and milliseconds\n-            int hour = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, ':');\n-\n-            int minutes = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, ':');\n-\n-            int seconds = parseInt(date, offset += 1, offset += 2);\n-            // milliseconds can be optional in the format\n+            int day = parseInt(date, offset, offset += 2);\n+            // default time value\n+            int hour = 0;\n+            int minutes = 0;\n+            int seconds = 0;\n             int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n-            if (date.charAt(offset) == '.') {\n-                checkOffset(date, offset, '.');\n-                milliseconds = parseInt(date, offset += 1, offset += 3);\n+            if (checkOffset(date, offset, 'T')) {\n+\n+                // extract hours, minutes, seconds and milliseconds\n+                hour = parseInt(date, offset += 1, offset += 2);\n+                if (checkOffset(date, offset, ':')) {\n+                    offset += 1;\n+                }\n+\n+                minutes = parseInt(date, offset, offset += 2);\n+                if (checkOffset(date, offset, ':')) {\n+                    offset += 1;\n+                }\n+                // second and milliseconds can be optional\n+                if (date.length() > offset) {\n+                    char c = date.charAt(offset);\n+                    if (c != 'Z' && c != '+' && c != '-') {\n+                        seconds = parseInt(date, offset, offset += 2);\n+                        // milliseconds can be optional in the format\n+                        if (checkOffset(date, offset, '.')) {\n+                            milliseconds = parseInt(date, offset += 1, offset += 3);\n+                        }\n+                    }\n+                }\n             }\n \n             // extract timezone\n             String timezoneId;\n+            if (date.length() <= offset) {\n+                throw new IllegalArgumentException(\"No time zone indicator\");\n+            }\n             char timezoneIndicator = date.charAt(offset);\n             if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                 String timezoneOffset = date.substring(offset);\n \n             pos.setIndex(offset);\n             return calendar.getTime();\n-            //If we get a ParseException it'll already have the right message/offset.\n-            //Other exception types can convert here.\n+            // If we get a ParseException it'll already have the right message/offset.\n+            // Other exception types can convert here.\n         } catch (IndexOutOfBoundsException e) {\n             fail = e;\n         } catch (NumberFormatException e) {\n         } catch (IllegalArgumentException e) {\n             fail = e;\n         }\n-        String input = (date == null) ? null : ('\"'+date+\"'\");\n-        throw new ParseException(\"Failed to parse date [\"+input\n-            +\"]: \"+fail.getMessage(), pos.getIndex());\n-    }\n-\n-    /**\n-     * Check if the expected character exist at the given offset of the\n-     *\n-     * @param value    the string to check at the specified offset\n-     * @param offset   the offset to look for the expected character\n+        String input = (date == null) ? null : ('\"' + date + \"'\");\n+        throw new ParseException(\"Failed to parse date [\" + input + \"]: \" + fail.getMessage(), pos.getIndex());\n+    }\n+\n+    /**\n+     * Check if the expected character exist at the given offset in the value.\n+     * \n+     * @param value the string to check at the specified offset\n+     * @param offset the offset to look for the expected character\n      * @param expected the expected character\n-     * @throws IndexOutOfBoundsException if the expected character is not found\n-     */\n-    private static void checkOffset(String value, int offset, char expected) throws ParseException {\n-        char found = value.charAt(offset);\n-        if (found != expected) {\n-            throw new ParseException(\"Expected '\" + expected + \"' character but found '\" + found + \"'\", offset);\n-        }\n+     * @return true if the expected character exist at the given offset\n+     */\n+    private static boolean checkOffset(String value, int offset, char expected) {\n+        return (offset < value.length()) && (value.charAt(offset) == expected);\n     }\n \n     /**\n      * Parse an integer located between 2 given offsets in a string\n-     *\n-     * @param value      the string to parse\n+     * \n+     * @param value the string to parse\n      * @param beginIndex the start index for the integer in the string\n-     * @param endIndex   the end index for the integer in the string\n+     * @param endIndex the end index for the integer in the string\n      * @return the int\n      * @throws NumberFormatException if the value is not a number\n      */\n \n     /**\n      * Zero pad a number to a specified length\n-     *\n+     * \n      * @param buffer buffer to use for padding\n-     * @param value  the integer value to pad if necessary.\n+     * @param value the integer value to pad if necessary.\n      * @param length the length of the string we should zero pad\n      */\n     private static void padInt(StringBuilder buffer, int value, int length) {\n         buffer.append(strValue);\n     }\n }\n-\n--- a/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n  * NOTE: since version 2.4.2, this is <b>NOT</b> an LRU-based at all; reason\n  * being that it is not possible to use JDK components that do LRU _AND_ perform\n  * well wrt synchronization on multi-core systems. So we choose efficient synchronization\n- * over potentially more effecient handling of entries.\n+ * over potentially more efficient handling of entries.\n+ *<p>\n+ * And yes, there are efficient LRU implementations such as\n+ * <a href=\"https://code.google.com/p/concurrentlinkedhashmap/\">concurrentlinkedhashmap</a>;\n+ * but at this point we really try to keep external deps to minimum. But perhaps\n+ * a shaded variant may be used one day.\n  */\n public class LRUMap<K,V>\n     implements java.io.Serializable\n         return _map.put(key, value);\n     }\n \n+    /**\n+     * @since 2.5\n+     */\n+    public V putIfAbsent(K key, V value) {\n+        // not 100% optimal semantically, but better from correctness (never exceeds\n+        // defined maximum) and close enough all in all:\n+        if (_map.size() >= _maxEntries) {\n+            synchronized (this) {\n+                if (_map.size() >= _maxEntries) {\n+                    clear();\n+                }\n+            }\n+        }\n+        return _map.putIfAbsent(key, value);\n+    }\n+    \n     // NOTE: key is of type Object only to retain binary backwards-compatibility\n     public V get(Object key) {  return _map.get(key); }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/util/PrimitiveArrayBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/PrimitiveArrayBuilder.java\n     /**********************************************************\n      */\n \n+    public int bufferedSize() { return _bufferedEntryCount; }\n+    \n     public T resetAndStart()\n     {\n         _reset();\n--- a/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n package com.fasterxml.jackson.databind.util;\n \n+import java.util.Collections;\n+import java.util.Iterator;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.PropertyMetadata;\n import com.fasterxml.jackson.databind.PropertyName;\n      * Member that defines logical property. Assumption is that it\n      * should be a 'simple' accessor; meaning a zero-argument getter,\n      * single-argument setter or constructor parameter.\n+     *<p>\n+     * NOTE: for \"virtual\" properties, this is null.\n      */\n     protected final AnnotatedMember _member;\n \n+    /**\n+     * @since 2.5\n+     */\n+    protected final PropertyMetadata _metadata;\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    protected final PropertyName _fullName;\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    protected final JsonInclude.Include _inclusion;\n+    \n+    /**\n+     * @deprecated Since 2.5 use <code>_fullName</code> instead.\n+     */\n+    @Deprecated\n     protected final String _name;\n     \n     /*\n      */\n     @Deprecated\n     public SimpleBeanPropertyDefinition(AnnotatedMember member, String name) {\n-        this(member, name, null);\n-    }\n-    \n-    private SimpleBeanPropertyDefinition(AnnotatedMember member, String name,\n-    \t\tAnnotationIntrospector intr) {\n+        this(member, new PropertyName(name), null, null, null);\n+    }\n+\n+    protected SimpleBeanPropertyDefinition(AnnotatedMember member, PropertyName fullName,\n+            AnnotationIntrospector intr, PropertyMetadata metadata,\n+            JsonInclude.Include inclusion)\n+    {\n         _introspector = intr;\n         _member = member;\n-        _name = name;\n+        _fullName = fullName;\n+        _name = fullName.getSimpleName();\n+        _metadata = (metadata == null) ? PropertyMetadata.STD_OPTIONAL: metadata;\n+        _inclusion = inclusion;\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5 Use variant that takes PropertyName\n+     */\n+    @Deprecated\n+    protected SimpleBeanPropertyDefinition(AnnotatedMember member, String name,\n+    \t\tAnnotationIntrospector intr) {\n+        this(member, new PropertyName(name), intr, null, null);\n     }\n \n     /**\n      */\n     public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n     \t\tAnnotatedMember member) {\n-        return new SimpleBeanPropertyDefinition(member, member.getName(),\n-                (config == null) ? null : config.getAnnotationIntrospector());\n-    }\n-    \n-    /**\n-     * @since 2.2\n-     */\n+        return new SimpleBeanPropertyDefinition(member, new PropertyName(member.getName()),\n+                (config == null) ? null : config.getAnnotationIntrospector(),\n+                        null, null);\n+    }\n+    \n+    /**\n+     * @deprecated Since 2.5\n+     */\n+    @Deprecated\n     public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n     \t\tAnnotatedMember member, String name) {\n-        return new SimpleBeanPropertyDefinition(member, name,\n-                (config == null) ? null : config.getAnnotationIntrospector());\n-    }\n+        return new SimpleBeanPropertyDefinition(member, new PropertyName(name),\n+                (config == null) ? null : config.getAnnotationIntrospector(),\n+                        null, null);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n+            AnnotatedMember member, PropertyName name) {\n+        return construct(config, member, name, null, null);\n+    }\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n+            AnnotatedMember member, PropertyName name, PropertyMetadata metadata,\n+            JsonInclude.Include inclusion) {\n+          return new SimpleBeanPropertyDefinition(member, name,\n+                  (config == null) ? null : config.getAnnotationIntrospector(),\n+                          metadata, inclusion);\n+      }\n     \n     /*\n     /**********************************************************\n \n     @Deprecated // since 2.3\n     @Override\n-    public SimpleBeanPropertyDefinition withName(String newName) {\n+    public BeanPropertyDefinition withName(String newName) {\n         return withSimpleName(newName);\n     }\n \n     @Override\n-    public SimpleBeanPropertyDefinition withSimpleName(String newName) {\n-        if (_name.equals(newName)) {\n+    public BeanPropertyDefinition withSimpleName(String newName) {\n+        if (_fullName.hasSimpleName(newName) && !_fullName.hasNamespace()) {\n             return this;\n         }\n-        return new SimpleBeanPropertyDefinition(_member, newName, _introspector);\n-    }\n-\n-    @Override\n-    public SimpleBeanPropertyDefinition withName(PropertyName newName) {\n-        return withSimpleName(newName.getSimpleName());\n+        return new SimpleBeanPropertyDefinition(_member, new PropertyName(newName),\n+                _introspector, _metadata, _inclusion);\n+    }\n+\n+    @Override\n+    public BeanPropertyDefinition withName(PropertyName newName) {\n+        if (_fullName.equals(newName)) {\n+            return this;\n+        }\n+        return new SimpleBeanPropertyDefinition(_member, newName,\n+                _introspector, _metadata, _inclusion);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public BeanPropertyDefinition withMetadata(PropertyMetadata metadata) {\n+        if (metadata.equals(_metadata)) {\n+            return this;\n+        }\n+        return new SimpleBeanPropertyDefinition(_member, _fullName,\n+                _introspector, metadata, _inclusion);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public BeanPropertyDefinition withInclusion(JsonInclude.Include inclusion) {\n+        if (_inclusion == inclusion) {\n+            return this;\n+        }\n+        return new SimpleBeanPropertyDefinition(_member, _fullName,\n+                _introspector, _metadata, inclusion);\n     }\n     \n     /*\n      */\n \n     @Override\n-    public String getName() { return _name; }\n-\n-    @Override\n-    public PropertyName getFullName() { return new PropertyName(_name); }\n-    \n+    public String getName() { return _fullName.getSimpleName(); }\n+\n+    @Override\n+    public PropertyName getFullName() { return _fullName; }\n+\n     @Override\n     public String getInternalName() { return getName(); }\n \n     @Override\n     public PropertyName getWrapperName() {\n-        return (_introspector == null) ? null : _introspector.findWrapperName(_member);\n-    }\n-    \n+        return ((_introspector == null) && (_member != null))\n+                ? null : _introspector.findWrapperName(_member);\n+    }\n+\n     // hmmh. what should we claim here?\n \n     @Override public boolean isExplicitlyIncluded() { return false; }\n      */\n     @Override\n     public PropertyMetadata getMetadata() {\n-        return PropertyMetadata.STD_OPTIONAL;\n-    }\n-    \n+        return _metadata;\n+    }\n+\n+    @Override\n+    public JsonInclude.Include findInclusion() {\n+        return _inclusion;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Access to accessors (fields, methods etc)\n         return (_member instanceof AnnotatedParameter) ? (AnnotatedParameter) _member : null;\n     }\n \n+    @Override\n+    public Iterator<AnnotatedParameter> getConstructorParameters() {\n+        AnnotatedParameter param = getConstructorParameter();\n+        if (param == null) {\n+            return EmptyIterator.instance();\n+        }\n+        return Collections.singleton(param).iterator();\n+    }\n+    \n     /**\n      * Method used to find accessor (getter, field to access) to use for accessing\n      * value of the property.\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n         /**********************************************************\n          */\n \n-        @Deprecated // since 2.3\n-        protected Parser(Segment firstSeg, ObjectCodec codec) {\n-            this(firstSeg, codec, false, false);\n-        }\n-\n-        /**\n-         * @since 2.3\n-         */\n         public Parser(Segment firstSeg, ObjectCodec codec,\n                 boolean hasNativeTypeIds,\n                 boolean hasNativeObjectIds)\n--- a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonValue;\n-\n import com.fasterxml.jackson.databind.ObjectMapper;\n-\n-import com.fasterxml.jackson.test.BaseTest;\n \n public abstract class BaseMapTest\n     extends BaseTest\n     {\n         return readAndMapFromString(SHARED_MAPPER, input, cls);\n     }\n-    \n-    protected <T> T readAndMapFromString(ObjectMapper m, String input, Class<T> cls)\n-        throws IOException\n+\n+    protected <T> T readAndMapFromString(ObjectMapper m, String input, Class<T> cls) throws IOException\n     {\n         return (T) m.readValue(\"\\\"\"+input+\"\\\"\", cls);\n     }\n     /* Helper methods, other\n     /**********************************************************\n      */\n-    \n+\n     protected TimeZone getUTCTimeZone() {\n         return TimeZone.getTimeZone(\"GMT\");\n     }\n         }\n     }\n \n-    protected String aposToQuotes(String json) {\n+    protected static String aposToQuotes(String json) {\n         return json.replace(\"'\", \"\\\"\");\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/BaseTest.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+//import static org.junit.Assert.*;\n+\n+public abstract class BaseTest\n+    extends TestCase\n+{\n+    /*\n+    /**********************************************************\n+    /* Some sample documents:\n+    /**********************************************************\n+     */\n+\n+    protected final static int SAMPLE_SPEC_VALUE_WIDTH = 800;\n+    protected final static int SAMPLE_SPEC_VALUE_HEIGHT = 600;\n+    protected final static String SAMPLE_SPEC_VALUE_TITLE = \"View from 15th Floor\";\n+    protected final static String SAMPLE_SPEC_VALUE_TN_URL = \"http://www.example.com/image/481989943\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_HEIGHT = 125;\n+    protected final static String SAMPLE_SPEC_VALUE_TN_WIDTH = \"100\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID1 = 116;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID2 = 943;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID3 = 234;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID4 = 38793;\n+\n+    protected final static String SAMPLE_DOC_JSON_SPEC = \n+        \"{\\n\"\n+        +\"  \\\"Image\\\" : {\\n\"\n+        +\"    \\\"Width\\\" : \"+SAMPLE_SPEC_VALUE_WIDTH+\",\\n\"\n+        +\"    \\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_HEIGHT+\",\"\n+        +\"\\\"Title\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TITLE+\"\\\",\\n\"\n+        +\"    \\\"Thumbnail\\\" : {\\n\"\n+        +\"      \\\"Url\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_URL+\"\\\",\\n\"\n+        +\"\\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_TN_HEIGHT+\",\\n\"\n+        +\"      \\\"Width\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_WIDTH+\"\\\"\\n\"\n+        +\"    },\\n\"\n+        +\"    \\\"IDs\\\" : [\"+SAMPLE_SPEC_VALUE_TN_ID1+\",\"+SAMPLE_SPEC_VALUE_TN_ID2+\",\"+SAMPLE_SPEC_VALUE_TN_ID3+\",\"+SAMPLE_SPEC_VALUE_TN_ID4+\"]\\n\"\n+        +\"  }\"\n+        +\"}\"\n+        ;\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes (beans)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Sample class from Jackson tutorial (\"JacksonInFiveMinutes\")\n+     */\n+    protected static class FiveMinuteUser {\n+        public enum Gender { MALE, FEMALE };\n+\n+        public static class Name\n+        {\n+          private String _first, _last;\n+\n+          public Name() { }\n+          public Name(String f, String l) {\n+              _first = f;\n+              _last = l;\n+          }\n+          \n+          public String getFirst() { return _first; }\n+          public String getLast() { return _last; }\n+\n+          public void setFirst(String s) { _first = s; }\n+          public void setLast(String s) { _last = s; }\n+\n+          @Override\n+          public boolean equals(Object o)\n+          {\n+              if (o == this) return true;\n+              if (o == null || o.getClass() != getClass()) return false;\n+              Name other = (Name) o;\n+              return _first.equals(other._first) && _last.equals(other._last); \n+          }\n+        }\n+\n+        private Gender _gender;\n+        private Name _name;\n+        private boolean _isVerified;\n+        private byte[] _userImage;\n+\n+        public FiveMinuteUser() { }\n+\n+        public FiveMinuteUser(String first, String last, boolean verified, Gender g, byte[] data)\n+        {\n+            _name = new Name(first, last);\n+            _isVerified = verified;\n+            _gender = g;\n+            _userImage = data;\n+        }\n+        \n+        public Name getName() { return _name; }\n+        public boolean isVerified() { return _isVerified; }\n+        public Gender getGender() { return _gender; }\n+        public byte[] getUserImage() { return _userImage; }\n+\n+        public void setName(Name n) { _name = n; }\n+        public void setVerified(boolean b) { _isVerified = b; }\n+        public void setGender(Gender g) { _gender = g; }\n+        public void setUserImage(byte[] b) { _userImage = b; }\n+\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this) return true;\n+            if (o == null || o.getClass() != getClass()) return false;\n+            FiveMinuteUser other = (FiveMinuteUser) o;\n+            if (_isVerified != other._isVerified) return false;\n+            if (_gender != other._gender) return false; \n+            if (!_name.equals(other._name)) return false;\n+            byte[] otherImage = other._userImage;\n+            if (otherImage.length != _userImage.length) return false;\n+            for (int i = 0, len = _userImage.length; i < len; ++i) {\n+                if (_userImage[i] != otherImage[i]) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* High-level helpers\n+    /**********************************************************\n+     */\n+\n+    protected void verifyJsonSpecSampleDoc(JsonParser jp, boolean verifyContents)\n+        throws IOException\n+    {\n+        verifyJsonSpecSampleDoc(jp, verifyContents, true);\n+    }\n+\n+    protected void verifyJsonSpecSampleDoc(JsonParser jp, boolean verifyContents,\n+            boolean requireNumbers)\n+        throws IOException\n+    {\n+        if (!jp.hasCurrentToken()) {\n+            jp.nextToken();\n+        }\n+        assertToken(JsonToken.START_OBJECT, jp.getCurrentToken()); // main object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Image'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Image\");\n+        }\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Width\");\n+        }\n+\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_WIDTH);\n+        }\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Height\");\n+        }\n+\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_HEIGHT);\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Title'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Title\");\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Thumbnail'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Thumbnail\");\n+        }\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Url'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Url\");\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (verifyContents) {\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(jp));\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Height\");\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_HEIGHT);\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Width\");\n+        }\n+        // Width value is actually a String in the example\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (verifyContents) {\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(jp));\n+        }\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'IDs'\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken()); // 'ids' array\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[0]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID1);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[1]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID2);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[2]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID3);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[3]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID4);\n+        }\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // main object\n+    }\n+\n+    private void verifyIntToken(JsonToken t, boolean requireNumbers)\n+    {\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return;\n+        }\n+        if (requireNumbers) { // to get error\n+            assertToken(JsonToken.VALUE_NUMBER_INT, t);\n+        }\n+        // if not number, must be String\n+        if (t != JsonToken.VALUE_STRING) {\n+            fail(\"Expected INT or STRING value, got \"+t);\n+        }\n+    }\n+    \n+    protected void verifyFieldName(JsonParser jp, String expName)\n+        throws IOException\n+    {\n+        assertEquals(expName, jp.getText());\n+        assertEquals(expName, jp.getCurrentName());\n+    }\n+\n+    protected void verifyIntValue(JsonParser jp, long expValue)\n+        throws IOException\n+    {\n+        // First, via textual\n+        assertEquals(String.valueOf(expValue), jp.getText());\n+    }\n+\n+    /**\n+     * Method that checks whether Unit tests appear to run from Ant build\n+     * scripts.\n+     * \n+     * @since 1.6\n+     */\n+    protected static boolean runsFromAnt() {\n+        return \"true\".equals(System.getProperty(\"FROM_ANT\"));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Parser/generator construction\n+    /**********************************************************\n+     */\n+\n+    protected JsonParser createParserUsingReader(String input)\n+        throws IOException, JsonParseException\n+    {\n+        return createParserUsingReader(new JsonFactory(), input);\n+    }\n+\n+    protected JsonParser createParserUsingReader(JsonFactory f, String input)\n+        throws IOException, JsonParseException\n+    {\n+        return f.createParser(new StringReader(input));\n+    }\n+\n+    protected JsonParser createParserUsingStream(String input, String encoding)\n+        throws IOException, JsonParseException\n+    {\n+        return createParserUsingStream(new JsonFactory(), input, encoding);\n+    }\n+\n+    protected JsonParser createParserUsingStream(JsonFactory f,\n+                                                 String input, String encoding)\n+        throws IOException, JsonParseException\n+    {\n+\n+        /* 23-Apr-2008, tatus: UTF-32 is not supported by JDK, have to\n+         *   use our own codec too (which is not optimal since there's\n+         *   a chance both encoder and decoder might have bugs, but ones\n+         *   that cancel each other out or such)\n+         */\n+        byte[] data;\n+        if (encoding.equalsIgnoreCase(\"UTF-32\")) {\n+            data = encodeInUTF32BE(input);\n+        } else {\n+            data = input.getBytes(encoding);\n+        }\n+        InputStream is = new ByteArrayInputStream(data);\n+        return f.createParser(is);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Additional assertion methods\n+    /**********************************************************\n+     */\n+\n+    protected void assertToken(JsonToken expToken, JsonToken actToken)\n+    {\n+        if (actToken != expToken) {\n+            fail(\"Expected token \"+expToken+\", current token \"+actToken);\n+        }\n+    }\n+\n+    protected void assertToken(JsonToken expToken, JsonParser jp)\n+    {\n+        assertToken(expToken, jp.getCurrentToken());\n+    }\n+\n+    protected void assertType(Object ob, Class<?> expType)\n+    {\n+        if (ob == null) {\n+            fail(\"Expected an object of type \"+expType.getName()+\", got null\");\n+        }\n+        Class<?> cls = ob.getClass();\n+        if (!expType.isAssignableFrom(cls)) {\n+            fail(\"Expected type \"+expType.getName()+\", got \"+cls.getName());\n+        }\n+    }\n+\n+    protected void assertValidLocation(JsonLocation location) {\n+        assertNotNull(\"Should have non-null location\", location);\n+        assertTrue(\"Should have positive line number\", location.getLineNr() > 0);\n+    }\n+\n+    protected void verifyException(Throwable e, String... matches)\n+    {\n+        String msg = e.getMessage();\n+        String lmsg = (msg == null) ? \"\" : msg.toLowerCase();\n+        for (String match : matches) {\n+            String lmatch = match.toLowerCase();\n+            if (lmsg.indexOf(lmatch) >= 0) {\n+                return;\n+            }\n+        }\n+        fail(\"Expected an exception with one of substrings (\"+Arrays.asList(matches)+\"): got one with message \\\"\"+msg+\"\\\"\");\n+    }\n+\n+    /**\n+     * Method that gets textual contents of the current token using\n+     * available methods, and ensures results are consistent, before\n+     * returning them\n+     */\n+    protected String getAndVerifyText(JsonParser jp)\n+        throws IOException, JsonParseException\n+    {\n+        // Ok, let's verify other accessors\n+        int actLen = jp.getTextLength();\n+        char[] ch = jp.getTextCharacters();\n+        String str2 = new String(ch, jp.getTextOffset(), actLen);\n+        String str = jp.getText();\n+\n+        if (str.length() !=  actLen) {\n+            fail(\"Internal problem (jp.token == \"+jp.getCurrentToken()+\"): jp.getText().length() ['\"+str+\"'] == \"+str.length()+\"; jp.getTextLength() == \"+actLen);\n+        }\n+        assertEquals(\"String access via getText(), getTextXxx() must be the same\", str, str2);\n+\n+        return str;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* And other helpers\n+    /**********************************************************\n+     */\n+\n+    protected byte[] encodeInUTF32BE(String input)\n+    {\n+        int len = input.length();\n+        byte[] result = new byte[len * 4];\n+        int ptr = 0;\n+        for (int i = 0; i < len; ++i, ptr += 4) {\n+            char c = input.charAt(i);\n+            result[ptr] = result[ptr+1] = (byte) 0;\n+            result[ptr+2] = (byte) (c >> 8);\n+            result[ptr+3] = (byte) c;\n+        }\n+        return result;\n+    }\n+\n+    public String quote(String str) {\n+        return '\"'+str+'\"';\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/BrokenStringReader.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+\n+public class BrokenStringReader\n+    extends FilterReader\n+{\n+    final String _message;\n+\n+    public BrokenStringReader(String content, String msg)\n+    {\n+        super(new StringReader(content));\n+        _message = msg;\n+    }\n+\n+    @Override\n+    public int read(char[] cbuf, int off, int len)\n+        throws IOException\n+    {\n+        int i = super.read(cbuf, off, len);\n+        if (i < 0) {\n+            throw new IOException(_message);\n+        }\n+        return i;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/BrokenStringWriter.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+\n+public class BrokenStringWriter\n+    extends FilterWriter\n+{\n+    final String _message;\n+\n+    public BrokenStringWriter(String msg) {\n+        super(new StringWriter());\n+        _message = msg;\n+    }\n+\n+    @Override\n+    public void write(char[] cbuf, int off, int len) throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+    \n+    @Override\n+    public void write(int c) throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+    \n+    @Override\n+    public void write(String str, int off, int len)  throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n         StringReader r = new StringReader(\"{}\");\n         //  bit ugly, but can't think of cleaner simple way to check this...\n         try {\n-            mapper.reader(s).withType(Object.class).readValue(r);\n+            mapper.reader(s).forType(Object.class).readValue(r);\n             fail(\"Excpected exception\");\n         } catch (SchemaException e) {\n             assertSame(s, e._schema);\n--- a/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n-\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n public class TestHandlerInstantiation extends BaseMapTest\n     }\n     \n     // copied from \"TestCustomTypeIdResolver\"\n-    static class CustomIdResolver implements TypeIdResolver\n+    static class CustomIdResolver extends TypeIdResolverBase\n     {\n         static List<JavaType> initTypes;\n \n         public CustomIdResolver(String idForBean) {\n             _id = idForBean;\n         }\n-        \n+\n         @Override\n         public Id getMechanism() {\n             return Id.CUSTOM;\n         }\n+\n         @Override\n         public String idFromValue(Object value)\n         {\n             }\n             return \"unknown\";\n         }\n+\n         @Override\n         public String idFromValueAndType(Object value, Class<?> type) {\n             return idFromValue(value);\n         }\n+\n         @Override\n         public void init(JavaType baseType) {\n             if (initTypes != null) {\n                 initTypes.add(baseType);\n             }\n         }\n-        @Override\n-        public JavaType typeFromId(String id)\n+\n+        @Override\n+        public JavaType typeFromId(DatabindContext context, String id)\n         {\n             if (id.equals(_id)) {\n                 return TypeFactory.defaultInstance().constructType(TypeIdBean.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n {\n     static class MyPojo {\n         public int x;\n-        private int y;\n+        protected int y;\n         \n         public MyPojo() { }\n         public MyPojo(int x0, int y0) {\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n package com.fasterxml.jackson.databind;\n \n import java.io.*;\n+import java.util.*;\n \n import com.fasterxml.jackson.core.JsonFactory;\n import com.fasterxml.jackson.core.JsonParser;\n-\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\n import com.fasterxml.jackson.databind.node.*;\n     public void testProviderConfig() throws Exception   \n     {\n         ObjectMapper m = new ObjectMapper();\n+        final String JSON = \"{ \\\"x\\\" : 3 }\";\n \n         assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n         // and then should get one constructed for:\n-        Bean bean = m.readValue(\"{ \\\"x\\\" : 3 }\", Bean.class);\n+        Bean bean = m.readValue(JSON, Bean.class);\n         assertNotNull(bean);\n         assertEquals(1, m._deserializationContext._cache.cachedDeserializersCount());\n         m._deserializationContext._cache.flushCachedDeserializers();\n         assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n+\n+        // 07-Nov-2014, tatu: As per [databind#604] verify that Maps also get cached\n+        m = new ObjectMapper();\n+        List<?> stuff = m.readValue(\"[ ]\", List.class);\n+        assertNotNull(stuff);\n+        // may look odd, but due to \"Untyped\" deserializer thing, we actually have\n+        // 3 deserializers (List<?>, Map<?,?>, Object)\n+        assertEquals(3, m._deserializationContext._cache.cachedDeserializersCount());\n     }\n     \n     // [Issue#28]: ObjectMapper.copy()\n         assertEquals(0, m.getDeserializationConfig().mixInCount());\n         assertEquals(0, m2.getDeserializationConfig().mixInCount());\n \n-        m.addMixInAnnotations(String.class, Integer.class);\n+        m.addMixIn(String.class, Integer.class);\n         assertEquals(1, m.getSerializationConfig().mixInCount());\n         assertEquals(0, m2.getSerializationConfig().mixInCount());\n         assertEquals(1, m.getDeserializationConfig().mixInCount());\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanDeserializer.java\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Unit tests for verifying deserialization of Beans.\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanSerializer.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * This unit test suite tries to verify that the \"Native\" java type\n         THIS_IS_AN_ENUM_VALUE_3,\n     }\n \n-    @SuppressWarnings(\"unused\")\n-    private static class FixtureObjectBase\n+    static class FixtureObjectBase\n     {\n         public static final String       VALUE_STRING = \"foobar\";\n         public static final EFixtureEnum VALUE_ENUM   = EFixtureEnum.THIS_IS_AN_ENUM_VALUE_2;\n         }\n     }\n \n-    @SuppressWarnings(\"unused\")\n-    private static class FixtureObject extends FixtureObjectBase\n-    {\n-        public Exception getTestError()\n-        {\n+    static class FixtureObject extends FixtureObjectBase\n+    {\n+        public Exception getTestError() {\n             return new Exception(VALUE_ERRTXT);\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n-public class TestParserUsingMapper  extends com.fasterxml.jackson.test.BaseTest\n+public class TestParserUsingMapper  extends BaseMapTest\n {\n     final static int TWO_BYTE_ESCAPED = 0x111;\n     final static int THREE_BYTE_ESCAPED = 0x1111;\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);\n-        assertEquals(quote(\"\\\\u0101\"), mapper.writeValueAsString(String.valueOf((char) 257)));\n+        mapper.writeValueAsString(String.valueOf((char) 257));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n  * Tests to ensure that we get proper Version information via\n  * things defined as Versioned.\n  */\n-public class TestVersions extends com.fasterxml.jackson.test.BaseTest\n+public class TestVersions extends BaseMapTest\n {\n     public void testMapperVersions()\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/access/TestSerAnyGetter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/access/TestSerAnyGetter.java\n         }\n     }\n \n-    private static class PrivateThing\n+    static class PrivateThing\n     {\n         @JsonAnyGetter\n         public Map<?,?> getProperties()\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextAttributeWithDeser.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextAttributeWithDeser.java\n \n         // as above, should not carry on state\n         TestPOJO pojo2 = MAPPER.reader(TestPOJO.class)\n-                .withAttribute(KEY, Integer.valueOf(3))\n+                .withAttribute(KEY, Integer.valueOf(5))\n                 .readValue(INPUT);\n-        assertEquals(\"x/3\", pojo2.value);\n+        assertEquals(\"x/5\", pojo2.value);\n     }\n \n     public void testHierarchic() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextAttributeWithSer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextAttributeWithSer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer;\n public class TestContextAttributeWithSer extends BaseMapTest\n {\n     final static String KEY = \"foobar\";\n-    \n+\n+    @SuppressWarnings(\"serial\")\n     static class PrefixStringSerializer extends StdScalarSerializer<String>\n     {\n         protected PrefixStringSerializer() {\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualDeserialization.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n-\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n \n /**\n  * that can use contextual information (like field/method\n  * annotations) for configuration.\n  */\n+@SuppressWarnings(\"serial\")\n public class TestContextualDeserialization extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n-    /* NOTE: important; MUST be considered a 'Jackson' annotation to be seen\n-     * (or recognized otherwise via AnnotationIntrospect.isHandled())\n-     */\n     @Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})\n     @Retention(RetentionPolicy.RUNTIME)\n     @JacksonAnnotation\n             String propertyName = (ann == null) ?  \"UNKNOWN\" : ann.value();\n             return new MyContextualDeserializer(propertyName);\n         }\n+    }\n+\n+    static class GenericStringDeserializer\n+        extends StdScalarDeserializer<Object>\n+        implements ContextualDeserializer\n+    {\n+        final String _value;\n+\n+        public GenericStringDeserializer() { this(\"N/A\"); }\n+        protected GenericStringDeserializer(String value) {\n+            super(String.class);\n+            _value = value;\n+        }\n+\n+        @Override\n+        public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property) {\n+            return new GenericStringDeserializer(String.valueOf(ctxt.getContextualType().getRawClass().getSimpleName()));\n+        }\n+\n+        @Override\n+        public Object deserialize(JsonParser p, DeserializationContext ctxt) {\n+            return _value;\n+        }\n+    }\n+\n+    static class GenericBean {\n+        @JsonDeserialize(contentUsing=GenericStringDeserializer.class)\n+        public Map<Integer, String> stuff;\n     }\n     \n     /*\n         assertEquals(\"1\", entry.getKey());\n         assertEquals(\"map=2\", entry.getValue().value);\n     }\n-    \n+\n+    // for [databind#165]\n+    public void testContextualType() throws Exception {\n+        GenericBean bean = new ObjectMapper().readValue(aposToQuotes(\"{'stuff':{'1':'b'}}\"),\n+                GenericBean.class);\n+        assertNotNull(bean.stuff);\n+        assertEquals(1, bean.stuff.size());\n+        assertEquals(\"String\", bean.stuff.get(Integer.valueOf(1)));\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper methods\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualKeyTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualKeyTypes.java\n         mapper.registerModule(module);\n         Map<String,Object> input = new HashMap<String,Object>();\n         input.put(\"a\", Integer.valueOf(3));\n-        String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class))\n+        String json = mapper.writerFor(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class))\n             .writeValueAsString(input);\n         assertEquals(\"{\\\"prefix:a\\\":3}\", json);\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/DisablingCreatorsTest.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Tests to ensure one can disable {@link JsonCreator} annotations.\n+ */\n+public class DisablingCreatorsTest extends BaseMapTest\n+{\n+     static class ConflictingCreators {\n+          @JsonCreator(mode=JsonCreator.Mode.PROPERTIES)\n+          public ConflictingCreators(@JsonProperty(\"foo\") String foo) { }\n+          @JsonCreator(mode=JsonCreator.Mode.PROPERTIES)\n+          public ConflictingCreators(@JsonProperty(\"foo\") String foo,\n+                    @JsonProperty(\"value\") int value) { }\n+     }\n+\n+     static class NonConflictingCreators {\n+          public String _value;\n+          \n+          @JsonCreator(mode=JsonCreator.Mode.DELEGATING)\n+          public NonConflictingCreators(String foo) { _value = foo; }\n+\n+          @JsonCreator(mode=JsonCreator.Mode.DISABLED)\n+          public NonConflictingCreators(String foo, int value) { }\n+     }\n+\n+     /*\n+     /**********************************************************\n+     /* Helper methods\n+     /**********************************************************\n+      */\n+\n+     public void testDisabling() throws Exception\n+     {\n+          final ObjectMapper mapper = objectMapper();\n+\n+          // first, non-problematic case\n+          NonConflictingCreators value = mapper.readValue(quote(\"abc\"), NonConflictingCreators.class);\n+          assertNotNull(value);\n+          assertEquals(\"abc\", value._value);\n+\n+          // then something that ought to fail\n+          try {\n+               /*ConflictingCreators value =*/ mapper.readValue(quote(\"abc\"), ConflictingCreators.class);\n+               fail(\"Should have failed with JsonCreator conflict\");\n+          } catch (JsonProcessingException e) {\n+               verifyException(e, \"Conflicting property-based creators\");\n+          }\n+     }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/ImplicitParamsForCreatorTest.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+\n+public class ImplicitParamsForCreatorTest extends BaseMapTest\n+{\n+    @SuppressWarnings(\"serial\")\n+    static class MyParamIntrospector extends JacksonAnnotationIntrospector\n+    {\n+        @Override\n+        public String findImplicitPropertyName(AnnotatedMember param) {\n+            if (param instanceof AnnotatedParameter) {\n+                AnnotatedParameter ap = (AnnotatedParameter) param;\n+                return \"param\"+ap.getIndex();\n+            }\n+            return super.findImplicitPropertyName(param);\n+        }\n+    }\n+\n+    static class XY {\n+        protected int x, y;\n+\n+        @JsonCreator\n+        public XY(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testNonSingleArgCreator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setAnnotationIntrospector(new MyParamIntrospector());\n+        XY value = mapper.readValue(aposToQuotes(\"{'param0':1,'param1':2}\"), XY.class);\n+        assertNotNull(value);\n+        assertEquals(1, value.x);\n+        assertEquals(2, value.y);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java\n package com.fasterxml.jackson.databind.creators;\n \n import com.fasterxml.jackson.annotation.*;\n-\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n \n public class SingleArgCreatorTest extends BaseMapTest\n {\n-    // [Issue#430]: single arg BUT named; should not delegate\n+    // [databind#430]: single arg BUT named; should not delegate\n \n     static class SingleNamedStringBean {\n-\n         final String _ss;\n \n         @JsonCreator\n         public String getSs() { return _ss; }\n     }\n \n+    // For [databind#614]\n+    static class SingleNamedButStillDelegating {\n+        protected final String value;\n+\n+        @JsonCreator(mode=JsonCreator.Mode.DELEGATING)\n+        public SingleNamedButStillDelegating(@JsonProperty(\"foobar\") String v){\n+            value = v;\n+        }\n+\n+        public String getFoobar() { return \"x\"; }\n+    }\n+    \n+    // [databind#557]\n+    \n+    static class StringyBean\n+    {\n+        public final String value;\n+\n+        private StringyBean(String value) { this.value = value; }\n+\n+        public String getValue() {\n+            return value;\n+        }\n+    }\n+\n+    static class StringyBeanWithProps\n+    {\n+        public final String value;\n+\n+        @JsonCreator\n+        private StringyBeanWithProps(String v) { value = v; }\n+\n+        public String getValue() {\n+            return value;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MyParamIntrospector extends JacksonAnnotationIntrospector\n+    {\n+        private final String name;\n+        \n+        public MyParamIntrospector(String n) { name = n; }\n+        \n+        @Override\n+        public String findImplicitPropertyName(AnnotatedMember param) {\n+            if (param instanceof AnnotatedParameter) {\n+                AnnotatedParameter ap = (AnnotatedParameter) param;\n+                switch (ap.getIndex()) {\n+                case 0: return name;\n+                }\n+                return \"param\"+ap.getIndex();\n+            }\n+            return super.findImplicitPropertyName(param);\n+        }\n+    }\n+\n+    // [databind#660]\n+    static class ExplicitFactoryBeanA {\n+        private String value;\n+\n+        private ExplicitFactoryBeanA(String str) {\n+            throw new IllegalStateException(\"Should not get called!\");\n+        }\n+\n+        private ExplicitFactoryBeanA(String str, boolean b) {\n+            value = str;\n+        }\n+\n+        @JsonCreator\n+        public static ExplicitFactoryBeanA create(String str) {\n+            ExplicitFactoryBeanA bean = new ExplicitFactoryBeanA(str, false);\n+            bean.value = str;\n+            return bean;\n+        }\n+\n+        public String value() { return value; }\n+    }\n+\n+    // [databind#660]\n+    static class ExplicitFactoryBeanB {\n+        private String value;\n+\n+        @JsonCreator\n+        private ExplicitFactoryBeanB(String str) {\n+            value = str;\n+        }\n+\n+        public static ExplicitFactoryBeanB valueOf(String str) {\n+            return new ExplicitFactoryBeanB(null);\n+        }\n+\n+        public String value() { return value; }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Test methods\n     /**********************************************************\n      */\n-    \n+\n     private final ObjectMapper MAPPER = objectMapper();\n \n     public void testNamedSingleArg() throws Exception\n                 SingleNamedStringBean.class);\n         assertEquals(\"foobar\", bean._ss);\n     }\n+\n+    public void testSingleStringArgWithImplicitName() throws Exception\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.setAnnotationIntrospector(new MyParamIntrospector(\"value\"));\n+        StringyBean bean = mapper.readValue(quote(\"foobar\"), StringyBean.class);\n+        assertEquals(\"foobar\", bean.getValue());\n+    }    \n+\n+    // [databind#714]\n+    public void testSingleImplicitlyNamedNotDelegating() throws Exception\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.setAnnotationIntrospector(new MyParamIntrospector(\"value\"));\n+        StringyBeanWithProps bean = mapper.readValue(\"{\\\"value\\\":\\\"x\\\"}\", StringyBeanWithProps.class);\n+        assertEquals(\"x\", bean.getValue());\n+    }    \n+    \n+    // [databind#714]\n+    public void testSingleExplicitlyNamedButDelegating() throws Exception\n+    {\n+        SingleNamedButStillDelegating bean = MAPPER.readValue(quote(\"xyz\"),\n+                SingleNamedButStillDelegating.class);\n+        assertEquals(\"xyz\", bean.value);\n+    }\n+\n+    public void testExplicitFactory660a() throws Exception\n+    {\n+        // First, explicit override for factory\n+        ExplicitFactoryBeanA bean = MAPPER.readValue(quote(\"abc\"), ExplicitFactoryBeanA.class);\n+        assertNotNull(bean);\n+        assertEquals(\"abc\", bean.value());\n+    }\n+\n+    public void testExplicitFactory660b() throws Exception\n+    {\n+        // and then one for private constructor\n+        ExplicitFactoryBeanB bean2 = MAPPER.readValue(quote(\"def\"), ExplicitFactoryBeanB.class);\n+        assertNotNull(bean2);\n+        assertEquals(\"def\", bean2.value());\n+    }\n }\n+\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java\n         }\n     }\n \n-    @SuppressWarnings(\"hiding\")\n     static class SimpleBuilderXY\n     {\n         public int x, y;\n     \t\n-        public SimpleBuilderXY withX(int x) {\n-    \t\t    this.x = x;\n+        public SimpleBuilderXY withX(int x0) {\n+    \t\t    this.x = x0;\n     \t\t    return this;\n         }\n \n-        public SimpleBuilderXY withY(int y) {\n-    \t\t    this.y = y;\n+        public SimpleBuilderXY withY(int y0) {\n+    \t\t    this.y = y0;\n     \t\t    return this;\n         }\n \n         }\n     }\n \n-    @SuppressWarnings(\"hiding\")\n     static class BuildABC\n     {\n         public int a; // to be used as is\n         private int b, c;\n     \t\n         @JsonProperty(\"b\")\n-        public BuildABC assignB(int b) {\n-            this.b = b;\n+        public BuildABC assignB(int b0) {\n+            this.b = b0;\n             return this;\n         }\n \n         // Also ok NOT to return 'this'\n         @JsonSetter(\"c\")\n-        public void c(int c) {\n-            this.c = c;\n+        public void c(int c0) {\n+            this.c = c0;\n         }\n \n         public ValueClassABC build() {\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorNullValue.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorNullValue.java\n package com.fasterxml.jackson.databind.creators;\n \n+import java.io.IOException;\n+import java.util.UUID;\n+\n import com.fasterxml.jackson.annotation.*;\n-\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.*;\n \n-// Mostly for [JACSON-774]\n public class TestCreatorNullValue extends BaseMapTest\n {\n     protected static class Container {\n         }\n     }\n \n-    private static interface Contained<T> {}\n+    protected static interface Contained<T> {}\n \n-    private static class NullContained implements Contained<Object> {}\n+    protected static class NullContained implements Contained<Object> {}\n \n-    private static final NullContained NULL_CONTAINED = new NullContained();\n+    protected static final NullContained NULL_CONTAINED = new NullContained();\n \n-    private static class ContainedDeserializer extends JsonDeserializer<Contained<?>> {\n+    protected static class ContainedDeserializer extends JsonDeserializer<Contained<?>> {\n         @Override\n         public Contained<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws JsonProcessingException {\n             return null;\n         }\n     }\n \n-    private static class ContainerDeserializerResolver extends Deserializers.Base {\n+    protected static class ContainerDeserializerResolver extends Deserializers.Base {\n         @Override\n         public JsonDeserializer<?> findBeanDeserializer(JavaType type,\n                 DeserializationConfig config, BeanDescription beanDesc)\n         {\n             if (!Contained.class.isAssignableFrom(type.getRawClass())) {\n                 return null;\n-            } else {\n-                return new ContainedDeserializer();\n             }\n+            return new ContainedDeserializer();\n         }\n     }\n \n-    private static class TestModule extends Module\n+    protected static class TestModule extends Module\n     {\n         @Override\n         public String getModuleName() {\n         }\n     }\n \n+    // [databind#597]\n+    static class JsonEntity {\n+        protected final String type;\n+        protected final UUID id;\n+\n+        private JsonEntity(String type, UUID id) {\n+            this.type = type;\n+            this.id = id;\n+        }\n+\n+        @JsonCreator\n+        public static JsonEntity create(@JsonProperty(\"type\") String type, @JsonProperty(\"id\") UUID id) {\n+            if (type != null && !type.contains(\" \") && (id != null)) {\n+                return new JsonEntity(type, id);\n+            }\n+\n+            return null;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         Container container = mapper.readValue(\"{}\", Container.class);\n         assertEquals(NULL_CONTAINED, container.contained);\n     }\n+\n+    // [databind#597]: ensure that a useful exception is thrown\n+    public void testCreatorReturningNull() throws IOException {\n+        ObjectMapper objectMapper = new ObjectMapper();\n+        String json = \"{ \\\"type\\\" : \\\"     \\\", \\\"id\\\" : \\\"000c0ffb-a0d6-4d2e-a379-4aeaaf283599\\\" }\";\n+        try {\n+            objectMapper.readValue(json, JsonEntity.class);\n+            fail(\"Should not have succeeded\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"JSON creator returned null\");\n+        }\n+    }    \n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorWithNamingStrategy556.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+\n+public class TestCreatorWithNamingStrategy556\n+    extends BaseMapTest\n+{\n+    static class RenamingCtorBean\n+    {\n+        protected String myName;\n+        protected int myAge;\n+\n+        @JsonCreator\n+        public RenamingCtorBean(int myAge, String myName)\n+        {\n+            this.myName = myName;\n+            this.myAge = myAge;\n+        }\n+    }\n+\n+    // Try the same with factory, too\n+    static class RenamedFactoryBean\n+    {\n+        protected String myName;\n+        protected int myAge;\n+\n+        private RenamedFactoryBean(int a, String n, boolean foo) {\n+            myAge = a;\n+            myName = n;\n+        }\n+        \n+        @JsonCreator\n+        public static RenamedFactoryBean create(int age, String name) {\n+            return new RenamedFactoryBean(age, name, true);\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    static class MyParamIntrospector extends JacksonAnnotationIntrospector\n+    {\n+        @Override\n+        public String findImplicitPropertyName(AnnotatedMember param) {\n+            if (param instanceof AnnotatedParameter) {\n+                AnnotatedParameter ap = (AnnotatedParameter) param;\n+                switch (ap.getIndex()) {\n+                case 0: return \"myAge\";\n+                case 1: return \"myName\";\n+                default:\n+                    return \"param\"+ap.getIndex();\n+                }\n+            }\n+            return super.findImplicitPropertyName(param);\n+        }\n+    }\n+    \n+    private final ObjectMapper MAPPER = new ObjectMapper()\n+            .setPropertyNamingStrategy(PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE)\n+            ;\n+    {\n+        MAPPER.setAnnotationIntrospector(new MyParamIntrospector());\n+    }\n+\n+    private final static String CTOR_JSON = aposToQuotes(\"{ 'MyAge' : 42,  'MyName' : 'NotMyRealName' }\");\n+    \n+    public void testRenameViaCtor() throws Exception\n+    {\n+        RenamingCtorBean bean = MAPPER.readValue(CTOR_JSON, RenamingCtorBean.class);\n+        assertEquals(42, bean.myAge);\n+        assertEquals(\"NotMyRealName\", bean.myName);\n+    }\n+\n+    public void testRenameViaFactory() throws Exception\n+    {\n+        RenamedFactoryBean bean = MAPPER.readValue(CTOR_JSON, RenamedFactoryBean.class);\n+        assertEquals(42, bean.myAge);\n+        assertEquals(\"NotMyRealName\", bean.myName);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorWithPolymorphic113.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Test(s) for [Issue#113], problems with polymorphic types, JsonCreator.\n+ */\n+public class TestCreatorWithPolymorphic113 extends BaseMapTest\n+{\n+    @JsonIgnoreProperties(ignoreUnknown = true)\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = \"_class\")\n+    @JsonSubTypes({  @JsonSubTypes.Type(Dog.class) })\n+    public static abstract class Animal {\n+        public final static String ID = \"id\";\n+\n+        private String id;\n+\n+        @JsonCreator\n+        public Animal(@JsonProperty(ID) String id) {\n+            this.id = id;\n+        }\n+\n+        @JsonProperty(ID)\n+        public String getId() {\n+            return id;\n+        }\n+    }\n+\n+    @JsonIgnoreProperties(ignoreUnknown = true)\n+    public static class Dog extends Animal {\n+        @JsonCreator\n+        public Dog(@JsonProperty(ID) String id) {\n+            super(id);\n+        }\n+    }\n+\n+    @JsonIgnoreProperties(ignoreUnknown = true)\n+    public static class AnimalWrapper {\n+        private Animal animal;\n+\n+        @JsonCreator\n+        public AnimalWrapper(@JsonProperty(\"animal\") Animal animal) {\n+            this.animal = animal;\n+        }\n+\n+        public Animal getAnimal() {\n+            return animal;\n+        }\n+    }\n+\n+    public void testSubtypes() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String id = \"nice dogy\";\n+        String json = mapper.writeValueAsString(new AnimalWrapper(new Dog(id)));\n+//System.err.println(\"JSON = \"+json);\n+        AnimalWrapper wrapper = mapper.readValue(json, AnimalWrapper.class);\n+        assertEquals(id, wrapper.getAnimal().getId());\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators.java\n         bean = MAPPER.readValue(\"0.25\", MultiBean.class);\n         assertEquals(Double.valueOf(0.25), bean.value);\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Test methods, valid cases, deferred, no mixins\n     public void testFactoryCreatorWithMixin() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(CreatorBean.class, MixIn.class);\n+        m.addMixIn(CreatorBean.class, MixIn.class);\n         CreatorBean bean = m.readValue\n             (\"{ \\\"a\\\" : \\\"xyz\\\", \\\"x\\\" : 12 }\", CreatorBean.class);\n         assertEquals(11, bean.x);\n     public void testFactoryCreatorWithRenamingMixin() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(FactoryBean.class, FactoryBeanMixIn.class);\n+        m.addMixIn(FactoryBean.class, FactoryBeanMixIn.class);\n         // override changes property name from \"f\" to \"mixed\"\n         FactoryBean bean = m.readValue(\"{ \\\"mixed\\\" :  20.5 }\", FactoryBean.class);\n         assertEquals(20.5, bean.d);\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators2.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators2.java\n     // For [JACKSON-541]: should not need @JsonCreator if SerializationFeature.AUTO_DETECT_CREATORS is on.\n     static class AutoDetectConstructorBean\n     {\n-    \tprotected final String foo;\n-    \tprotected final String bar;\n-\n-    \tpublic AutoDetectConstructorBean(@JsonProperty(\"bar\") String bar, @JsonProperty(\"foo\") String foo){\n-    \t    this.bar = bar;\n-    \t    this.foo = foo;\n-    \t}\n+        protected final String foo;\n+        protected final String bar;\n+\n+        public AutoDetectConstructorBean(@JsonProperty(\"bar\") String bar,\n+                @JsonProperty(\"foo\") String foo){\n+            this.bar = bar;\n+            this.foo = foo;\n+        }\n     }\n \n     static class BustedCtor {\n     }\n     \n     public void testCreatorMultipleArgumentWithoutAnnotation() throws Exception {\n-        AutoDetectConstructorBean value = MAPPER.readValue(\"{\\\"bar\\\":\\\"bar\\\",\\\"foo\\\":\\\"foo\\\"}\", AutoDetectConstructorBean.class);\n+        AutoDetectConstructorBean value = MAPPER.readValue(\"{\\\"bar\\\":\\\"bar\\\",\\\"foo\\\":\\\"foo\\\"}\",\n+                AutoDetectConstructorBean.class);\n         assertEquals(\"bar\", value.bar);\n         assertEquals(\"foo\", value.foo);\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators421.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+\n+public class TestCreators421 extends BaseMapTest\n+{\n+    static class MultiCtor\n+    {\n+        protected String _a, _b;\n+        \n+        private MultiCtor() { }\n+        private MultiCtor(String a, String b, Boolean c) {\n+            if (c == null) {\n+                throw new RuntimeException(\"Wrong factory!\");\n+            }\n+            _a = a;\n+            _b = b;\n+        }\n+\n+        @JsonCreator\n+        static MultiCtor factory(@JsonProperty(\"a\") String a, @JsonProperty(\"b\") String b) {\n+            return new MultiCtor(a, b, Boolean.TRUE);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MyParamIntrospector extends JacksonAnnotationIntrospector\n+    {\n+        @Override\n+        public String findImplicitPropertyName(AnnotatedMember param) {\n+            if (param instanceof AnnotatedParameter) {\n+                AnnotatedParameter ap = (AnnotatedParameter) param;\n+                switch (ap.getIndex()) {\n+                case 0: return \"a\";\n+                case 1: return \"b\";\n+                case 2: return \"c\";\n+                default:\n+                    return \"param\"+ap.getIndex();\n+                }\n+            }\n+            return super.findImplicitPropertyName(param);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    // [Issue#421]\n+    public void testMultiCtor421() throws Exception\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.setAnnotationIntrospector(new MyParamIntrospector());\n+\n+        MultiCtor bean = mapper.readValue(aposToQuotes(\"{'a':'123','b':'foo'}\"), MultiCtor.class);\n+        assertNotNull(bean);\n+        assertEquals(\"123\", bean._a);\n+        assertEquals(\"foo\", bean._b);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators541.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators541.java\n     static final class Foo {\n \n         @JsonProperty(\"foo\")\n-        private Map<Integer, Bar> foo;\n+        protected Map<Integer, Bar> foo;\n         @JsonProperty(\"anumber\")\n-        private long anumber;\n+        protected long anumber;\n \n         public Foo() {\n             anumber = 0;\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorsDelegating.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorsDelegating.java\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JacksonInject;\n+\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonToken;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n             return new Value592(buffer, false);\n         }\n     }\n-        \n+\n     /*\n     /**********************************************************\n     /* Unit tests\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestPolymorphicCreators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestPolymorphicCreators.java\n public class TestPolymorphicCreators\n     extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper beans\n-    /**********************************************************\n-     */\n-\n     static class Animal\n     {\n         // All animals have names, for our demo purposes...\n \n     abstract static class AbstractRoot\n     {\n-        private final String opt;\n+        protected final String opt;\n \n-        private AbstractRoot(String opt) {\n+        protected AbstractRoot(String opt) {\n             this.opt = opt;\n         }\n \n         @JsonCreator\n         public static final AbstractRoot make(@JsonProperty(\"which\") int which,\n             @JsonProperty(\"opt\") String opt) {\n-            if(1 == which) {\n+            if (1 == which) {\n                 return new One(opt);\n             }\n             throw new RuntimeException(\"cannot instantiate \" + which);\n         abstract public int getWhich();\n \n         public final String getOpt() {\n-                return opt;\n+            return opt;\n         }\n     }\n \n     static final class One extends AbstractRoot {\n-        private One(String opt) {\n+        protected One(String opt) {\n             super(opt);\n         }\n \n \n     public void testManualPolymorphicWithNumbered() throws Exception\n     {\n-         final ObjectWriter w = MAPPER.writerWithType(AbstractRoot.class);\n+         final ObjectWriter w = MAPPER.writerFor(AbstractRoot.class);\n          final ObjectReader r = MAPPER.reader(AbstractRoot.class);\n \n          AbstractRoot input = AbstractRoot.make(1, \"oh hai!\");\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestPolymorphicDelegating.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestPolymorphicDelegating extends BaseMapTest\n+{\n+\n+    // For [databind#580]\n+    \n+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)\n+    static abstract class Issue580Base {\n+    }\n+\n+    static class Issue580Impl extends Issue580Base {\n+        public int id = 3;\n+\n+        public Issue580Impl() { }\n+        public Issue580Impl(int id) { this.id = id; }\n+    }\n+\n+    static class Issue580Bean {\n+        public Issue580Base value;\n+\n+        @JsonCreator\n+        public Issue580Bean(Issue580Base v) {\n+            value = v;\n+        }\n+\n+        @JsonValue\n+        public Issue580Base value() {\n+            return value;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testAbstractDelegateWithCreator() throws Exception\n+    {\n+        Issue580Bean input = new Issue580Bean(new Issue580Impl(13));\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(input);\n+\n+        Issue580Bean result = mapper.readValue(json, Issue580Bean.class);\n+        assertNotNull(result);\n+        assertNotNull(result.value);\n+        assertEquals(13, ((Issue580Impl) result.value).id);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestValueUpdate.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestValueUpdate.java\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.test.BaseTest;\n \n-public class TestValueUpdate extends BaseTest\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestValueUpdate extends BaseMapTest\n {\n     static class Bean\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBasicAnnotations.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBasicAnnotations.java\n \n     static class Issue442Bean {\n         @JsonUnwrapped\n-        private IntWrapper w = new IntWrapper(13);\n+        protected IntWrapper w = new IntWrapper(13);\n     }\n     \n     final static class SizeClassSetter2\n     }\n \n     static class BeanWithDeserialize {\n-        @JsonDeserialize private int a;\n+        @JsonDeserialize protected int a;\n     }\n     \n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n     /********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testPropertyRemoval() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n     public void testPOJOFromEmptyString() throws Exception\n     {\n         // first, verify default settings which do not accept empty String:\n-        ObjectMapper mapper = new ObjectMapper();\n+        assertFalse(MAPPER.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT));\n         try {\n-            mapper.readValue(quote(\"\"), Bean.class);\n+            MAPPER.readValue(quote(\"\"), Bean.class);\n             fail(\"Should not accept Empty String for POJO\");\n         } catch (JsonProcessingException e) {\n             verifyException(e, \"from String value\");\n             assertValidLocation(e.getLocation());\n         }\n+        // should be ok to enable dynamically\n+        ObjectReader r = MAPPER.reader(Bean.class)\n+                .with(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n+        Bean result = r.readValue(quote(\"\"));\n+        assertNull(result);\n+    }\n+\n+    // [Databind#540]\n+    public void testPOJOFromEmptyArray() throws Exception\n+    {\n+        final String JSON = \"  [\\n]\";\n+        assertFalse(MAPPER.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT));\n+        // first, verify default settings which do not accept empty Array\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.readValue(JSON, Bean.class);\n+            fail(\"Should not accept Empty Array for POJO by default\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"START_ARRAY token\");\n+            assertValidLocation(e.getLocation());\n+        }\n \n         // should be ok to enable dynamically:\n+        ObjectReader r = MAPPER.reader(Bean.class)\n+                .with(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT);\n+        Bean result = r.readValue(JSON);\n+        assertNull(result);\n+    }\n+\n+    // [Databind#566]\n+    public void testCaseInsensitiveDeserialization() throws Exception\n+    {\n+    \tfinal String JSON = \"{\\\"Value1\\\" : {\\\"nAme\\\" : \\\"fruit\\\", \\\"vALUe\\\" : \\\"apple\\\"}, \\\"valUE2\\\" : {\\\"NAME\\\" : \\\"color\\\", \\\"value\\\" : \\\"red\\\"}}\";\n+        \n+        // first, verify default settings which do not accept improper case\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertFalse(mapper.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES));\n+        \n+        try {\n+            mapper.readValue(JSON, Issue476Bean.class);\n+            \n+            fail(\"Should not accept improper case properties by default\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"Unrecognized field\");\n+            assertValidLocation(e.getLocation());\n+        }\n+\n+        // Definitely not OK to enable dynamically - the BeanPropertyMap (which is the consumer of this particular feature) gets cached.\n         mapper = new ObjectMapper();\n-        mapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n-        Bean result = mapper.readValue(quote(\"\"), Bean.class);\n-        assertNull(result);\n-    }\n-\n+        mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+        ObjectReader r = mapper.reader(Issue476Bean.class);\n+        Issue476Bean result = r.readValue(JSON);\n+        assertEquals(result.value1.name, \"fruit\");\n+        assertEquals(result.value1.value, \"apple\");\n+    }\n+    \n     // [Issue#120]\n     public void testModifyArrayDeserializer() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n     public void testFromEmptyString() throws Exception\n     {\n         ObjectReader r = MAPPER.reader(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n-        List<?> result = r.withType(List.class).readValue(quote(\"\"));\n+        List<?> result = r.forType(List.class).readValue(quote(\"\"));\n         assertNull(result);\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.deser.std.*;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.util.StdConverter;\n \n         }\n         \n     }\n-    \n+\n+    // for [databind#631]\n+    static class Issue631Bean\n+    {\n+        @JsonDeserialize(using=ParentClassDeserializer.class)\n+        public Object prop;\n+    }\n+    \n+    static class ParentClassDeserializer\n+        extends StdScalarDeserializer<Object>\n+    {\n+        protected ParentClassDeserializer() {\n+            super(Object.class);\n+        }\n+\n+        @Override\n+        public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+                throws IOException {\n+            Object parent = p.getCurrentValue();\n+            String desc = (parent == null) ? \"NULL\" : parent.getClass().getSimpleName();\n+            return \"prop/\"+ desc;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertEquals(7, imm.y);\n     }\n \n+    // [databind#623]\n+    public void testJsonNodeDelegating() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addDeserializer(Immutable.class,\n+            new StdNodeBasedDeserializer<Immutable>(Immutable.class) {\n+                @Override\n+                public Immutable convert(JsonNode root, DeserializationContext ctxt) throws IOException {\n+                    int x = root.path(\"x\").asInt();\n+                    int y = root.path(\"y\").asInt();\n+                    return new Immutable(x, y);\n+                }\n+        });\n+        mapper.registerModule(module);\n+        Immutable imm = mapper.readValue(\"{\\\"x\\\":-10,\\\"y\\\":3}\", Immutable.class);\n+        assertEquals(-10, imm.x);\n+        assertEquals(3, imm.y);\n+    }\n+    \n     public void testIssue882() throws Exception\n     {\n         Model original = new Model(Collections.singletonMap(new CustomKey(123), \"test\"));\n         assertNotNull(w.value.inner);\n         assertEquals(-13, w.value.inner.x);\n     }\n+\n+    // [#631]: \"current value\" access\n+    public void testCurrentValueAccess() throws Exception\n+    {\n+        Issue631Bean bean = MAPPER.readValue(aposToQuotes(\"{'prop':'stuff'}\"),\n+                Issue631Bean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"prop/Issue631Bean\", bean.prop);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCyclicTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCyclicTypes.java\n     }\n \n     static class LinkB {\n-        private LinkA a;\n+        protected LinkA a;\n \n         public void setA(LinkA a) { this.a = a; }\n         public LinkA getA() { return a; }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n package com.fasterxml.jackson.databind.deser;\n \n import java.io.IOException;\n+import java.math.BigDecimal;\n import java.util.EnumMap;\n import java.util.EnumSet;\n import java.util.Map;\n import java.util.concurrent.TimeUnit;\n \n import com.fasterxml.jackson.annotation.*;\n-\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.*;\n             return TestEnum.valueOf(jp.getText().toUpperCase());\n         }\n     }\n-    \n+\n     protected enum EnumWithCreator {\n         A, B;\n \n         public static EnumWithCreator fromEnum(String str) {\n             if (\"enumA\".equals(str)) return A;\n             if (\"enumB\".equals(str)) return B;\n+            return null;\n+        }\n+    }\n+\n+    protected enum EnumWithBDCreator {\n+        E5, E8;\n+\n+        @JsonCreator\n+        public static EnumWithBDCreator create(BigDecimal bd) {\n+            if (bd.longValue() == 5L) return E5;\n+            if (bd.longValue() == 8L) return E8;\n             return null;\n         }\n     }\n     }\n \n     // [JACKSON-193]\n-    public void testCreatorEnums() throws Exception\n-    {\n+    public void testCreatorEnums() throws Exception {\n         EnumWithCreator value = MAPPER.readValue(\"\\\"enumA\\\"\", EnumWithCreator.class);\n         assertEquals(EnumWithCreator.A, value);\n+    }\n+\n+    public void testCreatorEnumsFromBigDecimal() throws Exception {\n+        EnumWithBDCreator value = MAPPER.readValue(\"\\\"8.0\\\"\", EnumWithBDCreator.class);\n+        assertEquals(EnumWithBDCreator.E8, value);\n     }\n     \n     // [JACKSON-212]\n     {\n         // can not use shared mapper when changing configs...\n         ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);\n-        assertNull(reader.withType(TestEnum.class).readValue(\"\\\"NO-SUCH-VALUE\\\"\"));\n-        assertNull(reader.withType(TestEnum.class).readValue(\" 4343 \"));\n+        assertNull(reader.forType(TestEnum.class).readValue(\"\\\"NO-SUCH-VALUE\\\"\"));\n+        assertNull(reader.forType(TestEnum.class).readValue(\" 4343 \"));\n     }\n \n     public void testAllowUnknownEnumValuesForEnumSets() throws Exception\n     {\n         ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);\n-        EnumSet<TestEnum> result = reader.withType(new TypeReference<EnumSet<TestEnum>>() { })\n+        EnumSet<TestEnum> result = reader.forType(new TypeReference<EnumSet<TestEnum>>() { })\n                 .readValue(\"[\\\"NO-SUCH-VALUE\\\"]\");\n         assertEquals(0, result.size());\n     }\n     public void testAllowUnknownEnumValuesAsMapKeysReadAsNull() throws Exception\n     {\n         ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);\n-        ClassWithEnumMapKey result = reader.withType(ClassWithEnumMapKey.class)\n+        ClassWithEnumMapKey result = reader.forType(ClassWithEnumMapKey.class)\n                 .readValue(\"{\\\"map\\\":{\\\"NO-SUCH-VALUE\\\":\\\"val\\\"}}\");\n         assertTrue(result.map.containsKey(null));\n     }\n     // [JACKSON-834]\n     public void testEnumsFromInts() throws Exception\n     {\n-        TestEnumFor834 res = MAPPER.readValue(\"1 \", TestEnumFor834.class);\n-        assertSame(TestEnumFor834.ENUM_A, res);\n+        Object ob = MAPPER.readValue(\"1 \", TestEnumFor834.class);\n+        assertEquals(TestEnumFor834.class, ob.getClass());\n+        assertSame(TestEnumFor834.ENUM_A, ob);\n     }\n \n     // [Issue#141]: allow mapping of empty String into null\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n-import com.fasterxml.jackson.test.BrokenStringReader;\n \n /**\n  * Unit test for verifying that exceptions are properly handled (caught,\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestFieldDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestFieldDeserialization.java\n         @JsonProperty(\"x\")\n         protected int myX = 10;\n \n-        @SuppressWarnings(\"hiding\")\n         public int y = 11;\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestInjectables.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestInjectables.java\n \n     static class IssueGH471Bean {\n \n-        private final Object constructorInjected;\n-        private final String constructorValue;\n+        protected final Object constructorInjected;\n+        protected final String constructorValue;\n \n-        @JacksonInject(\"field_injected\") private Object fieldInjected;\n-        @JsonProperty(\"field_value\")     private String fieldValue;\n+        @JacksonInject(\"field_injected\") protected Object fieldInjected;\n+        @JsonProperty(\"field_value\")     protected String fieldValue;\n \n-        private Object methodInjected;\n-        private String methodValue;\n+        protected Object methodInjected;\n+        protected String methodValue;\n \n         public int x;\n         \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n \n         @JsonProperty(\"Location\")\n         @JsonDeserialize(using=MyStackTraceElementDeserializer.class)\n-        private StackTraceElement location;    \n+        protected StackTraceElement location;    \n     }\n \n     @SuppressWarnings(\"serial\")\n         assertEquals(0, result.remaining());\n     }\n \n+    public void testStringBuilder() throws Exception\n+    {\n+        StringBuilder sb = MAPPER.readValue(quote(\"abc\"), StringBuilder.class);\n+        assertEquals(\"abc\", sb.toString());\n+    }\n+    \n     // [Issue#429]\n     public void testStackTraceElementWithCustom() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n public class TestMapDeserialization\n     extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Test classes, enums\n-    /**********************************************************\n-     */\n-\n-    enum Key {\n+    static enum Key {\n         KEY1, KEY2, WHATEVER;\n     }\n \n         ONE, TWO;\n     }\n \n-    \n+    static class ClassStringMap extends HashMap<Class<?>,String> { }\n     \n     /*\n     /**********************************************************\n         assertEquals(Integer.valueOf(1), result.get(\"a\"));\n \n         assertNull(result.get(\"\"));\n+    }\n+\n+    // [Databind#540]\n+    public void testMapFromEmptyArray() throws Exception\n+    {\n+        final String JSON = \"  [\\n]\";\n+        assertFalse(MAPPER.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT));\n+        // first, verify default settings which do not accept empty Array\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.readValue(JSON, Map.class);\n+            fail(\"Should not accept Empty Array for Map by default\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"START_ARRAY token\");\n+        }\n+        // should be ok to enable dynamically:\n+        ObjectReader r = MAPPER.reader(Map.class)\n+                .with(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT);\n+\n+        Map<?,?> result = r.readValue(JSON);\n+        assertNull(result);\n+\n+        EnumMap<?,?> result2 = r.forType(new TypeReference<EnumMap<Key,String>>() { })\n+                .readValue(JSON);\n+        assertNull(result2);\n     }\n \n     /*\n         assertEquals(key, ob);\n     }\n \n+    public void testCurrencyKeyMap() throws Exception {\n+        Currency key = Currency.getInstance(\"USD\");\n+        String JSON = \"{ \\\"\" + key + \"\\\":4}\";\n+        Map<Currency, Object> result = MAPPER.readValue(JSON, new TypeReference<Map<Currency, Object>>() {\n+        });\n+        assertNotNull(result);\n+        assertEquals(1, result.size());\n+        Object ob = result.keySet().iterator().next();\n+        assertNotNull(ob);\n+        assertEquals(Currency.class, ob.getClass());\n+        assertEquals(key, ob);\n+    }\n+\n     // Test confirming that @JsonCreator may be used with Map Key types\n     public void testKeyWithCreator() throws Exception\n     {\n         key = map.keySet().iterator().next();\n         assertEquals(\"foo\", key.value);\n     }\n+\n+    public void testClassKeyMap() throws Exception {\n+        ClassStringMap map = MAPPER.readValue(aposToQuotes(\"{'java.lang.String':'foo'}\"),\n+                ClassStringMap.class);\n+        assertNotNull(map);\n+        assertEquals(1, map.size());\n+        assertEquals(\"foo\", map.get(String.class));\n+    }\n     \n     /*\n     /**********************************************************\n      * Simple test to ensure that @JsonDeserialize.using is\n      * recognized\n      */\n-    public void testMapWithDeserializer() throws IOException\n+    public void testMapWithDeserializer() throws Exception\n     {\n         CustomMap result = MAPPER.readValue(quote(\"xyz\"), CustomMap.class);\n         assertEquals(1, result.size());\n         assertEquals(\"xyz\", result.get(\"x\"));\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Test methods, annotated Map.Entry\n+    /**********************************************************\n+     */\n+\n+    public void testMapEntrySimpleTypes() throws Exception\n+    {\n+        List<Map.Entry<String,Long>> stuff = MAPPER.readValue(aposToQuotes(\"[{'a':15},{'b':42}]\"),\n+                new TypeReference<List<Map.Entry<String,Long>>>() { });\n+        assertNotNull(stuff);\n+        assertEquals(2, stuff.size());\n+        assertNotNull(stuff.get(1));\n+        assertEquals(\"b\", stuff.get(1).getKey());\n+        assertEquals(Long.valueOf(42), stuff.get(1).getValue());\n+    }\n+\n+    public void testMapEntryWithStringBean() throws Exception\n+    {\n+        List<Map.Entry<Integer,StringWrapper>> stuff = MAPPER.readValue(aposToQuotes(\"[{'28':'Foo'},{'13':'Bar'}]\"),\n+                new TypeReference<List<Map.Entry<Integer,StringWrapper>>>() { });\n+        assertNotNull(stuff);\n+        assertEquals(2, stuff.size());\n+        assertNotNull(stuff.get(1));\n+        assertEquals(Integer.valueOf(13), stuff.get(1).getKey());\n+        \n+        StringWrapper sw = stuff.get(1).getValue();\n+        assertEquals(\"Bar\", sw.str);\n+    }\n+\n+    public void testMapEntryFail() throws Exception\n+    {\n+        try {\n+            /*List<Map.Entry<Integer,StringWrapper>> stuff =*/ MAPPER.readValue(aposToQuotes(\"[{'28':'Foo','13':'Bar'}]\"),\n+                    new TypeReference<List<Map.Entry<Integer,StringWrapper>>>() { });\n+            fail(\"Should not have passed\");\n+        } catch (Exception e) {\n+            verifyException(e, \"more than one entry in JSON\");\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Error tests\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestNoClassDefFoundDeserializer.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import javax.measure.Measure;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestNoClassDefFoundDeserializer extends BaseMapTest {\n+\n+    public static class Parent {\n+        public List<Child> child;\n+    }\n+\n+    public static class Child {\n+        public Measure<?> measure;\n+    }\n+\n+    public void testClassIsMissing()\n+    {\n+        boolean missing = false;\n+        try {\n+            Class.forName(\"javax.measure.Measure\");\n+        } catch (ClassNotFoundException ex) {\n+            missing = true;\n+        }\n+        assertTrue(\"javax.measure.Measure is not in classpath\", missing);\n+    }\n+\n+    public void testDeserialize() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Parent result = m.readValue(\" { } \", Parent.class);\n+        assertNotNull(result);\n+    }\n+\n+    public void testUseMissingClass() throws Exception\n+    {\n+        boolean missing = false;\n+        try {\n+            ObjectMapper m = new ObjectMapper();\n+            m.readValue(\" { \\\"child\\\" : [{}] } \", Parent.class);\n+        } catch (NoClassDefFoundError ex) {\n+            missing = true;\n+        }\n+        assertTrue(\"cannot instantiate a missing class\", missing);\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestNumbers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestNumbers.java\n /**\n  * Tests related to [JACKSON-139]\n  */\n-public class TestNumbers\n-    extends BaseMapTest\n+public class TestNumbers extends BaseMapTest\n {\n     /*\n     /**********************************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestValueAnnotations.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestValueAnnotations.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * This unit test suite tests use of \"value\" Annotations;\n  * deserialization.\n  */\n public class TestValueAnnotations\n-    extends BaseTest\n+    extends BaseMapTest\n {\n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/filter/TestMapFiltering.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/filter/TestMapFiltering.java\n package com.fasterxml.jackson.databind.filter;\n \n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonFilter;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.ser.PropertyFilter;\n+import com.fasterxml.jackson.databind.ser.PropertyWriter;\n import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\n import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;\n \n public class TestMapFiltering extends BaseMapTest\n {\n+    @Target({ElementType.FIELD})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface CustomOffset\n+    {\n+        public int value();\n+    }\n+\n     @SuppressWarnings(\"serial\")\n     @JsonFilter(\"filterForMaps\")\n     static class FilteredBean extends LinkedHashMap<String,Integer> { }\n     \n     static class MapBean {\n         @JsonFilter(\"filterX\")\n+        @CustomOffset(1)\n         public Map<String,Integer> values;\n         \n         public MapBean() {\n             values.put(\"c\", 9);\n         }\n     }\n-    \n+\n+    static class MyMapFilter implements PropertyFilter\n+    {\n+        @Override\n+        public void serializeAsField(Object value, JsonGenerator jgen,\n+                SerializerProvider provider, PropertyWriter writer)\n+            throws Exception\n+        {\n+            String name = writer.getName();\n+            if (!\"a\".equals(name)) {\n+                return;\n+            }\n+            CustomOffset n = writer.findAnnotation(CustomOffset.class);\n+            int offset = (n == null) ? 0 : n.value();\n+            Integer I = offset + ((Integer) value).intValue();\n+\n+            writer.serializeAsField(I, jgen, provider);\n+        }\n+\n+        @Override\n+        public void serializeAsElement(Object elementValue, JsonGenerator jgen,\n+                SerializerProvider prov, PropertyWriter writer)\n+                throws Exception {\n+            // not needed for testing\n+        }\n+\n+        @Override\n+        public void depositSchemaProperty(PropertyWriter writer,\n+                ObjectNode propertiesNode, SerializerProvider provider)\n+                throws JsonMappingException {\n+            \n+        }\n+\n+        @Override\n+        public void depositSchemaProperty(PropertyWriter writer,\n+                JsonObjectFormatVisitor objectVisitor,\n+                SerializerProvider provider) throws JsonMappingException {\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertEquals(aposToQuotes(\"{'b':3}\"), json);\n     }\n     \n+    // [Issue#522]\n+    public void testMapFilteringWithAnnotations() throws Exception\n+    {\n+        FilterProvider prov = new SimpleFilterProvider().addFilter(\"filterX\",\n+                new MyMapFilter());\n+        String json = MAPPER.writer(prov).writeValueAsString(new MapBean());\n+        // a=1 should become a=2\n+        assertEquals(aposToQuotes(\"{'values':{'a':2}}\"), json);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestCglibUsage.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestCglibUsage.java\n package com.fasterxml.jackson.databind.interop;\n \n-\n-import java.io.*;\n import java.lang.reflect.Method;\n import java.util.*;\n \n import net.sf.cglib.proxy.MethodProxy;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Unit test for checking that we can serialize CGLib generated proxies.\n  */\n-public class TestCglibUsage\n-    extends BaseTest\n+public class TestCglibUsage extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n     interface BeanInterface {\n         public int getX();\n     }\n         assertEquals(1, result.size());\n         assertEquals(Integer.valueOf(13), result.get(\"x\"));\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper methods\n-    /**********************************************************\n-     */\n-\n-    @SuppressWarnings(\"unchecked\")\n-\tprivate Map<String,Object> writeAndMap(ObjectMapper m, Object value)\n-        throws IOException\n-    {\n-        StringWriter sw = new StringWriter();\n-        m.writeValue(sw, value);\n-        return (Map<String,Object>) m.readValue(sw.toString(), Object.class);\n-    }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestFormatDetection.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestFormatDetection.java\n     \n     public void testSimpleWithJSON() throws Exception\n     {\n-        ObjectReader detecting = READER.withType(POJO.class);\n+        ObjectReader detecting = READER.forType(POJO.class);\n         detecting = detecting.withFormatDetection(detecting);\n         POJO pojo = detecting.readValue(utf8Bytes(\"{\\\"x\\\":1}\"));\n         assertNotNull(pojo);\n \n     public void testInvalid() throws Exception\n     {\n-        ObjectReader detecting = READER.withType(POJO.class);\n+        ObjectReader detecting = READER.forType(POJO.class);\n         detecting = detecting.withFormatDetection(detecting);\n         try {\n             detecting.readValue(utf8Bytes(\"<POJO><x>1</x></POJO>\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestHibernate.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestHibernate.java\n package com.fasterxml.jackson.databind.interop;\n \n-\n-import java.io.*;\n import java.lang.reflect.Method;\n import java.util.*;\n \n import org.hibernate.repackage.cglib.proxy.MethodProxy;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Basic tests covering Hibernate-compatibility features.\n  */\n public class TestHibernate\n-    extends BaseTest\n+    extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n     interface BeanInterfaceHib {\n         public int getX();\n     }\n         assertEquals(1, result.size());\n         assertEquals(Integer.valueOf(13), result.get(\"x\"));\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper methods\n-    /**********************************************************\n-     */\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private Map<String,Object> writeAndMap(ObjectMapper m, Object value)\n-        throws IOException\n-    {\n-        StringWriter sw = new StringWriter();\n-        m.writeValue(sw, value);\n-        return (Map<String,Object>) m.readValue(sw.toString(), Object.class);\n-    }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestJDKProxy.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestJDKProxy.java\n \n     public static <T> T getProxy(Class<T> type, Object obj) {\n         class ProxyUtil implements InvocationHandler {\n-            @SuppressWarnings(\"hiding\")\n-            Object obj;\n+            Object _obj;\n             public ProxyUtil(Object o) {\n-                obj = o;\n+                _obj = o;\n             }\n             @Override\n             public Object invoke(Object proxy, Method m, Object[] args) throws Throwable {\n                 Object result = null;\n-                result = m.invoke(obj, args);\n+                result = m.invoke(_obj, args);\n                 return result;\n             }\n         }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/BeanNamingTest.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+// Tests for [databind#653]\n+public class BeanNamingTest extends BaseMapTest\n+{\n+    static class URLBean {\n+        public String getURL() {\n+            return \"http://foo\";\n+        }\n+    }\n+\n+    static class ABean {\n+        public int getA() {\n+            return 3;\n+        }\n+    }\n+    \n+    public void testSimple() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertFalse(mapper.isEnabled(MapperFeature.USE_STD_BEAN_NAMING));\n+        assertEquals(aposToQuotes(\"{'url':'http://foo'}\"),\n+                mapper.writeValueAsString(new URLBean()));\n+        assertEquals(aposToQuotes(\"{'a':3}\"),\n+                mapper.writeValueAsString(new ABean()));\n+\n+        mapper = new ObjectMapper();\n+        mapper.enable(MapperFeature.USE_STD_BEAN_NAMING);\n+        assertEquals(aposToQuotes(\"{'URL':'http://foo'}\"),\n+                mapper.writeValueAsString(new URLBean()));\n+        assertEquals(aposToQuotes(\"{'a':3}\"),\n+                mapper.writeValueAsString(new ABean()));\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestAnnotionBundles.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestAnnotionBundles.java\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n \n-import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JacksonAnnotationsInside;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyName;\n \n /* Tests mostly for [JACKSON-754]: ability to create \"annotation bundles\"\n  */\n     public class Bean92 {\n         @Bundle92\n         protected String id = \"abc\";\n-    }    \n+    }\n+\n+    @HolderB\n+    @JacksonAnnotationsInside\n+    @Retention(RetentionPolicy.RUNTIME)\n+    static @interface HolderA {}\n+\n+    @HolderA\n+    @JacksonAnnotationsInside\n+    @Retention(RetentionPolicy.RUNTIME)\n+    static @interface HolderB {}\n+\n+    static class RecursiveHolder {\n+        @HolderA public int unimportant = 42;\n+    }\n+\n+    @JsonProperty\n+    @JacksonAnnotationsInside\n+    @Retention(RetentionPolicy.RUNTIME)\n+    static @interface InformativeHolder {\n+        // doesn't really contribute to the test, but would be impossible without this feature\n+        boolean important() default true;\n+    }\n+\n+    static class InformingHolder {\n+        @InformativeHolder public int unimportant = 42;\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class BundleAnnotationIntrospector extends JacksonAnnotationIntrospector {\n+        @Override\n+        public PropertyName findNameForSerialization(Annotated a)\n+        {\n+            InformativeHolder informativeHolder = a.getAnnotation(InformativeHolder.class);\n+            if ((informativeHolder != null) && informativeHolder.important()) {\n+                return new PropertyName(\"important\");\n+            }\n+            return super.findNameForSerialization(a);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n      */\n \n     private final ObjectMapper MAPPER = new ObjectMapper();\n-    \n+\n+    public void testKeepAnnotationBundle() throws Exception\n+    {\n+        MAPPER.setAnnotationIntrospector(new BundleAnnotationIntrospector());\n+        assertEquals(\"{\\\"important\\\":42}\", MAPPER.writeValueAsString(new InformingHolder()));\n+    }\n+\n+    public void testRecursiveBundles() throws Exception\n+    {\n+        assertEquals(\"{\\\"unimportant\\\":42}\", MAPPER.writeValueAsString(new RecursiveHolder()));\n+    }\n+\n     public void testBundledIgnore() throws Exception\n     {\n         assertEquals(\"{\\\"foobar\\\":13}\", MAPPER.writeValueAsString(new Bean()));\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestAutoDetect.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+\n+public class TestAutoDetect\n+    extends BaseMapTest\n+{\n+    static class PrivateBean {\n+        String a;\n+\n+        private PrivateBean() { }\n+\n+        private PrivateBean(String a) { this.a = a; }\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Unit tests\n+    /********************************************************\n+     */\n+    \n+    public void testPrivateCtor() throws Exception\n+    {\n+        // first, default settings, with which construction works ok\n+        ObjectMapper m = new ObjectMapper();\n+        PrivateBean bean = m.readValue(\"\\\"abc\\\"\", PrivateBean.class);\n+        assertEquals(\"abc\", bean.a);\n+\n+        // then by increasing visibility requirement:\n+        m = new ObjectMapper();\n+        // note: clumsy code, but needed for Eclipse/JDK1.5 compilation (not for 1.6)\n+        VisibilityChecker<?> vc = m.getVisibilityChecker();\n+        vc = vc.withCreatorVisibility(JsonAutoDetect.Visibility.PUBLIC_ONLY);\n+        m.setVisibilityChecker(vc);\n+        try {\n+            m.readValue(\"\\\"abc\\\"\", PrivateBean.class);\n+            fail(\"Expected exception for missing constructor\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"no single-String constructor/factory\");\n+        }\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestBuilderMethods.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestBuilderMethods.java\n     {\n         public int x;\n \n-        @SuppressWarnings(\"hiding\")\n-        public SimpleBuilder withX(int x) {\n-    \t\t    this.x = x;\n+        public SimpleBuilder withX(int x0) {\n+    \t\t    this.x = x0;\n     \t\t    return this;\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestInferredMutators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestInferredMutators.java\n public class TestInferredMutators extends BaseMapTest\n {\n     public static class Point {\n-        private int x;\n+        protected int x;\n         \n         public int getX() { return x; }\n     }\n \n     public static class FixedPoint {\n-        private final int x;\n+        protected final int x;\n \n         public FixedPoint() { x = 0; }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java\n \n     public static class JacksonExample\n     {\n-        private String attributeProperty;\n-        private String elementProperty;\n-        private List<String> wrappedElementProperty;\n-        private EnumExample enumProperty;\n-        private QName qname;\n+        protected String attributeProperty;\n+        protected String elementProperty;\n+        protected List<String> wrappedElementProperty;\n+        protected EnumExample enumProperty;\n+        protected QName qname;\n \n         @JsonSerialize(using=QNameSerializer.class)\n         public QName getQname()\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestMixinMerging.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestMixinMerging.java\n     }\n \n     static class ContactImpl implements Contact {\n+        @Override\n         public String getCity() { return \"Seattle\"; }\n     }\n \n     static class ContactMixin implements Contact {\n+        @Override\n         @JsonProperty\n         public String getCity() { return null; }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestNameConflicts.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestNameConflicts.java\n \n public class TestNameConflicts extends BaseMapTest\n {\n+    @JsonAutoDetect\n+    (fieldVisibility= JsonAutoDetect.Visibility.NONE,getterVisibility= JsonAutoDetect.Visibility.NONE, setterVisibility= JsonAutoDetect.Visibility.NONE, isGetterVisibility= JsonAutoDetect.Visibility.NONE)\n+    static class CoreBean158 {\n+        protected String bar = \"x\";\n+\n+        @JsonProperty\n+        public String getBar() {\n+            return bar;\n+        }\n+\n+        @JsonProperty\n+        public void setBar(String bar) {\n+            this.bar = bar;\n+        }\n+\n+        public void setBar(java.io.Serializable bar) {\n+            this.bar = bar.toString();\n+        }\n+    }\n+    \n     static class Bean193\n     {\n         @JsonProperty(\"val1\")\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = objectMapper();\n+    \n     // [Issue#193]\n     public void testIssue193() throws Exception\n     {\n     // [Issue#327]\n     public void testNonConflict() throws Exception\n     {\n-        String json = objectMapper().writeValueAsString(new BogusConflictBean());\n+        String json = MAPPER.writeValueAsString(new BogusConflictBean());\n         assertEquals(aposToQuotes(\"{'prop1':2,'prop2':1}\"), json);\n     }    \n \n         String json = objectWriter().writeValueAsString(new MultipleTheoreticalGetters());\n         assertEquals(aposToQuotes(\"{'a':3}\"), json);\n     }\n+\n+    // for [jackson-core#158]\n+    public void testOverrideName() throws Exception\n+    {\n+        final ObjectMapper mapper = objectMapper();\n+        String json = mapper.writeValueAsString(new CoreBean158());\n+        assertEquals(aposToQuotes(\"{'bar':'x'}\"), json);\n+\n+        // and back\n+        CoreBean158 result = null;\n+        try {\n+            result = mapper.readValue(aposToQuotes(\"{'bar':'y'}\"), CoreBean158.class);\n+        } catch (Exception e) {\n+            fail(\"Unexpected failure when reading CoreBean158: \"+e);\n+        }\n+        assertNotNull(result);\n+        assertEquals(\"y\", result.bar);\n+    }    \n }\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestPOJOPropertiesCollector.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestPOJOPropertiesCollector.java\n \n         public void setA(String a) { this.a = a; }\n \n-        @JsonProperty(required=true, index=B_INDEX)\n+        @JsonProperty(required=true, index=B_INDEX, defaultValue=\"13\")\n         public int getB() { return b; }\n     }\n     \n         assertNotNull(beanDesc);\n     }\n \n-    @SuppressWarnings(\"hiding\")\n     public void testJackson703() throws Exception\n     {\n     \t// note: need a separate mapper, need to reconfigure\n     {\n         // start via deser\n         BeanDescription beanDesc = mapper.getDeserializationConfig().introspect(mapper.constructType(PropDescBean.class));\n-        _verifyProperty(beanDesc, true, false);\n+        _verifyProperty(beanDesc, true, false, \"13\");\n         // and then via ser:\n         beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(PropDescBean.class));\n-        _verifyProperty(beanDesc, true, false);\n+        _verifyProperty(beanDesc, true, false, \"13\");\n     }\n \n     // [#438]: Support @JsonProperty.index\n     public void testPropertyIndex() throws Exception\n     {\n         BeanDescription beanDesc = mapper.getDeserializationConfig().introspect(mapper.constructType(PropDescBean.class));\n-        _verifyProperty(beanDesc, false, true);\n+        _verifyProperty(beanDesc, false, true, \"13\");\n         beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(PropDescBean.class));\n-        _verifyProperty(beanDesc, false, true);\n+        _verifyProperty(beanDesc, false, true, \"13\");\n     }\n \n     private void _verifyProperty(BeanDescription beanDesc,\n-    \t\tboolean verifyDesc, boolean verifyIndex)\n+    \t\tboolean verifyDesc, boolean verifyIndex, String expDefaultValue)\n     {\n         assertNotNull(beanDesc);\n         List<BeanPropertyDefinition> props = beanDesc.findProperties();\n                 if (verifyIndex) {\n                 \tassertEquals(Integer.valueOf(PropDescBean.B_INDEX), md.getIndex());\n                 }\n+                if (expDefaultValue != null) {\n+                    assertEquals(expDefaultValue, md.getDefaultValue());\n+                }\n             } else {\n                 fail(\"Unrecognized property '\"+name+\"'\");\n             }\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java\n     // [Issue#238]\n     protected static class Getters1A\n     {\n+        @JsonProperty\n         protected int value = 3;\n         \n         public int getValue() { return value+1; }\n     {\n         public boolean isValue() { return false; }\n \n+        @JsonProperty\n         protected int value = 3;\n         \n         public int getValue() { return value+1; }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractContainers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractContainers.java\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testAbstractLists() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         ListWrapper w = new ListWrapper();\n         w.list.add(\"x\");\n \n-        String json = mapper.writeValueAsString(w);\n-        Object o = mapper.readValue(json, ListWrapper.class);\n+        String json = MAPPER.writeValueAsString(w);\n+        Object o = MAPPER.readValue(json, ListWrapper.class);\n         assertEquals(ListWrapper.class, o.getClass());\n         ListWrapper out = (ListWrapper) o;\n+        assertNotNull(out.list);\n         assertEquals(1, out.list.size());\n         assertEquals(\"x\", out.list.get(0));\n    }\n     \n     public void testAbstractMaps() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         MapWrapper w = new MapWrapper();\n         w.map.put(\"key1\", \"name1\");\n \n-        String json = mapper.writeValueAsString(w);\n-        Object o = mapper.readValue(json, MapWrapper.class);\n+        String json = MAPPER.writeValueAsString(w);\n+        Object o = MAPPER.readValue(json, MapWrapper.class);\n         assertEquals(MapWrapper.class, o.getClass());\n         MapWrapper out = (MapWrapper) o;\n         assertEquals(1, out.map.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n \n-import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver;\n-import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n public class TestCustomTypeIdResolver extends BaseMapTest\n         }\n     }\n \n-    static class CustomResolverBase implements TypeIdResolver\n+    static class CustomResolverBase extends TypeIdResolverBase\n     {\n         protected final Class<?> superType;\n         protected final Class<?> subType;\n         public void init(JavaType baseType) { }\n \n         @Override\n-        public JavaType typeFromId(String id)\n+        public JavaType typeFromId(DatabindContext context, String id)\n         {\n             if (\"*\".equals(id)) {\n                 return TypeFactory.defaultInstance().constructType(subType);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n      * Another enum type, but this time forcing sub-classing\n      */\n     enum ComplexChoice {\n-    \tMAYBE(true), PROBABLY_NOT(false);\n-\n-    \tprivate boolean state;\n+        MAYBE(true), PROBABLY_NOT(false);\n+\n+        private boolean state;\n     \t\n-    \tprivate ComplexChoice(boolean b) { state = b; }\n+        private ComplexChoice(boolean b) { state = b; }\n     \t\n         @Override\n-    \tpublic String toString() { return String.valueOf(state); }\n+        public String toString() { return String.valueOf(state); }\n     }\n \n     // [JACKSON-311]\n         assertEquals(\"abc\", ((StringBean) result[0]).name);\n     }\n \n+    // with 2.5, another test to check that \"as-property\" is valid option\n+    public void testBeanAsObjectUsingAsProperty() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL,\n+                \".hype\");\n+        // note: need to wrap, to get declared as Object\n+        String json = m.writeValueAsString(new StringBean(\"abc\"));\n+        \n+        // Ok: serialization seems to work as expected. Now deserialize:\n+        Object result = m.readValue(json, Object.class);\n+        assertNotNull(result);\n+        assertEquals(StringBean.class, result.getClass());\n+        assertEquals(\"abc\", ((StringBean) result).name);\n+    }\n+    \n     /**\n      * Unit test that verifies that an abstract bean is stored with type information\n      * if default type information is enabled for non-concrete types.\n         String json = mapper.writeValueAsString(new BeanHolder(new StringBean(\"punny\")));\n         assertEquals(\"{\\\"bean\\\":{\\\"*CLASS*\\\":\\\"com.fasterxml.jackson.databind.jsontype.TestDefaultForObject$StringBean\\\",\\\"name\\\":\\\"punny\\\"}}\", json);\n     }\n+\n+    public void testNoGoWithExternalProperty() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT,\n+                    JsonTypeInfo.As.EXTERNAL_PROPERTY);\n+            fail(\"Should not have passed\");\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"Can not use includeAs of EXTERNAL_PROPERTY\");\n+        }\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n \n import com.fasterxml.jackson.annotation.*;\n \n-import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.core.type.TypeReference;\n \n import com.fasterxml.jackson.databind.*;\n     public void testSubTypesFor356() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        /* 06-Sep-2010, tatus: This was not fixed for 1.6; and to keep junit test\n-         *   suite green, let's not run it for versions prior to 1.7...\n-         */\n-        Version v = mapper.version();\n-        if (v.getMajorVersion() == 1 && v.getMinorVersion() == 6) {\n-            System.err.println(\"Note: skipping test for Jackson 1.6\");\n-            return;\n-        }\n         \n         JSONResponse<List<Parent>> input = new JSONResponse<List<Parent>>();\n \n         mapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n \n         JavaType rootType = TypeFactory.defaultInstance().constructType(new TypeReference<JSONResponse<List<Parent>>>() { });\n-        byte[] json = mapper.writerWithType(rootType).writeValueAsBytes(input);\n-//        byte[] json = mapper.writeValueAsBytes(input);\n-\n-//        System.out.println(\"After Serialization: \" + new String(json));\n+        byte[] json = mapper.writerFor(rootType).writeValueAsBytes(input);\n         \n         JSONResponse<List<Parent>> out = mapper.readValue(json, 0, json.length, rootType);\n \n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestNoTypeInfo.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestNoTypeInfo.java\n {\n     @JsonTypeInfo(use=JsonTypeInfo.Id.NONE)\n     @JsonDeserialize(as=NoType.class)\n-    private static interface NoTypeInterface {\n+    static interface NoTypeInterface {\n     }\n     \n-    private final static class NoType implements NoTypeInterface {\n+    final static class NoType implements NoTypeInterface {\n         public int a = 3;\n     }\n     \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPolymorphicWithDefaultImpl.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+\n+/**\n+ * Unit tests related to specialized handling of \"default implementation\"\n+ * ({@link JsonTypeInfo#defaultImpl}), as well as related\n+ * cases that allow non-default settings (such as missing type id).\n+ */\n+public class TestPolymorphicWithDefaultImpl extends BaseMapTest\n+{\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\", defaultImpl = LegacyInter.class)\n+    @JsonSubTypes(value = {@JsonSubTypes.Type(name = \"mine\", value = MyInter.class)})\n+    public static interface Inter { }\n+\n+    public static class MyInter implements Inter {\n+        @JsonProperty(\"blah\") public List<String> blah;\n+    }\n+\n+    public static class LegacyInter extends MyInter\n+    {\n+        @JsonCreator\n+        LegacyInter(Object obj)\n+        {\n+            if (obj instanceof List) {\n+                blah = new ArrayList<String>();\n+                for (Object o : (List<?>) obj) {\n+                    blah.add(o.toString());\n+                }\n+            }\n+            else if (obj instanceof String) {\n+                blah = Arrays.asList(((String) obj).split(\",\"));\n+            }\n+            else {\n+                throw new IllegalArgumentException(\"Unknown type: \" + obj.getClass());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Note: <code>NoClass</code> here has special meaning, of mapping invalid\n+     * types into null instances.\n+     */\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\",\n+            defaultImpl = NoClass.class)\n+    public static class DefaultWithNoClass { }\n+\n+    /**\n+     * Also another variant to verify that from 2.5 on, can use non-deprecated\n+     * value for the same.\n+     */\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\",\n+            defaultImpl = Void.class)\n+    public static class DefaultWithVoidAsDefault { }\n+\n+    // and then one with no defaultImpl nor listed subtypes\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\")\n+    abstract static class MysteryPolymorphic { }\n+\n+    // [Databind#511] types\n+\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.WRAPPER_OBJECT)\n+    @JsonSubTypes(@JsonSubTypes.Type(name=\"sub1\", value = BadSub1.class))\n+    public static class BadItem {}\n+\n+    public static class BadSub1 extends BadItem {\n+        public String a ;\n+    }\n+\n+    public static class Good {\n+        public List<GoodItem> many;\n+    }\n+\n+    public static class Bad {\n+        public List<BadItem> many;\n+    }\n+ \n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.WRAPPER_OBJECT)\n+    @JsonSubTypes({@JsonSubTypes.Type(name=\"sub1\", value = GoodSub1.class),\n+            @JsonSubTypes.Type(name=\"sub2\", value = GoodSub2.class) })\n+    public static class GoodItem {}\n+\n+    public static class GoodSub1 extends GoodItem {\n+        public String a;\n+    }\n+    public static class GoodSub2 extends GoodItem {\n+        public String b;\n+\n+    }\n+\n+    // for [databind#656]\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include= JsonTypeInfo.As.WRAPPER_OBJECT, defaultImpl=ImplFor656.class)\n+    static abstract class BaseFor656 { }\n+\n+    static class ImplFor656 extends BaseFor656 {\n+        public int a;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests, deserialization\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testDeserializationWithObject() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"{\\\"type\\\": \\\"mine\\\", \\\"blah\\\": [\\\"a\\\", \\\"b\\\", \\\"c\\\"]}\");\n+        assertTrue(inter instanceof MyInter);\n+        assertFalse(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), ((MyInter) inter).blah);\n+    }\n+\n+    public void testDeserializationWithString() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"\\\"a,b,c,d\\\"\");\n+        assertTrue(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\"), ((MyInter) inter).blah);\n+    }\n+\n+    public void testDeserializationWithArray() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"[\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"]\");\n+        assertTrue(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\"), ((MyInter) inter).blah);\n+    }\n+\n+    public void testDeserializationWithArrayOfSize2() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"[\\\"a\\\", \\\"b\\\"]\");\n+        assertTrue(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\"), ((MyInter) inter).blah);\n+    }\n+\n+    // [Databind#148]\n+    public void testDefaultAsNoClass() throws Exception\n+    {\n+        Object ob = MAPPER.reader(DefaultWithNoClass.class).readValue(\"{ }\");\n+        assertNull(ob);\n+        ob = MAPPER.reader(DefaultWithNoClass.class).readValue(\"{ \\\"bogus\\\":3 }\");\n+        assertNull(ob);\n+    }\n+\n+    // same, with 2.5 and Void.class\n+    public void testDefaultAsVoid() throws Exception\n+    {\n+        Object ob = MAPPER.reader(DefaultWithVoidAsDefault.class).readValue(\"{ }\");\n+        assertNull(ob);\n+        ob = MAPPER.reader(DefaultWithVoidAsDefault.class).readValue(\"{ \\\"bogus\\\":3 }\");\n+        assertNull(ob);\n+    }\n+\n+    // [Databind#148]\n+    public void testBadTypeAsNull() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.disable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);\n+        Object ob = mapper.readValue(\"{}\", MysteryPolymorphic.class);\n+        assertNull(ob);\n+        ob = mapper.readValue(\"{ \\\"whatever\\\":13}\", MysteryPolymorphic.class);\n+        assertNull(ob);\n+    }\n+\n+    // [Databind#511]\n+    public void testInvalidTypeId511() throws Exception {\n+        ObjectReader reader = MAPPER.reader().without(\n+                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE,\n+                DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,\n+                DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES\n+        );\n+        String json = \"{\\\"many\\\":[{\\\"sub1\\\":{\\\"a\\\":\\\"foo\\\"}},{\\\"sub2\\\":{\\\"b\\\":\\\"bar\\\"}}]}\" ;\n+        Good goodResult = reader.forType(Good.class).readValue(json) ;\n+        assertNotNull(goodResult) ;\n+        Bad badResult = reader.forType(Bad.class).readValue(json);\n+        assertNotNull(badResult);\n+    }\n+\n+    // [Databind#656]\n+    public void testDefaultImplWithObjectWrapper() throws Exception\n+    {\n+        BaseFor656 value = MAPPER.readValue(aposToQuotes(\"{'foobar':{'a':3}}\"), BaseFor656.class);\n+        assertNotNull(value);\n+        assertEquals(ImplFor656.class, value.getClass());\n+        assertEquals(3, ((ImplFor656) value).a);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests, serialization\n+    /**********************************************************\n+     */\n+\n+    /*\n+    public void testDontWriteIfDefaultImpl() throws Exception {\n+        String json = MAPPER.writeValueAsString(new MyInter());\n+        assertEquals(\"{\\\"blah\\\":null}\", json);\n+    }\n+    */\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPropertyTypeInfo.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPropertyTypeInfo.java\n     \n     static class MethodWrapperBean\n     {\n-        private Object value;\n+        protected Object value;\n         \n         @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)\n         public Object getValue() { return value; }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypes.java\n \n \n import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.annotation.JsonTypeName;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n     static class DefaultImpl505 extends SuperTypeWithoutDefault {\n         public int a;\n     }\n-    \n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=As.PROPERTY, property=\"type\")\n+    @JsonSubTypes({ @JsonSubTypes.Type(ImplX.class),\n+          @JsonSubTypes.Type(ImplY.class) })\n+    static abstract class BaseX { }\n+\n+    @JsonTypeName(\"x\")\n+    static class ImplX extends BaseX {\n+        public int x;\n+    }\n+\n+    @JsonTypeName(\"y\")\n+    static class ImplY extends BaseX {\n+        public int y;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertEquals(0, ((DefaultImpl505) bean).a);\n     \n     }\n+\n+    public void testErrorMessage() throws Exception {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.readValue(\"{ \\\"type\\\": \\\"z\\\"}\", BaseX.class);\n+            fail(\"Should have failed\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"known type ids =\");\n+        }\n+    }\n }\n-\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypesExistingProperty.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestSubtypesExistingProperty extends BaseMapTest {\n+\n+    /**\n+     * Polymorphic base class - existing property as simple property on subclasses\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\",\n+\t        visible=true)\n+\t@JsonSubTypes({\n+\t\t@Type(value = Apple.class, name = \"apple\") ,\n+\t\t@Type(value = Orange.class, name = \"orange\") \n+\t\t})\n+\tstatic abstract class Fruit {\n+        public String name;\n+        protected Fruit(String n)  { name = n; }\n+    }\n+\n+    @JsonTypeName(\"apple\")\n+    static class Apple extends Fruit\n+    {\n+        public int seedCount;\n+        public String type;\n+\n+        private Apple() { super(null);; }\n+        public Apple(String name, int b) {\n+            super(name);\n+            seedCount = b;\n+            type = \"apple\";\n+        }\n+    }\n+    \n+    @JsonTypeName(\"orange\")\n+    static class Orange extends Fruit\n+    {\n+        public String color;\n+        public String type;\n+        \n+        private Orange() { super(null); }\n+        public Orange(String name, String c) {\n+            super(name);\n+            color = c;\n+            type = \"orange\";\n+        }\n+    }\n+\n+    static class FruitWrapper {\n+        public Fruit fruit;\n+        public FruitWrapper() {}\n+        public FruitWrapper(Fruit f) { fruit = f; }\n+    }\n+    \n+    /**\n+     * Polymorphic base class - existing property forced by abstract method\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Dog.class, name = \"doggie\") ,\n+\t\t@Type(value = Cat.class, name = \"kitty\") \n+\t\t})\n+\tstatic abstract class Animal {\n+        public String name;\n+        \n+        protected Animal(String n)  { name = n; }\n+        \n+        public abstract String getType();\n+    }\n+\n+    @JsonTypeName(\"doggie\")\n+    static class Dog extends Animal\n+    {\n+        public int boneCount;\n+        \n+        private Dog() { super(null); }\n+        public Dog(String name, int b) {\n+            super(name);\n+            boneCount = b;\n+        }\n+        \n+ \t\t@Override\n+\t\tpublic String getType() {\n+        \treturn \"doggie\";\n+        }        \n+    }\n+    \n+    @JsonTypeName(\"kitty\")\n+    static class Cat extends Animal\n+    {\n+        public String furColor;\n+        \n+        private Cat() { super(null); }\n+        public Cat(String name, String c) {\n+            super(name);\n+            furColor = c;\n+        }\n+        \n+\t\t@Override\n+\t\tpublic String getType() {\n+        \treturn \"kitty\";\n+        }        \n+    }\n+\n+    static class AnimalWrapper {\n+        public Animal animal;\n+        public AnimalWrapper() {}\n+        public AnimalWrapper(Animal a) { animal = a; }\n+    }\n+\n+\n+    /**\n+     * Polymorphic base class - existing property NOT forced by abstract method on base class\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Accord.class, name = \"accord\") ,\n+\t\t@Type(value = Camry.class, name = \"camry\") \n+\t\t})\n+\tstatic abstract class Car {\n+        public String name;        \n+        protected Car(String n)  { name = n; }\n+    }\n+\n+    @JsonTypeName(\"accord\")\n+    static class Accord extends Car\n+    {\n+        public int speakerCount;\n+        \n+        private Accord() { super(null); }\n+        public Accord(String name, int b) {\n+            super(name);\n+            speakerCount = b;\n+        }\n+        \n+\t\tpublic String getType() {\n+        \treturn \"accord\";\n+        }        \n+    }\n+    \n+    @JsonTypeName(\"camry\")\n+    static class Camry extends Car\n+    {\n+        public String exteriorColor;\n+        \n+        private Camry() { super(null); }\n+        public Camry(String name, String c) {\n+            super(name);\n+            exteriorColor = c;\n+        }\n+        \n+\t\tpublic String getType() {\n+        \treturn \"camry\";\n+        }        \n+    }\n+\n+    static class CarWrapper {\n+        public Car car;\n+        public CarWrapper() {}\n+        public CarWrapper(Car c) { car = c; }\n+    }\n+    \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    /*\n+    /**********************************************************\n+    /* Mock data\n+    /**********************************************************\n+     */\n+\n+\tprivate static final Orange mandarin = new Orange(\"Mandarin Orange\", \"orange\");\n+\tprivate static final String mandarinJson = \"{\\\"name\\\":\\\"Mandarin Orange\\\",\\\"color\\\":\\\"orange\\\",\\\"type\\\":\\\"orange\\\"}\";\t\n+\tprivate static final Apple pinguo = new Apple(\"Apple-A-Day\", 16);\n+\tprivate static final String pinguoJson = \"{\\\"name\\\":\\\"Apple-A-Day\\\",\\\"seedCount\\\":16,\\\"type\\\":\\\"apple\\\"}\";\n+\tprivate static final FruitWrapper pinguoWrapper = new FruitWrapper(pinguo);\n+\tprivate static final String pinguoWrapperJson = \"{\\\"fruit\\\":\" + pinguoJson + \"}\";\n+\tprivate static final List<Fruit> fruitList = Arrays.asList(pinguo, mandarin);\n+\tprivate static final String fruitListJson = \"[\" + pinguoJson + \",\" + mandarinJson + \"]\";\n+\n+\tprivate static final Cat beelzebub = new Cat(\"Beelzebub\", \"tabby\");\n+\tprivate static final String beelzebubJson = \"{\\\"name\\\":\\\"Beelzebub\\\",\\\"furColor\\\":\\\"tabby\\\",\\\"type\\\":\\\"kitty\\\"}\";\t\n+\tprivate static final Dog rover = new Dog(\"Rover\", 42);\n+\tprivate static final String roverJson = \"{\\\"name\\\":\\\"Rover\\\",\\\"boneCount\\\":42,\\\"type\\\":\\\"doggie\\\"}\";\n+\tprivate static final AnimalWrapper beelzebubWrapper = new AnimalWrapper(beelzebub);\n+\tprivate static final String beelzebubWrapperJson = \"{\\\"animal\\\":\" + beelzebubJson + \"}\";\n+\tprivate static final List<Animal> animalList = Arrays.asList(beelzebub, rover);\n+\tprivate static final String animalListJson = \"[\" + beelzebubJson + \",\" + roverJson + \"]\";\n+\n+\tprivate static final Camry camry = new Camry(\"Sweet Ride\", \"candy-apple-red\");\n+\tprivate static final String camryJson = \"{\\\"name\\\":\\\"Sweet Ride\\\",\\\"exteriorColor\\\":\\\"candy-apple-red\\\",\\\"type\\\":\\\"camry\\\"}\";\t\n+\tprivate static final Accord accord = new Accord(\"Road Rage\", 6);\n+\tprivate static final String accordJson = \"{\\\"name\\\":\\\"Road Rage\\\",\\\"speakerCount\\\":6,\\\"type\\\":\\\"accord\\\"}\";\n+\tprivate static final CarWrapper camryWrapper = new CarWrapper(camry);\n+\tprivate static final String camryWrapperJson = \"{\\\"car\\\":\" + camryJson + \"}\";\n+\tprivate static final List<Car> carList = Arrays.asList(camry, accord);\n+\tprivate static final String carListJson = \"[\" + camryJson + \",\" + accordJson + \"]\";\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fruits - serialization tests for simple property on sub-classes\n+     */\n+    public void testExistingPropertySerializationFruits() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, pinguo);\n+        assertEquals(3, result.size());\n+        assertEquals(pinguo.name, result.get(\"name\"));\n+        assertEquals(pinguo.seedCount, result.get(\"seedCount\"));\n+        assertEquals(pinguo.type, result.get(\"type\"));\n+        \n+        result = writeAndMap(MAPPER, mandarin);\n+        assertEquals(3, result.size());\n+        assertEquals(mandarin.name, result.get(\"name\"));\n+        assertEquals(mandarin.color, result.get(\"color\"));\n+        assertEquals(mandarin.type, result.get(\"type\"));\n+        \n+        String pinguoSerialized = MAPPER.writeValueAsString(pinguo);\n+        assertEquals(pinguoSerialized, pinguoJson);\n+\n+        String mandarinSerialized = MAPPER.writeValueAsString(mandarin);\n+        assertEquals(mandarinSerialized, mandarinJson);\n+\n+        String fruitWrapperSerialized = MAPPER.writeValueAsString(pinguoWrapper);\n+        assertEquals(fruitWrapperSerialized, pinguoWrapperJson);\n+\n+        String fruitListSerialized = MAPPER.writeValueAsString(fruitList);\n+        assertEquals(fruitListSerialized, fruitListJson);\n+    }\n+\n+    /**\n+     * Fruits - deserialization tests for simple property on sub-classes\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationFruits() throws Exception\n+    {\n+        Fruit pinguoDeserialized = MAPPER.readValue(pinguoJson, Fruit.class);\n+        assertTrue(pinguoDeserialized instanceof Apple);\n+        assertSame(pinguoDeserialized.getClass(), Apple.class);\n+        assertEquals(pinguo.name, pinguoDeserialized.name);\n+        assertEquals(pinguo.seedCount, ((Apple) pinguoDeserialized).seedCount);\n+        assertEquals(pinguo.type, ((Apple) pinguoDeserialized).type);\n+\n+        FruitWrapper pinguoWrapperDeserialized = MAPPER.readValue(pinguoWrapperJson, FruitWrapper.class);\n+        Fruit pinguoExtracted = pinguoWrapperDeserialized.fruit;\n+        assertTrue(pinguoExtracted instanceof Apple);\n+        assertSame(pinguoExtracted.getClass(), Apple.class);\n+        assertEquals(pinguo.name, pinguoExtracted.name);\n+        assertEquals(pinguo.seedCount, ((Apple) pinguoExtracted).seedCount);\n+        assertEquals(pinguo.type, ((Apple) pinguoExtracted).type);\n+\n+        Fruit[] fruits = MAPPER.readValue(fruitListJson, Fruit[].class);\n+        assertEquals(2, fruits.length);\n+        assertEquals(Apple.class, fruits[0].getClass());\n+        assertEquals(\"apple\", ((Apple) fruits[0]).type);\n+        assertEquals(Orange.class, fruits[1].getClass());\n+        assertEquals(\"orange\", ((Orange) fruits[1]).type);\n+        \n+        List<Fruit> f2 = MAPPER.readValue(fruitListJson,\n+                new TypeReference<List<Fruit>>() { });\n+        assertNotNull(f2);\n+        assertTrue(f2.size() == 2);\n+        assertEquals(Apple.class, f2.get(0).getClass());\n+        assertEquals(Orange.class, f2.get(1).getClass());\n+    }\n+\n+    /**\n+     * Animals - serialization tests for abstract method in base class\n+     */\n+    public void testExistingPropertySerializationAnimals() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, beelzebub);\n+        assertEquals(3, result.size());\n+        assertEquals(beelzebub.name, result.get(\"name\"));\n+        assertEquals(beelzebub.furColor, result.get(\"furColor\"));\n+        assertEquals(beelzebub.getType(), result.get(\"type\"));\n+\n+        result = writeAndMap(MAPPER, rover);\n+        assertEquals(3, result.size());\n+        assertEquals(rover.name, result.get(\"name\"));\n+        assertEquals(rover.boneCount, result.get(\"boneCount\"));\n+        assertEquals(rover.getType(), result.get(\"type\"));\n+        \n+        String beelzebubSerialized = MAPPER.writeValueAsString(beelzebub);\n+        assertEquals(beelzebubSerialized, beelzebubJson);\n+        \n+        String roverSerialized = MAPPER.writeValueAsString(rover);\n+        assertEquals(roverSerialized, roverJson);\n+        \n+        String animalWrapperSerialized = MAPPER.writeValueAsString(beelzebubWrapper);\n+        assertEquals(animalWrapperSerialized, beelzebubWrapperJson);\n+\n+        String animalListSerialized = MAPPER.writeValueAsString(animalList);\n+        assertEquals(animalListSerialized, animalListJson);\n+    }\n+\n+    /**\n+     * Animals - deserialization tests for abstract method in base class\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationAnimals() throws Exception\n+    {\n+        Animal beelzebubDeserialized = MAPPER.readValue(beelzebubJson, Animal.class);\n+        assertTrue(beelzebubDeserialized instanceof Cat);\n+        assertSame(beelzebubDeserialized.getClass(), Cat.class);\n+        assertEquals(beelzebub.name, beelzebubDeserialized.name);\n+        assertEquals(beelzebub.furColor, ((Cat) beelzebubDeserialized).furColor);\n+        assertEquals(beelzebub.getType(), beelzebubDeserialized.getType());\n+\n+        AnimalWrapper beelzebubWrapperDeserialized = MAPPER.readValue(beelzebubWrapperJson, AnimalWrapper.class);\n+        Animal beelzebubExtracted = beelzebubWrapperDeserialized.animal;\n+        assertTrue(beelzebubExtracted instanceof Cat);\n+        assertSame(beelzebubExtracted.getClass(), Cat.class);\n+        assertEquals(beelzebub.name, beelzebubExtracted.name);\n+        assertEquals(beelzebub.furColor, ((Cat) beelzebubExtracted).furColor);\n+        assertEquals(beelzebub.getType(), beelzebubExtracted.getType());\n+    \t\n+        @SuppressWarnings(\"unchecked\")\n+        List<Animal> animalListDeserialized = MAPPER.readValue(animalListJson, List.class);\n+        assertNotNull(animalListDeserialized);\n+        assertTrue(animalListDeserialized.size() == 2);\n+        Animal cat = MAPPER.convertValue(animalListDeserialized.get(0), Animal.class);\n+        assertTrue(cat instanceof Cat);\n+        assertSame(cat.getClass(), Cat.class);\n+        Animal dog = MAPPER.convertValue(animalListDeserialized.get(1), Animal.class);\n+        assertTrue(dog instanceof Dog);\n+        assertSame(dog.getClass(), Dog.class);\n+    }\n+\n+    /**\n+     * Cars - serialization tests for no abstract method or type variable in base class\n+     */\n+    public void testExistingPropertySerializationCars() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, camry);\n+        assertEquals(3, result.size());\n+        assertEquals(camry.name, result.get(\"name\"));\n+        assertEquals(camry.exteriorColor, result.get(\"exteriorColor\"));\n+        assertEquals(camry.getType(), result.get(\"type\"));\n+\n+        result = writeAndMap(MAPPER, accord);\n+        assertEquals(3, result.size());\n+        assertEquals(accord.name, result.get(\"name\"));\n+        assertEquals(accord.speakerCount, result.get(\"speakerCount\"));\n+        assertEquals(accord.getType(), result.get(\"type\"));\n+        \n+        String camrySerialized = MAPPER.writeValueAsString(camry);\n+        assertEquals(camrySerialized, camryJson);\n+        \n+        String accordSerialized = MAPPER.writeValueAsString(accord);\n+        assertEquals(accordSerialized, accordJson);\n+        \n+        String carWrapperSerialized = MAPPER.writeValueAsString(camryWrapper);\n+        assertEquals(carWrapperSerialized, camryWrapperJson);\n+\n+        String carListSerialized = MAPPER.writeValueAsString(carList);\n+        assertEquals(carListSerialized, carListJson);\n+    }\n+\n+    /**\n+     * Cars - deserialization tests for no abstract method or type variable in base class\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationCars() throws Exception\n+    {\n+        Car camryDeserialized = MAPPER.readValue(camryJson, Camry.class);\n+        assertTrue(camryDeserialized instanceof Camry);\n+        assertSame(camryDeserialized.getClass(), Camry.class);\n+        assertEquals(camry.name, camryDeserialized.name);\n+        assertEquals(camry.exteriorColor, ((Camry) camryDeserialized).exteriorColor);\n+        assertEquals(camry.getType(), ((Camry) camryDeserialized).getType());\n+\n+        CarWrapper camryWrapperDeserialized = MAPPER.readValue(camryWrapperJson, CarWrapper.class);\n+        Car camryExtracted = camryWrapperDeserialized.car;\n+        assertTrue(camryExtracted instanceof Camry);\n+        assertSame(camryExtracted.getClass(), Camry.class);\n+        assertEquals(camry.name, camryExtracted.name);\n+        assertEquals(camry.exteriorColor, ((Camry) camryExtracted).exteriorColor);\n+        assertEquals(camry.getType(), ((Camry) camryExtracted).getType());\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<Car> carListDeserialized = MAPPER.readValue(carListJson, List.class);\n+        assertNotNull(carListDeserialized);\n+        assertTrue(carListDeserialized.size() == 2);\n+        Car result = MAPPER.convertValue(carListDeserialized.get(0), Car.class);\n+        assertTrue(result instanceof Camry);\n+        assertSame(result.getClass(), Camry.class);\n+\n+        result = MAPPER.convertValue(carListDeserialized.get(1), Car.class);\n+        assertTrue(result instanceof Accord);\n+        assertSame(result.getClass(), Accord.class);\n+    }\n+}    \n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArrayDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArrayDeserialization.java\n     {\n         ObjectMapper m = new ObjectMapper();\n         // use class name, WRAPPER_OBJECT\n-        m.addMixInAnnotations(long[].class, WrapperMixIn.class);\n+        m.addMixIn(long[].class, WrapperMixIn.class);\n         String JSON = \"{\\\"\"+long[].class.getName()+\"\\\":[5, 6, 7]}\";\n         long[] value = m.readValue(JSON, long[].class);\n         assertNotNull(value);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n     public void testIntArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(int[].class, WrapperMixIn.class);\n+        m.addMixIn(int[].class, WrapperMixIn.class);\n         int[] input = new int[] { 1, 2, 3 };\n         String clsName = int[].class.getName();\n         assertEquals(\"{\\\"\"+clsName+\"\\\":[1,2,3]}\", serializeAsString(m, input));\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedContainerSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedContainerSerialization.java\n     {\n             ArrayList<Animal> animals = new ArrayList<Animal>();\n             animals.add(new Dog(\"Spot\"));\n-            JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class);\n-            String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator());\n+            JavaType rootType = TypeFactory.defaultInstance().constructParametrizedType(Iterator.class, Iterator.class, Animal.class);\n+            String json = mapper.writerFor(rootType).writeValueAsString(animals.iterator());\n             if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n                 fail(\"No polymorphic type retained, should be; JSON = '\"+json+\"'\");\n             }\n             l2.add(new Issue508A());\n             l.add(l2);\n             TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() {};\n-            String json = mapper.writerWithType(typeRef).writeValueAsString(l);\n+            String json = mapper.writerFor(typeRef).writeValueAsString(l);\n \n             List<?> output = mapper.readValue(json, typeRef);\n             assertEquals(1, output.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserialization.java\n     public void testTypeAsWrapper() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Animal.class, TypeWithWrapper.class);\n+        m.addMixIn(Animal.class, TypeWithWrapper.class);\n         String JSON = \"{\\\".TestTypedDeserialization$Dog\\\" : \"\n             +asJSONObjectValueString(m, \"name\", \"Scooby\", \"boneCount\", \"6\")+\" }\";\n         Animal a = m.readValue(JSON, Animal.class);\n     public void testTypeAsArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Animal.class, TypeWithArray.class);\n+        m.addMixIn(Animal.class, TypeWithArray.class);\n         // hmmh. Not good idea to rely on exact output, order may change. But...\n         String JSON = \"[\\\"\"+Dog.class.getName()+\"\\\", \"\n             +asJSONObjectValueString(m, \"name\", \"Martti\", \"boneCount\", \"11\")+\" ]\";\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n     public void testTypeAsWrapper() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Animal.class, TypeWithWrapper.class);\n+        m.addMixIn(Animal.class, TypeWithWrapper.class);\n         Map<String,Object> result = writeAndMap(m, new Cat(\"Venla\", \"black\"));\n         // should get a wrapper; keyed by minimal class name (\"Cat\" here)\n         assertEquals(1, result.size());\n     public void testTypeAsArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Animal.class, TypeWithArray.class);\n+        m.addMixIn(Animal.class, TypeWithArray.class);\n         // hmmh. Not good idea to rely on exact output, order may change. But...\n         Map<String,Object> result = writeAndMap(m, new AnimalWrapper(new Dog(\"Amadeus\", 7)));\n         // First level, wrapper\n         List<Super> list = new ArrayList<Super>();\n         list.add(new A());\n         map.put(1L, list);\n-        String json = mapper.writerWithType(new TypeReference<Map<Long, Collection<Super>>>() {}).writeValueAsString(map);\n+        String json = mapper.writerFor(new TypeReference<Map<Long, Collection<Super>>>() {}).writeValueAsString(map);\n         assertTrue(\"JSON does not contain '@class': \"+json, json.contains(\"@class\"));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestVisibleTypeId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestVisibleTypeId.java\n package com.fasterxml.jackson.databind.jsontype;\n \n-import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n-import com.fasterxml.jackson.annotation.JsonSubTypes;\n-import com.fasterxml.jackson.annotation.JsonTypeId;\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n-import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n import com.fasterxml.jackson.databind.*;\n \n /**\n         public void setType(String t) { type = t; }\n     }\n \n-    // as external id, bit trickier\n-    static class ExternalIdWrapper {\n-        @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.EXTERNAL_PROPERTY,\n-                property=\"type\", visible=true)\n-        public ExternalIdBean bean = new ExternalIdBean();\n-    }\n-    \n     @JsonTypeName(\"ExternalType\")\n     static class ExternalIdBean {\n         public int a = 2;\n         public String getName() { return \"bob\"; }\n         \n         public int age = 41;\n+    }\n+\n+    // [databind#408]\n+    static class ExternalBeanWithId\n+    {\n+        protected String _type;\n+        \n+        @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property=\"type\", visible=true)\n+        public ValueBean bean;\n+\n+        public ExternalBeanWithId() { }\n+        public ExternalBeanWithId(int v) {\n+            bean = new ValueBean(v);\n+        }\n+\n+        public void setType(String t) {\n+            _type = t;\n+        }\n+    }\n+\n+    @JsonTypeName(\"vbean\")\n+    static class ValueBean {\n+        public int value;\n+        \n+        public ValueBean() { }\n+        public ValueBean(int v) { value = v; }\n     }\n     \n     /*\n         assertEquals(\"ObjectType\", result.type);\n     }\n \n-    public void testVisibleWithExternalId() throws Exception\n-    {\n-        String json = MAPPER.writeValueAsString(new ExternalIdWrapper());\n-        // but then expect to read it back\n-        ExternalIdWrapper result = MAPPER.readValue(json, ExternalIdWrapper.class);\n-        assertEquals(\"ExternalType\", result.bean.type);\n-        assertEquals(2, result.bean.a);\n-    }\n-\n-    // [JACKSON-762]\n-\n     public void testTypeIdFromProperty() throws Exception\n     {\n         assertEquals(\"{\\\"type\\\":\\\"SomeType\\\",\\\"a\\\":3}\",\n         I263Base result = MAPPER.readValue(\"{\\\"age\\\":19,\\\"name\\\":\\\"bob\\\"}\", I263Base.class);\n         assertTrue(result instanceof I263Impl);\n         assertEquals(19, ((I263Impl) result).age);\n+    }\n+\n+    // [databind#408]\n+    /* NOTE: Handling changed between 2.4 and 2.5; earlier, type id was 'injected'\n+     *  inside POJO; but with 2.5 this was fixed so it would remain outside, similar\n+     *  to how JSON structure is.\n+     */\n+    public void testVisibleTypeId408() throws Exception\n+    {\n+        String json = MAPPER.writeValueAsString(new ExternalBeanWithId(3));\n+        ExternalBeanWithId result = MAPPER.readValue(json, ExternalBeanWithId.class);\n+        assertNotNull(result);\n+        assertNotNull(result.bean);\n+        assertEquals(3, result.bean.value);\n+        assertEquals(\"vbean\", result._type);\n     }\n     \n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n         public MyParam(T v) { value = v; }\n     }\n \n-    private static class SomeObject {\n-        @SuppressWarnings(\"unused\")\n+    static class SomeObject {\n         public String someValue = UUID.randomUUID().toString();\n     }\n     \n     {\n         Dog dog = new Dog(\"Fluffy\", 3);\n         ContainerWithGetter<Animal> c2 = new ContainerWithGetter<Animal>(dog);\n-        String json = MAPPER.writerWithType(MAPPER.getTypeFactory().constructParametricType(ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);\n+        String json = MAPPER.writerFor(MAPPER.getTypeFactory().constructParametrizedType(ContainerWithGetter.class, ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);\n         if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n             fail(\"polymorphic type not kept, result == \"+json+\"; should contain 'object-type':'...'\");\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForClass.java\n          * use field\n          */\n         m = new ObjectMapper();\n-        m.addMixInAnnotations(LeafClass.class, MixIn.class);\n+        m.addMixIn(LeafClass.class, MixIn.class);\n         result = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\", LeafClass.class);\n         assertEquals(\"value\", result.a);\n     }\n     public void testClassMixInsMidLevel() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        m.addMixIn(BaseClass.class, MixIn.class);\n         {\n             BaseClass result = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\", BaseClass.class);\n             assertEquals(\"value\", result.a);\n     public void testClassMixInsForObjectClass() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Object.class, MixIn.class);\n+        m.addMixIn(Object.class, MixIn.class);\n         // will be seen for BaseClass\n         {\n             BaseClass result = m.readValue(\"{\\\"a\\\":\\\"\\\"}\", BaseClass.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForCreators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForCreators.java\n     public void testForConstructor() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(BaseClassWithPrivateCtor.class, MixInForPrivate.class);\n+        m.addMixIn(BaseClassWithPrivateCtor.class, MixInForPrivate.class);\n         BaseClassWithPrivateCtor result = m.readValue(\"\\\"?\\\"\", BaseClassWithPrivateCtor.class);\n         assertEquals(\"?...\", result._a);\n     }\n \n         // Then with simple mix-in: should change to use the factory method\n         m = new ObjectMapper();\n-        m.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        m.addMixIn(BaseClass.class, MixIn.class);\n         result = m.readValue(\"\\\"string\\\"\", BaseClass.class);\n         assertEquals(\"stringX\", result._a);\n     }\n     public void testFactoryMixIn() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(StringWrapper.class, StringWrapperMixIn.class);\n+        m.addMixIn(StringWrapper.class, StringWrapperMixIn.class);\n         StringWrapper result = m.readValue(\"\\\"a\\\"\", StringWrapper.class);\n         assertEquals(\"a\", result._value);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForMethods.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForMethods.java\n     public void testWithAnySetter() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        m.addMixIn(BaseClass.class, MixIn.class);\n         BaseClass result = m.readValue(\"{ \\\"a\\\" : 3, \\\"b\\\" : true }\", BaseClass.class);\n         assertNotNull(result);\n         assertEquals(2, result.values.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinInheritance.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinInheritance.java\n     public void testMixinFieldInheritance() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(Beano.class, BeanoMixinSub.class);\n+        mapper.addMixIn(Beano.class, BeanoMixinSub.class);\n         Map<String,Object> result;\n         result = writeAndMap(mapper, new Beano());\n         assertEquals(2, result.size());\n     public void testMixinMethodInheritance() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(Beano2.class, BeanoMixinSub2.class);\n+        mapper.addMixIn(Beano2.class, BeanoMixinSub2.class);\n         Map<String,Object> result;\n         result = writeAndMap(mapper, new Beano2());\n         assertEquals(2, result.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForClass.java\n \n         // then with top-level override\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(LeafClass.class, MixIn.class);\n+        mapper.addMixIn(LeafClass.class, MixIn.class);\n         result = writeAndMap(mapper, new LeafClass(\"abc\"));\n         assertEquals(2, result.size());\n         assertEquals(\"abc\", result.get(\"a\"));\n \n         // mid-level override; should not have any effect\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixIn(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, new LeafClass(\"abc\"));\n         assertEquals(1, result.size());\n         assertEquals(\"abc\", result.get(\"a\"));\n \n         // then with working mid-level override, which effectively suppresses 'a'\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(BaseClass.class, MixInAutoDetect.class);\n+        mapper.addMixIn(BaseClass.class, MixInAutoDetect.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(1, result.size());\n         assertEquals(\"c2\", result.get(\"c\"));\n         result = writeAndMap(mapper2, bean);\n         assertEquals(2, result.size());\n         ObjectMapper mapper3 = mapper2.copy();\n-        mapper3.addMixInAnnotations(BaseClass.class, MixInAutoDetect.class);\n+        mapper3.addMixIn(BaseClass.class, MixInAutoDetect.class);\n         result = writeAndMap(mapper3, bean);\n         assertEquals(1, result.size());\n         assertEquals(\"c2\", result.get(\"c\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForFields.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForFields.java\n \n         // and then with simple mix-in\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixIn(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(2, result.size());\n         assertEquals(\"1\", result.get(\"a\"));\n         HashMap<Class<?>,Class<?>> mixins = new HashMap<Class<?>,Class<?>>();\n         mixins.put(SubClass.class, MixIn.class);\n         mixins.put(BaseClass.class, MixIn2.class);\n-        mapper.setMixInAnnotations(mixins);\n+        mapper.setMixIns(mixins);\n \n         Map<String,Object> result;\n         result = writeAndMap(mapper, new SubClass(\"1\", \"2\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForMethods.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForMethods.java\n \n         // then with leaf-level mix-in\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixIn(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(2, result.size());\n         assertEquals(\"b2\", result.get(\"b2\"));\n         Map<String,Object> result;\n         LeafClass bean = new LeafClass(\"XXX\", \"b2\");\n \n-        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixIn(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(1, result.size());\n         assertEquals(\"XXX\", result.get(\"a\"));\n     public void testIntermediateMixin2() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(EmptyBean.class, MixInForSimple.class);\n+        mapper.addMixIn(EmptyBean.class, MixInForSimple.class);\n         Map<String,Object> result = writeAndMap(mapper, new SimpleBean());\n         assertEquals(1, result.size());\n         assertEquals(Integer.valueOf(42), result.get(\"x\"));\n     public void testObjectMixin() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(Object.class, ObjectMixIn.class);\n+        mapper.addMixIn(Object.class, ObjectMixIn.class);\n \n         // First, with our bean...\n         Map<String,Object> result = writeAndMap(mapper, new BaseClass(\"a\", \"b\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n \n         // Property SerializationConfig.SerializationFeature.DEFAULT_VIEW_INCLUSION set to false\n         mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, Boolean.FALSE);\n-        mapper.addMixInAnnotations(A.class, AMixInAnnotation.class);\n+        mapper.addMixIn(A.class, AMixInAnnotation.class);\n         String json = mapper.writerWithView(AView.class).writeValueAsString(a);\n \n         assertTrue(json.indexOf(\"\\\"name\\\"\") > 0);\n       sourceMixins.put( SimpleTestData.class, TestDataJAXBMixin.class );\n       sourceMixins.put( ComplexTestData.class, TestComplexDataJAXBMixin.class );\n       \n-      objectMapper.setMixInAnnotations(sourceMixins);\n+      objectMapper.setMixIns(sourceMixins);\n       return objectMapper;\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestDuplicateRegistration.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestDuplicateRegistration extends BaseMapTest\n+{\n+    static class MyModule extends Module {\n+        public int regCount;\n+        \n+        public MyModule() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getModuleName() {\n+            return \"TestModule\";\n+        }\n+\n+        @Override\n+        public Version version() {\n+            return Version.unknownVersion();\n+        }\n+\n+        @Override\n+        public void setupModule(SetupContext context) {\n+            ++regCount;\n+        }\n+    }\n+\n+    public void testDuplicateRegistration() throws Exception\n+    {\n+        // by default, duplicate registration should be prevented\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertTrue(mapper.isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS));\n+        MyModule module = new MyModule();\n+        mapper.registerModule(module);\n+        mapper.registerModule(module);\n+        mapper.registerModule(module);\n+        assertEquals(1, module.regCount);\n+\n+        // but may be allowed by changing setting\n+        mapper.disable(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS);\n+        mapper.registerModule(module);\n+        assertEquals(2, module.regCount);\n+\n+        // and ditto for a new instance\n+        ObjectMapper mapper2 = new ObjectMapper();\n+        mapper2.disable(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS);\n+        MyModule module2 = new MyModule();\n+        mapper.registerModule(module2);\n+        mapper.registerModule(module2);\n+        mapper.registerModule(module2);\n+        assertEquals(3, module2.regCount);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifierNameResolution.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifierNameResolution.java\n package com.fasterxml.jackson.databind.module;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.type.TypeBindings;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.type.TypeModifier;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.lang.reflect.Type;\n \n-public class TestTypeModifierNameResolution extends BaseTest {\n-\n+public class TestTypeModifierNameResolution extends BaseMapTest\n+{\n \tinterface MyType {\n \t\tString getData();\n \t\tvoid setData(String data);\n \t{\n \t\tObjectMapper mapper = new ObjectMapper();\n \t\tmapper.setTypeFactory(mapper.getTypeFactory().withModifier(new CustomTypeModifier()));\n-\t\tmapper.addMixInAnnotations(MyType.class, Mixin.class);\n+\t\tmapper.addMixIn(MyType.class, Mixin.class);\n \n \t\tMyType obj = new MyTypeImpl();\n \t\tobj.setData(\"something\");\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n     {\n         String JSON = \"{\\\"leaf\\\":{\\\"value\\\":13}}\";\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(Leaf.class, LeafMixIn.class);\n+        mapper.addMixIn(Leaf.class, LeafMixIn.class);\n         JsonNode root = mapper.readTree(JSON);\n         // Ok, try converting to bean using two mechanisms\n         Root r1 = mapper.treeToValue(root, Root.class);\n     public void testBigDecimalAsPlainStringTreeConversion() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.enable(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n+        mapper.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n         Map<String, Object> map = new HashMap<String, Object>();\n         String PI_STR = \"3.00000000\";\n         map.put(\"pi\", new BigDecimal(PI_STR));\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n import java.math.BigDecimal;\n import java.math.BigInteger;\n \n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonToken;\n-\n import com.fasterxml.jackson.databind.*;\n \n /**\n     {\n         ObjectMapper mapper = new ObjectMapper()\n                 .enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)\n-                .enable(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n+                .enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n         final String INPUT = \"{\\\"x\\\":1e2}\";\n         final JsonNode node = mapper.readTree(INPUT);\n         String result = mapper.writeValueAsString(node);\n \n         // also via ObjectWriter:\n         assertEquals(\"{\\\"x\\\":100}\", mapper.writer().writeValueAsString(node));\n+\n+        // and once more for [core#175]:\n+        BigDecimal bigDecimal = new BigDecimal(100);\n+        JsonNode tree = mapper.valueToTree(bigDecimal);\n+        assertEquals(\"100\", mapper.writeValueAsString(tree));\n     }\n \n     // Related to [Issue#333]\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestTreeMapperSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeMapperSerializer.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * This unit test suite tries to verify that the trees ObjectMapper\n  * constructs can be serialized properly.\n  */\n public class TestTreeMapperSerializer\n-    extends BaseTest\n+    extends BaseMapTest\n {\n     final static String FIELD1 = \"first\";\n     final static String FIELD2 = \"Second?\";\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/seq/ObjectReaderTest.java\n+package com.fasterxml.jackson.databind.seq;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class ObjectReaderTest extends BaseMapTest\n+{\n+    final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testParserFeatures() throws Exception\n+    {\n+        final String JSON = \"[ /* foo */ 7 ]\";\n+        // default won't accept comments, let's change that:\n+        ObjectReader reader = MAPPER.reader(int[].class)\n+                .with(JsonParser.Feature.ALLOW_COMMENTS);\n+\n+        int[] value = reader.readValue(JSON);\n+        assertNotNull(value);\n+        assertEquals(1, value.length);\n+        assertEquals(7, value[0]);\n+\n+        // but also can go back\n+        try {\n+            reader.without(JsonParser.Feature.ALLOW_COMMENTS).readValue(JSON);\n+            fail(\"Should not have passed\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"foo\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/seq/ObjectWriterTest.java\n+package com.fasterxml.jackson.databind.seq;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+/**\n+ * Unit tests for checking features added to {@link ObjectWriter}, such\n+ * as adding of explicit pretty printer.\n+ */\n+public class ObjectWriterTest\n+    extends BaseMapTest\n+{\n+    final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = \"type\")\n+    static class PolyBase {\n+    }\n+\n+    @JsonTypeName(\"A\")\n+    static class ImplA extends PolyBase {\n+        public int value;\n+        \n+        public ImplA(int v) { value = v; }\n+    }\n+\n+    @JsonTypeName(\"B\")\n+    static class ImplB extends PolyBase {\n+        public int b;\n+        \n+        public ImplB(int v) { b = v; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    public void testPrettyPrinter() throws Exception\n+    {\n+        ObjectWriter writer = MAPPER.writer();\n+        HashMap<String, Integer> data = new HashMap<String,Integer>();\n+        data.put(\"a\", 1);\n+        \n+        // default: no indentation\n+        assertEquals(\"{\\\"a\\\":1}\", writer.writeValueAsString(data));\n+\n+        // and then with standard\n+        writer = writer.withDefaultPrettyPrinter();\n+\n+        // pretty printer uses system-specific line feeds, so we do that as well.\n+        String lf = System.getProperty(\"line.separator\");\n+        assertEquals(\"{\" + lf + \"  \\\"a\\\" : 1\" + lf + \"}\", writer.writeValueAsString(data));\n+\n+        // and finally, again without indentation\n+        writer = writer.with((PrettyPrinter) null);\n+        assertEquals(\"{\\\"a\\\":1}\", writer.writeValueAsString(data));\n+    }\n+\n+    public void testPrefetch() throws Exception\n+    {\n+        ObjectWriter writer = MAPPER.writer();\n+        assertFalse(writer.hasPrefetchedSerializer());\n+        writer = writer.forType(String.class);\n+        assertTrue(writer.hasPrefetchedSerializer());\n+    }\n+\n+    public void testObjectWriterFeatures() throws Exception\n+    {\n+        ObjectWriter writer = MAPPER.writer()\n+                .without(JsonGenerator.Feature.QUOTE_FIELD_NAMES);                \n+        Map<String,Integer> map = new HashMap<String,Integer>();\n+        map.put(\"a\", 1);\n+        assertEquals(\"{a:1}\", writer.writeValueAsString(map));\n+        // but can also reconfigure\n+        assertEquals(\"{\\\"a\\\":1}\", writer.with(JsonGenerator.Feature.QUOTE_FIELD_NAMES)\n+                .writeValueAsString(map));\n+    }\n+\n+    public void testObjectWriterWithNode() throws Exception\n+    {\n+        ObjectNode stuff = MAPPER.createObjectNode();\n+        stuff.put(\"a\", 5);\n+        ObjectWriter writer = MAPPER.writerFor(JsonNode.class);\n+        String json = writer.writeValueAsString(stuff);\n+        assertEquals(\"{\\\"a\\\":5}\", json);\n+    }\n+\n+    public void testPolymorpicWithTyping() throws Exception\n+    {\n+        ObjectWriter writer = MAPPER.writerFor(PolyBase.class);\n+        String json;\n+\n+        json = writer.writeValueAsString(new ImplA(3));\n+        assertEquals(aposToQuotes(\"{'type':'A','value':3}\"), json);\n+        json = writer.writeValueAsString(new ImplB(-5));\n+        assertEquals(aposToQuotes(\"{'type':'B','b':-5}\"), json);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/seq/ReadValuesTest.java\n+package com.fasterxml.jackson.databind.seq;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.MappingIterator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+@SuppressWarnings(\"resource\")\n+public class ReadValuesTest extends BaseMapTest\n+{\n+    static class Bean {\n+        public int a;\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == null || o.getClass() != getClass()) return false;\n+            Bean other = (Bean) o;\n+            return other.a == this.a;\n+        }\n+        @Override public int hashCode() { return a; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests; root-level value sequences via Mapper\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testRootBeans() throws Exception\n+    {\n+        final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n+\n+        MappingIterator<Bean> it = MAPPER.reader(Bean.class).readValues(JSON);\n+\n+        assertNotNull(it.getCurrentLocation());\n+        assertTrue(it.hasNext());\n+        Bean b = it.next();\n+        assertEquals(3, b.a);\n+        assertTrue(it.hasNext());\n+        b = it.next();\n+        assertEquals(27, b.a);\n+        assertFalse(it.hasNext());\n+        it.close();\n+\n+        // Also, test 'readAll()'\n+        it = MAPPER.reader(Bean.class).readValues(JSON);\n+        List<Bean> all = it.readAll();\n+        assertEquals(2, all.size());\n+        it.close();\n+\n+        it = MAPPER.reader(Bean.class).readValues(\"{\\\"a\\\":3}{\\\"a\\\":3}\");\n+        Set<Bean> set = it.readAll(new HashSet<Bean>());\n+        assertEquals(HashSet.class, set.getClass());\n+        assertEquals(1, set.size());\n+        assertEquals(3, set.iterator().next().a);\n+    }\n+\n+    public void testRootBeansInArray() throws Exception\n+    {\n+        final String JSON = \"[{\\\"a\\\":6}, {\\\"a\\\":-7}]\";\n+\n+        MappingIterator<Bean> it = MAPPER.reader(Bean.class).readValues(JSON);\n+\n+        assertNotNull(it.getCurrentLocation());\n+        assertTrue(it.hasNext());\n+        Bean b = it.next();\n+        assertEquals(6, b.a);\n+        assertTrue(it.hasNext());\n+        b = it.next();\n+        assertEquals(-7, b.a);\n+        assertFalse(it.hasNext());\n+        it.close();\n+\n+        // Also, test 'readAll()'\n+        it = MAPPER.reader(Bean.class).readValues(JSON);\n+        List<Bean> all = it.readAll();\n+        assertEquals(2, all.size());\n+        it.close();\n+\n+        it = MAPPER.reader(Bean.class).readValues(\"[{\\\"a\\\":4},{\\\"a\\\":4}]\");\n+        Set<Bean> set = it.readAll(new HashSet<Bean>());\n+        assertEquals(HashSet.class, set.getClass());\n+        assertEquals(1, set.size());\n+        assertEquals(4, set.iterator().next().a);\n+    }\n+\n+    public void testRootMaps() throws Exception\n+    {\n+        final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n+        Iterator<Map<?,?>> it = MAPPER.reader(Map.class).readValues(JSON);\n+\n+        assertNotNull(((MappingIterator<?>) it).getCurrentLocation());\n+        assertTrue(it.hasNext());\n+        Map<?,?> map = it.next();\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(3), map.get(\"a\"));\n+        assertTrue(it.hasNext());\n+        assertNotNull(((MappingIterator<?>) it).getCurrentLocation());\n+        map = it.next();\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(27), map.get(\"a\"));\n+        assertFalse(it.hasNext());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests; root-level value sequences via JsonParser\n+    /**********************************************************\n+     */\n+\n+    public void testRootBeansWithParser() throws Exception\n+    {\n+        final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n+        JsonParser jp = MAPPER.getFactory().createParser(JSON);\n+        \n+        Iterator<Bean> it = jp.readValuesAs(Bean.class);\n+\n+        assertTrue(it.hasNext());\n+        Bean b = it.next();\n+        assertEquals(3, b.a);\n+        assertTrue(it.hasNext());\n+        b = it.next();\n+        assertEquals(27, b.a);\n+        assertFalse(it.hasNext());\n+    }\n+\n+    public void testRootArraysWithParser() throws Exception\n+    {\n+        final String JSON = \"[1][3]\";\n+        JsonParser jp = MAPPER.getFactory().createParser(JSON);\n+\n+        // NOTE: We must point JsonParser to the first element; if we tried to\n+        // use \"managed\" accessor, it would try to advance past START_ARRAY.\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        \n+        Iterator<int[]> it = MAPPER.reader(int[].class).readValues(jp);\n+        assertTrue(it.hasNext());\n+        int[] array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(1, array[0]);\n+        assertTrue(it.hasNext());\n+        array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(3, array[0]);\n+        assertFalse(it.hasNext());\n+    }\n+\n+    public void testHasNextWithEndArray() throws Exception {\n+        final String JSON = \"[1,3]\";\n+        JsonParser jp = MAPPER.getFactory().createParser(JSON);\n+\n+        // NOTE: We must point JsonParser to the first element; if we tried to\n+        // use \"managed\" accessor, it would try to advance past START_ARRAY.\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        jp.nextToken();\n+        \n+        Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(jp);\n+        assertTrue(it.hasNext());\n+        int value = it.next();\n+        assertEquals(1, value);\n+        assertTrue(it.hasNext());\n+        value = it.next();\n+        assertEquals(3, value);\n+        assertFalse(it.hasNext());\n+        assertFalse(it.hasNext());\n+    }\n+\n+    public void testHasNextWithEndArrayManagedParser() throws Exception {\n+        final String JSON = \"[1,3]\";\n+\n+        Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON);\n+        assertTrue(it.hasNext());\n+        int value = it.next();\n+        assertEquals(1, value);\n+        assertTrue(it.hasNext());\n+        value = it.next();\n+        assertEquals(3, value);\n+        assertFalse(it.hasNext());\n+        assertFalse(it.hasNext());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests; non-root arrays\n+    /**********************************************************\n+     */\n+\n+    public void testNonRootBeans() throws Exception\n+    {\n+        final String JSON = \"{\\\"leaf\\\":[{\\\"a\\\":3},{\\\"a\\\":27}]}\";\n+        JsonParser jp = MAPPER.getFactory().createParser(JSON);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        // can either advance to first START_OBJECT, or clear current token;\n+        // explicitly passed JsonParser MUST point to the first token of\n+        // the first element\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        \n+        Iterator<Bean> it = MAPPER.reader(Bean.class).readValues(jp);\n+\n+        assertTrue(it.hasNext());\n+        Bean b = it.next();\n+        assertEquals(3, b.a);\n+        assertTrue(it.hasNext());\n+        b = it.next();\n+        assertEquals(27, b.a);\n+        assertFalse(it.hasNext());\n+        jp.close();\n+    }\n+\n+    public void testNonRootMapsWithParser() throws Exception\n+    {\n+        final String JSON = \"[{\\\"a\\\":3},{\\\"a\\\":27}]\";\n+        JsonParser jp = MAPPER.getFactory().createParser(JSON);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        // can either advance to first START_OBJECT, or clear current token;\n+        // explicitly passed JsonParser MUST point to the first token of\n+        // the first element\n+        jp.clearCurrentToken();\n+        \n+        Iterator<Map<?,?>> it = MAPPER.reader(Map.class).readValues(jp);\n+\n+        assertTrue(it.hasNext());\n+        Map<?,?> map = it.next();\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(3), map.get(\"a\"));\n+        assertTrue(it.hasNext());\n+        map = it.next();\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(27), map.get(\"a\"));\n+        assertFalse(it.hasNext());\n+        jp.close();\n+    }\n+\n+    public void testNonRootMapsWithObjectReader() throws Exception\n+    {\n+        String JSON = \"[{ \\\"hi\\\": \\\"ho\\\", \\\"neighbor\\\": \\\"Joe\\\" },\\n\"\n+            +\"{\\\"boy\\\": \\\"howdy\\\", \\\"huh\\\": \\\"what\\\"}]\";\n+        final MappingIterator<Map<String, Object>> iterator = MAPPER\n+                .reader()\n+                .forType(new TypeReference<Map<String, Object>>(){})\n+                .readValues(JSON);\n+\n+        Map<String,Object> map;\n+        assertTrue(iterator.hasNext());\n+        map = iterator.nextValue();\n+        assertEquals(2, map.size());\n+        assertTrue(iterator.hasNext());\n+        map = iterator.nextValue();\n+        assertEquals(2, map.size());\n+        assertFalse(iterator.hasNext());\n+    }\n+    \n+    public void testNonRootArraysUsingParser() throws Exception\n+    {\n+        final String JSON = \"[[1],[3]]\";\n+        JsonParser jp = MAPPER.getFactory().createParser(JSON);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        \n+        // Important: as of 2.1, START_ARRAY can only be skipped if the\n+        // target type is NOT a Collection or array Java type.\n+        // So we have to explicitly skip it in this particular case.\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        \n+        Iterator<int[]> it = MAPPER.readValues(jp, int[].class);\n+\n+        assertTrue(it.hasNext());\n+        int[] array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(1, array[0]);\n+        assertTrue(it.hasNext());\n+        array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(3, array[0]);\n+        assertFalse(it.hasNext());\n+        jp.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/seq/SequenceWriterTest.java\n+package com.fasterxml.jackson.databind.seq;\n+\n+import java.io.StringWriter;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class SequenceWriterTest extends BaseMapTest\n+{\n+    static class Bean {\n+        public int a;\n+\n+        public Bean(int value) { a = value; }\n+        \n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == null || o.getClass() != getClass()) return false;\n+            Bean other = (Bean) o;\n+            return other.a == this.a;\n+        }\n+        @Override public int hashCode() { return a; }\n+    }\n+\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = \"type\")\n+    static class PolyBase {\n+    }\n+\n+    @JsonTypeName(\"A\")\n+    static class ImplA extends PolyBase {\n+        public int value;\n+        \n+        public ImplA(int v) { value = v; }\n+    }\n+\n+    @JsonTypeName(\"B\")\n+    static class ImplB extends PolyBase {\n+        public int b;\n+        \n+        public ImplB(int v) { b = v; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods, simple writes\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    private final ObjectWriter WRITER = MAPPER.writer()\n+            .withRootValueSeparator(\"\\n\");\n+\n+    public void testSimpleNonArray() throws Exception\n+    {\n+        StringWriter strw = new StringWriter();\n+        SequenceWriter w = WRITER\n+                .writeValues(strw);\n+        w.write(new Bean(13))\n+        .write(new Bean(-6))\n+        .writeAll(new Bean[] { new Bean(3), new Bean(1) });\n+        w.close();\n+        assertEquals(aposToQuotes(\"{'a':13}\\n{'a':-6}\\n{'a':3}\\n{'a':1}\"),\n+                strw.toString());\n+    }\n+\n+    public void testSimpleArray() throws Exception\n+    {\n+        StringWriter strw = new StringWriter();\n+        SequenceWriter w = WRITER.writeValuesAsArray(strw);\n+        w.write(new Bean(1))\n+        .write(new Bean(2))\n+        .writeAll(new Bean[] { new Bean(-7), new Bean(2) });\n+        w.close();\n+        assertEquals(aposToQuotes(\"[{'a':1},{'a':2},{'a':-7},{'a':2}]\"),\n+                strw.toString());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods, polymorphic writes\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testPolymorphicNonArrayWithoutType() throws Exception\n+    {\n+        StringWriter strw = new StringWriter();\n+        SequenceWriter w = WRITER\n+                .writeValues(strw);\n+        w.write(new ImplA(3))\n+            .write(new ImplA(4))\n+            .close();\n+        assertEquals(aposToQuotes(\"{'type':'A','value':3}\\n{'type':'A','value':4}\"),\n+                strw.toString());\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testPolymorphicArrayWithoutType() throws Exception\n+    {\n+        StringWriter strw = new StringWriter();\n+        SequenceWriter w = WRITER\n+                .writeValuesAsArray(strw);\n+        w.write(new ImplA(-1))\n+            .write(new ImplA(6))\n+            .close();\n+        assertEquals(aposToQuotes(\"[{'type':'A','value':-1},{'type':'A','value':6}]\"),\n+                strw.toString());\n+    }\n+\n+    @SuppressWarnings(\"resource\")\n+    public void testPolymorphicArrayWithType() throws Exception\n+    {\n+        StringWriter strw = new StringWriter();\n+        SequenceWriter w = WRITER\n+                .forType(PolyBase.class)\n+                .writeValuesAsArray(strw);\n+        w.write(new ImplA(-1))\n+            .write(new ImplB(3))\n+            .write(new ImplA(7))\n+            .close();\n+        assertEquals(aposToQuotes(\"[{'type':'A','value':-1},{'type':'B','b':3},{'type':'A','value':7}]\"),\n+                strw.toString());\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationInheritance.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationInheritance.java\n package com.fasterxml.jackson.databind.ser;\n \n-import java.io.*;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n  * bean serialization.\n  */\n public class TestAnnotationInheritance\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends BaseMapTest\n {\n     /*\n     /**********************************************************\n         assertEquals(Integer.valueOf(1), result.get(\"width\"));\n         assertEquals(Integer.valueOf(2), result.get(\"length\"));\n     }\n-\n-    /*\n-    //////////////////////////////////////////////\n-    // Helper methods\n-    //////////////////////////////////////////////\n-     */\n-\n-    @SuppressWarnings(\"unchecked\")\n-\tprivate Map<String,Object> writeAndMap(ObjectMapper m, Object value)\n-        throws IOException\n-    {\n-        StringWriter sw = new StringWriter();\n-        m.writeValue(sw, value);\n-        return (Map<String,Object>) m.readValue(sw.toString(), Object.class);\n-    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnyGetter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnyGetter.java\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializationFeature;\n \n-public class TestAnyGetter\n-    extends BaseMapTest\n+public class TestAnyGetter extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper bean classes\n-    /**********************************************************\n-     */\n-\n     static class Bean\n     {\n         final static Map<String,Boolean> extra = new HashMap<String,Boolean>();\n         }\n     }\n \n+    static class MapAsAny\n+    {\n+        protected Map<String,Object> stuff = new LinkedHashMap<String,Object>();\n+        \n+        @JsonAnyGetter\n+        public Map<String,Object> any() {\n+            return stuff;\n+        }\n+\n+        public void add(String key, Object value) {\n+            stuff.put(key, value);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Test cases\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testSimpleJsonValue() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        String json = serializeAsString(m, new Bean());\n-        Map<?,?> map = m.readValue(json, Map.class);\n+        String json = MAPPER.writeValueAsString(new Bean());\n+        Map<?,?> map = MAPPER.readValue(json, Map.class);\n         assertEquals(2, map.size());\n         assertEquals(Integer.valueOf(3), map.get(\"x\"));\n         assertEquals(Boolean.TRUE, map.get(\"a\"));\n         json = serializeAsString(m, new AnyOnlyBean());\n         assertEquals(\"{\\\"a\\\":3}\", json);\n     }\n+\n+    // Trying to repro [databind#577]\n+    public void testAnyWithNull() throws Exception\n+    {\n+        MapAsAny input = new MapAsAny();\n+        input.add(\"bar\", null);\n+        assertEquals(aposToQuotes(\"{'bar':null}\"),\n+                MAPPER.writeValueAsString(input));\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n import com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder;\n @SuppressWarnings(\"serial\")\n public class TestBeanSerializer extends BaseMapTest\n {\n-    /*\n-    /********************************************************\n-    /* Helper types\n-    /********************************************************\n-     */\n-\n-    static class ModuleImpl extends SimpleModule\n+    static class SerializerModifierModule extends SimpleModule\n     {\n         protected BeanSerializerModifier modifier;\n         \n-        public ModuleImpl(BeanSerializerModifier modifier)\n+        public SerializerModifierModule(BeanSerializerModifier modifier)\n         {\n             super(\"test\", Version.unknownVersion());\n             this.modifier = modifier;\n             // we need a valid BeanPropertyDefinition; this will do (just need name to match)\n             POJOPropertyBuilder prop = new POJOPropertyBuilder(new PropertyName(\"bogus\"), null, true);\n             try {\n-                AnnotatedField f = new AnnotatedField(EmptyBean.class.getDeclaredField(\"name\"), null);\n+                AnnotatedField f = new AnnotatedField(null, EmptyBean.class.getDeclaredField(\"name\"), null);\n                 beanProperties.add(new BeanPropertyWriter(prop, f, null,\n                         strType,\n                         null, null, strType,\n         }\n     }\n \n+    // [Issue#539]: use post-modifier\n+    static class EmptyBeanModifier539 extends BeanSerializerModifier\n+    {\n+        @Override\n+        public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\n+                BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n+        {\n+            return beanProperties;\n+        }\n+        \n+        @Override\n+        public JsonSerializer<?> modifySerializer(SerializationConfig config,\n+                BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+            return new BogusBeanSerializer(42);\n+        }\n+    }\n     // [Issue#120], arrays, collections, maps\n     \n     static class ArraySerializerModifier extends BeanSerializerModifier {\n     public void testPropertyRemoval() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new RemovingModifier(\"a\")));\n+        mapper.registerModule(new SerializerModifierModule(new RemovingModifier(\"a\")));\n         Bean bean = new Bean();\n         assertEquals(\"{\\\"b\\\":\\\"b\\\"}\", mapper.writeValueAsString(bean));\n     }\n     public void testPropertyReorder() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new ReorderingModifier()));\n+        mapper.registerModule(new SerializerModifierModule(new ReorderingModifier()));\n         Bean bean = new Bean();\n         assertEquals(\"{\\\"a\\\":\\\"a\\\",\\\"b\\\":\\\"b\\\"}\", mapper.writeValueAsString(bean));\n     }\n     public void testBuilderReplacement() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new BuilderModifier(new BogusBeanSerializer(17))));\n+        mapper.registerModule(new SerializerModifierModule(new BuilderModifier(new BogusBeanSerializer(17))));\n         Bean bean = new Bean();\n         assertEquals(\"17\", mapper.writeValueAsString(bean));\n     }    \n     public void testSerializerReplacement() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new ReplacingModifier(new BogusBeanSerializer(123))));\n+        mapper.registerModule(new SerializerModifierModule(new ReplacingModifier(new BogusBeanSerializer(123))));\n         Bean bean = new Bean();\n         assertEquals(\"123\", mapper.writeValueAsString(bean));\n     }\n         assertEquals(\"{\\\"bogus\\\":\\\"foo\\\"}\", json);\n     }\n \n+    // [Issue#539]\n+    public void testEmptyBean539() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new SimpleModule(\"test\", Version.unknownVersion()) {\n+            @Override\n+            public void setupModule(SetupContext context)\n+            {\n+                super.setupModule(context);\n+                context.addBeanSerializerModifier(new EmptyBeanModifier539());\n+            }\n+        });\n+        String json = mapper.writeValueAsString(new EmptyBean());\n+        assertEquals(\"42\", json);\n+    }\n+    \n     // [Issue#121]\n \n     public void testModifyArraySerializer() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.ser.std.CollectionSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\n+import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer;\n import com.fasterxml.jackson.databind.util.StdConverter;\n \n /**\n         }\n     }\n \n+    // for [databind#631]\n+    static class Issue631Bean\n+    {\n+        @JsonSerialize(using=ParentClassSerializer.class)\n+        public Object prop;\n+\n+        public Issue631Bean(Object o) {\n+            prop = o;\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    static class ParentClassSerializer\n+        extends StdScalarSerializer<Object>\n+    {\n+        protected ParentClassSerializer() {\n+            super(Object.class);\n+        }\n+\n+        @Override\n+        public void serialize(Object value, JsonGenerator gen,\n+                SerializerProvider provider) throws IOException {\n+            Object parent = gen.getCurrentValue();\n+            String desc = (parent == null) ? \"NULL\" : parent.getClass().getSimpleName();\n+            gen.writeString(desc+\"/\"+value);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Unit tests\n     public void testCustomization() throws Exception\n     {\n         ObjectMapper objectMapper = new ObjectMapper();\n-        objectMapper.addMixInAnnotations(Element.class, ElementMixin.class);\n+        objectMapper.addMixIn(Element.class, ElementMixin.class);\n         Element element = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument().createElement(\"el\");\n         StringWriter sw = new StringWriter();\n         objectMapper.writeValue(sw, element);\n     // [Issue#215]: Allow registering CharacterEscapes via ObjectWriter\n     public void testCustomEscapes() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         assertEquals(quote(\"foo\\\\u0062\\\\Ar\"),\n-                mapper.writer(new CustomEscapes()).writeValueAsString(\"foobar\"));\n+                MAPPER.writer(new CustomEscapes()).writeValueAsString(\"foobar\"));\n     }\n     \n     public void testNumberSubclass() throws Exception\n         assertEquals(aposToQuotes(\"{'x':42}\"),\n                 MAPPER.writeValueAsString(new LikeNumber(42)));\n     }\n+\n+    public void testWithCurrentValue() throws Exception\n+    {\n+        assertEquals(aposToQuotes(\"{'prop':'Issue631Bean/42'}\"),\n+                MAPPER.writeValueAsString(new Issue631Bean(42)));\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n         }\n \n         @Override\n-        public boolean isEmpty(NonZero value) {\n+        public boolean isEmpty(SerializerProvider provider, NonZero value) {\n             if (value == null) return true;\n             return (value.nr == 0);\n         }\n \n         // Including class annotation through mix-ins\n         ObjectMapper m2 = new ObjectMapper();\n-        m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class);\n+        m2.addMixIn(Empty.class, EmptyWithAnno.class);\n         assertEquals(\"{}\", m2.writeValueAsString(new Empty()));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n import java.io.*;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonAnyGetter;\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.annotation.JsonValue;\n-\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n         public OK text = OK.V1;\n     }\n     \n-    @JsonFormat(shape=JsonFormat.Shape.ARRAY) // not supported as of now\n-    static enum BrokenPoNum\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY) // alias for 'number', as of 2.5\n+    static enum PoAsArray\n     {\n         A, B;\n     }\n \n-    @SuppressWarnings(\"rawtypes\")\n+    @SuppressWarnings({ \"rawtypes\", \"serial\" })\n     static class LowerCasingEnumSerializer extends StdSerializer<Enum>\n     {\n         public LowerCasingEnumSerializer() { super(Enum.class); }\n             jgen.writeString(value.name().toLowerCase());\n         }\n     }\n-    \n+\n+    // for [databind#572]\n+    static class PoOverrideAsString\n+    {\n+        @JsonFormat(shape=Shape.STRING)\n+        public PoNUM value = PoNUM.B;\n+    }\n+\n+    static class PoOverrideAsNumber\n+    {\n+        @JsonFormat(shape=Shape.NUMBER)\n+        public PoNUM value = PoNUM.B;\n+    }\n+\n+    static enum MyEnum594 {\n+        VALUE_WITH_A_REALLY_LONG_NAME_HERE(\"longValue\");\n+\n+        private final String key;\n+        private MyEnum594(String k) { key = k; }\n+\n+        @JsonValue\n+        public String getKey() { return key; }\n+    }\n+\n+    static class MyStuff594 {\n+        public Map<MyEnum594,String> stuff = new EnumMap<MyEnum594,String>(MyEnum594.class);\n+        \n+        public MyStuff594(String value) {\n+            stuff.put(MyEnum594.VALUE_WITH_A_REALLY_LONG_NAME_HERE, value);\n+        }\n+    }\n+\n+    public class MyBean661 {\n+        private Map<Foo661, String> foo = new EnumMap<Foo661, String>(Foo661.class);\n+\n+        public MyBean661(String value) {\n+            foo.put(Foo661.FOO, value);\n+        }\n+\n+        @JsonAnyGetter\n+        @JsonSerialize(keyUsing = Foo661.Serializer.class)\n+        public Map<Foo661, String> getFoo() {\n+            return foo;\n+        }\n+    }\n+\n+    enum Foo661 {\n+        FOO;\n+        public static class Serializer extends JsonSerializer<Foo661> {\n+            @Override\n+            public void serialize(Foo661 value, JsonGenerator jgen, SerializerProvider provider) \n+                    throws IOException {\n+                jgen.writeFieldName(\"X-\"+value.name());\n+            }\n+        }\n+    }\n     /*\n     /**********************************************************\n     /* Tests\n     {\n         // can't share, as new mix-ins are added\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(TestEnum.class, ToStringMixin.class);\n+        m.addMixIn(TestEnum.class, ToStringMixin.class);\n         assertEquals(\"\\\"b\\\"\", m.writeValueAsString(TestEnum.B));\n     }\n \n     public void testEnumAsIndexViaAnnotations() throws Exception {\n         assertEquals(\"{\\\"text\\\":0}\", mapper.writeValueAsString(new PoNUMContainer()));\n     }\n-    \n+\n+    // As of 2.5, use of Shape.ARRAY is legal alias for \"write as number\"\n     public void testEnumAsObjectBroken() throws Exception\n     {\n-        try {\n-            String json = mapper.writeValueAsString(BrokenPoNum.A);\n-            fail(\"Should not have succeeded, produced: \"+json);\n-        } catch (JsonMappingException e) {\n-            verifyException(e, \"Unsupported serialization shape\");\n-        }\n+        assertEquals(\"0\", mapper.writeValueAsString(PoAsArray.A));\n     }\n     \n     // [Issue#227]\n         module.addSerializer(Enum.class, new LowerCasingEnumSerializer());\n         m.registerModule(module);\n         assertEquals(quote(\"b\"), m.writeValueAsString(TestEnum.B));\n+    }\n+\n+    // [databind#572]\n+    public void testOverrideEnumAsString() throws Exception {\n+        assertEquals(\"{\\\"value\\\":\\\"B\\\"}\", mapper.writeValueAsString(new PoOverrideAsString()));\n+    }\n+\n+    public void testOverrideEnumAsNumber() throws Exception {\n+        assertEquals(\"{\\\"value\\\":1}\", mapper.writeValueAsString(new PoOverrideAsNumber()));\n+    }\n+\n+    // [databind#594]\n+    public void testJsonValueForEnumMapKey() throws Exception {\n+        assertEquals(aposToQuotes(\"{'stuff':{'longValue':'foo'}}\"),\n+                mapper.writeValueAsString(new MyStuff594(\"foo\")));\n+    }\n+\n+    // [databind#661]\n+    public void testCustomEnumMapKeySerializer() throws Exception {\n+        String json = mapper.writeValueAsString(new MyBean661(\"abc\"));\n+        assertEquals(aposToQuotes(\"{'X-FOO':'abc'}\"), json);\n     }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestExceptionHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestExceptionHandling.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n-import com.fasterxml.jackson.test.BaseTest;\n-import com.fasterxml.jackson.test.BrokenStringWriter;\n \n /**\n  * Unit test for verifying that exceptions are properly handled (caught,\n  * with Object serialization.\n  */\n public class TestExceptionHandling\n-    extends BaseTest\n+    extends BaseMapTest\n {\n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n \n         // also: let's ensure that ObjectWriter won't interfere with it\n         bean = new CloseableBean();\n-        m.writerWithType(CloseableBean.class).writeValueAsString(bean);\n+        m.writerFor(CloseableBean.class).writeValueAsString(bean);\n         assertTrue(bean.wasClosed);\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestGenericTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestGenericTypes.java\n         public Person1(String name) { this.name = name; }\n \n         public String getName() {\n-                return name;\n+            return name;\n         }\n \n         public Key<Account> getAccount() {\n-                return account;\n+            return account;\n         }\n \n         public Long getId() {\n-                return id;\n+            return id;\n         }\n \n         public void setAccount(Key<Account> account) {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n import java.util.*;\n import java.util.regex.Pattern;\n \n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n \n /**\n     public void testBigDecimalAsPlainString()\n         throws Exception\n     {\n-        MAPPER.enable(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n+        final ObjectMapper mapper = new ObjectMapper();\n+\n+        mapper.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n         Map<String, Object> map = new HashMap<String, Object>();\n         String PI_STR = \"3.00000000\";\n         map.put(\"pi\", new BigDecimal(PI_STR));\n-        String str = MAPPER.writeValueAsString(map);\n+        String str = mapper.writeValueAsString(map);\n         assertEquals(\"{\\\"pi\\\":3.00000000}\", str);\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonRawValue.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonRawValue.java\n     @JsonPropertyOrder(alphabetic=true)\n     final static class ClassGetter<T>\n     {\n-    \tprivate final T _value;\n+        protected final T _value;\n     \t\n-        private ClassGetter(T value) { _value = value;}\n+        protected ClassGetter(T value) { _value = value;}\n  \n         public T getNonRaw() { return _value; }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java\n     }\n \n     static class Bar294{\n-        @JsonProperty private String id;\n-        @JsonProperty private String name;\n+        @JsonProperty protected String id;\n+        @JsonProperty protected String name;\n \n         public Bar294() { }\n         public Bar294(String id) {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java\n public class TestJsonSerializeAs extends BaseMapTest\n {\n     // [JACKSON-799] stuff:\n-    \n     public interface Fooable {\n         public int getFoo();\n     }\n             return new FooImpl();\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Test methods\n      */\n \n     private final ObjectWriter WRITER = objectWriter();\n-    \n+\n     // [JACKSON-799]\n     public void testSerializeAsInClass() throws IOException\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestKeySerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestKeySerializers.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n \n public class TestKeySerializers extends BaseMapTest\n {\n         public Map<String,Integer> map = new HashMap<String,Integer>();\n         {\n             map.put(\"Not Karl\", 1);\n+        }\n+    }\n+\n+    enum ABC {\n+        A, B, C\n+    }\n+\n+    static class ABCSerializer extends JsonSerializer<ABC> {\n+        @Override\n+        public void serialize(ABC value, JsonGenerator jgen,\n+                SerializerProvider provider) throws IOException {\n+            jgen.writeFieldName(\"xxx\"+value);\n+        }\n+    }\n+\n+    static class ABCMapWrapper {\n+        public Map<ABC,String> stuff = new HashMap<ABC,String>();\n+        public ABCMapWrapper() {\n+            stuff.put(ABC.B, \"bar\");\n         }\n     }\n \n         final String value2 = mapper.writeValueAsString(new KarlBean());\n         assertEquals(\"{\\\"map\\\":{\\\"Karl\\\":1}}\", value2);\n     }\n+\n+    // Test custom key serializer for enum\n+    public void testCustomForEnum() throws IOException\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\");\n+        mod.addKeySerializer(ABC.class, new ABCSerializer());\n+        mapper.registerModule(mod);\n+\n+        String json = mapper.writeValueAsString(new ABCMapWrapper());\n+        assertEquals(\"{\\\"stuff\\\":{\\\"xxxB\\\":\\\"bar\\\"}}\", json);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n import java.util.*;\n import java.util.concurrent.ConcurrentHashMap;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n public class TestMapSerialization\n     extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n     /**\n      * Class needed for testing [JACKSON-220]\n      */\n         }\n     }\n \n+    // [Databind#565]: Support ser/deser of Map.Entry\n+    static class StringIntMapEntry implements Map.Entry<String,Integer> {\n+        public final String k;\n+        public final Integer v;\n+        public StringIntMapEntry(String k, Integer v) {\n+            this.k = k;\n+            this.v = v;\n+        }\n+\n+        @Override\n+        public String getKey() {\n+            return k;\n+        }\n+\n+        @Override\n+        public Integer getValue() {\n+            return v;\n+        }\n+\n+        @Override\n+        public Integer setValue(Integer value) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    // [databind#527]\n+    static class NoNullValuesMapContainer {\n+        @JsonInclude(content=JsonInclude.Include.NON_NULL)\n+        public Map<String,String> stuff = new LinkedHashMap<String,String>();\n+        \n+        public NoNullValuesMapContainer add(String key, String value) {\n+            stuff.put(key, value);\n+            return this;\n+        }\n+    }\n+\n+    // [databind#527]\n+    @JsonInclude(content=JsonInclude.Include.NON_NULL)\n+    static class NoNullsStringMap extends LinkedHashMap<String,String> {\n+        public NoNullsStringMap add(String key, String value) {\n+            put(key, value);\n+            return this;\n+        }\n+    }\n+\n+    @JsonInclude(content=JsonInclude.Include.NON_EMPTY)\n+    static class NoEmptyStringsMap extends LinkedHashMap<String,String> {\n+        public NoEmptyStringsMap add(String key, String value) {\n+            put(key, value);\n+            return this;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n     /**********************************************************\n      */\n \n-    final ObjectMapper MAPPER = objectMapper();\n+    final private ObjectMapper MAPPER = objectMapper();\n \n     public void testUsingObjectWriter() throws IOException\n     {\n-        ObjectWriter w = MAPPER.writerWithType(Object.class);\n+        ObjectWriter w = MAPPER.writerFor(Object.class);\n         Map<String,Object> map = new LinkedHashMap<String,Object>();\n         map.put(\"a\", 1);\n         String json = w.writeValueAsString(map);\n         assertEquals(\"{\\\"a\\\":6,\\\"b\\\":3}\", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map));\n     }\n \n-    // [#335[\n+    // [Databind#335]\n     public void testOrderByKeyViaProperty() throws IOException\n     {\n         MapOrderingBean input = new MapOrderingBean(\"c\", \"b\", \"a\");\n         String json = MAPPER.writeValueAsString(input);\n         assertEquals(aposToQuotes(\"{'map':{'a':3,'b':2,'c':1}}\"), json);\n     }        \n+\n+    // [Databind#565]\n+    public void testEnumMapEntry() throws IOException\n+    {\n+        StringIntMapEntry input = new StringIntMapEntry(\"answer\", 42);\n+        String json = MAPPER.writeValueAsString(input);\n+        assertEquals(aposToQuotes(\"{'answer':42}\"), json);\n+\n+        StringIntMapEntry[] array = new StringIntMapEntry[] { input };\n+        json = MAPPER.writeValueAsString(array);\n+        assertEquals(aposToQuotes(\"[{'answer':42}]\"), json);\n+    }        \n+\n+    // [databind#527]\n+    public void testNonNullValueMap() throws IOException\n+    {\n+        String json = MAPPER.writeValueAsString(new NoNullsStringMap()\n+            .add(\"a\", \"foo\")\n+            .add(\"b\", null)\n+            .add(\"c\", \"bar\"));\n+        assertEquals(aposToQuotes(\"{'a':'foo','c':'bar'}\"), json);\n+    }\n+\n+    // [databind#527]\n+    public void testNonEmptyValueMap() throws IOException\n+    {\n+        String json = MAPPER.writeValueAsString(new NoEmptyStringsMap()\n+            .add(\"a\", \"foo\")\n+            .add(\"b\", \"bar\")\n+            .add(\"c\", \"\"));\n+        assertEquals(aposToQuotes(\"{'a':'foo','b':'bar'}\"), json);\n+    }\n+    \n+    // [databind#527]\n+    public void testNonNullValueMapViaProp() throws IOException\n+    {\n+        String json = MAPPER.writeValueAsString(new NoNullValuesMapContainer()\n+            .add(\"a\", \"foo\")\n+            .add(\"b\", null)\n+            .add(\"c\", \"bar\"));\n+        assertEquals(aposToQuotes(\"{'stuff':{'a':'foo','c':'bar'}}\"), json);\n+    }\n+\n+    public void testClassKey() throws IOException\n+    {\n+        Map<Class<?>,Integer> map = new LinkedHashMap<Class<?>,Integer>();\n+        map.put(String.class, 2);\n+        String json = MAPPER.writeValueAsString(map);\n+        assertEquals(aposToQuotes(\"{'java.lang.String':2}\"), json);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestNumbers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNumbers.java\n {\n     private final ObjectMapper MAPPER = objectMapper();\n \n-    private static class IntAsString {\n+    static class IntAsString {\n         @JsonFormat(shape=JsonFormat.Shape.STRING)\n         public int value = 3;\n     }\n \n-    private static class LongAsString {\n+    static class LongAsString {\n         @JsonFormat(shape=JsonFormat.Shape.STRING)\n         public long value = 4;\n     }\n-    \n-    private static class DoubleAsString {\n+\n+    static class DoubleAsString {\n         @JsonFormat(shape=JsonFormat.Shape.STRING)\n         public double value = -0.5;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Test methods\n     /**********************************************************\n      */\n-    \n+\n     public void testDouble() throws Exception\n     {\n         double[] values = new double[] {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n         assertEquals(Boolean.TRUE, result.get(\"b2\"));\n \n         // and then using specified typed writer\n-        ObjectWriter w = mapper.writerWithType(BaseType.class);\n+        ObjectWriter w = mapper.writerFor(BaseType.class);\n         String json = w.writeValueAsString(bean);\n         result = (Map<String,Object>)mapper.readValue(json, Map.class);\n         assertEquals(2, result.size());\n         SubType bean = new SubType();\n \n         // let's constrain by interface:\n-        ObjectWriter w = mapper.writerWithType(BaseInterface.class);\n+        ObjectWriter w = mapper.writerFor(BaseInterface.class);\n         String json = w.writeValueAsString(bean);\n         @SuppressWarnings(\"unchecked\")\n         Map<String,Object> result = mapper.readValue(json, Map.class);\n         // must force static typing, otherwise won't matter a lot\n         mapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n         SubType[] ob = new SubType[] { new SubType() };\n-        String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob);\n+        String json = mapper.writerFor(BaseInterface[].class).writeValueAsString(ob);\n         // should propagate interface type through due to root declaration; static typing\n         assertEquals(\"[{\\\"b\\\":3}]\", json);\n     }\n         SubType bean = new SubType();\n \n         // and then let's try using incompatible type\n-        ObjectWriter w = mapper.writerWithType(HashMap.class);\n+        ObjectWriter w = mapper.writerFor(HashMap.class);\n         try {\n             w.writeValueAsString(bean);\n             fail(\"Should have failed due to incompatible type\");\n         final String EXP = \"[{\\\"beanClass\\\":\\\"TestRootType$TestClass398\\\",\\\"property\\\":\\\"aa\\\"}]\";\n         \n         // First simplest way:\n-        String json = mapper.writerWithType(collectionType).writeValueAsString(typedList);\n+        String json = mapper.writerFor(collectionType).writeValueAsString(typedList);\n         assertEquals(EXP, json);\n \n         StringWriter out = new StringWriter();\n         JsonFactory f = new JsonFactory();\n-        mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList);\n+        mapper.writerFor(collectionType).writeValue(f.createGenerator(out), typedList);\n \n         assertEquals(EXP, out.toString());\n     }\n     public void testIssue456WrapperPart() throws Exception\n     {\n         ObjectMapper mapper = objectMapper();\n-        assertEquals(\"123\", mapper.writerWithType(Integer.TYPE).writeValueAsString(Integer.valueOf(123)));\n-        assertEquals(\"456\", mapper.writerWithType(Long.TYPE).writeValueAsString(Long.valueOf(456L)));\n+        assertEquals(\"123\", mapper.writerFor(Integer.TYPE).writeValueAsString(Integer.valueOf(123)));\n+        assertEquals(\"456\", mapper.writerFor(Long.TYPE).writeValueAsString(Long.valueOf(456L)));\n     }\n \n     // [JACKSON-630] also, allow annotation to define root name\n         cmd.uuid = \"1234\";\n         cmd.type = 1;\n \n-        ObjectWriter writer = WRAP_ROOT_MAPPER.writerWithType(TestCommandParent.class);\n+        ObjectWriter writer = WRAP_ROOT_MAPPER.writerFor(TestCommandParent.class);\n         String json =  writer.writeValueAsString(cmd);\n \n         assertEquals(json, \"{\\\"TestCommandParent\\\":{\\\"uuid\\\":\\\"1234\\\",\\\"type\\\":1}}\");\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n     public void testOrderWithMixins() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(BeanWithOrder.class, OrderMixIn.class);\n+        m.addMixIn(BeanWithOrder.class, OrderMixIn.class);\n         assertEquals(\"{\\\"b\\\":2,\\\"a\\\":1,\\\"c\\\":3,\\\"d\\\":4}\",\n                 serializeAsString(m, new BeanWithOrder(1, 2, 3, 4)));\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestTypedRootValueSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestTypedRootValueSerialization.java\n     public void testTypedSerialization() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        String singleJson = mapper.writerWithType(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n+        String singleJson = mapper.writerFor(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n         // start with specific value case:\n         assertEquals(\"{\\\"a\\\":3}\", singleJson);\n     }\n         ObjectMapper mapper = new ObjectMapper();\n // Work-around when real solution not yet implemented:        \n //        mapper.enable(MapperFeature.USE_STATIC_TYPING);\n-        assertEquals(\"[{\\\"a\\\":3}]\", mapper.writerWithType(Issue822Interface[].class).writeValueAsString(\n+        assertEquals(\"[{\\\"a\\\":3}]\", mapper.writerFor(Issue822Interface[].class).writeValueAsString(\n                 new Issue822Interface[] { new Issue822Impl() }));\n     }\n     \n \n         List<Issue822Interface> list = new ArrayList<Issue822Interface>();\n         list.add(new Issue822Impl());\n-        String listJson = mapper.writerWithType(new TypeReference<List<Issue822Interface>>(){})\n+        String listJson = mapper.writerFor(new TypeReference<List<Issue822Interface>>(){})\n                 .writeValueAsString(list);\n         assertEquals(\"[{\\\"a\\\":3}]\", listJson);\n     }\n         ObjectMapper mapper = new ObjectMapper();\n         Map<String,Issue822Interface> map = new HashMap<String,Issue822Interface>();\n         map.put(\"a\", new Issue822Impl());\n-        String listJson = mapper.writerWithType(new TypeReference<Map<String,Issue822Interface>>(){})\n+        String listJson = mapper.writerFor(new TypeReference<Map<String,Issue822Interface>>(){})\n                 .writeValueAsString(map);\n         assertEquals(\"{\\\"a\\\":{\\\"a\\\":3}}\", listJson);\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestVirtualProperties.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonAppend;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * Tests for verifying that one can append virtual properties after regular ones.\n+ * \n+ * @since 2.5\n+ */\n+public class TestVirtualProperties extends BaseMapTest\n+{\n+    @JsonAppend(attrs={ @JsonAppend.Attr(\"id\"),\n+        @JsonAppend.Attr(value=\"internal\", propName=\"extra\", required=true)\n+    })\n+    static class SimpleBean\n+    {\n+        public int value = 13;\n+    }\n+\n+    @JsonAppend(prepend=true, attrs={ @JsonAppend.Attr(\"id\"),\n+            @JsonAppend.Attr(value=\"internal\", propName=\"extra\")\n+        })\n+    static class SimpleBeanPrepend\n+    {\n+        public int value = 13;\n+    }\n+\n+    enum ABC {\n+        A, B, C;\n+    }\n+\n+    @JsonAppend(attrs=@JsonAppend.Attr(value=\"desc\", include=JsonInclude.Include.NON_EMPTY))\n+    static class OptionalsBean\n+    {\n+        public int value = 28;\n+    }\n+\n+    static class CustomVProperty\n+        extends VirtualBeanPropertyWriter\n+    {\n+        private CustomVProperty() { super(); }\n+\n+        private CustomVProperty(BeanPropertyDefinition propDef,\n+                Annotations ctxtAnn, JavaType type) {\n+            super(propDef, ctxtAnn, type);\n+        }\n+\n+        @Override\n+        protected Object value(Object bean, JsonGenerator jgen, SerializerProvider prov) {\n+            if (_name.toString().equals(\"id\")) {\n+                return \"abc123\";\n+            }\n+            if (_name.toString().equals(\"extra\")) {\n+                return new int[] { 42 };\n+            }\n+            return \"???\";\n+        }\n+\n+        @Override\n+        public VirtualBeanPropertyWriter withConfig(MapperConfig<?> config,\n+                AnnotatedClass declaringClass, BeanPropertyDefinition propDef,\n+                JavaType type)\n+        {\n+            return new CustomVProperty(propDef, declaringClass.getAnnotations(), type);\n+        }\n+    }\n+\n+    @JsonAppend(prepend=true, props={ @JsonAppend.Prop(value=CustomVProperty.class, name=\"id\"),\n+            @JsonAppend.Prop(value=CustomVProperty.class, name=\"extra\")\n+        })\n+    static class CustomVBean\n+    {\n+        public int value = 72;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final ObjectWriter WRITER = objectWriter();\n+\n+    public void testAttributeProperties() throws Exception\n+    {\n+        Map<String,Object> stuff = new LinkedHashMap<String,Object>();\n+        stuff.put(\"x\", 3);\n+        stuff.put(\"y\", ABC.B);\n+\n+        String json = WRITER.withAttribute(\"id\", \"abc123\")\n+                .withAttribute(\"internal\", stuff)\n+                .writeValueAsString(new SimpleBean());\n+        assertEquals(aposToQuotes(\"{'value':13,'id':'abc123','extra':{'x':3,'y':'B'}}\"), json);\n+\n+        json = WRITER.withAttribute(\"id\", \"abc123\")\n+                .withAttribute(\"internal\", stuff)\n+                .writeValueAsString(new SimpleBeanPrepend());\n+        assertEquals(aposToQuotes(\"{'id':'abc123','extra':{'x':3,'y':'B'},'value':13}\"), json);\n+    }\n+\n+    public void testAttributePropInclusion() throws Exception\n+    {\n+        // first, with desc\n+        String json = WRITER.withAttribute(\"desc\", \"nice\")\n+                .writeValueAsString(new OptionalsBean());\n+        assertEquals(aposToQuotes(\"{'value':28,'desc':'nice'}\"), json);\n+\n+        // then with null (not defined)\n+        json = WRITER.writeValueAsString(new OptionalsBean());\n+        assertEquals(aposToQuotes(\"{'value':28}\"), json);\n+\n+        // and finally \"empty\"\n+        json = WRITER.withAttribute(\"desc\", \"\")\n+                .writeValueAsString(new OptionalsBean());\n+        assertEquals(aposToQuotes(\"{'value':28}\"), json);\n+    }\n+\n+    public void testCustomProperties() throws Exception\n+    {\n+        String json = WRITER.withAttribute(\"desc\", \"nice\")\n+                .writeValueAsString(new CustomVBean());\n+        assertEquals(aposToQuotes(\"{'id':'abc123','extra':[42],'value':72}\"), json);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/JSOGDeserialize622Test.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit test(s) for [databind#622], supporting non-scalar-Object-ids,\n+ * to support things like JSOG.\n+ */\n+public class JSOGDeserialize622Test extends BaseMapTest\n+{\n+    /** the key of the property that holds the ref */\n+    public static final String REF_KEY = \"@ref\";\n+\n+    /**\n+     * JSON input\n+     */\n+    private static final String EXP_EXAMPLE_JSOG =  aposToQuotes(\n+            \"{'@id':'1','foo':66,'next':{'\"+REF_KEY+\"':'1'}}\");\n+\n+    /**\n+     * Customer IdGenerator\n+     */\n+    static class JSOGGenerator extends ObjectIdGenerator<JSOGRef>  {\n+\n+    private static final long serialVersionUID = 1L;\n+    protected transient int _nextValue;\n+    protected final Class<?> _scope;\n+\n+    protected JSOGGenerator() { this(null, -1); }\n+\n+    protected JSOGGenerator(Class<?> scope, int nextValue) {\n+        _scope = scope;\n+        _nextValue = nextValue;\n+    }\n+\n+    @Override\n+    public Class<?> getScope() {\n+        return _scope;\n+    }\n+\n+    @Override\n+    public boolean canUseFor(ObjectIdGenerator<?> gen) {\n+        return (gen.getClass() == getClass()) && (gen.getScope() == _scope);\n+    }\n+\n+    @Override\n+    public ObjectIdGenerator<JSOGRef> forScope(Class<?> scope) {\n+          return (_scope == scope) ? this : new JSOGGenerator(scope, _nextValue);\n+    }\n+\n+    @Override\n+    public ObjectIdGenerator<JSOGRef> newForSerialization(Object context) {\n+          return new JSOGGenerator(_scope, 1);\n+    }\n+\n+    @Override\n+    public com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey key(Object key) {\n+          return new IdKey(getClass(), _scope, key);\n+    }\n+\n+    // important: otherwise won't get proper handling\n+    @Override\n+    public boolean maySerializeAsObject() { return true; }\n+\n+    // ditto: needed for handling Object-valued Object references\n+    @Override\n+    public boolean isValidReferencePropertyName(String name, Object parser) {\n+        return REF_KEY.equals(name);\n+    }\n+\n+    @Override\n+    public JSOGRef generateId(Object forPojo) {\n+          int id = _nextValue;\n+          ++_nextValue;\n+          return new JSOGRef(id);\n+    }\n+    }\n+\n+    /**\n+     * The reference deserializer\n+     */\n+    static class JSOGRefDeserializer extends JsonDeserializer<JSOGRef>\n+    {\n+      @Override\n+      public JSOGRef deserialize(JsonParser jp, DeserializationContext ctx) throws IOException {\n+          JsonNode node = jp.readValueAsTree();\n+          return node.isTextual()\n+                  ? new JSOGRef(node.asInt()) : new JSOGRef(node.get(REF_KEY).asInt());\n+      }\n+    }\n+\n+    /**\n+     * The reference object\n+     */\n+    @JsonDeserialize(using=JSOGRefDeserializer.class)\n+    static class JSOGRef\n+    {\n+        @JsonProperty(REF_KEY)\n+        public int ref;\n+\n+        public JSOGRef() { }\n+\n+        public JSOGRef(int val) {\n+            ref = val;\n+        }\n+\n+        @Override\n+        public String toString() { return \"[JSOGRef#\"+ref+\"]\"; }\n+\n+        @Override\n+        public int hashCode() {\n+            return ref;\n+        }\n+        \n+        @Override\n+        public boolean equals(Object other) {\n+            return (other instanceof JSOGRef)\n+                    && ((JSOGRef) other).ref == this.ref;\n+        }\n+    }\n+\n+    /**\n+     * Example class using JSOGGenerator\n+     */\n+    @JsonIdentityInfo(generator=JSOGGenerator.class, property=\"@id\")\n+    public static class IdentifiableExampleJSOG {\n+        public int foo;\n+        public IdentifiableExampleJSOG next;\n+\n+        protected IdentifiableExampleJSOG() { }\n+        public IdentifiableExampleJSOG(int v) {\n+            foo = v;\n+        }\n+    }\n+\n+    public static class JSOGWrapper {\n+        public int value;\n+\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)\n+        public Object jsog;\n+\n+        JSOGWrapper() { }\n+        public JSOGWrapper(int v) { value = v; }\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Test methods\n+    /**********************************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n+    // Basic for [#622]\n+    public void testStructJSOGRef() throws Exception\n+    {\n+        IdentifiableExampleJSOG result = MAPPER.readValue(EXP_EXAMPLE_JSOG,\n+                IdentifiableExampleJSOG.class);\n+        assertEquals(66, result.foo);\n+        assertSame(result, result.next);\n+    }\n+\n+    // polymorphic alternative for [#622]\n+    public void testPolymorphicRoundTrip() throws Exception\n+    {\n+        JSOGWrapper w = new JSOGWrapper(15);\n+        // create a nice little loop\n+        IdentifiableExampleJSOG ex = new IdentifiableExampleJSOG(123);\n+        ex.next = ex;\n+        w.jsog = ex;\n+\n+        String json = MAPPER.writeValueAsString(w);\n+\n+        JSOGWrapper out = MAPPER.readValue(json, JSOGWrapper.class);\n+        assertNotNull(out);\n+        assertEquals(15, out.value);\n+        assertTrue(out.jsog instanceof IdentifiableExampleJSOG);\n+        IdentifiableExampleJSOG jsog = (IdentifiableExampleJSOG) out.jsog;\n+        assertEquals(123, jsog.foo);\n+        assertSame(jsog, jsog.next);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/PojoAsArray646Test.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class PojoAsArray646Test extends BaseMapTest\n+{\n+    @JsonFormat(shape = JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder(alphabetic = true)\n+    static class Outer {\n+        protected Map<String, TheItem> attributes;\n+\n+        public Outer() {\n+            attributes = new HashMap<String, TheItem>();\n+        }\n+\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.WRAPPER_ARRAY)\n+        public Map<String, TheItem> getAttributes() {\n+            return attributes;\n+        }\n+    }\n+\n+    @JsonFormat(shape = JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder(alphabetic = true)\n+    static class TheItem {\n+\n+        @JsonFormat(shape = JsonFormat.Shape.ARRAY)\n+        @JsonPropertyOrder(alphabetic = true)\n+        public static class NestedItem {\n+            public String nestedStrValue;\n+\n+            @JsonCreator\n+            public NestedItem(@JsonProperty(\"nestedStrValue\") String nestedStrValue) {\n+                this.nestedStrValue = nestedStrValue;\n+            }\n+        }\n+\n+        private String strValue;\n+        private boolean boolValue;\n+        private List<NestedItem> nestedItems;\n+\n+        @JsonCreator\n+        public TheItem(@JsonProperty(\"strValue\") String strValue, @JsonProperty(\"boolValue\") boolean boolValue, @JsonProperty(\"nestedItems\") List<NestedItem> nestedItems) {\n+            this.strValue = strValue;\n+            this.boolValue = boolValue;\n+            this.nestedItems = nestedItems;\n+        }\n+\n+        public String getStrValue() {\n+            return strValue;\n+        }\n+\n+        public void setStrValue(String strValue) {\n+            this.strValue = strValue;\n+        }\n+\n+        public boolean isBoolValue() {\n+            return boolValue;\n+        }\n+\n+        public void setBoolValue(boolean boolValue) {\n+            this.boolValue = boolValue;\n+        }\n+\n+        public List<NestedItem> getNestedItems() {\n+            return nestedItems;\n+        }\n+\n+        public void setNestedItems(List<NestedItem> nestedItems) {\n+            this.nestedItems = nestedItems;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testWithCustomTypeId() throws Exception {\n+\n+        List<TheItem.NestedItem> nestedList = new ArrayList<TheItem.NestedItem>();\n+        nestedList.add(new TheItem.NestedItem(\"foo1\"));\n+        nestedList.add(new TheItem.NestedItem(\"foo2\"));\n+        TheItem item = new TheItem(\"first\", false, nestedList);\n+        Outer outer = new Outer();\n+        outer.getAttributes().put(\"entry1\", item);\n+\n+        String json = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(outer);\n+\n+        Outer result = MAPPER.readValue(json, Outer.class);\n+        assertNotNull(result);\n+        assertNotNull(result.attributes);\n+        assertEquals(1, result.attributes.size());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestForwardReference.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+\n+/**\n+ * Test for testing forward reference handling\n+ */\n+public class TestForwardReference extends BaseMapTest {\n+\n+\tprivate final ObjectMapper MAPPER = new ObjectMapper()\n+\t\t\t.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)\n+\t\t\t.enable(SerializationFeature.INDENT_OUTPUT)\n+\t\t\t.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n+\n+\t/** Tests that we can read a hierarchical structure with forward references*/\n+\tpublic void testForwardRef() throws IOException {\n+\t\tMAPPER.readValue(\"{\" +\n+\t\t\t\t\"  \\\"@type\\\" : \\\"TestForwardReference$ForwardReferenceContainerClass\\\",\" +\n+\t\t\t\t\"  \\\"frc\\\" : \\\"willBeForwardReferenced\\\",\" +\n+\t\t\t\t\"  \\\"yac\\\" : {\" +\n+\t\t\t\t\"    \\\"@type\\\" : \\\"TestForwardReference$YetAnotherClass\\\",\" +\n+\t\t\t\t\"    \\\"frc\\\" : {\" +\n+\t\t\t\t\"      \\\"@type\\\" : \\\"One\\\",\" +\n+\t\t\t\t\"      \\\"id\\\" : \\\"willBeForwardReferenced\\\"\" +\n+\t\t\t\t\"    },\" +\n+\t\t\t\t\"    \\\"id\\\" : \\\"anId\\\"\" +\n+\t\t\t\t\"  },\" +\n+\t\t\t\t\"  \\\"id\\\" : \\\"ForwardReferenceContainerClass1\\\"\" +\n+\t\t\t\t\"}\", ForwardReferenceContainerClass.class);\n+\n+\n+\t}\n+\n+\t@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include= JsonTypeInfo.As.PROPERTY)\n+\tpublic static class ForwardReferenceContainerClass\n+\t{\n+\t\tpublic ForwardReferenceClass frc;\n+\t\tpublic YetAnotherClass yac;\n+\t\tpublic String id;\n+\t}\n+\n+\t@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)\n+\t@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")\n+\t@JsonSubTypes({\n+\t\t\t@JsonSubTypes.Type(value = ForwardReferenceClassOne.class, name = \"One\"),\n+\t\t\t@JsonSubTypes.Type(value = ForwardReferenceClassTwo.class, name = \"Two\")})\n+\tstatic abstract class ForwardReferenceClass\n+\t{\n+\t\tpublic String id;\n+\t\tpublic void setId(String id) {\n+\t\t\tthis.id = id;\n+\t\t}\n+\t}\n+\n+\t@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)\n+\tstatic class YetAnotherClass\n+\t{\n+\t\tpublic YetAnotherClass() {}\n+\t\tpublic ForwardReferenceClass frc;\n+\t\tpublic String id;\n+\t}\n+\n+\tpublic static class ForwardReferenceClassOne extends ForwardReferenceClass { }\n+\n+\tpublic static class ForwardReferenceClassTwo extends ForwardReferenceClass { }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\n     private static final String POOL_KEY = \"POOL\";\n \n     // // Classes for external id use\n-    \n+\n     @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"id\")\n     static class Identifiable\n     {\n         public int value;\n \n         public Identifiable next;\n-        \n+\n         public Identifiable() { this(0); }\n         public Identifiable(int v) {\n             value = v;\n         public UUIDNode() { this(0); }\n         public UUIDNode(int v) { value = v; }\n     }\n-    \n+\n     // // Classes for external id from property annotations:\n-    \n+\n     static class IdWrapper\n     {\n         @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"@id\")\n     static class ValueNodeExt\n     {\n         public int value;\n-        private int customId;\n+        protected int customId;\n         public IdWrapperExt next;\n         \n         public ValueNodeExt() { this(0); }\n \n     @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)\n     static class AnySetterObjectId {\n-        private Map<String, AnySetterObjectId> values = new HashMap<String, AnySetterObjectId>();\n+        protected Map<String, AnySetterObjectId> values = new HashMap<String, AnySetterObjectId>();\n \n         @JsonAnySetter\n         public void anySet(String field, AnySetterObjectId value) {\n             return new PoolResolver(pool);\n         }\n     }\n+    \n+    /*\n+    /*****************************************************\n+    /* Unit tests, external id deserialization\n+    /*****************************************************\n+     */\n \n     private final ObjectMapper mapper = new ObjectMapper();\n     \n-    /*\n-    /*****************************************************\n-    /* Unit tests, external id deserialization\n-    /*****************************************************\n-     */\n-\n     private final static String EXP_SIMPLE_INT_CLASS = \"{\\\"id\\\":1,\\\"value\\\":13,\\\"next\\\":1}\";\n \n     public void testSimpleDeserializationClass() throws Exception\n         assertSame(result, result.next);\n     }\n \n+    // Should be ok NOT to have Object id, as well\n+    public void testMissingObjectId() throws Exception\n+    {\n+        Identifiable result = mapper.readValue(aposToQuotes(\"{'value':28, 'next':{'value':29}}\"),\n+                Identifiable.class);\n+        assertNotNull(result);\n+        assertEquals(28, result.value);\n+        assertNotNull(result.next);\n+        assertEquals(29, result.next.value);\n+    }\n+    \n     public void testSimpleUUIDForClassRoundTrip() throws Exception\n     {\n         UUIDNode root = new UUIDNode(1);\n         }\n     }\n \n-    public void testKeepCollectionOrdering()\n-        throws Exception\n+    // [databind#299]: Allow unresolved ids to become nulls\n+    public void testUnresolvableAsNull() throws Exception\n+    {\n+        IdWrapper w = mapper.reader(IdWrapper.class)\n+                .without(DeserializationFeature.FAIL_ON_UNRESOLVED_OBJECT_IDS)\n+                .readValue(aposToQuotes(\"{'node':123}\"));\n+        assertNotNull(w);\n+        assertNull(w.node);\n+    }\n+\n+    public void testKeepCollectionOrdering() throws Exception\n     {\n         String json = \"{\\\"employees\\\":[2,1,\"\n                 + \"{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":null,\\\"reports\\\":[2]},\"\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdWithPolymorphic.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdWithPolymorphic.java\n     static abstract class Base\n     {\n         public int value;\n+        public Base next;\n \n-        public Base next;\n-        \n         public Base() { this(0); }\n         public Base(int v) {\n             value = v;\n         public int id;\n         public Base811 owner;\n             \n-        private Base811() {}\n+        protected Base811() {}\n         public Base811(Process owner) {\n             this.owner = owner;\n             if (owner == null) {\n                 super(owner);\n                 this.parent = parent;\n         }\n-        private Activity() {\n-                super();\n+        protected Activity() {\n+            super();\n         }\n     }\n     \n         public Scope(Process owner, Activity parent) {\n             super(owner, parent);\n         }\n-        private Scope() {\n+        protected Scope() {\n             super();\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArray.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArray.java\n package com.fasterxml.jackson.databind.struct;\n \n-import com.fasterxml.jackson.annotation.JsonFormat;\n-import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n \n-import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n \n         public String bar = null;\n         public String foo = \"bar\";\n     }\n-    \n+\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder(alphabetic=true)\n+    static class AsArrayWithMap\n+    {\n+        public Map<Integer,Integer> attrs;\n+\n+        public AsArrayWithMap() { }\n+        public AsArrayWithMap(int x, int y) {\n+            attrs = new HashMap<Integer,Integer>();\n+            attrs.put(x, y);\n+        }\n+    }\n+\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+    static class CreatorWithIndex {\n+        protected int _a, _b;\n+\n+        @JsonCreator\n+        public CreatorWithIndex(@JsonProperty(index=0, value=\"a\") int a,\n+                @JsonProperty(index=1, value=\"b\") int b) {\n+            this._a = a;\n+            this._b = b;\n+        }\n+    }\n+\n+\n     /*\n     /*****************************************************\n     /* Basic tests\n         String json = mapper.writeValueAsString(new SingleBean());\n         assertEquals(\"\\\"foo\\\"\", json);\n     }\n-    \n+\n+    public void testBeanAsArrayUnwrapped() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n+        SingleBean result = mapper.readValue(\"[\\\"foobar\\\"]\", SingleBean.class);\n+        assertNotNull(result);\n+        assertEquals(\"foobar\", result.name);\n+    }\n+\n     /*\n     /*****************************************************\n     /* Round-trip tests\n         mapper2.setAnnotationIntrospector(new ForceArraysIntrospector());\n         assertEquals(\"[[1,2]]\", mapper2.writeValueAsString(new A()));\n     }\n+\n+    public void testWithMaps() throws Exception\n+    {\n+        AsArrayWithMap input = new AsArrayWithMap(1, 2);\n+        String json = MAPPER.writeValueAsString(input);\n+        AsArrayWithMap output = MAPPER.readValue(json, AsArrayWithMap.class);\n+        assertNotNull(output);\n+        assertNotNull(output.attrs);\n+        assertEquals(1, output.attrs.size());\n+        assertEquals(Integer.valueOf(2), output.attrs.get(1));\n+    }\n+\n+    public void testSimpleWithIndex() throws Exception\n+    {\n+        // as POJO:\n+//        CreatorWithIndex value = MAPPER.readValue(aposToQuotes(\"{'b':1,'a':2}\"),\n+        CreatorWithIndex value = MAPPER.readValue(aposToQuotes(\"[2,1]\"),\n+                CreatorWithIndex.class);\n+        assertEquals(2, value._a);\n+        assertEquals(1, value._b);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayAdvanced.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayAdvanced.java\n package com.fasterxml.jackson.databind.struct;\n \n import com.fasterxml.jackson.annotation.*;\n-\n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n         public int b;\n         public int c;\n     }\n-    \n+\n     /*\n     /*****************************************************\n     /* Basic tests\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayWithBuilder.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayWithBuilder.java\n     {\n         public int x, y;\n         \n-        @SuppressWarnings(\"hiding\")\n-        public SimpleBuilderXY withX(int x) {\n-            this.x = x;\n+        public SimpleBuilderXY withX(int x0) {\n+            this.x = x0;\n             return this;\n         }\n \n-        @SuppressWarnings(\"hiding\")\n-        public SimpleBuilderXY withY(int y) {\n-            this.y = y;\n+        public SimpleBuilderXY withY(int y0) {\n+            this.y = y0;\n             return this;\n         }\n \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestParentChildReferences.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestParentChildReferences\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Test classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * First, a simple 'tree': just parent/child linkage\n+     */\n+    static class SimpleTreeNode\n+    {\n+        public String name;\n+        \n+        // Reference back to parent; reference, ignored during ser,\n+        // re-constructed during deser\n+        @JsonBackReference\n+        public SimpleTreeNode parent;\n+\n+        // Reference that is serialized normally during ser, back\n+        // reference within pointed-to instance assigned to point to\n+        // referring bean (\"this\")\n+        @JsonManagedReference\n+        public SimpleTreeNode child;\n+\n+        public SimpleTreeNode() { this(null); }\n+        public SimpleTreeNode(String n) { name = n; }\n+    }\n+\n+    static class SimpleTreeNode2\n+    {\n+        public String name;\n+        protected SimpleTreeNode2 parent;\n+        protected SimpleTreeNode2 child;\n+\n+        public SimpleTreeNode2() { this(null); }\n+        public SimpleTreeNode2(String n) { name = n; }\n+\n+        @JsonBackReference\n+        public SimpleTreeNode2 getParent() { return parent; }\n+        public void setParent(SimpleTreeNode2 p) { parent = p; }\n+\n+        @JsonManagedReference\n+        public SimpleTreeNode2 getChild() { return child; }\n+        public void setChild(SimpleTreeNode2 c) { child = c; }\n+    }\n+    \n+    /**\n+     * Then nodes with two separate linkages; parent/child\n+     * and prev/next-sibling\n+     */\n+    static class FullTreeNode\n+    {\n+        public String name;\n+\n+        // parent-child links\n+        @JsonBackReference(\"parent\")\n+        public FullTreeNode parent;\n+        @JsonManagedReference(\"parent\")\n+        public FullTreeNode firstChild;\n+\n+        // sibling-links\n+        @JsonManagedReference(\"sibling\")\n+        public FullTreeNode next;\n+        @JsonBackReference(\"sibling\")\n+        protected FullTreeNode prev;\n+        \n+        public FullTreeNode() { this(null); }\n+        public FullTreeNode(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    /**\n+     * Class for testing managed references via arrays\n+     */\n+    static class NodeArray\n+    {\n+        @JsonManagedReference(\"arr\")\n+        public ArrayNode[] nodes;\n+    }\n+\n+    static class ArrayNode\n+    {\n+        public String name;\n+        \n+        @JsonBackReference(\"arr\")\n+        public NodeArray parent;\n+\n+        public ArrayNode() { this(null); }\n+        public ArrayNode(String n) { name = n; }\n+    }\n+    \n+    /**\n+     * Class for testing managed references via Collections\n+     */\n+    static class NodeList\n+    {\n+        @JsonManagedReference\n+        public List<NodeForList> nodes;\n+    }\n+\n+    static class NodeForList\n+    {\n+        public String name;\n+        \n+        @JsonBackReference\n+        public NodeList parent;\n+\n+        public NodeForList() { this(null); }\n+        public NodeForList(String n) { name = n; }\n+    }\n+    \n+    static class NodeMap\n+    {\n+        @JsonManagedReference\n+        public Map<String,NodeForMap> nodes;\n+    }\n+\n+    static class NodeForMap\n+    {\n+        public String name;\n+        \n+        @JsonBackReference\n+        public NodeMap parent;\n+\n+        public NodeForMap() { this(null); }\n+        public NodeForMap(String n) { name = n; }\n+    }\n+\n+    public static class Parent {\n+        @JsonManagedReference\n+        protected final List<Child> children = new ArrayList<Child>();\n+\n+        public List<Child> getChildren() { return children; }\n+\n+        public void addChild(Child child) { children.add(child); child.setParent(this); }\n+    }\n+\n+    public static class Child {\n+        protected Parent parent;\n+        protected final String value; // So that the bean is not empty of properties\n+\n+        public Child(@JsonProperty(\"value\") String value) { this.value = value; }\n+\n+        public String getValue() { return value; }\n+\n+        @JsonBackReference\n+        public Parent getParent() { return parent; }\n+\n+        public void setParent(Parent parent) { this.parent = parent; }\n+    }\n+\n+    @JsonTypeInfo(use=Id.NAME)\n+    @JsonSubTypes({@JsonSubTypes.Type(ConcreteNode.class)})\n+    static abstract class AbstractNode\n+    {\n+        public String id;\n+        \n+        @JsonManagedReference public AbstractNode next;\n+        @JsonBackReference public AbstractNode prev;\n+    }\n+\n+    @JsonTypeName(\"concrete\")\n+    static class ConcreteNode extends AbstractNode {\n+        public ConcreteNode() { }\n+        public ConcreteNode(String id) { this.id = id; }\n+    }\n+    \n+    // [JACKSON-708]\n+    static class Model708 { }\n+    \n+    static class Advertisement708 extends Model708 {\n+        public String title;\n+        @JsonManagedReference public List<Photo708> photos;\n+    }\n+\n+    static class Photo708 extends Model708 {\n+        public int id;\n+        @JsonBackReference public Advertisement708 advertisement;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = objectMapper();\n+    \n+    public void testSimpleRefs() throws Exception\n+    {\n+        SimpleTreeNode root = new SimpleTreeNode(\"root\");\n+        SimpleTreeNode child = new SimpleTreeNode(\"kid\");\n+        root.child = child;\n+        child.parent = root;\n+        \n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        SimpleTreeNode resultNode = MAPPER.readValue(json, SimpleTreeNode.class);\n+        assertEquals(\"root\", resultNode.name);\n+        SimpleTreeNode resultChild = resultNode.child;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+    }\n+\n+    // [JACKSON-693]\n+    public void testSimpleRefsWithGetter() throws Exception\n+    {\n+        SimpleTreeNode2 root = new SimpleTreeNode2(\"root\");\n+        SimpleTreeNode2 child = new SimpleTreeNode2(\"kid\");\n+        root.child = child;\n+        child.parent = root;\n+        \n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        SimpleTreeNode2 resultNode = MAPPER.readValue(json, SimpleTreeNode2.class);\n+        assertEquals(\"root\", resultNode.name);\n+        SimpleTreeNode2 resultChild = resultNode.child;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+    }\n+    \n+    public void testFullRefs() throws Exception\n+    {\n+        FullTreeNode root = new FullTreeNode(\"root\");\n+        FullTreeNode child1 = new FullTreeNode(\"kid1\");\n+        FullTreeNode child2 = new FullTreeNode(\"kid2\");\n+        root.firstChild = child1;\n+        child1.parent = root;\n+        child1.next = child2;\n+        child2.prev = child1;\n+        \n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        FullTreeNode resultNode = MAPPER.readValue(json, FullTreeNode.class);\n+        assertEquals(\"root\", resultNode.name);\n+        FullTreeNode resultChild = resultNode.firstChild;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid1\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+\n+        // and then sibling linkage\n+        assertNull(resultChild.prev);\n+        FullTreeNode resultChild2 = resultChild.next;\n+        assertNotNull(resultChild2);\n+        assertEquals(\"kid2\", resultChild2.name);\n+        assertSame(resultChild, resultChild2.prev);\n+        assertNull(resultChild2.next);\n+    }\n+\n+    public void testArrayOfRefs() throws Exception\n+    {\n+        NodeArray root = new NodeArray();\n+        ArrayNode node1 = new ArrayNode(\"a\");\n+        ArrayNode node2 = new ArrayNode(\"b\");\n+        root.nodes = new ArrayNode[] { node1, node2 };\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeArray result = MAPPER.readValue(json, NodeArray.class);\n+        ArrayNode[] kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.length);\n+        assertEquals(\"a\", kids[0].name);\n+        assertEquals(\"b\", kids[1].name);\n+        assertSame(result, kids[0].parent);\n+        assertSame(result, kids[1].parent);\n+    }\n+\n+    public void testListOfRefs() throws Exception\n+    {\n+        NodeList root = new NodeList();\n+        NodeForList node1 = new NodeForList(\"a\");\n+        NodeForList node2 = new NodeForList(\"b\");\n+        root.nodes = Arrays.asList(node1, node2);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeList result = MAPPER.readValue(json, NodeList.class);\n+        List<NodeForList> kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.size());\n+        assertEquals(\"a\", kids.get(0).name);\n+        assertEquals(\"b\", kids.get(1).name);\n+        assertSame(result, kids.get(0).parent);\n+        assertSame(result, kids.get(1).parent);\n+    }\n+\n+    public void testMapOfRefs() throws Exception\n+    {\n+        NodeMap root = new NodeMap();\n+        NodeForMap node1 = new NodeForMap(\"a\");\n+        NodeForMap node2 = new NodeForMap(\"b\");\n+        Map<String,NodeForMap> nodes = new HashMap<String, NodeForMap>();\n+        nodes.put(\"a1\", node1);\n+        nodes.put(\"b2\", node2);\n+        root.nodes = nodes;\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeMap result = MAPPER.readValue(json, NodeMap.class);\n+        Map<String,NodeForMap> kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.size());\n+        assertNotNull(kids.get(\"a1\"));\n+        assertNotNull(kids.get(\"b2\"));\n+        assertEquals(\"a\", kids.get(\"a1\").name);\n+        assertEquals(\"b\", kids.get(\"b2\").name);\n+        assertSame(result, kids.get(\"a1\").parent);\n+        assertSame(result, kids.get(\"b2\").parent);\n+    }\n+\n+    // for [JACKSON-368]\n+    public void testAbstract368() throws Exception\n+    {\n+        AbstractNode parent = new ConcreteNode(\"p\");\n+        AbstractNode child = new ConcreteNode(\"c\");\n+        parent.next = child;\n+        child.prev = parent;\n+\n+        // serialization ought to be ok\n+        String json = MAPPER.writeValueAsString(parent);\n+\n+        AbstractNode root = MAPPER.readValue(json, AbstractNode.class);\n+\n+        assertEquals(ConcreteNode.class, root.getClass());\n+        assertEquals(\"p\", root.id);\n+        assertNull(root.prev);\n+        AbstractNode leaf = root.next;\n+        assertNotNull(leaf);\n+        assertEquals(\"c\", leaf.id);\n+        assertSame(root, leaf.prev);\n+    }\n+    \n+    public void testIssue693() throws Exception\n+    {\n+        Parent parent = new Parent();\n+        parent.addChild(new Child(\"foo\"));\n+        parent.addChild(new Child(\"bar\"));\n+        byte[] bytes = MAPPER.writeValueAsBytes(parent);\n+        Parent value = MAPPER.readValue(bytes, Parent.class); \n+        for (Child child : value.children) {\n+            assertEquals(value, child.getParent());\n+        }\n+    }\n+\n+    public void testIssue708() throws Exception\n+    {\n+        Advertisement708 ad = MAPPER.readValue(\"{\\\"title\\\":\\\"Hroch\\\",\\\"photos\\\":[{\\\"id\\\":3}]}\", Advertisement708.class);      \n+        assertNotNull(ad);\n+    }   \n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrapped.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrapped.java\n         public String first, last;\n     }\n \n+    // [databind#615]\n+    static class Parent {\n+        @JsonUnwrapped\n+        public Child c1;\n+\n+        public Parent() { }\n+        public Parent(String str) { c1 = new Child(str); }\n+    }\n+\n+    static class Child {\n+        public String field;\n+\n+        public Child() { }\n+        public Child(String f) { field = f; }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Tests, serialization\n         assertEquals(2, loc.y);\n     }\n \n+    public void testIssue615() throws Exception\n+    {\n+        Parent input = new Parent(\"name\");\n+        String json = MAPPER.writeValueAsString(input);\n+        Parent output = MAPPER.readValue(json, Parent.class);\n+        assertEquals(\"name\", output.c1.field);\n+    }\n+\n     // 22-Apr-2013, tatu: Commented out as it can't be simply fixed; requires implementing\n     //    deep-update/merge. But leaving here to help with that effort, if/when it proceeds.\n-    \n+\n     /*\n-    \n     // [Issue#211]: Actually just variant of #160\n-    \n+\n     static class Issue211Bean {\n         public String test1;\n \n         public String test3;\n         public String test4;\n     }\n-    \n+\n     public void testIssue211() throws Exception\n     {\n          Issue211Bean bean = new Issue211Bean();\n          assertNotNull(result.unwrapped);\n          assertEquals(\"Field 3 merged\", result.unwrapped.test3);\n          assertEquals(\"Field 4\", result.unwrapped.test4);\n-    }  \n+    }\n     */\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrappedWithSameName647.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import com.fasterxml.jackson.annotation.JsonUnwrapped;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestUnwrappedWithSameName647 extends BaseMapTest\n+{\n+    static class UnwrappedWithSamePropertyName {\n+        public MailHolder mail;\n+    }\n+\n+    static class MailHolder {\n+        @JsonUnwrapped\n+        public Mail mail;\n+    }\n+    \n+    static class Mail {\n+        public String mail;\n+    }\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testUnwrappedWithSamePropertyName() throws Exception {\n+        final String JSON = \"{'mail': {'mail': 'the mail text'}}\";\n+        UnwrappedWithSamePropertyName result = MAPPER.readValue(aposToQuotes(JSON), UnwrappedWithSamePropertyName.class);\n+        assertNotNull(result.mail);\n+        assertNotNull(result.mail.mail);\n+        assertEquals(\"the mail text\", result.mail.mail.mail);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java\n \n import java.util.*;\n \n+import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.JavaType;\n \n /**\n  * some degree\n  */\n public class TestJavaType\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends BaseMapTest\n {\n     static class BaseType { }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/type/TestTypeBindings.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeBindings.java\n \n import java.util.*;\n \n+import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.JavaType;\n \n /**\n  * implemented by {@link TypeBindings} class.\n  */\n public class TestTypeBindings\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends BaseMapTest\n {    \n     static class AbstractType<A,B> { }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.type.CollectionType;\n-import com.fasterxml.jackson.databind.type.HierarchicType;\n-import com.fasterxml.jackson.databind.type.MapType;\n-import com.fasterxml.jackson.databind.type.SimpleType;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n-import com.fasterxml.jackson.test.BaseTest;\n+\n+import com.fasterxml.jackson.databind.*;\n \n /**\n  * Simple tests to verify that the {@link TypeFactory} constructs\n  * type information as expected.\n  */\n public class TestTypeFactory\n-    extends BaseTest\n+    extends BaseMapTest\n {    \n     /*\n     /**********************************************************\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n         // first, simple class based\n-        JavaType t = tf.constructParametricType(ArrayList.class, String.class); // ArrayList<String>\n+        JavaType t = tf.constructParametrizedType(ArrayList.class, Collection.class, String.class); // ArrayList<String>\n         assertEquals(CollectionType.class, t.getClass());\n         JavaType strC = tf.constructType(String.class);\n         assertEquals(1, t.containedTypeCount());\n         assertNull(t.containedType(1));\n \n         // Then using JavaType\n-        JavaType t2 = tf.constructParametricType(Map.class, strC, t); // Map<String,ArrayList<String>>\n+        JavaType t2 = tf.constructParametrizedType(Map.class, Map.class, strC, t); // Map<String,ArrayList<String>>\n         // should actually produce a MapType\n         assertEquals(MapType.class, t2.getClass());\n         assertEquals(2, t2.containedTypeCount());\n         assertNull(t2.containedType(2));\n \n         // and then custom generic type as well\n-        JavaType custom = tf.constructParametricType(SingleArgGeneric.class, String.class);\n+        JavaType custom = tf.constructParametrizedType(SingleArgGeneric.class, SingleArgGeneric.class,\n+                String.class);\n         assertEquals(SimpleType.class, custom.getClass());\n         assertEquals(1, custom.containedTypeCount());\n         assertEquals(strC, custom.containedType(0));\n         // And finally, ensure that we can't create invalid combinations\n         try {\n             // Maps must take 2 type parameters, not just one\n-            tf.constructParametricType(Map.class, strC);\n+            tf.constructParametrizedType(Map.class, Map.class, strC);\n         } catch (IllegalArgumentException e) {\n             verifyException(e, \"Need exactly 2 parameter types for Map types\");\n         }\n \n         try {\n             // Type only accepts one type param\n-            tf.constructParametricType(SingleArgGeneric.class, strC, strC);\n+            tf.constructParametrizedType(SingleArgGeneric.class, SingleArgGeneric.class, strC, strC);\n         } catch (IllegalArgumentException e) {\n             verifyException(e, \"expected 1 parameters, was given 2\");\n         }\n         assertNull(sup2.getSuperType());\n     }\n \n+    private int _countSupers(HierarchicType t)\n+    {\n+        int depth = 0;\n+        for (HierarchicType sup = t.getSuperType(); sup != null; sup = sup.getSuperType()) {\n+            ++depth;\n+        }\n+        return depth;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests: map/collection type parameter resolution\n+    /**********************************************************\n+     */\n+\n+    public void testMapTypesSimple()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(new TypeReference<Map<String,Boolean>>() { });\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Boolean.class), mapType.getContentType());\n+    }\n+\n+    public void testMapTypesRaw()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(HashMap.class);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(Object.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Object.class), mapType.getContentType());        \n+    }\n+\n+    public void testMapTypesAdvanced()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(MyMap.class);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n+\n+        type = tf.constructType(MapInterface.class);\n+        mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n+\n+        type = tf.constructType(MyStringIntMap.class);\n+        mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n+    }\n+\n+    /**\n+     * Specific test to verify that complicate name mangling schemes\n+     * do not fool type resolver\n+     */\n+    public void testMapTypesSneaky()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(IntLongMap.class);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n+    }    \n+    \n+    /**\n+     * Plus sneaky types may be found via introspection as well.\n+     */\n+    public void testSneakyFieldTypes() throws Exception\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        Field field = SneakyBean.class.getDeclaredField(\"intMap\");\n+        JavaType type = tf.constructType(field.getGenericType());\n+        assertTrue(type instanceof MapType);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n+\n+        field = SneakyBean.class.getDeclaredField(\"longList\");\n+        type = tf.constructType(field.getGenericType());\n+        assertTrue(type instanceof CollectionType);\n+        CollectionType collectionType = (CollectionType) type;\n+        assertEquals(tf.constructType(Long.class), collectionType.getContentType());\n+    }    \n+    \n+    /**\n+     * Looks like type handling actually differs for properties, too.\n+     */\n+    public void testSneakyBeanProperties() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringLongMapBean bean = mapper.readValue(\"{\\\"value\\\":{\\\"a\\\":123}}\", StringLongMapBean.class);\n+        assertNotNull(bean);\n+        Map<String,Long> map = bean.value;\n+        assertEquals(1, map.size());\n+        assertEquals(Long.valueOf(123), map.get(\"a\"));\n+\n+        StringListBean bean2 = mapper.readValue(\"{\\\"value\\\":[\\\"...\\\"]}\", StringListBean.class);\n+        assertNotNull(bean2);\n+        List<String> list = bean2.value;\n+        assertSame(GenericList.class, list.getClass());\n+        assertEquals(1, list.size());\n+        assertEquals(\"...\", list.get(0));\n+    }\n+\n+    public void testSneakySelfRefs() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new SneakyBean2());\n+        assertEquals(\"{\\\"foobar\\\":null}\", json);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests: handling of specific JDK types\n+    /**********************************************************\n+     */\n+\n     public void testAtomicArrayRefParameterDetection()\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n         assertNull(sub.getSuperType());\n     }\n \n-    private int _countSupers(HierarchicType t)\n-    {\n-        int depth = 0;\n-        for (HierarchicType sup = t.getSuperType(); sup != null; sup = sup.getSuperType()) {\n-            ++depth;\n-        }\n-        return depth;\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Unit tests: map/collection type parameter resolution\n-    /**********************************************************\n-     */\n-\n-    public void testMapTypesSimple()\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        JavaType type = tf.constructType(new TypeReference<Map<String,Boolean>>() { });\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Boolean.class), mapType.getContentType());\n-    }\n-\n-    public void testMapTypesRaw()\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        JavaType type = tf.constructType(HashMap.class);\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(Object.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Object.class), mapType.getContentType());        \n-    }\n-\n-    public void testMapTypesAdvanced()\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        JavaType type = tf.constructType(MyMap.class);\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n-\n-        type = tf.constructType(MapInterface.class);\n-        mapType = (MapType) type;\n-        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n-\n-        type = tf.constructType(MyStringIntMap.class);\n-        mapType = (MapType) type;\n-        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n-    }\n-\n-    /**\n-     * Specific test to verify that complicate name mangling schemes\n-     * do not fool type resolver\n-     */\n-    public void testMapTypesSneaky()\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        JavaType type = tf.constructType(IntLongMap.class);\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n-    }    \n-    \n-    /**\n-     * Plus sneaky types may be found via introspection as well.\n-     */\n-    public void testSneakyFieldTypes() throws Exception\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        Field field = SneakyBean.class.getDeclaredField(\"intMap\");\n-        JavaType type = tf.constructType(field.getGenericType());\n-        assertTrue(type instanceof MapType);\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n-\n-        field = SneakyBean.class.getDeclaredField(\"longList\");\n-        type = tf.constructType(field.getGenericType());\n-        assertTrue(type instanceof CollectionType);\n-        CollectionType collectionType = (CollectionType) type;\n-        assertEquals(tf.constructType(Long.class), collectionType.getContentType());\n-    }    \n-    \n-    /**\n-     * Looks like type handling actually differs for properties, too.\n-     */\n-    public void testSneakyBeanProperties() throws Exception\n-    {\n-        ObjectMapper mapper = new ObjectMapper();\n-        StringLongMapBean bean = mapper.readValue(\"{\\\"value\\\":{\\\"a\\\":123}}\", StringLongMapBean.class);\n-        assertNotNull(bean);\n-        Map<String,Long> map = bean.value;\n-        assertEquals(1, map.size());\n-        assertEquals(Long.valueOf(123), map.get(\"a\"));\n-\n-        StringListBean bean2 = mapper.readValue(\"{\\\"value\\\":[\\\"...\\\"]}\", StringListBean.class);\n-        assertNotNull(bean2);\n-        List<String> list = bean2.value;\n-        assertSame(GenericList.class, list.getClass());\n-        assertEquals(1, list.size());\n-        assertEquals(\"...\", list.get(0));\n-    }\n-    \n     public void testAtomicArrayRefParameters()\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n         assertEquals(tf.constructType(long[].class), params[0]);\n     }\n \n-    public void testSneakySelfRefs() throws Exception\n-    {\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(new SneakyBean2());\n-        assertEquals(\"{\\\"foobar\\\":null}\", json);\n-    }\n-\n+    static abstract class StringIntMapEntry implements Map.Entry<String,Integer> { }\n+    \n+    public void testMapEntryResolution()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType t = tf.constructType(StringIntMapEntry.class);\n+        assertTrue(t.hasGenericTypes());\n+        assertEquals(2, t.containedTypeCount());\n+        assertEquals(String.class, t.containedType(0).getRawClass());\n+        assertEquals(Integer.class, t.containedType(1).getRawClass());\n+        // NOTE: no key/content types, at least not as of 2.5\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Unit tests: construction of \"raw\" types\n--- a/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n-\n+import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.type.CollectionType;\n import com.fasterxml.jackson.databind.type.MapType;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n @SuppressWarnings(\"serial\")\n-public class TestTypeResolution extends com.fasterxml.jackson.test.BaseTest\n+public class TestTypeResolution extends BaseMapTest\n {\n     public static class LongValuedMap<K> extends HashMap<K, Long> { }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java\n package com.fasterxml.jackson.databind.util;\n \n-import java.util.*;\n+import java.text.ParseException;\n import java.text.ParsePosition;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n \n import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.util.ISO8601Utils;\n \n /**\n  * @see ISO8601Utils\n  */\n-public class ISO8601UtilsTest extends BaseMapTest\n-{\n+public class ISO8601UtilsTest extends BaseMapTest {\n     private Date date;\n+    private Date dateWithoutTime;\n     private Date dateZeroMillis;\n+    private Date dateZeroSecondAndMillis;\n \n     @Override\n-    public void setUp()\n-    {\n+    public void setUp() {\n         Calendar cal = new GregorianCalendar(2007, 8 - 1, 13, 19, 51, 23);\n         cal.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n         cal.set(Calendar.MILLISECOND, 789);\n         date = cal.getTime();\n         cal.set(Calendar.MILLISECOND, 0);\n         dateZeroMillis = cal.getTime();\n+        cal.set(Calendar.SECOND, 0);\n+        dateZeroSecondAndMillis = cal.getTime();\n+        \n+        cal = new GregorianCalendar(2007, 8 - 1, 13, 0, 0, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        cal.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+        dateWithoutTime = cal.getTime();\n+\n     }\n \n     public void testFormat() {\n         assertEquals(date, d);\n     }\n \n+    public void testParseShortDate() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"20070813T19:51:23.789Z\", new ParsePosition(0));\n+        assertEquals(date, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T19:51:23Z\", new ParsePosition(0));\n+        assertEquals(dateZeroMillis, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T21:51:23.789+02:00\", new ParsePosition(0));\n+        assertEquals(date, d);\n+    }\n+\n+    public void testParseShortTime() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"2007-08-13T195123.789Z\", new ParsePosition(0));\n+        assertEquals(date, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T195123Z\", new ParsePosition(0));\n+        assertEquals(dateZeroMillis, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T215123.789+02:00\", new ParsePosition(0));\n+        assertEquals(date, d);\n+    }\n+\n+    public void testParseShortDateTime() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"20070813T195123.789Z\", new ParsePosition(0));\n+        assertEquals(date, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T195123Z\", new ParsePosition(0));\n+        assertEquals(dateZeroMillis, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T215123.789+02:00\", new ParsePosition(0));\n+        assertEquals(date, d);\n+    }\n+\n+    public void testParseWithoutTime() throws ParseException {\n+        Date d = ISO8601Utils.parse(\"2007-08-13Z\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+\n+        d = ISO8601Utils.parse(\"20070813Z\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13+00:00\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+\n+        d = ISO8601Utils.parse(\"20070813+00:00\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+    }\n+\n+    public void testParseWithoutTimeAndTimeZoneMustFail() {\n+        try {\n+            ISO8601Utils.parse(\"2007-08-13\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+        try {\n+            ISO8601Utils.parse(\"20070813\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+        try {\n+            ISO8601Utils.parse(\"2007-08-13\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+        try {\n+            ISO8601Utils.parse(\"20070813\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+    }\n+    \n+    \n+    public void testParseOptional() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"2007-08-13T19:51Z\", new ParsePosition(0));\n+        assertEquals(dateZeroSecondAndMillis, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T1951Z\", new ParsePosition(0));\n+        assertEquals(dateZeroSecondAndMillis, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T21:51+02:00\", new ParsePosition(0));\n+        assertEquals(dateZeroSecondAndMillis, d);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/util/TestObjectBuffer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/TestObjectBuffer.java\n \n import java.util.*;\n \n-import com.fasterxml.jackson.test.BaseTest;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n \n public class TestObjectBuffer\n-    extends BaseTest\n+    extends BaseMapTest\n {\n     /**\n      * First a test that treats results as plain old Object[]\n--- a/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.util.JsonParserSequence;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n-public class TestTokenBuffer extends com.fasterxml.jackson.test.BaseTest\n+public class TestTokenBuffer extends BaseMapTest\n {\n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/views/TestViewDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/views/TestViewDeserialization.java\n         \n         // but with different views, different contents\n         bean = mapper.readerWithView(ViewAA.class)\n-                .withType(Bean.class)\n+                .forType(Bean.class)\n                 .readValue(\"{\\\"a\\\":3, \\\"aa\\\":\\\"foo\\\", \\\"b\\\": 9 }\");\n         // should include 'a' and 'aa' (as per view)\n         assertEquals(3, bean.a);\n         assertEquals(0, bean.b);\n \n         bean = mapper.readerWithView(ViewA.class)\n-                .withType(Bean.class)\n+                .forType(Bean.class)\n                 .readValue(\"{\\\"a\\\":1, \\\"aa\\\":\\\"x\\\", \\\"b\\\": 3 }\");\n         assertEquals(1, bean.a);\n         assertNull(bean.aa);\n \n         // but with, say, AA, will not get 'b'\n         bean = myMapper.readerWithView(ViewAA.class)\n-                .withType(DefaultsBean.class)\n+                .forType(DefaultsBean.class)\n                 .readValue(\"{\\\"a\\\":1, \\\"b\\\": 2 }\");\n         // 'a' not there any more\n         assertEquals(0, bean.a);\n--- a/src/test/java/com/fasterxml/jackson/failing/TestConvertingSerializer357.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestConvertingSerializer357.java\n     extends com.fasterxml.jackson.databind.BaseMapTest\n {\n     // [Issue#357]\n-    static class A { }\n+    static class Value { }\n \n-    static class B {\n-        @JsonSerialize(contentConverter = AToStringConverter.class)\n-        public List<A> list = Arrays.asList(new A());\n+    static class ListWrapper {\n+        @JsonSerialize(contentConverter = ValueToStringListConverter.class)\n+        public List<Value> list = Arrays.asList(new Value());\n     }\n \n-    static class AToStringConverter extends StdConverter<A, List<String>> {\n+    static class ValueToStringListConverter extends StdConverter<Value, List<String>> {\n         @Override\n-        public List<String> convert(A value) {\n+        public List<String> convert(Value value) {\n             return Arrays.asList(\"Hello world!\");\n         }\n     }\n \n     // [Issue#357]\n     public void testConverterForList357() throws Exception {\n-        String json = objectWriter().writeValueAsString(new B());\n+        String json = objectWriter().writeValueAsString(new ListWrapper());\n         assertEquals(\"{\\\"list\\\":[[\\\"Hello world!\\\"]]}\", json);\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId222.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestExternalTypeId222 extends BaseMapTest\n+{\n+\t@SuppressWarnings(\"unused\")\n+\tpublic void testTypes() throws IOException {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+        final Point _date = new Point(new Date());\n+        final Point _integer = new Point(12231321);\n+        final Point _boolean = new Point(Boolean.TRUE);\n+        final Point _long = new Point(1234L);\n+\n+        final Point _pojo = new Point(new Pojo(1));\n+        final String s_date = mapper.writeValueAsString(_date);\n+        final String s_integer = mapper.writeValueAsString(_integer);\n+\n+//System.err.println(\"Int -> \"+s_integer);   \n+    \n+        final String s_boolean = mapper.writeValueAsString(_boolean);\n+        final String s_long = mapper.writeValueAsString(_long);\n+        final String s_pojo = mapper.writeValueAsString(_pojo);\n+\n+        final Point d_date = mapper.readValue(s_date, Point.class);\n+        final Point d_long = mapper.readValue(s_long, Point.class);\n+        final Point d_pojo = mapper.readValue(s_pojo, Point.class);\n+        final Point d_integer = mapper.readValue(s_integer, Point.class);\n+        final Point d_boolean = mapper.readValue(s_boolean, Point.class);\n+    }\n+\n+    @JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY,\n+        getterVisibility = JsonAutoDetect.Visibility.NONE,\n+        setterVisibility = JsonAutoDetect.Visibility.NONE)\n+    static class Point {\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+        property = \"t\",\n+        visible = true,\n+        include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+        defaultImpl = String.class)\n+        @JsonSubTypes({\n+        @JsonSubTypes.Type(value = Date.class, name = \"date\"),\n+        @JsonSubTypes.Type(value = Integer.class, name = \"int\"),\n+        @JsonSubTypes.Type(value = Long.class, name = \"long\"),\n+        @JsonSubTypes.Type(value = Boolean.class, name = \"bool\"),\n+        @JsonSubTypes.Type(value = Pojo.class, name = \"pojo\"),\n+        @JsonSubTypes.Type(value = String.class, name = \"\")\n+        })\n+        private final Object v;\n+    \n+        @JsonCreator\n+        public Point(@JsonProperty(\"v\") Object v) {\n+            this.v = v;\n+        }\n+    \n+        public Object getValue() {\n+            return v;\n+        }\n+    }\n+     \n+\n+    static class Pojo {\n+        public final int p;\n+\n+        @JsonCreator\n+        Pojo(@JsonProperty(\"p\") int p) {\n+            this.p = p;\n+        }\n+    }\n+\n+    // [Issue#222]\n+    static class Issue222Bean\n+    {\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+                property = \"type\",\n+                include = JsonTypeInfo.As.EXTERNAL_PROPERTY)\n+        public Issue222BeanB value;\n+\n+        public String type = \"foo\";\n+        \n+        public Issue222Bean() { }\n+        public Issue222Bean(int v) {\n+            value = new Issue222BeanB(v);\n+        }\n+    }\n+\n+    static class Issue222BeanB\n+    {\n+        public int x;\n+        \n+        public Issue222BeanB() { }\n+        public Issue222BeanB(int value) { x = value; }\n+    }\n+\n+    public void testIssue222() throws Exception\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        Issue222Bean input = new Issue222Bean(13);\n+        String json = mapper.writeValueAsString(input);\n+        assertEquals(\"{\\\"value\\\":{\\\"x\\\":13},\\\"type\\\":\\\"foo\\\"}\", json);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/failing/TestJavaType76.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestJavaType76.java\n \n import java.util.*;\n \n-import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Failing test related to [Issue#76]\n  */\n-public class TestJavaType76\n-    extends com.fasterxml.jackson.test.BaseTest\n+public class TestJavaType76 extends BaseMapTest\n {\n     @SuppressWarnings(\"serial\")\n     static class HashTree<K, V> extends HashMap<K, HashTree<K, V>> { }\n         assertNotNull(type);\n     }\n }\n-\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestLocalType609.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Failing test related to [databind#609]\n+ */\n+public class TestLocalType609 extends BaseMapTest\n+{\n+    static class EntityContainer {\n+        RuleForm entity;\n+        \n+        @SuppressWarnings(\"unchecked\")\n+        public <T extends RuleForm> T getEntity() { return (T) entity; }\n+        public <T extends RuleForm> void setEntity(T e) { entity = e; }\n+    }\n+\n+    static class RuleForm {\n+        public int value;\n+\n+        public RuleForm() { }\n+        public RuleForm(int v) { value = v; }\n+    }\n+\n+    public void testLocalPartialType609() throws Exception {\n+        ObjectMapper mapper = new ObjectMapper();\n+        \n+        EntityContainer input = new EntityContainer(); \n+        input.entity = new RuleForm(12);\n+        String json = mapper.writeValueAsString(input);\n+        \n+        EntityContainer output = mapper.readValue(json, EntityContainer.class);\n+        assertEquals(12, output.getEntity().value);\n+    }\n+}\n+\n--- a/src/test/java/com/fasterxml/jackson/failing/TestMapJsonValueKey47.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestMapJsonValueKey47.java\n package com.fasterxml.jackson.failing;\n \n import java.util.HashMap;\n-import java.util.Map;\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonValue;\n         }\n     }\n \n+    @SuppressWarnings(\"serial\")\n+    static class WatMap extends HashMap<Wat,Boolean> { }\n+    \n     public void testMapJsonValueKey()\n     throws Exception\n     {\n-        Map<Wat, Boolean> input = new HashMap<Wat, Boolean>();\n+        WatMap input = new WatMap();\n         input.put(new Wat(\"3\"), true);\n \n         ObjectMapper mapper = new ObjectMapper();\n         String json = mapper.writeValueAsString(input);\n-        assertEquals(aposToQuotes(\"{'3':'true'}\"), json);\n+        assertEquals(aposToQuotes(\"{'3':true}\"), json);\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestMapSerialization588.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.io.IOException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestMapSerialization588 extends BaseMapTest\n+{\n+    static class NoEmptiesMapContainer {\n+        @JsonInclude(value=JsonInclude.Include.NON_EMPTY,\n+                content=JsonInclude.Include.NON_EMPTY)\n+        public Map<String,String> stuff = new LinkedHashMap<String,String>();\n+        \n+        public NoEmptiesMapContainer add(String key, String value) {\n+            stuff.put(key, value);\n+            return this;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    final private ObjectMapper MAPPER = objectMapper();\n+\n+    // [databind#588]\n+    public void testNonNullValueMapViaProp() throws IOException\n+    {\n+        String json = MAPPER.writeValueAsString(new NoEmptiesMapContainer()\n+            .add(\"a\", null)\n+            .add(\"b\", \"\"));\n+        assertEquals(aposToQuotes(\"{}\"), json);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestMultipleExternalIds291.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestMultipleExternalIds291 extends BaseMapTest\n+{\n+    // For [Issue#291]\n+    interface F1 {}\n+\n+    static class A implements F1 {\n+        public String a;\n+    }\n+\n+    static class B implements F1 {\n+        public String b;\n+    }\n+\n+    static interface F2 {}\n+\n+    static class C implements F2 {\n+        public String c;\n+    }\n+\n+    static class D implements F2{\n+        public String d;\n+    }\n+\n+    static class Container {\n+        public String type;\n+\n+        @JsonTypeInfo(use = Id.NAME, property = \"type\", include = As.EXTERNAL_PROPERTY)\n+        @JsonSubTypes({\n+                @JsonSubTypes.Type(value = A.class, name = \"1\"),\n+                @JsonSubTypes.Type(value = B.class, name = \"2\")})\n+        public F1 field1;\n+\n+        @JsonTypeInfo(use = Id.NAME, property = \"type\", include = As.EXTERNAL_PROPERTY)\n+        @JsonSubTypes({\n+                @JsonSubTypes.Type(value = C.class, name = \"1\"),\n+                @JsonSubTypes.Type(value = D.class, name = \"2\")})\n+        public F2 field2;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    // [Issue#291]\n+    public void testMultiple() throws Exception\n+    {\n+        final ObjectMapper mapper = objectMapper();\n+        final String JSON =\n+\"{\\\"type\\\" : \\\"1\\\",\\n\"\n++\"\\\"field1\\\" : {\\n\"\n++\"  \\\"a\\\" : \\\"AAA\\\"\\n\"\n++\"}, \\\"field2\\\" : {\\n\"\n++\"  \\\"c\\\" : \\\"CCC\\\"\\n\"\n++\"}\\n\"\n++\"}\";\n+\n+        Container c = mapper.readValue(JSON, Container.class);\n+        assertNotNull(c);\n+        assertTrue(c.field1 instanceof A);\n+        assertTrue(c.field2 instanceof C);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestObjectIdWithInjectables538.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestObjectIdWithInjectables538 extends BaseMapTest\n+{\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)\n+    public static class A {\n+        public B b;\n+\n+        public A(@JacksonInject(\"i1\") String injected) {\n+        }\n+    }\n+\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)\n+    public static class B {\n+        public A a;\n+\n+        public B(@JacksonInject(\"i2\") String injected) {\n+        }\n+    } \n+\n+    /*\n+    /*****************************************************\n+    /* Test methods\n+    /*****************************************************\n+     */\n+    \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testWithInjectables538() throws Exception\n+    {\n+        A a = new A(\"a\");\n+        B b = new B(\"b\");\n+        a.b = b;\n+        b.a = a;\n+\n+        String json = MAPPER.writeValueAsString(a);\n+\n+        InjectableValues.Std inject = new InjectableValues.Std();\n+        inject.addValue(\"i1\", \"e1\");\n+        inject.addValue(\"i2\", \"e2\");\n+        A output = null;\n+\n+        try {\n+            output = MAPPER.reader(inject).forType(A.class).readValue(json);\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Failed to deserialize from JSON '\"+json+\"'\", e);\n+        }\n+        assertNotNull(output);\n+\n+        assertNotNull(output.b);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestOverlappingTypeIdNames312.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestOverlappingTypeIdNames312 extends BaseMapTest\n+{\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\")\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(name = \"a\", value = Impl312.class),\n+            @JsonSubTypes.Type(name = \"b\", value = Impl312.class)\n+    })\n+    static abstract class Base312 { }\n+\n+    static class Impl312 extends Base312 {\n+        public int x;\n+    }\n+    \n+    public void testOverlappingNameDeser() throws Exception\n+    {\n+        final ObjectMapper mapper = objectMapper();\n+        Base312 value;\n+\n+        // Ensure both type ids are acceptable\n+\n+        value = mapper.readValue(aposToQuotes(\"{'type':'a','x':7}\"), Base312.class);\n+        assertNotNull(value);\n+        assertEquals(Impl312.class, value.getClass());\n+        assertEquals(7, ((Impl312) value).x);\n+        \n+        value = mapper.readValue(aposToQuotes(\"{'type':'b','x':3}\"), Base312.class);\n+        assertNotNull(value);\n+        assertEquals(Impl312.class, value.getClass());\n+        assertEquals(3, ((Impl312) value).x);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/failing/TestPolymorphicDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestPolymorphicDeserialization.java\n  * deserializer comes to different conclusion (using default implementation class),\n  * resulting in a <code>ClassCastException</code>.\n  * Whether this is wrong, and if so, can we fix it, is unknown at this point\n- * (2.3.0-SNAPSHOT): quite possibly this can not be changed.\n+ * (2.3): quite possibly this can not be changed.\n  */\n public class TestPolymorphicDeserialization extends BaseMapTest\n {\n--- a/src/test/java/com/fasterxml/jackson/failing/TestScalaLikeImplicitProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestScalaLikeImplicitProperties.java\n             String name = null;\n             if (member instanceof AnnotatedField) {\n                 name = member.getName();\n-            }\n-            if (name != null) {\n-                if (name.endsWith(\"\u203f\")) {                    \n+                if (name.endsWith(\"\u203f\")) {\n                     return name.substring(0, name.length()-1);\n                 }\n+            } else if (member instanceof AnnotatedMethod) {\n+                name = member.getName();\n+                if (name.endsWith(\"_\u2040\")) {\n+                    return name.substring(0, name.length()-2);\n+                }\n+                if (!name.startsWith(\"get\") && !name.startsWith(\"set\")) {\n+                    return name;\n+                }\n+            } else if (member instanceof AnnotatedParameter) {\n+                // A placeholder for legitimate property name detection\n+                // such as what the JDK8 module provides\n+                return \"prop\";\n             }\n             return null;\n+        }\n+\n+        @Override\n+        public boolean hasCreatorAnnotation(Annotated a) {\n+            // A placeholder for legitmate creator detection.\n+            // In Scala, all primary constructors should be creators,\n+            // but I can't obtain a reference to the AnnotatedClass from the\n+            // AnnotatedConstructor, so it's simulated here.\n+            return (a instanceof AnnotatedConstructor);\n         }\n     }\n     \n     static class ValProperty\n     {\n-        public final String prop\u203f;\n+        private final String prop\u203f;\n         public String prop() { return prop\u203f; }\n \n         public ValProperty(String prop) {\n \n     static class ValWithBeanProperty\n     {\n-        public final String prop\u203f;\n+        private final String prop\u203f;\n         public String prop() { return prop\u203f; }\n         public String getProp() { return prop\u203f; }\n \n \n     static class VarProperty\n     {\n-        public String prop\u203f;\n+        private String prop\u203f;\n         public String prop() { return prop\u203f; }\n         public void prop_\u2040(String p) { prop\u203f = p; }\n \n \n     static class VarWithBeanProperty\n     {\n-        public String prop\u203f;\n+        private String prop\u203f;\n         public String prop() { return prop\u203f; }\n         public void prop_\u2040(String p) { prop\u203f = p; }\n         public String getProp() { return prop\u203f; }\n     {\n         ObjectMapper m = manglingMapper();\n \n-        // TODO: Activate whatever handler implements the property detection style\n-\n         assertEquals(\"{\\\"prop\\\":\\\"val\\\"}\", m.writeValueAsString(new ValProperty(\"val\")));\n     }\n \n     {\n         ObjectMapper m = manglingMapper();\n \n-        // TODO: Activate whatever handler implements the property detection style\n-\n         assertEquals(\"{\\\"prop\\\":\\\"val\\\"}\", m.writeValueAsString(new ValWithBeanProperty(\"val\")));\n     }\n \n     public void testVarProperty() throws Exception\n     {\n         ObjectMapper m = manglingMapper();\n-\n-        // TODO: Activate whatever handler implements the property detection style\n \n         assertEquals(\"{\\\"prop\\\":\\\"var\\\"}\", m.writeValueAsString(new VarProperty(\"var\")));\n         VarProperty result = m.readValue(\"{\\\"prop\\\":\\\"read\\\"}\", VarProperty.class);\n     {\n         ObjectMapper m = manglingMapper();\n \n-        // TODO: Activate whatever handler implements the property detection style\n-\n         assertEquals(\"{\\\"prop\\\":\\\"var\\\"}\", m.writeValueAsString(new VarWithBeanProperty(\"var\")));\n         VarWithBeanProperty result = m.readValue(\"{\\\"prop\\\":\\\"read\\\"}\", VarWithBeanProperty.class);\n         assertEquals(\"read\", result.prop());\n     public void testGetterSetterProperty() throws Exception\n     {\n         ObjectMapper m = manglingMapper();\n-\n-        // TODO: Activate whatever handler implements the property detection style\n \n         assertEquals(\"{\\\"prop\\\":\\\"get/set\\\"}\", m.writeValueAsString(new GetterSetterProperty()));\n         GetterSetterProperty result = m.readValue(\"{\\\"prop\\\":\\\"read\\\"}\", GetterSetterProperty.class);\n--- a/src/test/java/com/fasterxml/jackson/failing/TestSetterlessProperties501.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestSetterlessProperties501.java\n \n import com.fasterxml.jackson.databind.*;\n \n-/**\n- * Unit tests for verifying that feature requested\n- * via [JACKSON-88] (\"setterless collections\") work as\n- * expected, similar to how Collections and Maps work\n- * with JAXB.\n- */\n public class TestSetterlessProperties501\n     extends BaseMapTest\n {\n--- a/src/test/java/com/fasterxml/jackson/failing/TestTypeWithJsonValue466.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestTypeWithJsonValue466.java\n package com.fasterxml.jackson.failing;\n \n import java.io.*;\n+import java.math.BigDecimal;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n     // The following is required for the testDecimalMetadata test case. That case fails.\n     @JsonTypeName(value = \"decimalValue\")\n     public static class DecimalValue {\n-        private java.math.BigDecimal value;\n-        public DecimalValue(){ this.value = java.math.BigDecimal.valueOf( 1234.4321 ); }\n+        private BigDecimal value;\n+        public DecimalValue() { value = new BigDecimal(\"111.1\"); }\n      \n         @JsonValue\n-        public java.math.BigDecimal getValue(){ return value; }\n+        public BigDecimal getValue(){ return value; }\n     }\n \n     @JsonPropertyOrder({\"key\",\"value\"})\n     public static class DecimalEntry {\n-    public DecimalEntry(){}\n-        public String getKey(){ return \"num\"; }\n+    public DecimalEntry() {}\n+        public String getKey() { return \"num\"; }\n          \n         @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.EXTERNAL_PROPERTY)\n         public DecimalValue getValue(){\n     @JsonTypeName(value = \"doubleValue\")\n     public static class DoubleValue {\n         private Double value;\n-        public DoubleValue(){ this.value = 1234.4321; }\n+        public DoubleValue() { value = 1234.25; }\n          \n         @JsonValue\n-        public Double getValue(){ return value; }\n+        public Double getValue() { return value; }\n     }\n \n     @JsonPropertyOrder({\"key\",\"value\"})\n     \n     public void testDoubleMetadata() throws IOException {\n         DoubleMetadata doub = new DoubleMetadata();\n-        String expected = \"{\\\"metadata\\\":[{\\\"key\\\":\\\"num\\\",\\\"value\\\":1234.4321,\\\"@type\\\":\\\"doubleValue\\\"}]}\";\n+        String expected = \"{\\\"metadata\\\":[{\\\"key\\\":\\\"num\\\",\\\"value\\\":1234.25,\\\"@type\\\":\\\"doubleValue\\\"}]}\";\n         String json = MAPPER.writeValueAsString(doub);\n         assertEquals(\"Serialized json not equivalent\", expected, json);\n     }\n \n     public void testDecimalMetadata() throws IOException{\n         DecimalMetadata dec = new DecimalMetadata();\n-        String expected = \"{\\\"metadata\\\":[{\\\"key\\\":\\\"num\\\",\\\"value\\\":1234.4321,\\\"@type\\\":\\\"decimalValue\\\"}]}\";\n+        String expected = \"{\\\"metadata\\\":[{\\\"key\\\":\\\"num\\\",\\\"value\\\":111.1,\\\"@type\\\":\\\"decimalValue\\\"}]}\";\n         String json = MAPPER.writeValueAsString(dec);\n         assertEquals(\"Serialized json not equivalent\", expected, json);\n     }\n--- a/src/test/java/com/fasterxml/jackson/failing/TestUnknownProperty426.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestUnknownProperty426.java\n public class TestUnknownProperty426 extends BaseMapTest\n {\n     // For [Issue#426]\n-    @JsonIgnoreProperties({ \"userId\"})\n-    public class User {\n+    @JsonIgnoreProperties({ \"userId\" })\n+    static class User {\n+        public String firstName;\n         Integer userId; \n \n         void setUserId(String id) {\n             setUserId(new Integer(id));\n         }\n-    \n+\n         public Integer getUserId() {\n             return userId;\n         }\n-    \n+\n         public void setUserId(Integer v) {\n             this.userId = v;\n         }\n \n     public void testIssue426() throws Exception\n     {\n-        String jsonString = \"{id: 9, firstName: \\\"Mike\\\" }\";\n-        User result = MAPPER.reader( User.class ).readValue(jsonString);\n+        final String JSON = aposToQuotes(\"{'userId': 9, 'firstName': 'Mike' }\");\n+        User result = MAPPER.reader(User.class).readValue(JSON);\n         assertNotNull(result);\n+        assertEquals(\"Mike\", result.firstName);\n     }\n }\n \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestUnwrappedWithCreator265.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestUnwrappedWithCreator265 extends BaseMapTest\n+{\n+    static class JAddress {\n+        protected String address;\n+        protected String city;\n+        protected String state;\n+         \n+        @JsonCreator\n+        public JAddress( @JsonProperty(\"address\") String address,\n+                @JsonProperty(\"city\") String city,\n+                @JsonProperty(\"state\") String state\n+        ){\n+            this.address = address;\n+            this.city = city;\n+            this.state = state;\n+        }\n+         \n+        public String getAddress1() { return address; }\n+        public String getCity() { return city; }\n+        public String getState() { return state; }\n+    }\n+\n+    static class JPerson {\n+        protected String _name;\n+        protected JAddress _address;\n+        protected String _alias;\n+         \n+        @JsonCreator\n+        public JPerson(@JsonProperty(\"name\") String name,\n+        @JsonUnwrapped JAddress address,\n+        @JsonProperty(\"alias\") String alias) {\n+            _name = name;\n+            _address = address;\n+            _alias = alias;\n+        }\n+         \n+        public String getName() {\n+            return _name;\n+        }\n+         \n+        @JsonUnwrapped public JAddress getAddress() {\n+            return _address;\n+        }\n+         \n+        public String getAlias() { return _alias; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    // For [Issue#265] / [Scala#90]\n+    public void testUnwrappedWithCreator() throws Exception\n+    {\n+        JPerson person = new JPerson(\"MyName\", new JAddress(\"main street\", \"springfield\", \"WA\"), \"bubba\");\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(person);\n+        JPerson result = mapper.readValue(json, JPerson.class);\n+        assertNotNull(result);\n+        assertEquals(person._name, result._name);\n+        assertNotNull(result._address);\n+        assertEquals(person._address.city, result._address.city);\n+\n+        // and see that round-tripping works\n+        assertEquals(json, mapper.writeValueAsString(result));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestUnwrappedWithUnknown650.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.JsonUnwrapped;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestUnwrappedWithUnknown650 extends BaseMapTest\n+{\n+    static class A {\n+        @JsonUnwrapped\n+        public B b;\n+    }\n+\n+    static class B {\n+        public String field;\n+    }\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testFailOnUnknownPropertyUnwrapped() throws Exception\n+    {\n+        assertTrue(MAPPER.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+\n+        final String JSON = \"{'field': 'value', 'bad':'bad value'}\";\n+        try {\n+            MAPPER.readValue(aposToQuotes(JSON), A.class);\n+            fail(\"Exception was not thrown on unkown property\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Unrecognized field\");\n+        }\n+    }\n+}\n--- a/src/test/java/perf/ManulWritePerfWithUUID.java\n+++ b/src/test/java/perf/ManulWritePerfWithUUID.java\n     public UUIDSlow(UUID[] v) { values = v; }\n }\n \n+@SuppressWarnings(\"serial\")\n class SlowSer extends StdScalarSerializer<UUID>\n {\n     public SlowSer() { super(UUID.class); }\n--- a/src/test/java/perf/ObjectReaderTestBase.java\n+++ b/src/test/java/perf/ObjectReaderTestBase.java\n         System.out.print(\"Warming up\");\n \n         final ObjectReader jsonReader = mapper1.reader()\n-                .withType(inputClass1);\n+                .forType(inputClass1);\n         final ObjectReader arrayReader = mapper2.reader()\n-                .withType(inputClass2);\n+                .forType(inputClass2);\n         \n         int i = 0;\n         final int TYPES = 2;\n \n         final ObjectReader jsonReader = mapper1.reader()\n                 .with(DeserializationFeature.EAGER_DESERIALIZER_FETCH)\n-                .withType(inputClass1);\n+                .forType(inputClass1);\n         final ObjectReader arrayReader = mapper2.reader()\n                 .with(DeserializationFeature.EAGER_DESERIALIZER_FETCH)\n-                .withType(inputClass2);\n+                .forType(inputClass2);\n         \n         int i = 0;\n         final int TYPES = 2;\n--- a/src/test/java/perf/ObjectWriterTestBase.java\n+++ b/src/test/java/perf/ObjectWriterTestBase.java\n         }\n \n         final ObjectWriter writer0 = mapper.writer().with(SerializationFeature.EAGER_SERIALIZER_FETCH);\n-        final ObjectWriter writer1 = writer0.withType(inputClass1);\n-        final ObjectWriter writer2 = writer0.withType(inputClass2);\n+        final ObjectWriter writer1 = writer0.forType(inputClass1);\n+        final ObjectWriter writer2 = writer0.forType(inputClass2);\n         \n         int i = 0;\n         int roundsDone = 0;", "timestamp": 1421912724, "metainfo": ""}