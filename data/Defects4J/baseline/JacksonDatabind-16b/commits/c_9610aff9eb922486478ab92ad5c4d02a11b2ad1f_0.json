{"sha": "9610aff9eb922486478ab92ad5c4d02a11b2ad1f", "log": "Implemented [JACKSON-777] (renamed SerializationConfig.Feature, DeserializationConfig.Feature); various other restructure", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java\n package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n \n /**\n  * Defines interface for resolvers that can resolve abstract types into concrete\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n import com.fasterxml.jackson.databind.util.Annotations;\n import com.fasterxml.jackson.databind.util.Named;\n \n-\n /**\n  * Bean properties are logical entities that represent data\n- * Java objects (\"beans\", although more accurately POJOs)\n- * contain; and that are accessed using some combination\n- * of methods (getter, setter), field and constructor\n- * parameter.\n+ * that Java objects (POJOs (Plain Old Java Objects), sometimes also called \"beans\")\n+ * contain; and that are accessed using accessors (methods like getters\n+ * and setters, fields, contstructor parametrers).\n  * Instances allow access to annotations directly associated\n  * to property (via field or method), as well as contextual\n  * annotations (annotations for class that contains properties).\n  *<p>\n- * Instances are passed during construction of serializers and\n- * deserializers, and references can be stored by serializers\n- * and deserializers for futher use; mostly to retain access\n- * to annotations when dynamically locating handlers for\n- * sub-properties or dynamic types.\n+ * Instances are not typically passed when constructing serializers\n+ * and deserializers, but rather only passed when context\n+ * is known when\n+ * {@link com.fasterxml.jackson.databind.ser.ContextualSerializer} and\n+ * {@link com.fasterxml.jackson.databind.deser.ContextualDeserializer}\n+ * resolution occurs (<code>createContextual(...)</code> method is called).\n+ * References may (need to) be retained by serializers and deserializers,\n+ * especially when further resolving dependant handlers like value\n+ * serializers/deserializers or structured types.\n  */\n public interface BeanProperty extends Named\n {\n     \n     /*\n     /**********************************************************\n-    /* Simple stand-alone implementation, useful as a placeholder\n-    /* or base class.\n+    /* Helper classes\n     /**********************************************************\n      */\n \n+    /**\n+     * Simple stand-alone implementation, useful as a placeholder\n+     * or base class for more complex implementations.\n+     */\n     public static class Std implements BeanProperty\n     {\n         protected final String _name;\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanPropertyDefinition.java\n  * serialization and deserialization purposes.\n  * These instances are created before actual {@link BeanProperty}\n  * instances are created, i.e. they are used earlier in the process\n- * flow.\n+ * flow, and are typically use to construct actual\n+ * {@link BeanProperty} instances.\n  */\n public abstract class BeanPropertyDefinition\n     implements Named\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.annotation.NoClass;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.deser.impl.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer;\n      * Convenience method for checking whether specified on/off\n      * feature is enabled\n      */\n-    public final boolean isEnabled(DeserializationConfig.Feature feat) {\n+    public final boolean isEnabled(DeserializationFeature feat) {\n         /* 03-Dec-2010, tatu: minor shortcut; since this is called quite often,\n          *   let's use a local copy of feature settings:\n          */\n         return (_featureFlags & feat.getMask()) != 0;\n     }\n \n-    public final boolean isEnabled(MapperConfig.Feature feat) {\n+    public final boolean isEnabled(MapperFeature feat) {\n         return _config.isEnabled(feat);\n     }\n     \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.databind.cfg.ConfigFeature;\n+\n+/**\n+ * Enumeration that defines simple on/off features that affect\n+ * the way Java objects are deserialized from JSON\n+ *<p>\n+ * Note that features can be set both through\n+ * {@link ObjectMapper} (as sort of defaults) and through\n+ * {@link ObjectReader}.\n+ * In first case these defaults must follow \"config-then-use\" patterns\n+ * (i.e. defined once, not changed afterwards); all per-call\n+ * changes must be done using {@link ObjectReader}.\n+ */\n+public enum DeserializationFeature implements ConfigFeature\n+{\n+    /*\n+    /******************************************************\n+    /* Type conversion features\n+    /******************************************************\n+     */\n+\n+    /**\n+     * SerializationFeature that determines whether JSON floating point numbers\n+     * are to be deserialized into {@link java.math.BigDecimal}s\n+     * if only generic type description (either {@link Object} or\n+     * {@link Number}, or within untyped {@link java.util.Map}\n+     * or {@link java.util.Collection} context) is available.\n+     * If enabled such values will be deserialized as {@link java.math.BigDecimal}s;\n+     * if disabled, will be deserialized as {@link Double}s.\n+     * <p>\n+     * SerializationFeature is disabled by default, meaning that \"untyped\" floating\n+     * point numbers will by default be deserialized as {@link Double}s\n+     * (choice is for performance reason -- BigDecimals are slower than\n+     * Doubles).\n+     */\n+    USE_BIG_DECIMAL_FOR_FLOATS(false),\n+\n+    /**\n+     * SerializationFeature that determines whether JSON integral (non-floating-point)\n+     * numbers are to be deserialized into {@link java.math.BigInteger}s\n+     * if only generic type description (either {@link Object} or\n+     * {@link Number}, or within untyped {@link java.util.Map}\n+     * or {@link java.util.Collection} context) is available.\n+     * If enabled such values will be deserialized as\n+     * {@link java.math.BigInteger}s;\n+     * if disabled, will be deserialized as \"smallest\" available type,\n+     * which is either {@link Integer}, {@link Long} or\n+     * {@link java.math.BigInteger}, depending on number of digits.\n+     * <p>\n+     * SerializationFeature is disabled by default, meaning that \"untyped\" floating\n+     * point numbers will by default be deserialized using whatever\n+     * is the most compact integral type, to optimize efficiency.\n+     */\n+    USE_BIG_INTEGER_FOR_INTS(false),\n+\n+    // [JACKSON-652]\n+    /**\n+     * SerializationFeature that determines whether JSON Array is mapped to\n+     * <code>Object[]</code> or <code>List&lt;Object></code> when binding\n+     * \"untyped\" objects (ones with nominal type of <code>java.lang.Object</code>).\n+     * If true, binds as <code>Object[]</code>; if false, as <code>List&lt;Object></code>.\n+     *<p>\n+     * SerializationFeature is disabled by default, meaning that JSON arrays are bound as\n+     * {@link java.util.List}s.\n+     */\n+    USE_JAVA_ARRAY_FOR_JSON_ARRAY(false),\n+    \n+    /**\n+     * SerializationFeature that determines standard deserialization mechanism used for\n+     * Enum values: if enabled, Enums are assumed to have been serialized  using\n+     * return value of <code>Enum.toString()</code>;\n+     * if disabled, return value of <code>Enum.name()</code> is assumed to have been used.\n+     *<p>\n+     * Note: this feature should usually have same value\n+     * as {@link SerializationConfig.SerializationFeature#WRITE_ENUMS_USING_TO_STRING}.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    READ_ENUMS_USING_TO_STRING(false),\n+    \n+    /*\n+    /******************************************************\n+     *  Error handling features\n+    /******************************************************\n+     */\n+\n+    /**\n+     * SerializationFeature that determines whether encountering of unknown\n+     * properties (ones that do not map to a property, and there is\n+     * no \"any setter\" or handler that can handle it)\n+     * should result in a failure (by throwing a\n+     * {@link JsonMappingException}) or not.\n+     * This setting only takes effect after all other handling\n+     * methods for unknown properties have been tried, and\n+     * property remains unhandled.\n+     *<p>\n+     * SerializationFeature is enabled by default (meaning that a\n+     * {@link JsonMappingException} will be thrown if an unknown property\n+     * is encountered).\n+     */\n+    FAIL_ON_UNKNOWN_PROPERTIES(true),\n+\n+    /**\n+     * SerializationFeature that determines whether encountering of JSON null\n+     * is an error when deserializing into Java primitive types\n+     * (like 'int' or 'double'). If it is, a JsonProcessingException\n+     * is thrown to indicate this; if not, default value is used\n+     * (0 for 'int', 0.0 for double, same defaulting as what JVM uses).\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    FAIL_ON_NULL_FOR_PRIMITIVES(false),\n+\n+    /**\n+     * SerializationFeature that determines whether JSON integer numbers are valid\n+     * values to be used for deserializing Java enum values.\n+     * If set to 'false' numbers are acceptable and are used to map to\n+     * ordinal() of matching enumeration value; if 'true', numbers are\n+     * not allowed and a {@link JsonMappingException} will be thrown.\n+     * Latter behavior makes sense if there is concern that accidental\n+     * mapping from integer values to enums might happen (and when enums\n+     * are always serialized as JSON Strings)\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    FAIL_ON_NUMBERS_FOR_ENUMS(false),\n+\n+    /**\n+     * SerializationFeature that determines whether Jackson code should catch\n+     * and wrap {@link Exception}s (but never {@link Error}s!)\n+     * to add additional information about\n+     * location (within input) of problem or not. If enabled,\n+     * most exceptions will be caught and re-thrown (exception\n+     * specifically being that {@link java.io.IOException}s may be passed\n+     * as is, since they are declared as throwable); this can be\n+     * convenient both in that all exceptions will be checked and\n+     * declared, and so there is more contextual information.\n+     * However, sometimes calling application may just want \"raw\"\n+     * unchecked exceptions passed as is.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    WRAP_EXCEPTIONS(true),\n+    \n+    /*\n+    /******************************************************\n+     *  Structural conversion features\n+    /******************************************************\n+     */\n+\n+    /**\n+     * SerializationFeature that determines whether it is acceptable to coerce non-array\n+     * (in JSON) values to work with Java collection (arrays, java.util.Collection)\n+     * types. If enabled, collection deserializers will try to handle non-array\n+     * values as if they had \"implicit\" surrounding JSON array.\n+     * This feature is meant to be used for compatibility/interoperability reasons,\n+     * to work with packages (such as XML-to-JSON converters) that leave out JSON\n+     * array in cases where there is just a single element in array.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    ACCEPT_SINGLE_VALUE_AS_ARRAY(false),\n+    \n+    /**\n+     * SerializationFeature to allow \"unwrapping\" root-level JSON value, to match setting of\n+     * {@link SerializationConfig.SerializationFeature#WRAP_ROOT_VALUE} used for serialization.\n+     * Will verify that the root JSON value is a JSON Object, and that it has\n+     * a single property with expected root name. If not, a\n+     * {@link JsonMappingException} is thrown; otherwise value of the wrapped property\n+     * will be deserialized as if it was the root value.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    UNWRAP_ROOT_VALUE(false),\n+\n+    /*\n+    /******************************************************\n+    /* Value conversion features\n+    /******************************************************\n+     */\n+    \n+    /**\n+     * SerializationFeature that can be enabled to allow JSON empty String\n+     * value (\"\") to be bound to POJOs as null.\n+     * If disabled, standard POJOs can only be bound from JSON null or\n+     * JSON Object (standard meaning that no custom deserializers or\n+     * constructors are defined; both of which can add support for other\n+     * kinds of JSON values); if enable, empty JSON String can be taken\n+     * to be equivalent of JSON null.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false)\n+    \n+    ;\n+\n+    private final boolean _defaultState;\n+    \n+    private DeserializationFeature(boolean defaultState) {\n+        _defaultState = defaultState;\n+    }\n+\n+    @Override\n+    public boolean enabledByDefault() { return _defaultState; }\n+\n+    @Override\n+    public int getMask() { return (1 << ordinal()); }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.cfg.ConfigFeature;\n+\n+/**\n+ * Enumeration that defines simple on/off features to set\n+ * for {@link ObjectMapper}, and accessible (but not changeable)\n+ * via {@link ObjectReader} and {@link ObjectWriter} (as well as\n+ * through various convenience methods through context objects).\n+ *<p>\n+ * Note that in addition to being only mutable via {@link ObjectMapper},\n+ * changes only take effect when done <b>before any serialization or\n+ * deserialization</b> calls -- that is, caller must follow\n+ * \"configure-then-use\" pattern.\n+ */\n+public enum MapperFeature implements ConfigFeature\n+{\n+    /*\n+    /******************************************************\n+    /*  Introspection features\n+    /******************************************************\n+     */\n+    \n+    /**\n+     * Feature that determines whether annotation introspection\n+     * is used for configuration; if enabled, configured\n+     * {@link AnnotationIntrospector} will be used: if disabled,\n+     * no annotations are considered.\n+     *<p>\n+     * Feature is enabled by default.\n+     */\n+    USE_ANNOTATIONS(true),\n+\n+    /**\n+     * Feature that determines whether \"creator\" methods are\n+     * automatically detected by consider public constructors,\n+     * and static single argument methods with name \"valueOf\".\n+     * If disabled, only methods explicitly annotated are considered\n+     * creator methods (except for the no-arg default constructor which\n+     * is always considered a factory method).\n+     *<p>\n+     * Note that this feature has lower precedence than per-class\n+     * annotations, and is only used if there isn't more granular\n+     * configuration available.\n+     *<P>\n+     * Feature is enabled by default.\n+     */\n+    AUTO_DETECT_CREATORS(true),\n+    \n+    /**\n+     * Feature that determines whether non-static fields are recognized as\n+     * properties.\n+     * If yes, then all public member fields\n+     * are considered as properties. If disabled, only fields explicitly\n+     * annotated are considered property fields.\n+     *<p>\n+     * Note that this feature has lower precedence than per-class\n+     * annotations, and is only used if there isn't more granular\n+     * configuration available.\n+     *<p>\n+     * Feature is enabled by default.\n+     */\n+     AUTO_DETECT_FIELDS(true),\n+    \n+    /**\n+     * Feature that determines whether regualr \"getter\" methods are\n+     * automatically detected based on standard Bean naming convention\n+     * or not. If yes, then all public zero-argument methods that\n+     * start with prefix \"get\" \n+     * are considered as getters.\n+     * If disabled, only methods explicitly  annotated are considered getters.\n+     *<p>\n+     * Note that since version 1.3, this does <b>NOT</b> include\n+     * \"is getters\" (see {@link #AUTO_DETECT_IS_GETTERS} for details)\n+     *<p>\n+     * Note that this feature has lower precedence than per-class\n+     * annotations, and is only used if there isn't more granular\n+     * configuration available.\n+     *<p>\n+     * Feature is enabled by default.\n+     */\n+    AUTO_DETECT_GETTERS(true),\n+\n+    /**\n+     * Feature that determines whether \"is getter\" methods are\n+     * automatically detected based on standard Bean naming convention\n+     * or not. If yes, then all public zero-argument methods that\n+     * start with prefix \"is\", and whose return type is boolean\n+     * are considered as \"is getters\".\n+     * If disabled, only methods explicitly annotated are considered getters.\n+     *<p>\n+     * Note that this feature has lower precedence than per-class\n+     * annotations, and is only used if there isn't more granular\n+     * configuration available.\n+     *<p>\n+     * Feature is enabled by default.\n+     */\n+    AUTO_DETECT_IS_GETTERS(true),\n+\n+     /**\n+      * Feature that determines whether \"setter\" methods are\n+      * automatically detected based on standard Bean naming convention\n+      * or not. If yes, then all public one-argument methods that\n+      * start with prefix \"set\"\n+      * are considered setters. If disabled, only methods explicitly\n+      * annotated are considered setters.\n+      *<p>\n+      * Note that this feature has lower precedence than per-class\n+      * annotations, and is only used if there isn't more granular\n+      * configuration available.\n+      *<P>\n+      * Feature is enabled by default.\n+      */\n+     AUTO_DETECT_SETTERS(true),\n+     \n+     /**\n+      * Feature that determines whether getters (getter methods)\n+      * can be auto-detected if there is no matching mutator (setter,\n+      * constructor parameter or field) or not: if set to true,\n+      * only getters that match a mutator are auto-discovered; if\n+      * false, all auto-detectable getters can be discovered.\n+      *<p>\n+      * Feature is disabled by default.\n+      */\n+     REQUIRE_SETTERS_FOR_GETTERS(false),\n+\n+     /**\n+      * Feature that determines whether otherwise regular \"getter\"\n+      * methods (but only ones that handle Collections and Maps,\n+      * not getters of other type)\n+      * can be used for purpose of getting a reference to a Collection\n+      * and Map to modify the property, without requiring a setter\n+      * method.\n+      * This is similar to how JAXB framework sets Collections and\n+      * Maps: no setter is involved, just setter.\n+      *<p>\n+      * Note that such getters-as-setters methods have lower\n+      * precedence than setters, so they are only used if no\n+      * setter is found for the Map/Collection property.\n+      *<p>\n+      * Feature is enabled by default.\n+      */\n+     USE_GETTERS_AS_SETTERS(true),\n+\n+     /**\n+     * Feature that determines whether method and field access\n+     * modifier settings can be overridden when accessing\n+     * properties. If enabled, method\n+     * {@link java.lang.reflect.AccessibleObject#setAccessible}\n+     * may be called to enable access to otherwise unaccessible\n+     * objects.\n+     *<p>\n+     * Feature is enabled by default.\n+     */\n+    CAN_OVERRIDE_ACCESS_MODIFIERS(true),\n+\n+    /*\n+    /******************************************************\n+    /* Type-handling features\n+    /******************************************************\n+     */\n+\n+    /**\n+     * SerializationFeature that determines whether the type detection for\n+     * serialization should be using actual dynamic runtime type,\n+     * or declared static type.\n+     * Note that deserialization always uses declared static types\n+     * since no runtime types are available (as we are creating\n+     * instances after using type information).\n+     *<p>\n+     * This global default value can be overridden at class, method\n+     * or field level by using {@link JsonSerialize#typing} annotation\n+     * property.\n+     *<p>\n+     * Feature is disabled by default which means that dynamic runtime types\n+     * are used (instead of declared static types) for serialization.\n+     */\n+    USE_STATIC_TYPING(false),\n+\n+    /*\n+    /******************************************************\n+    /* View-related features\n+    /******************************************************\n+     */\n+    \n+    /**\n+     * SerializationFeature that determines whether properties that have no view\n+     * annotations are included in JSON serialization views (see\n+     * {@link com.fasterxml.jackson.annotation.JsonView} for more\n+     * details on JSON Views).\n+     * If enabled, non-annotated properties will be included;\n+     * when disabled, they will be excluded. So this feature\n+     * changes between \"opt-in\" (feature disabled) and\n+     * \"opt-out\" (feature enabled) modes.\n+     *<p>\n+     * Default value is enabled, meaning that non-annotated\n+     * properties are included in all views if there is no\n+     * {@link com.fasterxml.jackson.annotation.JsonView} annotation.\n+     *<p>\n+     * Feature is enabled by default.\n+     */\n+    DEFAULT_VIEW_INCLUSION(true),\n+    \n+    /*\n+    /******************************************************\n+    /* Generic output features\n+    /******************************************************\n+     */\n+\n+    /**\n+     * SerializationFeature that defines default property serialization order used\n+     * for POJO fields (note: does <b>not</b> apply to {@link java.util.Map}\n+     * serialization!):\n+     * if enabled, default ordering is alphabetic (similar to\n+     * how {@link com.fasterxml.jackson.annotation.JsonPropertyOrder#alphabetic()}\n+     * works); if disabled, order is unspecified (based on what JDK gives\n+     * us, which may be declaration order, but is not guaranteed).\n+     *<p>\n+     * Note that this is just the default behavior, and can be overridden by\n+     * explicit overrides in classes.\n+     *<p>\n+     * Feature is disabled by default.\n+     */\n+    SORT_PROPERTIES_ALPHABETICALLY(false)\n+\n+    ;\n+\n+    private final boolean _defaultState;\n+    \n+    private MapperFeature(boolean defaultState) {\n+        _defaultState = defaultState;\n+    }\n+    \n+    @Override\n+    public boolean enabledByDefault() { return _defaultState; }\n+\n+    @Override\n+    public int getMask() { return (1 << ordinal()); }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/Module.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/Module.java\n package com.fasterxml.jackson.databind;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n import com.fasterxml.jackson.databind.deser.Deserializers;\n import com.fasterxml.jackson.databind.deser.KeyDeserializers;\n          */\n         public TypeFactory getTypeFactory();\n         \n-        public boolean isEnabled(MapperConfig.Feature f);\n-        \n-        public boolean isEnabled(DeserializationConfig.Feature f);\n-\n-        public boolean isEnabled(SerializationConfig.Feature f);\n+        public boolean isEnabled(MapperFeature f);\n+        \n+        public boolean isEnabled(DeserializationFeature f);\n+\n+        public boolean isEnabled(SerializationFeature f);\n \n         public boolean isEnabled(JsonFactory.Feature f);\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.core.util.*;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.introspect.BasicClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n             }\n             \n             @Override\n-            public boolean isEnabled(MapperConfig.Feature f) {\n+            public boolean isEnabled(MapperFeature f) {\n                 return mapper.isEnabled(f);\n             }\n \n             @Override\n-            public boolean isEnabled(DeserializationConfig.Feature f) {\n+            public boolean isEnabled(DeserializationFeature f) {\n                 return mapper.isEnabled(f);\n             }\n             \n             @Override\n-            public boolean isEnabled(SerializationConfig.Feature f) {\n+            public boolean isEnabled(SerializationFeature f) {\n                 return mapper.isEnabled(f);\n             }\n \n      * Method for changing state of an on/off mapper feature for\n      * this mapper instance.\n      */\n-    public ObjectMapper configure(MapperConfig.Feature f, boolean state) {\n+    public ObjectMapper configure(MapperFeature f, boolean state) {\n         _serializationConfig = state ?\n                 _serializationConfig.with(f) : _serializationConfig.without(f);\n         _deserializationConfig = state ?\n      * Method for changing state of an on/off serialization feature for\n      * this object mapper.\n      */\n-    public ObjectMapper configure(SerializationConfig.Feature f, boolean state) {\n+    public ObjectMapper configure(SerializationFeature f, boolean state) {\n         _serializationConfig = state ?\n                 _serializationConfig.with(f) : _serializationConfig.without(f);\n         return this;\n      * Method for changing state of an on/off deserialization feature for\n      * this object mapper.\n      */\n-    public ObjectMapper configure(DeserializationConfig.Feature f, boolean state) {\n+    public ObjectMapper configure(DeserializationFeature f, boolean state) {\n         _deserializationConfig = state ?\n                 _deserializationConfig.with(f) : _deserializationConfig.without(f);\n         return this;\n      * Method for enabling specified {@link MapperConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper enable(MapperConfig.Feature... f) {\n+    public ObjectMapper enable(MapperFeature... f) {\n         _deserializationConfig = _deserializationConfig.with(f);\n         _serializationConfig = _serializationConfig.with(f);\n         return this;\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper disable(MapperConfig.Feature... f) {\n+    public ObjectMapper disable(MapperFeature... f) {\n         _deserializationConfig = _deserializationConfig.without(f);\n         _serializationConfig = _serializationConfig.without(f);\n         return this;\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper enable(DeserializationConfig.Feature feature) {\n+    public ObjectMapper enable(DeserializationFeature feature) {\n         _deserializationConfig = _deserializationConfig.with(feature);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper enable(DeserializationConfig.Feature first,\n-            DeserializationConfig.Feature... f) {\n+    public ObjectMapper enable(DeserializationFeature first,\n+            DeserializationFeature... f) {\n         _deserializationConfig = _deserializationConfig.with(first, f);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper disable(DeserializationConfig.Feature feature) {\n+    public ObjectMapper disable(DeserializationFeature feature) {\n         _deserializationConfig = _deserializationConfig.without(feature);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper disable(DeserializationConfig.Feature first,\n-            DeserializationConfig.Feature... f) {\n+    public ObjectMapper disable(DeserializationFeature first,\n+            DeserializationFeature... f) {\n         _deserializationConfig = _deserializationConfig.without(first, f);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} feature.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper enable(SerializationConfig.Feature f) {\n+    public ObjectMapper enable(SerializationFeature f) {\n         _serializationConfig = _serializationConfig.with(f);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper enable(SerializationConfig.Feature first,\n-            SerializationConfig.Feature... f) {\n+    public ObjectMapper enable(SerializationFeature first,\n+            SerializationFeature... f) {\n         _serializationConfig = _serializationConfig.with(first, f);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper disable(SerializationConfig.Feature f) {\n+    public ObjectMapper disable(SerializationFeature f) {\n         _serializationConfig = _serializationConfig.without(f);\n         return this;\n     }\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n-    public ObjectMapper disable(SerializationConfig.Feature first,\n-            SerializationConfig.Feature... f) {\n+    public ObjectMapper disable(SerializationFeature first,\n+            SerializationFeature... f) {\n         _serializationConfig = _serializationConfig.without(first, f);\n         return this;\n     }\n      * Method for checking whether given Mapper\n      * feature is enabled.\n      */\n-    public boolean isEnabled(MapperConfig.Feature f) {\n+    public boolean isEnabled(MapperFeature f) {\n         // ok to use either one, should be kept in sync\n         return _serializationConfig.isEnabled(f);\n     }\n      * Method for checking whether given serialization-specific\n      * feature is enabled.\n      */\n-    public boolean isEnabled(SerializationConfig.Feature f) {\n+    public boolean isEnabled(SerializationFeature f) {\n         return _serializationConfig.isEnabled(f);\n     }\n     \n      * Method for checking whether given deserialization-specific\n      * feature is enabled.\n      */\n-    public boolean isEnabled(DeserializationConfig.Feature f) {\n+    public boolean isEnabled(DeserializationFeature f) {\n         return _deserializationConfig.isEnabled(f);\n     }\n \n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n         SerializationConfig config = getSerializationConfig();\n-        if (config.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+        if (config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _writeCloseableValue(jgen, value, config);\n         } else {\n             _serializerProvider(config).serializeValue(jgen, value);\n-            if (config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+            if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             }\n         }\n     {\n         SerializationConfig config = getSerializationConfig();\n         _serializerProvider(config).serializeValue(jgen, rootNode);\n-        if (config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+        if (config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n             jgen.flush();\n         }\n     }\n      * specified feature enabled (compared to settings that this\n      * mapper instance has).\n      */\n-    public ObjectWriter writer(SerializationConfig.Feature feature) {\n+    public ObjectWriter writer(SerializationFeature feature) {\n         return new ObjectWriter(this, getSerializationConfig().with(feature));\n     }\n \n      * specified features enabled (compared to settings that this\n      * mapper instance has).\n      */\n-    public ObjectWriter writer(SerializationConfig.Feature first,\n-            SerializationConfig.Feature... other) {\n+    public ObjectWriter writer(SerializationFeature first,\n+            SerializationFeature... other) {\n         return new ObjectWriter(this, getSerializationConfig().with(first, other));\n     }\n     \n      * Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader(DeserializationConfig.Feature feature) {\n+    public ObjectReader reader(DeserializationFeature feature) {\n         return new ObjectReader(this, getDeserializationConfig().with(feature));\n     }\n \n      * Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader(DeserializationConfig.Feature first,\n-            DeserializationConfig.Feature... other) {\n+    public ObjectReader reader(DeserializationFeature first,\n+            DeserializationFeature... other) {\n         return new ObjectReader(this, getDeserializationConfig().with(first, other));\n     }\n     \n         try {\n             // inlined 'writeValue' with minor changes:\n             // first: disable wrapping when writing\n-            SerializationConfig config = getSerializationConfig().without(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+            SerializationConfig config = getSerializationConfig().without(SerializationFeature.WRAP_ROOT_VALUE);\n             // no need to check for closing of TokenBuffer\n             _serializerProvider(config).serializeValue(buf, fromValue);\n \n     {\n         SerializationConfig cfg = getSerializationConfig();\n         // [JACKSON-96]: allow enabling pretty printing for ObjectMapper directly\n-        if (cfg.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT)) {\n+        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n             jgen.useDefaultPrettyPrinter();\n         }\n         // [JACKSON-282]: consider Closeable\n-        if (cfg.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _configAndWriteCloseable(jgen, value, cfg);\n             return;\n         }\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n         SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n-        if (cfg.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT)) {\n+        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n             jgen.useDefaultPrettyPrinter();\n         }\n         // [JACKSON-282]: consider Closeable\n-        if (cfg.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+        if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _configAndWriteCloseable(jgen, value, cfg);\n             return;\n         }\n         Closeable toClose = (Closeable) value;\n         try {\n             _serializerProvider(cfg).serializeValue(jgen, value);\n-            if (cfg.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+            if (cfg.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             }\n             Closeable tmpToClose = toClose;\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n \n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.NullNode;\n import com.fasterxml.jackson.databind.node.TreeTraversingParser;\n      * Method for constructing a new reader instance that is configured\n      * with specified feature enabled.\n      */\n-    public ObjectReader with(DeserializationConfig.Feature feature) \n+    public ObjectReader with(DeserializationFeature feature) \n     {\n         DeserializationConfig newConfig = _config.with(feature);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n      * Method for constructing a new reader instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectReader with(DeserializationConfig.Feature first,\n-            DeserializationConfig.Feature... other)\n+    public ObjectReader with(DeserializationFeature first,\n+            DeserializationFeature... other)\n     {\n         DeserializationConfig newConfig = _config.with(first, other);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n      * Method for constructing a new reader instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectReader withFeatures(DeserializationConfig.Feature... features)\n+    public ObjectReader withFeatures(DeserializationFeature... features)\n     {\n         DeserializationConfig newConfig = _config.withFeatures(features);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n      * Method for constructing a new reader instance that is configured\n      * with specified feature disabled.\n      */\n-    public ObjectReader without(DeserializationConfig.Feature feature) \n+    public ObjectReader without(DeserializationFeature feature) \n     {\n         DeserializationConfig newConfig = _config.without(feature);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n      * Method for constructing a new reader instance that is configured\n      * with specified features disabled.\n      */\n-    public ObjectReader without(DeserializationConfig.Feature first,\n-            DeserializationConfig.Feature... other)\n+    public ObjectReader without(DeserializationFeature first,\n+            DeserializationFeature... other)\n     {\n         DeserializationConfig newConfig = _config.without(first, other);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n      * Method for constructing a new reader instance that is configured\n      * with specified features disabled.\n      */\n-    public ObjectReader withoutFeatures(DeserializationConfig.Feature... features)\n+    public ObjectReader withoutFeatures(DeserializationFeature... features)\n     {\n         DeserializationConfig newConfig = _config.withoutFeatures(features);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n     /**********************************************************\n      */\n     \n-    public boolean isEnabled(DeserializationConfig.Feature f) {\n+    public boolean isEnabled(DeserializationFeature f) {\n         return _config.isEnabled(f);\n     }\n \n-    public boolean isEnabled(MapperConfig.Feature f) {\n+    public boolean isEnabled(MapperFeature f) {\n         return _config.isEnabled(f);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n import com.fasterxml.jackson.databind.ser.SerializerFactory;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n      * Method for constructing a new instance that is configured\n      * with specified feature enabled.\n      */\n-    public ObjectWriter with(SerializationConfig.Feature feature) \n+    public ObjectWriter with(SerializationFeature feature) \n     {\n         SerializationConfig newConfig = _config.with(feature);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n      * Method for constructing a new instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectWriter with(SerializationConfig.Feature first,\n-            SerializationConfig.Feature... other)\n+    public ObjectWriter with(SerializationFeature first,\n+            SerializationFeature... other)\n     {\n         SerializationConfig newConfig = _config.with(first, other);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n      * Method for constructing a new instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectWriter withFeatures(SerializationConfig.Feature... features)\n+    public ObjectWriter withFeatures(SerializationFeature... features)\n     {\n         SerializationConfig newConfig = _config.withFeatures(features);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n      * Method for constructing a new instance that is configured\n      * with specified feature enabled.\n      */\n-    public ObjectWriter without(SerializationConfig.Feature feature) \n+    public ObjectWriter without(SerializationFeature feature) \n     {\n         SerializationConfig newConfig = _config.without(feature);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n      * Method for constructing a new instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectWriter without(SerializationConfig.Feature first,\n-            SerializationConfig.Feature... other)\n+    public ObjectWriter without(SerializationFeature first,\n+            SerializationFeature... other)\n     {\n         SerializationConfig newConfig = _config.without(first, other);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n      * Method for constructing a new instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectWriter withoutFeatures(SerializationConfig.Feature... features)\n+    public ObjectWriter withoutFeatures(SerializationFeature... features)\n     {\n         SerializationConfig newConfig = _config.withoutFeatures(features);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n     /**********************************************************\n      */\n \n-    public boolean isEnabled(SerializationConfig.Feature f) {\n+    public boolean isEnabled(SerializationFeature f) {\n         return _config.isEnabled(f);\n     }\n \n-    public boolean isEnabled(MapperConfig.Feature f) {\n+    public boolean isEnabled(MapperFeature f) {\n         return _config.isEnabled(f);\n     }\n \n     public void writeValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonGenerationException, JsonMappingException\n     {\n-        if (_config.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+        if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _writeCloseableValue(jgen, value, _config);\n         } else {\n             if (_rootType == null) {\n             } else {\n                 _serializerProvider(_config).serializeValue(jgen, value, _rootType);\n             }\n-            if (_config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+            if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             }\n         }\n         if (_prettyPrinter != null) {\n             PrettyPrinter pp = _prettyPrinter;\n             jgen.setPrettyPrinter((pp == NULL_PRETTY_PRINTER) ? null : pp);\n-        } else if (_config.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT)) {\n+        } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n             jgen.useDefaultPrettyPrinter();\n         }\n         // [JACKSON-520]: add support for pass-through schema:\n             jgen.setSchema(_schema);\n         }\n         // [JACKSON-282]: consider Closeable\n-        if (_config.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+        if (_config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _configAndWriteCloseable(jgen, value, _config);\n             return;\n         }\n             } else {\n                 _serializerProvider(cfg).serializeValue(jgen, value, _rootType);\n             }\n-            if (_config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+            if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 jgen.flush();\n             }\n             Closeable tmpToClose = toClose;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.databind.cfg.ConfigFeature;\n+\n+/**\n+ * Enumeration that defines simple on/off features that affect\n+ * the way Java objects are serialized.\n+ *<p>\n+ * Note that features can be set both through\n+ * {@link ObjectMapper} (as sort of defaults) and through\n+ * {@link ObjectWriter}.\n+ * In first case these defaults must follow \"config-then-use\" patterns\n+ * (i.e. defined once, not changed afterwards); all per-call\n+ * changes must be done using {@link ObjectWriter}.\n+ */\n+public enum SerializationFeature implements ConfigFeature\n+{\n+    /*\n+    /******************************************************\n+    /* Generic output features\n+    /******************************************************\n+     */\n+    \n+    /**\n+     * SerializationFeature that can be enabled to make root value (usually JSON\n+     * Object but can be any type) wrapped within a single property\n+     * JSON object, where key as the \"root name\", as determined by\n+     * annotation introspector (esp. for JAXB that uses\n+     * <code>@XmlRootElement.name</code>) or fallback (non-qualified\n+     * class name).\n+     * SerializationFeature is mostly intended for JAXB compatibility.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    WRAP_ROOT_VALUE(false),\n+\n+    /**\n+     * SerializationFeature that allows enabling (or disabling) indentation\n+     * for the underlying generator, using the default pretty\n+     * printer (see\n+     * {@link com.fasterxml.jackson.core.JsonGenerator#useDefaultPrettyPrinter}\n+     * for details).\n+     *<p>\n+     * Note that this only affects cases where\n+     * {@link com.fasterxml.jackson.core.JsonGenerator}\n+     * is constructed implicitly by ObjectMapper: if explicit\n+     * generator is passed, its configuration is not changed.\n+     *<p>\n+     * Also note that if you want to configure details of indentation,\n+     * you need to directly configure the generator: there is a\n+     * method to use any <code>PrettyPrinter</code> instance.\n+     * This feature will only allow using the default implementation.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    INDENT_OUTPUT(false),\n+    \n+    /*\n+    /******************************************************\n+    /*  Error handling features\n+    /******************************************************\n+     */\n+    \n+    /**\n+     * SerializationFeature that determines what happens when no accessors are\n+     * found for a type (and there are no annotations to indicate\n+     * it is meant to be serialized). If enabled (default), an\n+     * exception is thrown to indicate these as non-serializable\n+     * types; if disabled, they are serialized as empty Objects,\n+     * i.e. without any properties.\n+     *<p>\n+     * Note that empty types that this feature has only effect on\n+     * those \"empty\" beans that do not have any recognized annotations\n+     * (like <code>@JsonSerialize</code>): ones that do have annotations\n+     * do not result in an exception being thrown.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    FAIL_ON_EMPTY_BEANS(true),\n+\n+    /**\n+     * SerializationFeature that determines whether Jackson code should catch\n+     * and wrap {@link Exception}s (but never {@link Error}s!)\n+     * to add additional information about\n+     * location (within input) of problem or not. If enabled,\n+     * most exceptions will be caught and re-thrown (exception\n+     * specifically being that {@link java.io.IOException}s may be passed\n+     * as is, since they are declared as throwable); this can be\n+     * convenient both in that all exceptions will be checked and\n+     * declared, and so there is more contextual information.\n+     * However, sometimes calling application may just want \"raw\"\n+     * unchecked exceptions passed as is.\n+     *<p>\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    WRAP_EXCEPTIONS(true),\n+\n+    /*\n+    /******************************************************\n+    /* Output life cycle features\n+    /******************************************************\n+     */\n+    \n+     /**\n+      * SerializationFeature that determines whether <code>close</code> method of\n+      * serialized <b>root level</b> objects (ones for which <code>ObjectMapper</code>'s\n+      * writeValue() (or equivalent) method is called)\n+      * that implement {@link java.io.Closeable} \n+      * is called after serialization or not. If enabled, <b>close()</b> will\n+      * be called after serialization completes (whether succesfully, or\n+      * due to an error manifested by an exception being thrown). You can\n+      * think of this as sort of \"finally\" processing.\n+      *<p>\n+      * NOTE: only affects behavior with <b>root</b> objects, and not other\n+      * objects reachable from the root object. Put another way, only one\n+      * call will be made for each 'writeValue' call.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+      */\n+    CLOSE_CLOSEABLE(false),\n+\n+    /**\n+     * SerializationFeature that determines whether <code>JsonGenerator.flush()</code> is\n+     * called after <code>writeValue()</code> method <b>that takes JsonGenerator\n+     * as an argument</b> completes (i.e. does NOT affect methods\n+     * that use other destinations); same for methods in {@link ObjectWriter}.\n+     * This usually makes sense; but there are cases where flushing\n+     * should not be forced: for example when underlying stream is\n+     * compressing and flush() causes compression state to be flushed\n+     * (which occurs with some compression codecs).\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    FLUSH_AFTER_WRITE_VALUE(true),\n+     \n+    /*\n+    /******************************************************\n+    /* Data type - specific serialization configuration\n+    /******************************************************\n+     */\n+\n+    /**\n+     * SerializationFeature that determines whether {@link java.util.Date} values\n+     * (and Date-based things like {@link java.util.Calendar}s) are to be\n+     * serialized as numeric timestamps (true; the default),\n+     * or as something else (usually textual representation).\n+     * If textual representation is used, the actual format is\n+     * one returned by a call to {@link #getDateFormat}.\n+     *<p>\n+     * Note: whether this feature affects handling of other date-related\n+     * types depend on handlers of those types, although ideally they\n+     * should use this feature\n+     *<p>\n+     * Note: whether {@link java.util.Map} keys are serialized as Strings\n+     * or not is controlled using {@link #WRITE_DATE_KEYS_AS_TIMESTAMPS}.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    WRITE_DATES_AS_TIMESTAMPS(true),\n+\n+    /**\n+     * SerializationFeature that determines whether {@link java.util.Date}s\n+     * (and sub-types) used as {@link java.util.Map} keys are serialized\n+     * as timestamps or not (if not, will be serialized as textual\n+     * values).\n+     *<p>\n+     * Default value is 'false', meaning that Date-valued Map keys are serialized\n+     * as textual (ISO-8601) values.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    WRITE_DATE_KEYS_AS_TIMESTAMPS(false),\n+\n+    /**\n+     * SerializationFeature that determines how type <code>char[]</code> is serialized:\n+     * when enabled, will be serialized as an explict JSON array (with\n+     * single-character Strings as values); when disabled, defaults to\n+     * serializing them as Strings (which is more compact).\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS(false),\n+\n+    /**\n+     * SerializationFeature that determines standard serialization mechanism used for\n+     * Enum values: if enabled, return value of <code>Enum.toString()</code>\n+     * is used; if disabled, return value of <code>Enum.name()</code> is used.\n+     *<p>\n+     * Note: this feature should usually have same value\n+     * as {@link DeserializationConfig.DeserializationFeature#READ_ENUMS_USING_TO_STRING}.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    WRITE_ENUMS_USING_TO_STRING(false),\n+\n+    /**\n+     * SerializationFeature that determines whethere Java Enum values are serialized\n+     * as numbers (true), or textual values (false). If textual values are\n+     * used, other settings are also considered.\n+     * If this feature is enabled,\n+     *  return value of <code>Enum.ordinal()</code>\n+     * (an integer) will be used as the serialization.\n+     *<p>\n+     * Note that this feature has precedence over {@link #WRITE_ENUMS_USING_TO_STRING},\n+     * which is only considered if this feature is set to false.\n+     *<p>\n+     * SerializationFeature is disabled by default.\n+     */\n+    WRITE_ENUMS_USING_INDEX(false),\n+    \n+    /**\n+     * SerializationFeature that determines whether Map entries with null values are\n+     * to be serialized (true) or not (false).\n+     *<p>\n+     * For further details, check out [JACKSON-314]\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    WRITE_NULL_MAP_VALUES(true),\n+\n+    /**\n+     * SerializationFeature that determines whether Container properties (POJO properties\n+     * with declared value of Collection or array; i.e. things that produce JSON\n+     * arrays) that are empty (have no elements)\n+     * will be serialized as empty JSON arrays (true), or suppressed from output (false).\n+     *<p>\n+     * Note that this does not change behavior of {@link java.util.Map}s, or\n+     * \"Collection-like\" types.\n+     *<p>\n+     * SerializationFeature is enabled by default.\n+     */\n+    WRITE_EMPTY_JSON_ARRAYS(true)\n+    \n+        ;\n+\n+    private final boolean _defaultState;\n+    \n+    private SerializationFeature(boolean defaultState) {\n+        _defaultState = defaultState;\n+    }\n+    \n+    @Override\n+    public boolean enabledByDefault() { return _defaultState; }\n+\n+    @Override\n+    public int getMask() { return (1 << ordinal()); }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.annotation.NoClass;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n             String rootName = _config.getRootName();\n             if (rootName == null) { // not explicitly specified\n                 // [JACKSON-163]\n-                wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+                wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n                 if (wrap) {\n                     jgen.writeStartObject();\n                     jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n             // root value, not reached via property:\n             ser = findTypedValueSerializer(rootType, true, null);\n             // [JACKSON-163]\n-            wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n             if (wrap) {\n                 jgen.writeStartObject();\n                 jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n      *  getConfig().isEnabled(feature);\n      *</pre>\n      */\n-    public final boolean isEnabled(MapperConfig.Feature feature) {\n+    public final boolean isEnabled(MapperFeature feature) {\n         return _config.isEnabled(feature);\n     }\n \n      *  getConfig().isEnabled(feature);\n      *</pre>\n      */\n-    public final boolean isEnabled(SerializationConfig.Feature feature) {\n+    public final boolean isEnabled(SerializationFeature feature) {\n         return _config.isEnabled(feature);\n     }\n \n         throws IOException, JsonProcessingException\n     {\n         // [JACKSON-87]: Support both numeric timestamps and textual\n-        if (isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+        if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n             jgen.writeNumber(timestamp);\n         } else {\n             if (_dateFormat == null) {\n         throws IOException, JsonProcessingException\n     {\n         // [JACKSON-87]: Support both numeric timestamps and textual\n-        if (isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+        if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n             jgen.writeNumber(date.getTime());\n         } else {\n             if (_dateFormat == null) {\n \n     /**\n      * Method that will handle serialization of Dates used as {@link java.util.Map} keys,\n-     * based on {@link SerializationConfig.Feature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n+     * based on {@link SerializationFeature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n      * value (and if using textual representation, configured date format)\n      */\n     public void defaultSerializeDateKey(long timestamp, JsonGenerator jgen)\n         throws IOException, JsonProcessingException\n     {\n-        if (isEnabled(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n+        if (isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n             jgen.writeFieldName(String.valueOf(timestamp));\n         } else {\n             if (_dateFormat == null) {\n \n     /**\n      * Method that will handle serialization of Dates used as {@link java.util.Map} keys,\n-     * based on {@link SerializationConfig.Feature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n+     * based on {@link SerializationFeature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n      * value (and if using textual representation, configured date format)\n      */\n     public void defaultSerializeDateKey(Date date, JsonGenerator jgen)\n         throws IOException, JsonProcessingException\n     {\n-        if (isEnabled(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n+        if (isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n             jgen.writeFieldName(String.valueOf(date.getTime()));\n         } else {\n             if (_dateFormat == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.PropertyAccessor;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/ConfigFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/ConfigFeature.java\n package com.fasterxml.jackson.databind.cfg;\n \n /**\n- * Interface that actual Feature enumerations used by\n+ * Interface that actual SerializationFeature enumerations used by\n  * {@link MapperConfig} implementations must implement.\n  * Necessary since enums can not be extended using normal\n  * inheritance, but can implement interfaces\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/DatabindVersion.java\n+package com.fasterxml.jackson.databind.cfg;\n+\n+import com.fasterxml.jackson.core.util.VersionUtil;\n+\n+/**\n+ * Helper class used for finding and caching version information\n+ * for the databind bundle.\n+ * NOTE: although defined as public, should NOT be accessed directly\n+ * from outside databind bundle itself.\n+ */\n+public class DatabindVersion extends VersionUtil\n+{\n+    public final static DatabindVersion instance = new DatabindVersion();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializationConfig.java\n+package com.fasterxml.jackson.databind.cfg;\n+\n+import java.text.DateFormat;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.BeanDescription;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n+import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n+import com.fasterxml.jackson.databind.introspect.NopAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.LinkedNode;\n+\n+/**\n+ * Object that contains baseline configuration for deserialization\n+ * process. An instance is owned by {@link ObjectMapper}, which\n+ * passes an immutable instance to be used for deserialization process.\n+ *<p>\n+ * Note that instances are considered immutable and as such no copies\n+ * should need to be created (there are some implementation details\n+ * with respect to mix-in annotations; where this is guaranteed as\n+ * long as caller follow \"copy-then-use\" pattern)\n+ */\n+public final class DeserializationConfig\n+    extends MapperConfigBase<DeserializationFeature, DeserializationConfig>\n+{\n+    /**\n+     * Set of features enabled; actual type (kind of features)\n+     * depends on sub-classes.\n+     */\n+    protected final int _deserFeatures;\n+\n+    /**\n+     * Linked list that contains all registered problem handlers.\n+     * Implementation as front-added linked list allows for sharing\n+     * of the list (tail) without copying the list.\n+     */\n+    protected final LinkedNode<DeserializationProblemHandler> _problemHandlers;\n+    \n+    /**\n+     * Factory used for constructing {@link com.fasterxml.jackson.core.JsonNode} instances.\n+     */\n+    protected final JsonNodeFactory _nodeFactory;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used by ObjectMapper to create default configuration object instance.\n+     */\n+    public DeserializationConfig(BaseSettings base,\n+            SubtypeResolver str, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(base, str, mixins);\n+        _deserFeatures = collectFeatureDefaults(DeserializationFeature.class);\n+        _nodeFactory = JsonNodeFactory.instance;\n+        _problemHandlers = null;\n+    }\n+\n+    /**\n+     * Copy constructor used to create a non-shared instance with given mix-in\n+     * annotation definitions and subtype resolver.\n+     */\n+    private DeserializationConfig(DeserializationConfig src, SubtypeResolver str)\n+    {\n+        super(src, str);\n+        _deserFeatures = src._deserFeatures;\n+        _nodeFactory = src._nodeFactory;\n+        _problemHandlers = src._problemHandlers;\n+    }\n+\n+    private DeserializationConfig(DeserializationConfig src,\n+            int mapperFeatures, int deserFeatures)\n+    {\n+        super(src, mapperFeatures);\n+        _deserFeatures = deserFeatures;\n+        _nodeFactory = src._nodeFactory;\n+        _problemHandlers = src._problemHandlers;\n+    }\n+    \n+    private DeserializationConfig(DeserializationConfig src, BaseSettings base)\n+    {\n+        super(src, base);\n+        _deserFeatures = src._deserFeatures;\n+        _nodeFactory = src._nodeFactory;\n+        _problemHandlers = src._problemHandlers;\n+    }\n+    \n+    private DeserializationConfig(DeserializationConfig src, JsonNodeFactory f)\n+    {\n+        super(src);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = f;\n+    }\n+\n+    private DeserializationConfig(DeserializationConfig src,\n+            LinkedNode<DeserializationProblemHandler> problemHandlers)\n+    {\n+        super(src);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+    }\n+\n+    private DeserializationConfig(DeserializationConfig src, String rootName)\n+    {\n+        super(src, rootName);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+    }\n+\n+    private DeserializationConfig(DeserializationConfig src, Class<?> view)\n+    {\n+        super(src, view);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, factory methods from MapperConfig\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public DeserializationConfig with(MapperFeature... features)\n+    {\n+        int newMapperFlags = _mapperFeatures;\n+        for (MapperFeature f : features) {\n+            newMapperFlags |= f.getMask();\n+        }\n+        return (newMapperFlags == _mapperFeatures) ? this :\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+    }\n+\n+    @Override\n+    public DeserializationConfig without(MapperFeature... features)\n+    {\n+        int newMapperFlags = _mapperFeatures;\n+        for (MapperFeature f : features) {\n+             newMapperFlags &= ~f.getMask();\n+        }\n+        return (newMapperFlags == _mapperFeatures) ? this :\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withClassIntrospector(ClassIntrospector ci) {\n+        return _withBase(_base.withClassIntrospector(ci));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return _withBase(_base.withAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withVisibilityChecker(VisibilityChecker<?> vc) {\n+        return _withBase(_base.withVisibilityChecker(vc));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n+        return _withBase( _base.withVisibility(forMethod, visibility));\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withTypeResolverBuilder(TypeResolverBuilder<?> trb) {\n+        return _withBase(_base.withTypeResolverBuilder(trb));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withSubtypeResolver(SubtypeResolver str) {\n+        return (_subtypeResolver == str) ? this : new DeserializationConfig(this, str);\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n+        return _withBase(_base.withPropertyNamingStrategy(pns));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withRootName(String rootName) {\n+        if (rootName == null) {\n+            if (_rootName == null) {\n+                return this;\n+            }\n+        } else if (rootName.equals(_rootName)) {\n+            return this;\n+        }\n+        return new DeserializationConfig(this, rootName);\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withTypeFactory(TypeFactory tf) {\n+        return _withBase( _base.withTypeFactory(tf));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withDateFormat(DateFormat df) {\n+        return _withBase(_base.withDateFormat(df));\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withHandlerInstantiator(HandlerInstantiator hi) {\n+        return _withBase(_base.withHandlerInstantiator(hi));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return _withBase(_base.withInsertedAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return _withBase(_base.withAppendedAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withView(Class<?> view) {\n+        return (_view == view) ? this : new DeserializationConfig(this, view);\n+    }\n+    \n+    private final DeserializationConfig _withBase(BaseSettings newBase) {\n+        return (_base == newBase) ? this : new DeserializationConfig(this, newBase);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, deserialization-specific factory methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fluent factory method that will construct a new instance with\n+     * specified {@link JsonNodeFactory}\n+     */\n+    public DeserializationConfig withNodeFactory(JsonNodeFactory f) {\n+        if (_nodeFactory == f) {\n+            return this;\n+        }\n+        return new DeserializationConfig(this, f);\n+    }\n+\n+    /**\n+     * Method that can be used to add a handler that can (try to)\n+     * resolve non-fatal deserialization problems.\n+     */\n+    public DeserializationConfig withHandler(DeserializationProblemHandler h)\n+    {\n+        // Sanity check: let's prevent adding same handler multiple times\n+        if (LinkedNode.contains(_problemHandlers, h)) {\n+            return this;\n+        }\n+        return new DeserializationConfig(this,\n+                new LinkedNode<DeserializationProblemHandler>(h, _problemHandlers));\n+    }\n+\n+    /**\n+     * Method for removing all configured problem handlers; usually done to replace\n+     * existing handler(s) with different one(s)\n+     */\n+    public DeserializationConfig withNoProblemHandlers() {\n+        if (_problemHandlers == null) {\n+            return this;\n+        }\n+        return new DeserializationConfig(this,\n+                (LinkedNode<DeserializationProblemHandler>) null);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig with(DeserializationFeature feature)\n+    {\n+        int newDeserFeatures = (_deserFeatures | feature.getMask());\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig with(DeserializationFeature first,\n+            DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures | first.getMask();\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures |= f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig withFeatures(DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures;\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures |= f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature disabled.\n+     */\n+    public DeserializationConfig without(DeserializationFeature feature)\n+    {\n+        int newDeserFeatures = _deserFeatures & ~feature.getMask();\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public DeserializationConfig without(DeserializationFeature first,\n+            DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures & ~first.getMask();\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures &= ~f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public DeserializationConfig withoutFeatures(DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures;\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures &= ~f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* MapperConfig implementation\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for getting {@link AnnotationIntrospector} configured\n+     * to introspect annotation values used for configuration.\n+     */\n+    @Override\n+    public AnnotationIntrospector getAnnotationIntrospector()\n+    {\n+        /* 29-Jul-2009, tatu: it's now possible to disable use of\n+         *   annotations; can be done using \"no-op\" introspector\n+         */\n+        if (isEnabled(MapperFeature.USE_ANNOTATIONS)) {\n+            return super.getAnnotationIntrospector();\n+        }\n+        return NopAnnotationIntrospector.instance;\n+    }\n+\n+    @Override\n+    public boolean useRootWrapping()\n+    {\n+        if (_rootName != null) { // empty String disables wrapping; non-empty enables\n+            return (_rootName.length() > 0);\n+        }\n+        return isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+    }\n+    \n+    /**\n+     * Accessor for getting bean description that only contains class\n+     * annotations: useful if no getter/setter/creator information is needed.\n+     */\n+    @Override\n+    public BeanDescription introspectClassAnnotations(JavaType type) {\n+        return getClassIntrospector().forClassAnnotations(this, type, this);\n+    }\n+\n+    /**\n+     * Accessor for getting bean description that only contains immediate class\n+     * annotations: ones from the class, and its direct mix-in, if any, but\n+     * not from super types.\n+     */\n+    @Override\n+    public BeanDescription introspectDirectClassAnnotations(JavaType type) {\n+        return getClassIntrospector().forDirectClassAnnotations(this, type, this);\n+    }\n+\n+    @Override\n+    public VisibilityChecker<?> getDefaultVisibilityChecker()\n+    {\n+        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n+        if (!isEnabled(MapperFeature.AUTO_DETECT_SETTERS)) {\n+            vchecker = vchecker.withSetterVisibility(Visibility.NONE);\n+        }\n+        if (!isEnabled(MapperFeature.AUTO_DETECT_CREATORS)) {\n+            vchecker = vchecker.withCreatorVisibility(Visibility.NONE);\n+        }\n+        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n+            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n+        }\n+        return vchecker;\n+    }\n+\n+    public final boolean isEnabled(DeserializationFeature f) {\n+        return (_deserFeatures & f.getMask()) != 0;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Other configuration\n+    /**********************************************************\n+     */\n+\n+    public final int getDeserializationFeatures() {\n+        return _deserFeatures;\n+    }\n+    \n+    /**\n+     * Method for getting head of the problem handler chain. May be null,\n+     * if no handlers have been added.\n+     */\n+    public LinkedNode<DeserializationProblemHandler> getProblemHandlers() {\n+        return _problemHandlers;\n+    }\n+    \n+    /**\n+     * Method called during deserialization if Base64 encoded content\n+     * needs to be decoded. Default version just returns default Jackson\n+     * uses, which is modified-mime which does not add linefeeds (because\n+     * those would have to be escaped in JSON strings).\n+     */\n+    public Base64Variant getBase64Variant() {\n+        return Base64Variants.getDefaultVariant();\n+    }\n+\n+    public final JsonNodeFactory getNodeFactory() {\n+        return _nodeFactory;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Introspection methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will introspect full bean properties for the purpose\n+     * of building a bean deserializer\n+     *\n+     * @param type Type of class to be introspected\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends BeanDescription> T introspect(JavaType type) {\n+        return (T) getClassIntrospector().forDeserialization(this, type, this);\n+    }\n+\n+    /**\n+     * Method that will introspect subset of bean properties needed to\n+     * construct bean instance.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends BeanDescription> T introspectForCreation(JavaType type) {\n+        return (T) getClassIntrospector().forCreation(this, type, this);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n+package com.fasterxml.jackson.databind.cfg;\n+\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.KeyDeserializer;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+\n+/**\n+ * Helper class used for handling details of creating handler instances (things\n+ * like {@link JsonSerializer}s, {@link JsonDeserializer}s, various type\n+ * handlers) of specific types. Actual handler type has been resolved at this\n+ * point, so instantiator is strictly responsible for providing a configured\n+ * instance by constructing and configuring a new instance, or possibly by\n+ * recycling a shared instance. One use case is that of allowing\n+ * dependency injection, which would otherwise be difficult to do.\n+ *<p>\n+ * Custom instances are allowed to return null to indicate that caller should\n+ * use the default instantiation handling (which just means calling no-argument\n+ * constructor via reflection).\n+ *<p>\n+ * Care has to be taken to ensure that if instance returned is shared, it will\n+ * be thread-safe; caller will not synchronize access to returned instances.\n+ */\n+public abstract class HandlerInstantiator\n+{\n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to get an instance of deserializer of specified type.\n+     * \n+     * @param config Deserialization configuration in effect\n+     * @param annotated Element (Class, Method, Field, constructor parameter) that\n+     *    had annotation defining class of deserializer to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param deserClass Class of deserializer instance to return\n+     * \n+     * @return Deserializer instance to use\n+     */\n+    public abstract JsonDeserializer<?> deserializerInstance(DeserializationConfig config,\n+            Annotated annotated, Class<?> deserClass);\n+\n+    /**\n+     * Method called to get an instance of key deserializer of specified type.\n+     * \n+     * @param config Deserialization configuration in effect\n+     * @param annotated Element (Class, Method, Field, constructor parameter) that\n+     *    had annotation defining class of key deserializer to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param keyDeserClass Class of key deserializer instance to return\n+     * \n+     * @return Key deserializer instance to use\n+     */\n+    public abstract KeyDeserializer keyDeserializerInstance(DeserializationConfig config,\n+            Annotated annotated, Class<?> keyDeserClass);\n+    \n+    /**\n+     * Method called to get an instance of serializer of specified type.\n+     * \n+     * @param config Serialization configuration in effect\n+     * @param annotated Element (Class, Method, Field) that\n+     *    had annotation defining class of serializer to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param serClass Class of serializer instance to return\n+     * \n+     * @return Serializer instance to use\n+     */\n+    public abstract JsonSerializer<?> serializerInstance(SerializationConfig config,\n+            Annotated annotated, Class<?> serClass);\n+\n+    /**\n+     * Method called to get an instance of TypeResolverBuilder of specified type.\n+     * \n+     * @param config Mapper configuration in effect (either SerializationConfig or\n+     *   DeserializationConfig, depending on when instance is being constructed)\n+     * @param annotated annotated Element (Class, Method, Field) that\n+     *    had annotation defining class of builder to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param builderClass Class of builder instance to return\n+     * \n+     * @return TypeResolverBuilder instance to use\n+     */\n+    public abstract TypeResolverBuilder<?> typeResolverBuilderInstance(MapperConfig<?> config,\n+            Annotated annotated, Class<?> builderClass);\n+\n+    /**\n+     * Method called to get an instance of TypeIdResolver of specified type.\n+     * \n+     * @param config Mapper configuration in effect (either SerializationConfig or\n+     *   DeserializationConfig, depending on when instance is being constructed)\n+     * @param annotated annotated Element (Class, Method, Field) that\n+     *    had annotation defining class of resolver to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param resolverClass Class of resolver instance to return\n+     * \n+     * @return TypeResolverBuilder instance to use\n+     */\n+    public abstract TypeIdResolver typeIdResolverInstance(MapperConfig<?> config,\n+            Annotated annotated, Class<?> resolverClass);\n+\n+    /**\n+     * Method called to construct an instance of ValueInstantiator of specified type.\n+     */\n+    public ValueInstantiator valueInstantiatorInstance(MapperConfig<?> config,\n+            Annotated annotated, Class<?> resolverClass) {\n+        return null;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n  * accessors to mode-independent configuration settings\n  * and such.\n  * In addition, shared features are defined\n- * in {@link MapperConfig.Feature}\n+ * in {@link MapperFeature}\n  *<p>\n  * Small part of implementation is included here by aggregating\n  * {@link BaseSettings} instance that contains configuration\n     implements ClassIntrospector.MixInResolver\n {\n     /**\n-     * Enumeration that defines simple on/off features to set\n-     * for {@link ObjectMapper}, and accessible (but NOT mutable!)\n-     * via {@link SerializationConfig} and {@link DeserializationConfig}.\n-     * Note that in addition to being only mutable via {@link ObjectMapper},\n-     * changes only take effect when done <b>before any serialization or\n-     * deserialization</b> calls -- that is, caller must follow\n-     * \"configure-then-use\" pattern.\n-     */\n-    public enum Feature implements ConfigFeature\n-    {\n-        /*\n-        /******************************************************\n-        /*  Introspection features\n-        /******************************************************\n-         */\n-        \n-        /**\n-         * Feature that determines whether annotation introspection\n-         * is used for configuration; if enabled, configured\n-         * {@link AnnotationIntrospector} will be used: if disabled,\n-         * no annotations are considered.\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-        USE_ANNOTATIONS(true),\n-\n-        /**\n-         * Feature that determines whether \"creator\" methods are\n-         * automatically detected by consider public constructors,\n-         * and static single argument methods with name \"valueOf\".\n-         * If disabled, only methods explicitly annotated are considered\n-         * creator methods (except for the no-arg default constructor which\n-         * is always considered a factory method).\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<P>\n-         * Feature is enabled by default.\n-         */\n-        AUTO_DETECT_CREATORS(true),\n-        \n-        /**\n-         * Feature that determines whether non-static fields are recognized as\n-         * properties.\n-         * If yes, then all public member fields\n-         * are considered as properties. If disabled, only fields explicitly\n-         * annotated are considered property fields.\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-         AUTO_DETECT_FIELDS(true),\n-        \n-        /**\n-         * Feature that determines whether regualr \"getter\" methods are\n-         * automatically detected based on standard Bean naming convention\n-         * or not. If yes, then all public zero-argument methods that\n-         * start with prefix \"get\" \n-         * are considered as getters.\n-         * If disabled, only methods explicitly  annotated are considered getters.\n-         *<p>\n-         * Note that since version 1.3, this does <b>NOT</b> include\n-         * \"is getters\" (see {@link #AUTO_DETECT_IS_GETTERS} for details)\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-        AUTO_DETECT_GETTERS(true),\n-\n-        /**\n-         * Feature that determines whether \"is getter\" methods are\n-         * automatically detected based on standard Bean naming convention\n-         * or not. If yes, then all public zero-argument methods that\n-         * start with prefix \"is\", and whose return type is boolean\n-         * are considered as \"is getters\".\n-         * If disabled, only methods explicitly annotated are considered getters.\n-         *<p>\n-         * Note that this feature has lower precedence than per-class\n-         * annotations, and is only used if there isn't more granular\n-         * configuration available.\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-        AUTO_DETECT_IS_GETTERS(true),\n-\n-         /**\n-          * Feature that determines whether \"setter\" methods are\n-          * automatically detected based on standard Bean naming convention\n-          * or not. If yes, then all public one-argument methods that\n-          * start with prefix \"set\"\n-          * are considered setters. If disabled, only methods explicitly\n-          * annotated are considered setters.\n-          *<p>\n-          * Note that this feature has lower precedence than per-class\n-          * annotations, and is only used if there isn't more granular\n-          * configuration available.\n-          *<P>\n-          * Feature is enabled by default.\n-          */\n-         AUTO_DETECT_SETTERS(true),\n-         \n-         /**\n-          * Feature that determines whether getters (getter methods)\n-          * can be auto-detected if there is no matching mutator (setter,\n-          * constructor parameter or field) or not: if set to true,\n-          * only getters that match a mutator are auto-discovered; if\n-          * false, all auto-detectable getters can be discovered.\n-          *<p>\n-          * Feature is disabled by default.\n-          */\n-         REQUIRE_SETTERS_FOR_GETTERS(false),\n-\n-         /**\n-          * Feature that determines whether otherwise regular \"getter\"\n-          * methods (but only ones that handle Collections and Maps,\n-          * not getters of other type)\n-          * can be used for purpose of getting a reference to a Collection\n-          * and Map to modify the property, without requiring a setter\n-          * method.\n-          * This is similar to how JAXB framework sets Collections and\n-          * Maps: no setter is involved, just setter.\n-          *<p>\n-          * Note that such getters-as-setters methods have lower\n-          * precedence than setters, so they are only used if no\n-          * setter is found for the Map/Collection property.\n-          *<p>\n-          * Feature is enabled by default.\n-          */\n-         USE_GETTERS_AS_SETTERS(true),\n-\n-         /**\n-         * Feature that determines whether method and field access\n-         * modifier settings can be overridden when accessing\n-         * properties. If enabled, method\n-         * {@link java.lang.reflect.AccessibleObject#setAccessible}\n-         * may be called to enable access to otherwise unaccessible\n-         * objects.\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-        CAN_OVERRIDE_ACCESS_MODIFIERS(true),\n-\n-        /*\n-        /******************************************************\n-        /* Type-handling features\n-        /******************************************************\n-         */\n-\n-        /**\n-         * Feature that determines whether the type detection for\n-         * serialization should be using actual dynamic runtime type,\n-         * or declared static type.\n-         * Note that deserialization always uses declared static types\n-         * since no runtime types are available (as we are creating\n-         * instances after using type information).\n-         *<p>\n-         * This global default value can be overridden at class, method\n-         * or field level by using {@link JsonSerialize#typing} annotation\n-         * property.\n-         *<p>\n-         * Feature is disabled by default which means that dynamic runtime types\n-         * are used (instead of declared static types) for serialization.\n-         */\n-        USE_STATIC_TYPING(false),\n-\n-        /*\n-        /******************************************************\n-        /* View-related features\n-        /******************************************************\n-         */\n-        \n-        /**\n-         * Feature that determines whether properties that have no view\n-         * annotations are included in JSON serialization views (see\n-         * {@link com.fasterxml.jackson.annotation.JsonView} for more\n-         * details on JSON Views).\n-         * If enabled, non-annotated properties will be included;\n-         * when disabled, they will be excluded. So this feature\n-         * changes between \"opt-in\" (feature disabled) and\n-         * \"opt-out\" (feature enabled) modes.\n-         *<p>\n-         * Default value is enabled, meaning that non-annotated\n-         * properties are included in all views if there is no\n-         * {@link com.fasterxml.jackson.annotation.JsonView} annotation.\n-         *<p>\n-         * Feature is enabled by default.\n-         */\n-        DEFAULT_VIEW_INCLUSION(true),\n-        \n-        /*\n-        /******************************************************\n-        /* Generic output features\n-        /******************************************************\n-         */\n-\n-        /**\n-         * Feature that defines default property serialization order used\n-         * for POJO fields (note: does <b>not</b> apply to {@link java.util.Map}\n-         * serialization!):\n-         * if enabled, default ordering is alphabetic (similar to\n-         * how {@link com.fasterxml.jackson.annotation.JsonPropertyOrder#alphabetic()}\n-         * works); if disabled, order is unspecified (based on what JDK gives\n-         * us, which may be declaration order, but is not guaranteed).\n-         *<p>\n-         * Note that this is just the default behavior, and can be overridden by\n-         * explicit overrides in classes.\n-         *<p>\n-         * Feature is disabled by default.\n-         */\n-        SORT_PROPERTIES_ALPHABETICALLY(false)\n-\n-        ;\n-\n-        private final boolean _defaultState;\n-        \n-        private Feature(boolean defaultState) {\n-            _defaultState = defaultState;\n-        }\n-        \n-        @Override\n-        public boolean enabledByDefault() { return _defaultState; }\n-\n-        @Override\n-        public int getMask() { return (1 << ordinal()); }\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Simple immutable basic settings\n-    /**********************************************************\n-     */\n-\n-    /**\n      * Set of shared mapper features enabled.\n      */\n     protected final int _mapperFeatures;\n      * Method for constructing and returning a new instance with specified\n      * mapper features enabled.\n      */\n-    public abstract T with(MapperConfig.Feature... features);\n+    public abstract T with(MapperFeature... features);\n \n     /**\n      * Method for constructing and returning a new instance with specified\n      * mapper features disabled.\n      */\n-    public abstract T without(MapperConfig.Feature... features);\n+    public abstract T without(MapperFeature... features);\n     \n     /*\n     /**********************************************************\n      * Accessor for simple mapper features (which are shared for\n      * serialization, deserialization)\n      */\n-    public final boolean isEnabled(MapperConfig.Feature f) {\n+    public final boolean isEnabled(MapperFeature f) {\n         return (_mapperFeatures & f.getMask()) != 0;\n     }\n     \n      * @return True if annotation processing is enabled; false if not\n      */\n     public final boolean isAnnotationProcessingEnabled() {\n-        return isEnabled(MapperConfig.Feature.USE_ANNOTATIONS);\n+        return isEnabled(MapperFeature.USE_ANNOTATIONS);\n     }\n \n     /**\n      *   to override.\n      */\n     public final boolean canOverrideAccessModifiers() {\n-        return isEnabled(MapperConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS);\n+        return isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS);\n     }\n \n     /**\n      * indicate that properties should be alphabetically ordered or not.\n      */\n     public final boolean shouldSortPropertiesAlphabetically() {\n-        return isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY);\n+        return isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.PropertyAccessor;\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n-import com.fasterxml.jackson.databind.HandlerInstantiator;\n+import com.fasterxml.jackson.databind.MapperFeature;\n import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n     T extends MapperConfigBase<CFG,T>>\n     extends MapperConfig<T>\n {\n-    private final static int DEFAULT_MAPPER_FEATURES = collectFeatureDefaults(MapperConfig.Feature.class);\n+    private final static int DEFAULT_MAPPER_FEATURES = collectFeatureDefaults(MapperFeature.class);\n \n     /*\n     /**********************************************************\n      * Note that when a root name is set to a non-Empty String, this will automatically force use\n      * of root element wrapping with given name. If empty String passed, will\n      * disable root name wrapping; and if null used, will instead use\n-     * <code>Feature</code> to determine if to use wrapping, and annotation\n+     * <code>SerializationFeature</code> to determine if to use wrapping, and annotation\n      * (or default name) for actual root name to use.\n      * \n      * @param rootName to use: if null, means \"use default\" (clear setting);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/SerializationConfig.java\n+package com.fasterxml.jackson.databind.cfg;\n+\n+import java.text.DateFormat;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.BeanDescription;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.ser.SerializerFactory;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Object that contains baseline configuration for serialization\n+ * process. An instance is owned by {@link ObjectMapper}, which\n+ * passes an immutable instance for serialization process to\n+ * {@link SerializerProvider} and {@link SerializerFactory}\n+ * (either directly, or through {@link ObjectWriter}.\n+ *<p>\n+ * Note that instances are considered immutable and as such no copies\n+ * should need to be created (there are some implementation details\n+ * with respect to mix-in annotations; where this is guaranteed as\n+ * long as caller follow \"copy-then-use\" pattern)\n+ */\n+public final class SerializationConfig\n+    extends MapperConfigBase<SerializationFeature, SerializationConfig>\n+{\n+    /**\n+     * Set of features enabled; actual type (kind of features)\n+     * depends on sub-classes.\n+     */\n+    protected final int _serFeatures;\n+    \n+    /**\n+     * Which Bean/Map properties are to be included in serialization?\n+     * Default settings is to include all regardless of value; can be\n+     * changed to only include non-null properties, or properties\n+     * with non-default values.\n+     */\n+    protected JsonInclude.Include _serializationInclusion = null;\n+    \n+    /**\n+     * Object used for resolving filter ids to filter instances.\n+     * Non-null if explicitly defined; null by default.\n+     */\n+    protected final FilterProvider _filterProvider;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used by ObjectMapper to create default configuration object instance.\n+     */\n+    public SerializationConfig(BaseSettings base,\n+            SubtypeResolver str, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(base, str, mixins);\n+        _serFeatures = collectFeatureDefaults(SerializationFeature.class);\n+        _filterProvider = null;\n+    }\n+    \n+    private SerializationConfig(SerializationConfig src, SubtypeResolver str)\n+    {\n+        super(src, str);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n+\n+    private SerializationConfig(SerializationConfig src,\n+            int mapperFeatures, int serFeatures)\n+    {\n+        super(src, mapperFeatures);\n+        _serFeatures = serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n+    \n+    private SerializationConfig(SerializationConfig src, BaseSettings base)\n+    {\n+        super(src, base);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n+\n+    private SerializationConfig(SerializationConfig src, FilterProvider filters)\n+    {\n+        super(src);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = filters;\n+    }\n+\n+    private SerializationConfig(SerializationConfig src, Class<?> view)\n+    {\n+        super(src, view);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n+\n+    private SerializationConfig(SerializationConfig src, JsonInclude.Include incl)\n+    {\n+        super(src);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = incl;\n+        _filterProvider = src._filterProvider;\n+    }\n+\n+    private SerializationConfig(SerializationConfig src, String rootName)\n+    {\n+        super(src, rootName);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, factory methods from MapperConfig\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    @Override\n+    public SerializationConfig with(MapperFeature... features)\n+    {\n+        int newMapperFlags = _mapperFeatures;\n+        for (MapperFeature f : features) {\n+            newMapperFlags |= f.getMask();\n+        }\n+        return (newMapperFlags == _mapperFeatures) ? this\n+                : new SerializationConfig(this, newMapperFlags, _serFeatures);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    @Override\n+    public SerializationConfig without(MapperFeature... features)\n+    {\n+        int newMapperFlags = _mapperFeatures;\n+        for (MapperFeature f : features) {\n+             newMapperFlags &= ~f.getMask();\n+        }\n+        return (newMapperFlags == _mapperFeatures) ? this\n+                : new SerializationConfig(this, newMapperFlags, _serFeatures);\n+    }\n+\n+    @Override\n+    public SerializationConfig withAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return _withBase(_base.withAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public SerializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return _withBase(_base.withAppendedAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public SerializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return _withBase(_base.withInsertedAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public SerializationConfig withClassIntrospector(ClassIntrospector ci) {\n+        return _withBase(_base.withClassIntrospector(ci));\n+    }\n+    \n+    /**\n+     * In addition to constructing instance with specified date format,\n+     * will enable or disable <code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code>\n+     * (enable if format set as null; disable if non-null)\n+     */\n+    @Override\n+    public SerializationConfig withDateFormat(DateFormat df) {\n+        SerializationConfig cfg =  new SerializationConfig(this, _base.withDateFormat(df));\n+        // Also need to toggle this feature based on existence of date format:\n+        if (df == null) {\n+            cfg = cfg.with(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+        } else {\n+            cfg = cfg.without(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+        }\n+        return cfg;\n+    }\n+    \n+    @Override\n+    public SerializationConfig withHandlerInstantiator(HandlerInstantiator hi) {\n+        return _withBase(_base.withHandlerInstantiator(hi));\n+    }\n+    \n+    @Override\n+    public SerializationConfig withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n+        return _withBase(_base.withPropertyNamingStrategy(pns));\n+    }\n+\n+    @Override\n+    public SerializationConfig withRootName(String rootName) {\n+        if (rootName == null) {\n+            if (_rootName == null) {\n+                return this;\n+            }\n+        } else if (rootName.equals(_rootName)) {\n+            return this;\n+        }\n+        return new SerializationConfig(this, rootName);\n+    }\n+\n+    @Override\n+    public SerializationConfig withSubtypeResolver(SubtypeResolver str) {\n+        return (str == _subtypeResolver)? this : new SerializationConfig(this, str);\n+    }\n+\n+    @Override\n+    public SerializationConfig withTypeFactory(TypeFactory tf) {\n+        return _withBase(_base.withTypeFactory(tf));\n+    }\n+\n+    @Override\n+    public SerializationConfig withTypeResolverBuilder(TypeResolverBuilder<?> trb) {\n+        return _withBase(_base.withTypeResolverBuilder(trb));\n+    }\n+    \n+    public SerializationConfig withView(Class<?> view) {\n+        return (_view == view) ? this : new SerializationConfig(this, view);\n+    }\n+\n+    @Override\n+    public SerializationConfig withVisibilityChecker(VisibilityChecker<?> vc) {\n+        return _withBase(_base.withVisibilityChecker(vc));\n+    }\n+\n+    @Override\n+    public SerializationConfig withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n+        return _withBase(_base.withVisibility(forMethod, visibility));\n+    }\n+    \n+    private final SerializationConfig _withBase(BaseSettings newBase) {\n+        return (_base == newBase) ? this : new SerializationConfig(this, newBase);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, SerializationConfig specific factory methods\n+    /**********************************************************\n+     */\n+        \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature enabled.\n+     */\n+    public SerializationConfig with(SerializationFeature feature)\n+    {\n+        int newSerFeatures = _serFeatures | feature.getMask();\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public SerializationConfig with(SerializationFeature first, SerializationFeature... features)\n+    {\n+        int newSerFeatures = _serFeatures | first.getMask();\n+        for (SerializationFeature f : features) {\n+            newSerFeatures |= f.getMask();\n+        }\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public SerializationConfig withFeatures(SerializationFeature... features)\n+    {\n+        int newSerFeatures = _serFeatures;\n+        for (SerializationFeature f : features) {\n+            newSerFeatures |= f.getMask();\n+        }\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature disabled.\n+     */\n+    public SerializationConfig without(SerializationFeature feature)\n+    {\n+        int newSerFeatures = _serFeatures & ~feature.getMask();\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public SerializationConfig without(SerializationFeature first, SerializationFeature... features)\n+    {\n+        int newSerFeatures = _serFeatures & ~first.getMask();\n+        for (SerializationFeature f : features) {\n+            newSerFeatures &= ~f.getMask();\n+        }\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public SerializationConfig withoutFeatures(SerializationFeature... features)\n+    {\n+        int newSerFeatures = _serFeatures;\n+        for (SerializationFeature f : features) {\n+            newSerFeatures &= ~f.getMask();\n+        }\n+        return (newSerFeatures == _serFeatures) ? this\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+    }\n+    \n+    public SerializationConfig withFilters(FilterProvider filterProvider) {\n+        return (filterProvider == _filterProvider) ? this : new SerializationConfig(this, filterProvider);\n+    }\n+\n+    public SerializationConfig withSerializationInclusion(JsonInclude.Include incl) {\n+        return (_serializationInclusion == incl) ? this:  new SerializationConfig(this, incl);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* MapperConfig implementation/overrides\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public boolean useRootWrapping()\n+    {\n+        if (_rootName != null) { // empty String disables wrapping; non-empty enables\n+            return (_rootName.length() > 0);\n+        }\n+        return isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n+    }\n+    \n+    @Override\n+    public AnnotationIntrospector getAnnotationIntrospector()\n+    {\n+        /* 29-Jul-2009, tatu: it's now possible to disable use of\n+         *   annotations; can be done using \"no-op\" introspector\n+         */\n+        if (isEnabled(MapperFeature.USE_ANNOTATIONS)) {\n+            return super.getAnnotationIntrospector();\n+        }\n+        return AnnotationIntrospector.nopInstance();\n+    }\n+\n+    /**\n+     * Accessor for getting bean description that only contains class\n+     * annotations: useful if no getter/setter/creator information is needed.\n+     */\n+    @Override\n+    public BeanDescription introspectClassAnnotations(JavaType type) {\n+        return getClassIntrospector().forClassAnnotations(this, type, this);\n+    }\n+\n+    /**\n+     * Accessor for getting bean description that only contains immediate class\n+     * annotations: ones from the class, and its direct mix-in, if any, but\n+     * not from super types.\n+     */\n+    @Override\n+    public BeanDescription introspectDirectClassAnnotations(JavaType type) {\n+        return getClassIntrospector().forDirectClassAnnotations(this, type, this);\n+    }\n+    \n+    @Override\n+    public VisibilityChecker<?> getDefaultVisibilityChecker()\n+    {\n+        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n+        if (!isEnabled(MapperFeature.AUTO_DETECT_GETTERS)) {\n+            vchecker = vchecker.withGetterVisibility(Visibility.NONE);\n+        }\n+        // then global overrides (disabling)\n+        if (!isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS)) {\n+            vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);\n+        }\n+        if (!isEnabled(MapperFeature.AUTO_DETECT_FIELDS)) {\n+            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n+        }\n+        return vchecker;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: other\n+    /**********************************************************\n+     */\n+\n+    public final boolean isEnabled(SerializationFeature f) {\n+        return (_serFeatures & f.getMask()) != 0;\n+    }\n+    \n+    public final int getSerializationFeatures() {\n+        return _serFeatures;\n+    }\n+    \n+    public JsonInclude.Include getSerializationInclusion()\n+    {\n+        if (_serializationInclusion != null) {\n+            return _serializationInclusion;\n+        }\n+        return JsonInclude.Include.ALWAYS;\n+    }\n+    \n+    /**\n+     * Method for getting provider used for locating filters given\n+     * id (which is usually provided with filter annotations).\n+     * Will be null if no provided was set for {@link ObjectWriter}\n+     * (or if serialization directly called from {@link ObjectMapper})\n+     */\n+    public FilterProvider getFilterProvider() {\n+        return _filterProvider;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Introspection methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will introspect full bean properties for the purpose\n+     * of building a bean serializer\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends BeanDescription> T introspect(JavaType type) {\n+        return (T) getClassIntrospector().forSerialization(this, type, this);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Debug support\n+    /**********************************************************\n+     */\n+    \n+    @Override public String toString()\n+    {\n+        return \"[SerializationConfig: flags=0x\"+Integer.toHexString(_serFeatures)+\"]\";\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/package-info.java\n+/**\n+Package that contains most of configuration-related classes;\n+exception being couple of most-commonly used configuration\n+things (like Feature enumerations) that are at the\n+main level (<code>com.fasterxml.jackson.databind</code>).\n+*/\n+\n+package com.fasterxml.jackson.databind.cfg;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n import com.fasterxml.jackson.databind.deser.std.*;\n import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n             return EnumResolver.constructUnsafeUsingMethod(enumClass, accessor);\n         }\n         // [JACKSON-212]: may need to use Enum.toString()\n-        if (config.isEnabled(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING)) {\n+        if (config.isEnabled(DeserializationFeature.READ_ENUMS_USING_TO_STRING)) {\n             return EnumResolver.constructUnsafeUsingToString(enumClass);\n         }\n         return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n         if (t instanceof Error) {\n             throw (Error) t;\n         }\n-        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationConfig.Feature.WRAP_EXCEPTIONS);\n+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n         // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n         if (t instanceof IOException) {\n             if (!wrap || !(t instanceof JsonMappingException)) {\n         if (t instanceof Error) {\n             throw (Error) t;\n         }\n-        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationConfig.Feature.WRAP_EXCEPTIONS);\n+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n         // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n         if (t instanceof IOException) {\n             if (!wrap || !(t instanceof JsonMappingException)) {\n         if (t instanceof Error) {\n             throw (Error) t;\n         }\n-        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationConfig.Feature.WRAP_EXCEPTIONS);\n+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationFeature.WRAP_EXCEPTIONS);\n         if (t instanceof IOException) {\n             // Since we have no more information to add, let's not actually wrap..\n             throw (IOException) t;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n \n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.impl.BeanPropertyMap;\n import com.fasterxml.jackson.databind.deser.impl.ValueInjector;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n             DeserializationConfig config)\n     { \n         _beanDesc = beanDesc;\n-        _defaultViewInclusion = config.isEnabled(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION);\n+        _defaultViewInclusion = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.impl.DeserializerCache;\n import com.fasterxml.jackson.databind.deser.std.JdkDeserializers;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n                 }\n             }\n         }\n-        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS)\n-                && ctxt.isEnabled(MapperConfig.Feature.AUTO_DETECT_GETTERS));\n+        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS)\n+                && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n \n         // Ok: let's then filter out property definitions\n         List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n                 Class<?>[] views = propDef.findViews();\n                 if (views == null) {\n                     // one more twist: if default inclusion disabled, need to force empty set of views\n-                    if (!ctxt.isEnabled(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION)) {\n+                    if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) {\n                         views = NO_VIEWS;\n                     }\n                 }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java\n import java.util.List;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.BeanDeserializer;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerFactory;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializationProblemHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializationProblemHandler.java\n \n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n \n /**\n  * This is the class that can be registered (via\n      *</pre>\n      *<p>\n      * Note: version 1.2 added new deserialization feature\n-     * (<code>DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES</code>).\n+     * (<code>DeserializationConfig.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>).\n      * It will only have effect <b>after</b> handler is called, and only\n      * if handler did <b>not</b> handle the problem.\n      *\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n package com.fasterxml.jackson.databind.deser;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.*;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n package com.fasterxml.jackson.databind.deser;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.KeyDeserializer;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.*;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/KeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/KeyDeserializers.java\n package com.fasterxml.jackson.databind.deser;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n \n /**\n  * Interface that defines API for simple extensions that can provide additional deserializers\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n \n         public Object nullValue(DeserializationContext ctxt) throws JsonProcessingException\n         {\n-            if (_isPrimitive && ctxt.isEnabled(DeserializationConfig.Feature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n+            if (_isPrimitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n                 throw ctxt.mappingException(\"Can not map JSON null into type \"+_rawType.getName()\n-                        +\" (set DeserializationConfig.Feature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\");\n+                        +\" (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\");\n             }\n             return _nullValue;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n \n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiators.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiators.java\n package com.fasterxml.jackson.databind.deser;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n \n /**\n  * Interface for providers of {@link ValueInstantiator} instances.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n \n \n import com.fasterxml.jackson.databind.BeanDescription;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.CreatorProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/DeserializerCache.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n import com.fasterxml.jackson.databind.deser.DeserializerFactory;\n import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n         throws IOException, JsonProcessingException\n     {\n         // [JACKSON-526]: implicit arrays from single values?\n-        if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n             throw ctxt.mappingException(_collectionType.getRawClass());\n         }\n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n \n import com.fasterxml.jackson.core.*;\n \n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n             /* ... unless told not to do that. :-)\n              * (as per [JACKSON-412]\n              */\n-            if (ctxt.isEnabled(DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS)) {\n-                throw ctxt.mappingException(\"Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)\");\n+            if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS)) {\n+                throw ctxt.mappingException(\"Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)\");\n             }\n             \n             int index = jp.getIntValue();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JacksonDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JacksonDeserializers.java\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.databind.BeanDescription;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.CreatorProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n             {\n                 JsonParser.NumberType nt = jp.getNumberType();\n                 if (nt == JsonParser.NumberType.BIG_INTEGER\n-                    || ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                    || ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                     return nodeFactory.numberNode(jp.getBigIntegerValue());\n                 }\n                 if (nt == JsonParser.NumberType.INT) {\n             {\n                 JsonParser.NumberType nt = jp.getNumberType();\n                 if (nt == JsonParser.NumberType.BIG_DECIMAL\n-                    || ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                    || ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                     return nodeFactory.numberNode(jp.getDecimalValue());\n                 }\n                 return nodeFactory.numberNode(jp.getDoubleValue());\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n         {\n             JsonToken t = jp.getCurrentToken();\n             if (t == JsonToken.VALUE_NUMBER_INT) {\n-                if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                     return jp.getBigIntegerValue();\n                 }\n                 return jp.getNumberValue();\n                 /* [JACKSON-72]: need to allow overriding the behavior\n                  * regarding which type to use\n                  */\n-                if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                     return jp.getDecimalValue();\n                 }\n                 return Double.valueOf(jp.getDoubleValue());\n                 try {\n                     if (text.indexOf('.') >= 0) { // floating point\n                         // as per [JACKSON-72]:\n-                        if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                        if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                             return new BigDecimal(text);\n                         }\n                         return new Double(text);\n                     }\n                     // as per [JACKSON-100]:\n-                    if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                    if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                         return new BigInteger(text);\n                     }\n                     long value = Long.parseLong(text);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n     {\n         // [JACKSON-620] Empty String can become null...\n         if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n             String str = jp.getText();\n             if (str.length() == 0) {\n                 return null;\n         }\n         \n         // Can we do implicit coercion to a single-element array still?\n-        if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n             /* 04-Oct-2009, tatu: One exception; byte arrays are generally\n              *   serialized as base64, so that should be handled\n              */\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n             throws IOException, JsonProcessingException\n         {\n             // [JACKSON-526]: implicit arrays from single values?\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 // [JACKSON-620] Empty String can become null...\n                 if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                        && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                        && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n                     String str = jp.getText();\n                     if (str.length() == 0) {\n                         return null;\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             return new boolean[] { _parseBooleanPrimitive(jp, ctxt) };\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             byte value;\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             return new short[] { _parseShortPrimitive(jp, ctxt) };\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             return new int[] { _parseIntPrimitive(jp, ctxt) };\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             return new long[] { _parseLongPrimitive(jp, ctxt) };\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             return new float[] { _parseFloatPrimitive(jp, ctxt) };\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n-                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n-                if (jp.getText().length() == 0) {\n-                    return null;\n-                }\n-            }\n-            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                    && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n                 throw ctxt.mappingException(_valueClass);\n             }\n             return new double[] { _parseDoublePrimitive(jp, ctxt) };\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n         throws IOException, JsonProcessingException\n     {\n         // throw exception if that's what we are expected to do\n-        if (ctxt.isEnabled(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n+        if (ctxt.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n             throw ctxt.unknownFieldException(instanceOrClass, fieldName);\n         }\n         // ... or if not, just ignore\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.CreatorProperty;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n     public StdValueInstantiator(DeserializationConfig config, Class<?> valueType)\n     {\n         _cfgEmptyStringsAsObjects = (config == null) ? false\n-                : config.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n+                : config.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n         _valueTypeDesc = (valueType == null) ? \"UNKNOWN TYPE\" : valueType.getName();\n     }\n     \n     public StdValueInstantiator(DeserializationConfig config, JavaType valueType)\n     {\n         _cfgEmptyStringsAsObjects = (config == null) ? false\n-                : config.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n+                : config.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n         _valueTypeDesc = (valueType == null) ? \"UNKNOWN TYPE\" : valueType.toString();\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n         throws IOException, JsonProcessingException\n     {\n         // [JACKSON-526]: implicit arrays from single values?\n-        if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+        if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n             throw ctxt.mappingException(_collectionType.getRawClass());\n         }\n         // Strings are one of \"native\" (intrinsic) types, so there's never type deserializer involved\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n \n import com.fasterxml.jackson.core.*;\n \n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.ObjectBuffer;\n             /* [JACKSON-100]: caller may want to get all integral values\n              * returned as BigInteger, for consistency\n              */\n-            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                 return jp.getBigIntegerValue(); // should be optimal, whatever it is\n             }\n             return jp.getNumberValue(); // should be optimal, whatever it is\n             /* [JACKSON-72]: need to allow overriding the behavior regarding\n              *   which type to use\n              */\n-            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return jp.getDecimalValue();\n             }\n             return Double.valueOf(jp.getDoubleValue());\n \n         case VALUE_NUMBER_INT:\n             // For [JACKSON-100], see above:\n-            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS)) {\n                 return jp.getBigIntegerValue();\n             }\n             return jp.getIntValue();\n \n         case VALUE_NUMBER_FLOAT:\n             // For [JACKSON-72], see above\n-            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+            if (ctxt.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n                 return jp.getDecimalValue();\n             }\n             return Double.valueOf(jp.getDoubleValue());\n     protected Object mapArray(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n-        if (ctxt.isEnabled(DeserializationConfig.Feature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+        if (ctxt.isEnabled(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n             return mapArrayToArray(jp, ctxt);\n         }\n         // Minor optimization to handle small lists (default size for ArrayList is 10)\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/JodaSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/JodaSerializers.java\n         public void serialize(DateTime value, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n-            if (provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+            if (provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n                 jgen.writeNumber(value.getMillis());\n             } else {\n                 jgen.writeString(value.toString());\n         @Override\n         public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n         {\n-            return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+            return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                     ? \"number\" : \"string\", true);\n         }\n     }\n         public void serialize(LocalDateTime dt, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n-            if (provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+            if (provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n                 // Timestamp here actually means an array of values\n                 jgen.writeStartArray();\n                 jgen.writeNumber(dt.year().get());\n         @Override\n         public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n         {\n-            return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+            return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                     ? \"array\" : \"string\", true);\n         }\n     }\n         public void serialize(LocalDate dt, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n-            if (provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+            if (provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n                 // Timestamp here actually means an array of values\n                 jgen.writeStartArray();\n                 jgen.writeNumber(dt.year().get());\n         @Override\n         public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n         {\n-            return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+            return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                     ? \"array\" : \"string\", true);\n         }\n     }\n         public void serialize(DateMidnight dt, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n-            if (provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+            if (provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n                 // same as with other date-only values\n                 jgen.writeStartArray();\n                 jgen.writeNumber(dt.year().get());\n         @Override\n         public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n         {\n-            return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+            return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                     ? \"array\" : \"string\", true);\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n import java.util.Map;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.util.Provider;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.type.SimpleType;\n \n public class BasicClassIntrospector\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/ClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/ClassIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n \n import com.fasterxml.jackson.databind.BeanDescription;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n \n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n \n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n \n /**\n  * Dummy, \"no-operation\" implementation of {@link AnnotationIntrospector}.\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n \n /**\n  * Interface that defines builders that are configured based on\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java\n \n \n import com.fasterxml.jackson.databind.AbstractTypeResolver;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.type.ClassKey;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.Deserializers;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.*;\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n \n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.KeyDeserializers;\n import com.fasterxml.jackson.databind.type.ClassKey;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java\n \n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.Serializers;\n import com.fasterxml.jackson.databind.type.ArrayType;\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleValueInstantiators.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleValueInstantiators.java\n import java.util.HashMap;\n \n import com.fasterxml.jackson.databind.BeanDescription;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.deser.ValueInstantiators;\n import com.fasterxml.jackson.databind.type.ClassKey;\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.base.ParserMinimalBase;\n \n-import com.fasterxml.jackson.databind.DatabindVersion;\n import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n \n /**\n  * Facade over {@link JsonNode} that implements {@link JsonParser} to allow\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\n import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n                 return true;\n             }\n         } else {\n-            if (config.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING)) {\n+            if (config.isEnabled(MapperFeature.USE_STATIC_TYPING)) {\n                 return true;\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n             }\n             JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n             // copied from BasicSerializerFactory.buildMapSerializer():\n-            boolean staticTyping = config.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING);\n+            boolean staticTyping = config.isEnabled(MapperFeature.USE_STATIC_TYPING);\n             JavaType valueType = type.getContentType();\n             TypeSerializer typeSer = createTypeSerializer(config, valueType);\n             // last 2 nulls; don't know key, value serializers (yet)\n         removeIgnorableTypes(config, beanDesc, properties);\n         \n         // and possibly remove ones without matching mutator...\n-        if (config.isEnabled(MapperConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS)) {\n+        if (config.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS)) {\n             removeSetterlessGetters(config, beanDesc, properties);\n         }\n         \n     {\n         // [JACKSON-232]: whether non-annotated fields are included by default or not is configurable\n         List<BeanPropertyWriter> props = builder.getProperties();\n-        boolean includeByDefault = config.isEnabled(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION);\n+        boolean includeByDefault = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n         final int propCount = props.size();\n         int viewsFound = 0;\n         BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerModifier.java\n \n import com.fasterxml.jackson.databind.BeanDescription;\n import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n \n /**\n  * Abstract class that defines API for objects that can be registered (for {@link BeanSerializerFactory}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize.Inclusion;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.util.*;\n             case ALWAYS: // default\n                 // we may still want to suppress empty collections, as per [JACKSON-254]:\n                 if (declaredType.isContainerType()\n-                        && !_config.isEnabled(SerializationConfig.Feature.WRITE_EMPTY_JSON_ARRAYS)) {\n+                        && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n                     valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n                 }\n                 break;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerFactory.java\n package com.fasterxml.jackson.databind.ser;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java\n package com.fasterxml.jackson.databind.ser;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.type.*;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n         throws IOException, JsonMappingException\n     {\n         // 27-Nov-2009, tatu: As per [JACKSON-201] may or may not fail...\n-        if (provider.isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS)) {\n+        if (provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) {\n             failForEmpty(value);\n         }\n         // But if it's fine, we'll just output empty JSON Object:\n             TypeSerializer typeSer)\n         throws IOException, JsonGenerationException\n     {\n-        if (provider.isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS)) {\n+        if (provider.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS)) {\n             failForEmpty(value);\n         }\n         typeSer.writeTypePrefixForObject(value, jgen);\n \n     protected void failForEmpty(Object value) throws JsonMappingException\n     {\n-        throw new JsonMappingException(\"No serializer found for class \"+value.getClass().getName()+\" and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS) )\");\n+        throw new JsonMappingException(\"No serializer found for class \"+value.getClass().getName()+\" and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationConfig.SerializationFeature.FAIL_ON_EMPTY_BEANS) )\");\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n     {\n         //TODO: (ryan) add a format for the date in the schema?\n-        return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+        return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                 ? \"number\" : \"string\", true);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n     {\n         //todo: (ryan) add a format for the date in the schema?\n-        return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+        return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n                 ? \"number\" : \"string\", true);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.node.ArrayNode;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.util.EnumValues;\n     {\n         // [JACKSON-212]: If toString() is to be used instead, leave EnumValues null\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        EnumValues v = config.isEnabled(SerializationConfig.Feature.WRITE_ENUMS_USING_TO_STRING)\n+        EnumValues v = config.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)\n             ? EnumValues.constructFromToString(enumClass, intr) : EnumValues.constructFromName(enumClass, intr);\n         return new EnumSerializer(v);\n     }\n         throws IOException, JsonGenerationException\n     {\n         // [JACKSON-684]: serialize as index?\n-        if (provider.isEnabled(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX)) {\n+        if (provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n             jgen.writeNumber(en.ordinal());\n             return;\n         }\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n     {\n         // [JACKSON-684]: serialize as index?\n-        if (provider.isEnabled(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX)) {\n+        if (provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n             return createSchemaNode(\"integer\", true);\n         }\n         ObjectNode objectNode = createSchemaNode(\"string\", true);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n              * if not, we don't really know the actual type until we get the instance.\n              */\n             // 10-Mar-2010, tatu: Except if static typing is to be used\n-            if (provider.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING)\n+            if (provider.isEnabled(MapperFeature.USE_STATIC_TYPING)\n                     || Modifier.isFinal(_accessorMethod.getReturnType().getModifiers())) {\n                 JavaType t = provider.constructType(_accessorMethod.getGenericReturnType());\n                 // false -> no need to cache\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n         \n         final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationConfig.Feature.WRITE_NULL_MAP_VALUES);\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         PropertySerializerMap serializers = _dynamicValueSerializers;\n \n         final JsonSerializer<Object> keySerializer = _keySerializer;\n         final HashSet<String> ignored = _ignoredEntries;\n         final TypeSerializer typeSer = _valueTypeSerializer;\n-        final boolean skipNulls = !provider.isEnabled(SerializationConfig.Feature.WRITE_NULL_MAP_VALUES);\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n             Object valueElem = entry.getValue();\n         JsonSerializer<Object> prevValueSerializer = null;\n         Class<?> prevValueClass = null;\n         final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationConfig.Feature.WRITE_NULL_MAP_VALUES);\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n     \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n             Object valueElem = entry.getValue();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n             throws IOException, JsonGenerationException\n         {\n             // [JACKSON-289] allows serializing as 'sparse' char array too:\n-            if (provider.isEnabled(SerializationConfig.Feature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {\n+            if (provider.isEnabled(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {\n                 jgen.writeStartArray();\n                 _writeArrayContents(jgen, value);\n                 jgen.writeEndArray();\n             throws IOException, JsonGenerationException\n         {\n             // [JACKSON-289] allows serializing as 'sparse' char array too:\n-            if (provider.isEnabled(SerializationConfig.Feature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {\n+            if (provider.isEnabled(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {\n                 typeSer.writeTypePrefixForArray(value, jgen);\n                 _writeArrayContents(jgen, value);\n                 typeSer.writeTypeSuffixForArray(value, jgen);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n             throw (Error) t;\n         }\n         // Ditto for IOExceptions... except for mapping exceptions!\n-        boolean wrap = (provider == null) || provider.isEnabled(SerializationConfig.Feature.WRAP_EXCEPTIONS);\n+        boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS);\n         if (t instanceof IOException) {\n             if (!wrap || !(t instanceof JsonMappingException)) {\n                 throw (IOException) t;\n             throw (Error) t;\n         }\n         // Ditto for IOExceptions... except for mapping exceptions!\n-        boolean wrap = (provider == null) || provider.isEnabled(SerializationConfig.Feature.WRAP_EXCEPTIONS);\n+        boolean wrap = (provider == null) || provider.isEnabled(SerializationFeature.WRAP_EXCEPTIONS);\n         if (t instanceof IOException) {\n             if (!wrap || !(t instanceof JsonMappingException)) {\n                 throw (IOException) t;\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n  *<p>\n  * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n  * as well as many objects it constructs (like\n-* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n- * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n+* {@link com.fasterxml.jackson.databind.cfg.DeserializationConfig} and\n+ * {@link com.fasterxml.jackson.databind.cfg.SerializationConfig})),\n  * but usually those objects also \n  * expose convenience methods (<code>constructType</code>).\n  * So, you can do for example:\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n import com.fasterxml.jackson.core.json.JsonWriteContext;\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n \n-import com.fasterxml.jackson.databind.DatabindVersion;\n+import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n \n /**\n  * Utility class used for efficient storage of {@link JsonToken}\n         return this;\n     }\n \n-    //public JsonGenerator configure(Feature f, boolean state) { }\n+    //public JsonGenerator configure(SerializationFeature f, boolean state) { }\n \n     @Override\n     public boolean isEnabled(Feature f) {\n--- a/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.HandlerInstantiator;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.KeyDeserializer;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n--- a/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.setPropertyNamingStrategy(new LcStrategy());\n-//        mapper.disable(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS);\n+//        mapper.disable(DeserializationConfig.DeserializationFeature.USE_GETTERS_AS_SETTERS);\n         RenamedCollectionBean foo = mapper.readValue(\"{\\\"thevalues\\\":[\\\"a\\\"]}\", RenamedCollectionBean.class);\n         assertNotNull(foo.getTheVALUEs());\n         assertEquals(1, foo.getTheVALUEs().size());\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n \n import com.fasterxml.jackson.core.JsonFactory;\n \n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.node.*;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n         ObjectMapper m = new ObjectMapper();\n         \n         // sort-alphabetically is disabled by default:\n-        assertFalse(m.isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        assertFalse(m.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY));\n         SerializationConfig sc = m.getSerializationConfig();\n-        assertFalse(sc.isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        assertFalse(sc.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY));\n         assertFalse(sc.shouldSortPropertiesAlphabetically());\n         DeserializationConfig dc = m.getDeserializationConfig();\n         assertFalse(dc.shouldSortPropertiesAlphabetically());\n \n         // but when enabled, should be visible:\n-        m.enable(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY);\n+        m.enable(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY);\n         sc = m.getSerializationConfig();\n-        assertTrue(sc.isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        assertTrue(sc.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY));\n         assertTrue(sc.shouldSortPropertiesAlphabetically());\n         dc = m.getDeserializationConfig();\n         // and not just via SerializationConfig, but also via DeserializationConfig\n-        assertTrue(dc.isEnabled(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        assertTrue(dc.isEnabled(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY));\n         assertTrue(dc.shouldSortPropertiesAlphabetically());\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/TestRootName.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestRootName.java\n \n import com.fasterxml.jackson.annotation.*;\n \n-import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n \n /**\n  * Unit tests dealing with handling of \"root element wrapping\",\n         String jsonUnwrapped = mapper.writeValueAsString(input);\n         assertEquals(\"{\\\"a\\\":3}\", jsonUnwrapped);\n         // secondary: wrapping\n-        String jsonWrapped = mapper.writer(SerializationConfig.Feature.WRAP_ROOT_VALUE)\n+        String jsonWrapped = mapper.writer(SerializationFeature.WRAP_ROOT_VALUE)\n             .writeValueAsString(input);\n         assertEquals(\"{\\\"rudy\\\":{\\\"a\\\":3}}\", jsonWrapped);\n \n         Bean result = mapper.readValue(jsonUnwrapped, Bean.class);\n         assertNotNull(result);\n         try { // must not have extra wrapping\n-            result = mapper.reader(Bean.class).with(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE)\n+            result = mapper.reader(Bean.class).with(DeserializationFeature.UNWRAP_ROOT_VALUE)\n                 .readValue(jsonUnwrapped);\n             fail(\"Should have failed\");\n         } catch (JsonMappingException e) {\n             verifyException(e, \"Root name 'a'\");\n         }\n         // except wrapping may be expected:\n-        result = mapper.reader(Bean.class).with(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE)\n+        result = mapper.reader(Bean.class).with(DeserializationFeature.UNWRAP_ROOT_VALUE)\n             .readValue(jsonWrapped);\n         assertNotNull(result);\n     }\n         Bean bean = reader.readValue(json);\n         assertNotNull(bean);\n \n-        // also: verify that we can override Feature as well:\n+        // also: verify that we can override SerializationFeature as well:\n         ObjectMapper wrapping = rootMapper();\n         json = wrapping.writer().withRootName(\"something\").writeValueAsString(new Bean());\n         assertEquals(\"{\\\"something\\\":{\\\"a\\\":3}}\", json);\n     private ObjectMapper rootMapper()\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.WRAP_ROOT_VALUE, true);\n-        mapper.configure(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE, true);\n+        mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);\n+        mapper.configure(DeserializationFeature.UNWRAP_ROOT_VALUE, true);\n         return mapper;\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java\n     public void testWrapping() throws Exception\n     {\n         ObjectMapper wrappingMapper = new ObjectMapper();\n-        wrappingMapper.enable(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n-        wrappingMapper.enable(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+        wrappingMapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+        wrappingMapper.enable(SerializationFeature.WRAP_ROOT_VALUE);\n \n         // conversion is ok, even if it's bogus one\n         _convertAndVerifyPoint(wrappingMapper);\n         // also: ok to have mismatched settings, since as per [JACKSON-710], should\n         // not actually use wrapping internally in these cases\n         wrappingMapper = new ObjectMapper();\n-        wrappingMapper.enable(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n-        wrappingMapper.disable(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+        wrappingMapper.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+        wrappingMapper.disable(SerializationFeature.WRAP_ROOT_VALUE);\n         _convertAndVerifyPoint(wrappingMapper);\n \n         wrappingMapper = new ObjectMapper();\n-        wrappingMapper.disable(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n-        wrappingMapper.enable(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+        wrappingMapper.disable(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+        wrappingMapper.enable(SerializationFeature.WRAP_ROOT_VALUE);\n         _convertAndVerifyPoint(wrappingMapper);\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestAnyProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestAnyProperties.java\n     public void testIgnored() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(com.fasterxml.jackson.databind.DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, true);\n+        mapper.configure(com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, true);\n         _testIgnorals(mapper);\n     }\n \n     public void testIgnored383() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(com.fasterxml.jackson.databind.DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        mapper.configure(com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n         _testIgnorals(mapper);\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestArrayDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestArrayDeserialization.java\n     public void testFromEmptyString() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+        m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n         assertNull(m.readValue(quote(\"\"), Object[].class));\n         assertNull( m.readValue(quote(\"\"), String[].class));\n         assertNull( m.readValue(quote(\"\"), int[].class));\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.BeanDeserializer;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerBuilder;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n \n         // should be ok to enable dynamically:\n         mapper = new ObjectMapper();\n-        mapper.configure(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+        mapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n         Bean result = mapper.readValue(quote(\"\"), Bean.class);\n         assertNull(result);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n     public void testImplicitArrays() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);\n+        mapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);\n \n         // first with simple scalar types (numbers), with collections\n         List<Integer> ints = mapper.readValue(\"4\", List.class);\n     public void testFromEmptyString() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+        m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n         List<?> result = m.readValue(quote(\"\"), List.class);\n         assertNull(result);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestConfig.java\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n \n /**\n  * Unit tests for checking handling of DeserializationConfig.\n         DeserializationConfig cfg = m.getDeserializationConfig();\n \n         // Expected defaults:\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.USE_ANNOTATIONS));\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.AUTO_DETECT_SETTERS));\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.AUTO_DETECT_CREATORS));\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS));\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n+        assertTrue(cfg.isEnabled(MapperFeature.USE_ANNOTATIONS));\n+        assertTrue(cfg.isEnabled(MapperFeature.AUTO_DETECT_SETTERS));\n+        assertTrue(cfg.isEnabled(MapperFeature.AUTO_DETECT_CREATORS));\n+        assertTrue(cfg.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS));\n+        assertTrue(cfg.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n \n \n-        assertFalse(cfg.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS));\n-        assertFalse(cfg.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS));\n+        assertFalse(cfg.isEnabled(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS));\n+        assertFalse(cfg.isEnabled(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS));\n \n-        assertTrue(cfg.isEnabled(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES));\n+        assertTrue(cfg.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n     }\n \n     public void testOverrideIntrospectors()\n     {\n         // first: verify that annotation introspection is enabled by default\n         ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.getDeserializationConfig().isEnabled(MapperConfig.Feature.USE_ANNOTATIONS));\n+        assertTrue(m.getDeserializationConfig().isEnabled(MapperFeature.USE_ANNOTATIONS));\n         // with annotations, property is renamed\n         AnnoBean bean = m.readValue(\"{ \\\"y\\\" : 0 }\", AnnoBean.class);\n         assertEquals(0, bean.value);\n \n         m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_ANNOTATIONS, false);\n+        m.configure(MapperFeature.USE_ANNOTATIONS, false);\n         // without annotations, should default to default bean-based name...\n         bean = m.readValue(\"{ \\\"x\\\" : 0 }\", AnnoBean.class);\n         assertEquals(0, bean.value);\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCreators2.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCreators2.java\n         }\n     }\n     \n-    // For [JACKSON-541]: should not need @JsonCreator if Feature.AUTO_DETECT_CREATORS is on.\n+    // For [JACKSON-541]: should not need @JsonCreator if SerializationFeature.AUTO_DETECT_CREATORS is on.\n     static class AutoDetectConstructorBean\n     {\n     \tprotected final String foo;\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n     {\n         // can't reuse global one due to reconfig\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING, true);\n+        m.configure(DeserializationFeature.READ_ENUMS_USING_TO_STRING, true);\n         LowerCaseEnum value = m.readValue(\"\\\"c\\\"\", LowerCaseEnum.class);\n         assertEquals(LowerCaseEnum.C, value);\n     }\n     {\n         // can't reuse global one due to reconfig\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING, true);\n+        m.configure(DeserializationFeature.READ_ENUMS_USING_TO_STRING, true);\n         EnumMap<LowerCaseEnum,String> value = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\",\n                 new TypeReference<EnumMap<LowerCaseEnum,String>>() { });\n         assertEquals(\"value\", value.get(LowerCaseEnum.A));\n     public void testNumbersToEnums() throws Exception\n     {\n         // by default numbers are fine:\n-        assertFalse(mapper.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS));\n+        assertFalse(mapper.getDeserializationConfig().isEnabled(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS));\n         TestEnum value = mapper.readValue(\"1\", TestEnum.class);\n         assertSame(TestEnum.RULES, value);\n \n         // but can also be changed to errors:\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS, true);\n+        m.configure(DeserializationFeature.FAIL_ON_NUMBERS_FOR_ENUMS, true);\n         try {\n             value = m.readValue(\"1\", TestEnum.class);\n             fail(\"Expected an error\");\n     public void testEnumsWithIndex() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.enable(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX);\n+        m.enable(SerializationFeature.WRITE_ENUMS_USING_INDEX);\n         String json = m.writeValueAsString(TestEnum.RULES);\n         assertEquals(String.valueOf(TestEnum.RULES.ordinal()), json);\n         TestEnum result = m.readValue(json, TestEnum.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericNumber.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericNumber.java\n          * to BigInteger even if value would fit in Integer\n          */\n         ObjectMapper m = new ObjectMapper();\n-        m.enable(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS);\n+        m.enable(DeserializationFeature.USE_BIG_INTEGER_FOR_INTS);\n         BigInteger exp = BigInteger.valueOf(123L);\n \n         // first test as any Number\n     public void testFpTypeOverrideSimple() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.enable(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS);\n+        m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n         BigDecimal dec = new BigDecimal(\"0.1\");\n \n         // First test generic stand-alone Number\n         ObjectMapper m = new ObjectMapper();\n         BigDecimal dec = new BigDecimal(\"-19.37\");\n \n-        m.enable(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS);\n+        m.enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS);\n \n         // List element types\n         @SuppressWarnings(\"unchecked\")\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n         \n         // but not when enabled\n         final ObjectMapper mapper2 = new ObjectMapper();\n-        mapper2.configure(DeserializationConfig.Feature.FAIL_ON_NULL_FOR_PRIMITIVES, true);\n+        mapper2.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, true);\n \n         // boolean\n         try {\n         assertTrue(ob instanceof List<?>);\n \n         // but can change to produce Object[]:\n-        mapper.configure(DeserializationConfig.Feature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);\n+        mapper.configure(DeserializationFeature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);\n         ob = mapper.readValue(\"[1]\", Object.class);\n         assertEquals(Object[].class, ob.getClass());\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n     public void testFromEmptyString() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+        m.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n         Map<?,?> result = m.readValue(quote(\"\"), Map.class);\n         assertNull(result);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSetterlessProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSetterlessProperties.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for verifying that feature requested\n     {\n         ObjectMapper m = new ObjectMapper();\n         // by default, it should be enabled\n-        assertTrue(m.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS));\n-        m.configure(MapperConfig.Feature.USE_GETTERS_AS_SETTERS, false);\n-        assertFalse(m.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS));\n+        assertTrue(m.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS));\n+        m.configure(MapperFeature.USE_GETTERS_AS_SETTERS, false);\n+        assertFalse(m.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS));\n \n         // and now this should fail\n         try {\n         throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_GETTERS_AS_SETTERS, false);\n+        m.configure(MapperFeature.USE_GETTERS_AS_SETTERS, false);\n         // so this should fail now without a setter\n         try {\n             m.readValue\n     public void testSetterlessPrecedence() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_GETTERS_AS_SETTERS, true);\n+        m.configure(MapperFeature.USE_GETTERS_AS_SETTERS, true);\n         Dual value = m.readValue(\"{\\\"list\\\":[1,2,3]}, valueType)\", Dual.class);\n         assertNotNull(value);\n         assertEquals(3, value.values.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestUnknownProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUnknownProperties.java\n         throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n         TestBean result = null;\n         try {\n             result = mapper.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/ext/TestCoreXMLTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ext/TestCoreXMLTypes.java\n         assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis());\n         \n         // and then textual variant\n-        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);\n+        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n         // this is ALMOST same as default for XMLGregorianCalendar... just need to unify Z/+0000\n         String exp = cal.toXMLFormat();\n         String act = mapper.writeValueAsString(cal);\n--- a/src/test/java/com/fasterxml/jackson/databind/ext/TestJodaTime.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ext/TestJodaTime.java\n \n         // but if re-configured, as regular ISO-8601 string\n         m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);\n+        m.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n         assertEquals(quote(\"1970-01-01T00:00:00.000Z\"), serializeAsString(m, dt));\n     }\n \n         assertEquals(\"[2001,5,25]\", mapper.writeValueAsString(date));\n         // but we can force it to be a String as well (note: here we assume this is\n         // dynamically changeable)\n-        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);        \n+        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);        \n         assertEquals(quote(\"2001-05-25\"), mapper.writeValueAsString(date));\n     }\n \n         assertEquals(\"[2001,5,25]\", mapper.writeValueAsString(date));\n         // but we can force it to be a String as well (note: here we assume this is\n         // dynamically changeable)\n-        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);        \n+        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);        \n         assertEquals(quote(\"2001-05-25\"), mapper.writeValueAsString(date));\n     }\n \n         assertEquals(\"[2001,5,25,10,15,30,37]\", mapper.writeValueAsString(date));\n         // but we can force it to be a String as well (note: here we assume this is\n         // dynamically changeable)\n-        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);        \n+        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);        \n         assertEquals(quote(\"2001-05-25T10:15:30.037\"), mapper.writeValueAsString(date));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java\n     public void testSerializeDeserializeWithJaxbAnnotations() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.enable(SerializationConfig.Feature.INDENT_OUTPUT);\n+        mapper.enable(SerializationFeature.INDENT_OUTPUT);\n         JacksonExample ex = new JacksonExample();\n         QName qname = new QName(\"urn:hi\", \"hello\");\n         ex.setQname(qname);\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestPOJOPropertiesCollector.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestPOJOPropertiesCollector.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n public class TestPOJOPropertiesCollector\n     extends BaseMapTest\n     public void testGlobalVisibilityForGetters()\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        m.configure(MapperFeature.AUTO_DETECT_GETTERS, false);\n         POJOPropertiesCollector coll = collector(m, SimpleGetterVisibility.class, true);\n         // should be 1, expect that we disabled getter auto-detection, so\n         Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n     public void testJackson703() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(MapperConfig.Feature.USE_ANNOTATIONS, false);\n+        mapper.configure(MapperFeature.USE_ANNOTATIONS, false);\n         BasicBeanDescription beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(Jackson703.class));\n         assertNotNull(beanDesc);\n \n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractTypeNames.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractTypeNames.java\n     public void testEmptyCollection() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.INDENT_OUTPUT, true);\n+        mapper.configure(SerializationFeature.INDENT_OUTPUT, true);\n         List<User>friends = new ArrayList<User>();\n         friends.add(new DefaultUser(\"Joe Hildebrandt\", null));\n         friends.add(new DefaultEmployee(\"Richard Nasr\",null,\"MDA\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n import com.fasterxml.jackson.core.type.TypeReference;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n public class TestGenericListSerialization\n         embedded.add(new Child1());\n         embedded.add(new Child2());\n         input.setResult(embedded);\n-        mapper.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        mapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n \n         JavaType rootType = TypeFactory.defaultInstance().constructType(new TypeReference<JSONResponse<List<Parent>>>() { });\n         byte[] json = mapper.writerWithType(rootType).writeValueAsBytes(input);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypes.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n \n     {\n         // First, with annotations\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, true);\n+        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, true);\n         String json = mapper.writeValueAsString(new EmptyBean());\n         assertEquals(\"{\\\"@type\\\":\\\"TestSubtypes$EmptyBean\\\"}\", json);\n \n         mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n         json = mapper.writeValueAsString(new EmptyBean());\n         assertEquals(\"{\\\"@type\\\":\\\"TestSubtypes$EmptyBean\\\"}\", json);\n \n         // and then with defaults\n         mapper = new ObjectMapper();\n         mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n-        mapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n         json = mapper.writeValueAsString(new EmptyNonFinal());\n         assertEquals(\"[\\\"com.fasterxml.jackson.databind.jsontype.TestSubtypes$EmptyNonFinal\\\",{}]\", json);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for verifying that types that serialize as JSON Arrays\n \n         // then with static typing enabled:\n         m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperFeature.USE_STATIC_TYPING, true);\n         assertEquals(EXP, m.writeValueAsString(input));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n     public void testEmptyBean() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        m.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n         assertEquals(\"{\\\"@type\\\":\\\"empty\\\"}\", m.writeValueAsString(new Empty()));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n         ObjectMapper om = new ObjectMapper();\n         om.enableDefaultTyping( ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY );\n         om.setSerializationInclusion(JsonInclude.Include.NON_NULL );\n-        om.enable( SerializationConfig.Feature.INDENT_OUTPUT);\n+        om.enable( SerializationFeature.INDENT_OUTPUT);\n \n         MyClass mc = new MyClass();\n \n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n public class TestMixinSerWithViews\n     extends BaseMapTest\n         ObjectMapper mapper = new ObjectMapper();\n         A a = new A(\"myname\", 29, \"mysurname\");\n \n-        // Property SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION set to false\n-        mapper.configure(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION, Boolean.FALSE);\n+        // Property SerializationConfig.SerializationFeature.DEFAULT_VIEW_INCLUSION set to false\n+        mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, Boolean.FALSE);\n         mapper.addMixInAnnotations(A.class, AMixInAnnotation.class);\n         String json = mapper.writerWithView(AView.class).writeValueAsString(a);\n \n     private ObjectMapper createObjectMapper( )\n     {\n       ObjectMapper objectMapper = new ObjectMapper( );\n-      objectMapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false );\n+      objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false );\n       objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL );\n-      objectMapper.configure(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION, false );\n+      objectMapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false );\n \n       Map<Class<?>, Class<?>> sourceMixins = new HashMap<Class<?>, Class<?>>( );\n       sourceMixins.put( SimpleTestData.class, TestDataJAXBMixin.class );\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.module.SimpleDeserializers;\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestValueInstantiator.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestValueInstantiator.java\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonValueInstantiator;\n+import com.fasterxml.jackson.databind.cfg.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationAnyGetter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationAnyGetter.java\n \n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n \n public class TestAnnotationAnyGetter\n     extends BaseMapTest\n \n         // First, with normal fail settings:\n         m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, true);\n+        m.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, true);\n         String json = serializeAsString(m, new AnyOnlyBean());\n         assertEquals(\"{\\\"a\\\":3}\", json);\n \n         // then without fail\n         m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        m.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n         json = serializeAsString(m, new AnyOnlyBean());\n         assertEquals(\"{\\\"a\\\":3}\", json);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonSerialize.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonSerialize.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * This unit test suite tests use of @JsonClass Annotation\n     public void testStaticTypingWithMap() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperFeature.USE_STATIC_TYPING, true);\n         ValueMap map = new ValueMap();\n         map.put(\"a\", new ValueClass());\n         assertEquals(\"{\\\"a\\\":{\\\"x\\\":3}}\", serializeAsString(m, map));\n     public void testStaticTypingWithArrayList() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperFeature.USE_STATIC_TYPING, true);\n         ValueList list = new ValueList();\n         list.add(new ValueClass());\n         assertEquals(\"[{\\\"x\\\":3}]\", m.writeValueAsString(list));\n     public void testStaticTypingWithLinkedList() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperFeature.USE_STATIC_TYPING, true);\n         ValueLinkedList list = new ValueLinkedList();\n         list.add(new ValueClass());\n         assertEquals(\"[{\\\"x\\\":3}]\", serializeAsString(m, list));\n     public void testStaticTypingWithArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        m.configure(MapperFeature.USE_STATIC_TYPING, true);\n         ValueInterface[] array = new ValueInterface[] { new ValueClass() };\n         assertEquals(\"[{\\\"x\\\":3}]\", serializeAsString(m, array));\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonValue.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonValue.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n \n /**\n \n         // then static\n         ObjectMapper staticMapper = new ObjectMapper();\n-        staticMapper.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        staticMapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n         assertEquals(\"{\\\"a\\\":\\\"a\\\"}\", staticMapper.writeValueAsString(new ValueWrapper()));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotations.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotations.java\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * This unit test suite tests use of Annotations for\n         public int getZ() { return 3; }\n     }\n \n-    // For [JACKSON-666] (\"Feature of the Beast!\")\n+    // For [JACKSON-666] (\"SerializationFeature of the Beast!\")\n     @JsonPropertyOrder(alphabetic=true)\n     static class GettersWithoutSetters\n     {\n     {\n         ObjectMapper m = new ObjectMapper();\n         GettersWithoutSetters bean = new GettersWithoutSetters(123);\n-        assertFalse(m.isEnabled(MapperConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS));\n+        assertFalse(m.isEnabled(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS));\n     \n         // by default, all 4 found:\n         assertEquals(\"{\\\"a\\\":3,\\\"b\\\":4,\\\"c\\\":5,\\\"d\\\":6}\", m.writeValueAsString(bean));\n \n         // but 3 if we require mutator:\n         m = new ObjectMapper();\n-        m.enable(MapperConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS);\n+        m.enable(MapperFeature.REQUIRE_SETTERS_FOR_GETTERS);\n         assertEquals(\"{\\\"a\\\":3,\\\"c\\\":5,\\\"d\\\":6}\", m.writeValueAsString(bean));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n import com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n         EmptyListBean list = new EmptyListBean();\n         EmptyArrayBean array = new EmptyArrayBean();\n         ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.getSerializationConfig().isEnabled(SerializationConfig.Feature.WRITE_EMPTY_JSON_ARRAYS));\n+        assertTrue(m.getSerializationConfig().isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS));\n         assertEquals(\"{\\\"empty\\\":[]}\", m.writeValueAsString(list));\n         assertEquals(\"{\\\"empty\\\":[]}\", m.writeValueAsString(array));\n \n         // note: value of setting may be cached when constructing serializer, need a new instance\n         m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.WRITE_EMPTY_JSON_ARRAYS, false);\n+        m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false);\n         assertEquals(\"{}\", m.writeValueAsString(list));\n         assertEquals(\"{}\", m.writeValueAsString(array));\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n \n /**\n         SerializationConfig cfg = m.getSerializationConfig();\n \n         // First, defaults:\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.USE_ANNOTATIONS));\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.AUTO_DETECT_GETTERS));\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n+        assertTrue(cfg.isEnabled(MapperFeature.USE_ANNOTATIONS));\n+        assertTrue(cfg.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n+        assertTrue(cfg.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n \n-        assertTrue(cfg.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS));\n+        assertTrue(cfg.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS));\n \n-        assertFalse(cfg.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT));\n-        assertFalse(cfg.isEnabled(MapperConfig.Feature.USE_STATIC_TYPING));\n+        assertFalse(cfg.isEnabled(SerializationFeature.INDENT_OUTPUT));\n+        assertFalse(cfg.isEnabled(MapperFeature.USE_STATIC_TYPING));\n \n         // since 1.3:\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.AUTO_DETECT_IS_GETTERS));\n+        assertTrue(cfg.isEnabled(MapperFeature.AUTO_DETECT_IS_GETTERS));\n         // since 1.4\n         \n-        assertTrue(cfg.isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS));\n+        assertTrue(cfg.isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS));\n         // since 1.5\n-        assertTrue(cfg.isEnabled(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION));\n+        assertTrue(cfg.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION));\n \n     }\n \n     public void testIndentation() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(SerializationConfig.Feature.INDENT_OUTPUT, true);\n+        m.configure(SerializationFeature.INDENT_OUTPUT, true);\n         Map<String,Integer> map = new HashMap<String,Integer>();\n         map.put(\"a\", Integer.valueOf(2));\n         String result = serializeAsString(m, map).trim();\n     {\n         // first: verify that annotation introspection is enabled by default\n         ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.isEnabled(MapperConfig.Feature.USE_ANNOTATIONS));\n+        assertTrue(m.isEnabled(MapperFeature.USE_ANNOTATIONS));\n         Map<String,Object> result = writeAndMap(m, new AnnoBean());\n         assertEquals(2, result.size());\n \n         m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.USE_ANNOTATIONS, false);\n+        m.configure(MapperFeature.USE_ANNOTATIONS, false);\n         result = writeAndMap(m, new AnnoBean());\n         assertEquals(1, result.size());\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n         ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n         // default is to output time stamps...\n-        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS));\n+        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS));\n         // shouldn't matter which offset we give...\n         mapper.writeValue(sw, new Date(199L));\n         assertEquals(\"199\", sw.toString());\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n-        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);\n+        mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n         // let's hit epoch start\n         mapper.writeValue(sw, new Date(0L));\n         assertEquals(\"\\\"1970-01-01T00:00:00.000+0000\\\"\", sw.toString());\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         Map<Date,Integer> map = new HashMap<Date,Integer>();\n-        assertFalse(mapper.isEnabled(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS));\n+        assertFalse(mapper.isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS));\n         map.put(new Date(0L), Integer.valueOf(1));\n         // by default will serialize as ISO-8601 values...\n         assertEquals(\"{\\\"1970-01-01T00:00:00.000+0000\\\":1}\", mapper.writeValueAsString(map));\n         \n         // but can change to use timestamps too\n-        mapper.configure(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true);\n+        mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true);\n         assertEquals(\"{\\\"0\\\":1}\", mapper.writeValueAsString(map));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n     public void testEmptyWithFeature() throws Exception\n     {\n         // should be enabled by default\n-        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS));\n-        mapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationFeature.FAIL_ON_EMPTY_BEANS));\n+        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n         assertEquals(\"{}\", serializeAsString(mapper, new Empty()));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n     public void testToStringEnum() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.WRITE_ENUMS_USING_TO_STRING, true);\n+        mapper.configure(SerializationFeature.WRITE_ENUMS_USING_TO_STRING, true);\n         assertEquals(\"\\\"b\\\"\", mapper.writeValueAsString(LowerCaseEnum.B));\n     }\n \n     public void testToStringEnumWithEnumMap() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.WRITE_ENUMS_USING_TO_STRING, true);\n+        mapper.configure(SerializationFeature.WRITE_ENUMS_USING_TO_STRING, true);\n         EnumMap<LowerCaseEnum,String> m = new EnumMap<LowerCaseEnum,String>(LowerCaseEnum.class);\n         m.put(LowerCaseEnum.C, \"value\");\n         assertEquals(\"{\\\"c\\\":\\\"value\\\"}\", mapper.writeValueAsString(m));\n     {\n         // By default, serialize using name\n         ObjectMapper mapper = new ObjectMapper();\n-        assertFalse(mapper.isEnabled(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX));\n+        assertFalse(mapper.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX));\n         assertEquals(quote(\"B\"), mapper.writeValueAsString(TestEnum.B));\n \n         // but we can change (dynamically, too!) it to be number-based\n-        mapper.enable(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX);\n+        mapper.enable(SerializationFeature.WRITE_ENUMS_USING_INDEX);\n         assertEquals(\"1\", mapper.writeValueAsString(TestEnum.B));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for checking whether JsonSerializerFactory.Feature\n         // Then auto-detection disabled. But note: we MUST create a new\n         // mapper, since old version of serializer may be cached by now\n         m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        m.configure(MapperFeature.AUTO_DETECT_GETTERS, false);\n         result = writeAndMap(m, new GetterClass());\n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"x\"));\n         assertTrue(result.containsKey(\"x\"));\n \n         // And then class-level auto-detection enabling, should override defaults\n-        m.configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        m.configure(MapperFeature.AUTO_DETECT_GETTERS, false);\n         result = writeAndMap(m, new EnabledGetterClass());\n         assertEquals(2, result.size());\n         assertTrue(result.containsKey(\"x\"));\n     {\n         ObjectMapper m = new ObjectMapper();\n         // class level should override\n-        m.configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, true);\n-        m.configure(MapperConfig.Feature.AUTO_DETECT_IS_GETTERS, false);\n+        m.configure(MapperFeature.AUTO_DETECT_GETTERS, true);\n+        m.configure(MapperFeature.AUTO_DETECT_IS_GETTERS, false);\n          Map<String,Object> result = writeAndMap(m, new EnabledIsGetterClass());\n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"ok\"));\n     public void testConfigChainability()\n     {\n         ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.isEnabled(MapperConfig.Feature.AUTO_DETECT_SETTERS));\n-        assertTrue(m.isEnabled(MapperConfig.Feature.AUTO_DETECT_GETTERS));\n-        m.configure(MapperConfig.Feature.AUTO_DETECT_SETTERS, false)\n-            .configure(MapperConfig.Feature.AUTO_DETECT_GETTERS, false);\n-        assertFalse(m.isEnabled(MapperConfig.Feature.AUTO_DETECT_SETTERS));\n-        assertFalse(m.isEnabled(MapperConfig.Feature.AUTO_DETECT_GETTERS));\n+        assertTrue(m.isEnabled(MapperFeature.AUTO_DETECT_SETTERS));\n+        assertTrue(m.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n+        m.configure(MapperFeature.AUTO_DETECT_SETTERS, false)\n+            .configure(MapperFeature.AUTO_DETECT_GETTERS, false);\n+        assertFalse(m.isEnabled(MapperFeature.AUTO_DETECT_SETTERS));\n+        assertFalse(m.isEnabled(MapperFeature.AUTO_DETECT_GETTERS));\n     }\n \n     // Test for [JACKSON-282]\n         assertFalse(bean.wasClosed);\n \n         // but can enable it:\n-        m.configure(SerializationConfig.Feature.CLOSE_CLOSEABLE, true);\n+        m.configure(SerializationFeature.CLOSE_CLOSEABLE, true);\n         bean = new CloseableBean();\n         m.writeValueAsString(bean);\n         assertTrue(bean.wasClosed);\n         assertEquals(quote(\"abc\"), m.writeValueAsString(chars));\n         \n         // new feature: serialize as JSON array:\n-        m.configure(SerializationConfig.Feature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS, true);\n+        m.configure(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS, true);\n         assertEquals(\"[\\\"a\\\",\\\"b\\\",\\\"c\\\"]\", m.writeValueAsString(chars));\n     }\n \n     public void testFlushingAutomatic() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE));\n+        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE));\n         // default is to flush after writeValue()\n         StringWriter sw = new StringWriter();\n         JsonGenerator jgen = mapper.getJsonFactory().createJsonGenerator(sw);\n     {\n         // but should not occur if configured otherwise\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE, false);\n+        mapper.configure(SerializationFeature.FLUSH_AFTER_WRITE_VALUE, false);\n         StringWriter sw = new StringWriter();\n         JsonGenerator jgen = mapper.getJsonFactory().createJsonGenerator(sw);\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n         // by default, should output null-valued entries:\n         assertEquals(\"{\\\"a\\\":null}\", m.writeValueAsString(map));\n         // but not if explicitly asked not to (note: config value is dynamic here)\n-        m.configure(SerializationConfig.Feature.WRITE_NULL_MAP_VALUES, false);\n+        m.configure(SerializationFeature.WRITE_NULL_MAP_VALUES, false);\n         assertEquals(\"{}\", m.writeValueAsString(map));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n \n public class TestNullSerialization\n     extends BaseMapTest\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.annotation.*;\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         // must force static typing, otherwise won't matter a lot\n-        mapper.configure(MapperConfig.Feature.USE_STATIC_TYPING, true);\n+        mapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n         SubType[] ob = new SubType[] { new SubType() };\n         String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob);\n         // should propagate interface type through due to root declaration; static typing\n     public void testRootWrapping() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.WRAP_ROOT_VALUE, true);\n+        mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);\n         String json = mapper.writeValueAsString(new StringWrapper(\"abc\"));\n         assertEquals(\"{\\\"StringWrapper\\\":{\\\"str\\\":\\\"abc\\\"}}\", json);\n     }\n     public void testRootNameAnnotation() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.configure(SerializationConfig.Feature.WRAP_ROOT_VALUE, true);\n+        mapper.configure(SerializationFeature.WRAP_ROOT_VALUE, true);\n         String json = mapper.writeValueAsString(new WithRootName());\n         assertEquals(\"{\\\"root\\\":{\\\"a\\\":3}}\", json);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for verifying that constraints on ordering of serialized\n     public void testOrderWithFeature() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.configure(MapperConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY, true);\n+        m.configure(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, true);\n         assertEquals(\"{\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":3,\\\"d\\\":4}\", serializeAsString(m, new BeanFor459()));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializerProvider.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializerProvider.java\n package com.fasterxml.jackson.databind.ser;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.SerializationConfig;\n import com.fasterxml.jackson.databind.ser.BeanSerializerFactory;\n \n public class TestSerializerProvider\n--- a/src/test/java/com/fasterxml/jackson/databind/views/TestViewDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/views/TestViewDeserialization.java\n import com.fasterxml.jackson.annotation.JsonView;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n public class TestViewDeserialization extends BaseMapTest\n {\n         assertEquals(9, bean.b);\n \n         ObjectMapper myMapper = new ObjectMapper();\n-        myMapper.disable(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION);\n+        myMapper.disable(MapperFeature.DEFAULT_VIEW_INCLUSION);\n \n         // but with, say, AA, will not get 'b'\n         bean = myMapper.readerWithView(ViewAA.class)\n--- a/src/test/java/com/fasterxml/jackson/databind/views/TestViewSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/views/TestViewSerialization.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n /**\n  * Unit tests for verifying JSON view functionality: ability to declaratively\n \n         // but can also change (but not necessarily on the fly...)\n         mapper = new ObjectMapper();\n-        mapper.configure(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION, false);\n+        mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false);\n         // with this setting, only explicit inclusions count:\n         String json = mapper.writerWithView(ViewA.class).writeValueAsString(bean);\n         map = mapper.readValue(json, Map.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/views/TestViewsSerialization2.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/views/TestViewsSerialization2.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.MapperConfig;\n \n public class TestViewsSerialization2 extends BaseMapTest\n {\n   private ObjectMapper createObjectMapper(Class<?> viewClass)\n   {\n     ObjectMapper objectMapper = new ObjectMapper( );\n-    objectMapper.configure( SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false );\n+    objectMapper.configure( SerializationFeature.FAIL_ON_EMPTY_BEANS, false );\n     objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL );\n-    objectMapper.configure(MapperConfig.Feature.DEFAULT_VIEW_INCLUSION, false );\n-//    objectMapper.getSerializationConfig( ).disable( SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION );\n+    objectMapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, false );\n+//    objectMapper.getSerializationConfig( ).disable( SerializationConfig.SerializationFeature.DEFAULT_VIEW_INCLUSION );\n //    objectMapper.getSerializationConfig( ).setSerializationView( viewClass );\n     return objectMapper;\n   }", "timestamp": 1328211008, "metainfo": ""}