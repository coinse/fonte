{"sha": "58077e9d135f0285a361a1d89b3767c5ece0095a", "log": "Ok, Object Id handling back to working as good as before refactoring, i.e. just for serialization...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n import com.fasterxml.jackson.databind.ser.std.StdKeySerializers;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n-import com.fasterxml.jackson.databind.util.ObjectIdMap;\n import com.fasterxml.jackson.databind.util.RootNameLookup;\n \n /**\n      * Helper object for keeping track of introspected root names\n      */\n     final protected RootNameLookup _rootNames;\n-\n-    /**\n-     * Container for Object Ids we may need.\n-     */\n-    protected ObjectIdMap _objectIds;\n     \n     /*\n     /**********************************************************\n \n     /*\n     /**********************************************************\n-    /* State, for non-blueprint instances\n-    /**********************************************************\n-     */\n-\n+    /* State, for non-blueprint instances: generic\n+    /**********************************************************\n+     */\n+    \n     /**\n      * For fast lookups, we will have a local non-shared read-only\n      * map that contains serializers previously fetched.\n      * (not blueprints), so that access need not be thread-safe.\n      */\n     protected DateFormat _dateFormat;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n      */\n \n     /**\n-     * Method used to try to find the Object Id for given POJO; and\n-     * if one is not found, to generate id for it.\n-     */\n-    public final Object findObjectId(Object pojo)\n-    {\n-        if (_objectIds == null) {\n-            return null;\n-        }\n-        return _objectIds.findId(pojo);\n-    }\n-\n-    public final void addObjectId(Object pojo, Object id)\n-    {\n-        if (_objectIds == null) {\n-            _objectIds = new ObjectIdMap();\n-        }\n-        _objectIds.insertId(pojo, id);\n-    }\n+     * Method called to find a {@link ObjectIdGenerator} instance to\n+     * use when specified kind of generator is needed.\n+     */\n+    public abstract ObjectIdGenerator<?> objectIdsFor(ObjectIdGenerator<?> type);\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n \n import java.io.IOException;\n \n+import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n import com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer;\n import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n     {\n         super(type, builder, properties, filteredProperties);\n     }\n-\n-    /**\n-     * Copy-constructor that is useful for sub-classes that just want to\n-     * copy all super-class properties without modifications.\n-     */\n-    protected BeanSerializer(BeanSerializer src) {\n-        super(src);\n-    }\n-\n+    \n     /**\n      * Alternate copy constructor that can be used to construct\n      * standard {@link BeanSerializer} passing an instance of\n      */\n     protected BeanSerializer(BeanSerializerBase src) {\n         super(src);\n+    }\n+\n+    protected BeanSerializer(BeanSerializerBase src, ObjectIdWriter objectIdWriter) {\n+        super(src, objectIdWriter);\n     }\n     \n     /*\n     public JsonSerializer<Object> unwrappingSerializer(NameTransformer unwrapper) {\n         return new UnwrappingBeanSerializer(this, unwrapper);\n     }\n+\n+    @Override\n+    protected BeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n+        return new BeanSerializer(this, objectIdWriter);\n+    }\n     \n     /*\n     /**********************************************************\n     public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n-        if (_objectIdHandler != null) {\n+        if (_objectIdWriter != null) {\n             serializeWithObjectId(bean, jgen, provider);\n             return;\n         }\n     private final void serializeWithObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n+        final ObjectIdWriter w = _objectIdWriter;\n         // Ok: if we have seen this POJO before, just write the reference:\n-        if (_objectIdHandler.handleReference(bean, jgen, provider)) {\n-            return;\n+        ObjectIdGenerator<?> gen = provider.objectIdsFor(_objectIdWriter.generator);\n+        Object id = gen.findId(bean);\n+        if (id == null) { // first time around: must generate\n+            id = gen.generateId(bean);\n+            // If not, need to inject the id:\n+            jgen.writeStartObject();\n+            jgen.writeFieldName(w.propertyName);\n+            w.serializer.serialize(id, jgen, provider);\n+            if (_propertyFilterId != null) {\n+                serializeFieldsFiltered(bean, jgen, provider);\n+            } else {\n+                serializeFields(bean, jgen, provider);\n+            }\n+            jgen.writeEndObject();\n+        } else { // already generated; use one we have\n+            w.serializer.serialize(id, jgen, provider);\n         }\n-        // If not, need to inject the id:\n-        jgen.writeStartObject();\n-        _objectIdHandler.writeAsProperty(bean, jgen, provider);\n-        if (_propertyFilterId != null) {\n-            serializeFieldsFiltered(bean, jgen, provider);\n-        } else {\n-            serializeFields(bean, jgen, provider);\n-        }\n-        jgen.writeEndObject();\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerBuilder.java\n      */\n     protected AnnotatedMember _typeId;\n \n-    protected ObjectIdWriter _objectIdHandler;\n+    /**\n+     * Object responsible for serializing Object Ids for the handled\n+     * type, if any.\n+     */\n+    protected ObjectIdWriter _objectIdWriter;\n     \n     /*\n     /**********************************************************\n         _typeId = idProp;\n     }\n \n-    public void setObjectIdHandler(ObjectIdWriter h) {\n-        _objectIdHandler = h;\n+    public void setObjectIdWriter(ObjectIdWriter w) {\n+        _objectIdWriter = w;\n     }\n     \n     /*\n \n     public AnnotatedMember getTypeId() { return _typeId; }\n \n-    public ObjectIdWriter getObjectIdHandler() { return _objectIdHandler; }\n+    public ObjectIdWriter getObjectIdWriter() { return _objectIdWriter; }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         processViews(config, builder);\n \n         // And if Object Id is needed, some preparation for that as well:\n-        builder.setObjectIdHandler(constructObjectIdHandler(prov, beanDesc));\n+        builder.setObjectIdWriter(constructObjectIdHandler(prov, beanDesc));\n         \n         // Finally: let interested parties mess with the result bit more...\n         if (_factoryConfig.hasSerializerModifiers()) {\n         TypeBindings typeBind = beanDesc.bindingsForBeanType();\n         for (BeanPropertyDefinition property : properties) {\n             final AnnotatedMember accessor = property.getAccessor();\n-            \n-            // [JACKSON-762]: type id? Requires special handling:\n-            if (property.isTypeId()) {\n-                if (accessor != null) { // only add if we can access... but otherwise?\n-                    if (config.canOverrideAccessModifiers()) {\n-                        accessor.fixAccess();\n-                    }\n-                    builder.setTypeId(accessor);\n-                }\n-                continue;\n-            }\n             \n             // [JACKSON-235]: suppress writing of back references\n             AnnotationIntrospector.ReferenceProperty refType = property.findReferenceType();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n package com.fasterxml.jackson.databind.ser;\n \n import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.ObjectWriter;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n-import com.fasterxml.jackson.databind.SerializationFeature;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n  */\n public abstract class DefaultSerializerProvider extends SerializerProvider\n {\n+    /*\n+    /**********************************************************\n+    /* State, for non-blueprint instances: Object Id handling\n+    /**********************************************************\n+     */\n+\n+    protected ArrayList<ObjectIdGenerator<?>> _objectIds;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n     protected DefaultSerializerProvider() { super(); }\n \n     protected DefaultSerializerProvider( SerializerProvider src,\n         super(src, config, f);\n     }\n \n-//    public abstract SerializerProviderImpl createInstance(...)\n-\n-    /*\n-    /**********************************************************\n-    /* Extends API: methods that ObjectMapper will call\n+    /*\n+    /**********************************************************\n+    /* Extended API: methods that ObjectMapper will call\n     /**********************************************************\n      */\n \n     public void flushCachedSerializers() {\n         _serializerCache.flush();\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Life-cycle\n+\n+    /*\n+    /**********************************************************\n+    /* Object Id handling\n+    /**********************************************************\n+     */\n+\n+    public final ObjectIdGenerator<?> objectIdsFor(ObjectIdGenerator<?> blueprint)\n+    {\n+        if (_objectIds != null) {\n+            for (int i = 0, len = _objectIds.size(); i < len; ++i) {\n+                ObjectIdGenerator<?> gen = _objectIds.get(i);\n+                if (gen.canUseFor(blueprint)) {\n+                    return gen;\n+                }\n+            }\n+        }\n+        // not yet constructed; construct, append\n+        if (_objectIds == null) {\n+            _objectIds = new ArrayList<ObjectIdGenerator<?>>(8);\n+        }\n+        ObjectIdGenerator<?> gen = blueprint.newForSerialization();\n+        _objectIds.add(gen);\n+        return gen;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n     /**********************************************************\n      */\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/ObjectIdWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ObjectIdWriter.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n-import java.io.IOException;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n \n-import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.*;\n \n /**\n  * Object that knows how to serialize Object Ids.\n  */\n-public class ObjectIdWriter\n+public final class ObjectIdWriter\n {\n-    protected final JavaType _idType;\n+    public final JavaType idType;\n \n-    protected final String _propertyName;\n+    public final SerializedString propertyName;\n     \n-    protected final ObjectIdGenerator<?> _generator;\n-\n     /**\n-     * Logical property that represents the id.\n+     * Blueprint generator instance: actual instance will be\n+     * fetched from {@link SerializerProvider} using this as\n+     * the key.\n      */\n-//    protected final BeanProperty _property;\n+    public final ObjectIdGenerator<?> generator;\n     \n     /**\n      * Serializer used for serializing id values.\n      */\n-    protected final JsonSerializer<Object> _serializer;\n+    public final JsonSerializer<Object> serializer;\n     \n     /*\n     /**********************************************************\n      */\n     \n     @SuppressWarnings(\"unchecked\")\n-    protected ObjectIdWriter(JavaType idType, String propName, ObjectIdGenerator<?> gen,\n+    protected ObjectIdWriter(JavaType t, SerializedString propName, ObjectIdGenerator<?> gen,\n             JsonSerializer<?> ser)\n     {\n-        _idType = idType;\n-        _propertyName = propName;\n-        _generator = gen;\n-        _serializer = (JsonSerializer<Object>) ser;\n+        idType = t;\n+        propertyName = propName;\n+        generator = gen;\n+        serializer = (JsonSerializer<Object>) ser;\n     }\n \n     /**\n      * with the initial information based on standard settings for the type\n      * for which serializer is being built.\n      */\n-    public static ObjectIdWriter construct(JavaType idType, String propertyName,\n+    public static ObjectIdWriter construct(JavaType idType, String propName,\n             ObjectIdGenerator<?> generator)\n     {\n-        return new ObjectIdWriter(idType, propertyName, generator, null);\n+        return new ObjectIdWriter(idType, new SerializedString(propName), generator, null);\n     }\n \n-    public ObjectIdWriter withSerializer(SerializerProvider provider)\n-        throws JsonMappingException\n-    {\n-        JsonSerializer<?> ser = provider.findValueSerializer(_idType, null);\n-        return new ObjectIdWriter(_idType, _propertyName, _generator, ser);\n+    public ObjectIdWriter withSerializer(JsonSerializer<?> ser) {\n+        return new ObjectIdWriter(idType, propertyName, generator, ser);\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Accessors\n-    /**********************************************************\n-     */\n-\n-    public JavaType getType() { return _idType; }\n-    public String getPropertyName() { return _propertyName; }\n-    \n-    /*\n-    /**********************************************************\n-    /* Serialization API\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Method called to see if we could possibly just write a reference to previously\n-     * serialized POJO.\n-     */\n-    public boolean handleReference(Object pojo, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n-    {\n-        Object id = provider.findObjectId(pojo);\n-        // if it has been serialized, just write reference:\n-        if (id == null) {\n-            return false;\n-        }\n-        _serializer.serialize(id, jgen, provider);\n-        return true;\n-    }        \n-\n-    /**\n-     * Method called to write Object Id as regular property, in case where POJO\n-     * has not yet been serialized.\n-     */\n-    public void writeAsProperty(Object pojo, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n-    {\n-        Object id = _generator.generateId(pojo);\n-        provider.addObjectId(pojo, id);\n-        // if it has been serialized, just write reference:\n-        jgen.writeFieldName(_propertyName);\n-        _serializer.serialize(id, jgen, provider);\n-    }        \n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n         _nameTransformer = transformer;\n     }\n \n+    public UnwrappingBeanSerializer(UnwrappingBeanSerializer src, ObjectIdWriter objectIdWriter) {    \n+        super(src, objectIdWriter);\n+        _nameTransformer = src._nameTransformer;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle: factory methods, fluent factories\n     @Override\n     public boolean isUnwrappingSerializer() {\n         return true; // sure is\n+    }\n+\n+    @Override\n+    protected UnwrappingBeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n+        return new UnwrappingBeanSerializer(this, objectIdWriter);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n import java.io.IOException;\n import java.lang.reflect.Type;\n \n+import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n      * annotated properties\n      */\n     final protected AnyGetterWriter _anyGetterWriter;\n-\n+    \n+    /**\n+     * Id of the bean property filter to use, if any; null if none.\n+     */\n+    final protected Object _propertyFilterId;\n+\n+    /**\n+     * If using custom type ids (usually via getter, or field), this is the\n+     * reference to that member.\n+     */\n+    final protected AnnotatedMember _typeId;\n+    \n     /**\n      * If this POJO can be alternatively serialized using just an object id\n      * to denote a reference to previously serialized object,\n      * this Object will handle details.\n      *<p>\n      * Note: not final since we need to get contextual instance during\n-     * resolutuon.\n-     */\n-    protected ObjectIdWriter _objectIdHandler;\n-    \n-    /**\n-     * If using custom type ids (usually via getter, or field), this is the\n-     * reference to that member.\n-     */\n-    final protected AnnotatedMember _typeId;\n-    \n-    /**\n-     * Id of the bean property filter to use, if any; null if none.\n-     */\n-    final protected Object _propertyFilterId;\n+     * resolution.\n+     */\n+    protected final ObjectIdWriter _objectIdWriter;\n     \n     /*\n     /**********************************************************\n         _props = properties;\n         _filteredProps = filteredProperties;\n         if (builder == null) { // mostly for testing\n-            _objectIdHandler = null;\n             _typeId = null;\n+            _anyGetterWriter = null;\n             _propertyFilterId = null;\n-            _anyGetterWriter = null;\n-        } else {\n+            _objectIdWriter = null;\n+        } else {\n+            _typeId = builder.getTypeId();\n             _anyGetterWriter = builder.getAnyGetter();\n-            _typeId = builder.getTypeId();\n             _propertyFilterId = builder.getFilterId();\n-            _objectIdHandler = builder.getObjectIdHandler();\n+            _objectIdWriter = builder.getObjectIdWriter();\n         }\n     }\n \n         super(src._handledType);\n         _props = properties;\n         _filteredProps = filteredProperties;\n+\n+        _typeId = src._typeId;\n+        _anyGetterWriter = src._anyGetterWriter;\n+        _objectIdWriter = src._objectIdWriter;\n+        _propertyFilterId = src._propertyFilterId;\n+    }\n+\n+    protected BeanSerializerBase(BeanSerializerBase src, ObjectIdWriter objectIdWriter)\n+    {\n+        super(src._handledType);\n+        _props = src._props;\n+        _filteredProps = src._filteredProps;\n         \n+        _typeId = src._typeId;\n         _anyGetterWriter = src._anyGetterWriter;\n-        _objectIdHandler = src._objectIdHandler;\n-        _typeId = src._typeId;\n+        _objectIdWriter = objectIdWriter;\n         _propertyFilterId = src._propertyFilterId;\n-        _objectIdHandler = src._objectIdHandler;\n-    }\n-\n+    }\n+\n+    /**\n+     * Fluent factory used for creating a new instance with different\n+     * {@link ObjectIdWriter}.\n+     */\n+    protected abstract BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter);\n+    \n     /**\n      * Copy-constructor that is useful for sub-classes that just want to\n      * copy all super-class properties without modifications.\n     protected BeanSerializerBase(BeanSerializerBase src, NameTransformer unwrapper) {\n         this(src, rename(src._props, unwrapper), rename(src._filteredProps, unwrapper));\n     }\n-\n+    \n     private final static BeanPropertyWriter[] rename(BeanPropertyWriter[] props,\n             NameTransformer transformer)\n     {\n         if (_anyGetterWriter != null) {\n             _anyGetterWriter.resolve(provider);\n         }\n-        // and ObjectIdHandler resolved, if there is one\n-        if (_objectIdHandler != null) {\n-            _objectIdHandler = _objectIdHandler.withSerializer(provider);\n-        }\n-    }\n-\n-    @Override\n-    public JsonSerializer<?> createContextual(SerializerProvider prov,\n+    }\n+\n+    @Override\n+    public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n     {\n-        // Can't have any overrides for root values, so:\n-        if (property == null) {\n-            return this;\n-        }\n-\n-        /* Ok: here we may need to override ObjectIdHandler, if referring\n-         * property happens to redefine it.\n-         */\n-        final AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n-        AnnotatedMember accessor = property.getMember();\n-        ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n-        if (objectIdInfo != null) {\n-            // !!! TODO: copy stuff from BeanSerializerFactory.constructObjectIdHandler(...)\n-            // ObjectIdGenerator<?> gen = prov.objectIdGeneratorInstance(property.getMember(), objectIdInfo.getGenerator());\n+        ObjectIdWriter oiw = _objectIdWriter;\n+        \n+        // First: may have an override for Object Id:\n+        if (property != null) {\n+            final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+            final AnnotatedMember accessor = property.getMember();\n+            final ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n+            if (objectIdInfo != null) {\n+                /* Ugh: mostly copied from BeanSerializerBase: but can't easily\n+                 * change it to be able to move to SerializerProvider (where it\n+                 * really belongs)\n+                 */\n+                ObjectIdGenerator<?> gen;\n+                Class<?> implClass = objectIdInfo.getGenerator();\n+                JavaType type = provider.constructType(implClass);\n+                JavaType idType = provider.getTypeFactory().findTypeParameters(type, ObjectIdGenerator.class)[0];\n+                // Property-based generator is trickier\n+                if (implClass == ObjectIdGenerators.PropertyGenerator.class) {\n+                    // !!! TODO\n+                    gen = null;\n+                    if (true) throw new IllegalStateException(\"Not yet implemented!\");\n+                } else { // other types need to be simpler\n+                    gen = provider.objectIdGeneratorInstance(accessor, implClass);\n+                }\n+                oiw = ObjectIdWriter.construct(idType, objectIdInfo.getProperty(), gen);\n+\n+            }\n+        }\n+        // either way, need to resolve serializer:\n+        if (oiw != null) {\n+            JsonSerializer<?> ser = provider.findValueSerializer(oiw.idType, property);\n+            oiw = oiw.withSerializer(ser);\n+            if (oiw != _objectIdWriter) {\n+                return withObjectIdWriter(oiw);\n+            }\n         }\n         return this;\n     }\n \n     @Override\n     public boolean usesObjectId() {\n-        return (_objectIdHandler != null);\n+        return (_objectIdWriter != null);\n     }\n     \n     // Main serialization method left unimplemented\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectId.java\n             value = v;\n         }\n     }\n+\n+    static class IdWrapper\n+    {\n+        @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"@id\")\n+        public ValueNode node;\n+\n+        public IdWrapper() { }\n+        public IdWrapper(int v) {\n+            node = new ValueNode(v);\n+        }\n+    }\n+\n+    static class ValueNode {\n+        public int value;\n+        public IdWrapper next;\n+        \n+        public ValueNode() { this(0); }\n+        public ValueNode(int v) { value = v; }\n+    }\n     \n     /*\n     /*****************************************************\n-    /* Unit tests\n+    /* Unit tests; simple class annotation\n     /*****************************************************\n      */\n \n+    private final static String EXP_SIMPLE_INT_CLASS = \"{\\\"id\\\":1,\\\"value\\\":13,\\\"next\\\":1}\";\n+    \n     private final ObjectMapper mapper = new ObjectMapper();\n     \n-    public void testSimpleCyclicSerialization() throws Exception\n+    public void testSimpleSerializationClass() throws Exception\n     {\n         Identifiable src = new Identifiable(13);\n         src.next = src;\n         \n         // First, serialize:\n         String json = mapper.writeValueAsString(src);\n-        assertEquals(\"{\\\"id\\\":1,\\\"value\\\":13,\\\"next\\\":1}\", json);\n+        assertEquals(EXP_SIMPLE_INT_CLASS, json);\n+\n+        // and ensure that state is cleared in-between as well:\n+        json = mapper.writeValueAsString(src);\n+        assertEquals(EXP_SIMPLE_INT_CLASS, json);\n     }\n         \n-    public void testSimpleCyclicDeserialization() throws Exception\n+    public void testSimpleDeserializationClass() throws Exception\n     {\n         // then bring back...\n-        String input = \"{\\\"id\\\":1,\\\"value\\\":13,\\\"next\\\":1}\";\n-        Identifiable result = mapper.readValue(input, Identifiable.class);\n+        Identifiable result = mapper.readValue(EXP_SIMPLE_INT_CLASS, Identifiable.class);\n         assertEquals(13, result.value);\n-//        assertEquals(1, result.id);\n         assertSame(result, result.next);\n     }\n+\n+    /*\n+    /*****************************************************\n+    /* Unit tests; simple property annotation\n+    /*****************************************************\n+     */\n+\n+    // Bit more complex, due to extra wrapping etc:\n+    private final static String EXP_SIMPLE_INT_PROP = \"{\\\"node\\\":{\\\"@id\\\":1,\\\"value\\\":7,\\\"next\\\":{\\\"node\\\":1}}}\";\n+    \n+    public void testSimpleSerializationProperty() throws Exception\n+    {\n+        IdWrapper src = new IdWrapper(7);\n+        src.node.next = src;\n+        \n+        // First, serialize:\n+        String json = mapper.writeValueAsString(src);\n+        assertEquals(EXP_SIMPLE_INT_PROP, json);\n+        // and second time too, for a good measure\n+        json = mapper.writeValueAsString(src);\n+        assertEquals(EXP_SIMPLE_INT_PROP, json);\n+    }\n+        \n+    public void testSimpleDeserializationProperty() throws Exception\n+    {\n+        // then bring back...\n+        IdWrapper result = mapper.readValue(EXP_SIMPLE_INT_PROP, IdWrapper.class);\n+        assertEquals(7, result.node.value);\n+        assertSame(result, result.node.next);\n+    }\n+\n+\n }", "timestamp": 1328672853, "metainfo": ""}