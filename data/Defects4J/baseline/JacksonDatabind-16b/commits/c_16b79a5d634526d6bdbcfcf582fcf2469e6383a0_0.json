{"sha": "16b79a5d634526d6bdbcfcf582fcf2469e6383a0", "log": "minor javadoc cleanup", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * event is a value event, not container).\n      *\n      * @param source URL to use for fetching contents to parse as JSON for building a tree instance\n-     *\n-     * @since 1.9\n      */\n     public JsonNode readTree(URL source)\n         throws IOException, JsonProcessingException\n      * Method that can be used to serialize any Java value as\n      * JSON output, using provided {@link JsonGenerator},\n      * configured as per passed configuration object.\n-     *\n-     * @since 1.1\n      */\n     public void writeValue(JsonGenerator jgen, Object value, SerializationConfig config)\n         throws IOException, JsonGenerationException, JsonMappingException\n     /**\n      * Method to serialize given Json Tree, using generator\n      * provided.\n-     *\n-     * @since 1.1\n      */\n     public void writeTree(JsonGenerator jgen, JsonNode rootNode,\n                           SerializationConfig cfg)\n      * abstraction can not refer to concrete node types (as it's\n      * part of core package, whereas impls are part of mapper\n      * package)\n-     *\n-     * @since 1.2\n      */\n     @Override    \n     public ObjectNode createObjectNode() {\n      * abstraction can not refer to concrete node types (as it's\n      * part of core package, whereas impls are part of mapper\n      * package)\n-     *\n-     * @since 1.2\n      */\n     @Override\n     public ArrayNode createArrayNode() {\n      * representation.\n      * \n      * @param n Root node of the tree that resulting parser will read from\n-     * \n-     * @since 1.3\n      */\n     @Override\n     public JsonParser treeAsTokens(JsonNode n)\n         return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), valueType);\n     } \n \n-    /**\n-     * @since 1.8\n-     */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(byte[] src, Class<T> valueType)\n         throws IOException, JsonParseException, JsonMappingException\n         return (T) _readMapAndClose(_jsonFactory.createJsonParser(src, offset, len), _typeFactory.constructType(valueType));\n     } \n \n-    /**\n-     * @since 1.8\n-     */\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     public <T> T readValue(byte[] src, TypeReference valueTypeRef)\n         throws IOException, JsonParseException, JsonMappingException\n         return (T) _readMapAndClose(_jsonFactory.createJsonParser(src, offset, len), _typeFactory.constructType(valueTypeRef));\n     } \n \n-    /**\n-     * @since 1.8\n-     */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(byte[] src, JavaType valueType)\n         throws IOException, JsonParseException, JsonMappingException\n      *<pre>\n      *   mapper.readValue(mapper.treeAsTokens(root), valueType);\n      *</pre>\n-     *\n-     * @since 1.6\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(JsonNode root, Class<T> valueType)\n      *<pre>\n      *   mapper.readValue(mapper.treeAsTokens(root), valueType);\n      *</pre>\n-     *\n-     * @since 1.6\n      */\n     @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n     public <T> T readValue(JsonNode root, TypeReference valueTypeRef)\n      *<pre>\n      *   mapper.readValue(mapper.treeAsTokens(root), valueType);\n      *</pre>\n-     *\n-     * @since 1.6\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(JsonNode root, JavaType valueType)\n      * a String. Functionally equivalent to calling\n      * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n      * and constructing String, but more efficient.\n-     *\n-     * @since 1.3\n      */\n     public String writeValueAsString(Object value)\n         throws IOException, JsonGenerationException, JsonMappingException\n      * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}\n      * and getting bytes, but more efficient.\n      * Encoding used will be UTF-8.\n-     *\n-     * @since 1.5\n      */\n     public byte[] writeValueAsBytes(Object value)\n         throws IOException, JsonGenerationException, JsonMappingException\n     /**\n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n-     * \n-     * @since 1.6\n      */\n     public ObjectReader reader(JavaType type)\n     {\n     /**\n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n-     * \n-     * @since 1.6\n      */\n     public ObjectReader reader(Class<?> type)\n     {\n     /**\n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n-     * \n-     * @since 1.6\n      */\n     public ObjectReader reader(TypeReference<?> type)\n     {\n     /**\n      * Factory method for constructing {@link ObjectReader} that will\n      * use specified {@link JsonNodeFactory} for constructing JSON trees.\n-     * \n-     * @since 1.6\n      */\n     public ObjectReader reader(JsonNodeFactory f)\n     {\n      * reading content.\n      * \n      * @param schema Schema to pass to parser\n-     * \n-     * @since 1.8\n      */\n     public ObjectReader reader(FormatSchema schema) {\n         return new ObjectReader(this, copyDeserializationConfig(), null, null,\n      * Helper method that should return default pretty-printer to\n      * use for generators constructed by this mapper, when instructed\n      * to use default pretty printer.\n-     * \n-     * @since 1.7\n      */\n     protected PrettyPrinter _defaultPrettyPrinter() {\n         return new DefaultPrettyPrinter();", "timestamp": 1326563846, "metainfo": ""}