{"sha": "257ae1c7a88c5ccec2882433a39c0df1de2b73aa", "log": "Fix #660", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n                     AnnotatedParameter arg = ctor.getParameter(0);\n                     properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, arg,\n                             intr.findInjectableValueId(arg));\n-                    creators.addPropertyCreator(ctor, properties);\n+                    creators.addPropertyCreator(ctor, isCreator, properties);\n                 } else {\n                     /*boolean added = */ _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n                             ctor, isCreator,\n             if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                 // simple case; everything covered:\n                 if ((namedCount + injectCount) == argCount) {\n-                    creators.addPropertyCreator(ctor, properties);\n+                    creators.addPropertyCreator(ctor, isCreator, properties);\n                 } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                     // [712] secondary: all but one injectable, one un-annotated (un-named)\n-                    creators.addDelegatingCreator(ctor, properties);\n+                    creators.addDelegatingCreator(ctor, isCreator, properties);\n                 } else { // otherwise, epic fail\n                     throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                             +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n     {\n         // otherwise either 'simple' number, String, or general delegate:\n         Class<?> type = ctor.getRawParameterType(0);\n-        if (type == String.class) {\n+        if (type == String.class || type == CharSequence.class) {\n             if (isCreator || isVisible) {\n-                creators.addStringCreator(ctor);\n+                creators.addStringCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         if (type == int.class || type == Integer.class) {\n             if (isCreator || isVisible) {\n-                creators.addIntCreator(ctor);\n+                creators.addIntCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         if (type == long.class || type == Long.class) {\n             if (isCreator || isVisible) {\n-                creators.addLongCreator(ctor);\n+                creators.addLongCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         if (type == double.class || type == Double.class) {\n             if (isCreator || isVisible) {\n-                creators.addDoubleCreator(ctor);\n+                creators.addDoubleCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         if (type == boolean.class || type == Boolean.class) {\n             if (isCreator || isVisible) {\n-                creators.addBooleanCreator(ctor);\n+                creators.addBooleanCreator(ctor, isCreator);\n             }\n             return true;\n         }\n         // Delegating Creator ok iff it has @JsonCreator (etc)\n         if (isCreator) {\n-            creators.addDelegatingCreator(ctor, null);\n+            creators.addDelegatingCreator(ctor, isCreator, null);\n             return true;\n         }\n         return false;\n             if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                 // simple case; everything covered:\n                 if ((namedCount + injectCount) == argCount) {\n-                    creators.addPropertyCreator(factory, properties);\n+                    creators.addPropertyCreator(factory, isCreator, properties);\n                 } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                     // [712] secondary: all but one injectable, one un-annotated (un-named)\n-                    creators.addDelegatingCreator(factory, properties);\n+                    creators.addDelegatingCreator(factory, isCreator, properties);\n                 } else { // otherwise, epic fail\n                     throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n                             +\" of factory method \"+factory+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n     {\n         Class<?> type = factory.getRawParameterType(0);\n         \n-        if (type == String.class) {\n+        if (type == String.class || type == CharSequence.class) {\n             if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addStringCreator(factory);\n+                creators.addStringCreator(factory, isCreator);\n             }\n             return true;\n         }\n         if (type == int.class || type == Integer.class) {\n             if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addIntCreator(factory);\n+                creators.addIntCreator(factory, isCreator);\n             }\n             return true;\n         }\n         if (type == long.class || type == Long.class) {\n             if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addLongCreator(factory);\n+                creators.addLongCreator(factory, isCreator);\n             }\n             return true;\n         }\n         if (type == double.class || type == Double.class) {\n             if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addDoubleCreator(factory);\n+                creators.addDoubleCreator(factory, isCreator);\n             }\n             return true;\n         }\n         if (type == boolean.class || type == Boolean.class) {\n             if (isCreator || vchecker.isCreatorVisible(factory)) {\n-                creators.addBooleanCreator(factory);\n+                creators.addBooleanCreator(factory, isCreator);\n             }\n             return true;\n         }\n         if (isCreator) {\n-            creators.addDelegatingCreator(factory, null);\n+            creators.addDelegatingCreator(factory, isCreator, null);\n             return true;\n         }\n         return false;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n  */\n public class CreatorCollector\n {\n+    // Since 2.5\n+    protected final static int C_DEFAULT = 0;\n+    protected final static int C_STRING = 1;\n+    protected final static int C_INT = 2;\n+    protected final static int C_LONG = 3;\n+    protected final static int C_DOUBLE = 4;\n+    protected final static int C_BOOLEAN = 5;\n+    protected final static int C_DELEGATE = 6;\n+    protected final static int C_PROPS = 7;\n+\n+    protected final static String[] TYPE_DESCS = new String[] {\n+        \"default\",\n+        \"String\", \"int\", \"long\", \"double\", \"boolean\",\n+        \"delegate\", \"property-based\"\n+    };\n+\n     /// Type of bean being created\n     final protected BeanDescription _beanDesc;\n \n     final protected boolean _canFixAccess;\n \n     /**\n-     * Reference to the default creator (constructor or factory method).\n-     *<p>\n-     * Note: name is a misnomer, after resolving of [JACKSON-850], since this\n-     * can also point to factory method.\n-     */\n-    protected AnnotatedWithParams _defaultConstructor;\n-    \n-    protected AnnotatedWithParams _stringCreator, _intCreator, _longCreator;\n-    protected AnnotatedWithParams _doubleCreator, _booleanCreator;\n-\n-    protected AnnotatedWithParams _delegateCreator;\n+     * Set of creators we have collected so far\n+     * \n+     * @since 2.5\n+     */\n+    protected final AnnotatedWithParams[] _creators = new AnnotatedWithParams[8];\n+\n+    /**\n+     * Bitmask of creators that were explicitly marked as creators; false for auto-detected\n+     * (ones included base on naming and/or visibility, not annotation)\n+     * \n+     * @since 2.5\n+     */\n+    protected int _explicitCreators = 0;\n+    \n+    protected boolean _hasNonDefaultCreator = false;\n+    \n     // when there are injectable values along with delegate:\n     protected CreatorProperty[] _delegateArgs;\n     \n-    protected AnnotatedWithParams _propertyBasedCreator;\n-    protected CreatorProperty[] _propertyBasedArgs = null;\n+    protected CreatorProperty[] _propertyBasedArgs;\n \n     protected AnnotatedParameter _incompleteParameter;\n \n     public ValueInstantiator constructValueInstantiator(DeserializationConfig config)\n     {\n         JavaType delegateType;\n-        boolean maybeVanilla = _delegateCreator == null;\n-        \n-        if (maybeVanilla) {\n+        boolean maybeVanilla = !_hasNonDefaultCreator;\n+\n+        if (maybeVanilla || (_creators[C_DELEGATE] == null)) {\n             delegateType = null;\n         } else {\n             // need to find type...\n                 }\n             }\n             TypeBindings bindings = _beanDesc.bindingsForBeanType();\n-            delegateType = bindings.resolveType(_delegateCreator.getGenericParameterType(ix));\n+            delegateType = bindings.resolveType(_creators[C_DELEGATE].getGenericParameterType(ix));\n         }\n \n         final JavaType type = _beanDesc.getType();\n \n         // Any non-standard creator will prevent; with one exception: int-valued constructor\n         // that standard containers have can be ignored\n-        maybeVanilla &= (_propertyBasedCreator == null)\n-                && (_delegateCreator == null)\n-                && (_stringCreator == null)\n-                && (_longCreator == null)\n-                && (_doubleCreator == null)\n-                && (_booleanCreator == null)\n-                ;\n+        maybeVanilla &= !_hasNonDefaultCreator;\n \n         if (maybeVanilla) {\n             /* 10-May-2014, tatu: If we have nothing special, and we are dealing with one\n         }\n         \n         StdValueInstantiator inst = new StdValueInstantiator(config, type);\n-        inst.configureFromObjectSettings(_defaultConstructor,\n-                _delegateCreator, delegateType, _delegateArgs,\n-                _propertyBasedCreator, _propertyBasedArgs);\n-        inst.configureFromStringCreator(_stringCreator);\n-        inst.configureFromIntCreator(_intCreator);\n-        inst.configureFromLongCreator(_longCreator);\n-        inst.configureFromDoubleCreator(_doubleCreator);\n-        inst.configureFromBooleanCreator(_booleanCreator);\n+        inst.configureFromObjectSettings(_creators[C_DEFAULT],\n+                _creators[C_DELEGATE], delegateType, _delegateArgs,\n+                _creators[C_PROPS], _propertyBasedArgs);\n+        inst.configureFromStringCreator(_creators[C_STRING]);\n+        inst.configureFromIntCreator(_creators[C_INT]);\n+        inst.configureFromLongCreator(_creators[C_LONG]);\n+        inst.configureFromDoubleCreator(_creators[C_DOUBLE]);\n+        inst.configureFromBooleanCreator(_creators[C_BOOLEAN]);\n         inst.configureIncompleteParameter(_incompleteParameter);\n         return inst;\n     }\n      *   factory method.\n      */\n     public void setDefaultCreator(AnnotatedWithParams creator) {\n-        _defaultConstructor = _fixAccess(creator);\n-    }\n-    \n-    public void addStringCreator(AnnotatedWithParams creator) {\n-        _stringCreator = verifyNonDup(creator, _stringCreator, \"String\");\n-    }\n-    public void addIntCreator(AnnotatedWithParams creator) {\n-        _intCreator = verifyNonDup(creator, _intCreator, \"int\");\n-    }\n-    public void addLongCreator(AnnotatedWithParams creator) {\n-        _longCreator = verifyNonDup(creator, _longCreator, \"long\");\n-    }\n-    public void addDoubleCreator(AnnotatedWithParams creator) {\n-        _doubleCreator = verifyNonDup(creator, _doubleCreator, \"double\");\n-    }\n-    public void addBooleanCreator(AnnotatedWithParams creator) {\n-        _booleanCreator = verifyNonDup(creator, _booleanCreator, \"boolean\");\n-    }\n-\n-    public void addDelegatingCreator(AnnotatedWithParams creator,\n+        _creators[C_DEFAULT] = _fixAccess(creator);\n+    }\n+    \n+    public void addStringCreator(AnnotatedWithParams creator, boolean explicit) {\n+        verifyNonDup(creator, C_STRING, explicit);\n+    }\n+    public void addIntCreator(AnnotatedWithParams creator, boolean explicit) {\n+        verifyNonDup(creator, C_INT, explicit);\n+    }\n+    public void addLongCreator(AnnotatedWithParams creator, boolean explicit) {\n+        verifyNonDup(creator, C_LONG, explicit);\n+    }\n+    public void addDoubleCreator(AnnotatedWithParams creator, boolean explicit) {\n+        verifyNonDup(creator, C_DOUBLE, explicit);\n+    }\n+    public void addBooleanCreator(AnnotatedWithParams creator, boolean explicit) {\n+        verifyNonDup(creator, C_BOOLEAN, explicit);\n+    }\n+\n+    public void addDelegatingCreator(AnnotatedWithParams creator, boolean explicit,\n             CreatorProperty[] injectables)\n     {\n-        _delegateCreator = verifyNonDup(creator, _delegateCreator, \"delegate\");\n+        verifyNonDup(creator, C_DELEGATE, explicit);\n         _delegateArgs = injectables;\n     }\n     \n-    public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties)\n-    {\n-        _propertyBasedCreator = verifyNonDup(creator, _propertyBasedCreator, \"property-based\");\n+    public void addPropertyCreator(AnnotatedWithParams creator, boolean explicit,\n+            CreatorProperty[] properties)\n+    {\n+        verifyNonDup(creator, C_PROPS, explicit);\n         // [JACKSON-470] Better ensure we have no duplicate names either...\n         if (properties.length > 1) {\n             HashMap<String,Integer> names = new HashMap<String,Integer>();\n         }\n     }\n \n+    // Bunch of methods deprecated in 2.5, to be removed from 2.6 or later\n+    \n+    @Deprecated // since 2.5\n+    public void addStringCreator(AnnotatedWithParams creator) {\n+        addStringCreator(creator, false);\n+    }\n+    @Deprecated // since 2.5\n+    public void addIntCreator(AnnotatedWithParams creator) {\n+        addBooleanCreator(creator, false);\n+    }\n+    @Deprecated // since 2.5\n+    public void addLongCreator(AnnotatedWithParams creator) {\n+        addBooleanCreator(creator, false);\n+    }\n+    @Deprecated // since 2.5\n+    public void addDoubleCreator(AnnotatedWithParams creator) {\n+        addBooleanCreator(creator, false);\n+    }\n+    @Deprecated // since 2.5\n+    public void addBooleanCreator(AnnotatedWithParams creator) {\n+        addBooleanCreator(creator, false);\n+    }\n+\n+    @Deprecated // since 2.5\n+    public void addDelegatingCreator(AnnotatedWithParams creator, CreatorProperty[] injectables) {\n+        addDelegatingCreator(creator, false, injectables);\n+    }\n+\n+    @Deprecated // since 2.5\n+    public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties) {\n+        addPropertyCreator(creator, false, properties);\n+    }\n+\n+    @Deprecated // since 2.5, remove from 2.6\n+    protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, int typeIndex) {\n+        verifyNonDup(newOne, typeIndex, false);\n+        return _creators[typeIndex];\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Accessors\n      * @since 2.1\n      */\n     public boolean hasDefaultCreator() {\n-        return _defaultConstructor != null;\n+        return _creators[C_DEFAULT] != null;\n     }\n \n     /*\n         return member;\n     }\n \n-    protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, AnnotatedWithParams oldOne,\n-            String type)\n-    {\n+    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n+    {\n+        final int mask = (1 << typeIndex);\n+        _hasNonDefaultCreator = true;\n+        AnnotatedWithParams oldOne = _creators[typeIndex];\n+        // already had an explicitly marked one?\n         if (oldOne != null) {\n-            // important: ok to override factory with constructor; but not within same type, so:\n+            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n+                // but skip, if new one not annotated\n+                if (!explicit) {\n+                    return;\n+                }\n+            }\n+            // one more thing: ok to override in sub-class\n             if (oldOne.getClass() == newOne.getClass()) {\n-                throw new IllegalArgumentException(\"Conflicting \"+type+\" creators: already had \"+oldOne+\", encountered \"+newOne);\n-            }\n-        }\n-        return _fixAccess(newOne);\n+                throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n+                        +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n+            }\n+        }\n+        if (explicit) {\n+            _explicitCreators |= mask;\n+        }\n+        _creators[typeIndex] = _fixAccess(newOne);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n public class BeanSerializer\n     extends BeanSerializerBase\n {\n+    private static final long serialVersionUID = -4536893235025590367L;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle: constructors\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n public class BeanAsArraySerializer\n     extends BeanSerializerBase\n {\n+    private static final long serialVersionUID = -893701886577615846L;\n+\n     /**\n      * Serializer that would produce JSON Object version; used in\n      * cases where array output can not be used.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n public class UnwrappingBeanSerializer\n     extends BeanSerializerBase\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /**\n      * Transformer used to add prefix and/or suffix for properties\n      * of unwrapped POJO.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BooleanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BooleanSerializer.java\n import java.io.IOException;\n import java.lang.reflect.Type;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n+\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonNode;\n public final class BooleanSerializer\n     extends NonTypedScalarSerializerBase<Boolean>\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /**\n      * Whether type serialized is primitive (boolean) or wrapper\n      * (java.lang.Boolean); if true, former, if false, latter.\n     }\n \n     @Override\n-    public void serialize(Boolean value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n+    public void serialize(Boolean value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         jgen.writeBoolean(value.booleanValue());\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteBufferSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ByteBufferSerializer.java\n import java.nio.ByteBuffer;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.util.ByteBufferBackedInputStream;\n \n+@SuppressWarnings(\"serial\")\n public class ByteBufferSerializer extends StdScalarSerializer<ByteBuffer>\n {\n     public ByteBufferSerializer() { super(ByteBuffer.class); }\n \n     @Override\n-    public void serialize(ByteBuffer bbuf, JsonGenerator gen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serialize(ByteBuffer bbuf, JsonGenerator gen, SerializerProvider provider) throws IOException\n     {\n         // first, simple case when wrapping an array...\n         if (bbuf.hasArray()) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n import java.util.Calendar;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n  * (standard Java 64-bit timestamp) or textual formats (usually ISO-8601).\n  */\n @JacksonStdImpl\n+@SuppressWarnings(\"serial\")\n public class CalendarSerializer\n     extends DateTimeSerializerBase<Calendar>\n {\n     }\n \n     @Override\n-    public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n         if (_asTimestamp(provider)) {\n             jgen.writeNumber(_timestamp(value));\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n  * @deprecated Since 2.4.4; standard {@link MapSerializer} works better.\n  *   (to be removed from 2.6)\n  */\n+@SuppressWarnings(\"serial\")\n @JacksonStdImpl\n @Deprecated\n public class EnumMapSerializer\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n     extends StdScalarSerializer<Enum<?>>\n     implements ContextualSerializer\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /**\n      * This map contains pre-resolved values (since there are ways\n      * to customize actual String constants to use) to use as\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n+@SuppressWarnings(\"serial\")\n public class EnumSetSerializer\n     extends AsArraySerializerBase<EnumSet<? extends Enum<?>>>\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/InetSocketAddressSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/InetSocketAddressSerializer.java\n /**\n  * Simple serializer for {@link InetSocketAddress}.\n  */\n+@SuppressWarnings(\"serial\")\n public class InetSocketAddressSerializer\n     extends StdScalarSerializer<InetSocketAddress>\n {\n     public InetSocketAddressSerializer() { super(InetSocketAddress.class); }\n \n     @Override\n-    public void serialize(InetSocketAddress value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException\n+    public void serialize(InetSocketAddress value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n         InetAddress addr = value.getAddress();\n         String str = addr == null ? value.getHostName() : addr.toString().trim();\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java\n     }\n \n     // [databind#660]\n-    static class ExplicitFactoryBean1 {\n+    static class ExplicitFactoryBeanA {\n         private String value;\n \n-        private ExplicitFactoryBean1(String str) {\n-            value = null;\n+        private ExplicitFactoryBeanA(String str) {\n+            throw new IllegalStateException(\"Should not get called!\");\n         }\n \n-        private ExplicitFactoryBean1(String str, boolean b) {\n+        private ExplicitFactoryBeanA(String str, boolean b) {\n             value = str;\n         }\n \n         @JsonCreator\n-        public ExplicitFactoryBean1 create(String str) {\n-            ExplicitFactoryBean1 bean = new ExplicitFactoryBean1(str, false);\n+        public static ExplicitFactoryBeanA create(String str) {\n+            ExplicitFactoryBeanA bean = new ExplicitFactoryBeanA(str, false);\n             bean.value = str;\n             return bean;\n         }\n     }\n \n     // [databind#660]\n-    static class ExplicitFactoryBean2 {\n+    static class ExplicitFactoryBeanB {\n         private String value;\n \n         @JsonCreator\n-        private ExplicitFactoryBean2(String str) {\n-            value = null;\n+        private ExplicitFactoryBeanB(String str) {\n+            value = str;\n         }\n \n-        public static ExplicitFactoryBean2 valueOf(String str) {\n-            return new ExplicitFactoryBean2(null);\n+        public static ExplicitFactoryBeanB valueOf(String str) {\n+            return new ExplicitFactoryBeanB(null);\n         }\n \n         public String value() { return value; }\n         assertEquals(\"xyz\", bean.value);\n     }\n \n-    public void testExplicitFactory660() throws Exception\n+    public void testExplicitFactory660a() throws Exception\n     {\n         // First, explicit override for factory\n-        ExplicitFactoryBean1 bean = MAPPER.readValue(quote(\"abc\"), ExplicitFactoryBean1.class);\n+        ExplicitFactoryBeanA bean = MAPPER.readValue(quote(\"abc\"), ExplicitFactoryBeanA.class);\n         assertNotNull(bean);\n         assertEquals(\"abc\", bean.value());\n+    }\n \n+    public void testExplicitFactory660b() throws Exception\n+    {\n         // and then one for private constructor\n-        ExplicitFactoryBean2 bean2 = MAPPER.readValue(quote(\"def\"), ExplicitFactoryBean2.class);\n+        ExplicitFactoryBeanB bean2 = MAPPER.readValue(quote(\"def\"), ExplicitFactoryBeanB.class);\n         assertNotNull(bean2);\n         assertEquals(\"def\", bean2.value());\n     }", "timestamp": 1419375946, "metainfo": ""}