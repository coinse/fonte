{"sha": "f0929aca5a75fa6de54507e400d168a86e42b77a", "log": "Simplify/clean up annotation introspector parts", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.core.Versioned;\n-import com.fasterxml.jackson.core.util.VersionUtil;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n      */\n \n     @Override\n-    public Version version() {\n-        return VersionUtil.versionFor(getClass());\n-    }\n+    public abstract Version version();\n     \n     /*\n     /**********************************************************\n      * Method called by framework to determine whether given annotation\n      * is handled by this introspector.\n      */\n-    public abstract boolean isHandled(Annotation ann);\n+    public boolean isHandled(Annotation ann) {\n+        return false;\n+    }\n \n     /**\n      * Method for checking whether given annotation is considered an\n      * is defined. Returns null if no declaration found; can return\n      * explicit empty String, which is usually ignored as well as null.\n      */\n-    public abstract String findRootName(AnnotatedClass ac);\n+    public String findRootName(AnnotatedClass ac) {\n+        return null;\n+    }\n \n     /**\n      * Method for finding list of properties to ignore for given class\n      * after other detection mechanisms, to filter out these specific\n      * properties from being serialized and deserialized.\n      */\n-    public abstract String[] findPropertiesToIgnore(AnnotatedClass ac);\n+    public String[] findPropertiesToIgnore(AnnotatedClass ac) {\n+        return null;\n+    }\n \n     /**\n      * Method for checking whether an annotation indicates that all unknown properties\n      */\n-    public abstract Boolean findIgnoreUnknownProperties(AnnotatedClass ac);\n+    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n+        return null;\n+    }\n \n     /**\n      * Method for checking whether properties that have specified type\n      */\n \n     /**\n-     * Note: defined as non-abstract to reduce fragility between\n-     * versions.\n+     * Method for checking if given member indicates that it is part\n+     * of a reference (parent/child).\n      */\n     public ReferenceProperty findReferenceType(AnnotatedMember member) {\n         return null;\n         return null;\n     }\n \n+    /**\n+     * Method for checking if annotated property (represented by a field or\n+     * getter/setter method) has definitions for views it is to be included in.\n+     * If null is returned, no view definitions exist and property is always\n+     * included (or always excluded as per default view inclusion configuration);\n+     * otherwise it will only be included for views included in returned\n+     * array. View matches are checked using class inheritance rules (sub-classes\n+     * inherit inclusions of super-classes)\n+     * \n+     * @param a Annotated property (represented by a method, field or ctor parameter)\n+     * @return Array of views (represented by classes) that the property is included in;\n+     *    if null, always included (same as returning array containing <code>Object.class</code>)\n+     */\n+    public Class<?>[] findViews(Annotated a) {\n+        return null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Serialization: general annotations\n      * <code>Class<JsonSerializer></code>); if value of different\n      * type is returned, a runtime exception may be thrown by caller.\n      */\n-    public abstract Object findSerializer(Annotated am);\n+    public Object findSerializer(Annotated am) {\n+        return null;\n+    }\n \n     /**\n      * Method for getting a serializer definition for keys of associated <code>Map</code> property.\n      *\n      * @return Class to use instead of runtime type\n      */\n-    public abstract Class<?> findSerializationType(Annotated a);\n+    public Class<?> findSerializationType(Annotated a) {\n+        return null;\n+    }\n \n     /**\n      * Method for finding possible widening type definition that a property\n      *\n      * @return Typing mode to use, if annotation is found; null otherwise\n      */\n-    public abstract JsonSerialize.Typing findSerializationTyping(Annotated a);\n-\n-    /**\n-     * Method for checking if annotated serializable property (represented by\n-     * field or getter method) has definitions for views it is to be included\n-     * in. If null is returned, no view definitions exist and property is always\n-     * included; otherwise it will only be included for views included in returned\n-     * array. View matches are checked using class inheritance rules (sub-classes\n-     * inherit inclusions of super-classes)\n-     * \n-     * @param a Annotated serializable property (field or getter method)\n-     * @return Array of views (represented by classes) that the property is included in;\n-     *    if null, always included (same as returning array containing <code>Object.class</code>)\n-     */\n-    public abstract Class<?>[] findSerializationViews(Annotated a);\n+    public JsonSerialize.Typing findSerializationTyping(Annotated a) {\n+        return null;\n+    }\n     \n     /*\n     /**********************************************************\n      * Method for accessing defined property serialization order (which may be\n      * partial). May return null if no ordering is defined.\n      */\n-    public abstract String[] findSerializationPropertyOrder(AnnotatedClass ac);\n+    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n+        return null;\n+    }\n \n     /**\n      * Method for checking whether an annotation indicates that serialized properties\n      * for which no explicit is defined should be alphabetically (lexicograpically)\n      * ordered\n      */\n-    public abstract Boolean findSerializationSortAlphabetically(AnnotatedClass ac);\n+    public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n+        return null;\n+    }\n     \n     /*\n     /**********************************************************\n      * \"use standard bean name detection if applicable;\n      * method name if not\".\n      */\n-    public abstract String findSerializationName(AnnotatedMethod am);\n+    public String findSerializationName(AnnotatedMethod am) {\n+        return null;\n+    }\n \n     /**\n      * Method for checking whether given method has an annotation\n      * @return True if such annotation is found (and is not disabled);\n      *   false if no enabled annotation is found\n      */\n-    public abstract boolean hasAsValueAnnotation(AnnotatedMethod am);\n+    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n+        return false;\n+    }\n \n     /**\n      * Method for determining the String value to use for serializing\n      *\n      * @return Serialized enum value.\n      */\n-    public abstract String findEnumValue(Enum<?> value);\n+    public String findEnumValue(Enum<?> value) {\n+        return null;\n+    }\n \n     /*\n     /**********************************************************\n      * name, except for empty String (\"\") which is taken to mean\n      * \"use the field name as is\".\n      */\n-    public abstract String findSerializationName(AnnotatedField af);\n+    public String findSerializationName(AnnotatedField af) {\n+        return null;\n+    }\n \n     /*\n     /**********************************************************\n      * <code>Class<JsonDeserializer></code>); if value of different\n      * type is returned, a runtime exception may be thrown by caller.\n      */\n-    public abstract Object findDeserializer(Annotated am);\n+    public Object findDeserializer(Annotated am) {\n+        return null;\n+    }\n \n     /**\n      * Method for getting a deserializer definition for keys of\n      * <code>Class<JsonDeserializer></code>); if value of different\n      * type is returned, a runtime exception may be thrown by caller.\n      */\n-    public abstract Object findKeyDeserializer(Annotated am);\n+    public Object findKeyDeserializer(Annotated am) {\n+        return null;\n+    }\n \n     /**\n      * Method for getting a deserializer definition for content (values) of\n      * <code>Class<JsonDeserializer></code>); if value of different\n      * type is returned, a runtime exception may be thrown by caller.\n      */\n-    public abstract Object findContentDeserializer(Annotated am);\n+    public Object findContentDeserializer(Annotated am) {\n+        return null;\n+    }\n \n     /**\n      * Method for accessing annotated type definition that a\n      *\n      * @return Class to use for deserialization instead of declared type\n      */\n-    public abstract Class<?> findDeserializationType(Annotated am, JavaType baseType,\n-            String propName);\n+    public Class<?> findDeserializationType(Annotated am, JavaType baseType,\n+            String propName) {\n+        return null;\n+    }\n \n     /**\n      * Method for accessing additional narrowing type definition that a\n      * @return Class specifying more specific type to use instead of\n      *   declared type, if annotation found; null if not\n      */\n-    public abstract Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType,\n-            String propName);\n+    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType,\n+            String propName) {\n+        return null;\n+    }\n \n     /**\n      * Method for accessing additional narrowing type definition that a\n      * @return Class specifying more specific type to use instead of\n      *   declared type, if annotation found; null if not\n      */\n-    public abstract Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType,\n-            String propName);\n+    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType,\n+            String propName) {\n+        return null;\n+    }\n \n     /*\n     /**********************************************************\n      * \"use standard bean name detection if applicable;\n      * method name if not\".\n      */\n-    public abstract String findDeserializationName(AnnotatedMethod am);\n+    public String findDeserializationName(AnnotatedMethod am) {\n+        return null;\n+    }\n \n     /**\n      * Method for checking whether given method has an annotation\n      * name, except for empty String (\"\") which is taken to mean\n      * \"use the field name as is\".\n      */\n-    public abstract String findDeserializationName(AnnotatedField af);\n+    public String findDeserializationName(AnnotatedField af) {\n+        return null;\n+    }\n \n     /*\n     /**********************************************************\n      * No actual parameter object can be passed since JDK offers no\n      * representation; just annotations.\n      */\n-    public abstract String findDeserializationName(AnnotatedParameter param);\n+    public String findDeserializationName(AnnotatedParameter param) {\n+        return null;\n+    }\n \n     /*\n     /**********************************************************\n         }\n \n         @Override\n-        public Class<?>[] findSerializationViews(Annotated a)\n+        public Class<?>[] findViews(Annotated a)\n         {\n             /* Theoretically this could be trickier, if multiple introspectors\n              * return non-null entries. For now, though, we'll just consider\n              * first one to return non-null to win.\n              */\n-            Class<?>[] result = _primary.findSerializationViews(a);\n-            if (result == null) {\n-                result = _secondary.findSerializationViews(a);\n+            Class<?>[] result = _primary.findViews(a);\n+            if (result == null) {\n+                result = _secondary.findViews(a);\n             }\n             return result;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n             throws IOException, JsonProcessingException\n     {\n         // This method should never be called...\n-        throw ctxt.instantiationException(_baseType.getRawClass(), \"abstract types either need to be mapped to concrete types, have custom deserializer, or be instantiated with additional type information\");\n+        throw ctxt.instantiationException(_baseType.getRawClass(),\n+                \"abstract types either need to be mapped to concrete types, have custom deserializer, or be instantiated with additional type information\");\n     }\n \n     protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n-        /* As per [JACKSON-417], there is a chance we might be \"natular\" types\n+        /* As per [JACKSON-417], there is a chance we might be \"natural\" types\n          * (String, Boolean, Integer, Double), which do not include any type information...\n          * Care must be taken to only return this if return type matches, however.\n          * Finally, we may have to consider possibility of custom handlers for\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n     }\n \n     @Override\n-    public Class<?>[] findSerializationViews(Annotated a)\n+    public Class<?>[] findViews(Annotated a)\n     {\n         JsonView ann = a.getAnnotation(JsonView.class);\n         return (ann == null) ? null : ann.value();\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n \n-import java.lang.annotation.Annotation;\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.databind.*;\n \n-import com.fasterxml.jackson.core.Version;\n-import com.fasterxml.jackson.databind.AnnotationIntrospector;\n-import com.fasterxml.jackson.databind.DatabindVersion;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.KeyDeserializer;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize.Typing;\n /**\n  * Dummy, \"no-operation\" implementation of {@link AnnotationIntrospector}.\n  * Can be used as is to suppress handling of annotations; or as a basis\n- * for simple complementary annotators\n+ * for simple configuration overrides (whether based on annotations or not).\n  */\n-public class NopAnnotationIntrospector\n+public abstract class NopAnnotationIntrospector\n     extends AnnotationIntrospector\n {\n     /**\n      * \"null\" introspector: one that never finds any annotation\n      * information.\n      */\n-    public final static NopAnnotationIntrospector instance = new NopAnnotationIntrospector();\n+    public final static NopAnnotationIntrospector instance = new NopAnnotationIntrospector() {\n+        @Override\n+        public Version version() {\n+            return DatabindVersion.instance.version();\n+        }\n+    };\n \n     @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* General annotation properties\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public boolean isHandled(Annotation ann) {\n-        return false;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* General annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public String findEnumValue(Enum<?> value) {\n-        return null;\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* General Class annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public String findRootName(AnnotatedClass ac) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String[] findPropertiesToIgnore(AnnotatedClass ac) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n-        return null;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* General member (field, method/constructor) annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public boolean hasIgnoreMarker(AnnotatedMember member) {\n-        return false;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Serialization: general annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public Object findSerializer(Annotated am) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Class<?> findSerializationType(Annotated a) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Typing findSerializationTyping(Annotated a) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Class<?>[] findSerializationViews(Annotated a) {\n-        return null;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Serialization: class annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n-        return null;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Serialization: method annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public String findSerializationName(AnnotatedMethod am) {\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n-        return false;\n-    }\n-    \n-    @Override\n-    public String findDeserializationName(AnnotatedField af) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Class<?> findDeserializationContentType(Annotated am, JavaType t, String propName) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Class<?> findDeserializationKeyType(Annotated am, JavaType t, String propName) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Class<?> findDeserializationType(Annotated am, JavaType t, String propName) {\n-        return null;\n-    }\n-\n-    @Override\n-    public Object findDeserializer(Annotated am) { return null; }\n-\n-    @Override\n-    public Class<KeyDeserializer> findKeyDeserializer(Annotated am) { return null; }\n-\n-    @Override\n-    public Class<JsonDeserializer<?>> findContentDeserializer(Annotated am) { return null; }\n-\n-\n-    @Override\n-    public String findDeserializationName(AnnotatedParameter param) {\n-        return null;\n-    }\n-\n-    @Override\n-    public String findSerializationName(AnnotatedField af) {\n-        return null;\n-    }\n-    \n-    @Override\n-    public String findDeserializationName(AnnotatedMethod am) {\n-        return null;\n+        return Version.unknownVersion();\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n                         typeSer, contentTypeSer, accessor, staticTyping);\n         // how about views? (1.4+)\n         AnnotationIntrospector intr = prov.getAnnotationIntrospector();\n-        pbw.setViews(intr.findSerializationViews(accessor));\n+        pbw.setViews(intr.findViews(accessor));\n         return pbw;\n     }\n }", "timestamp": 1327537480, "metainfo": ""}