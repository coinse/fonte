{"sha": "5087367a02dd50222bf93cc416c3b0465c5cbeb0", "log": "Implement a fix for #465", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n         _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));\n \n         // Other numbers, more complicated\n-        final JsonSerializer<?> ns = new NumberSerializers.NumberSerializer();\n+        final JsonSerializer<?> ns = NumberSerializer.instance;\n         _concrete.put(BigInteger.class.getName(), ns);\n         _concrete.put(BigDecimal.class.getName(), ns);\n \n             return ToStringSerializer.instance;\n         }\n         if (Number.class.isAssignableFrom(raw)) {\n-            return NumberSerializers.NumberSerializer.instance;\n+            // 21-May-2014, tatu: Couple of alternatives actually\n+            JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n+            if (format != null) {\n+                switch (format.getShape()) {\n+                case STRING:\n+                    return ToStringSerializer.instance;\n+                case OBJECT: // need to bail out to let it be serialized as POJO\n+                case ARRAY: // or, I guess ARRAY; otherwise no point in speculating\n+                    return null;\n+                default:\n+                }\n+            }\n+            return NumberSerializer.instance;\n         }\n         if (Enum.class.isAssignableFrom(raw)) {\n             return buildEnumSerializer(prov.getConfig(), type, beanDesc);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\n+\n+/**\n+ * As a fallback, we may need to use this serializer for other\n+ * types of {@link Number}s (custom types).\n+ */\n+@JacksonStdImpl\n+public final class NumberSerializer\n+    extends StdScalarSerializer<Number>\n+{\n+    public final static NumberSerializer instance = new NumberSerializer();\n+\n+    public NumberSerializer() { super(Number.class); }\n+\n+    @Override\n+    public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+        if (value instanceof BigDecimal) {\n+            jgen.writeNumber((BigDecimal) value);\n+        } else if (value instanceof BigInteger) {\n+            jgen.writeNumber((BigInteger) value);\n+            \n+        /* These shouldn't match (as there are more specific ones),\n+         * but just to be sure:\n+         */\n+        } else if (value instanceof Integer) {\n+            jgen.writeNumber(value.intValue());\n+        } else if (value instanceof Long) {\n+            jgen.writeNumber(value.longValue());\n+        } else if (value instanceof Double) {\n+            jgen.writeNumber(value.doubleValue());\n+        } else if (value instanceof Float) {\n+            jgen.writeNumber(value.floatValue());\n+        } else if ((value instanceof Byte) || (value instanceof Short)) {\n+            jgen.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n+        } else {\n+            // We'll have to use fallback \"untyped\" number write method\n+            jgen.writeNumber(value.toString());\n+        }\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n+        return createSchemaNode(\"number\", true);\n+    }\n+    \n+    @Override\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n+    {\n+        // Hmmh. What should it be? Ideally should probably indicate BIG_DECIMAL\n+        // to ensure no information is lost? But probably won't work that well...\n+        JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n+        if (v2 != null) {\n+            v2.numberType(JsonParser.NumberType.BIG_DECIMAL);\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n \n import java.io.IOException;\n import java.lang.reflect.Type;\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n import java.util.Map;\n \n import com.fasterxml.jackson.core.*;\n         public ShortSerializer() { super(Short.class); }\n         \n         @Override\n-        public void serialize(Short value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n-        {\n+        public void serialize(Short value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n             jgen.writeNumber(value.shortValue());\n         }\n     \n         @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        {\n-            return createSchemaNode(\"number\", true);\t\t// msteiger: maybe \"integer\" or \"short\" ?\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-                throws JsonMappingException\n-        {\n-            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.INT);\t\t\t// should be SHORT\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n+            return createSchemaNode(\"number\", true);\n+        }\n+        \n+        @Override\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n+        {\n+            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n+            if (v2 != null) {\n+                v2.numberType(JsonParser.NumberType.INT);\n             }\n         }\n     }\n         public IntegerSerializer() { super(Integer.class); }\n     \n         @Override\n-        public void serialize(Integer value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException\n-        {\n+        public void serialize(Integer value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonGenerationException {\n             jgen.writeNumber(value.intValue());\n         }\n     \n         }\n         \n         @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-                throws JsonMappingException\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n         {\n             JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n             if (v2 != null) {\n             }\n         }\n     }\n-    \n-    /**\n-     * As a fallback, we may need to use this serializer for other\n-     * types of {@link Number}s (custom types).\n-     */\n-    @JacksonStdImpl\n-    public final static class NumberSerializer\n-        extends StdScalarSerializer<Number>\n-    {\n-        public final static NumberSerializer instance = new NumberSerializer();\n-    \n-        public NumberSerializer() { super(Number.class); }\n-    \n-        @Override\n-        public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n-        {\n-            // As per [JACKSON-423], handling for BigInteger and BigDecimal was missing!\n-            if (value instanceof BigDecimal) {\n-                // 07-Jul-2013, tatu: Should be handled by propagating setting to JsonGenerator\n-                //    so this should not be needed:\n-                /*\n-                if (provider.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n-                    // [Issue#232]: Ok, rather clumsy, but let's try to work around the problem with:\n-                    if (!(jgen instanceof TokenBuffer)) {\n-                        jgen.writeNumber(((BigDecimal) value).toPlainString());\n-                        return;\n-                    }\n-                }\n-                */\n-                jgen.writeNumber((BigDecimal) value);\n-            } else if (value instanceof BigInteger) {\n-                jgen.writeNumber((BigInteger) value);\n-                \n-            /* These shouldn't match (as there are more specific ones),\n-             * but just to be sure:\n-             */\n-            } else if (value instanceof Integer) {\n-                jgen.writeNumber(value.intValue());\n-            } else if (value instanceof Long) {\n-                jgen.writeNumber(value.longValue());\n-            } else if (value instanceof Double) {\n-                jgen.writeNumber(value.doubleValue());\n-            } else if (value instanceof Float) {\n-                jgen.writeNumber(value.floatValue());\n-            } else if ((value instanceof Byte) || (value instanceof Short)) {\n-                jgen.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n-            } else {\n-                // We'll have to use fallback \"untyped\" number write method\n-                jgen.writeNumber(value.toString());\n-            }\n-        }\n-    \n-        @Override\n-        public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-            return createSchemaNode(\"number\", true);\n-        }\n-        \n-        @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-            throws JsonMappingException\n-        {\n-            // Hmmh. What should it be? Ideally should probably indicate BIG_DECIMAL\n-            // to ensure no information is lost? But probably won't work that well...\n-            JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(JsonParser.NumberType.BIG_DECIMAL);\n-            }\n-        }\n-    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n \n import org.w3c.dom.Element;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.CharacterEscapes;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.util.StdConverter;\n \n /**\n- * Test for verifying [JACKSON-238]\n- *\n- * @author Pablo Lalloni <plalloni@gmail.com>\n- * @author tatu\n+ * Tests for verifying various issues with custom serializers.\n  */\n-public class TestCustomSerializers\n-    extends com.fasterxml.jackson.databind.BaseMapTest\n+public class TestCustomSerializers extends BaseMapTest\n {\n     /*\n     /**********************************************************\n             return null;\n         }\n     }\n-    \n+\n+    @JsonFormat(shape=JsonFormat.Shape.OBJECT)\n+    static class LikeNumber extends Number {\n+        private static final long serialVersionUID = 1L;\n+\n+        public int x;\n+\n+        public LikeNumber(int value) { x = value; }\n+        \n+        @Override\n+        public double doubleValue() {\n+            return x;\n+        }\n+\n+        @Override\n+        public float floatValue() {\n+            return x;\n+        }\n+\n+        @Override\n+        public int intValue() {\n+            return x;\n+        }\n+\n+        @Override\n+        public long longValue() {\n+            return x;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n     /**********************************************************\n     */\n-    \n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n     public void testCustomization() throws Exception\n     {\n         ObjectMapper objectMapper = new ObjectMapper();\n         assertEquals(quote(\"foo\\\\u0062\\\\Ar\"),\n                 mapper.writer(new CustomEscapes()).writeValueAsString(\"foobar\"));\n     }\n+    \n+    public void testNumberSubclass() throws Exception\n+    {\n+        assertEquals(aposToQuotes(\"{'x':42}\"),\n+                MAPPER.writeValueAsString(new LikeNumber(42)));\n+    }\n }", "timestamp": 1400710808, "metainfo": ""}