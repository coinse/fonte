{"sha": "9ee8c71799875b547f62b79099c0ebea78ab3369", "log": "Merge pull request #637 from mspiegel/noclassdeffound-fix  NoClassDefFoundDeserializer for missing classes", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.impl.NoClassDefFoundDeserializer;\n import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.type.*;\n         if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n             type = factory.mapAbstractType(config, type);\n         }\n-        BeanDescription beanDesc = config.introspect(type);\n+        BeanDescription beanDesc;\n+        try {\n+            beanDesc = config.introspect(type);\n+        } catch (NoClassDefFoundError error) {\n+            return new NoClassDefFoundDeserializer<Object>(error);\n+        }\n         // Then: does type define explicit deserializer to use, with annotation(s)?\n         JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                 beanDesc.getClassInfo());\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/NoClassDefFoundDeserializer.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+\n+/**\n+ * A deserializer that stores a {@link NoClassDefFoundError} error\n+ * and throws the stored exception when attempting to deserialize\n+ * a value. Null and empty values can be deserialized without error.\n+ */\n+public class NoClassDefFoundDeserializer<T> extends JsonDeserializer<T>\n+{\n+    private final NoClassDefFoundError _cause;\n+\n+    public NoClassDefFoundDeserializer(NoClassDefFoundError cause)\n+    {\n+        _cause = cause;\n+    }\n+\n+    @Override\n+    public T deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        throw _cause;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestNoClassDefFoundDeserializer.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+\n+import javax.measure.Measure;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestNoClassDefFoundDeserializer extends BaseMapTest {\n+\n+    public static class Parent {\n+        public List<Child> child;\n+    }\n+\n+    public static class Child {\n+        public Measure measure;\n+    }\n+\n+    public void testClassIsMissing()\n+    {\n+        boolean missing = false;\n+        try {\n+            Class.forName(\"javax.measure.Measure\");\n+        } catch (ClassNotFoundException ex) {\n+            missing = true;\n+        }\n+        assertTrue(\"javax.measure.Measure is not in classpath\", missing);\n+    }\n+\n+    public void testDeserialize() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Parent result = m.readValue(\" { } \", Parent.class);\n+        assertNotNull(result);\n+    }\n+\n+    public void testUseMissingClass() throws Exception\n+    {\n+        boolean missing = false;\n+        try {\n+            ObjectMapper m = new ObjectMapper();\n+            m.readValue(\" { \\\"child\\\" : [{}] } \", Parent.class);\n+        } catch (NoClassDefFoundError ex) {\n+            missing = true;\n+        }\n+        assertTrue(\"cannot instantiate a missing class\", missing);\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n      * like Afterburner change definition.\n      */\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonToken t = jp.getCurrentToken();\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        JsonToken t = p.getCurrentToken();\n         // common case first:\n         if (t == JsonToken.START_OBJECT) {\n             if (_vanillaProcessing) {\n-                return vanillaDeserialize(jp, ctxt, jp.nextToken());\n-            }\n-            jp.nextToken();\n+                return vanillaDeserialize(p, ctxt, p.nextToken());\n+            }\n+            p.nextToken();\n             if (_objectIdReader != null) {\n-                return deserializeWithObjectId(jp, ctxt);\n-            }\n-            return deserializeFromObject(jp, ctxt);\n-        }\n-        return _deserializeOther(jp, ctxt, t);\n-    }\n-\n-    protected final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt,\n+                return deserializeWithObjectId(p, ctxt);\n+            }\n+            return deserializeFromObject(p, ctxt);\n+        }\n+        return _deserializeOther(p, ctxt, t);\n+    }\n+\n+    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n             JsonToken t) throws IOException\n     {\n         // and then others, generally requiring use of @JsonCreator\n         switch (t) {\n         case VALUE_STRING:\n-            return deserializeFromString(jp, ctxt);\n+            return deserializeFromString(p, ctxt);\n         case VALUE_NUMBER_INT:\n-            return deserializeFromNumber(jp, ctxt);\n+            return deserializeFromNumber(p, ctxt);\n         case VALUE_NUMBER_FLOAT:\n-\t    return deserializeFromDouble(jp, ctxt);\n+\t    return deserializeFromDouble(p, ctxt);\n         case VALUE_EMBEDDED_OBJECT:\n-            return deserializeFromEmbedded(jp, ctxt);\n+            return deserializeFromEmbedded(p, ctxt);\n         case VALUE_TRUE:\n         case VALUE_FALSE:\n-            return deserializeFromBoolean(jp, ctxt);\n+            return deserializeFromBoolean(p, ctxt);\n         case START_ARRAY:\n             // these only work if there's a (delegating) creator...\n-            return deserializeFromArray(jp, ctxt);\n+            return deserializeFromArray(p, ctxt);\n         case FIELD_NAME:\n         case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n             if (_vanillaProcessing) {\n-                return vanillaDeserialize(jp, ctxt, t);\n+                return vanillaDeserialize(p, ctxt, t);\n             }\n             if (_objectIdReader != null) {\n-                return deserializeWithObjectId(jp, ctxt);\n-            }\n-            return deserializeFromObject(jp, ctxt);\n+                return deserializeWithObjectId(p, ctxt);\n+            }\n+            return deserializeFromObject(p, ctxt);\n         default:\n             throw ctxt.mappingException(handledType());\n         }\n     }\n \n-    protected Object _missingToken(JsonParser jp, DeserializationContext ctxt)\n+    protected Object _missingToken(JsonParser p, DeserializationContext ctxt)\n         throws JsonProcessingException\n     {\n         throw ctxt.endOfInputException(handledType());\n      * after collecting some or all of the properties to set.\n      */\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n+    {\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         if (_unwrappedPropertyHandler != null) {\n-            return deserializeWithUnwrapped(jp, ctxt, bean);\n+            return deserializeWithUnwrapped(p, ctxt, bean);\n         }\n         if (_externalTypeIdHandler != null) {\n-            return deserializeWithExternalTypeId(jp, ctxt, bean);\n-        }\n-        JsonToken t = jp.getCurrentToken();\n+            return deserializeWithExternalTypeId(p, ctxt, bean);\n+        }\n+        JsonToken t = p.getCurrentToken();\n         // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n         if (t == JsonToken.START_OBJECT) {\n-            t = jp.nextToken();\n+            t = p.nextToken();\n         }\n         if (_needViewProcesing) {\n             Class<?> view = ctxt.getActiveView();\n             if (view != null) {\n-                return deserializeWithView(jp, ctxt, bean, view);\n-            }\n-        }\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+                return deserializeWithView(p, ctxt, bean, view);\n+            }\n+        }\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             \n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+            handleUnknownVanilla(p, ctxt, bean, propName);\n         }\n         return bean;\n     }\n      * Streamlined version that is only used when no \"special\"\n      * features are enabled.\n      */\n-    private final Object vanillaDeserialize(JsonParser jp,\n+    private final Object vanillaDeserialize(JsonParser p,\n     \t\tDeserializationContext ctxt, JsonToken t)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             } else {\n-                handleUnknownVanilla(jp, ctxt, bean, propName);\n+                handleUnknownVanilla(p, ctxt, bean, propName);\n             }\n         }\n         return bean;\n      * features.\n      */\n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         if (_nonStandardCreation) {\n             if (_unwrappedPropertyHandler != null) {\n-                return deserializeWithUnwrapped(jp, ctxt);\n+                return deserializeWithUnwrapped(p, ctxt);\n             }\n             if (_externalTypeIdHandler != null) {\n-                return deserializeWithExternalTypeId(jp, ctxt);\n-            }\n-            Object bean = deserializeFromObjectUsingNonDefault(jp, ctxt);\n+                return deserializeWithExternalTypeId(p, ctxt);\n+            }\n+            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n             if (_injectables != null) {\n                 injectValues(ctxt, bean);\n             }\n             return bean;\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n-        if (jp.canReadObjectId()) {\n-            Object id = jp.getObjectId();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+        if (p.canReadObjectId()) {\n+            Object id = p.getObjectId();\n             if (id != null) {\n-                _handleTypedObjectId(jp, ctxt, bean, id);\n+                _handleTypedObjectId(p, ctxt, bean, id);\n             }\n         }\n         if (_injectables != null) {\n         if (_needViewProcesing) {\n             Class<?> view = ctxt.getActiveView();\n             if (view != null) {\n-                return deserializeWithView(jp, ctxt, bean, view);\n-            }\n-        }\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+                return deserializeWithView(p, ctxt, bean, view);\n+            }\n+        }\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+            handleUnknownVanilla(p, ctxt, bean, propName);\n         }\n         return bean;\n     }\n      */\n     @Override\n     @SuppressWarnings(\"resource\")\n-    protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n+    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n         throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n         \n         // 04-Jan-2010, tatu: May need to collect unknown properties for polymorphic cases\n         TokenBuffer unknown = null;\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                    jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n                         bean = creator.build(ctxt, buffer);\n                     if (bean == null) {\n                         throw ctxt.instantiationException(_beanType.getRawClass(), \"JSON Creator returned null\");\n                     }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n+\n                     //  polymorphic?\n                     if (bean.getClass() != _beanType.getRawClass()) {\n-                        return handlePolymorphic(jp, ctxt, bean, unknown);\n+                        return handlePolymorphic(p, ctxt, bean, unknown);\n                     }\n                     if (unknown != null) { // nope, just extra unknown stuff...\n                         bean = handleUnknownProperties(ctxt, bean, unknown);\n                     }\n                     // or just clean?\n-                    return deserialize(jp, ctxt, bean);\n+                    return deserialize(p, ctxt, bean);\n                 }\n                 continue;\n             }\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             // As per [JACKSON-313], things marked as ignorable should not be\n             // passed to any setter\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                 continue;\n             }\n             // Ok then, let's collect the whole field; name and value\n             if (unknown == null) {\n-                unknown = new TokenBuffer(jp);\n+                unknown = new TokenBuffer(p);\n             }\n             unknown.writeFieldName(propName);\n-            unknown.copyCurrentStructure(jp);\n+            unknown.copyCurrentStructure(p);\n         }\n         \n         // We hit END_OBJECT, so:\n     /**********************************************************\n      */\n     \n-    protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt,\n+    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n             Object bean, Class<?> activeView)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+        throws IOException\n+    {\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n                 if (!prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+            handleUnknownVanilla(p, ctxt, bean, propName);\n         }\n         return bean;\n     }\n      * which need special handling\n      */\n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n-            return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt);\n-        }\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+            return deserializeUsingPropertyBasedWithUnwrapped(p, ctxt);\n+        }\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n \n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n-        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken();\n+        for (; p.getCurrentToken() != JsonToken.END_OBJECT; p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // how about any setter? We'll get copies but...\n             if (_anySetter != null) {\n                 try {\n-                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             }\n         }\n         tokens.writeEndObject();\n-        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n         return bean;\n     }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonToken t = jp.getCurrentToken();\n+    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n+    {\n+        JsonToken t = p.getCurrentToken();\n         if (t == JsonToken.START_OBJECT) {\n-            t = jp.nextToken();\n-        }\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+            t = p.nextToken();\n+        }\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            SettableBeanProperty prop = _beanProperties.find(propName);\n-            jp.nextToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            p.nextToken();\n             if (prop != null) { // normal case\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // how about any setter? We'll get copies but...\n             if (_anySetter != null) {\n-                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n             }\n         }\n         tokens.writeEndObject();\n-        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n         return bean;\n     }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n-\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n+\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                    t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n                         bean = creator.build(ctxt, buffer);\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         continue; // never gets here\n                     }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n-                        jp.nextToken(); // to skip name\n-                        tokens.copyCurrentStructure(jp);\n-                        t = jp.nextToken();\n+                        p.nextToken(); // to skip name\n+                        tokens.copyCurrentStructure(p);\n+                        t = p.nextToken();\n                     }\n                     tokens.writeEndObject();\n                     if (bean.getClass() != _beanType.getRawClass()) {\n                         tokens.close();\n                         throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                     }\n-                    return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                 }\n                 continue;\n             }\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             /* As per [JACKSON-313], things marked as ignorable should not be\n              * passed to any setter\n              */\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n             }\n         }\n \n             wrapInstantiationProblem(e, ctxt);\n             return null; // never gets here\n         }\n-        return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n     }\n \n     /*\n     /**********************************************************\n      */\n     \n-    protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_propertyBasedCreator != null) {\n-            return deserializeUsingPropertyBasedWithExternalTypeId(jp, ctxt);\n-        }\n-        return deserializeWithExternalTypeId(jp, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n+            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n+        }\n+        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n     }\n     \n-    protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt,\n+    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n             Object bean)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n         final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken();\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 // [JACKSON-831]: may have property AND be used as external type id:\n-                if (jp.getCurrentToken().isScalarValue()) {\n-                    ext.handleTypePropertyValue(jp, ctxt, propName, bean);\n+                if (p.getCurrentToken().isScalarValue()) {\n+                    ext.handleTypePropertyValue(p, ctxt, propName, bean);\n                 }\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but others are likely to be part of external type id thingy...\n-            if (ext.handlePropertyValue(jp, ctxt, propName, bean)) {\n+            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                 continue;\n             }\n             // if not, the usual fallback handling:\n             if (_anySetter != null) {\n                 try {\n-                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n             // Unknown: let's call handler method\n-            handleUnknownProperty(jp, ctxt, bean, propName);         \n+            handleUnknownProperty(p, ctxt, bean, propName);         \n         }\n         // and when we get this far, let's try finalizing the deal:\n-        return ext.complete(jp, ctxt, bean);\n+        return ext.complete(p, ctxt, bean);\n     }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n-\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n+\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n-                if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) {\n+                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n-                    Object value = creatorProp.deserialize(jp, ctxt);\n+                    Object value = creatorProp.deserialize(p, ctxt);\n                     if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                        t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                         Object bean;\n                         try {\n                             bean = creator.build(ctxt, buffer);\n                         }\n                         // if so, need to copy all remaining tokens into buffer\n                         while (t == JsonToken.FIELD_NAME) {\n-                            jp.nextToken(); // to skip name\n-                            tokens.copyCurrentStructure(jp);\n-                            t = jp.nextToken();\n+                            p.nextToken(); // to skip name\n+                            tokens.copyCurrentStructure(p);\n+                            t = p.nextToken();\n                         }\n                         if (bean.getClass() != _beanType.getRawClass()) {\n                             // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                             //   it's too complicated, so bail out\n                             throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                         }\n-                        return ext.complete(jp, ctxt, bean);\n+                        return ext.complete(p, ctxt, bean);\n                     }\n                 }\n                 continue;\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             // external type id (or property that depends on it)?\n-            if (ext.handlePropertyValue(jp, ctxt, propName, null)) {\n+            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                 continue;\n             }\n             /* As per [JACKSON-313], things marked as ignorable should not be\n              * passed to any setter\n              */\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n             }\n         }\n \n         // We hit END_OBJECT; resolve the pieces:\n         try {\n-            return ext.complete(jp, ctxt, buffer, creator);\n+            return ext.complete(p, ctxt, buffer, creator);\n         } catch (Exception e) {\n             wrapInstantiationProblem(e, ctxt);\n             return null; // never gets here\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n      * features.\n      */\n     public abstract Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException;\n+        throws IOException;\n \n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // 16-Feb-2012, tatu: ObjectId may be used as well... need to check that first\n         if (_objectIdReader != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n      */\n \n     protected final Object finishBuild(DeserializationContext ctxt, Object builder)\n-            throws IOException\n+        throws IOException\n     {\n         try {\n             return _buildMethod.getMember().invoke(builder);\n     }\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Let's delegate just in case we got a JSON Object (could error out, alternatively?)\n-        if (!jp.isExpectedStartArrayToken()) {\n-            return finishBuild(ctxt, _deserializeFromNonArray(jp, ctxt));\n+        if (!p.isExpectedStartArrayToken()) {\n+            return finishBuild(ctxt, _deserializeFromNonArray(p, ctxt));\n         }\n         if (!_vanillaProcessing) {\n-            return finishBuild(ctxt, _deserializeNonVanilla(jp, ctxt));\n+            return finishBuild(ctxt, _deserializeNonVanilla(p, ctxt));\n         }\n         Object builder = _valueInstantiator.createUsingDefault(ctxt);\n         final SettableBeanProperty[] props = _orderedProperties;\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return finishBuild(ctxt, builder);\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, builder, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return finishBuild(ctxt, builder);\n     }\n \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object builder)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object builder)\n+        throws IOException\n     {\n         /* No good way to verify that we have an array... although could I guess\n          * check via JsonParser. So let's assume everything is working fine, for now.\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return finishBuild(ctxt, builder);\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, builder, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return finishBuild(ctxt, builder);\n     }\n \n     // needed since 2.1\n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-    {\n-        return _deserializeFromNonArray(jp, ctxt);\n+    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n+    {\n+        return _deserializeFromNonArray(p, ctxt);\n     }\n     \n     /*\n      * \n      * @return Builder object in use.\n      */\n-    protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeNonVanilla(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_nonStandardCreation) {\n-            return _deserializeWithCreator(jp, ctxt);\n+            return _deserializeWithCreator(p, ctxt);\n         }\n         Object builder = _valueInstantiator.createUsingDefault(ctxt);\n         if (_injectables != null) {\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return builder;\n             }\n             if (i == propCount) {\n             if (prop != null) { // normal case\n                 if (activeView == null || prop.visibleInView(activeView)) {\n                     try {\n-                        prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                        prop.deserializeSetAndReturn(p, ctxt, builder);\n                     } catch (Exception e) {\n                         wrapAndThrow(e, builder, prop.getName(), ctxt);\n                     }\n                 }\n             }\n             // otherwise, skip it (view-filtered, no prop etc)\n-            jp.skipChildren();\n+            p.skipChildren();\n         }\n         // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n         if (!_ignoreAllUnknown) {\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return builder;\n     }\n     \n-    protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeWithCreator(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {        \n         if (_delegateDeserializer != null) {\n             return _valueInstantiator.createUsingDelegate(ctxt,\n-                    _delegateDeserializer.deserialize(jp, ctxt));\n+                    _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n-            return _deserializeUsingPropertyBased(jp, ctxt);\n+            return _deserializeUsingPropertyBased(p, ctxt);\n         }\n         // should only occur for abstract types...\n         if (_beanType.isAbstract()) {\n-            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+            throw JsonMappingException.from(p, \"Can not instantiate abstract type \"+_beanType\n                     +\" (need to add/enable type information?)\");\n         }\n-        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+        throw JsonMappingException.from(p, \"No suitable constructor found for type \"\n                 +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n     }\n \n      * as well.\n      */\n     @Override\n-    protected final Object _deserializeUsingPropertyBased(final JsonParser jp,\n+    protected final Object _deserializeUsingPropertyBased(final JsonParser p,\n             final DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n \n         final SettableBeanProperty[] props = _orderedProperties;\n         final int propCount = props.length;\n         int i = 0;\n         Object builder = null;\n         \n-        for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) {\n+        for (; p.nextToken() != JsonToken.END_ARRAY; ++i) {\n             SettableBeanProperty prop = (i < propCount) ? props[i] : null;\n             if (prop == null) { // we get null if there are extra elements; maybe otherwise too?\n-                jp.skipChildren();\n+                p.skipChildren();\n                 continue;\n             }\n             // if we have already constructed POJO, things are simple:\n             if (builder != null) {\n                 try {\n-                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, builder, prop.getName(), ctxt);\n                 }\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                     try {\n                         builder = creator.build(ctxt, buffer);\n                 continue;\n             }\n             // regular property? needs buffering\n-            buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n         }\n \n         // In case we didn't quite get all the creator properties, we may have to do this:\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n      */\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Let's delegate just in case we got a JSON Object (could error out, alternatively?)\n-        if (!jp.isExpectedStartArrayToken()) {\n-            return _deserializeFromNonArray(jp, ctxt);\n+        if (!p.isExpectedStartArrayToken()) {\n+            return _deserializeFromNonArray(p, ctxt);\n         }\n         if (!_vanillaProcessing) {\n-            return _deserializeNonVanilla(jp, ctxt);\n+            return _deserializeNonVanilla(p, ctxt);\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+\n         final SettableBeanProperty[] props = _orderedProperties;\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return bean;\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return bean;\n     }\n \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n+    {\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n         /* No good way to verify that we have an array... although could I guess\n          * check via JsonParser. So let's assume everything is working fine, for now.\n          */\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return bean;\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return bean;\n     }\n \n     // needed since 2.1\n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-    {\n-        return _deserializeFromNonArray(jp, ctxt);\n+    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        return _deserializeFromNonArray(p, ctxt);\n     }\n     \n     /*\n      * Alternate deserialization method that has to check many more configuration\n      * aspects than the \"vanilla\" processing.\n      */\n-    protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeNonVanilla(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_nonStandardCreation) {\n-            return _deserializeWithCreator(jp, ctxt);\n+            return _deserializeWithCreator(p, ctxt);\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return bean;\n             }\n             if (i == propCount) {\n             if (prop != null) { // normal case\n                 if (activeView == null || prop.visibleInView(activeView)) {\n                     try {\n-                        prop.deserializeAndSet(jp, ctxt, bean);\n+                        prop.deserializeAndSet(p, ctxt, bean);\n                     } catch (Exception e) {\n                         wrapAndThrow(e, bean, prop.getName(), ctxt);\n                     }\n                 }\n             }\n             // otherwise, skip it (view-filtered, no prop etc)\n-            jp.skipChildren();\n+            p.skipChildren();\n         }\n         // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n         if (!_ignoreAllUnknown) {\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return bean;\n     }\n     \n-    protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeWithCreator(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {        \n         if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n-            return _deserializeUsingPropertyBased(jp, ctxt);\n+            return _deserializeUsingPropertyBased(p, ctxt);\n         }\n         // should only occur for abstract types...\n         if (_beanType.isAbstract()) {\n-            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+            throw JsonMappingException.from(p, \"Can not instantiate abstract type \"+_beanType\n                     +\" (need to add/enable type information?)\");\n         }\n-        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+        throw JsonMappingException.from(p, \"No suitable constructor found for type \"\n                 +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n     }\n \n      * as well.\n      */\n     @Override\n-    protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected final Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n \n         final SettableBeanProperty[] props = _orderedProperties;\n         final int propCount = props.length;\n         int i = 0;\n         Object bean = null;\n         \n-        for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) {\n+        for (; p.nextToken() != JsonToken.END_ARRAY; ++i) {\n             SettableBeanProperty prop = (i < propCount) ? props[i] : null;\n             if (prop == null) { // we get null if there are extra elements; maybe otherwise too?\n-                jp.skipChildren();\n+                p.skipChildren();\n                 continue;\n             }\n             // if we have already constructed POJO, things are simple:\n             if (bean != null) {\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, prop.getName(), ctxt);\n                 }\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                     try {\n                         bean = creator.build(ctxt, buffer);\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         continue; // never gets here\n                     }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n+                    \n                     //  polymorphic?\n                     if (bean.getClass() != _beanType.getRawClass()) {\n                         /* 23-Jul-2012, tatu: Not sure if these could ever be properly\n                 continue;\n             }\n             // regular property? needs buffering\n-            buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n         }\n \n         // In case we didn't quite get all the creator properties, we may have to do this:\n     /**********************************************************\n      */\n \n-    protected Object _deserializeFromNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+    protected Object _deserializeFromNonArray(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Let's start with failure\n         throw ctxt.mappingException(\"Can not deserialize a POJO (of type \"+_beanType.getRawClass().getName()\n-                +\") from non-Array representation (token: \"+jp.getCurrentToken()\n+                +\") from non-Array representation (token: \"+p.getCurrentToken()\n                 +\"): type/property designed to be serialized as JSON Array\");\n         // in future, may allow use of \"standard\" POJO serialization as well; if so, do:\n         //return _delegate.deserialize(jp, ctxt);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n     \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n+    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt)\n         throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt,\n-                    _delegateDeserializer.deserialize(jp, ctxt));\n+                    _delegateDeserializer.deserialize(p, ctxt));\n         }\n         /* [JACKSON-620]: empty String may be ok; bit tricky to check, however, since\n          *  there is also possibility of \"auto-wrapping\" of single-element arrays.\n          *  Hence we only accept empty String here.\n          */\n-        if (jp.getCurrentToken() == JsonToken.VALUE_STRING) {\n-            String str = jp.getText();\n+        if (p.getCurrentToken() == JsonToken.VALUE_STRING) {\n+            String str = p.getText();\n             if (str.length() == 0) {\n                 return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str);\n             }\n         }\n-        return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));\n-    }\n-\n-    @Override\n-    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+        return deserialize(p, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));\n+    }\n+\n+    @Override\n+    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt,\n             Collection<Object> result)\n         throws IOException\n     {\n         // Ok: must point to START_ARRAY (or equivalent)\n-        if (!jp.isExpectedStartArrayToken()) {\n-            return handleNonArray(jp, ctxt, result);\n-        }\n+        if (!p.isExpectedStartArrayToken()) {\n+            return handleNonArray(p, ctxt, result);\n+        }\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(result);\n \n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n                 new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);\n \n         JsonToken t;\n-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+        while ((t = p.nextToken()) != JsonToken.END_ARRAY) {\n             try {\n                 Object value;\n                 if (t == JsonToken.VALUE_NULL) {\n                     value = valueDes.getNullValue();\n                 } else if (typeDeser == null) {\n-                    value = valueDes.deserialize(jp, ctxt);\n+                    value = valueDes.deserialize(p, ctxt);\n                 } else {\n-                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                    value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n                 }\n                 if (referringAccumulator != null) {\n                     referringAccumulator.add(value);\n             } catch (UnresolvedForwardReference reference) {\n                 if (referringAccumulator == null) {\n                     throw JsonMappingException\n-                            .from(jp, \"Unresolved forward reference but no identity info\", reference);\n+                            .from(p, \"Unresolved forward reference but no identity info\", reference);\n                 }\n                 Referring ref = referringAccumulator.handleUnresolvedReference(reference);\n                 reference.getRoid().appendReferring(ref);\n      * throw an exception, or try to handle value as if member of implicit\n      * array, depending on configuration.\n      */\n-    protected final Collection<Object> handleNonArray(JsonParser jp, DeserializationContext ctxt,\n+    protected final Collection<Object> handleNonArray(JsonParser p, DeserializationContext ctxt,\n             Collection<Object> result)\n         throws IOException\n     {\n         }\n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n \n         Object value;\n \n             if (t == JsonToken.VALUE_NULL) {\n                 value = valueDes.getNullValue();\n             } else if (typeDeser == null) {\n-                value = valueDes.deserialize(jp, ctxt);\n+                value = valueDes.deserialize(p, ctxt);\n             } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n             }\n         } catch (Exception e) {\n             // note: pass Object.class, not Object[].class, as we need element type for error info\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n     }\n \n     @Override\n-    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+    public Map<Object,Object> deserialize(JsonParser p, DeserializationContext ctxt,\n             Map<Object,Object> result)\n-        throws IOException, JsonProcessingException\n-    {\n+        throws IOException\n+    {\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(result);\n+        \n         // Ok: must point to START_OBJECT or FIELD_NAME\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n         if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n             throw ctxt.mappingException(getMapClass());\n         }\n         if (_standardStringKey) {\n-            _readAndBindStringMap(jp, ctxt, result);\n+            _readAndBindStringMap(p, ctxt, result);\n             return result;\n         }\n-        _readAndBind(jp, ctxt, result);\n+        _readAndBind(p, ctxt, result);\n         return result;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/node/NodeCursor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NodeCursor.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.JsonNode;\n \n /**\n      * Current field name\n      */\n     protected String _currentName;\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected java.lang.Object _currentValue;\n     \n     public NodeCursor(int contextType, NodeCursor p)\n     {\n     public void overrideCurrentName(String name) {\n         _currentName = name;\n     }\n+\n+    @Override\n+    public java.lang.Object getCurrentValue() {\n+        return _currentValue;\n+    }\n+\n+    @Override\n+    public void setCurrentValue(java.lang.Object v) {\n+        _currentValue = v;\n+    }\n     \n     /*\n     /**********************************************************\n         JsonNode n = currentNode();\n         if (n == null) throw new IllegalStateException(\"No current node\");\n         if (n.isArray()) { // false since we have already returned START_ARRAY\n-            return new Array(n, this);\n+            return new ArrayCursor(n, this);\n         }\n         if (n.isObject()) {\n-            return new Object(n, this);\n+            return new ObjectCursor(n, this);\n         }\n         throw new IllegalStateException(\"Current node of type \"+n.getClass().getName());\n     }\n      * than JSON Object and Array).\n      * Note that context is NOT created for leaf values.\n      */\n-    protected final static class RootValue\n+    protected final static class RootCursor\n         extends NodeCursor\n     {\n         protected JsonNode _node;\n \n         protected boolean _done = false;\n \n-        public RootValue(JsonNode n, NodeCursor p) {\n+        public RootCursor(JsonNode n, NodeCursor p) {\n             super(JsonStreamContext.TYPE_ROOT, p);\n             _node = n;\n         }\n     /**\n      * Cursor used for traversing non-empty JSON Array nodes\n      */\n-    protected final static class Array\n+    protected final static class ArrayCursor\n         extends NodeCursor\n     {\n         protected Iterator<JsonNode> _contents;\n \n         protected JsonNode _currentNode;\n \n-        public Array(JsonNode n, NodeCursor p) {\n+        public ArrayCursor(JsonNode n, NodeCursor p) {\n             super(JsonStreamContext.TYPE_ARRAY, p);\n             _contents = n.elements();\n         }\n     /**\n      * Cursor used for traversing non-empty JSON Object nodes\n      */\n-    protected final static class Object\n+    protected final static class ObjectCursor\n         extends NodeCursor\n     {\n         protected Iterator<Map.Entry<String, JsonNode>> _contents;\n \n         protected boolean _needEntry;\n         \n-        public Object(JsonNode n, NodeCursor p)\n+        public ObjectCursor(JsonNode n, NodeCursor p)\n         {\n             super(JsonStreamContext.TYPE_OBJECT, p);\n             _contents = ((ObjectNode) n).fields();\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n         _objectCodec = codec;\n         if (n.isArray()) {\n             _nextToken = JsonToken.START_ARRAY;\n-            _nodeCursor = new NodeCursor.Array(n, null);\n+            _nodeCursor = new NodeCursor.ArrayCursor(n, null);\n         } else if (n.isObject()) {\n             _nextToken = JsonToken.START_OBJECT;\n-            _nodeCursor = new NodeCursor.Object(n, null);\n+            _nodeCursor = new NodeCursor.ObjectCursor(n, null);\n         } else { // value node\n-            _nodeCursor = new NodeCursor.RootValue(n, null);\n+            _nodeCursor = new NodeCursor.RootCursor(n, null);\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.impl.BeanAsArraySerializer;\n import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n      * {@link BeanPropertyWriter} instances.\n      */\n     @Override\n-    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public final void serialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         if (_objectIdWriter != null) {\n-            _serializeWithObjectId(bean, jgen, provider, true);\n+            _serializeWithObjectId(bean, gen, provider, true);\n             return;\n         }\n-        jgen.writeStartObject();\n+        gen.writeStartObject();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(bean);\n         if (_propertyFilterId != null) {\n-            serializeFieldsFiltered(bean, jgen, provider);\n+            serializeFieldsFiltered(bean, gen, provider);\n         } else {\n-            serializeFields(bean, jgen, provider);\n+            serializeFields(bean, gen, provider);\n         }\n-        jgen.writeEndObject();\n+        gen.writeEndObject();\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n      * {@link BeanPropertyWriter} instances.\n      */\n     @Override\n-    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+    public final void serialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n         // [JACKSON-805]\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(provider)) {\n-            serializeAsArray(bean, jgen, provider);\n+            serializeAsArray(bean, gen, provider);\n             return;\n         }\n         /* note: it is assumed here that limitations (type id, object id,\n          * any getter, filtering) have already been checked; so code here\n          * is trivial.\n          */\n-        jgen.writeStartArray();\n-        serializeAsArray(bean, jgen, provider);\n-        jgen.writeEndArray();\n+        gen.writeStartArray();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(bean);\n+        serializeAsArray(bean, gen, provider);\n+        gen.writeEndArray();\n     }\n \n     /*\n         return props.length == 1;\n     }\n \n-    protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    protected final void serializeAsArray(Object bean, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         final BeanPropertyWriter[] props;\n         if (_filteredProps != null && provider.getActiveView() != null) {\n             for (final int len = props.length; i < len; ++i) {\n                 BeanPropertyWriter prop = props[i];\n                 if (prop == null) { // can have nulls in filtered list; but if so, MUST write placeholders\n-                    jgen.writeNull();\n+                    gen.writeNull();\n                 } else {\n-                    prop.serializeAsElement(bean, jgen, provider);\n+                    prop.serializeAsElement(bean, gen, provider);\n                 }\n             }\n             // NOTE: any getters can not be supported either\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java\n      */\n \n     @Override\n-    public void serialize(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider)\n+    public void serialize(Map.Entry<?, ?> value, JsonGenerator gen, SerializerProvider provider)\n         throws IOException\n     {\n-        jgen.writeStartObject();\n+        gen.writeStartObject();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (_valueSerializer != null) {\n-            serializeUsing(value, jgen, provider, _valueSerializer);\n-        } else {\n-            serializeDynamic(value, jgen, provider);\n-        }\n-        jgen.writeEndObject();\n-    }\n-\n-    @Override\n-    public void serializeWithType(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider,\n+            serializeUsing(value, gen, provider, _valueSerializer);\n+        } else {\n+            serializeDynamic(value, gen, provider);\n+        }\n+        gen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(Map.Entry<?, ?> value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer) throws IOException\n     {\n-        typeSer.writeTypePrefixForObject(value, jgen);\n+        typeSer.writeTypePrefixForObject(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (_valueSerializer != null) {\n-            serializeUsing(value, jgen, provider, _valueSerializer);\n-        } else {\n-            serializeDynamic(value, jgen, provider);\n-        }\n-        typeSer.writeTypeSuffixForObject(value, jgen);\n+            serializeUsing(value, gen, provider, _valueSerializer);\n+        } else {\n+            serializeDynamic(value, gen, provider);\n+        }\n+        typeSer.writeTypeSuffixForObject(value, gen);\n     }\n \n     protected void serializeDynamic(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n     // at least if they can provide access to actual size of value and use `writeStartArray()`\n     // variant that passes size of array to output, which is helpful with some data formats\n     @Override\n-    public void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    public void serialize(T value, JsonGenerator gen, SerializerProvider provider) throws IOException\n     {\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(value)) {\n-            serializeContents(value, jgen, provider);\n+            serializeContents(value, gen, provider);\n             return;\n         }\n-        jgen.writeStartArray();\n-        serializeContents(value, jgen, provider);\n-        jgen.writeEndArray();\n+        gen.writeStartArray();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        gen.writeEndArray();\n     }\n \n     @Override\n-    public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+    public final void serializeWithType(T value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         // note: let's NOT consider [JACKSON-805] here; gets too complicated, and probably just won't work\n-        typeSer.writeTypePrefixForArray(value, jgen);\n-        serializeContents(value, jgen, provider);\n-        typeSer.writeTypeSuffixForArray(value, jgen);\n+        typeSer.writeTypePrefixForArray(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        typeSer.writeTypeSuffixForArray(value, gen);\n     }\n     \n     protected abstract void serializeContents(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n     // at least if they can provide access to actual size of value and use `writeStartArray()`\n     // variant that passes size of array to output, which is helpful with some data formats\n     @Override\n-    public void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    public void serialize(T value, JsonGenerator gen, SerializerProvider provider) throws IOException\n     {\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(value)) {\n-            serializeContents(value, jgen, provider);\n+            serializeContents(value, gen, provider);\n             return;\n         }\n-        jgen.writeStartArray();\n-        serializeContents(value, jgen, provider);\n-        jgen.writeEndArray();\n-    }\n-\n-    @Override\n-    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+        gen.writeStartArray();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        gen.writeEndArray();\n+    }\n+\n+    @Override\n+    public void serializeWithType(T value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer) throws IOException\n     {\n         // note: let's NOT consider [JACKSON-805] here; gets too complicated, and probably just won't work\n-        typeSer.writeTypePrefixForArray(value, jgen);\n-        serializeContents(value, jgen, provider);\n-        typeSer.writeTypeSuffixForArray(value, jgen);\n-    }\n-\n-    protected abstract void serializeContents(T value, JsonGenerator jgen, SerializerProvider provider)\n+        typeSer.writeTypePrefixForArray(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        typeSer.writeTypeSuffixForArray(value, gen);\n+    }\n+\n+    protected abstract void serializeContents(T value, JsonGenerator gen, SerializerProvider provider)\n         throws IOException;\n \n     @SuppressWarnings(\"deprecation\")\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n      */\n \n     @Override\n-    public void serialize(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n+    public void serialize(Map<?,?> value, JsonGenerator gen, SerializerProvider provider)\n         throws IOException\n     {\n-        jgen.writeStartObject();\n+        gen.writeStartObject();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (!value.isEmpty()) {\n             Object suppressableValue = _suppressableValue;\n             if (suppressableValue == null) {\n                 value = _orderEntries(value);\n             }\n             if (_filterId != null) {\n-                serializeFilteredFields(value, jgen, provider,\n+                serializeFilteredFields(value, gen, provider,\n                         findPropertyFilter(provider, _filterId, value), suppressableValue);\n             } else if (suppressableValue != null) {\n-                serializeOptionalFields(value, jgen, provider, suppressableValue);\n+                serializeOptionalFields(value, gen, provider, suppressableValue);\n             } else if (_valueSerializer != null) {\n-                serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n-            } else {\n-                serializeFields(value, jgen, provider);\n-            }\n-        }\n-        jgen.writeEndObject();\n-    }\n-\n-    @Override\n-    public void serializeWithType(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+                serializeFieldsUsing(value, gen, provider, _valueSerializer);\n+            } else {\n+                serializeFields(value, gen, provider);\n+            }\n+        }\n+        gen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer)\n         throws IOException\n     {\n-        typeSer.writeTypePrefixForObject(value, jgen);\n+        typeSer.writeTypePrefixForObject(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (!value.isEmpty()) {\n             Object suppressableValue = _suppressableValue;\n             if (suppressableValue == null) {\n                 value = _orderEntries(value);\n             }\n             if (_filterId != null) {\n-                serializeFilteredFields(value, jgen, provider,\n+                serializeFilteredFields(value, gen, provider,\n                         findPropertyFilter(provider, _filterId, value), suppressableValue);\n             } else if (suppressableValue != null) {\n-                serializeOptionalFields(value, jgen, provider, suppressableValue);\n+                serializeOptionalFields(value, gen, provider, suppressableValue);\n             } else if (_valueSerializer != null) {\n-                serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n-            } else {\n-                serializeFields(value, jgen, provider);\n-            }\n-        }\n-        typeSer.writeTypeSuffixForObject(value, jgen);\n+                serializeFieldsUsing(value, gen, provider, _valueSerializer);\n+            } else {\n+                serializeFields(value, gen, provider);\n+            }\n+        }\n+        typeSer.writeTypeSuffixForObject(value, gen);\n     }\n \n     /*\n      * Method called to serialize fields, when the value type is not statically known;\n      * but we know that no value suppression is needed (which simplifies processing a bit)\n      */\n-    public void serializeFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n+    public void serializeFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider)\n         throws IOException\n     {\n         // If value type needs polymorphic type handling, some more work needed:\n         if (_valueTypeSerializer != null) {\n-            serializeTypedFields(value, jgen, provider, null);\n+            serializeTypedFields(value, gen, provider, null);\n             return;\n         }\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n             // First, serialize key\n             Object keyElem = entry.getKey();\n             if (keyElem == null) {\n-                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n+                provider.findNullKeySerializer(_keyType, _property).serialize(null, gen, provider);\n             } else {\n                 // One twist: is entry ignorable? If so, skip\n                 if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySerializer.serialize(keyElem, jgen, provider);\n+                keySerializer.serialize(keyElem, gen, provider);\n             }\n \n             // And then value\n             if (valueElem == null) {\n-                provider.defaultSerializeNull(jgen);\n+                provider.defaultSerializeNull(gen);\n             } else {\n                 Class<?> cc = valueElem.getClass();\n                 JsonSerializer<Object> serializer = serializers.serializerFor(cc);\n                     serializers = _dynamicValueSerializers;\n                 }\n                 try {\n-                    serializer.serialize(valueElem, jgen, provider);\n+                    serializer.serialize(valueElem, gen, provider);\n                 } catch (Exception e) {\n                     // Add reference information\n                     String keyDesc = \"\"+keyElem;\n         }\n     }\n \n-    public void serializeOptionalFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+    public void serializeOptionalFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n             Object suppressableValue)\n         throws IOException\n     {\n         // If value type needs polymorphic type handling, some more work needed:\n         if (_valueTypeSerializer != null) {\n-            serializeTypedFields(value, jgen, provider, suppressableValue);\n+            serializeTypedFields(value, gen, provider, suppressableValue);\n             return;\n         }\n         final HashSet<String> ignored = _ignoredEntries;\n             }\n             // and then serialize, if all went well\n             try {\n-                keySerializer.serialize(keyElem, jgen, provider);\n-                valueSer.serialize(valueElem, jgen, provider);\n+                keySerializer.serialize(keyElem, gen, provider);\n+                valueSer.serialize(valueElem, gen, provider);\n             } catch (Exception e) {\n                 String keyDesc = \"\"+keyElem;\n                 wrapAndThrow(provider, e, value, keyDesc);\n      * so that value serializer is passed and does not need to be fetched from\n      * provider.\n      */\n-    protected void serializeFieldsUsing(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+    protected void serializeFieldsUsing(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n             JsonSerializer<Object> ser)\n         throws IOException\n     {\n             if (ignored != null && ignored.contains(keyElem)) continue;\n \n             if (keyElem == null) {\n-                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n-            } else {\n-                keySerializer.serialize(keyElem, jgen, provider);\n+                provider.findNullKeySerializer(_keyType, _property).serialize(null, gen, provider);\n+            } else {\n+                keySerializer.serialize(keyElem, gen, provider);\n             }\n             final Object valueElem = entry.getValue();\n             if (valueElem == null) {\n-                provider.defaultSerializeNull(jgen);\n+                provider.defaultSerializeNull(gen);\n             } else {\n                 try {\n                     if (typeSer == null) {\n-                        ser.serialize(valueElem, jgen, provider);\n+                        ser.serialize(valueElem, gen, provider);\n                     } else {\n-                        ser.serializeWithType(valueElem, jgen, provider, typeSer);\n+                        ser.serializeWithType(valueElem, gen, provider, typeSer);\n                     }\n                 } catch (Exception e) {\n                     String keyDesc = \"\"+keyElem;\n      * \n      * @since 2.5\n      */\n-    public void serializeFilteredFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+    public void serializeFilteredFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n             PropertyFilter filter,\n             Object suppressableValue) // since 2.5\n         throws IOException\n             // and with that, ask filter to handle it\n             prop.reset(keyElem, keySerializer, valueSer);\n             try {\n-                filter.serializeAsField(valueElem, jgen, provider, prop);\n+                filter.serializeAsField(valueElem, gen, provider, prop);\n             } catch (Exception e) {\n                 String keyDesc = \"\"+keyElem;\n                 wrapAndThrow(provider, e, value, keyDesc);\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.StdNodeBasedDeserializer;\n+import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.deser.std.*;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.util.StdConverter;\n \n         }\n         \n     }\n-    \n+\n+    // for [databind#631]\n+    static class Issue631Bean\n+    {\n+        @JsonDeserialize(using=ParentClassDeserializer.class)\n+        public Object prop;\n+    }\n+    \n+    static class ParentClassDeserializer\n+        extends StdScalarDeserializer<Object>\n+    {\n+        protected ParentClassDeserializer() {\n+            super(Object.class);\n+        }\n+\n+        @Override\n+        public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+                throws IOException {\n+            Object parent = p.getCurrentValue();\n+            String desc = (parent == null) ? \"NULL\" : parent.getClass().getSimpleName();\n+            return \"prop/\"+ desc;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertNotNull(w.value.inner);\n         assertEquals(-13, w.value.inner.x);\n     }\n+\n+    // [#631]: \"current value\" access\n+    public void testCurrentValueAccess() throws Exception\n+    {\n+        Issue631Bean bean = MAPPER.readValue(aposToQuotes(\"{'prop':'stuff'}\"),\n+                Issue631Bean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"prop/Issue631Bean\", bean.prop);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.ser.std.CollectionSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\n+import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer;\n import com.fasterxml.jackson.databind.util.StdConverter;\n \n /**\n         }\n     }\n \n+    // for [databind#631]\n+    static class Issue631Bean\n+    {\n+        @JsonSerialize(using=ParentClassSerializer.class)\n+        public Object prop;\n+\n+        public Issue631Bean(Object o) {\n+            prop = o;\n+        }\n+    }\n+    \n+    static class ParentClassSerializer\n+        extends StdScalarSerializer<Object>\n+    {\n+        protected ParentClassSerializer() {\n+            super(Object.class);\n+        }\n+\n+        @Override\n+        public void serialize(Object value, JsonGenerator gen,\n+                SerializerProvider provider) throws IOException {\n+            Object parent = gen.getCurrentValue();\n+            String desc = (parent == null) ? \"NULL\" : parent.getClass().getSimpleName();\n+            gen.writeString(desc+\"/\"+value);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Unit tests\n     // [Issue#215]: Allow registering CharacterEscapes via ObjectWriter\n     public void testCustomEscapes() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         assertEquals(quote(\"foo\\\\u0062\\\\Ar\"),\n-                mapper.writer(new CustomEscapes()).writeValueAsString(\"foobar\"));\n+                MAPPER.writer(new CustomEscapes()).writeValueAsString(\"foobar\"));\n     }\n     \n     public void testNumberSubclass() throws Exception\n         assertEquals(aposToQuotes(\"{'x':42}\"),\n                 MAPPER.writeValueAsString(new LikeNumber(42)));\n     }\n+\n+    public void testWithCurrentValue() throws Exception\n+    {\n+        assertEquals(aposToQuotes(\"{'prop':'Issue631Bean/42'}\"),\n+                MAPPER.writeValueAsString(new Issue631Bean(42)));\n+    }\n }", "timestamp": 1417456408, "metainfo": ""}