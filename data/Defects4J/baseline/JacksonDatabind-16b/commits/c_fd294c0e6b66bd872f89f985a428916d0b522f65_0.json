{"sha": "fd294c0e6b66bd872f89f985a428916d0b522f65", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeSerializerBase.java\n     protected String idFromValue(Object value) {\n         String id = _idResolver.idFromValue(value);\n         if (id == null) {\n-            String typeDesc = (value == null) ? \"NULL\" : value.getClass().getName();\n-            throw new IllegalArgumentException(\"Can not resolve type id for \"\n-                    +typeDesc+\" (using \"+_idResolver.getClass().getName()+\")\");\n+            handleMissingId(value);\n         }\n         return id;\n     }\n     protected String idFromValueAndType(Object value, Class<?> type) {\n         String id = _idResolver.idFromValueAndType(value, type);\n         if (id == null) {\n-            String typeDesc = (value == null) ? \"NULL\" : value.getClass().getName();\n-            throw new IllegalArgumentException(\"Can not resolve type id for \"\n-                    +typeDesc+\" (using \"+_idResolver.getClass().getName()+\")\");\n+            handleMissingId(value);\n         }\n         return id;\n     }\n+\n+    // As per [databind#633], maybe better just not do anything...\n+    protected void handleMissingId(Object value) {\n+        /*\n+        String typeDesc = (value == null) ? \"NULL\" : value.getClass().getName();\n+        throw new IllegalArgumentException(\"Can not resolve type id for \"\n+                +typeDesc+\" (using \"+_idResolver.getClass().getName()+\")\");\n+                */\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n     /**\n      * Method for checking whether we could find a deserializer\n      * for given type.\n-     * \n+     *\n      * @param type\n      * @since 2.3\n      */\n     }\n \n     /**\n+     * Variant that will try to locate deserializer for current type, but without\n+     * performing any contextualization (unlike {@link #findContextualValueDeserializer})\n+     * or checking for need to create a {@link TypeDeserializer} (unlike\n+     * {@link #findRootValueDeserializer(JavaType)}.\n+     * This method is usually called from within {@link ResolvableDeserializer#resolve},\n+     * and expectation is that caller then calls either\n+     * {@link #handlePrimaryContextualization(JsonDeserializer, BeanProperty)} or\n+     * {@link #handleSecondaryContextualization(JsonDeserializer, BeanProperty)} at a\n+     * later point, as necessary.\n+     *\n+     * @since 2.5\n+     */\n+    public final JsonDeserializer<Object> findNonContextualValueDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        return _cache.findValueDeserializer(this, _factory, type);\n+    }\n+    \n+    /**\n      * Method for finding a deserializer for root-level value.\n      */\n     @SuppressWarnings(\"unchecked\")\n             BeanProperty prop)\n         throws JsonMappingException\n     {\n-        if (deser != null) {\n-            if (deser instanceof ContextualDeserializer) {\n-                deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n-            }\n+        if (deser instanceof ContextualDeserializer) {\n+            deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n         }\n         return deser;\n     }\n      */\n     public JsonDeserializer<?> handleSecondaryContextualization(JsonDeserializer<?> deser,\n             BeanProperty prop)\n-        throws JsonMappingException {\n-        if (deser != null && (deser instanceof ContextualDeserializer)) {\n+        throws JsonMappingException\n+    {\n+        if (deser instanceof ContextualDeserializer) {\n             deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n         }\n         return deser;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n         _stringDeserializer = (JsonDeserializer<Object>) stringDeser;\n         _numberDeserializer = (JsonDeserializer<Object>) numberDeser;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Initialization\n     protected JsonDeserializer<Object> _findCustomDeser(DeserializationContext ctxt, JavaType type)\n         throws JsonMappingException\n     {\n-        // NOTE: since we don't yet have the referring property, this should be fine:\n-        JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(type);\n+        // Since we are calling from `resolve`, we should NOT try to contextualize yet;\n+        // contextualization will only occur at a later point\n+        JsonDeserializer<?> deser = ctxt.findNonContextualValueDeserializer(type);\n         if (ClassUtil.isJacksonStdImpl(deser)) {\n             return null;\n         }\n                 &&  getClass() == UntypedObjectDeserializer.class) {\n             return Vanilla.std;\n         }\n-        JsonDeserializer<?> mapDeserializer = _mapDeserializer;\n-        if (mapDeserializer instanceof ContextualDeserializer) {\n-            mapDeserializer = ((ContextualDeserializer)mapDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> listDeserializer = _listDeserializer;\n-        if (listDeserializer instanceof ContextualDeserializer) {\n-            listDeserializer = ((ContextualDeserializer)listDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> stringDeserializer = _stringDeserializer;\n-        if (stringDeserializer instanceof ContextualDeserializer) {\n-            stringDeserializer = ((ContextualDeserializer)stringDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> numberDeserializer = _numberDeserializer;\n-        if (numberDeserializer instanceof ContextualDeserializer) {\n-            numberDeserializer = ((ContextualDeserializer)numberDeserializer).createContextual(ctxt, property);\n-        }\n+        JsonDeserializer<?> mapDeserializer = ctxt.handlePrimaryContextualization(_mapDeserializer, property);\n+        JsonDeserializer<?> listDeserializer = ctxt.handlePrimaryContextualization(_listDeserializer, property);\n+        JsonDeserializer<?> stringDeserializer = ctxt.handlePrimaryContextualization(_stringDeserializer, property);\n+        JsonDeserializer<?> numberDeserializer = ctxt.handlePrimaryContextualization(_numberDeserializer, property);\n \n         // And if anything changed, we'll need to change too!\n         if ((mapDeserializer != _mapDeserializer)\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n     protected JsonNode _at(JsonPointer ptr) {\n         return get(ptr.getMatchingIndex());\n     }\n-    \n+\n     // note: co-variant to allow caller-side type safety\n     @SuppressWarnings(\"unchecked\")\n     @Override\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n-\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n \n /**\n- * Unit tests for verifying \"old\" data binding from JSON to JDK objects;\n+ * Unit tests for verifying \"raw\" (or \"untyped\") data binding from JSON to JDK objects;\n  * one that only uses core JDK types; wrappers, Maps and Lists.\n  */\n+@SuppressWarnings(\"serial\")\n public class TestUntypedDeserialization\n     extends BaseMapTest\n {\n-    @SuppressWarnings(\"serial\")\n     static class UCStringDeserializer\n         extends StdScalarDeserializer<String>\n     {\n         public UCStringDeserializer() { super(String.class); }\n \n         @Override\n-        public String deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n+        public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n             return jp.getText().toUpperCase();\n         }\n     }\n \n-    @SuppressWarnings(\"serial\")\n     static class CustomNumberDeserializer\n         extends StdScalarDeserializer<Number>\n     {\n         }\n \n         @Override\n-        public Number deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n+        public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n             return value;\n         }\n     }\n \n-    @SuppressWarnings(\"serial\")\n+    // Let's make this Contextual, to tease out cyclic resolution issues, if any\n     static class ListDeserializer extends StdDeserializer<List<Object>>\n+        implements ContextualDeserializer\n     {\n         public ListDeserializer() { super(List.class); }\n \n             }\n             return list;\n         }\n-    }\n-\n-    @SuppressWarnings(\"serial\")\n+\n+        @Override\n+        public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+                BeanProperty property) throws JsonMappingException\n+        {\n+            // For now, we just need to access \"untyped\" deserializer; not use it.\n+            \n+            /*JsonDeserializer<Object> ob = */\n+            ctxt.findContextualValueDeserializer(ctxt.constructType(Object.class), property);\n+            return this;\n+        }\n+    }\n+\n     static class MapDeserializer extends StdDeserializer<Map<String,Object>>\n     {\n         public MapDeserializer() { super(Map.class); }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestForwardReference.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+\n+/**\n+ * Test for testing forward reference handling\n+ */\n+public class TestForwardReference extends BaseMapTest {\n+\n+\tprivate final ObjectMapper MAPPER = new ObjectMapper()\n+\t\t\t.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)\n+\t\t\t.enable(SerializationFeature.INDENT_OUTPUT)\n+\t\t\t.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n+\n+\t/** Tests that we can read a hierarchical structure with forward references*/\n+\tpublic void testForwardRef() throws IOException {\n+\t\tMAPPER.readValue(\"{\" +\n+\t\t\t\t\"  \\\"@type\\\" : \\\"TestForwardReference$ForwardReferenceContainerClass\\\",\" +\n+\t\t\t\t\"  \\\"frc\\\" : \\\"willBeForwardReferenced\\\",\" +\n+\t\t\t\t\"  \\\"yac\\\" : {\" +\n+\t\t\t\t\"    \\\"@type\\\" : \\\"TestForwardReference$YetAnotherClass\\\",\" +\n+\t\t\t\t\"    \\\"frc\\\" : {\" +\n+\t\t\t\t\"      \\\"@type\\\" : \\\"One\\\",\" +\n+\t\t\t\t\"      \\\"id\\\" : \\\"willBeForwardReferenced\\\"\" +\n+\t\t\t\t\"    },\" +\n+\t\t\t\t\"    \\\"id\\\" : \\\"anId\\\"\" +\n+\t\t\t\t\"  },\" +\n+\t\t\t\t\"  \\\"id\\\" : \\\"ForwardReferenceContainerClass1\\\"\" +\n+\t\t\t\t\"}\", ForwardReferenceContainerClass.class);\n+\n+\n+\t}\n+\n+\t@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include= JsonTypeInfo.As.PROPERTY)\n+\tpublic static class ForwardReferenceContainerClass\n+\t{\n+\t\tpublic ForwardReferenceClass frc;\n+\t\tpublic YetAnotherClass yac;\n+\t\tpublic String id;\n+\t}\n+\n+\t@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)\n+\t@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")\n+\t@JsonSubTypes({\n+\t\t\t@JsonSubTypes.Type(value = ForwardReferenceClassOne.class, name = \"One\"),\n+\t\t\t@JsonSubTypes.Type(value = ForwardReferenceClassTwo.class, name = \"Two\")})\n+\tstatic abstract class ForwardReferenceClass\n+\t{\n+\t\tpublic String id;\n+\t\tpublic void setId(String id) {\n+\t\t\tthis.id = id;\n+\t\t}\n+\t}\n+\n+\t@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)\n+\tstatic class YetAnotherClass\n+\t{\n+\t\tpublic YetAnotherClass() {}\n+\t\tpublic ForwardReferenceClass frc;\n+\t\tpublic String id;\n+\t}\n+\n+\tpublic static class ForwardReferenceClassOne extends ForwardReferenceClass { }\n+\n+\tpublic static class ForwardReferenceClassTwo extends ForwardReferenceClass { }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n         }\n     }\n \n-    public void testKeepCollectionOrdering()\n-        throws Exception\n+    public void testKeepCollectionOrdering() throws Exception\n     {\n         String json = \"{\\\"employees\\\":[2,1,\"\n                 + \"{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":null,\\\"reports\\\":[2]},\"\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestParentChildReferences.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestParentChildReferences\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Test classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * First, a simple 'tree': just parent/child linkage\n+     */\n+    static class SimpleTreeNode\n+    {\n+        public String name;\n+        \n+        // Reference back to parent; reference, ignored during ser,\n+        // re-constructed during deser\n+        @JsonBackReference\n+        public SimpleTreeNode parent;\n+\n+        // Reference that is serialized normally during ser, back\n+        // reference within pointed-to instance assigned to point to\n+        // referring bean (\"this\")\n+        @JsonManagedReference\n+        public SimpleTreeNode child;\n+\n+        public SimpleTreeNode() { this(null); }\n+        public SimpleTreeNode(String n) { name = n; }\n+    }\n+\n+    static class SimpleTreeNode2\n+    {\n+        public String name;\n+        protected SimpleTreeNode2 parent;\n+        protected SimpleTreeNode2 child;\n+\n+        public SimpleTreeNode2() { this(null); }\n+        public SimpleTreeNode2(String n) { name = n; }\n+\n+        @JsonBackReference\n+        public SimpleTreeNode2 getParent() { return parent; }\n+        public void setParent(SimpleTreeNode2 p) { parent = p; }\n+\n+        @JsonManagedReference\n+        public SimpleTreeNode2 getChild() { return child; }\n+        public void setChild(SimpleTreeNode2 c) { child = c; }\n+    }\n+    \n+    /**\n+     * Then nodes with two separate linkages; parent/child\n+     * and prev/next-sibling\n+     */\n+    static class FullTreeNode\n+    {\n+        public String name;\n+\n+        // parent-child links\n+        @JsonBackReference(\"parent\")\n+        public FullTreeNode parent;\n+        @JsonManagedReference(\"parent\")\n+        public FullTreeNode firstChild;\n+\n+        // sibling-links\n+        @JsonManagedReference(\"sibling\")\n+        public FullTreeNode next;\n+        @JsonBackReference(\"sibling\")\n+        protected FullTreeNode prev;\n+        \n+        public FullTreeNode() { this(null); }\n+        public FullTreeNode(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    /**\n+     * Class for testing managed references via arrays\n+     */\n+    static class NodeArray\n+    {\n+        @JsonManagedReference(\"arr\")\n+        public ArrayNode[] nodes;\n+    }\n+\n+    static class ArrayNode\n+    {\n+        public String name;\n+        \n+        @JsonBackReference(\"arr\")\n+        public NodeArray parent;\n+\n+        public ArrayNode() { this(null); }\n+        public ArrayNode(String n) { name = n; }\n+    }\n+    \n+    /**\n+     * Class for testing managed references via Collections\n+     */\n+    static class NodeList\n+    {\n+        @JsonManagedReference\n+        public List<NodeForList> nodes;\n+    }\n+\n+    static class NodeForList\n+    {\n+        public String name;\n+        \n+        @JsonBackReference\n+        public NodeList parent;\n+\n+        public NodeForList() { this(null); }\n+        public NodeForList(String n) { name = n; }\n+    }\n+    \n+    static class NodeMap\n+    {\n+        @JsonManagedReference\n+        public Map<String,NodeForMap> nodes;\n+    }\n+\n+    static class NodeForMap\n+    {\n+        public String name;\n+        \n+        @JsonBackReference\n+        public NodeMap parent;\n+\n+        public NodeForMap() { this(null); }\n+        public NodeForMap(String n) { name = n; }\n+    }\n+\n+    public static class Parent {\n+        @JsonManagedReference\n+        protected final List<Child> children = new ArrayList<Child>();\n+\n+        public List<Child> getChildren() { return children; }\n+\n+        public void addChild(Child child) { children.add(child); child.setParent(this); }\n+    }\n+\n+    public static class Child {\n+        protected Parent parent;\n+        protected final String value; // So that the bean is not empty of properties\n+\n+        public Child(@JsonProperty(\"value\") String value) { this.value = value; }\n+\n+        public String getValue() { return value; }\n+\n+        @JsonBackReference\n+        public Parent getParent() { return parent; }\n+\n+        public void setParent(Parent parent) { this.parent = parent; }\n+    }\n+\n+    @JsonTypeInfo(use=Id.NAME)\n+    @JsonSubTypes({@JsonSubTypes.Type(ConcreteNode.class)})\n+    static abstract class AbstractNode\n+    {\n+        public String id;\n+        \n+        @JsonManagedReference public AbstractNode next;\n+        @JsonBackReference public AbstractNode prev;\n+    }\n+\n+    @JsonTypeName(\"concrete\")\n+    static class ConcreteNode extends AbstractNode {\n+        public ConcreteNode() { }\n+        public ConcreteNode(String id) { this.id = id; }\n+    }\n+    \n+    // [JACKSON-708]\n+    static class Model708 { }\n+    \n+    static class Advertisement708 extends Model708 {\n+        public String title;\n+        @JsonManagedReference public List<Photo708> photos;\n+    }\n+\n+    static class Photo708 extends Model708 {\n+        public int id;\n+        @JsonBackReference public Advertisement708 advertisement;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = objectMapper();\n+    \n+    public void testSimpleRefs() throws Exception\n+    {\n+        SimpleTreeNode root = new SimpleTreeNode(\"root\");\n+        SimpleTreeNode child = new SimpleTreeNode(\"kid\");\n+        root.child = child;\n+        child.parent = root;\n+        \n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        SimpleTreeNode resultNode = MAPPER.readValue(json, SimpleTreeNode.class);\n+        assertEquals(\"root\", resultNode.name);\n+        SimpleTreeNode resultChild = resultNode.child;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+    }\n+\n+    // [JACKSON-693]\n+    public void testSimpleRefsWithGetter() throws Exception\n+    {\n+        SimpleTreeNode2 root = new SimpleTreeNode2(\"root\");\n+        SimpleTreeNode2 child = new SimpleTreeNode2(\"kid\");\n+        root.child = child;\n+        child.parent = root;\n+        \n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        SimpleTreeNode2 resultNode = MAPPER.readValue(json, SimpleTreeNode2.class);\n+        assertEquals(\"root\", resultNode.name);\n+        SimpleTreeNode2 resultChild = resultNode.child;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+    }\n+    \n+    public void testFullRefs() throws Exception\n+    {\n+        FullTreeNode root = new FullTreeNode(\"root\");\n+        FullTreeNode child1 = new FullTreeNode(\"kid1\");\n+        FullTreeNode child2 = new FullTreeNode(\"kid2\");\n+        root.firstChild = child1;\n+        child1.parent = root;\n+        child1.next = child2;\n+        child2.prev = child1;\n+        \n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        FullTreeNode resultNode = MAPPER.readValue(json, FullTreeNode.class);\n+        assertEquals(\"root\", resultNode.name);\n+        FullTreeNode resultChild = resultNode.firstChild;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid1\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+\n+        // and then sibling linkage\n+        assertNull(resultChild.prev);\n+        FullTreeNode resultChild2 = resultChild.next;\n+        assertNotNull(resultChild2);\n+        assertEquals(\"kid2\", resultChild2.name);\n+        assertSame(resultChild, resultChild2.prev);\n+        assertNull(resultChild2.next);\n+    }\n+\n+    public void testArrayOfRefs() throws Exception\n+    {\n+        NodeArray root = new NodeArray();\n+        ArrayNode node1 = new ArrayNode(\"a\");\n+        ArrayNode node2 = new ArrayNode(\"b\");\n+        root.nodes = new ArrayNode[] { node1, node2 };\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeArray result = MAPPER.readValue(json, NodeArray.class);\n+        ArrayNode[] kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.length);\n+        assertEquals(\"a\", kids[0].name);\n+        assertEquals(\"b\", kids[1].name);\n+        assertSame(result, kids[0].parent);\n+        assertSame(result, kids[1].parent);\n+    }\n+\n+    public void testListOfRefs() throws Exception\n+    {\n+        NodeList root = new NodeList();\n+        NodeForList node1 = new NodeForList(\"a\");\n+        NodeForList node2 = new NodeForList(\"b\");\n+        root.nodes = Arrays.asList(node1, node2);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeList result = MAPPER.readValue(json, NodeList.class);\n+        List<NodeForList> kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.size());\n+        assertEquals(\"a\", kids.get(0).name);\n+        assertEquals(\"b\", kids.get(1).name);\n+        assertSame(result, kids.get(0).parent);\n+        assertSame(result, kids.get(1).parent);\n+    }\n+\n+    public void testMapOfRefs() throws Exception\n+    {\n+        NodeMap root = new NodeMap();\n+        NodeForMap node1 = new NodeForMap(\"a\");\n+        NodeForMap node2 = new NodeForMap(\"b\");\n+        Map<String,NodeForMap> nodes = new HashMap<String, NodeForMap>();\n+        nodes.put(\"a1\", node1);\n+        nodes.put(\"b2\", node2);\n+        root.nodes = nodes;\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeMap result = MAPPER.readValue(json, NodeMap.class);\n+        Map<String,NodeForMap> kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.size());\n+        assertNotNull(kids.get(\"a1\"));\n+        assertNotNull(kids.get(\"b2\"));\n+        assertEquals(\"a\", kids.get(\"a1\").name);\n+        assertEquals(\"b\", kids.get(\"b2\").name);\n+        assertSame(result, kids.get(\"a1\").parent);\n+        assertSame(result, kids.get(\"b2\").parent);\n+    }\n+\n+    // for [JACKSON-368]\n+    public void testAbstract368() throws Exception\n+    {\n+        AbstractNode parent = new ConcreteNode(\"p\");\n+        AbstractNode child = new ConcreteNode(\"c\");\n+        parent.next = child;\n+        child.prev = parent;\n+\n+        // serialization ought to be ok\n+        String json = MAPPER.writeValueAsString(parent);\n+\n+        AbstractNode root = MAPPER.readValue(json, AbstractNode.class);\n+\n+        assertEquals(ConcreteNode.class, root.getClass());\n+        assertEquals(\"p\", root.id);\n+        assertNull(root.prev);\n+        AbstractNode leaf = root.next;\n+        assertNotNull(leaf);\n+        assertEquals(\"c\", leaf.id);\n+        assertSame(root, leaf.prev);\n+    }\n+    \n+    public void testIssue693() throws Exception\n+    {\n+        Parent parent = new Parent();\n+        parent.addChild(new Child(\"foo\"));\n+        parent.addChild(new Child(\"bar\"));\n+        byte[] bytes = MAPPER.writeValueAsBytes(parent);\n+        Parent value = MAPPER.readValue(bytes, Parent.class); \n+        for (Child child : value.children) {\n+            assertEquals(value, child.getParent());\n+        }\n+    }\n+\n+    public void testIssue708() throws Exception\n+    {\n+        Advertisement708 ad = MAPPER.readValue(\"{\\\"title\\\":\\\"Hroch\\\",\\\"photos\\\":[{\\\"id\\\":3}]}\", Advertisement708.class);      \n+        assertNotNull(ad);\n+    }   \n+}", "timestamp": 1417020689, "metainfo": ""}