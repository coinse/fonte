{"sha": "09ad6820e892387852c46958e03eaa1d3f3b10f6", "log": "Fixed #421 (phew!)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n         return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                 config.canOverrideAccessModifiers());\n     }\n-    \n+\n     protected void _addDeserializerConstructors\n         (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n          AnnotationIntrospector intr, CreatorCollector creators)\n         throws JsonMappingException\n     {\n-        /* First things first: the \"default constructor\" (zero-arg\n-         * constructor; whether implicit or explicit) is NOT included\n-         * in list of constructors, so needs to be handled separately.\n-         */\n+        // First things first: the \"default constructor\" (zero-arg\n+        // constructor; whether implicit or explicit) is NOT included\n+        // in list of constructors, so needs to be handled separately.\n         AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n         if (defaultCtor != null) {\n             if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) {\n             }\n         }\n \n+        // And then other constructors\n+        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n+            boolean isCreator = intr.hasCreatorAnnotation(ctor);\n+            int argCount = ctor.getParameterCount();\n+            // some single-arg factory methods (String, number) are auto-detected\n+            if (argCount == 1) {\n+                AnnotatedParameter param = ctor.getParameter(0);\n+                // NOTE: only consider EXPLICIT names for auto-detection\n+                PropertyName pn = _findExplicitParamName(param, intr);\n+                Object injectId = intr.findInjectableValueId(param);\n+\n+                if ((injectId == null) && (pn == null || pn.isEmpty())) { // not property based\n+                    _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n+                            ctor, isCreator,\n+                            vchecker.isCreatorVisible(ctor), pn);\n+                    // otherwise just ignored\n+                    continue;\n+                }\n+                // fall through if there's name\n+            }\n+            \n+            // 1 or more args; all params must have name annotations\n+            AnnotatedParameter nonAnnotatedParam = null;            \n+            CreatorProperty[] properties = new CreatorProperty[argCount];\n+            int explicitNameCount = 0;\n+            int implicitNameCount = 0;\n+            int injectCount = 0;            \n+            for (int i = 0; i < argCount; ++i) {\n+                AnnotatedParameter param = ctor.getParameter(i);\n+                PropertyName name = _findExplicitParamName(param, intr);\n+                Object injectId = intr.findInjectableValueId(param);\n+                if (name != null && name.hasSimpleName()) {\n+                    ++explicitNameCount;\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n+                    continue;\n+                }\n+                if (injectId != null) {\n+                    ++injectCount;\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n+                    continue;\n+                }\n+                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n+                if (unwrapper != null) {\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n+                    ++explicitNameCount;\n+                    continue;\n+                }\n+                // One more thing: implicit names are ok iff ctor has creator annotation\n+                if (isCreator) {\n+                    name = _findImplicitParamName(param, intr);\n+                    if (name != null && !name.isEmpty()) {\n+                        ++implicitNameCount;\n+                        properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n+                        continue;\n+                    }\n+                }\n+                if (nonAnnotatedParam == null) {\n+                    nonAnnotatedParam = param;\n+                }\n+                // 23-Sep-2014, tatu: TODO: probably will need support for using implicit\n+                //   names, still, \n+            }\n+\n+            final int namedCount = explicitNameCount + implicitNameCount;\n+            // Ok: if named or injectable, we have more work to do\n+            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n+                // simple case; everything covered:\n+                if ((namedCount + injectCount) == argCount) {\n+                    creators.addPropertyCreator(ctor, properties);\n+                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n+                    // [712] secondary: all but one injectable, one un-annotated (un-named)\n+                    creators.addDelegatingCreator(ctor, properties);\n+                } else { // otherwise, epic fail\n+                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n+                            +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n+                }\n+            }\n+        }\n+    }\n+\n+    /* 23-Sep-2014, tatu: This is the old definition of method above, from 2.4.x,\n+     *   rewritten in 2.5. Left here until 2.6, just in case there's a regression,\n+     *   and we need to inspect diffs...\n+     */\n+/*    \n+    protected void XXX_addDeserializerConstructors\n+        (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+         AnnotationIntrospector intr, CreatorCollector creators)\n+        throws JsonMappingException\n+    {\n+        // First things first: the \"default constructor\" (zero-arg\n+        // constructor; whether implicit or explicit) is NOT included\n+        // in list of constructors, so needs to be handled separately.\n+        AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n+        if (defaultCtor != null) {\n+            if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) {\n+                creators.setDefaultCreator(defaultCtor);\n+            }\n+        }\n+\n         PropertyName[] ctorPropNames = null;\n         AnnotatedConstructor propertyCtor = null;\n+        \n         for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n             if (propDef.getConstructorParameter() != null) {\n                 AnnotatedParameter param = propDef.getConstructorParameter();\n                     if (propertyCtor == null) {\n                         propertyCtor = (AnnotatedConstructor) owner;\n                         ctorPropNames = new PropertyName[propertyCtor.getParameterCount()];\n+                    } else if (owner != propertyCtor) {\n+                        // there is a mismatch of some kind here (problem?)\n+                        continue;\n                     }\n                     ctorPropNames[param.getIndex()] = propDef.getFullName();\n                 }\n         }\n \n         for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n+\n             int argCount = ctor.getParameterCount();\n             boolean isCreator = intr.hasCreatorAnnotation(ctor) || (ctor == propertyCtor);\n //            boolean isCreator = intr.hasCreatorAnnotation(ctor);\n             \n             boolean isVisible =  vchecker.isCreatorVisible(ctor);\n+            \n             // some single-arg constructors (String, number) are auto-detected\n             if (argCount == 1) {\n                 PropertyName name = (ctor == propertyCtor) ? ctorPropNames[0] : null;\n             // [JACKSON-541] improved handling a bit so:\n             // 2 or more args; all params must have name annotations\n             // ... or @JacksonInject (or equivalent)\n-            /* [JACKSON-711] One more possibility; can have 1 or more injectables, and\n-             * exactly one non-annotated parameter: if so, it's still delegating.\n-             */\n+            // [JACKSON-711] One more possibility; can have 1 or more injectables, and\n+            // exactly one non-annotated parameter: if so, it's still delegating.\n             AnnotatedParameter nonAnnotatedParam = null;\n             int namedCount = 0;\n             int injectCount = 0;\n                     }\n                 }\n             }\n-\n-            // Ok: if named or injectable, we have more work to do\n             if (isCreator || namedCount > 0 || injectCount > 0) {\n                 // simple case; everything covered:\n                 if ((namedCount + injectCount) == argCount) {\n             }\n         }\n     }\n+*/\n \n     protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt,\n             BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n                 }\n                 continue;\n             }\n+            \n             // some single-arg factory methods (String, number) are auto-detected\n             if (argCount == 1) {\n                 AnnotatedParameter param = factory.getParameter(0);\n         }\n         return null;\n     }\n+\n+    protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n+    {\n+        String str = intr.findImplicitPropertyName(param);\n+        if (str != null && !str.isEmpty()) {\n+            return new PropertyName(str);\n+        }\n+        return null;\n+    }\n     \n     protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n         if (!expl) {\n             if (impl.isEmpty()) {\n                 /* Important: if neither implicit nor explicit name, can not make use\n-                 * of this creator paramter -- may or may not be a problem, verified\n+                 * of this creator parameter -- may or may not be a problem, verified\n                  * at a later point.\n                  */\n+                return;\n+            }\n+            // Also: if this occurs, there MUST be explicit annotation on creator itself\n+            if (!_annotationIntrospector.hasCreatorAnnotation(param.getOwner())) {\n                 return;\n             }\n             pn = new PropertyName(impl);\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators421.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+\n+public class TestCreators421 extends BaseMapTest\n+{\n+    static class MultiCtor\n+    {\n+        protected String _a, _b;\n+        \n+        private MultiCtor() { }\n+        private MultiCtor(String a, String b, Boolean c) {\n+            if (c == null) {\n+                throw new RuntimeException(\"Wrong factory!\");\n+            }\n+            _a = a;\n+            _b = b;\n+        }\n+\n+        @JsonCreator\n+        static MultiCtor factory(@JsonProperty(\"a\") String a, @JsonProperty(\"b\") String b) {\n+            return new MultiCtor(a, b, Boolean.TRUE);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MyParamIntrospector extends JacksonAnnotationIntrospector\n+    {\n+        @Override\n+        public String findImplicitPropertyName(AnnotatedMember param) {\n+            if (param instanceof AnnotatedParameter) {\n+                AnnotatedParameter ap = (AnnotatedParameter) param;\n+                switch (ap.getIndex()) {\n+                case 0: return \"a\";\n+                case 1: return \"b\";\n+                case 2: return \"c\";\n+                default:\n+                    return \"param\"+ap.getIndex();\n+                }\n+            }\n+            return super.findImplicitPropertyName(param);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    // [Issue#421]\n+    public void testMultiCtor421() throws Exception\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.setAnnotationIntrospector(new MyParamIntrospector());\n+\n+        MultiCtor bean = mapper.readValue(aposToQuotes(\"{'a':'123','b':'foo'}\"), MultiCtor.class);\n+        assertNotNull(bean);\n+        assertEquals(\"123\", bean._a);\n+        assertEquals(\"foo\", bean._b);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/failing/TestTypeWithJsonValue466.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestTypeWithJsonValue466.java\n package com.fasterxml.jackson.failing;\n \n import java.io.*;\n+import java.math.BigDecimal;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n     // The following is required for the testDecimalMetadata test case. That case fails.\n     @JsonTypeName(value = \"decimalValue\")\n     public static class DecimalValue {\n-        private java.math.BigDecimal value;\n-        public DecimalValue(){ this.value = java.math.BigDecimal.valueOf( 1234.4321 ); }\n+        private BigDecimal value;\n+        public DecimalValue() { value = new BigDecimal(\"111.1\"); }\n      \n         @JsonValue\n-        public java.math.BigDecimal getValue(){ return value; }\n+        public BigDecimal getValue(){ return value; }\n     }\n \n     @JsonPropertyOrder({\"key\",\"value\"})\n     public static class DecimalEntry {\n-    public DecimalEntry(){}\n-        public String getKey(){ return \"num\"; }\n+    public DecimalEntry() {}\n+        public String getKey() { return \"num\"; }\n          \n         @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.EXTERNAL_PROPERTY)\n         public DecimalValue getValue(){\n     @JsonTypeName(value = \"doubleValue\")\n     public static class DoubleValue {\n         private Double value;\n-        public DoubleValue(){ this.value = 1234.4321; }\n+        public DoubleValue() { value = 1234.25; }\n          \n         @JsonValue\n-        public Double getValue(){ return value; }\n+        public Double getValue() { return value; }\n     }\n \n     @JsonPropertyOrder({\"key\",\"value\"})\n     \n     public void testDoubleMetadata() throws IOException {\n         DoubleMetadata doub = new DoubleMetadata();\n-        String expected = \"{\\\"metadata\\\":[{\\\"key\\\":\\\"num\\\",\\\"value\\\":1234.4321,\\\"@type\\\":\\\"doubleValue\\\"}]}\";\n+        String expected = \"{\\\"metadata\\\":[{\\\"key\\\":\\\"num\\\",\\\"value\\\":1234.25,\\\"@type\\\":\\\"doubleValue\\\"}]}\";\n         String json = MAPPER.writeValueAsString(doub);\n         assertEquals(\"Serialized json not equivalent\", expected, json);\n     }\n \n     public void testDecimalMetadata() throws IOException{\n         DecimalMetadata dec = new DecimalMetadata();\n-        String expected = \"{\\\"metadata\\\":[{\\\"key\\\":\\\"num\\\",\\\"value\\\":1234.4321,\\\"@type\\\":\\\"decimalValue\\\"}]}\";\n+        String expected = \"{\\\"metadata\\\":[{\\\"key\\\":\\\"num\\\",\\\"value\\\":111.1,\\\"@type\\\":\\\"decimalValue\\\"}]}\";\n         String json = MAPPER.writeValueAsString(dec);\n         assertEquals(\"Serialized json not equivalent\", expected, json);\n     }", "timestamp": 1411535472, "metainfo": ""}