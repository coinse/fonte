{"sha": "3f0ca2ef4bce571e381ad1f357cf5c0b797c8f0e", "log": "finishing touches for timezone/date handling", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n-import com.fasterxml.jackson.databind.util.ArrayBuilders;\n-import com.fasterxml.jackson.databind.util.ClassUtil;\n-import com.fasterxml.jackson.databind.util.LinkedNode;\n-import com.fasterxml.jackson.databind.util.ObjectBuffer;\n-import com.fasterxml.jackson.databind.util.StdDateFormat;\n+import com.fasterxml.jackson.databind.util.*;\n \n /**\n  * Context for the process of deserialization a single root-level value.\n         if (_dateFormat != null) {\n             return _dateFormat;\n         }\n-        /* 24-Feb-2012, tatu: This is tricky: whether we should force timezone\n-         *   on DateFormat? Let's only do that if (and only if) we are using\n-         *   the default date format, but not if overridden.\n+        /* 24-Feb-2012, tatu: At this point, all timezone configuration\n+         *    should have occured, with respect to default dateformat\n+         *    and timezone configuration. But we still better clone\n+         *    an instance as formatters may be stateful.\n          */\n         DateFormat df = _config.getDateFormat();\n-        if (df.getClass() == StdDateFormat.class) {\n-            TimeZone tz = _config.getTimeZone();\n-            df = ((StdDateFormat) df).withTimeZone(tz);\n-        } else {\n-            df = (DateFormat) df.clone();\n-            /*\n-            df.setTimeZone(tz);\n-            */\n-        }\n-        _dateFormat = df;\n+        _dateFormat = df = (DateFormat) df.clone();\n         return df;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n import java.io.IOException;\n import java.lang.reflect.Type;\n import java.text.DateFormat;\n-import java.util.Date;\n-import java.util.Locale;\n-import java.util.TimeZone;\n+import java.util.*;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.RootNameLookup;\n-import com.fasterxml.jackson.databind.util.StdDateFormat;\n \n /**\n  * Class that defines API used by {@link ObjectMapper} and\n         if (_dateFormat != null) {\n             return _dateFormat;\n         }\n-        /* 24-Feb-2012, tatu: This is tricky: whether we should force timezone\n-         *   on DateFormat? Let's only do that if we have not specified custom\n-         *   DateFormat.\n+        /* 24-Feb-2012, tatu: At this point, all timezone configuration\n+         *    should have occured, with respect to default dateformat\n+         *    and timezone configuration. But we still better clone\n+         *    an instance as formatters may be stateful.\n          */\n         DateFormat df = _config.getDateFormat();\n-        if (df.getClass() == StdDateFormat.class) {\n-            TimeZone tz = _config.getTimeZone();\n-            df = ((StdDateFormat) df).withTimeZone(tz);\n-        } else {\n-            df = (DateFormat) df.clone();\n-        }\n-        _dateFormat = df;\n+        _dateFormat = df = (DateFormat) df.clone();\n         return df;\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.StdDateFormat;\n \n /**\n  * Immutable container class used to store simple configuration\n      * Default {@link java.util.TimeZone} used with serialization formats.\n      * Default value is {@link Timezone#getDefault()}, which is typically the\n      * local timezone (unless overridden for JVM).\n+     *<p>\n+     * Note that if a new value is set, timezone is also assigned to\n+     * {@link #_dateFormat} of this object.\n      */\n     protected final TimeZone _timeZone;\n     \n                 _typeResolverBuilder, _dateFormat, _handlerInstantiator, l, _timeZone);\n     }\n \n-    public BaseSettings with(TimeZone tz) {\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, tz);\n+    /**\n+     * Fluent factory for constructing a new instance that uses specified TimeZone.\n+     * Note that timezone used with also be assigned to configured {@link DateFormat},\n+     * changing time formatting defaults.\n+     */\n+    public BaseSettings with(TimeZone tz)\n+    {\n+        if (tz == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        DateFormat df = _dateFormat;\n+        if (df instanceof StdDateFormat) {\n+            df = ((StdDateFormat) df).withTimeZone(tz);\n+        } else {\n+            // we don't know if original format might be shared; better create a clone:\n+            df = (DateFormat) df.clone();\n+            df.setTimeZone(tz);\n+        }\n+        return new BaseSettings(_classIntrospector, _annotationIntrospector,\n+                _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                _typeResolverBuilder, df, _handlerInstantiator, _locale, tz);\n     }\n     \n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n         json = mapper.writeValueAsString(new DateInCETBean(0L));\n         assertEquals(\"{\\\"date\\\":\\\"1970-01-01,01:00\\\"}\", json);\n     }\n+\n+    /**\n+     * Test to ensure that setting a TimeZone _after_ dateformat should enforce\n+     * that timezone on format, regardless of TimeZone format had.\n+     */\n+    public void testWithTimeZoneOverride() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd/HH:mm\"));\n+        mapper.setTimeZone(TimeZone.getTimeZone(\"PST\"));\n+        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+        String json = mapper.writeValueAsString(new Date(0));\n+        // pacific time is GMT-8; so midnight becomes 16:00 previous day:\n+        assertEquals(quote(\"1969-12-31/16:00\"), json);\n+    }\n }\n ", "timestamp": 1330214048, "metainfo": ""}