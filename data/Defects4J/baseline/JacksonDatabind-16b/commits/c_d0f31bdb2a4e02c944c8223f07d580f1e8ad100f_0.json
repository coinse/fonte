{"sha": "d0f31bdb2a4e02c944c8223f07d580f1e8ad100f", "log": "previously removed generateSchema is returned  also, moved jsonValueFormat into core, along with SchemaType  factored the rest of new schema into jackphel/jackson-module-jsonSchema", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n     public Object findFilterId(AnnotatedClass ac) {\n         return null;\n     }\n-    \n+\n     /**\n      * Method for finding {@link PropertyNamingStrategy} for given\n      * class, if any specified by annotations; and if so, either return\n      */\n     public Object findNamingStrategy(AnnotatedClass ac) {\n         return null;\n-    }\n-    \n+    }    \n+\n     /*\n     /**********************************************************\n     /* Property auto-detection\n             }\n             return str;\n         }\n-        \n+\n         /*\n         /******************************************************\n         /* Property auto-detection\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n     public DeserializationConfig with(TimeZone tz) {\n         return _withBase(_base.with(tz));\n     }\n+\n+    @Override\n+    public DeserializationConfig with(Base64Variant base64) {\n+        return _withBase(_base.with(base64));\n+    }\n     \n     private final DeserializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new DeserializationConfig(this, newBase);\n     public LinkedNode<DeserializationProblemHandler> getProblemHandlers() {\n         return _problemHandlers;\n     }\n-    \n-    /**\n-     * Method called during deserialization if Base64 encoded content\n-     * needs to be decoded. Default version just returns default Jackson\n-     * uses, which is modified-mime which does not add linefeeds (because\n-     * those would have to be escaped in JSON strings).\n-     */\n-    public Base64Variant getBase64Variant() {\n-        return Base64Variants.getDefaultVariant();\n-    }\n \n     public final JsonNodeFactory getNodeFactory() {\n         return _nodeFactory;\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.jsontype.*;\n import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n             null, StdDateFormat.instance, null,\n             Locale.getDefault(),\n //            TimeZone.getDefault()\n-            TimeZone.getTimeZone(\"GMT\")\n+            TimeZone.getTimeZone(\"GMT\"),\n+            Base64Variants.getDefaultVariant() // 2.1\n             );\n     \n     /*\n \n     /**\n      * Method for setting defalt POJO property inclusion strategy for serialization.\n-     * Equivalent to:\n-     *<pre>\n-     *  mapper.setSerializationConfig(mapper.getSerializationConfig().withSerializationInclusion(incl));\n-     *</pre>\n      */\n     public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n         _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n         return this;\n     }\n-   \n+    \n     /*\n     /**********************************************************\n     /* Type information configuration (1.5+)\n     public ObjectWriter writer(FormatSchema schema) {\n         return new ObjectWriter(this, getSerializationConfig(), schema);\n     }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * use specified Base64 encoding variant for Base64-encoded binary data.\n+     * \n+     * @since 2.1\n+     */\n+    public ObjectWriter writer(Base64Variant defaultBase64) {\n+        return new ObjectWriter(this, getSerializationConfig().with(defaultBase64));\n+    }\n     \n     /*\n     /**********************************************************\n      * pass specific schema object to {@link JsonParser} used for\n      * reading content.\n      * \n-     * @param schema JsonSchema to pass to parser\n+     * @param schema Schema to pass to parser\n      */\n     public ObjectReader reader(FormatSchema schema) {\n         return new ObjectReader(this, getDeserializationConfig(), null, null,\n      */\n     public ObjectReader readerWithView(Class<?> view) {\n         return new ObjectReader(this, getDeserializationConfig().withView(view));\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectReader} that will\n+     * use specified Base64 encoding variant for Base64-encoded binary data.\n+     * \n+     * @since 2.1\n+     */\n+    public ObjectReader reader(Base64Variant defaultBase64) {\n+        return new ObjectReader(this, getDeserializationConfig().with(defaultBase64));\n     }\n     \n     /*\n \n     /*\n     /**********************************************************\n-    /* Extended Public API: JSON JsonSchema generation\n-    /**********************************************************\n-     */\n-\n+    /* Extended Public API: JSON Schema generation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Generate <a href=\"http://json-schema.org/\">Json-schema</a>\n+     * instance for specified class.\n+     *\n+     * @param t The class to generate schema for\n+     * @return Constructed JSON schema.\n+     */\n+    public JsonSchema generateJsonSchema(Class<?> t) throws JsonMappingException {\n+        return _serializerProvider(getSerializationConfig()).generateJsonSchema(t);\n+    }\n+    \n     /**\n      * Generate <a href=\"http://json-schema.org/\">Json-schema</a>\n      * instance for specified class.\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n      * Method for constructing a new reader instance that is configured\n      * with specified feature enabled.\n      */\n-    public ObjectReader with(DeserializationFeature feature) \n-    {\n-        DeserializationConfig newConfig = _config.with(feature);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    public ObjectReader with(DeserializationFeature feature) {\n+        return _with(_config.with(feature));\n     }    \n \n     /**\n     public ObjectReader with(DeserializationFeature first,\n             DeserializationFeature... other)\n     {\n-        DeserializationConfig newConfig = _config.with(first, other);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+        return _with(_config.with(first, other));\n     }    \n \n     /**\n      * Method for constructing a new reader instance that is configured\n      * with specified features enabled.\n      */\n-    public ObjectReader withFeatures(DeserializationFeature... features)\n-    {\n-        DeserializationConfig newConfig = _config.withFeatures(features);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    public ObjectReader withFeatures(DeserializationFeature... features) {\n+        return _with(_config.withFeatures(features));\n     }    \n     \n     /**\n      * Method for constructing a new reader instance that is configured\n      * with specified feature disabled.\n      */\n-    public ObjectReader without(DeserializationFeature feature) \n-    {\n-        DeserializationConfig newConfig = _config.without(feature);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    public ObjectReader without(DeserializationFeature feature) {\n+        return _with(_config.without(feature)); \n     }    \n \n     /**\n     public ObjectReader without(DeserializationFeature first,\n             DeserializationFeature... other)\n     {\n-        DeserializationConfig newConfig = _config.without(first, other);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+        return _with(_config.without(first, other));\n     }    \n \n     /**\n      * Method for constructing a new reader instance that is configured\n      * with specified features disabled.\n      */\n-    public ObjectReader withoutFeatures(DeserializationFeature... features)\n-    {\n-        DeserializationConfig newConfig = _config.withoutFeatures(features);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n+        return _with(_config.withoutFeatures(features));\n     }    \n     \n     /**\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader with(JsonNodeFactory f)\n-    {\n-        DeserializationConfig newConfig = _config.with(f);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    public ObjectReader with(JsonNodeFactory f) {\n+        return _with(_config.with(f));\n     }\n \n     /**\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    public ObjectReader withRootName(String rootName)\n-    {\n-        DeserializationConfig newConfig = _config.withRootName(rootName);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+    public ObjectReader withRootName(String rootName) {\n+        return _with(_config.withRootName(rootName));\n     }\n     \n     /**\n      * rather construct and returns a newly configured instance.\n      */\n     public ObjectReader withView(Class<?> activeView) {\n-        DeserializationConfig newConfig = _config.withView(activeView);\n-        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+        return _with(_config.withView(activeView));\n     }\n \n     public ObjectReader with(Locale l) {\n-        DeserializationConfig newConfig = _config.with(l);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.with(l));\n     }\n \n     public ObjectReader with(TimeZone tz) {\n-        DeserializationConfig newConfig = _config.with(tz);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.with(tz));\n     }\n \n     public ObjectReader withHandler(DeserializationProblemHandler h) {\n-        DeserializationConfig newConfig = _config.withHandler(h);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.withHandler(h));\n+    }\n+\n+    public ObjectReader with(Base64Variant defaultBase64) {\n+        return _with(_config.with(defaultBase64));\n+    }\n+\n+    protected ObjectReader _with(DeserializationConfig newConfig) {\n+        if (newConfig == _config) return this;\n+        return new ObjectReader(this, newConfig);\n     }\n     \n     /*\n         return t;\n     }\n \n-    \n-static int col = 0;\n+//static int col = 0;\n \n     /**\n      * Method called to locate deserializer for the passed root-level value.\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n     }\n     \n     /**\n-     * Helper method used when value to serialize is {@link java.util.Closeable}\n-     * and its <code>close()</code>\n+     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n      * method is to be called right after serialization has been called\n      */\n     private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg)\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.core.Base64Variant;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfigBase;\n     public SerializationConfig with(TimeZone tz) {\n         return _withBase(_base.with(tz));\n     }\n+\n+    @Override\n+    public SerializationConfig with(Base64Variant base64) {\n+        return _withBase(_base.with(base64));\n+    }\n     \n     private final SerializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new SerializationConfig(this, newBase);\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n \n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.PropertyAccessor;\n+import com.fasterxml.jackson.core.Base64Variant;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n      * {@link #_dateFormat} of this object.\n      */\n     protected final TimeZone _timeZone;\n+\n+    /**\n+     * Explicitly default {@link Base64Variant} to use for handling\n+     * binary data (<code>byte[]</code>), used with data formats\n+     * that use base64 encoding (like JSON, CSV).\n+     * \n+     * @since 2.1\n+     */\n+    protected final Base64Variant _defaultBase64;\n     \n     /*\n     /**********************************************************\n     public BaseSettings(ClassIntrospector ci, AnnotationIntrospector ai,\n             VisibilityChecker<?> vc, PropertyNamingStrategy pns, TypeFactory tf,\n             TypeResolverBuilder<?> typer, DateFormat dateFormat, HandlerInstantiator hi,\n-            Locale locale, TimeZone tz)\n+            Locale locale, TimeZone tz, Base64Variant defaultBase64)\n     {\n         _classIntrospector = ci;\n         _annotationIntrospector = ai;\n         _handlerInstantiator = hi;\n         _locale = locale;\n         _timeZone = tz;\n+        _defaultBase64 = defaultBase64;\n     }\n \n     /*\n      */\n     \n     public BaseSettings withClassIntrospector(ClassIntrospector ci) {\n+        if (_classIntrospector == ci) {\n+            return this;\n+        }\n         return new BaseSettings(ci, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n     \n     public BaseSettings withAnnotationIntrospector(AnnotationIntrospector ai) {\n+        if (_annotationIntrospector == ai) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, ai, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n     }\n     \n     public BaseSettings withVisibilityChecker(VisibilityChecker<?> vc) {\n+        if (_visibilityChecker == vc) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, vc, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility) {\n         return new BaseSettings(_classIntrospector, _annotationIntrospector,\n                 _visibilityChecker.withVisibility(forMethod, visibility),\n                 _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n     \n     public BaseSettings withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n+        if (_propertyNamingStrategy == pns) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, pns, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withTypeFactory(TypeFactory tf) {\n+        if (_typeFactory == tf) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, tf,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withTypeResolverBuilder(TypeResolverBuilder<?> typer) {\n+        if (_typeResolverBuilder == typer) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                typer, _dateFormat, _handlerInstantiator, _locale, _timeZone);\n+                typer, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n+        if (_dateFormat == df) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone);\n+                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n+                _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n+        if (_handlerInstantiator == hi) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, hi, _locale, _timeZone);\n+                _typeResolverBuilder, _dateFormat, hi, _locale,\n+                _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings with(Locale l) {\n+        if (_locale == l) {\n+            return this;\n+        }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, _dateFormat, _handlerInstantiator, l, _timeZone);\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, l,\n+                _timeZone, _defaultBase64);\n     }\n \n     /**\n         }\n         return new BaseSettings(_classIntrospector, _annotationIntrospector,\n                 _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale, tz);\n+                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n+                tz, _defaultBase64);\n+    }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    public BaseSettings with(Base64Variant base64) {\n+        if (base64 == _defaultBase64) {\n+            return this;\n+        }\n+        return new BaseSettings(_classIntrospector, _annotationIntrospector,\n+                _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                _typeResolverBuilder, _dateFormat, _handlerInstantiator, _locale,\n+                _timeZone, base64);\n     }\n     \n     /*\n         return _annotationIntrospector;\n     }\n \n-\n     public VisibilityChecker<?> getVisibilityChecker() {\n         return _visibilityChecker;\n     }\n     public TimeZone getTimeZone() {\n         return _timeZone;\n     }\n+\n+    public Base64Variant getBase64Variant() {\n+        return _defaultBase64;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n import java.util.TimeZone;\n \n import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.core.Base64Variant;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n      * Accessor for finding currently active view, if any (null if none)\n      */\n     public abstract Class<?> getActiveView();\n+\n+    /**\n+     * Method called during deserialization if Base64 encoded content\n+     * needs to be decoded. Default version just returns default Jackson\n+     * uses, which is modified-mime which does not add linefeeds (because\n+     * those would have to be escaped in JSON strings); but this can\n+     * be configured on {@link ObjectWriter}.\n+     */\n+    public Base64Variant getBase64Variant() {\n+        return _base.getBase64Variant();\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n \n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.PropertyAccessor;\n+import com.fasterxml.jackson.core.Base64Variant;\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.MapperFeature;\n import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n     protected final SubtypeResolver _subtypeResolver;\n \n     /**\n-     * Explicitly definite root name to use, if any; if empty\n+     * Explicitly defined root name to use, if any; if empty\n      * String, will disable root-name wrapping; if null, will\n      * use defaults\n      */\n      * default {@link java.util.TimeZone} to use for formatting of date values.\n      */\n     public abstract T with(TimeZone tz);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * default {@link Base64Variant} to use with base64-encoded binary values.\n+     */\n+    public abstract T with(Base64Variant base64);\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n             default:\n                 value = deserializeAny(jp, ctxt, nodeFactory);\n             }\n-            JsonNode old = node.put(fieldName, value);\n+            JsonNode old = node.replace(fieldName, value);\n             if (old != null) {\n                 _handleDuplicateField(fieldName, node, old, value);\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n     {\n         JsonNaming ann = ac.getAnnotation(JsonNaming.class);\n         return (ann == null) ? null : ann.value();\n-    }\n-    \n+    } \n+\n     /*\n     /**********************************************************\n     /* Property auto-detection\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n \n         // Rename remaining properties\n         _renameProperties();\n-\n         // And use custom naming strategy, if applicable...\n         PropertyNamingStrategy naming = _findNamingStrategy();\n         if (naming != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonArrayFormatVisitor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonArrayFormatVisitor.java\n package com.fasterxml.jackson.databind.jsonFormatVisitors;\n \n import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n \n public interface JsonArrayFormatVisitor extends JsonFormatVisitorWithSerializerProvider {\n \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormat.java\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+/**\n+ * This enum represents the encoded format for a jsonSchema value type\n+ * @author jphelan\n+ *\n+ */\n+public enum JsonValueFormat {\n+\t/**\n+\t * This SHOULD be a date in ISO 8601 format of YYYY-MM-\n+      DDThh:mm:ssZ in UTC time.  This is the recommended form of date/\n+      timestamp.\n+\t */\n+\tDATE_TIME {\n+\t\t@Override\n+\t\tpublic String toString() { return \"date-time\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be a date in the format of YYYY-MM-DD.  It is\n+      recommended that you use the \"date-time\" format instead of \"date\"\n+      unless you need to transfer only the date part.\n+\t */\n+\tDATE {\n+\t\t@Override\n+\t\tpublic String toString() { return \"date\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be a time in the format of hh:mm:ss.  It is\n+      recommended that you use the \"date-time\" format instead of \"time\"\n+      unless you need to transfer only the time part.\n+\t */\n+\tTIME {\n+\t\t@Override\n+\t\tpublic String toString() { return \"time\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be the difference, measured in\n+      milliseconds, between the specified time and midnight, 00:00 of\n+      January 1, 1970 UTC.  The value SHOULD be a number (integer or\n+      float).\n+\t */\n+\tUTC_MILLISEC {\n+\t\t@Override\n+\t\tpublic String toString() { return \"utc-millisec\"; }\n+\t},\n+\t\n+\t/**\n+\t * A regular expression, following the regular expression\n+  \t  specification from ECMA 262/Perl 5.\n+\t */\n+\tREGEX {\n+\t\t@Override\n+\t\tpublic String toString() { return \"regex\"; }\n+\t},\n+\t\n+\t/**\n+\t * This is a CSS color (like \"#FF0000\" or \"red\"), based on CSS\n+  \t\t2.1 [W3C.CR-CSS21-20070719].\n+\t */\n+\tCOLOR {\n+\t\t@Override\n+\t\tpublic String toString() { return \"color\"; }\n+\t},\n+\t\n+\t/**\n+\t * This is a CSS style definition (like \"color: red; background-\n+  \t\tcolor:#FFF\"), based on CSS 2.1 [W3C.CR-CSS21-20070719].\n+\t */\n+\tSTYLE {\n+\t\t@Override\n+\t\tpublic String toString() { return \"style\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be a phone number (format MAY follow E.123).\n+\t */\n+\tPHONE {\n+\t\t@Override\n+\t\tpublic String toString() { return \"phone\"; }\n+\t},\n+\t\n+\t/**\n+\t * This value SHOULD be a URI..\n+\t */\n+\tURI {\n+\t\t@Override\n+\t\tpublic String toString() { return \"uri\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be an email address.\n+\t */\n+\tEMAIL {\n+\t\t@Override\n+\t\tpublic String toString() { return \"email\"; }\n+\t},\n+\t/**\n+\t * This SHOULD be an ip version 4 address.\n+\t */\n+\tIP_ADDRESS {\n+\t\t@Override\n+\t\tpublic String toString() { return \"ip-address\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be an ip version 6 address.\n+\t */\n+\tIPV6 {\n+\t\t@Override\n+\t\tpublic String toString() { return \"ipv6\"; }\n+\t},\n+\t\n+\t/**\n+\t * This SHOULD be a host-name.\n+\t */\n+\tHOST_NAME {\n+\t\t@Override\n+\t\tpublic String toString() { return \"host-name\"; }\n+\t}\n+\t\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormatVisitor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/JsonValueFormatVisitor.java\n package com.fasterxml.jackson.databind.jsonFormatVisitors;\n \n import java.util.Set;\n-\n-import com.fasterxml.jackson.databind.jsonschema.types.JsonValueFormat;\n \n public interface JsonValueFormatVisitor {\n \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonFormatVisitors/SchemaType.java\n+package com.fasterxml.jackson.databind.jsonFormatVisitors;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+\n+public enum SchemaType {\n+\t\n+\tSTRING,\n+\tNUMBER,\n+\tINTEGER,\n+\tBOOLEAN,\n+\tOBJECT,\n+\tARRAY,\n+\tNULL,\n+\tANY;\n+\t\n+\t\n+\t@JsonValue\n+\tpublic String value() {\n+\t\treturn this.name().toLowerCase();\n+\t}\n+\t\n+\t@JsonCreator\n+\tpublic static SchemaType forValue(String s) {\n+\t\treturn valueOf(s.toUpperCase());\n+\t}\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/JsonSchema.java\n+package com.fasterxml.jackson.databind.jsonschema;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+/**\n+ * Container for a logical JSON Schema instance.\n+ * Internally schema data is stored as a JSON Tree\n+ * (instance of {@link JsonNode} is the root\n+ * of schema document)\n+ *\n+ * @author Ryan Heaton\n+ * @see <a href=\"http://json-schema.org/\">JSON Schema</a>\n+ */\n+public class JsonSchema\n+{\n+    private final ObjectNode schema;\n+\n+    /**\n+     * Main constructor for schema instances.\n+     *<p>\n+     * This is the creator constructor used by Jackson itself when\n+     * deserializing instances. It is so-called delegating creator, \n+     * meaning that its argument will be bound by Jackson before\n+     * constructor gets called.\n+     */\n+    @JsonCreator\n+    public JsonSchema(ObjectNode schema)\n+    {\n+        this.schema = schema;\n+    }\n+\n+    /**\n+     * Method for accessing root JSON object of the contained schema.\n+     *<p>\n+     * Note: this method is specified with {@link JsonValue} annotation\n+     * to represent serialization to use; same as if explicitly\n+     * serializing returned object.\n+     *\n+     * @return Root node of the schema tree\n+     */\n+    @JsonValue\n+    public ObjectNode getSchemaNode()\n+    {\n+        return schema;\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return this.schema.toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (!(o instanceof JsonSchema)) return false;\n+\n+        JsonSchema other = (JsonSchema) o;\n+        if (schema == null) {\n+            return other.schema == null;\n+        }\n+        return schema.equals(other.schema);\n+    }\n+\n+    /**\n+     * Get the default schema node.\n+     *\n+     * @return The default schema node.\n+     */\n+    public static JsonNode getDefaultSchemaNode()\n+    {\n+        ObjectNode objectNode = JsonNodeFactory.instance.objectNode();\n+        objectNode.put(\"type\", \"any\");\n+        // \"required\" is false by default, no need to include\n+        //objectNode.put(\"required\", false);\n+        return objectNode;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/JsonSerializableSchema.java\n+package com.fasterxml.jackson.databind.jsonschema;\n+\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+\n+/**\n+ * Annotation that can be used to define JSON Schema definition for\n+ * the annotated class.\n+ *<p>\n+ * Note that annotation is often not needed: for example, regular\n+ * Jackson beans that Jackson can introspect can be used without\n+ * annotations, to produce JSON schema definition.\n+ * \n+ * @author Ryan Heaton\n+ * @author Tatu Saloranta\n+ */\n+@Target(ElementType.TYPE)\n+@Retention(RetentionPolicy.RUNTIME)\n+@JacksonAnnotation\n+public @interface JsonSerializableSchema\n+{\n+    /**\n+     * Marker value used to indicate that property has \"no value\";\n+     * needed because annotations can not have null as default\n+     * value.\n+     */\n+    public final static String NO_VALUE = \"##irrelevant\";\n+\n+    /**\n+     * Property that can be used to indicate id of the type when\n+     * generating JSON Schema; empty String indicates that no id\n+     * is defined.\n+     */\n+    public String id() default \"\";\n+    \n+    /**\n+     * The schema type for this JsonSerializable instance.\n+     * Possible values: \"string\", \"number\", \"boolean\", \"object\", \"array\", \"null\", \"any\"\n+     *\n+     * @return The schema type for this JsonSerializable instance.\n+     */\n+    public String schemaType() default \"any\";\n+\n+    /**\n+     * If the schema type is \"object\", JSON definition of properties of the object as\n+     * a String.\n+     *\n+     * @return The node representing the schema properties, or \"##irrelevant\" if irrelevant.\n+     */\n+    public String schemaObjectPropertiesDefinition() default NO_VALUE;\n+\n+    /**\n+     * If the schema type if \"array\", JSON definition of the schema for item types contained.\n+     *\n+     * @return The schema for the items in the array, or \"##irrelevant\" if irrelevant.\n+     */\n+    public String schemaItemDefinition() default NO_VALUE;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/SchemaAware.java\n+package com.fasterxml.jackson.databind.jsonschema;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Marker interface for schema-aware serializers.\n+ */\n+public interface SchemaAware\n+{\n+    /**\n+     * Get the representation of the schema to which this serializer will conform.\n+     *\n+     * @param provider The serializer provider.\n+     * @param typeHint A hint about the type.\n+     * @return <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n+     */\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException;\n+    \n+    /**\n+     * Get the representation of the schema to which this serializer will conform.\n+     *\n+     * @param provider The serializer provider.\n+     * @param isOptional Is the type optional\n+     * @param typeHint A hint about the type.\n+     * @return <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n+     */\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional)\n+        throws JsonMappingException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/package-info.java\n+/**\n+ * Classes needed for JSON schema support (currently just ability\n+ * to generate schemas using serialization part of data mapping)\n+ */\n+package com.fasterxml.jackson.databind.jsonschema;\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n      * Method for removing an entry from this ArrayNode.\n      * Will return value of the entry at specified index, if entry existed;\n      * null if not.\n+     * \n+     * @return Node removed, if any; null if none\n      */\n     public JsonNode remove(int index)\n     {\n         return null;\n     }\n \n+    /**\n+     * Method for removing all elements of this array, leaving the\n+     * array empty.\n+     * \n+     * @return This node (to allow chaining)\n+     */\n     @Override\n     public ArrayNode removeAll()\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/BinaryNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BinaryNode.java\n     public final void serialize(JsonGenerator jg, SerializerProvider provider)\n         throws IOException, JsonProcessingException\n     {\n-        jg.writeBinary(_data);\n+        jg.writeBinary(provider.getConfig().getBase64Variant(),\n+                _data, 0, _data.length);\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n \n     /*\n     /**********************************************************\n-    /* Extended ObjectNode API, mutators, generic\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Method that will set specified field, replacing old value,\n-     * if any.\n+    /* Extended ObjectNode API, mutators, since 2.1\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will set specified field, replacing old value, if any.\n+     * Note that this is identical to {@link #replace(String, JsonNode)},\n+     * except for return value.\n+     *<p>\n+     * NOTE: added to replace those uses of {@link #put(String, JsonNode)}\n+     * where chaining with 'this' is desired.\n      *\n      * @param value to set field to; if null, will be converted\n      *   to a {@link NullNode} first  (to remove field entry, call\n      *   {@link #remove} instead)\n      *\n-     * @return Old value of the field, if any; null if there was no\n-     *   old value.\n-     */\n-    public JsonNode put(String fieldName, JsonNode value)\n-    {\n-        if (value == null) { // let's not store 'raw' nulls but nodes\n+     * @return This node after adding/replacing property value (to allow chaining)\n+     *\n+     * @since 2.1\n+     */\n+    public JsonNode set(String fieldName, JsonNode value)\n+    {\n+        if (value == null) {\n             value = nullNode();\n         }\n-        return _put(fieldName, value);\n-    }\n-\n-    /**\n-     * Method for removing field entry from this ObjectNode.\n-     * Will return value of the field, if such field existed;\n-     * null if not.\n-     * \n-     * @return Value of specified field, if it existed; null if not\n-     */\n-    public JsonNode remove(String fieldName)\n-    {\n-        if (_children != null) {\n-            return _children.remove(fieldName);\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * Method for removing specified field properties out of\n-     * this ObjectNode.\n-     * \n-     * @param fieldNames Names of fields to remove\n-     * \n-     * @return This ObjectNode after removing entries\n-     */\n-    public ObjectNode remove(Collection<String> fieldNames)\n-    {\n-        if (_children != null) {\n-            for (String fieldName : fieldNames) {\n-                _children.remove(fieldName);\n-            }\n-        }\n-        return this;\n-    }\n-    \n-    /**\n-     * Method for removing all field properties, such that this\n-     * ObjectNode will contain no properties after call.\n-     * \n-     * @return This ObjectNode after removing all entries\n-     */\n-    @Override\n-    public ObjectNode removeAll()\n-    {\n-        _children = null;\n+        _put(fieldName, value);\n         return this;\n     }\n \n      * \n      * @param properties Properties to add\n      * \n-     * @return This node (to allow chaining)\n-     */\n-    public JsonNode putAll(Map<String,JsonNode> properties)\n+     * @return This node after adding/replacing property values (to allow chaining)\n+     *\n+     * @since 2.1\n+     */\n+    public JsonNode setAll(Map<String,JsonNode> properties)\n     {\n         if (_children == null) {\n             _children = new LinkedHashMap<String, JsonNode>(properties);\n      * any existing values for those properties.\n      * \n      * @param other Object of which properties to add to this object\n-     * \n-     * @return This node (to allow chaining)\n-     */\n-    public JsonNode putAll(ObjectNode other)\n+     *\n+     * @return This node after addition (to allow chaining)\n+     *\n+     * @since 2.1\n+     */\n+    public JsonNode setAll(ObjectNode other)\n     {\n         int len = other.size();\n         if (len > 0) {\n         }\n         return this;\n     }\n+    \n+    /**\n+     * Method for replacing value of specific property with passed\n+     * value, and returning value (or null if none).\n+     *\n+     * @param fieldName Property of which value to replace\n+     * @param value Value to set property to, replacing old value if any\n+     * \n+     * @return Old value of the property; null if there was no such property\n+     *   with value\n+     * \n+     * @since 2.1\n+     */\n+    public JsonNode replace(String fieldName, JsonNode value)\n+    {\n+        if (value == null) { // let's not store 'raw' nulls but nodes\n+            value = nullNode();\n+        }\n+        return _put(fieldName, value);\n+    }\n+\n+    /**\n+     * Method for removing field entry from this ObjectNode, and\n+     * returning instance after removal.\n+     * \n+     * @return This node after removing entry (if any)\n+     * \n+     * @since 2.1\n+     */\n+    public JsonNode without(String fieldName)\n+    {\n+        if (_children != null) {\n+            _children.remove(fieldName);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for removing specified field properties out of\n+     * this ObjectNode.\n+     * \n+     * @param fieldNames Names of fields to remove\n+     * \n+     * @return This node after removing entries\n+     * \n+     * @since 2.1\n+     */\n+    public ObjectNode without(Collection<String> fieldNames)\n+    {\n+        if (_children != null) {\n+            for (String fieldName : fieldNames) {\n+                _children.remove(fieldName);\n+            }\n+        }\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended ObjectNode API, mutators, generic\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that will set specified field, replacing old value, if any.\n+     *\n+     * @param value to set field to; if null, will be converted\n+     *   to a {@link NullNode} first  (to remove field entry, call\n+     *   {@link #remove} instead)\n+     *<p>\n+     * NOTE: this method will be <b>deprecated</b> in 2.2; and should\n+     * be replace with either\n+     * {@link #set(String,JsonNode)} or {@link #replace(String,JsonNode)},\n+     * depending on which return value is desired for possible chaining.\n+     *   \n+     * @return Old value of the field, if any; null if there was no\n+     *   old value.\n+     */\n+    public JsonNode put(String fieldName, JsonNode value)\n+    {\n+        if (value == null) { // let's not store 'raw' nulls but nodes\n+            value = nullNode();\n+        }\n+        return _put(fieldName, value);\n+    }\n+    \n+    /**\n+     * Method for removing field entry from this ObjectNode.\n+     * Will return value of the field, if such field existed;\n+     * null if not.\n+     * \n+     * @return Value of specified field, if it existed; null if not\n+     */\n+    public JsonNode remove(String fieldName)\n+    {\n+        if (_children != null) {\n+            return _children.remove(fieldName);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Method for removing specified field properties out of\n+     * this ObjectNode.\n+     * \n+     * @param fieldNames Names of fields to remove\n+     * \n+     * @return This node after removing entries\n+     */\n+    public ObjectNode remove(Collection<String> fieldNames)\n+    {\n+        if (_children != null) {\n+            for (String fieldName : fieldNames) {\n+                _children.remove(fieldName);\n+            }\n+        }\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for removing all field properties, such that this\n+     * ObjectNode will contain no properties after call.\n+     * \n+     * @return This node after removing all entries\n+     */\n+    @Override\n+    public ObjectNode removeAll()\n+    {\n+        _children = null;\n+        return this;\n+    }\n+\n+    /**\n+     * Method for adding given properties to this object node, overriding\n+     * any existing values for those properties.\n+     *<p>\n+     * NOTE: this method will be <b>deprecated</b> in 2.2; and should\n+     * be replace with {@link #setAll(Map)}.\n+     * \n+     * @param properties Properties to add\n+     * \n+     * @return This node after adding/replacing property values (to allow chaining)\n+     */\n+    public JsonNode putAll(Map<String,JsonNode> properties) {\n+        return setAll(properties);\n+    }\n+\n+    /**\n+     * Method for adding all properties of the given Object, overriding\n+     * any existing values for those properties.\n+     *<p>\n+     * NOTE: this method will be <b>deprecated</b> in 2.2; and should\n+     * be replace with {@link #setAll(ObjectNode)}.\n+     * \n+     * @param other Object of which properties to add to this object\n+     * \n+     * @return This node (to allow chaining)\n+     */\n+    public JsonNode putAll(ObjectNode other) {\n+        return setAll(other);\n+    }\n \n     /**\n      * Method for removing all field properties out of this ObjectNode\n      * \n      * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n      * \n-     * @return This ObjectNode (to allow call chaining)\n+     * @return This node (to allow call chaining)\n      */\n     public ObjectNode retain(Collection<String> fieldNames)\n     {\n      * \n      * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n      * \n-     * @return This ObjectNode (to allow call chaining)\n+     * @return This node (to allow call chaining)\n      */\n     public ObjectNode retain(String... fieldNames) {\n         return retain(Arrays.asList(fieldNames));\n     }\n \n     /**\n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode putPOJO(String fieldName, Object pojo) {\n         _put(fieldName, POJONode(pojo));\n     }\n \n     /**\n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode putNull(String fieldName)\n     {\n     /**\n      * Method for setting value of a field to specified numeric value.\n      * \n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, int v) {\n         _put(fieldName, numberNode(v));\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n      * \n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, Integer value) {\n         if (value == null) {\n     /**\n      * Method for setting value of a field to specified numeric value.\n      * \n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, long v) {\n         _put(fieldName, numberNode(v));\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n      * \n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, Long value) {\n         if (value == null) {\n     /**\n      * Method for setting value of a field to specified numeric value.\n      * \n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, float v) {\n         _put(fieldName, numberNode(v));\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n      * \n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, Float value) {\n         if (value == null) {\n     /**\n      * Method for setting value of a field to specified numeric value.\n      * \n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, double v) {\n         _put(fieldName, numberNode(v));\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n      * \n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, Double value) {\n         if (value == null) {\n     /**\n      * Method for setting value of a field to specified numeric value.\n      * \n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, BigDecimal v) {\n         if (v == null) {\n     /**\n      * Method for setting value of a field to specified String value.\n      * \n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, String v) {\n         if (v == null) {\n     /**\n      * Method for setting value of a field to specified String value.\n      * \n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, boolean v) {\n         _put(fieldName, booleanNode(v));\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n      * \n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, Boolean value) {\n         if (value == null) {\n     /**\n      * Method for setting value of a field to specified binary value\n      * \n-     * @return This <code>ObjectNode</code>\n+     * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, byte[] v) {\n         if (v == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyFilter.java\n      * \tprocessing\n      *\n      */\n+    public void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode,\n+    \t\tSerializerProvider provider);\n+    \n+    /**\n+     * Method called by {@link BeanSerializer} to let the filter determine whether, and in what\n+     * form the given property exist within the parent, or root, schema. Filters can omit\n+     * adding the property to the node, or choose the form of the schema value for the property\n+     * \n+     * @param writer Bean property serializer to use to create schema value\n+     * @param objectVisitor JsonObjectFormatVisitor which should be aware of \n+     * the property's existence\n+     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n+     * \tprocessing\n+     * \n+     */\n     public void depositSchemaProperty(BeanPropertyWriter writer, JsonObjectFormatVisitor objectVisitor,\n     \t\tSerializerProvider provider);\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n \n     \n     /**\n      * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n-\t\tTODO:fillme\n+     * to generate <a href=\"http://json-schema.org/\">JSON schema</a> for\n+     * given type.\n      *\n      * @param type The type for which to generate schema\n+     */\n+    public JsonSchema generateJsonSchema(Class<?> type)\n+            throws JsonMappingException\n+        {\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"A class must be provided\");\n+            }\n+            /* no need for embedded type information for JSON schema generation (all\n+             * type information it needs is accessible via \"untyped\" serializer)\n+             */\n+            JsonSerializer<Object> ser = findValueSerializer(type, null);\n+            JsonNode schemaNode = (ser instanceof SchemaAware) ?\n+                    ((SchemaAware) ser).getSchema(this, null) : \n+                    JsonSchema.getDefaultSchemaNode();\n+            if (!(schemaNode instanceof ObjectNode)) {\n+                throw new IllegalArgumentException(\"Class \" + type.getName() +\n+                        \" would not be serialized as a JSON object and therefore has no schema\");\n+            }\n+            return new JsonSchema((ObjectNode) schemaNode);\n+        }\n+    \n+    /**\n+     * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n+     * to to expose the format of the given to to the given visitor\n+     *\n+     * @param type The type for which to generate format\n+     * @param visitor the visitor to accept the format\n      */\n     public void acceptJsonFormatVisitor(Class<?> type, JsonFormatVisitorWrapper visitor)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n     }\n \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return null;\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n         ;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n-import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.SchemaType;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.std.StaticListSerializerBase;\n         super(List.class);\n         _serializer = (JsonSerializer<String>) ser;\n         \n+    }\n+    \n+    @Override protected JsonNode contentSchema() {\n+        return createSchemaNode(\"string\", true);\n     }\n \n \t@Override\n             wrapAndThrow(provider, e, value, i);\n         }\n     }\n-\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n import com.fasterxml.jackson.core.JsonGenerator;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.ser.BeanPropertyFilter;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n \t\t}\n \t\t\n \t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n+\t\t\t\tObjectNode propertiesNode, SerializerProvider provider) {\n+\t\t\tif (_propertiesToInclude.contains(writer.getName())) {\n+\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n \t\t\t\tJsonObjectFormatVisitor objectVisitor, SerializerProvider provider) {\n \t\t\tif (_propertiesToInclude.contains(writer.getName())) {\n \t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, objectVisitor);\n \t\t}\n \n \t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n+\t\t\t\tObjectNode propertiesNode, SerializerProvider provider) {\n+\t\t\tif (!_propertiesToExclude.contains(writer.getName())) {\n+\t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, propertiesNode, provider);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tpublic void depositSchemaProperty(BeanPropertyWriter writer,\n \t\t\t\tJsonObjectFormatVisitor objectVisitor, SerializerProvider provider) {\n \t\t\tif (!_propertiesToExclude.contains(writer.getName())) {\n \t\t\t\tBeanSerializerBase.depositSchemaProperty(writer, objectVisitor);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n-import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.SchemaType;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n     }\n \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        ObjectNode o = createSchemaNode(\"array\", true);\n+        o.put(\"items\", createSchemaNode(\"string\"));\n+        return o;\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n     \tvisitor.expectArrayFormat(null).itemsFormat(SchemaType.STRING);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n-import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.SchemaType;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.std.StaticListSerializerBase;\n         super(Collection.class);\n         _serializer = (JsonSerializer<String>) ser;\n     }        \n+    \n+    @Override protected JsonNode contentSchema() {\n+        return createSchemaNode(\"string\", true);\n+    }\n     \n \t@Override\n \tprotected void acceptContentVisitor(JsonArrayFormatVisitor visitor) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n \n     }\n     \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n+        return null;\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) { \n     \tvisitor.expectAnyFormat(typeHint);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.SerializationFeature;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n+import com.fasterxml.jackson.databind.ser.*;\n \n /**\n  * Intermediate base class for serializers used for various\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializationFeature;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n     protected abstract void serializeContents(T value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException;\n \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        /* 15-Jan-2010, tatu: This should probably be rewritten, given that\n+         *    more information about content type is actually being explicitly\n+         *    passed. So there should be less need to try to re-process that\n+         *    information.\n+         */\n+        ObjectNode o = createSchemaNode(\"array\", true);\n+        JavaType contentType = null;\n+        if (typeHint != null) {\n+            JavaType javaType = provider.constructType(typeHint);\n+            contentType = javaType.getContentType();\n+            if (contentType == null) { // could still be parametrized (Iterators)\n+                if (typeHint instanceof ParameterizedType) {\n+                    Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();\n+                    if (typeArgs.length == 1) {\n+                        contentType = provider.constructType(typeArgs[0]);\n+                    }\n+                }\n+            }\n+        }\n+        if (contentType == null && _elementType != null) {\n+            contentType = _elementType;\n+        }\n+        if (contentType != null) {\n+            JsonNode schemaNode = null;\n+            // 15-Oct-2010, tatu: We can't serialize plain Object.class; but what should it produce here? Untyped?\n+            if (contentType.getRawClass() != Object.class) {\n+                JsonSerializer<Object> ser = provider.findValueSerializer(contentType, _property);\n+                if (ser instanceof SchemaAware) {\n+                    schemaNode = ((SchemaAware) ser).getSchema(provider, null);\n+                }\n+            }\n+            if (schemaNode == null) {\n+                schemaNode = JsonSchema.getDefaultSchemaNode();\n+            }\n+            o.put(\"items\", schemaNode);\n+        }\n+        return o;\n+    }\n+    \n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n+import java.lang.reflect.Type;\n+import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.AnyGetterWriter;\n public abstract class BeanSerializerBase\n     extends StdSerializer<Object>\n     implements ContextualSerializer, ResolvableSerializer,\n-        JsonFormatVisitorAware\n+        JsonFormatVisitorAware, SchemaAware\n {\n     final protected static BeanPropertyWriter[] NO_PROPS = new BeanPropertyWriter[0];\n \n         return filter;\n     }\n     \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        ObjectNode o = createSchemaNode(\"object\", true);\n+        // [JACKSON-813]: Add optional JSON Schema id attribute, if found\n+        // NOTE: not optimal, does NOT go through AnnotationIntrospector etc:\n+        JsonSerializableSchema ann = _handledType.getAnnotation(JsonSerializableSchema.class);\n+        if (ann != null) {\n+            String id = ann.id();\n+            if (id != null && id.length() > 0) {\n+                o.put(\"id\", id);\n+            }\n+        }\n+ \n+        //todo: should the classname go in the title?\n+        //o.put(\"title\", _className);\n+        ObjectNode propertiesNode = o.objectNode();\n+        final BeanPropertyFilter filter;\n+        if (_propertyFilterId != null) {\n+        \tfilter = findFilter(provider);\n+        } else {\n+        \tfilter = null;\n+        }\n+        \t\t\n+        for (int i = 0; i < _props.length; i++) {\n+            BeanPropertyWriter prop = _props[i];\n+            if (filter != null) {\n+            \tfilter.depositSchemaProperty(prop, propertiesNode, provider);\n+            \t continue;\n+            }\n+            depositSchemaProperty(prop, propertiesNode, provider);\n+\n+        }\n+        o.put(\"properties\", propertiesNode);\n+        return o;\n+    }\n+    \n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n     \t//deposit your output format \n         }\n     }\n \n-    /**\n-\t * \tAttempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n-\t * \tOtherwise, add the default schema {@link JsonNode} in place of the writer's output\n+    \n+    /**\n+     * \tAttempt to add the output of the given {@link BeanPropertyWriter} in the given {@link ObjectNode}.\n+     * \tOtherwise, add the default schema {@link JsonNode} in place of the writer's output\n+     * \n+     * @param writer Bean property serializer to use to create schema value\n+     * @param propertiesNode Node which the given property would exist within\n+     * @param provider Provider that can be used for accessing dynamic aspects of serialization\n+     * \tprocessing\n+     * \t\n+     *  {@link BeanPropertyFilter#depositSchemaProperty(BeanPropertyWriter, ObjectNode, SerializerProvider)}\n+     */\n+    public static void depositSchemaProperty(BeanPropertyWriter writer, ObjectNode propertiesNode, SerializerProvider provider)\n+    {\n+        JavaType propType = writer.getSerializationType();\n+\n+        // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n+        Type hint = (propType == null) ? writer.getGenericPropertyType() : propType.getRawClass();\n+        JsonNode schemaNode;\n+        // Maybe it already has annotated/statically configured serializer?\n+        JsonSerializer<Object> ser = writer.getSerializer();\n+\n+        try {\n+            if (ser == null) { // nope\n+                Class<?> serType = writer.getRawSerializationType();\n+                if (serType == null) {\n+                    serType = writer.getPropertyType();\n+                }\n+                ser = provider.findValueSerializer(serType, writer);\n+            }\n+            boolean isOptional = !BeanSerializerBase.isPropertyRequired(writer, provider);\n+            if (ser instanceof SchemaAware) {\n+                schemaNode =  ((SchemaAware) ser).getSchema(provider, hint, isOptional) ;\n+            } else {  \n+                schemaNode = JsonSchema.getDefaultSchemaNode(); \n+            }\n+        } catch (JsonMappingException e) {\n+            schemaNode = JsonSchema.getDefaultSchemaNode(); \n+            // TODO: handle in better way (why not throw?)\n+        }\n+        propertiesNode.put(writer.getName(), schemaNode);\n+    }\n+    \n+    /**\n+\t * \tAttempt to add the output of the given {@link BeanPropertyWriter} in the \n+\t *  given {@link JsonObjectFormatVisitor}.\n \t * \n \t * @param writer Bean property serializer to use to create schema value\n-     * @param propertiesNode Node which the given property would exist within\n+     * @param visitor ObjectVisitor which cab receive the propert\n \t */\n \tpublic static void depositSchemaProperty(BeanPropertyWriter writer, JsonObjectFormatVisitor objectVisitor) {\n \t\tif (isPropertyRequired(writer, objectVisitor.getProvider())) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BooleanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BooleanSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n     }\n \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        return createSchemaNode(\"boolean\", !_forPrimitive);\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n         visitor.expectBooleanFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n import java.text.DateFormat;\n import java.util.Calendar;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.*;\n+\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n import java.util.Collection;\n import java.util.Iterator;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n \n import java.io.IOException;\n import java.text.DateFormat;\n-import java.util.Date;\n+import java.util.*;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.text.DateFormat;\n import java.text.SimpleDateFormat;\n import java.util.Locale;\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n-import com.fasterxml.jackson.databind.jsonschema.types.JsonValueFormat;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonValueFormat;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.util.StdDateFormat;\n \n \n     protected abstract long _timestamp(T value);\n     \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        //todo: (ryan) add a format for the date in the schema?\n+        boolean asNumber = _useTimestamp;\n+        if (!asNumber) {\n+            if (_customFormat == null) {\n+                asNumber = provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+            }\n+        }\n+        return createSchemaNode(asNumber ? \"number\" : \"string\", true);\n+    }\n+    \n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n         //todo: (ryan) add a format for the date in the schema?\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n                 }\n             }\n         }\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        ObjectNode o = createSchemaNode(\"object\", true);\n+        if (typeHint instanceof ParameterizedType) {\n+            Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();\n+            if (typeArgs.length == 2) {\n+                JavaType enumType = provider.constructType(typeArgs[0]);\n+                JavaType valueType = provider.constructType(typeArgs[1]);\n+                ObjectNode propsNode = JsonNodeFactory.instance.objectNode();\n+                Class<Enum<?>> enumClass = (Class<Enum<?>>) enumType.getRawClass();\n+                for (Enum<?> enumValue : enumClass.getEnumConstants()) {\n+                    JsonSerializer<Object> ser = provider.findValueSerializer(valueType.getRawClass(), _property);\n+                    JsonNode schemaNode = (ser instanceof SchemaAware) ?\n+                            ((SchemaAware) ser).getSchema(provider, null) :\n+                            JsonSchema.getDefaultSchemaNode();\n+                    propsNode.put(provider.getConfig().getAnnotationIntrospector().findEnumValue((Enum<?>)enumValue), schemaNode);\n+                }\n+                o.put(\"properties\", propsNode);\n+            }\n+        }\n+        return o;\n     }\n     \n     @SuppressWarnings(\"unchecked\")\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.util.HashSet;\n import java.util.Set;\n \n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializationConfig;\n import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonStringFormatVisitor;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.util.EnumValues;\n \n             return;\n         }\n         jgen.writeString(_values.serializedValueFor(en));\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        // [JACKSON-684]: serialize as index?\n+        if (_serializeAsIndex(provider)) {\n+            return createSchemaNode(\"integer\", true);\n+        }\n+        ObjectNode objectNode = createSchemaNode(\"string\", true);\n+        if (typeHint != null) {\n+            JavaType type = provider.constructType(typeHint);\n+            if (type.isEnumType()) {\n+                ArrayNode enumNode = objectNode.putArray(\"enum\");\n+                for (SerializedString value : _values.values()) {\n+                    enumNode.add(value.getValue());\n+                }\n+            }\n+        }\n+        return objectNode;\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n import java.io.IOException;\n import java.util.EnumSet;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n public class EnumSetSerializer\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/InetAddressSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/InetAddressSerializer.java\n import java.io.IOException;\n import java.net.InetAddress;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.*;\n+\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n import java.io.IOException;\n import java.util.Iterator;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.*;\n+\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n+import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.MapperFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.BeanSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n @JacksonStdImpl\n public class JsonValueSerializer\n     extends StdSerializer<Object>\n-    implements ContextualSerializer, JsonFormatVisitorAware\n+    implements ContextualSerializer, JsonFormatVisitorAware, SchemaAware\n {\n     protected final Method _accessorMethod;\n \n     }\n     \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return (_valueSerializer instanceof SchemaAware) ?\n+                ((SchemaAware) _valueSerializer).getSchema(provider, null) :\n+                JsonSchema.getDefaultSchemaNode();\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n     \tif (_valueSerializer instanceof JsonFormatVisitorAware) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.util.HashSet;\n import java.util.Map;\n import java.util.SortedMap;\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n     }\n     \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        ObjectNode o = createSchemaNode(\"object\", true);\n+        //(ryan) even though it's possible to statically determine the \"value\" type of the map,\n+        // there's no way to statically determine the keys, so the \"Entries\" can't be determined.\n+        return o;\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n     \tvisitor.expectObjectFormat(null);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.*;\n+\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NullSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NullSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n+import java.lang.reflect.Type;\n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n \n     }\n     \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return createSchemaNode(\"null\");\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n     \tvisitor.expectNullFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.util.Map;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n \n         }\n     \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"integer\", true);\n+        }\n+        \n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectIntegerFormat(typeHint);\n         }\n     \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"integer\", true);\n+        }\n+        \n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectIntegerFormat(typeHint);\n         }\n     \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"number\", true);\n+        }\n+        \n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectNumberFormat(typeHint);\n             jgen.writeNumber(value.floatValue());\n         }\n     \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"number\", true);\n+        }\n+        \n         @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n             jgen.writeNumber(value.doubleValue());\n         }\n     \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"number\", true);\n+        }\n+        \n         @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         }\n     \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"number\", true);\n+        }\n+        \n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectNumberFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n \n import java.io.IOException;\n import java.lang.reflect.InvocationTargetException;\n-\n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+import com.fasterxml.jackson.databind.type.ArrayType;\n \n /**\n  * Generic serializer for Object arrays (<code>Object[]</code>).\n     }\n     \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        ObjectNode o = createSchemaNode(\"array\", true);\n+        if (typeHint != null) {\n+            JavaType javaType = provider.constructType(typeHint);\n+            if (javaType.isArrayType()) {\n+                Class<?> componentType = ((ArrayType) javaType).getContentType().getRawClass();\n+                // 15-Oct-2010, tatu: We can't serialize plain Object.class; but what should it produce here? Untyped?\n+                if (componentType == Object.class) {\n+                    o.put(\"items\", JsonSchema.getDefaultSchemaNode());\n+                } else {\n+                    JsonSerializer<Object> ser = provider.findValueSerializer(componentType, _property);\n+                    JsonNode schemaNode = (ser instanceof SchemaAware) ?\n+                            ((SchemaAware) ser).getSchema(provider, null) :\n+                            JsonSchema.getDefaultSchemaNode();\n+                    o.put(\"items\", schemaNode);\n+                }\n+            }\n+        }\n+        return o;\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n     \tvisitor.expectArrayFormat(typeHint).itemsFormat(_elementType);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n+import java.lang.reflect.Type;\n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n     }\n     \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        // type not really known, but since it is a JSON string:\n+        return createSchemaNode(\"string\", true);\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n         visitor.expectStringFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializable;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSerializableSchema;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Generic handler for types that implement {@link JsonSerializable}.\n  */\n @JacksonStdImpl\n public class SerializableSerializer\n-    extends StdSerializer<JsonSerializable>\n+extends StdSerializer<JsonSerializable>\n {\n-    public final static SerializableSerializer instance = new SerializableSerializer();\n+\tpublic final static SerializableSerializer instance = new SerializableSerializer();\n \n-    // Ugh. Should NOT need this...\n-    private final static AtomicReference<ObjectMapper> _mapperReference = new AtomicReference<ObjectMapper>();\n-    \n-    protected SerializableSerializer() { super(JsonSerializable.class); }\n+\t// Ugh. Should NOT need this...\n+\tprivate final static AtomicReference<ObjectMapper> _mapperReference = new AtomicReference<ObjectMapper>();\n \n-    @Override\n-    public void serialize(JsonSerializable value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n-        value.serialize(jgen, provider);\n-    }\n+\tprotected SerializableSerializer() { super(JsonSerializable.class); }\n \n-    @Override\n-    public final void serializeWithType(JsonSerializable value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n-    {\n-        value.serializeWithType(jgen, provider, typeSer);\n-    }\n-    \n-    @Override\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-    {\n-    \tvisitor.expectAnyFormat(typeHint);\n-    }\n-    }\n+\t@Override\n+\tpublic void serialize(JsonSerializable value, JsonGenerator jgen, SerializerProvider provider)\n+\t\t\tthrows IOException, JsonGenerationException\n+\t\t\t{\n+\t\tvalue.serialize(jgen, provider);\n+\t\t\t}\n+\n+\t@Override\n+\tpublic final void serializeWithType(JsonSerializable value, JsonGenerator jgen, SerializerProvider provider,\n+\t\t\tTypeSerializer typeSer)\n+\t\t\t\t\tthrows IOException, JsonGenerationException\n+\t\t\t\t\t{\n+\t\tvalue.serializeWithType(jgen, provider, typeSer);\n+\t\t\t\t\t}\n+\n+\t@Override\n+\tpublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+\t\t\tthrows JsonMappingException\n+\t\t\t{\n+\t\tObjectNode objectNode = createObjectNode();\n+\t\tString schemaType = \"any\";\n+\t\tString objectProperties = null;\n+\t\tString itemDefinition = null;\n+\t\tif (typeHint != null) {\n+\t\t\tClass<?> rawClass = TypeFactory.rawClass(typeHint);\n+\t\t\tif (rawClass.isAnnotationPresent(JsonSerializableSchema.class)) {\n+\t\t\t\tJsonSerializableSchema schemaInfo = rawClass.getAnnotation(JsonSerializableSchema.class);\n+\t\t\t\tschemaType = schemaInfo.schemaType();\n+\t\t\t\tif (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaObjectPropertiesDefinition())) {\n+\t\t\t\t\tobjectProperties = schemaInfo.schemaObjectPropertiesDefinition();\n+\t\t\t\t}\n+\t\t\t\tif (!JsonSerializableSchema.NO_VALUE.equals(schemaInfo.schemaItemDefinition())) {\n+\t\t\t\t\titemDefinition = schemaInfo.schemaItemDefinition();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t/* 19-Mar-2012, tatu: geez, this is butt-ugly abonimation of code...\n+\t\t *    really, really should not require back ref to an ObjectMapper.\n+\t\t */\n+\t\tobjectNode.put(\"type\", schemaType);\n+\t\tif (objectProperties != null) {\n+\t\t\ttry {\n+\t\t\t\tobjectNode.put(\"properties\", _getObjectMapper().readTree(objectProperties));\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new JsonMappingException(\"Failed to parse @JsonSerializableSchema.schemaObjectPropertiesDefinition value\");\n+\t\t\t}\n+\t\t}\n+\t\tif (itemDefinition != null) {\n+\t\t\ttry {\n+\t\t\t\tobjectNode.put(\"items\", _getObjectMapper().readTree(itemDefinition));\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tthrow new JsonMappingException(\"Failed to parse @JsonSerializableSchema.schemaItemDefinition value\");\n+\t\t\t}\n+\t\t}\n+\t\t// always optional, no need to specify:\n+\t\t//objectNode.put(\"required\", false);\n+\t\treturn objectNode;\n+\t\t\t}\n+\n+\tprivate final static synchronized ObjectMapper _getObjectMapper()\n+\t{\n+\t\tObjectMapper mapper = _mapperReference.get();\n+\t\tif (mapper == null) {\n+\t\t\tmapper = new ObjectMapper();\n+\t\t\t_mapperReference.set(mapper);\n+\t\t}\n+\t\treturn mapper;\n+\t}\n+\n+\t@Override\n+\tpublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+\t{\n+\t\tvisitor.expectAnyFormat(typeHint);\n+\t}\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlDateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlDateSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n-import com.fasterxml.jackson.databind.jsonschema.types.JsonValueFormat;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonValueFormat;\n \n /**\n  * Compared to regular {@link java.util.Date} serialization, we do use String\n     }\n \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        //todo: (ryan) add a format for the date in the schema?\n+        return createSchemaNode(\"string\", true);\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n     \tvisitor.expectStringFormat(typeHint).format(JsonValueFormat.DATE_TIME);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SqlTimeSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n-import com.fasterxml.jackson.databind.jsonschema.types.JsonValueFormat;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonValueFormat;\n \n @JacksonStdImpl\n public class SqlTimeSerializer\n     }\n \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        return createSchemaNode(\"string\", true);\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n     \tvisitor.expectStringFormat(typeHint).format(JsonValueFormat.DATE_TIME);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n package com.fasterxml.jackson.databind.ser.std;\n \n+import java.lang.reflect.Type;\n import java.util.Collection;\n \n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n \n /**\n  * Intermediate base class for Lists, Collections and Arrays\n     }\n     \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        ObjectNode o = createSchemaNode(\"array\", true);\n+        o.put(\"items\", contentSchema());\n+        return o;\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n     \tacceptContentVisitor(visitor.expectArrayFormat(typeHint));\n     /**********************************************************\n      */\n \n+    protected abstract JsonNode contentSchema();\n+    \n     protected abstract void acceptContentVisitor(JsonArrayFormatVisitor visitor);    \n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.util.HashMap;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n-import com.fasterxml.jackson.databind.jsonschema.types.SchemaType;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.SchemaType;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n         }\n \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            o.put(\"items\", createSchemaNode(\"boolean\"));\n+            return o;\n+        }\n+        \n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectArrayFormat(typeHint).itemsFormat(SchemaType.BOOLEAN);\n         public void serialize(byte[] value, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n-            jgen.writeBinary(value);\n+            jgen.writeBinary(provider.getConfig().getBase64Variant(),\n+                    value, 0, value.length);\n         }\n \n         @Override\n             throws IOException, JsonGenerationException\n         {\n             typeSer.writeTypePrefixForScalar(value, jgen);\n-            jgen.writeBinary(value);\n+            jgen.writeBinary(provider.getConfig().getBase64Variant(),\n+                    value, 0, value.length);\n             typeSer.writeTypeSuffixForScalar(value, jgen);\n+        }\n+        \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            ObjectNode itemSchema = createSchemaNode(\"string\"); //binary values written as strings?\n+            o.put(\"items\", itemSchema);\n+            return o;\n         }\n         \n         @Override\n             }\n         }\n \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            //no \"short\" type defined by json\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            o.put(\"items\", createSchemaNode(\"integer\"));\n+            return o;\n+        }\n+        \n         @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         }\n \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            ObjectNode itemSchema = createSchemaNode(\"string\");\n+            itemSchema.put(\"type\", \"string\");\n+            o.put(\"items\", itemSchema);\n+            return o;\n+        }\n+        \n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectArrayFormat(typeHint).itemsFormat(SchemaType.STRING);\n             }\n         }\n \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            o.put(\"items\", createSchemaNode(\"integer\"));\n+            return o;\n+        }\n+        \n         @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         }\n \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            o.put(\"items\", createSchemaNode(\"number\", true));\n+            return o;\n+        }\n+\n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectArrayFormat(typeHint).itemsFormat(SchemaType.NUMBER);\n         }\n \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            o.put(\"items\", createSchemaNode(\"number\"));\n+            return o;\n+        }\n+        \n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectArrayFormat(typeHint).itemsFormat(SchemaType.NUMBER);\n         }\n \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            o.put(\"items\", createSchemaNode(\"number\"));\n+            return o;\n+        }\n+        \n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectArrayFormat(typeHint).itemsFormat(SchemaType.NUMBER);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdContainerSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdContainerSerializers.java\n package com.fasterxml.jackson.databind.ser.std;\n \n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.impl.IndexedListSerializer;\n import com.fasterxml.jackson.databind.ser.impl.IteratorSerializer;\n+import com.fasterxml.jackson.databind.ser.std.CollectionSerializer;\n \n /**\n  * Dummy container class to group standard container serializers: serializers\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n \n import java.io.File;\n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.util.Collection;\n import java.util.Currency;\n import java.util.HashMap;\n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.BasicSerializerFactory;\n         }\n     \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"boolean\", true);\n+        }\n+        \n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectBooleanFormat(typeHint);\n         }\n     \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"integer\", true);\n+        }\n+        \n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectIntegerFormat(typeHint);\n         }\n     \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"integer\", true);\n+        }\n+        \n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectIntegerFormat(typeHint);\n             provider.defaultSerializeValue(value.get(), jgen);\n         }\n \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"any\", true);\n+        }\n+        \n         @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         }\n \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"string\", true);\n+        }\n+        \n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectStringFormat(typeHint);\n         }\n \n         @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"string\", true);\n+        }\n+        \n+        @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         {\n         \tvisitor.expectStringFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.util.Date;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n \n     }\n \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return createSchemaNode(\"string\");\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n     \tvisitor.expectStringFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n import java.util.Calendar;\n import java.util.Date;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.*;\n+\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdScalarSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n     }\n \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return createSchemaNode(\"string\", true);\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n         visitor.expectAnyFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n \n import java.io.IOException;\n import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorAware;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n \n /**\n  * Base class used by all standard serializers, and can also\n  */\n public abstract class StdSerializer<T>\n     extends JsonSerializer<T>\n-    implements JsonFormatVisitorAware\n+    implements JsonFormatVisitorAware, SchemaAware\n {\n     /**\n      * Nominal type supported, usually declared type of\n \n     /*\n     /**********************************************************\n-    /* Helper methods for JSON JsonSchema generation\n-    /**********************************************************\n-     */\n+    /* Helper methods for JSON Schema generation\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Default implementation simply claims type is \"string\"; usually\n+     * overriden by custom serializers.\n+     */\n+//  @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return createSchemaNode(\"string\");\n+    }\n+    \n+    /**\n+     * Default implementation simply claims type is \"string\"; usually\n+     * overriden by custom serializers.\n+     */\n+//    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional)\n+        throws JsonMappingException\n+    {\n+    \tObjectNode schema = (ObjectNode) getSchema(provider, typeHint);\n+    \tif (!isOptional) {\n+    \t\tschema.put(\"required\", !isOptional);\n+    \t}\n+        return schema;\n+    }\n+    \n+    protected ObjectNode createObjectNode() {\n+        return JsonNodeFactory.instance.objectNode();\n+    }\n+    \n+    protected ObjectNode createSchemaNode(String type)\n+    {\n+        ObjectNode schema = createObjectNode();\n+        schema.put(\"type\", type);\n+        return schema;\n+    }\n+    \n+    protected ObjectNode createSchemaNode(String type, boolean isOptional)\n+    {\n+        ObjectNode schema = createSchemaNode(type);\n+        // as per [JACKSON-563]. Note that 'required' defaults to false\n+        if (!isOptional) {\n+            schema.put(\"required\", !isOptional);\n+        }\n+        return schema;\n+    }\n     \n     /**\n      * Default implementation specifies no format. This behavior is usually\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n     }\n \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        return createSchemaNode(\"string\", true);\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n     \tvisitor.expectStringFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/TimeZoneSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/TimeZoneSerializer.java\n import java.io.IOException;\n import java.util.TimeZone;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n-import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.*;\n+\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n     }\n     \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return createSchemaNode(\"string\", true);\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n     \tvisitor.expectStringFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n     }\n     \n     @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        /* 01-Jan-2010, tatu: Not 100% sure what we should say here:\n+         *   type is basically not known. This seems closest\n+         *   approximation\n+         */\n+        return createSchemaNode(\"any\", true);\n+    }\n+    \n+    @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n     {\n         /* 01-Jan-2010, tatu: Not 100% sure what we should say here:\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n \n     /**\n      * Object codec to use for stream-based object\n-     *   conversion through parser/generator interfaces. If null,\n-     *   such methods can not be used.\n+     * conversion through parser/generator interfaces. If null,\n+     * such methods can not be used.\n      */\n     protected ObjectCodec _objectCodec;\n \n--- a/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n \n /**\n- * Unit tests to verify functioning of {@link PropertyNamingStrategy}.\n+ * Unit tests to verify functioning of {@link PropertyNamingStrategy} which\n+ * was added in Jackson 1.8, as per [JACKSON-178].\n  */\n public class TestNamingStrategy extends BaseMapTest\n {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n import java.net.URL;\n import java.net.URI;\n import java.util.*;\n+\n+import org.junit.Assert;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n         }\n     }\n \n+    // as per [Issue#42], allow Base64 variant use as well\n+    public void testBase64Variants() throws Exception\n+    {\n+        final byte[] INPUT = \"abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X\".getBytes(\"UTF-8\");\n+        \n+        // default encoding is \"MIME, no linefeeds\", so:\n+        Assert.assertArrayEquals(INPUT, MAPPER.readValue(\n+                quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA==\"),\n+                byte[].class));\n+        ObjectReader reader = MAPPER.reader(byte[].class);\n+        Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME_NO_LINEFEEDS).readValue(\n+                quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA==\"\n+        )));\n+\n+        // but others should be slightly different\n+        Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MIME).readValue(\n+                quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\\\ndnd4eXoxMjM0NTY3ODkwWA==\"\n+        )));\n+        Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.MODIFIED_FOR_URL).readValue(\n+                quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA\"\n+        )));\n+        // PEM mandates 64 char lines:\n+        Assert.assertArrayEquals(INPUT, (byte[]) reader.with(Base64Variants.PEM).readValue(\n+                quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA==\"\n+        )));\n+    }    \n     /*\n     /**********************************************************\n     /* Simple non-primitive types\n--- a/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n package com.fasterxml.jackson.databind.jsonschema;\n \n import java.util.Collection;\n-import java.util.HashMap;\n import java.util.Map;\n \n import com.fasterxml.jackson.annotation.JsonFilter;\n import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.jsonschema.factories.SchemaFactory;\n-import com.fasterxml.jackson.databind.jsonschema.factories.SchemaFactoryProvider;\n-import com.fasterxml.jackson.databind.jsonschema.types.ObjectSchema;\n-import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n-import com.fasterxml.jackson.databind.jsonschema.types.ArraySchema.Items;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\n import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;\n         private String property2;\n         private String[] property3;\n         private Collection<Float> property4;\n-        @JsonProperty(required = true)\n+        @JsonProperty(required=true)\n         private String property5;\n         \n         public int getProperty1()\n         public String name;\n     }\n \n-    //@JsonSerializableSchema(id=\"myType\")\n+    @JsonSerializableSchema(id=\"myType\")\n     public class BeanWithId {\n         public String value;\n     }\n     public void testGeneratingJsonSchema()\n         throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        SchemaFactoryProvider visitor = new SchemaFactoryProvider();\n-        m.acceptJsonFormatVisitor(SimpleBean.class, visitor);\n-        JsonSchema jsonSchema = visitor.finalSchema();\n+        JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class);\n         \n         assertNotNull(jsonSchema);\n \n         assertFalse(jsonSchema.equals(null));\n         assertFalse(jsonSchema.equals(\"foo\"));\n \n-        assertTrue(jsonSchema.isObjectSchema());\n-        ObjectSchema object = jsonSchema.asObjectSchema();\n-        assertNotNull(object);\n-        Map<String,JsonSchema> properties = object.getProperties();\n-        assertNotNull(properties);\n-        JsonSchema prop1 = properties.get(\"property1\");\n-        assertNotNull(prop1);\n-        assertTrue(prop1.isIntegerSchema());\n-        assertNull(prop1.getRequired());\n-        \n-        JsonSchema prop2 = properties.get(\"property2\");\n-        assertNotNull(prop2);\n-        assertTrue(prop2.isStringSchema());\n-        assertNull(prop2.getRequired());\n-        \n-        JsonSchema prop3 = properties.get(\"property3\");\n-        assertNotNull(prop3);\n-        assertTrue(prop3.isArraySchema());\n-        assertNull(prop3.getRequired());\n-        Items items = prop3.asArraySchema().getItems();\n-        assertTrue(items.isSingleItems());\n-        JsonSchema itemType = items.asSingleItems().getSchema();\n-        assertNotNull(itemType);\n-        assertTrue(itemType.isStringSchema());\n-        \n-        JsonSchema prop4 = properties.get(\"property4\");\n-        assertNotNull(prop4);\n-        assertTrue(prop4.isArraySchema());\n-        assertNull(prop4.getRequired());\n-        items = prop4.asArraySchema().getItems();\n-        assertTrue(items.isSingleItems());\n-        itemType = items.asSingleItems().getSchema();\n-        assertNotNull(itemType);\n-        assertTrue(itemType.isNumberSchema());\n-        \n-        JsonSchema prop5 = properties.get(\"property5\");\n-        assertNotNull(prop5);\n-        assertTrue(prop5.getRequired());\n-      \n+        // other basic things\n+        assertNotNull(jsonSchema.toString());\n+        assertNotNull(JsonSchema.getDefaultSchemaNode());\n+\n+\tObjectNode root = jsonSchema.getSchemaNode();\n+        assertEquals(\"object\", root.get(\"type\").asText());\n+        assertEquals(false, root.path(\"required\").booleanValue());\n+        JsonNode propertiesSchema = root.get(\"properties\");\n+        assertNotNull(propertiesSchema);\n+        JsonNode property1Schema = propertiesSchema.get(\"property1\");\n+        assertNotNull(property1Schema);\n+        assertEquals(\"integer\", property1Schema.get(\"type\").asText());\n+        assertEquals(false, property1Schema.path(\"required\").booleanValue());\n+        JsonNode property2Schema = propertiesSchema.get(\"property2\");\n+        assertNotNull(property2Schema);\n+        assertEquals(\"string\", property2Schema.get(\"type\").asText());\n+        assertEquals(false, property2Schema.path(\"required\").booleanValue());\n+        JsonNode property3Schema = propertiesSchema.get(\"property3\");\n+        assertNotNull(property3Schema);\n+        assertEquals(\"array\", property3Schema.get(\"type\").asText());\n+        assertEquals(false, property3Schema.path(\"required\").booleanValue());\n+        assertEquals(\"string\", property3Schema.get(\"items\").get(\"type\").asText());\n+        JsonNode property4Schema = propertiesSchema.get(\"property4\");\n+        assertNotNull(property4Schema);\n+        assertEquals(\"array\", property4Schema.get(\"type\").asText());\n+        assertEquals(false, property4Schema.path(\"required\").booleanValue());\n+        assertEquals(\"number\", property4Schema.get(\"items\").get(\"type\").asText());\n     }\n     \n     @JsonFilter(\"filteredBean\")\n     public void testGeneratingJsonSchemaWithFilters() throws Exception {\n     \tObjectMapper mapper = new ObjectMapper();\n     \tmapper.setFilters(secretFilterProvider);\n-    \tSchemaFactoryProvider visitor = new SchemaFactoryProvider();\n-        mapper.acceptJsonFormatVisitor(FilteredBean.class, visitor);\n-        JsonSchema jsonSchema = visitor.finalSchema();\n-    \tassertNotNull(jsonSchema);\n-    \tassertTrue(jsonSchema.isObjectSchema());\n-    \tObjectSchema object = jsonSchema.asObjectSchema();\n-    \tassertNotNull(object);\n-    \tMap<String, JsonSchema> properties = object.getProperties();\n-    \tassertNotNull(properties);\n-    \tJsonSchema obvious = properties.get(\"obvious\");\n-    \tassertNotNull(obvious);\n-    \tassertTrue(obvious.isStringSchema());\n-    \tassertNull(properties.get(\"secret\"));\n+    \tJsonSchema schema = mapper.generateJsonSchema(FilteredBean.class);\n+    \tJsonNode node = schema.getSchemaNode().get(\"properties\");\n+    \tassertTrue(node.has(\"obvious\"));\n+    \tassertFalse(node.has(\"secret\"));\n     }\n \n     /**\n     public void testSchemaSerialization()\n             throws Exception\n     {\n-    \tSchemaFactoryProvider visitor = new SchemaFactoryProvider();\n-        MAPPER.acceptJsonFormatVisitor(SimpleBean.class, visitor);\n-        JsonSchema jsonSchema = visitor.finalSchema();\n-        Map<String,Object> result = writeAndMap(MAPPER, jsonSchema);\n-        assertNotNull(result);\n-        // no need to check out full structure, just basics...\n-        assertEquals(\"object\", result.get(\"type\"));\n-        // only add 'required' if it is true...\n-        assertNull(result.get(\"required\"));\n-        assertNotNull(result.get(\"properties\"));\n+        JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class);\n+\tMap<String,Object> result = writeAndMap(MAPPER, jsonSchema);\n+\tassertNotNull(result);\n+\t// no need to check out full structure, just basics...\n+\tassertEquals(\"object\", result.get(\"type\"));\n+\t// only add 'required' if it is true...\n+\tassertNull(result.get(\"required\"));\n+\tassertNotNull(result.get(\"properties\"));\n     }\n \n     public void testInvalidCall()\n     {\n         // not ok to pass null\n         try {\n-        \tSchemaFactoryProvider visitor = new SchemaFactoryProvider();\n-            MAPPER.acceptJsonFormatVisitor(null, visitor);\n-            JsonSchema jsonSchema = visitor.finalSchema();\n+            MAPPER.generateJsonSchema(null);\n             fail(\"Should have failed\");\n         } catch (IllegalArgumentException iae) {\n             verifyException(iae, \"class must be provided\");\n      */\n     public void testThatObjectsHaveNoItems() throws Exception\n     {\n-    \tSchemaFactoryProvider visitor = new SchemaFactoryProvider();\n-        MAPPER.acceptJsonFormatVisitor(TrivialBean.class, visitor);\n-        JsonSchema jsonSchema = visitor.finalSchema();\n-        Map<String,Object> result = writeAndMap(MAPPER, jsonSchema);\n+        JsonSchema jsonSchema = MAPPER.generateJsonSchema(TrivialBean.class);\n+        String json = jsonSchema.toString().replaceAll(\"\\\"\", \"'\");\n         // can we count on ordering being stable? I think this is true with current ObjectNode impl\n         // as perh [JACKSON-563]; 'required' is only included if true\n-        assertFalse(result.containsKey(\"items\"));\n-\n-    }\n-\n-    @SuppressWarnings({ \"unchecked\", \"rawtypes\", \"serial\" })\n-\tpublic void testSchemaId() throws Exception\n-    {\n-    \tSchemaFactoryProvider visitor = new SchemaFactoryProvider();\n-        MAPPER.acceptJsonFormatVisitor(BeanWithId.class, visitor);\n-        JsonSchema jsonSchema = visitor.finalSchema();\n-        Map<String,Object> result = writeAndMap(MAPPER, jsonSchema);\n-        \n-        assertEquals(new HashMap() {{ \n-        \tput(\"type\", \"object\");\n-        \tput(\"properties\", \n-        \t\t\tnew HashMap(){{ put(\"value\", \n-        \t\t\t\t\tnew HashMap() {{ put(\"type\", \"string\");}}\n-        \t\t\t);}}\n-        \t);}}, result);\n+        assertEquals(\"{'type':'object','properties':{'name':{'type':'string'}}}\",\n+                json);\n+    }\n+\n+    public void testSchemaId() throws Exception\n+    {\n+        JsonSchema jsonSchema = MAPPER.generateJsonSchema(BeanWithId.class);\n+        String json = jsonSchema.toString().replaceAll(\"\\\"\", \"'\");\n+        assertEquals(\"{'type':'object','id':'myType','properties':{'value':{'type':'string'}}}\",\n+                json);\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestReadJsonSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestReadJsonSchema.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.jsonschema.factories.SchemaFactory;\n-import com.fasterxml.jackson.databind.jsonschema.factories.SchemaFactoryProvider;\n-import com.fasterxml.jackson.databind.jsonschema.types.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n \n /**\n  * Trivial test to ensure {@link JsonSchema} can be also deserialized\n     public void testDeserializeSimple() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        SchemaFactoryProvider visitor = new SchemaFactoryProvider();\n-        mapper.acceptJsonFormatVisitor(Schemable.class, visitor);\n-        JsonSchema jsonSchema = visitor.finalSchema();\n-        assertNotNull(jsonSchema);\n+        JsonSchema schema = mapper.generateJsonSchema(Schemable.class);\n+        assertNotNull(schema);\n \n-        String schemaStr = mapper.writeValueAsString(jsonSchema);\n+        String schemaStr = mapper.writeValueAsString(schema);\n         assertNotNull(schemaStr);\n         JsonSchema result = mapper.readValue(schemaStr, JsonSchema.class);\n-        assertEquals(\"Trying to read from '\"+schemaStr+\"'\", jsonSchema, result);\n+        assertEquals(\"Trying to read from '\"+schemaStr+\"'\", schema, result);\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n package com.fasterxml.jackson.databind.module;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.util.*;\n \n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.module.SimpleDeserializers;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.module.SimpleSerializers;\n         }\n \n         @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) {\n-            visitor.expectAnyFormat(typeHint);\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n+            return null;\n         }\n     }\n     \n         }\n \n         @Override\n-        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) {\n-            visitor.expectAnyFormat(typeHint);\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n+            return null;\n         }\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java\n         assertTrue(n.path(\"a\").isMissingNode());\n \n         TextNode text = TextNode.valueOf(\"x\");\n-        n.put(\"a\", text);\n+        n.set(\"a\", text);\n         assertEquals(1, n.size());\n         assertTrue(n.elements().hasNext());\n         assertTrue(n.fields().hasNext());\n         ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance);\n         n2.put(\"b\", 13);\n         assertFalse(n.equals(n2));\n-        n.putAll(n2);\n+        n.setAll(n2);\n         assertEquals(2, n.size());\n-        n.put(\"null\", (JsonNode)null);\n+        n.set(\"null\", (JsonNode)null);\n         assertEquals(3, n.size());\n         // should replace, not add\n         n.put(\"null\", \"notReallNull\");\n \n         Map<String,JsonNode> nodes = new HashMap<String,JsonNode>();\n         nodes.put(\"d\", text);\n-        n.putAll(nodes);\n+        n.setAll(nodes);\n         assertEquals(3, n.size());\n \n         n.removeAll();\n         ObjectNode o1 = JsonNodeFactory.instance.objectNode();\n         ObjectNode o2 = JsonNodeFactory.instance.objectNode();\n         // used to throw NPE before fix:\n-        o1.putAll(o2);\n+        o1.setAll(o2);\n         assertEquals(0, o1.size());\n         assertEquals(0, o2.size());\n \n         // also: nulls should be converted to NullNodes...\n-        o1.put(\"x\", (ObjectNode) null);\n+        o1.set(\"x\", null);\n         JsonNode n = o1.get(\"x\");\n         assertNotNull(n);\n         assertSame(n, NullNode.instance);\n         ObjectNode src = mapper.createObjectNode();\n         ObjectNode dest = mapper.createObjectNode();\n         src.put(\"a\", \"b\");\n-        dest.putAll(src);\n+        dest.setAll(src);\n     }\n \n     public void testRemove()\n         ob.put(\"b\", \"b\");\n         ob.put(\"c\", \"c\");\n         assertEquals(3, ob.size());\n-        assertSame(ob, ob.remove(Arrays.asList(\"a\", \"c\")));\n+        assertSame(ob, ob.without(Arrays.asList(\"a\", \"c\")));\n         assertEquals(1, ob.size());\n         assertEquals(\"b\", ob.get(\"b\").textValue());\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java\n         assertTrue(n1.equals(n2));\n         assertTrue(n2.equals(n1));\n \n-        n1.put(\"x\", TextNode.valueOf(\"Test\"));\n+        n1.set(\"x\", TextNode.valueOf(\"Test\"));\n \n         assertFalse(n1.equals(n2));\n         assertFalse(n2.equals(n1));\n \n-        n2.put(\"x\", TextNode.valueOf(\"Test\"));\n+        n2.set(\"x\", TextNode.valueOf(\"Test\"));\n \n         assertTrue(n1.equals(n2));\n         assertTrue(n2.equals(n1));\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java\n import java.math.BigInteger;\n \n \n+import com.fasterxml.jackson.core.Base64Variants;\n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n public class TestSimpleTypes\n     extends BaseMapTest\n {\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testBoolean() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(\"true\", serializeAsString(mapper, Boolean.TRUE));\n-        assertEquals(\"false\", serializeAsString(mapper, Boolean.FALSE));\n+        assertEquals(\"true\", serializeAsString(MAPPER, Boolean.TRUE));\n+        assertEquals(\"false\", serializeAsString(MAPPER, Boolean.FALSE));\n     }\n \n     public void testBooleanArray() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(\"[true,false]\", serializeAsString(mapper, new boolean[] { true, false} ));\n-        assertEquals(\"[true,false]\", serializeAsString(mapper, new Boolean[] { Boolean.TRUE, Boolean.FALSE} ));\n+        assertEquals(\"[true,false]\", serializeAsString(MAPPER, new boolean[] { true, false} ));\n+        assertEquals(\"[true,false]\", serializeAsString(MAPPER, new Boolean[] { Boolean.TRUE, Boolean.FALSE} ));\n     }\n \n     public void testByteArray() throws Exception\n         for (int i = 0; i < data.length; ++i) {\n             data2[i] = data[i]; // auto-boxing\n         }\n-        ObjectMapper mapper = new ObjectMapper();\n         // For this we need to deserialize, to get base64 codec\n-        String str1 = serializeAsString(mapper, data);\n-        String str2 = serializeAsString(mapper, data2);\n-        assertArrayEquals(data, mapper.readValue(str1, byte[].class));\n-        assertArrayEquals(data2, mapper.readValue(str2, Byte[].class));\n+        String str1 = serializeAsString(MAPPER, data);\n+        String str2 = serializeAsString(MAPPER, data2);\n+        assertArrayEquals(data, MAPPER.readValue(str1, byte[].class));\n+        assertArrayEquals(data2, MAPPER.readValue(str2, Byte[].class));\n     }\n \n+    // as per [Issue#42], allow Base64 variant use as well\n+    public void testBase64Variants() throws Exception\n+    {\n+        final byte[] INPUT = \"abcdefghijklmnopqrstuvwxyz1234567890abcdefghijklmnopqrstuvwxyz1234567890X\".getBytes(\"UTF-8\");\n+        \n+        // default encoding is \"MIME, no linefeeds\", so:\n+        assertEquals(quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA==\"), MAPPER.writeValueAsString(INPUT));\n+        assertEquals(quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA==\"),\n+                MAPPER.writer(Base64Variants.MIME_NO_LINEFEEDS).writeValueAsString(INPUT));\n+\n+        // but others should be slightly different\n+        assertEquals(quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1\\\\ndnd4eXoxMjM0NTY3ODkwWA==\"),\n+                MAPPER.writer(Base64Variants.MIME).writeValueAsString(INPUT));\n+        assertEquals(quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA\"), // no padding or LF\n+                MAPPER.writer(Base64Variants.MODIFIED_FOR_URL).writeValueAsString(INPUT));\n+        // PEM mandates 64 char lines:\n+        assertEquals(quote(\"YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwYWJjZGVmZ2hpamts\\\\nbW5vcHFyc3R1dnd4eXoxMjM0NTY3ODkwWA==\"),\n+                MAPPER.writer(Base64Variants.PEM).writeValueAsString(INPUT));\n+    }\n+    \n     public void testShortArray() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(\"[0,1]\", serializeAsString(mapper, new short[] { 0, 1 }));\n-        assertEquals(\"[2,3]\", serializeAsString(mapper, new Short[] { 2, 3 }));\n+        assertEquals(\"[0,1]\", serializeAsString(MAPPER, new short[] { 0, 1 }));\n+        assertEquals(\"[2,3]\", serializeAsString(MAPPER, new Short[] { 2, 3 }));\n     }\n \n     public void testIntArray() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(\"[0,-3]\", serializeAsString(mapper, new int[] { 0, -3 }));\n-        assertEquals(\"[13,9]\", serializeAsString(mapper, new Integer[] { 13, 9 }));\n+        assertEquals(\"[0,-3]\", serializeAsString(MAPPER, new int[] { 0, -3 }));\n+        assertEquals(\"[13,9]\", serializeAsString(MAPPER, new Integer[] { 13, 9 }));\n     }\n \n     /* Note: dealing with floating-point values is tricky; not sure if\n         double[] values = new double[] {\n             0.0, 1.0, 0.1, -37.01, 999.99, 0.3, 33.3, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY\n         };\n-        ObjectMapper mapper = new ObjectMapper();\n-\n         for (double d : values) {\n            float f = (float) d;\n     \t   String expected = String.valueOf(f);\n            if (Float.isNaN(f) || Float.isInfinite(f)) {\n                expected = \"\\\"\"+expected+\"\\\"\";\n        \t   }\n-           assertEquals(expected,serializeAsString(mapper, Float.valueOf(f)));\n+           assertEquals(expected,serializeAsString(MAPPER, Float.valueOf(f)));\n         }\n     }\n \n         double[] values = new double[] {\n             0.0, 1.0, 0.1, -37.01, 999.99, 0.3, 33.3, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY\n         };\n-        ObjectMapper mapper = new ObjectMapper();\n-\n         for (double d : values) {\n             String expected = String.valueOf(d);\n             if (Double.isNaN(d) || Double.isInfinite(d)) {\n                 expected = \"\\\"\"+d+\"\\\"\";\n             }\n-            assertEquals(expected,serializeAsString(mapper, Double.valueOf(d)));\n+            assertEquals(expected, MAPPER.writeValueAsString(Double.valueOf(d)));\n         }\n     }\n \n                 new BigInteger(\"123456789012345678901234568\"),\n                 new BigInteger(\"-1250000124326904597090347547457\")\n                 };\n-        ObjectMapper mapper = new ObjectMapper();\n \n         for (BigInteger value : values) {\n             String expected = value.toString();\n-            assertEquals(expected,serializeAsString(mapper, value));\n+            assertEquals(expected, MAPPER.writeValueAsString(value));\n         }\n     }\n     \n     public void testClass() throws Exception\n     {\n-        String result = serializeAsString(java.util.List.class);\n+        String result = MAPPER.writeValueAsString(java.util.List.class);\n         assertEquals(\"\\\"java.util.List\\\"\", result);\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestTreeSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestTreeSerialization.java\n         ObjectMapper mapper = new ObjectMapper();\n         // also need tree mapper to construct tree to serialize\n         ObjectNode n = mapper.getNodeFactory().objectNode();\n-        n.put(\"pojo\", mapper.getNodeFactory().POJONode(\"abc\"));\n+        n.set(\"pojo\", mapper.getNodeFactory().POJONode(\"abc\"));\n         StringWriter sw = new StringWriter();\n         JsonGenerator jg = mapper.getJsonFactory().createJsonGenerator(sw);\n         mapper.writeTree(jg, n);\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         ObjectNode n = mapper.getNodeFactory().objectNode();\n-        n.put(\"pojo\", mapper.getNodeFactory().POJONode(new int[] { 1, 2, 3 }));\n+        n.set(\"pojo\", mapper.getNodeFactory().POJONode(new int[] { 1, 2, 3 }));\n         StringWriter sw = new StringWriter();\n         JsonGenerator jg = mapper.getJsonFactory().createJsonGenerator(sw);\n         mapper.writeTree(jg, n);\n         ObjectMapper mapper = new ObjectMapper();\n         // also need tree mapper to construct tree to serialize\n         ObjectNode n = mapper.getNodeFactory().objectNode();\n-        n.put(\"pojo\", mapper.getNodeFactory().POJONode(new Bean()));\n+        n.set(\"pojo\", mapper.getNodeFactory().POJONode(new Bean()));\n         StringWriter sw = new StringWriter();\n         JsonGenerator jg = mapper.getJsonFactory().createJsonGenerator(sw);\n         mapper.writeTree(jg, n);", "timestamp": 1345073206, "metainfo": ""}