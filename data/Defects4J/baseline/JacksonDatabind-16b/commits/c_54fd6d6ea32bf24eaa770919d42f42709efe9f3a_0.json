{"sha": "54fd6d6ea32bf24eaa770919d42f42709efe9f3a", "log": "Partial fix/workaround for #489: add `TypeFactory.clearCache()`", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n \n     public TypeFactory withModifier(TypeModifier mod) \n     {\n+        if (mod == null) { // mostly for unit tests\n+            return new TypeFactory(_parser, _modifiers);\n+        }\n         if (_modifiers == null) {\n             return new TypeFactory(_parser, new TypeModifier[] { mod });\n         }\n      */\n     public static TypeFactory defaultInstance() { return instance; }\n \n+    /**\n+     * Method that will clear up any cached type definitions that may\n+     * be cached by this {@link TypeFactory} instance.\n+     * This method should not be commonly used, that is, only use it\n+     * if you know there is a problem with retention of type definitions;\n+     * the most likely (and currently only known) problem is retention\n+     * of {@link Class} instances via {@link JavaType} reference.\n+     * \n+     * @since 2.4.1\n+     */\n+    public void clearCache() {\n+        _typeCache.clear();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Static methods for non-instance-specific functionality\n--- a/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n             _writeLock.unlock();\n         }\n     }\n+\n+    /**\n+     * Overridden to allow concurrent way of removing all cached entries.\n+     * \n+     * @since 2.4.1\n+     */\n+    @Override\n+    public void clear() {\n+        _writeLock.lock();\n+        try {\n+            super.clear();\n+        } finally {\n+            _writeLock.unlock();\n+        }\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java\n     /**\n      * Test for verifying that parametric types can be constructed\n      * programmatically\n-     * \n-     * @since 1.5\n      */\n     public void testParametricTypes()\n     {\n     /* Unit tests: low-level inheritance resolution\n     /**********************************************************\n      */\n-    \n-    /**\n-     * @since 1.6\n-     */\n+\n     public void testSuperTypeDetectionClass()\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n         assertSame(HashMap.class, sup2.getRawClass());\n         assertNull(sup2.getSuperType());\n     }\n-    \n-    /**\n-     * @since 1.6\n-     */\n+\n     public void testSuperTypeDetectionInterface()\n     {\n         // List first\n         assertNull(sup2.getSuperType());\n     }\n \n-    /**\n-     * @since 1.6\n-     */\n     public void testAtomicArrayRefParameterDetection()\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n     /* Unit tests: map/collection type parameter resolution\n     /**********************************************************\n      */\n-    \n-    /**\n-     * @since 1.6\n-     */\n+\n     public void testMapTypesSimple()\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n         assertEquals(tf.constructType(Boolean.class), mapType.getContentType());\n     }\n \n-    /**\n-     * @since 1.6\n-     */\n     public void testMapTypesRaw()\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n         assertEquals(tf.constructType(Object.class), mapType.getContentType());        \n     }\n \n-    /**\n-     * @since 1.6\n-     */\n     public void testMapTypesAdvanced()\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n     /**\n      * Specific test to verify that complicate name mangling schemes\n      * do not fool type resolver\n-     * \n-     * @since 1.6\n      */\n     public void testMapTypesSneaky()\n     {\n     \n     /**\n      * Plus sneaky types may be found via introspection as well.\n-     * \n-     * @since 1.7\n      */\n     public void testSneakyFieldTypes() throws Exception\n     {\n     \n     /**\n      * Looks like type handling actually differs for properties, too.\n-     * \n-     * @since 1.7\n      */\n     public void testSneakyBeanProperties() throws Exception\n     {\n         assertSame(t1, tf.moreSpecificType(t1, t2));\n         assertSame(t2, tf.moreSpecificType(t2, t1));\n     }\n+\n+    // [Issue#489]\n+    public void testCacheClearing()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance().withModifier(null);\n+        assertEquals(0, tf._typeCache.size());\n+        tf.constructType(getClass());\n+        assertEquals(1, tf._typeCache.size());\n+        tf.clearCache();\n+        assertEquals(0, tf._typeCache.size());\n+    }\n }\n         ", "timestamp": 1402872187, "metainfo": ""}