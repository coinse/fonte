{"sha": "add3cc35d6b5223be8198fd591dc4a26640fbf31", "log": "Fix #408", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n      */\n     public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt,\n             String propName, Object bean)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         Integer I = _nameToPropertyIndex.get(propName);\n         if (I == null) {\n      * @return True, if the given property was properly handled\n      */\n     public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt,\n-            String propName, Object bean)\n-        throws IOException, JsonProcessingException\n+            String propName, Object bean) throws IOException\n     {\n         Integer I = _nameToPropertyIndex.get(propName);\n         if (I == null) {\n     \n     @SuppressWarnings(\"resource\")\n     public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         for (int i = 0, len = _properties.length; i < len; ++i) {\n             String typeId = _typeIds[i];\n      */\n     public Object complete(JsonParser jp, DeserializationContext ctxt,\n             PropertyValueBuffer buffer, PropertyBasedCreator creator)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // first things first: deserialize all data buffered:\n         final int len = _properties.length;\n \n     @SuppressWarnings(\"resource\")\n     protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt,\n-            int index, String typeId)\n-        throws IOException, JsonProcessingException\n+            int index, String typeId) throws IOException\n     {\n         TokenBuffer merged = new TokenBuffer(jp);\n         merged.writeStartArray();\n \n     @SuppressWarnings(\"resource\")\n     protected final void _deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-            Object bean, int index, String typeId)\n-        throws IOException, JsonProcessingException\n+            Object bean, int index, String typeId) throws IOException\n     {\n         /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n          * style to ensure we can handle all kinds of JSON constructs.\n         p2.nextToken();\n         merged.copyCurrentStructure(p2);\n         merged.writeEndArray();\n-        \n         // needs to point to START_OBJECT (or whatever first token is)\n         p2 = merged.asParser(jp);\n         p2.nextToken();\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n     extends TypeDeserializerBase\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 5345570420394408290L;\n+    private static final long serialVersionUID = 1L;\n \n     public AsArrayTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n             String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n         String typeId = _locateTypeId(jp, ctxt);\n         JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n         // Minor complication: we may need to merge type id in?\n-        if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) {\n+        if (_typeIdVisible\n+                // 06-Oct-2014, tatu: To fix [databind#408], must distinguish between\n+                //   internal and external properties\n+                //  TODO: but does it need to be injected in external case? Why not?\n+                && !_usesExternalId()\n+                && jp.getCurrentToken() == JsonToken.START_OBJECT) {\n             // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n             TokenBuffer tb = new TokenBuffer(null, false);\n             tb.writeStartObject(); // recreate START_OBJECT\n     protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         if (!jp.isExpectedStartArrayToken()) {\n-            // [JACKSON-712] Need to allow even more customized handling, if something unexpected seen...\n+            // Need to allow even more customized handling, if something unexpected seen...\n             // but should there be a way to limit this to likely success cases?\n             if (_defaultImpl != null) {\n                 return _idResolver.idFromBaseType();\n         }\n         throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n     }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected boolean _usesExternalId() {\n+        return false;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n     \n     @Override\n     public As getTypeInclusion() { return As.EXTERNAL_PROPERTY; }\n+\n+    // yes, very important distinction...\n+    @Override\n+    protected boolean _usesExternalId() {\n+        return true;\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestVisibleTypeId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestVisibleTypeId.java\n package com.fasterxml.jackson.databind.jsontype;\n \n-import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n-import com.fasterxml.jackson.annotation.JsonSubTypes;\n-import com.fasterxml.jackson.annotation.JsonTypeId;\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n-import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n import com.fasterxml.jackson.databind.*;\n \n /**\n         public void setType(String t) { type = t; }\n     }\n \n-    // as external id, bit trickier\n-    static class ExternalIdWrapper {\n-        @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.EXTERNAL_PROPERTY,\n-                property=\"type\", visible=true)\n-        public ExternalIdBean bean = new ExternalIdBean();\n-    }\n-    \n     @JsonTypeName(\"ExternalType\")\n     static class ExternalIdBean {\n         public int a = 2;\n         public String getName() { return \"bob\"; }\n         \n         public int age = 41;\n+    }\n+\n+    // [databind#408]\n+    static class ExternalBeanWithId\n+    {\n+        protected String _type;\n+        \n+        @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property=\"type\", visible=true)\n+        public ValueBean bean;\n+\n+        public ExternalBeanWithId() { }\n+        public ExternalBeanWithId(int v) {\n+            bean = new ValueBean(v);\n+        }\n+\n+        public void setType(String t) {\n+            _type = t;\n+        }\n+    }\n+\n+    @JsonTypeName(\"vbean\")\n+    static class ValueBean {\n+        public int value;\n+        \n+        public ValueBean() { }\n+        public ValueBean(int v) { value = v; }\n     }\n     \n     /*\n         assertEquals(\"ObjectType\", result.type);\n     }\n \n-    public void testVisibleWithExternalId() throws Exception\n-    {\n-        String json = MAPPER.writeValueAsString(new ExternalIdWrapper());\n-        // but then expect to read it back\n-        ExternalIdWrapper result = MAPPER.readValue(json, ExternalIdWrapper.class);\n-        assertEquals(\"ExternalType\", result.bean.type);\n-        assertEquals(2, result.bean.a);\n-    }\n-\n-    // [JACKSON-762]\n-\n     public void testTypeIdFromProperty() throws Exception\n     {\n         assertEquals(\"{\\\"type\\\":\\\"SomeType\\\",\\\"a\\\":3}\",\n         I263Base result = MAPPER.readValue(\"{\\\"age\\\":19,\\\"name\\\":\\\"bob\\\"}\", I263Base.class);\n         assertTrue(result instanceof I263Impl);\n         assertEquals(19, ((I263Impl) result).age);\n+    }\n+\n+    // [databind#408]\n+    /* NOTE: Handling changed between 2.4 and 2.5; earlier, type id was 'injected'\n+     *  inside POJO; but with 2.5 this was fixed so it would remain outside, similar\n+     *  to how JSON structure is.\n+     */\n+    public void testVisibleTypeId408() throws Exception\n+    {\n+        String json = MAPPER.writeValueAsString(new ExternalBeanWithId(3));\n+        ExternalBeanWithId result = MAPPER.readValue(json, ExternalBeanWithId.class);\n+        assertNotNull(result);\n+        assertNotNull(result.bean);\n+        assertEquals(3, result.bean.value);\n+        assertEquals(\"vbean\", result._type);\n     }\n     \n     /*", "timestamp": 1412659544, "metainfo": ""}