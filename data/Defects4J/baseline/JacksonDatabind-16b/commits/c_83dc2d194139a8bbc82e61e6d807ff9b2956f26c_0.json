{"sha": "83dc2d194139a8bbc82e61e6d807ff9b2956f26c", "log": "Make ObjectNode final  This also means a test had to be removed, which tested whether JsonNodeFactory's .objectNode() could be overriden.  However, other methods of JsonNodeFactory, overridable, also return final classes (.binaryNode(), .textNode() etc).", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n package com.fasterxml.jackson.databind.node;\n \n-import java.io.IOException;\n-import java.math.BigDecimal;\n-import java.util.*;\n-\n-import com.fasterxml.jackson.core.*;\n-\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.util.EmptyIterator;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Node that maps to JSON Object structures in JSON content.\n  */\n-public class ObjectNode\n+public final class ObjectNode\n     extends ContainerNode<ObjectNode>\n {\n     // Note: LinkedHashMap for backwards compatibility\n-    protected final Map<String, JsonNode> _children\n+    private final Map<String, JsonNode> _children\n         = new LinkedHashMap<String, JsonNode>();\n \n     public ObjectNode(JsonNodeFactory nc) { super(nc); }\n     @Override\n     public ObjectNode deepCopy()\n     {\n-        /* 28-Sep-2012, tatu: Sub-classes really should override this method to\n-         *   produce compliant copies.\n-         */\n-        if (getClass() != ObjectNode.class) {\n-            throw new IllegalStateException(\"ObjectNode subtype (\"+getClass().getName()+\" does not override deepCopy(), needs to\");\n-        }\n-        return _defaultDeepCopy();\n-    }\n- \n-    /**\n-     * Default implementation for 'deepCopy()': can be delegated to by sub-classes\n-     * if necessary; but usually isn't.\n-     */\n-    protected ObjectNode _defaultDeepCopy()\n-    {\n-        final int len = _children.size();\n-        final ObjectNode ret = new ObjectNode(_nodeFactory);\n-\n-        for (Map.Entry<String, JsonNode> entry : _children.entrySet())\n+        ObjectNode ret = new ObjectNode(_nodeFactory);\n+\n+        for (Map.Entry<String, JsonNode> entry: _children.entrySet())\n             ret._children.put(entry.getKey(), entry.getValue().deepCopy());\n \n         return ret;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Implementation of core JsonNode API\n      */\n \n     @Override\n-    public final JsonNodeType getNodeType()\n+    public JsonNodeType getNodeType()\n     {\n         return JsonNodeType.OBJECT;\n     }\n      * all of its descendants using specified JSON generator.\n      */\n     @Override\n-    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+    public void serialize(JsonGenerator jg, SerializerProvider provider)\n         throws IOException, JsonProcessingException\n     {\n         jg.writeStartObject();\n      */\n     public JsonNode setAll(ObjectNode other)\n     {\n-        int len = other.size();\n-        if (len > 0) {\n-            other.putContentsTo(_children);\n-        }\n+        other._children.putAll(_children);\n         return this;\n     }\n     \n \n     /*\n     /**********************************************************\n-    /* Overridable methods\n-    /**********************************************************\n-     */\n-\n-    /*\n-    /**********************************************************\n-    /* Package methods (for other node classes to use)\n-    /**********************************************************\n-     */\n-\n-    protected void putContentsTo(Map<String,JsonNode> dst)\n-    {\n-        if (_children != null) {\n-            for (Map.Entry<String,JsonNode> en : _children.entrySet()) {\n-                dst.put(en.getKey(), en.getValue());\n-            }\n-        }\n-    }\n-\n-    /*\n-    /**********************************************************\n     /* Standard methods\n     /**********************************************************\n      */\n \n     @Override\n-    public final boolean equals(Object o)\n+    public boolean equals(Object o)\n     {\n         if (o == this) return true;\n         if (o == null) return false;\n         \n         // minor improvement, wrt [Issue#70]\n-        if (o.getClass() != getClass() && !(o instanceof ObjectNode)) {\n+        if (getClass() != o.getClass()) {\n             return false;\n         }\n-        /* This is bit convoluted, but the goal is to make it possible to\n-         * fully override equality comparison, even though it is\n-         * asymmetric (i.e. can be called on either side, but we\n-         * want behavior to match).\n-         */\n-        return _equals((ObjectNode) o);\n-    }\n-    \n-    /**\n-     * Method that sub-classes should override, if equality comparison\n-     * needs additional verification beyond defaults.\n-     * \n-     * @since 2.1\n-     */\n-    protected boolean _equals(ObjectNode other)\n-    {\n-        return _children.equals(other._children);\n+        return _children.equals(((ObjectNode) o)._children);\n     }\n     \n     @Override", "timestamp": 1359407186, "metainfo": ""}