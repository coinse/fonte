{"sha": "0b3cf995914506207682414c6c91bc23b4d7e537", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeSerializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type serializer used with {@link As#EXISTING_PROPERTY} inclusion mechanism.\n+ * Expects type information to be a well-defined property on all sub-classes.\n+ * \n+ * @author fleeman (modeled after code by tatus)\n+ */\n+public class AsExistingPropertyTypeSerializer\n+    extends AsPropertyTypeSerializer\n+{\n+\n+    public AsExistingPropertyTypeSerializer(TypeIdResolver idRes, BeanProperty property, String propName)\n+    {\n+        super(idRes, property, propName);\n+    }\n+\n+    @Override\n+    public AsExistingPropertyTypeSerializer forProperty(BeanProperty prop) {\n+        return (_property == prop) ? this : new AsExistingPropertyTypeSerializer(this._idResolver, prop, this._typePropertyName);\n+    }\n+    \n+    @Override\n+    public As getTypeInclusion() { return As.EXISTING_PROPERTY; }\n+    \n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException\n+    {\n+        final String typeId = idFromValue(value);\n+        if (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException\n+    {\n+        final String typeId = idFromValueAndType(value, type);\n+        if (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+    \n+    @Override\n+    public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException\n+    {\n+    \tif (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n             return new AsExternalTypeSerializer(idRes, null,\n                     _typeProperty);\n         case EXISTING_PROPERTY:\n-            throw _noExisting();\n+        \t// as per [#528]\n+        \treturn new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n \n     // as per [#368]\n-    private IllegalArgumentException _noExisting() {\n-        return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n-    }\n+    // removed when fix [#528]\n+    //private IllegalArgumentException _noExisting() {\n+    //    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n+    //}\n \n     @Override\n     public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n             return new AsExternalTypeDeserializer(baseType, idRes,\n                     _typeProperty, _typeIdVisible, _defaultImpl);\n         case EXISTING_PROPERTY:\n-            throw _noExisting();\n+        \t// as per [#528]\n+        \treturn new AsPropertyTypeDeserializer(baseType, idRes,\n+                    _typeProperty, _typeIdVisible, _defaultImpl);\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypesExistingProperty.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestSubtypesExistingProperty extends BaseMapTest {\n+\n+    /**\n+     * Polymorphic base class - existing property as simple property on subclasses\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Apple.class, name = \"apple\") ,\n+\t\t@Type(value = Orange.class, name = \"orange\") \n+\t\t})\n+\tstatic abstract class Fruit {\n+        public String name;\n+        protected Fruit(String n)  { name = n; }\n+    }\n+\n+    @JsonTypeName(\"apple\")\n+    static class Apple extends Fruit\n+    {\n+    \tpublic int seedCount;\n+    \tpublic String type;\n+        \n+        private Apple() { super(null); type = \"apple\"; }\n+        public Apple(String name, int b) {\n+            super(name);\n+            seedCount = b;\n+            type = \"apple\";\n+        }\n+    }\n+    \n+    @JsonTypeName(\"orange\")\n+    static class Orange extends Fruit\n+    {\n+        public String color;\n+        public String type;\n+        \n+        private Orange() { super(null); type = \"orange\"; }\n+        public Orange(String name, String c) {\n+            super(name);\n+            color = c;\n+            type = \"orange\";\n+        }\n+    }\n+\n+    static class FruitWrapper {\n+        public Fruit fruit;\n+        public FruitWrapper() {}\n+        public FruitWrapper(Fruit f) { fruit = f; }\n+    }\n+    \n+    /**\n+     * Polymorphic base class - existing property forced by abstract method\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Dog.class, name = \"doggie\") ,\n+\t\t@Type(value = Cat.class, name = \"kitty\") \n+\t\t})\n+\tstatic abstract class Animal {\n+        public String name;\n+        \n+        protected Animal(String n)  { name = n; }\n+        \n+        public abstract String getType();\n+    }\n+\n+    @JsonTypeName(\"doggie\")\n+    static class Dog extends Animal\n+    {\n+        public int boneCount;\n+        \n+        private Dog() { super(null); }\n+        public Dog(String name, int b) {\n+            super(name);\n+            boneCount = b;\n+        }\n+        \n+ \t\t@Override\n+\t\tpublic String getType() {\n+        \treturn \"doggie\";\n+        }        \n+    }\n+    \n+    @JsonTypeName(\"kitty\")\n+    static class Cat extends Animal\n+    {\n+        public String furColor;\n+        \n+        private Cat() { super(null); }\n+        public Cat(String name, String c) {\n+            super(name);\n+            furColor = c;\n+        }\n+        \n+\t\t@Override\n+\t\tpublic String getType() {\n+        \treturn \"kitty\";\n+        }        \n+    }\n+\n+    static class AnimalWrapper {\n+        public Animal animal;\n+        public AnimalWrapper() {}\n+        public AnimalWrapper(Animal a) { animal = a; }\n+    }\n+\n+\n+    /**\n+     * Polymorphic base class - existing property NOT forced by abstract method on base class\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Accord.class, name = \"accord\") ,\n+\t\t@Type(value = Camry.class, name = \"camry\") \n+\t\t})\n+\tstatic abstract class Car {\n+        public String name;        \n+        protected Car(String n)  { name = n; }\n+    }\n+\n+    @JsonTypeName(\"accord\")\n+    static class Accord extends Car\n+    {\n+        public int speakerCount;\n+        \n+        private Accord() { super(null); }\n+        public Accord(String name, int b) {\n+            super(name);\n+            speakerCount = b;\n+        }\n+        \n+\t\tpublic String getType() {\n+        \treturn \"accord\";\n+        }        \n+    }\n+    \n+    @JsonTypeName(\"camry\")\n+    static class Camry extends Car\n+    {\n+        public String exteriorColor;\n+        \n+        private Camry() { super(null); }\n+        public Camry(String name, String c) {\n+            super(name);\n+            exteriorColor = c;\n+        }\n+        \n+\t\tpublic String getType() {\n+        \treturn \"camry\";\n+        }        \n+    }\n+\n+    static class CarWrapper {\n+        public Car car;\n+        public CarWrapper() {}\n+        public CarWrapper(Car c) { car = c; }\n+    }\n+    \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    /*\n+    /**********************************************************\n+    /* Mock data\n+    /**********************************************************\n+     */\n+\n+\tprivate static final Orange mandarin = new Orange(\"Mandarin Orange\", \"orange\");\n+\tprivate static final String mandarinJson = \"{\\\"name\\\":\\\"Mandarin Orange\\\",\\\"color\\\":\\\"orange\\\",\\\"type\\\":\\\"orange\\\"}\";\t\n+\tprivate static final Apple pinguo = new Apple(\"Apple-A-Day\", 16);\n+\tprivate static final String pinguoJson = \"{\\\"name\\\":\\\"Apple-A-Day\\\",\\\"seedCount\\\":16,\\\"type\\\":\\\"apple\\\"}\";\n+\tprivate static final FruitWrapper pinguoWrapper = new FruitWrapper(pinguo);\n+\tprivate static final String pinguoWrapperJson = \"{\\\"fruit\\\":\" + pinguoJson + \"}\";\n+\tprivate static final List<Fruit> fruitList = Arrays.asList(pinguo, mandarin);\n+\tprivate static final String fruitListJson = \"[\" + pinguoJson + \",\" + mandarinJson + \"]\";\n+\n+\tprivate static final Cat beelzebub = new Cat(\"Beelzebub\", \"tabby\");\n+\tprivate static final String beelzebubJson = \"{\\\"name\\\":\\\"Beelzebub\\\",\\\"furColor\\\":\\\"tabby\\\",\\\"type\\\":\\\"kitty\\\"}\";\t\n+\tprivate static final Dog rover = new Dog(\"Rover\", 42);\n+\tprivate static final String roverJson = \"{\\\"name\\\":\\\"Rover\\\",\\\"boneCount\\\":42,\\\"type\\\":\\\"doggie\\\"}\";\n+\tprivate static final AnimalWrapper beelzebubWrapper = new AnimalWrapper(beelzebub);\n+\tprivate static final String beelzebubWrapperJson = \"{\\\"animal\\\":\" + beelzebubJson + \"}\";\n+\tprivate static final List<Animal> animalList = Arrays.asList(beelzebub, rover);\n+\tprivate static final String animalListJson = \"[\" + beelzebubJson + \",\" + roverJson + \"]\";\n+\n+\tprivate static final Camry camry = new Camry(\"Sweet Ride\", \"candy-apple-red\");\n+\tprivate static final String camryJson = \"{\\\"name\\\":\\\"Sweet Ride\\\",\\\"exteriorColor\\\":\\\"candy-apple-red\\\",\\\"type\\\":\\\"camry\\\"}\";\t\n+\tprivate static final Accord accord = new Accord(\"Road Rage\", 6);\n+\tprivate static final String accordJson = \"{\\\"name\\\":\\\"Road Rage\\\",\\\"speakerCount\\\":6,\\\"type\\\":\\\"accord\\\"}\";\n+\tprivate static final CarWrapper camryWrapper = new CarWrapper(camry);\n+\tprivate static final String camryWrapperJson = \"{\\\"car\\\":\" + camryJson + \"}\";\n+\tprivate static final List<Car> carList = Arrays.asList(camry, accord);\n+\tprivate static final String carListJson = \"[\" + camryJson + \",\" + accordJson + \"]\";\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fruits - serialization tests for simple property on sub-classes\n+     */\n+    public void testExistingPropertySerializationFruits() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, pinguo);\n+        assertEquals(3, result.size());\n+        assertEquals(pinguo.name, result.get(\"name\"));\n+        assertEquals(pinguo.seedCount, result.get(\"seedCount\"));\n+        assertEquals(pinguo.type, result.get(\"type\"));\n+        \n+        result = writeAndMap(MAPPER, mandarin);\n+        assertEquals(3, result.size());\n+        assertEquals(mandarin.name, result.get(\"name\"));\n+        assertEquals(mandarin.color, result.get(\"color\"));\n+        assertEquals(mandarin.type, result.get(\"type\"));\n+        \n+        String pinguoSerialized = MAPPER.writeValueAsString(pinguo);\n+        assertEquals(pinguoSerialized, pinguoJson);\n+\n+        String mandarinSerialized = MAPPER.writeValueAsString(mandarin);\n+        assertEquals(mandarinSerialized, mandarinJson);\n+\n+        String fruitWrapperSerialized = MAPPER.writeValueAsString(pinguoWrapper);\n+        assertEquals(fruitWrapperSerialized, pinguoWrapperJson);\n+\n+        String fruitListSerialized = MAPPER.writeValueAsString(fruitList);\n+        assertEquals(fruitListSerialized, fruitListJson);\n+    }\n+\n+    /**\n+     * Fruits - deserialization tests for simple property on sub-classes\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationFruits() throws Exception\n+    {\n+    \tFruit pinguoDeserialized = MAPPER.readValue(pinguoJson, Fruit.class);\n+    \tassertTrue(pinguoDeserialized instanceof Apple);\n+        assertSame(pinguoDeserialized.getClass(), Apple.class);\n+    \tassertEquals(pinguo.name, pinguoDeserialized.name);\n+    \tassertEquals(pinguo.seedCount, ((Apple) pinguoDeserialized).seedCount);\n+    \tassertEquals(pinguo.type, ((Apple) pinguoDeserialized).type);\n+\n+    \tFruitWrapper pinguoWrapperDeserialized = MAPPER.readValue(pinguoWrapperJson, FruitWrapper.class);\n+    \tFruit pinguoExtracted = pinguoWrapperDeserialized.fruit;\n+    \tassertTrue(pinguoExtracted instanceof Apple);\n+        assertSame(pinguoExtracted.getClass(), Apple.class);\n+    \tassertEquals(pinguo.name, pinguoExtracted.name);\n+    \tassertEquals(pinguo.seedCount, ((Apple) pinguoExtracted).seedCount);\n+    \tassertEquals(pinguo.type, ((Apple) pinguoExtracted).type);\n+\n+    \t@SuppressWarnings(\"unchecked\")\n+\t\tList<Fruit> fruitListDeserialized = MAPPER.readValue(fruitListJson, List.class);\n+    \tassertNotNull(fruitListDeserialized);\n+    \tassertTrue(fruitListDeserialized.size() == 2);\n+    \tFruit apple = MAPPER.convertValue(fruitListDeserialized.get(0), Apple.class);\n+    \tassertTrue(apple instanceof Apple);\n+        assertSame(apple.getClass(), Apple.class);\n+    \tFruit orange = MAPPER.convertValue(fruitListDeserialized.get(1), Orange.class);\n+    \tassertTrue(orange instanceof Orange);\n+        assertSame(orange.getClass(), Orange.class);\n+    }\n+\n+\n+    /**\n+     * Animals - serialization tests for abstract method in base class\n+     */\n+    public void testExistingPropertySerializationAnimals() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, beelzebub);\n+        assertEquals(3, result.size());\n+        assertEquals(beelzebub.name, result.get(\"name\"));\n+        assertEquals(beelzebub.furColor, result.get(\"furColor\"));\n+        assertEquals(beelzebub.getType(), result.get(\"type\"));\n+\n+        result = writeAndMap(MAPPER, rover);\n+        assertEquals(3, result.size());\n+        assertEquals(rover.name, result.get(\"name\"));\n+        assertEquals(rover.boneCount, result.get(\"boneCount\"));\n+        assertEquals(rover.getType(), result.get(\"type\"));\n+        \n+        String beelzebubSerialized = MAPPER.writeValueAsString(beelzebub);\n+        assertEquals(beelzebubSerialized, beelzebubJson);\n+        \n+        String roverSerialized = MAPPER.writeValueAsString(rover);\n+        assertEquals(roverSerialized, roverJson);\n+        \n+        String animalWrapperSerialized = MAPPER.writeValueAsString(beelzebubWrapper);\n+        assertEquals(animalWrapperSerialized, beelzebubWrapperJson);\n+\n+        String animalListSerialized = MAPPER.writeValueAsString(animalList);\n+        assertEquals(animalListSerialized, animalListJson);\n+    }\n+\n+    /**\n+     * Animals - deserialization tests for abstract method in base class\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationAnimals() throws Exception\n+    {\n+    \tAnimal beelzebubDeserialized = MAPPER.readValue(beelzebubJson, Animal.class);\n+    \tassertTrue(beelzebubDeserialized instanceof Cat);\n+        assertSame(beelzebubDeserialized.getClass(), Cat.class);\n+    \tassertEquals(beelzebub.name, beelzebubDeserialized.name);\n+    \tassertEquals(beelzebub.furColor, ((Cat) beelzebubDeserialized).furColor);\n+    \tassertEquals(beelzebub.getType(), beelzebubDeserialized.getType());\n+\n+    \tAnimalWrapper beelzebubWrapperDeserialized = MAPPER.readValue(beelzebubWrapperJson, AnimalWrapper.class);\n+    \tAnimal beelzebubExtracted = beelzebubWrapperDeserialized.animal;\n+    \tassertTrue(beelzebubExtracted instanceof Cat);\n+        assertSame(beelzebubExtracted.getClass(), Cat.class);\n+    \tassertEquals(beelzebub.name, beelzebubExtracted.name);\n+    \tassertEquals(beelzebub.furColor, ((Cat) beelzebubExtracted).furColor);\n+    \tassertEquals(beelzebub.getType(), beelzebubExtracted.getType());\n+    \t\n+    \t@SuppressWarnings(\"unchecked\")\n+\t\tList<Animal> animalListDeserialized = MAPPER.readValue(animalListJson, List.class);\n+    \tassertNotNull(animalListDeserialized);\n+    \tassertTrue(animalListDeserialized.size() == 2);\n+    \tAnimal cat = MAPPER.convertValue(animalListDeserialized.get(0), Animal.class);\n+    \tassertTrue(cat instanceof Cat);\n+        assertSame(cat.getClass(), Cat.class);\n+    \tAnimal dog = MAPPER.convertValue(animalListDeserialized.get(1), Animal.class);\n+    \tassertTrue(dog instanceof Dog);\n+        assertSame(dog.getClass(), Dog.class);\n+    }\n+\n+    \n+    /**\n+     * Cars - serialization tests for no abstract method or type variable in base class\n+     */\n+    public void testExistingPropertySerializationCars() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, camry);\n+        assertEquals(3, result.size());\n+        assertEquals(camry.name, result.get(\"name\"));\n+        assertEquals(camry.exteriorColor, result.get(\"exteriorColor\"));\n+        assertEquals(camry.getType(), result.get(\"type\"));\n+\n+        result = writeAndMap(MAPPER, accord);\n+        assertEquals(3, result.size());\n+        assertEquals(accord.name, result.get(\"name\"));\n+        assertEquals(accord.speakerCount, result.get(\"speakerCount\"));\n+        assertEquals(accord.getType(), result.get(\"type\"));\n+        \n+        String camrySerialized = MAPPER.writeValueAsString(camry);\n+        assertEquals(camrySerialized, camryJson);\n+        \n+        String accordSerialized = MAPPER.writeValueAsString(accord);\n+        assertEquals(accordSerialized, accordJson);\n+        \n+        String carWrapperSerialized = MAPPER.writeValueAsString(camryWrapper);\n+        assertEquals(carWrapperSerialized, camryWrapperJson);\n+\n+        String carListSerialized = MAPPER.writeValueAsString(carList);\n+        assertEquals(carListSerialized, carListJson);\n+    }\n+\n+    /**\n+     * Cars - deserialization tests for no abstract method or type variable in base class\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationCars() throws Exception\n+    {\n+    \tCar camryDeserialized = MAPPER.readValue(camryJson, Camry.class);\n+    \tassertTrue(camryDeserialized instanceof Camry);\n+        assertSame(camryDeserialized.getClass(), Camry.class);\n+    \tassertEquals(camry.name, camryDeserialized.name);\n+    \tassertEquals(camry.exteriorColor, ((Camry) camryDeserialized).exteriorColor);\n+    \tassertEquals(camry.getType(), ((Camry) camryDeserialized).getType());\n+\n+    \tCarWrapper camryWrapperDeserialized = MAPPER.readValue(camryWrapperJson, CarWrapper.class);\n+    \tCar camryExtracted = camryWrapperDeserialized.car;\n+    \tassertTrue(camryExtracted instanceof Camry);\n+        assertSame(camryExtracted.getClass(), Camry.class);\n+    \tassertEquals(camry.name, camryExtracted.name);\n+    \tassertEquals(camry.exteriorColor, ((Camry) camryExtracted).exteriorColor);\n+    \tassertEquals(camry.getType(), ((Camry) camryExtracted).getType());\n+    \t\n+    \t@SuppressWarnings(\"unchecked\")\n+\t\tList<Car> carListDeserialized = MAPPER.readValue(carListJson, List.class);\n+    \tassertNotNull(carListDeserialized);\n+    \tassertTrue(carListDeserialized.size() == 2);\n+    \tCar camry = MAPPER.convertValue(carListDeserialized.get(0), Car.class);\n+    \tassertTrue(camry instanceof Camry);\n+        assertSame(camry.getClass(), Camry.class);\n+    \tCar accord = MAPPER.convertValue(carListDeserialized.get(1), Car.class);\n+    \tassertTrue(accord instanceof Accord);\n+        assertSame(accord.getClass(), Accord.class);\n+    }\n+\n+    \n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     }\n \n     /**\n+     * @since 2.1\n+     */\n+    protected void _checkInvalidCopy(Class<?> exp)\n+    {\n+        if (getClass() != exp) {\n+            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n+                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n+        }\n+    }\n+\n+    /**\n      * Factory method sub-classes must override, to produce {@link ObjectReader}\n      * instances of proper sub-type\n      * \n             FormatSchema schema, InjectableValues injectableValues) {\n         return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues);\n     }\n-    \n-    /**\n-     * @since 2.1\n-     */\n-    protected void _checkInvalidCopy(Class<?> exp)\n-    {\n-        if (getClass() != exp) {\n-            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n-                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n-        }\n-    }\n-    \n+\n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _newWriter(SerializationConfig config) {\n+        return new ObjectWriter(this, config);\n+    }\n+\n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) {\n+        return new ObjectWriter(this, config, schema);\n+    }\n+    \n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _newWriter(SerializationConfig config,\n+            JavaType rootType, PrettyPrinter pp) {\n+        return new ObjectWriter(this, config, rootType, pp);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Versioned impl\n      * with default settings.\n      */\n     public ObjectWriter writer() {\n-        return new ObjectWriter(this, getSerializationConfig());\n+        return _newWriter(getSerializationConfig());\n     }\n \n     /**\n      * mapper instance has).\n      */\n     public ObjectWriter writer(SerializationFeature feature) {\n-        return new ObjectWriter(this, getSerializationConfig().with(feature));\n+        return _newWriter(getSerializationConfig().with(feature));\n     }\n \n     /**\n      */\n     public ObjectWriter writer(SerializationFeature first,\n             SerializationFeature... other) {\n-        return new ObjectWriter(this, getSerializationConfig().with(first, other));\n+        return _newWriter(getSerializationConfig().with(first, other));\n     }\n     \n     /**\n      * null passed, using timestamp (64-bit number.\n      */\n     public ObjectWriter writer(DateFormat df) {\n-        return new ObjectWriter(this, getSerializationConfig().with(df));\n+        return _newWriter(getSerializationConfig().with(df));\n     }\n     \n     /**\n      * serialize objects using specified JSON View (filter).\n      */\n     public ObjectWriter writerWithView(Class<?> serializationView) {\n-        return new ObjectWriter(this, getSerializationConfig().withView(serializationView));\n+        return _newWriter(getSerializationConfig().withView(serializationView));\n     }\n     \n     /**\n      * type.\n      */\n     public ObjectWriter writerWithType(Class<?> rootType) {\n-        return new ObjectWriter(this, getSerializationConfig(),\n+        return _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                 ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                 /*PrettyPrinter*/null);\n      * runtime type of value. Type must be a super-type of runtime type.\n      */\n     public ObjectWriter writerWithType(TypeReference<?> rootType) {\n-        return new ObjectWriter(this, getSerializationConfig(),\n+        return _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                 ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                 /*PrettyPrinter*/null);\n      * runtime type of value. Type must be a super-type of runtime type.\n      */\n     public ObjectWriter writerWithType(JavaType rootType) {\n-        return new ObjectWriter(this, getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n+        return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n     }\n     \n     /**\n         if (pp == null) { // need to use a marker to indicate explicit disabling of pp\n             pp = ObjectWriter.NULL_PRETTY_PRINTER;\n         }\n-        return new ObjectWriter(this, getSerializationConfig(), /*root type*/ null, pp);\n+        return _newWriter(getSerializationConfig(), /*root type*/ null, pp);\n     }\n     \n     /**\n      * serialize objects using the default pretty printer for indentation\n      */\n     public ObjectWriter writerWithDefaultPrettyPrinter() {\n-        return new ObjectWriter(this, getSerializationConfig(),\n+        return _newWriter(getSerializationConfig(),\n                 /*root type*/ null, _defaultPrettyPrinter());\n     }\n     \n      * serialize objects using specified filter provider.\n      */\n     public ObjectWriter writer(FilterProvider filterProvider) {\n-        return new ObjectWriter(this,\n-                getSerializationConfig().withFilters(filterProvider));\n+        return _newWriter(getSerializationConfig().withFilters(filterProvider));\n     }\n     \n     /**\n      */\n     public ObjectWriter writer(FormatSchema schema) {\n         _verifySchemaType(schema);\n-        return new ObjectWriter(this, getSerializationConfig(), schema);\n+        return _newWriter(getSerializationConfig(), schema);\n     }\n \n     /**\n      * @since 2.1\n      */\n     public ObjectWriter writer(Base64Variant defaultBase64) {\n-        return new ObjectWriter(this, getSerializationConfig().with(defaultBase64));\n+        return _newWriter(getSerializationConfig().with(defaultBase64));\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectWriter writer(CharacterEscapes escapes) {\n-        return writer().with(escapes);\n+        return _newWriter(getSerializationConfig()).with(escapes);\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectWriter writer(ContextAttributes attrs) {\n-        return new ObjectWriter(this, getSerializationConfig().with(attrs));\n+        return _newWriter(getSerializationConfig().with(attrs));\n     }\n     \n     /*", "timestamp": 1413426253, "metainfo": ""}