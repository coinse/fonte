{"sha": "a854674b6692a958bd64abc61183274486d575da", "log": "test cleanup", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n \n     static class XBean {\n         public int x;\n-    }\n-\n-    // [JACKSON-822]\n-    static interface Issue822Interface {\n-        public int getA();\n-    }\n-\n-    // If this annotation is added, things will work:\n-    //@com.fasterxml.jackson.databind.annotation.JsonSerialize(as=Issue822Interface.class)\n-    // but it should not be necessary when root type is passed\n-    static class Issue822Impl implements Issue822Interface {\n-        public int getA() { return 3; }\n-        public int getB() { return 9; }\n     }\n     \n     /*\n         List<?> result = r.withType(List.class).readValue(quote(\"\"));\n         assertNull(result);\n     }\n-\n-    // [JACKSON-822]: ensure that type can be coerced\n-    public void testTypedLists() throws Exception\n-    {\n-        List<Issue822Interface> list = new ArrayList<Issue822Interface>();\n-        String singleJson = MAPPER.writerWithType(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n-        // start with specific value case:\n-        assertEquals(\"{\\\"a\\\":3}\", singleJson);\n-        // then lists\n-        list.add(new Issue822Impl());\n-        String listJson = MAPPER.writerWithType(new TypeReference<List<Issue822Interface>>(){})\n-                .writeValueAsString(list);\n-        assertEquals(\"[{\\\"a\\\":3}]\", listJson);\n-    }\n-\n-    // [JACKSON-822]: ensure that type can be coerced\n-    public void testTypedArrays() throws Exception\n-    {\n-        assertEquals(\"[{\\\"a\\\":3}]\", MAPPER.writerWithType(Issue822Interface[].class).writeValueAsString(\n-                new Issue822Interface[] { new Issue822Impl() }));\n-    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n \n \n         public Iterable<String> getValues() { return values; }\n     }\n+\n+    // [JACKSON-822]\n+    static interface Issue822Interface {\n+        public int getA();\n+    }\n+\n+    // If this annotation is added, things will work:\n+    //@com.fasterxml.jackson.databind.annotation.JsonSerialize(as=Issue822Interface.class)\n+    // but it should not be necessary when root type is passed\n+    static class Issue822Impl implements Issue822Interface {\n+        public int getA() { return 3; }\n+        public int getB() { return 9; }\n+    }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n+    private final static ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testCollections()\n         throws IOException\n     {\n         // Let's try different collections, arrays etc\n         final int entryLen = 98;\n-        ObjectMapper mapper = new ObjectMapper();\n \n         for (int type = 0; type < 4; ++type) {\n             Object value;\n                 }\n                 value = c;\n             }\n-            StringWriter sw = new StringWriter();\n-            mapper.writeValue(sw, value);\n+            String json = MAPPER.writeValueAsString(value);\n             \n             // and then need to verify:\n-            JsonParser jp = new JsonFactory().createJsonParser(sw.toString());\n+            JsonParser jp = new JsonFactory().createJsonParser(json);\n             assertToken(JsonToken.START_ARRAY, jp.nextToken());\n             for (int i = 0; i < entryLen; ++i) {\n                 assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n         for (int i = 0; i <= COUNT; ++i) {\n             value.add(i);\n         }\n-        ObjectMapper mapper = new ObjectMapper();\n         // Let's test using 3 main variants...\n         for (int mode = 0; mode < 3; ++mode) {\n             JsonParser jp = null;\n             switch (mode) {\n             case 0:\n                 {\n-                    byte[] data = mapper.writeValueAsBytes(value);\n+                    byte[] data = MAPPER.writeValueAsBytes(value);\n                     jp = new JsonFactory().createJsonParser(data);\n                 }\n                 break;\n             case 1:\n                 {\n                     StringWriter sw = new StringWriter(value.size());\n-                    mapper.writeValue(sw, value);\n+                    MAPPER.writeValue(sw, value);\n                     jp = createParserUsingReader(sw.toString());\n                 }\n                 break;\n             case 2:\n                 {\n-                    String str = mapper.writeValueAsString(value);\n+                    String str = MAPPER.writeValueAsString(value);\n                     jp = createParserUsingReader(str);\n                 }\n                 break;\n     public void testEnumMap()\n         throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        StringWriter sw = new StringWriter();\n         EnumMap<Key,String> map = new EnumMap<Key,String>(Key.class);\n         map.put(Key.B, \"xyz\");\n         map.put(Key.C, \"abc\");\n         // assuming EnumMap uses enum entry order, which I think is true...\n-        mapper.writeValue(sw, map);\n-        assertEquals(\"{\\\"B\\\":\\\"xyz\\\",\\\"C\\\":\\\"abc\\\"}\", sw.toString().trim());\n+        String json = MAPPER.writeValueAsString(map);\n+        assertEquals(\"{\\\"B\\\":\\\"xyz\\\",\\\"C\\\":\\\"abc\\\"}\",json.trim());\n     }\n \n     public void testIterator()\n         throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n         ArrayList<Integer> l = new ArrayList<Integer>();\n         l.add(1);\n         l.add(-9);\n         l.add(0);\n-        mapper.writeValue(sw, l.iterator());\n+        MAPPER.writeValue(sw, l.iterator());\n         assertEquals(\"[1,-9,0]\", sw.toString().trim());\n     }\n \n     public void testIterable()\n         throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         StringWriter sw = new StringWriter();\n-        mapper.writeValue(sw, new IterableWrapper(new int[] { 1, 2, 3 }));\n+        MAPPER.writeValue(sw, new IterableWrapper(new int[] { 1, 2, 3 }));\n         assertEquals(\"[1,2,3]\", sw.toString().trim());\n     }\n \n         Collection<Object> x = new ArrayList<Object>();\n         x.add(\"foobar\");\n         CollectionBean cb = new CollectionBean(x);\n-        ObjectMapper m = new ObjectMapper();\n-        Map<String,Object> result = writeAndMap(m, cb);\n+        Map<String,Object> result = writeAndMap(MAPPER, cb);\n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"values\"));\n         Collection<Object> x2 = (Collection<Object>) result.get(\"values\");\n         throws IOException\n     {\n         CollectionBean cb = new CollectionBean(null);\n-        ObjectMapper m = new ObjectMapper();\n-        Map<String,Object> result = writeAndMap(m, cb);\n+        Map<String,Object> result = writeAndMap(MAPPER, cb);\n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"values\"));\n         assertNull(result.get(\"values\"));\n     {\n         EnumMap<Key,String> map = new EnumMap<Key,String>(Key.class);\n         EnumMapBean b = new EnumMapBean(map);\n-        ObjectMapper m = new ObjectMapper();\n-        Map<String,Object> result = writeAndMap(m, b);\n+        Map<String,Object> result = writeAndMap(MAPPER, b);\n \n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"map\"));\n         throws IOException\n     {\n         EnumMapBean b = new EnumMapBean(null);\n-        ObjectMapper m = new ObjectMapper();\n-        Map<String,Object> result = writeAndMap(m, b);\n+        Map<String,Object> result = writeAndMap(MAPPER, b);\n \n         assertEquals(1, result.size());\n         assertTrue(result.containsKey(\"map\"));\n     // Test [JACKSON-220]\n     public void testListSerializer() throws IOException\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        assertEquals(\"\\\"[ab, cd, ef]\\\"\", m.writeValueAsString(new PseudoList(\"ab\", \"cd\", \"ef\")));\n+        assertEquals(\"\\\"[ab, cd, ef]\\\"\",\n+                MAPPER.writeValueAsString(new PseudoList(\"ab\", \"cd\", \"ef\")));\n     }\n \n     // [JACKSON-254]\n         // by default, empty lists serialized normally\n         EmptyListBean list = new EmptyListBean();\n         EmptyArrayBean array = new EmptyArrayBean();\n+        assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS));\n+        assertEquals(\"{\\\"empty\\\":[]}\", MAPPER.writeValueAsString(list));\n+        assertEquals(\"{\\\"empty\\\":[]}\", MAPPER.writeValueAsString(array));\n+\n+        // note: value of setting may be cached when constructing serializer, need a new instance\n         ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.getSerializationConfig().isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS));\n-        assertEquals(\"{\\\"empty\\\":[]}\", m.writeValueAsString(list));\n-        assertEquals(\"{\\\"empty\\\":[]}\", m.writeValueAsString(array));\n-\n-        // note: value of setting may be cached when constructing serializer, need a new instance\n-        m = new ObjectMapper();\n         m.configure(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS, false);\n         assertEquals(\"{}\", m.writeValueAsString(list));\n         assertEquals(\"{}\", m.writeValueAsString(array));\n     // [JACKSON-689]\n     public void testWithIterable() throws IOException\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        assertEquals(\"{\\\"values\\\":[\\\"value\\\"]}\", m.writeValueAsString(new BeanWithIterable()));\n+        assertEquals(\"{\\\"values\\\":[\\\"value\\\"]}\",\n+                MAPPER.writeValueAsString(new BeanWithIterable()));\n+    }\n+    \n+    // [JACKSON-822]: ensure that type can be coerced\n+    public void testTypedArrays() throws Exception\n+    {\n+        assertEquals(\"[{\\\"a\\\":3}]\", MAPPER.writerWithType(Issue822Interface[].class).writeValueAsString(\n+                new Issue822Interface[] { new Issue822Impl() }));\n+    }\n+    \n+    // [JACKSON-822]: ensure that type can be coerced\n+    public void testTypedLists() throws Exception\n+    {\n+        /*\n+        String singleJson = MAPPER.writerWithType(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n+        // start with specific value case:\n+        assertEquals(\"{\\\"a\\\":3}\", singleJson);\n+        */\n+\n+        // then lists\n+        List<Issue822Interface> list = new ArrayList<Issue822Interface>();\n+        list.add(new Issue822Impl());\n+        String listJson = MAPPER.writerWithType(new TypeReference<List<Issue822Interface>>(){})\n+                .writeValueAsString(list);\n+        assertEquals(\"[{\\\"a\\\":3}]\", listJson);\n     }\n }", "timestamp": 1338678585, "metainfo": ""}