{"sha": "c5b808b930e3342bf86869584f71467139d490e0", "log": "More work on trying to call JsonParser.nextTextValue() for String-valued JSON arrays, to help with XML processing", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n \n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+            TypeDeserializer typeDeserializer) throws IOException\n     {\n         /* Should there be separate handling for base64 stuff?\n          * for now this should be enough:\n         public CharDeser() { super(char[].class); }\n \n         @Override\n-        public char[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public char[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             /* Won't take arrays, must get a String (could also\n              * convert other tokens to Strings... but let's not bother\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n \n-        private final boolean[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        private final boolean[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n         public ByteDeser() { super(byte[].class); }\n \n         @Override\n-        public byte[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             JsonToken t = jp.getCurrentToken();\n             \n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n \n-        private final byte[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        private final byte[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n         public ShortDeser() { super(short[].class); }\n \n         @Override\n-        public short[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public short[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             if (!jp.isExpectedStartArrayToken()) {\n                 return handleNonArray(jp, ctxt);\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n \n-        private final short[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        private final short[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n         public IntDeser() { super(int[].class); }\n \n         @Override\n-        public int[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public int[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             if (!jp.isExpectedStartArrayToken()) {\n                 return handleNonArray(jp, ctxt);\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n \n-        private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n         public LongDeser() { super(long[].class); }\n \n         @Override\n-        public long[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public long[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             if (!jp.isExpectedStartArrayToken()) {\n                 return handleNonArray(jp, ctxt);\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n \n-        private final long[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        private final long[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n         public DoubleDeser() { super(double[].class); }\n \n         @Override\n-        public double[] deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public double[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             if (!jp.isExpectedStartArrayToken()) {\n                 return handleNonArray(jp, ctxt);\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n \n-        private final double[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        private final double[] handleNonArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n         {\n             // [JACKSON-620] Empty String can become null...\n             if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n         final JsonDeserializer<String> deser = _elementDeserializer;\n         \n         int ix = 0;\n-        JsonToken t;\n \n         try {\n-            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n-                // Ok: no need to convert Strings, but must recognize nulls\n-                String value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n+            while (true) {\n+                /* 30-Dec-2014, tatu: This may look odd, but let's actually call method\n+                 *   that suggest we are expecting a String; this helps with some formats,\n+                 *   notably XML. Note, however, that while we can get String, we can't\n+                 *   assume that's what we use due to custom deserializer\n+                 */\n+                String value;\n+                if (jp.nextTextValue() == null) {\n+                    JsonToken t = jp.getCurrentToken();\n+                    if (t == JsonToken.END_ARRAY) {\n+                        break;\n+                    }\n+                    // Ok: no need to convert Strings, but must recognize nulls\n+                    value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n+                } else {\n+                    value = deser.deserialize(jp, ctxt);\n+                }\n                 if (ix >= chunk.length) {\n                     chunk = buffer.appendCompletedChunk(chunk);\n                     ix = 0;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n     private Collection<String> deserializeUsingCustom(JsonParser jp, DeserializationContext ctxt,\n             Collection<String> result, final JsonDeserializer<String> deser) throws IOException\n     {\n-        JsonToken t;\n-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+        while (true) {\n+            /* 30-Dec-2014, tatu: This may look odd, but let's actually call method\n+             *   that suggest we are expecting a String; this helps with some formats,\n+             *   notably XML. Note, however, that while we can get String, we can't\n+             *   assume that's what we use due to custom deserializer\n+             */\n             String value;\n-\n-            if (t == JsonToken.VALUE_NULL) {\n-                value = deser.getNullValue();\n+            if (jp.nextTextValue() == null) {\n+                JsonToken t = jp.getCurrentToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    break;\n+                }\n+                // Ok: no need to convert Strings, but must recognize nulls\n+                value = (t == JsonToken.VALUE_NULL) ? deser.getNullValue() : deser.deserialize(jp, ctxt);\n             } else {\n                 value = deser.deserialize(jp, ctxt);\n             }\n     }\n \n     /**\n-     * Helper method called when current token is no START_ARRAY. Will either\n+     * Helper method called when current token is not START_ARRAY. Will either\n      * throw an exception, or try to handle value as if member of implicit\n      * array, depending on configuration.\n      */", "timestamp": 1419998379, "metainfo": ""}