{"sha": "930187bf135ea5519d2d70f24079ec0e39d797a6", "log": "Implemented #195, ability to disable inference of mutators (inclusion of non-visible field/setter, if visible/annotated getter with same name is found)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n       */\n      AUTO_DETECT_SETTERS(true),\n      \n-     /**\n-      * Feature that determines whether getters (getter methods)\n-      * can be auto-detected if there is no matching mutator (setter,\n-      * constructor parameter or field) or not: if set to true,\n-      * only getters that match a mutator are auto-discovered; if\n-      * false, all auto-detectable getters can be discovered.\n-      *<p>\n-      * Feature is disabled by default.\n-      */\n-     REQUIRE_SETTERS_FOR_GETTERS(false),\n-\n-     /**\n-      * Feature that determines whether otherwise regular \"getter\"\n-      * methods (but only ones that handle Collections and Maps,\n-      * not getters of other type)\n-      * can be used for purpose of getting a reference to a Collection\n-      * and Map to modify the property, without requiring a setter\n-      * method.\n-      * This is similar to how JAXB framework sets Collections and\n-      * Maps: no setter is involved, just setter.\n-      *<p>\n-      * Note that such getters-as-setters methods have lower\n-      * precedence than setters, so they are only used if no\n-      * setter is found for the Map/Collection property.\n-      *<p>\n-      * Feature is enabled by default.\n-      */\n-     USE_GETTERS_AS_SETTERS(true),\n-\n-     /**\n+    /**\n+     * Feature that determines whether getters (getter methods)\n+     * can be auto-detected if there is no matching mutator (setter,\n+     * constructor parameter or field) or not: if set to true,\n+     * only getters that match a mutator are auto-discovered; if\n+     * false, all auto-detectable getters can be discovered.\n+     *<p>\n+     * Feature is disabled by default.\n+     */\n+    REQUIRE_SETTERS_FOR_GETTERS(false),\n+\n+    /**\n+     * Feature that determines whether otherwise regular \"getter\"\n+     * methods (but only ones that handle Collections and Maps,\n+     * not getters of other type)\n+     * can be used for purpose of getting a reference to a Collection\n+     * and Map to modify the property, without requiring a setter\n+     * method.\n+     * This is similar to how JAXB framework sets Collections and\n+     * Maps: no setter is involved, just setter.\n+     *<p>\n+     * Note that such getters-as-setters methods have lower\n+     * precedence than setters, so they are only used if no\n+     * setter is found for the Map/Collection property.\n+     *<p>\n+     * Feature is enabled by default.\n+     */\n+    USE_GETTERS_AS_SETTERS(true),\n+\n+    /**\n      * Feature that determines whether method and field access\n      * modifier settings can be overridden when accessing\n      * properties. If enabled, method\n      */\n     CAN_OVERRIDE_ACCESS_MODIFIERS(true),\n \n+    /**\n+     * Feature that determines whether member mutators (fields and\n+     * setters) may be \"pulled in\" even if they are not visible,\n+     * as long as there is a visible accessor (getter or field) with same name.\n+     * For example: field \"value\" may be inferred as mutator,\n+     * if there is visible or explicitly marked getter \"getValue()\".\n+     * If enabled, inferring is enabled; otherwise (disabled) only visible and\n+     * explicitly annotated accessors are ever used.\n+     *<p>\n+     * Note that 'getters' are never inferred and need to be either visible (including\n+     * bean-style naming) or explicitly annotated.\n+     *<p>\n+     * Feature is enabled by default.\n+     * \n+     * @since 2.2\n+     */\n+    INFER_PROPERTY_MUTATORS(true),\n+    \n     /*\n     /******************************************************\n     /* Type-handling features\n      * @since 2.1\n      */\n     USE_WRAPPER_NAME_AS_PROPERTY_NAME(false)\n-    \n     ;\n \n     private final boolean _defaultState;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n     protected void _removeUnwantedProperties()\n     {\n         Iterator<Map.Entry<String,POJOPropertyBuilder>> it = _properties.entrySet().iterator();\n+        final boolean forceNonVisibleRemoval = !_config.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS);\n+        \n         while (it.hasNext()) {\n             Map.Entry<String, POJOPropertyBuilder> entry = it.next();\n             POJOPropertyBuilder prop = entry.getValue();\n                 }\n             }\n             // and finally, handle removal of individual non-visible elements\n-            prop.removeNonVisible();\n+            prop.removeNonVisible(forceNonVisibleRemoval);\n         }\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n         _ctorParameters = _removeIgnored(_ctorParameters);\n     }\n \n-    public void removeNonVisible()\n+    /**\n+     * @deprecated Since 2.2, use variant that takes boolean argument\n+     */\n+    @Deprecated\n+    public void removeNonVisible() {\n+        removeNonVisible(false);\n+    }\n+    \n+    \n+    public void removeNonVisible(boolean force)\n     {\n         /* 21-Aug-2011, tatu: This is tricky part -- if and when allow\n          *   non-visible property elements to be \"pulled in\" by visible\n          *   For now, we will only do this to pull in setter or field used\n          *   as setter, if an explicit getter is found.\n          */\n+        /*\n+         * 28-Mar-2013, tatu: Also, as per [Issue#195], may force removal\n+         *   if inferred properties are NOT supported.\n+         */\n         _getters = _removeNonVisible(_getters);\n         _ctorParameters = _removeNonVisible(_ctorParameters);\n \n-        if (_getters == null) {\n+        if (force || (_getters == null)) {\n             _fields = _removeNonVisible(_fields);\n             _setters = _removeNonVisible(_setters);\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestConfig.java\n     /**********************************************************\n      */\n \n+    /* Test to verify that we don't overflow number of features; if we\n+     * hit the limit, need to change implementation -- this test just\n+     * gives low-water mark\n+     */\n+    public void testEnumIndexes()\n+    {\n+        int max = 0;\n+        \n+        for (DeserializationFeature f : DeserializationFeature.values()) {\n+            max = Math.max(max, f.ordinal());\n+        }\n+        if (max >= 31) { // 31 is actually ok; 32 not\n+            fail(\"Max number of DeserializationFeature enums reached: \"+max);\n+        }\n+    }\n+    \n     public void testDefaults()\n     {\n         ObjectMapper m = new ObjectMapper();\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestInferredAccessors.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.MapperFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestInferredAccessors\n+    extends BaseMapTest\n+{\n+    public static class Point {\n+        private int x;\n+        \n+        public int getX() { return x; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testDeserializationInference() throws Exception\n+    {\n+        final String JSON = \"{\\\"x\\\":2}\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        // First: default case, inference enabled:\n+        assertTrue(mapper.isEnabled(MapperFeature.INFER_PROPERTY_MUTATORS));\n+        Point p = mapper.readValue(JSON,  Point.class);\n+        assertEquals(2, p.x);\n+\n+        // but without it, should fail:\n+        mapper = new ObjectMapper();\n+        mapper.disable(MapperFeature.INFER_PROPERTY_MUTATORS);\n+        try {\n+            p = mapper.readValue(JSON,  Point.class);\n+            fail(\"Should not succeeed\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"unrecognized field \\\"x\\\"\");\n+        }\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n \n     final static ObjectMapper MAPPER = new ObjectMapper();\n \n+    /* Test to verify that we don't overflow number of features; if we\n+     * hit the limit, need to change implementation -- this test just\n+     * gives low-water mark\n+     */\n+    public void testEnumIndexes()\n+    {\n+        int max = 0;\n+        \n+        for (SerializationFeature f : SerializationFeature.values()) {\n+            max = Math.max(max, f.ordinal());\n+        }\n+        if (max >= 31) { // 31 is actually ok; 32 not\n+            fail(\"Max number of SerializationFeature enums reached: \"+max);\n+        }\n+    }\n+    \n     public void testDefaults()\n     {\n         SerializationConfig cfg = MAPPER.getSerializationConfig();", "timestamp": 1364505442, "metainfo": ""}