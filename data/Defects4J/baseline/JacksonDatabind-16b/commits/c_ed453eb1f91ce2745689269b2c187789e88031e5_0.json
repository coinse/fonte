{"sha": "ed453eb1f91ce2745689269b2c187789e88031e5", "log": "Added most modifiers for #120", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n             return NumberSerializers.NumberSerializer.instance;\n         }\n         if (Enum.class.isAssignableFrom(raw)) {\n-            /* As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n-             * Challenge here is that EnumSerializer does not know how to produce\n-             * POJO style serialization, so we must handle that special case separately;\n-             * otherwise pass it to EnumSerializer.\n-             */\n-            JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n-            if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n-                // one special case: suppress serialization of \"getDeclaringClass()\"...\n-                ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\");\n-            } else {\n-                @SuppressWarnings(\"unchecked\")\n-                Class<Enum<?>> enumClass = (Class<Enum<?>>) raw;\n-                return EnumSerializer.construct(enumClass, prov.getConfig(), beanDesc, format);\n-            }\n+            return buildEnumSerializer(prov.getConfig(), type, beanDesc);\n         }\n         if (Calendar.class.isAssignableFrom(raw)) {\n             return CalendarSerializer.instance;\n             }\n             // Only custom serializers may be available:\n             for (Serializers serializers : customSerializers()) {\n+                MapLikeType mlType = (MapLikeType) type;\n                 JsonSerializer<?> ser = serializers.findMapLikeSerializer(config,\n-                        (MapLikeType) type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n+                        mlType, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n                 if (ser != null) {\n+                    // [Issue#120]: Allow post-processing\n+                    if (_factoryConfig.hasSerializerModifiers()) {\n+                        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                            ser = mod.modifyMapLikeSerializer(config, mlType, beanDesc, ser);\n+                        }\n+                    }\n                     return ser;\n                 }\n             }\n         }\n         if (type.isCollectionLikeType()) {\n             CollectionLikeType clt = (CollectionLikeType) type;\n-            if (clt.isTrueCollectionType()) { // only have custom ones, if any:\n-                CollectionType trueCT = (CollectionType) clt;\n-                // Module-provided custom collection serializers?\n-                for (Serializers serializers : customSerializers()) {\n-                    JsonSerializer<?> ser = serializers.findCollectionSerializer(config,\n-                            trueCT, beanDesc, elementTypeSerializer, elementValueSerializer);\n-                    if (ser != null) {\n-                        return ser;\n+            if (clt.isTrueCollectionType()) {\n+                return buildCollectionSerializer(config,  (CollectionType) clt, beanDesc, staticTyping,\n+                        elementTypeSerializer, elementValueSerializer);\n+            }\n+            CollectionLikeType clType = (CollectionLikeType) type;\n+            // Only custom variants for this:\n+            for (Serializers serializers : customSerializers()) {\n+                JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config,\n+                        clType, beanDesc, elementTypeSerializer, elementValueSerializer);\n+                if (ser != null) {\n+                    // [Issue#120]: Allow post-processing\n+                    if (_factoryConfig.hasSerializerModifiers()) {\n+                        for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                            ser = mod.modifyCollectionLikeSerializer(config, clType, beanDesc, ser);\n+                        }\n                     }\n+                    return ser;\n                 }\n-\n-                // As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n-                // Challenge here is that EnumSerializer does not know how to produce\n-                // POJO style serialization, so we must handle that special case separately;\n-                // otherwise pass it to EnumSerializer.\n-                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n-\n-                if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) {\n-                    return buildCollectionSerializer(config, trueCT, beanDesc, staticTyping,\n-                            elementTypeSerializer, elementValueSerializer);\n-                }\n-            } else {\n-                // Only custom variants for this:\n-                for (Serializers serializers : customSerializers()) {\n-                    JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config,\n-                            (CollectionLikeType) type, beanDesc, elementTypeSerializer, elementValueSerializer);\n-                    if (ser != null) {\n-                        return ser;\n-                    }\n-                }\n-                // fall through either way (whether shape dictates serialization as POJO or not)\n-                return null;\n-            }\n+            }\n+            // fall through either way (whether shape dictates serialization as POJO or not)\n+            return null;\n         }\n         if (type.isArrayType()) {\n             return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n         throws JsonMappingException\n     {\n-        Class<?> raw = type.getRawClass();\n-        if (EnumSet.class.isAssignableFrom(raw)) {\n-            // this may or may not be available (Class doesn't; type of field/method does)\n-            JavaType enumType = type.getContentType();\n-            // and even if nominally there is something, only use if it really is enum\n-            if (!enumType.isEnumType()) {\n-                enumType = null;\n-            }\n-            return StdContainerSerializers.enumSetSerializer(enumType);\n-        }\n-        Class<?> elementRaw = type.getContentType().getRawClass();\n-        if (isIndexedList(raw)) {\n-            if (elementRaw == String.class) {\n-                // [JACKSON-829] Must NOT use if we have custom serializer\n-                if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n-                    return IndexedStringListSerializer.instance;\n+        JsonSerializer<?> ser = null;\n+        // Module-provided custom collection serializers?\n+        for (Serializers serializers : customSerializers()) {\n+            ser = serializers.findCollectionSerializer(config,\n+                    type, beanDesc, elementTypeSerializer, elementValueSerializer);\n+            if (ser != null) {\n+                break;\n+            }\n+        }\n+\n+        // As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n+        // Challenge here is that EnumSerializer does not know how to produce\n+        // POJO style serialization, so we must handle that special case separately;\n+        // otherwise pass it to EnumSerializer.\n+        if (ser == null) {\n+            JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n+            if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n+                return null;\n+            }\n+            Class<?> raw = type.getRawClass();\n+            if (EnumSet.class.isAssignableFrom(raw)) {\n+                // this may or may not be available (Class doesn't; type of field/method does)\n+                JavaType enumType = type.getContentType();\n+                // and even if nominally there is something, only use if it really is enum\n+                if (!enumType.isEnumType()) {\n+                    enumType = null;\n                 }\n-            }\n-            return StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping,\n-                    elementTypeSerializer, elementValueSerializer);\n-        }\n-        if (elementRaw == String.class) {\n-            // [JACKSON-829] Must NOT use if we have custom serializer\n-            if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n-                return StringCollectionSerializer.instance;\n-            }\n-        }\n-        return StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping,\n-                elementTypeSerializer, elementValueSerializer);\n+                ser = StdContainerSerializers.enumSetSerializer(enumType);\n+            } else {\n+                Class<?> elementRaw = type.getContentType().getRawClass();\n+                if (isIndexedList(raw)) {\n+                    if (elementRaw == String.class) {\n+                        // [JACKSON-829] Must NOT use if we have custom serializer\n+                        if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n+                            ser = IndexedStringListSerializer.instance;\n+                        }\n+                    } else {\n+                        ser = StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping,\n+                            elementTypeSerializer, elementValueSerializer);\n+                    }\n+                } else if (elementRaw == String.class) {\n+                    // [JACKSON-829] Must NOT use if we have custom serializer\n+                    if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n+                        ser = StringCollectionSerializer.instance;\n+                    }\n+                }\n+                if (ser == null) {\n+                    ser = StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping,\n+                            elementTypeSerializer, elementValueSerializer);\n+                }\n+            }\n+        }\n+        // [Issue#120]: Allow post-processing\n+        if (_factoryConfig.hasSerializerModifiers()) {\n+            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                ser = mod.modifyCollectionSerializer(config, type, beanDesc, ser);\n+            }\n+        }\n+        return ser;\n     }\n     \n     protected boolean isIndexedList(Class<?> cls)\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n         throws JsonMappingException\n     {\n+        JsonSerializer<?> ser = null;\n         for (Serializers serializers : customSerializers()) {\n-            JsonSerializer<?> ser = serializers.findMapSerializer(config, type, beanDesc,\n+            ser = serializers.findMapSerializer(config, type, beanDesc,\n                     keySerializer, elementTypeSerializer, elementValueSerializer);\n             if (ser != null) {\n-                return ser;\n-            }\n-        }\n-        if (EnumMap.class.isAssignableFrom(type.getRawClass())) {\n-            JavaType keyType = type.getKeyType();\n-            // Need to find key enum values...\n-            EnumValues enums = null;\n-            if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance)\n-                @SuppressWarnings(\"unchecked\")\n-                Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();\n-                enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector());\n-            }\n-            return new EnumMapSerializer(type.getContentType(), staticTyping, enums,\n-                elementTypeSerializer, elementValueSerializer);\n-        }\n-        return MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()),\n-                type, staticTyping, elementTypeSerializer,\n-                keySerializer, elementValueSerializer);\n+                break;\n+            }\n+        }\n+        if (ser == null) {\n+            if (EnumMap.class.isAssignableFrom(type.getRawClass())) {\n+                JavaType keyType = type.getKeyType();\n+                // Need to find key enum values...\n+                EnumValues enums = null;\n+                if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance)\n+                    @SuppressWarnings(\"unchecked\")\n+                    Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();\n+                    enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector());\n+                }\n+                ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums,\n+                    elementTypeSerializer, elementValueSerializer);\n+            } else {\n+                ser = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()),\n+                    type, staticTyping, elementTypeSerializer,\n+                    keySerializer, elementValueSerializer);\n+            }\n+        }\n+        // [Issue#120]: Allow post-processing\n+        if (_factoryConfig.hasSerializerModifiers()) {\n+            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                ser = mod.modifyMapSerializer(config, type, beanDesc, ser);\n+            }\n+        }\n+        return ser;\n     }\n \n     /*\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n         throws JsonMappingException\n     {\n+        JsonSerializer<?> ser = null;        \n          // Module-provided custom collection serializers?\n          for (Serializers serializers : customSerializers()) {\n-             JsonSerializer<?> ser = serializers.findArraySerializer(config,\n+             ser = serializers.findArraySerializer(config,\n                      type, beanDesc, elementTypeSerializer, elementValueSerializer);\n              if (ser != null) {\n-                 return ser;\n+                 break;\n              }\n          }\n-        Class<?> raw = type.getRawClass();\n-        // Important: do NOT use standard serializers if non-standard element value serializer specified\n-        if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n-            if (String[].class == raw) {\n-                return StringArraySerializer.instance;\n-            }\n-            // other standard types?\n-            JsonSerializer<?> ser = StdArraySerializers.findStandardImpl(raw);\n-            if (ser != null) {\n-                return ser;\n-            }\n-        }\n-        return new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n-                elementValueSerializer);\n+         if (ser == null) {\n+             Class<?> raw = type.getRawClass();\n+             // Important: do NOT use standard serializers if non-standard element value serializer specified\n+             if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n+                 if (String[].class == raw) {\n+                     ser = StringArraySerializer.instance;\n+                 } else {\n+                     // other standard types?\n+                     ser = StdArraySerializers.findStandardImpl(raw);\n+                 }\n+             }\n+             if (ser == null) {\n+                 ser = new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n+                         elementValueSerializer);\n+             }\n+         }\n+         // [Issue#120]: Allow post-processing\n+         if (_factoryConfig.hasSerializerModifiers()) {\n+             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                 ser = mod.modifyArraySerializer(config, type, beanDesc, ser);\n+             }\n+         }\n+         return ser;\n     }\n \n     /*\n                 usesStaticTyping(config, beanDesc, vts), vts);\n     }\n     \n+    protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config,\n+            JavaType type, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        /* As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n+         * Challenge here is that EnumSerializer does not know how to produce\n+         * POJO style serialization, so we must handle that special case separately;\n+         * otherwise pass it to EnumSerializer.\n+         */\n+        JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n+        if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n+            // one special case: suppress serialization of \"getDeclaringClass()\"...\n+            ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\");\n+            // returning null will mean that eventually BeanSerializer gets constructed\n+            return null;\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        Class<Enum<?>> enumClass = (Class<Enum<?>>) type.getRawClass();\n+        JsonSerializer<?> ser = EnumSerializer.construct(enumClass, config, beanDesc, format);\n+        // [Issue#120]: Allow post-processing\n+        if (_factoryConfig.hasSerializerModifiers()) {\n+            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                ser = mod.modifyEnumSerializer(config, type, beanDesc, ser);\n+            }\n+        }\n+        return ser;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Other helper methods\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerModifier.java\n \n import java.util.List;\n \n-import com.fasterxml.jackson.databind.BeanDescription;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.DeserializerFactory;\n+import com.fasterxml.jackson.databind.type.*;\n \n /**\n  * Abstract class that defines API for objects that can be registered (for {@link BeanSerializerFactory}\n      * to use. Note that although initial serializer being passed is of type\n      * {@link BeanSerializer}, modifiers may return serializers of other types;\n      * and this is why implementations must check for type before casting.\n+     *<p>\n+     * NOTE: since 2.2, gets called for serializer of those non-POJO types that\n+     * do not go through any of more specific <code>modifyXxxSerializer</code>\n+     * methods; mostly for JDK types like {@link java.util.Iterator} and such.\n      */\n     public JsonSerializer<?> modifySerializer(SerializationConfig config,\n             BeanDescription beanDesc, JsonSerializer<?> serializer) {\n         return serializer;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Callback methods for other types (since 2.2)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called by {@link DeserializerFactory} after it has constructed the\n+     * standard serializer for given\n+     * {@link ArrayType}\n+     * to make it possible to either replace or augment this serializer with\n+     * additional functionality.\n+     * \n+     * @param config Configuration in use\n+     * @param valueType Type of the value serializer is used for.\n+     * @param beanDesc Description f\n+     * @param serializer Default serializer that would be used.\n+     * \n+     * @return Serializer to use; either <code>serializer</code> that was passed\n+     *   in, or an instance method constructed.\n+     * \n+     * @since 2.2\n+     */\n+    public JsonSerializer<?> modifyArraySerializer(SerializationConfig config,\n+            ArrayType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+        return serializer;\n+    }\n+\n+    public JsonSerializer<?> modifyCollectionSerializer(SerializationConfig config,\n+            CollectionType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+        return serializer;\n+    }\n+\n+    public JsonSerializer<?> modifyCollectionLikeSerializer(SerializationConfig config,\n+            CollectionLikeType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+        return serializer;\n+    }\n+    \n+    public JsonSerializer<?> modifyMapSerializer(SerializationConfig config,\n+            MapType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+        return serializer;\n+    }\n+\n+    public JsonSerializer<?> modifyMapLikeSerializer(SerializationConfig config,\n+            MapLikeType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+        return serializer;\n+    }\n+\n+    public JsonSerializer<?> modifyEnumSerializer(SerializationConfig config,\n+            JavaType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+        return serializer;\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n             context.addBeanDeserializerModifier(new Issue476DeserializerModifier());\n         }        \n     }\n-\n     \n     // [Issue#121], arrays, collections, maps\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n import com.fasterxml.jackson.databind.ser.BeanSerializer;\n import com.fasterxml.jackson.databind.ser.BeanSerializerBuilder;\n import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.fasterxml.jackson.databind.type.ArrayType;\n+import com.fasterxml.jackson.databind.type.CollectionType;\n+import com.fasterxml.jackson.databind.type.MapType;\n \n /**\n  * Unit tests for verifying that it is possible to configure\n         public int getX() { return 3; }\n         public boolean isX() { return false; }\n     }\n+\n+    // [Issue#120], arrays, collections, maps\n+    \n+    static class ArraySerializerModifier extends BeanSerializerModifier {\n+        @Override\n+        public JsonSerializer<?> modifyArraySerializer(SerializationConfig config,\n+                ArrayType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+            return new StdSerializer<Object>(Object.class) {\n+                @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+                    jgen.writeNumber(123);\n+                }\n+            };\n+        }\n+    }\n+\n+    static class CollectionSerializerModifier extends BeanSerializerModifier {\n+        @Override\n+        public JsonSerializer<?> modifyCollectionSerializer(SerializationConfig config,\n+                CollectionType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+            return new StdSerializer<Object>(Object.class) {\n+                @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+                    jgen.writeNumber(123);\n+                }\n+            };\n+        }\n+    }\n+\n+    static class MapSerializerModifier extends BeanSerializerModifier {\n+        @Override\n+        public JsonSerializer<?> modifyMapSerializer(SerializationConfig config,\n+                MapType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+            return new StdSerializer<Object>(Object.class) {\n+                @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+                    jgen.writeNumber(123);\n+                }\n+            };\n+        }\n+    }\n+\n+    static class EnumSerializerModifier extends BeanSerializerModifier {\n+        @Override\n+        public JsonSerializer<?> modifyEnumSerializer(SerializationConfig config,\n+                JavaType valueType, BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+            return new StdSerializer<Object>(Object.class) {\n+                @Override public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+                    jgen.writeNumber(123);\n+                }\n+            };\n+        }\n+    }\n+    \n+    enum EnumABC { A, B, C };\n     \n     /*\n     /********************************************************\n         assertEquals(\"{\\\"bogus\\\":\\\"foo\\\"}\", json);\n     }\n \n+    // [Issue#121]\n+\n+    public void testModifyArraySerializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new SimpleModule(\"test\")\n+            .setSerializerModifier(new ArraySerializerModifier()));\n+        assertEquals(\"123\", mapper.writeValueAsString(new Integer[] { 1, 2 }));\n+    }\n+\n+    public void testModifyCollectionSerializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new SimpleModule(\"test\")\n+            .setSerializerModifier(new CollectionSerializerModifier()));\n+        assertEquals(\"123\", mapper.writeValueAsString(new ArrayList<Integer>()));\n+    }\n+\n+    public void testModifyMapSerializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new SimpleModule(\"test\")\n+            .setSerializerModifier(new MapSerializerModifier()));\n+        assertEquals(\"123\", mapper.writeValueAsString(new HashMap<String,String>()));\n+    }\n+\n+    public void testModifyEnumSerializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new SimpleModule(\"test\")\n+            .setSerializerModifier(new EnumSerializerModifier()));\n+        assertEquals(\"123\", mapper.writeValueAsString(EnumABC.C));\n+    }\n+\n+    public void testModifyKeySerializer() throws Exception\n+    {\n+    }\n+    \n     /*\n     /********************************************************\n     /* Unit tests: failure handling", "timestamp": 1354340943, "metainfo": ""}