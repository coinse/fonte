{"sha": "5ee65912c33cab6d185dd5460d1ce801ca106135", "log": "Complete #655 implementation (add `ObjectWriter.writeValues()`)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n import com.fasterxml.jackson.core.util.*;\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.*;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n      */\n \n     /**\n-     * Specified root serialization type to use; can be same\n-     * as runtime type, but usually one of its super types\n-     */\n-    protected final JavaType _rootType;\n+     * Container for settings that need to be passed to {@link JsonGenerator}\n+     * constructed for serializing values.\n+     *\n+     * @since 2.5\n+     */\n+    protected final GeneratorSettings _generatorSettings;\n \n     /**\n      * We may pre-fetch serializer if {@link #_rootType}\n      * is known, and if so, reuse it afterwards.\n      * This allows avoiding further serializer lookups and increases\n      * performance a bit on cases where readers are reused.\n-     * \n-     * @since 2.1\n-     */\n-    protected final JsonSerializer<Object> _rootSerializer;\n-\n-    /**\n-     * Container for settings that need to be passed to {@link JsonGenerator}\n-     * constructed for serializing values.\n-     *\n-     * @since 2.5\n-     */\n-    protected final GeneratorSettings _generatorSettings;\n-\n+     *\n+     * @since 2.5\n+     */\n+    protected final Prefetch _prefetch;\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle, constructors\n \n         // 29-Apr-2014, tatu: There is no \"untyped serializer\", so:\n         if (rootType == null || rootType.hasRawClass(Object.class)) {\n-            _rootType = null;\n-            _rootSerializer = null;\n+            _prefetch = Prefetch.empty;\n         } else {\n-            _rootType = rootType.withStaticTyping();\n-            _rootSerializer = _prefetchRootSerializer(config, _rootType);\n+            rootType = rootType.withStaticTyping();\n+            _prefetch = _prefetchRootSerializer(config, rootType);\n         }\n     }\n \n         _serializerFactory = mapper._serializerFactory;\n         _generatorFactory = mapper._jsonFactory;\n \n-        _rootType = null;\n-        _rootSerializer = null;\n+        _prefetch = Prefetch.empty;\n         _generatorSettings = GeneratorSettings.empty;\n     }\n \n         _serializerFactory = mapper._serializerFactory;\n         _generatorFactory = mapper._jsonFactory;\n \n-        _rootType = null;\n-        _rootSerializer = null;\n+        _prefetch = Prefetch.empty;\n         _generatorSettings = (s == null) ? GeneratorSettings.empty\n                 : new GeneratorSettings(null, s, null);\n     }\n      * Copy constructor used for building variations.\n      */\n     protected ObjectWriter(ObjectWriter base, SerializationConfig config,\n-            JavaType rootType, JsonSerializer<Object> rootSer,\n-            GeneratorSettings genSettings)\n+            GeneratorSettings genSettings, Prefetch prefetch)\n     {\n         _config = config;\n \n         _serializerFactory = base._serializerFactory;\n         _generatorFactory = base._generatorFactory;\n \n-        _rootType = rootType;\n-        _rootSerializer = rootSer;\n         _generatorSettings = genSettings;\n+        _prefetch = prefetch;\n     }\n \n     /**\n         _serializerFactory = base._serializerFactory;\n         _generatorFactory = base._generatorFactory;\n         _generatorSettings = base._generatorSettings;\n-\n-        _rootType = base._rootType;\n-        _rootSerializer = base._rootSerializer;\n+        _prefetch = base._prefetch;\n     }\n \n     /**\n         _serializerFactory = base._serializerFactory;\n         _generatorFactory = base._generatorFactory;\n         _generatorSettings = base._generatorSettings;\n-\n-        _rootType = base._rootType;\n-        _rootSerializer = base._rootSerializer;\n+        _prefetch = base._prefetch;\n     }\n \n     /**\n      * \n      * @since 2.5\n      */\n-    protected ObjectWriter _new(JavaType rootType, JsonSerializer<Object> rootSer,\n-            GeneratorSettings genSettings) {\n-        return new ObjectWriter(this, _config, rootType, rootSer, genSettings);\n+    protected ObjectWriter _new(GeneratorSettings genSettings, Prefetch prefetch) {\n+        return new ObjectWriter(this, _config, genSettings, prefetch);\n     }\n \n     /**\n         throws IOException\n     {\n         return new SequenceWriter(_serializerProvider(_config),\n-                _configureGenerator(gen), managedInput, _rootType, _rootSerializer)\n+                _configureGenerator(gen), managedInput, _prefetch)\n             .init(wrapInArray);\n     }\n \n         if (genSet == _generatorSettings) {\n             return this;\n         }\n-        return _new(_rootType, _rootSerializer, genSet);\n+        return _new(genSet, _prefetch);\n     }\n \n     /**\n             return this;\n         }\n         _verifySchemaType(schema);\n-        return _new(_rootType, _rootSerializer, genSet);\n+        return _new(genSet, _prefetch);\n     }\n \n     /**\n      */\n     public ObjectWriter forType(JavaType rootType)\n     {\n-        JsonSerializer<Object> rootSer;\n+        Prefetch pf;\n         if (rootType == null || rootType.hasRawClass(Object.class)) {\n-            rootType = null;\n-            rootSer = null;\n+            pf = Prefetch.empty;\n         } else {\n             // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n             rootType = rootType.withStaticTyping();\n-            rootSer = _prefetchRootSerializer(_config, rootType);\n-        }\n-        return _new(rootType, rootSer, _generatorSettings);\n+            pf = _prefetchRootSerializer(_config, rootType);\n+        }\n+        return (pf == _prefetch) ? this : _new(_generatorSettings, pf);\n     }    \n \n     /**\n         if (genSet == _generatorSettings) {\n             return this;\n         }\n-        return _new(_rootType, _rootSerializer, genSet);\n+        return _new(genSet, _prefetch);\n     }\n \n     /**\n      * @since 2.2\n      */\n     public boolean hasPrefetchedSerializer() {\n-        return _rootSerializer != null;\n+        return _prefetch.hasSerializer();\n     }\n \n     /**\n                 && (value instanceof Closeable)) {\n             _writeCloseableValue(gen, value, _config);\n         } else {\n-            if (_rootType == null) {\n+            if (_prefetch.valueSerializer != null) {\n+                _serializerProvider(_config).serializeValue(gen, value, _prefetch.rootType,\n+                        _prefetch.valueSerializer);\n+            } else if (_prefetch.typeSerializer != null) {\n+                _serializerProvider(_config).serializePolymorphic(gen, value, _prefetch.typeSerializer);\n+            } else {\n                 _serializerProvider(_config).serializeValue(gen, value);\n-            } else {\n-                _serializerProvider(_config).serializeValue(gen, value, _rootType, _rootSerializer);\n             }\n             if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 gen.flush();\n         }\n         boolean closed = false;\n         try {\n-            if (_rootType == null) {\n+            if (_prefetch.valueSerializer != null) {\n+                _serializerProvider(_config).serializeValue(gen, value, _prefetch.rootType,\n+                        _prefetch.valueSerializer);\n+            } else if (_prefetch.typeSerializer != null) {\n+                _serializerProvider(_config).serializePolymorphic(gen, value, _prefetch.typeSerializer);\n+            } else {\n                 _serializerProvider(_config).serializeValue(gen, value);\n-            } else {\n-                _serializerProvider(_config).serializeValue(gen, value, _rootType, _rootSerializer);\n             }\n             closed = true;\n             gen.close();\n     {\n         Closeable toClose = (Closeable) value;\n         try {\n-            if (_rootType == null) {\n+            if (_prefetch.valueSerializer != null) {\n+                _serializerProvider(cfg).serializeValue(gen, value, _prefetch.rootType,\n+                        _prefetch.valueSerializer);\n+            } else if (_prefetch.typeSerializer != null) {\n+                _serializerProvider(cfg).serializePolymorphic(gen, value, _prefetch.typeSerializer);\n+            } else {\n                 _serializerProvider(cfg).serializeValue(gen, value);\n-            } else {\n-                _serializerProvider(cfg).serializeValue(gen, value, _rootType, _rootSerializer);\n             }\n             JsonGenerator tmpGen = gen;\n             gen = null;\n     {\n         Closeable toClose = (Closeable) value;\n         try {\n-            if (_rootType == null) {\n+            if (_prefetch.valueSerializer != null) {\n+                _serializerProvider(cfg).serializeValue(gen, value, _prefetch.rootType,\n+                        _prefetch.valueSerializer);\n+            } else if (_prefetch.typeSerializer != null) {\n+                _serializerProvider(cfg).serializePolymorphic(gen, value, _prefetch.typeSerializer);\n+            } else {\n                 _serializerProvider(cfg).serializeValue(gen, value);\n-            } else {\n-                _serializerProvider(cfg).serializeValue(gen, value, _rootType, _rootSerializer);\n             }\n             if (_config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE)) {\n                 gen.flush();\n      * by configuration. Method also is NOT to throw an exception if\n      * access fails.\n      */\n-    protected JsonSerializer<Object> _prefetchRootSerializer(\n-            SerializationConfig config, JavaType valueType)\n-    {\n-        if (valueType == null || !_config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)) {\n-            return null;\n-        }\n-        try {\n-            return _serializerProvider(config).findTypedValueSerializer(valueType, true, null);\n-        } catch (JsonProcessingException e) {\n-            // need to swallow?\n-            return null;\n-        }\n+    protected Prefetch _prefetchRootSerializer(SerializationConfig config, JavaType valueType)\n+    {\n+        if (valueType != null && _config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)) {\n+            try {\n+                TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType);\n+                // Polymorphic type? If so, can only do partial resolution\n+                if (typeSer != null) {\n+                    return Prefetch.construct(valueType, typeSer);\n+                }\n+                JsonSerializer<Object> ser = _serializerProvider(config).findValueSerializer(valueType,  null);\n+                return Prefetch.construct(valueType,  ser);\n+            } catch (JsonProcessingException e) {\n+                // need to swallow?\n+                ;\n+            }\n+        }\n+        return Prefetch.empty;\n     }\n     \n     /**\n                     : new GeneratorSettings(prettyPrinter, schema, esc);\n         }\n     }\n+\n+    /**\n+     * As a minor optimization, we will make an effort to pre-fetch a serializer,\n+     * or at least relevant <code>TypeSerializer</code>, if given enough\n+     * information.\n+     * \n+     * @since 2.5\n+     */\n+    public final static class Prefetch\n+        implements java.io.Serializable\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        public final static Prefetch empty = new Prefetch(null, null, null);\n+        \n+        /**\n+         * Specified root serialization type to use; can be same\n+         * as runtime type, but usually one of its super types\n+         */\n+        public final JavaType rootType;\n+\n+        /**\n+         * We may pre-fetch serializer if {@link #rootType}\n+         * is known, and if so, reuse it afterwards.\n+         * This allows avoiding further serializer lookups and increases\n+         * performance a bit on cases where readers are reused.\n+         */\n+        public final JsonSerializer<Object> valueSerializer;\n+\n+        /**\n+         * When dealing with polymorphic types, we can not pre-fetch\n+         * serializer, but we can pre-fetch {@link TypeSerializer}.\n+         */\n+        public final TypeSerializer typeSerializer;\n+        \n+        private Prefetch(JavaType type, JsonSerializer<Object> ser, TypeSerializer typeSer)\n+        {\n+            rootType = type;\n+            valueSerializer = ser;\n+            typeSerializer = typeSer;\n+        }\n+\n+        public static Prefetch construct(JavaType type, JsonSerializer<Object> ser) {\n+            if (type == null && ser == null) {\n+                return empty;\n+            }\n+            return new Prefetch(type, ser, null);\n+        }\n+        \n+        public static Prefetch construct(JavaType type, TypeSerializer typeSer) {\n+            if (type == null && typeSer == null) {\n+                return empty;\n+            }\n+            return new Prefetch(type, null, typeSer);\n+        }\n+\n+        public boolean hasSerializer() {\n+            return (valueSerializer != null) || (typeSerializer != null);\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/SequenceWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SequenceWriter.java\n import java.util.Collection;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+import com.fasterxml.jackson.databind.ser.impl.TypeWrappedSerializer;\n \n /**\n  * Writer class similar to {@link ObjectWriter}, except that it can be used\n     protected final SerializationConfig _config;\n     protected final JsonGenerator _generator;\n \n-    protected final JavaType _rootType;\n     protected final JsonSerializer<Object> _rootSerializer;\n+    protected final TypeSerializer _typeSerializer;\n     \n     protected final boolean _closeGenerator;\n     protected final boolean _cfgFlush;\n      */\n \n     public SequenceWriter(DefaultSerializerProvider prov, JsonGenerator gen,\n-            boolean closeGenerator, JavaType rootType, JsonSerializer<Object> rootSerializer)\n-                    throws IOException\n+            boolean closeGenerator, ObjectWriter.Prefetch prefetch)\n+        throws IOException\n     {\n         _provider = prov;\n         _generator = gen;\n         _closeGenerator = closeGenerator;\n-        _rootType = rootType;\n-        _rootSerializer = rootSerializer;\n+        _rootSerializer = prefetch.valueSerializer;\n+        _typeSerializer = prefetch.typeSerializer;\n+\n         _config = prov.getConfig();\n         _cfgFlush = _config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE);\n         _cfgCloseCloseable = _config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE);\n                 ser = _findAndAddDynamic(type);\n             }\n         }\n-        _provider.serializeValue(_generator, value, _rootType, ser);\n+        _provider.serializeValue(_generator, value, null, ser);\n         if (_cfgFlush) {\n             _generator.flush();\n         }\n                 if (ser == null) {\n                     ser = _findAndAddDynamic(type);\n                 }\n-                _provider.serializeValue(_generator, value, null, ser);\n-            }\n-            _provider.serializeValue(_generator, value, _rootType, ser);\n+            }\n+            _provider.serializeValue(_generator, value, null, ser);\n             if (_cfgFlush) {\n                 _generator.flush();\n             }\n         return this;\n     }\n \n-    protected final JsonSerializer<Object> _findAndAddDynamic(Class<?> type) throws JsonMappingException\n-    {\n-        PropertySerializerMap.SerializerAndMapResult result\n-            = _dynamicSerializers.findAndAddRootValueSerializer(type, _provider);\n+    private final JsonSerializer<Object> _findAndAddDynamic(Class<?> type) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result;\n+        if (_typeSerializer == null) {\n+            result = _dynamicSerializers.findAndAddRootValueSerializer(type, _provider);\n+        } else {\n+            result = _dynamicSerializers.addSerializer(type,\n+                    new TypeWrappedSerializer(_typeSerializer, _provider.findValueSerializer(type, null)));\n+        }\n         _dynamicSerializers = result.map;\n         return result.serializer;\n     }\n \n-    protected final JsonSerializer<Object> _findAndAddDynamic(JavaType type) throws JsonMappingException\n-    {\n-        PropertySerializerMap.SerializerAndMapResult result\n-            = _dynamicSerializers.findAndAddRootValueSerializer(type, _provider);\n+    private final JsonSerializer<Object> _findAndAddDynamic(JavaType type) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result;\n+        if (_typeSerializer == null) {\n+            result = _dynamicSerializers.findAndAddRootValueSerializer(type, _provider);\n+        } else {\n+            result = _dynamicSerializers.addSerializer(type,\n+                    new TypeWrappedSerializer(_typeSerializer, _provider.findValueSerializer(type, null)));\n+        }\n         _dynamicSerializers = result.map;\n         return result.serializer;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n     }\n \n     /**\n+     * Alternate serialization call used for polymorphic types, when {@link TypeSerializer}\n+     * is already known, but not actual value serializer.\n+     *\n+     * @since 2.5\n+     */\n+    public void serializePolymorphic(JsonGenerator gen, Object value, TypeSerializer typeSer)\n+            throws IOException\n+    {\n+        if (value == null) {\n+            _serializeNull(gen);\n+            return;\n+        }\n+        final Class<?> type = value.getClass();\n+        JsonSerializer<Object> ser = findValueSerializer(type, null);\n+\n+        final boolean wrap;\n+        String rootName = _config.getRootName();\n+        if (rootName == null) {\n+            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n+            if (wrap) {\n+                gen.writeStartObject();\n+                PropertyName pname = _rootNames.findRootName(type, _config);\n+                gen.writeFieldName(pname.simpleAsEncoded(_config));\n+            }\n+        } else if (rootName.length() == 0) {\n+            wrap = false;\n+        } else {\n+            wrap = true;\n+            gen.writeStartObject();\n+            gen.writeFieldName(rootName);\n+        }\n+        try {\n+            ser.serializeWithType(value, gen, this, typeSer);\n+            if (wrap) {\n+                gen.writeEndObject();\n+            }\n+        } catch (IOException ioe) { // no wrapping for IO (and derived)\n+            throw ioe;\n+        } catch (Exception e) { // but others do need to be, to get path etc\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+    }\n+    \n+    /**\n      * Helper method called when root value to serialize is null\n      * \n      * @since 2.3\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n         JsonSerializer<Object> serializer = provider.findTypedValueSerializer(type, false, null);\n         return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));\n     }\n-    \n+\n+    /**\n+     * Method that can be used to 'register' a serializer that caller has resolved\n+     * without help of this map.\n+     * \n+     * @since 2.5\n+     */\n+    public final SerializerAndMapResult addSerializer(Class<?> type, JsonSerializer<Object> serializer) {\n+        return new SerializerAndMapResult(serializer, newWith(type, serializer));\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public final SerializerAndMapResult addSerializer(JavaType type, JsonSerializer<Object> serializer) {\n+        return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));\n+    }\n+\n     public abstract PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer);\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/TypeWrappedSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/TypeWrappedSerializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n \n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n     }\n \n     @Override\n-    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonProcessingException\n-    {\n+    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         _serializer.serializeWithType(value, jgen, provider, _typeSerializer);\n     }\n \n     @Override\n     public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonProcessingException\n+            TypeSerializer typeSer) throws IOException\n     {\n         /* Is this an erroneous call? For now, let's assume it is not, and\n          * that type serializer is just overridden if so\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n      * For Strings, both null and Empty String qualify for emptiness.\n      */\n     @Override\n+    @Deprecated\n     public boolean isEmpty(String value) {\n+        return (value == null) || (value.length() == 0);\n+    }\n+\n+    @Override\n+    public boolean isEmpty(SerializerProvider prov, String value) {\n         return (value == null) || (value.length() == 0);\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestObjectWriter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestObjectWriter.java\n     {\n         ObjectWriter writer = MAPPER.writerFor(PolyBase.class);\n         String json = writer.writeValueAsString(new ImplA(3));\n-        assertEquals(aposToQuotes(\"{'type':'A':'value':3}\"), json);\n+        assertEquals(aposToQuotes(\"{'type':'A','value':3}\"), json);\n     }\n }", "timestamp": 1418798698, "metainfo": ""}