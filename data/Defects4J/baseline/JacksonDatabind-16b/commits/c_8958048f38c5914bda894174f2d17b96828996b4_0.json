{"sha": "8958048f38c5914bda894174f2d17b96828996b4", "log": "Implemented [JACKSON-437]; allow type id to be passed to POJO (via @JsonTypeInfo.visible=true)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n     /**********************************************************\n      */\n \n-    // @since 1.6\n     @Override        \n     public ReferenceProperty findReferenceType(AnnotatedMember member)\n     {\n         return _findTypeResolver(config, am, baseType);\n     }\n \n-    /**\n-     * Since 1.7, it is possible to use {@link JsonTypeInfo} from a property too.\n-     */\n     @Override\n     public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n             AnnotatedMember am, JavaType containerType)\n         JsonTypeResolver resAnn = ann.getAnnotation(JsonTypeResolver.class);\n         \n         if (resAnn != null) {\n-            /* 14-Aug-2010, tatu: not sure if this can ever happen normally, but unit\n-             *    tests were able to trigger this... so let's check:\n-             */\n             if (info == null) {\n                 return null;\n             }\n         if (defaultImpl != JsonTypeInfo.None.class) {\n             b = b.defaultImpl(defaultImpl);\n         }\n+        b = b.typeIdVisibility(info.visible());\n         return b;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java\n      * Accessor for currently configured default type; implementation\n      * class that may be used in case no valid type information is\n      * available during type resolution\n-     * \n-     * @since 1.9\n      */\n     public Class<?> getDefaultImpl();\n     \n      * is either not available, or can not be resolved.\n      */\n     public T defaultImpl(Class<?> defaultImpl);\n+\n+    /**\n+     * Method for specifying whether type id should be visible to\n+     * {@link com.fasterxml.jackson.databind.JsonDeserializer}s or not.\n+     * \n+     * @since 2.0\n+     */\n+    public T typeIdVisibility(boolean isVisible);\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonParserSequence;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n  * Type deserializer used with {@link As#WRAPPER_ARRAY}\n  * is done using a 2-element JSON Array where type id is the first\n  * element, and actual object data as second element.\n  * \n- * @author tatus\n+ * @author tatu\n  */\n public class AsArrayTypeDeserializer extends TypeDeserializerBase\n {\n     public AsArrayTypeDeserializer(JavaType bt, TypeIdResolver idRes, BeanProperty property,\n-            Class<?> defaultImpl)\n+            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n     {\n-        super(bt, idRes, property, defaultImpl);\n+        super(bt, idRes, property, typePropertyName, typeIdVisible, defaultImpl);\n     }\n     \n     @Override\n         throws IOException, JsonProcessingException\n     {\n         boolean hadStartArray = jp.isExpectedStartArrayToken();\n-        JsonDeserializer<Object> deser = _findDeserializer(ctxt, _locateTypeId(jp, ctxt));\n+        String typeId = _locateTypeId(jp, ctxt);\n+        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n+        // Minor complication: we may need to merge type id in?\n+        if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) {\n+            // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n+            TokenBuffer tb = new TokenBuffer(null);\n+            tb.writeStartObject(); // recreate START_OBJECT\n+            tb.writeFieldName(_typePropertyName);\n+            tb.writeString(typeId);\n+            jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n+            jp.nextToken();\n+        }\n         Object value = deser.deserialize(jp, ctxt);\n         // And then need the closing END_ARRAY\n         if (hadStartArray && jp.nextToken() != JsonToken.END_ARRAY) {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n  */\n public class AsExternalTypeDeserializer extends AsArrayTypeDeserializer\n {\n-    protected final String _typePropertyName;\n-    \n     public AsExternalTypeDeserializer(JavaType bt, TypeIdResolver idRes, BeanProperty property,\n-            Class<?> defaultImpl,\n-            String typePropName)\n+            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n     {\n-        super(bt, idRes, property, defaultImpl);\n-        _typePropertyName = typePropName;\n+        super(bt, idRes, property, typePropertyName, typeIdVisible, defaultImpl);\n     }\n \n     @Override\n     public As getTypeInclusion() {\n         return As.EXTERNAL_PROPERTY;\n     }\n-\n-    @Override\n-    public String getPropertyName() { return _typePropertyName; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeSerializer.java\n    protected final String _typePropertyName;\n \n    public AsExternalTypeSerializer(TypeIdResolver idRes, BeanProperty property,\n-           String propName)\n+          String propName)\n    {\n        super(idRes, property);\n        _typePropertyName = propName;\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n  */\n public class AsPropertyTypeDeserializer extends AsArrayTypeDeserializer\n {\n-    protected final String _typePropertyName;\n-    \n     public AsPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes, BeanProperty property,\n-            Class<?> defaultImpl,\n-            String typePropName)\n+            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n     {\n-        super(bt, idRes, property, defaultImpl);\n-        _typePropertyName = typePropName;\n+        super(bt, idRes, property, typePropertyName, typeIdVisible, defaultImpl);\n     }\n \n     @Override\n     public As getTypeInclusion() {\n         return As.PROPERTY;\n     }\n-\n-    @Override\n-    public String getPropertyName() { return _typePropertyName; }\n \n     /**\n      * This is the trickiest thing to handle, since property we are looking\n             String name = jp.getCurrentName();\n             jp.nextToken(); // to point to the value\n             if (_typePropertyName.equals(name)) { // gotcha!\n-                String typeId = jp.getText();\n-                JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n-               if (tb != null) { // need to put back skipped properties?\n-                    jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n-                }\n-                /* Must point to the next value; tb had no current, jp\n-                 * pointed to VALUE_STRING:\n-                 */\n-                jp.nextToken(); // to skip past String value\n-                // deserializer should take care of closing END_OBJECT as well\n-                return deser.deserialize(jp, ctxt);\n+                return _deserializeTypedForId(jp, ctxt, tb);\n             }\n             if (tb == null) {\n                 tb = new TokenBuffer(null);\n             tb.copyCurrentStructure(jp);\n         }\n         return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb);\n+    }\n+\n+    protected final Object _deserializeTypedForId(JsonParser jp, DeserializationContext ctxt,\n+            TokenBuffer tb)\n+        throws IOException, JsonProcessingException\n+    {\n+        String typeId = jp.getText();\n+        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n+        if (_typeIdVisible) { // need to merge id back in JSON input?\n+            if (tb == null) {\n+                tb = new TokenBuffer(null);\n+            }\n+            tb.writeFieldName(jp.getCurrentName());\n+            tb.writeString(typeId);\n+        }\n+        if (tb != null) { // need to put back skipped properties?\n+            jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n+        }\n+        // Must point to the next value; tb had no current, jp pointed to VALUE_STRING:\n+        jp.nextToken(); // to skip past String value\n+        // deserializer should take care of closing END_OBJECT as well\n+        return deser.deserialize(jp, ctxt);\n     }\n     \n     // off-lined to keep main method lean and mean...\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeSerializer.java\n  * uses a JSON Array wrapper (similar to how\n  * {@link As#WRAPPER_ARRAY} always works) as a fallback.\n  * \n- * @since 1.5\n  * @author tatus\n  */\n public class AsPropertyTypeSerializer\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonParserSequence;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n  * Type deserializer used with {@link As#WRAPPER_OBJECT}\n public class AsWrapperTypeDeserializer extends TypeDeserializerBase\n {\n     public AsWrapperTypeDeserializer(JavaType bt, TypeIdResolver idRes, BeanProperty property,\n-            Class<?> defaultImpl)\n+            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n     {\n-        super(bt, idRes, property, null);\n+        super(bt, idRes, property, typePropertyName, typeIdVisible, null);\n     }\n \n     @Override\n             throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n                     \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n         }\n-        JsonDeserializer<Object> deser = _findDeserializer(ctxt, jp.getText());\n+        final String typeId = jp.getText();\n+        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n         jp.nextToken();\n+\n+        // Minor complication: we may need to merge type id in?\n+        if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) {\n+            // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n+            TokenBuffer tb = new TokenBuffer(null);\n+            tb.writeStartObject(); // recreate START_OBJECT\n+            tb.writeFieldName(_typePropertyName);\n+            tb.writeString(typeId);\n+            jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n+            jp.nextToken();\n+        }\n+        \n         Object value = deser.deserialize(jp, ctxt);\n         // And then need the closing END_OBJECT\n         if (jp.nextToken() != JsonToken.END_OBJECT) {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java\n  * just use a wrapping array with type information as the first element\n  * and value as second.\n  * \n- * @since 1.5\n- * @author tatus\n+ * @author tatu\n  */\n public class AsWrapperTypeSerializer\n     extends TypeSerializerBase\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n     protected String _typeProperty;\n \n     /**\n+     * Whether type id should be exposed to deserializers or not\n+     */\n+    protected boolean _typeIdVisible = false;\n+    \n+    /**\n      * Default class to use in case type information is not available\n      * or is broken.\n      */\n     // Objects\n     \n     protected TypeIdResolver _customIdResolver;\n-\n-    /*\n-    /**********************************************************\n-    /* Accessors\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public Class<?> getDefaultImpl() {\n-        return _defaultImpl;\n-    }\n     \n     /*\n     /**********************************************************\n         case WRAPPER_ARRAY:\n             return new AsArrayTypeSerializer(idRes, property);\n         case PROPERTY:\n-            return new AsPropertyTypeSerializer(idRes, property, _typeProperty);\n+            return new AsPropertyTypeSerializer(idRes, property,\n+                    _typeProperty);\n         case WRAPPER_OBJECT:\n             return new AsWrapperTypeSerializer(idRes, property);\n         case EXTERNAL_PROPERTY:\n-            return new AsExternalTypeSerializer(idRes, property, _typeProperty);\n+            return new AsExternalTypeSerializer(idRes, property,\n+                    _typeProperty);\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n         // First, method for converting type info to type id:\n         switch (_includeAs) {\n         case WRAPPER_ARRAY:\n-            return new AsArrayTypeDeserializer(baseType, idRes, property, _defaultImpl);\n+            return new AsArrayTypeDeserializer(baseType, idRes, property,\n+                    _typeProperty, _typeIdVisible, _defaultImpl);\n         case PROPERTY:\n             return new AsPropertyTypeDeserializer(baseType, idRes, property,\n-                    _defaultImpl, _typeProperty);\n+                    _typeProperty, _typeIdVisible, _defaultImpl);\n         case WRAPPER_OBJECT:\n-            return new AsWrapperTypeDeserializer(baseType, idRes, property, _defaultImpl);\n+            return new AsWrapperTypeDeserializer(baseType, idRes, property,\n+                    _typeProperty, _typeIdVisible, _defaultImpl);\n         case EXTERNAL_PROPERTY:\n             return new AsExternalTypeDeserializer(baseType, idRes, property,\n-                    _defaultImpl, _typeProperty);\n+                    _typeProperty, _typeIdVisible, _defaultImpl);\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Construction, configuration\n         _defaultImpl = defaultImpl;\n         return this;\n     }\n+\n+    @Override\n+    public StdTypeResolverBuilder typeIdVisibility(boolean isVisible) {\n+        _typeIdVisible = isVisible;\n+        return this;\n+    }\n     \n     /*\n     /**********************************************************\n      */\n \n     public String getTypeProperty() { return _typeProperty; }\n+\n+    @Override\n+    public Class<?> getDefaultImpl() {\n+        return _defaultImpl;\n+    }\n+\n+    public boolean isTypeIdVisible() { return _typeIdVisible; }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n      * missing or can not be resolved.\n      */\n     protected final JavaType _defaultImpl;\n+\n+    /**\n+     * Name of type property used; needed for non-property versions too,\n+     * in cases where type id is to be exposed as part of JSON.\n+     */\n+    protected final String _typePropertyName;\n+    \n+    protected final boolean _typeIdVisible;\n     \n     /**\n      * For efficient operation we will lazily build mappings from type ids\n     protected JsonDeserializer<Object> _defaultImplDeserializer;\n \n     protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, BeanProperty property,\n-            Class<?> defaultImpl)\n+            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n     {\n         _baseType = baseType;\n         _idResolver = idRes;\n         _property = property;\n+        _typePropertyName = typePropertyName;\n+        _typeIdVisible = typeIdVisible;\n         _deserializers = new HashMap<String,JsonDeserializer<Object>>();\n         if (defaultImpl == null) {\n             _defaultImpl = null;\n     public String baseTypeName() { return _baseType.getRawClass().getName(); }\n \n     @Override\n-    public String getPropertyName() { return null; }\n+    public final String getPropertyName() { return _typePropertyName; }\n     \n     @Override    \n     public TypeIdResolver getTypeIdResolver() { return _idResolver; }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestVisibleTypeId.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Tests to verify [JACKSON-437]\n+ */\n+public class TestVisibleTypeId extends BaseMapTest\n+{\n+    // type id as property, exposed\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY,\n+            property=\"type\", visible=true)\n+    @JsonTypeName(\"BaseType\")\n+    static class PropertyBean {\n+        public int a = 3;\n+\n+        protected String type;\n+\n+        public void setType(String t) { type = t; }\n+    }\n+\n+    // as wrapper-array\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.WRAPPER_ARRAY,\n+            property=\"type\", visible=true)\n+    @JsonTypeName(\"ArrayType\")\n+    static class WrapperArrayBean {\n+        public int a = 1;\n+\n+        protected String type;\n+\n+        public void setType(String t) { type = t; }\n+    }\n+\n+    // as wrapper-object\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.WRAPPER_OBJECT,\n+            property=\"type\", visible=true)\n+    @JsonTypeName(\"ObjectType\")\n+    static class WrapperObjectBean {\n+        public int a = 2;\n+\n+        protected String type;\n+\n+        public void setType(String t) { type = t; }\n+    }\n+\n+    // as external id, bit trickier\n+    static class ExternalIdWrapper {\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+                property=\"type\", visible=true)\n+        public ExternalIdBean bean = new ExternalIdBean();\n+    }\n+    \n+    @JsonTypeName(\"ExternalType\")\n+    static class ExternalIdBean {\n+        public int a = 2;\n+\n+        protected String type;\n+\n+        public void setType(String t) { type = t; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper mapper = new ObjectMapper();\n+    \n+    public void testVisibleWithProperty() throws Exception\n+    {\n+        String json = mapper.writeValueAsString(new PropertyBean());\n+        // just default behavior:\n+        assertEquals(\"{\\\"type\\\":\\\"BaseType\\\",\\\"a\\\":3}\", json);\n+        // but then expect to read it back\n+        PropertyBean result = mapper.readValue(json, PropertyBean.class);\n+        assertEquals(\"BaseType\", result.type);\n+\n+        // also, should work with order reversed\n+        result = mapper.readValue(\"{\\\"a\\\":7, \\\"type\\\":\\\"BaseType\\\"}\", PropertyBean.class);\n+        assertEquals(7, result.a);\n+        assertEquals(\"BaseType\", result.type);\n+    }\n+\n+    public void testVisibleWithWrapperArray() throws Exception\n+    {\n+        String json = mapper.writeValueAsString(new WrapperArrayBean());\n+        // just default behavior:\n+        assertEquals(\"[\\\"ArrayType\\\",{\\\"a\\\":1}]\", json);\n+        // but then expect to read it back\n+        WrapperArrayBean result = mapper.readValue(json, WrapperArrayBean.class);\n+        assertEquals(\"ArrayType\", result.type);\n+        assertEquals(1, result.a);\n+    }\n+\n+    public void testVisibleWithWrapperObject() throws Exception\n+    {\n+        String json = mapper.writeValueAsString(new WrapperObjectBean());\n+        assertEquals(\"{\\\"ObjectType\\\":{\\\"a\\\":2}}\", json);\n+        // but then expect to read it back\n+        WrapperObjectBean result = mapper.readValue(json, WrapperObjectBean.class);\n+        assertEquals(\"ObjectType\", result.type);\n+    }\n+\n+    public void testVisibleWithExternalId() throws Exception\n+    {\n+        String json = mapper.writeValueAsString(new ExternalIdWrapper());\n+        // but then expect to read it back\n+        ExternalIdWrapper result = mapper.readValue(json, ExternalIdWrapper.class);\n+        assertEquals(\"ExternalType\", result.bean.type);\n+        assertEquals(2, result.bean.a);\n+    }\n+}", "timestamp": 1327126136, "metainfo": ""}