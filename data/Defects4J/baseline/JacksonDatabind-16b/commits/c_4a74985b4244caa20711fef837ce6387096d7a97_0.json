{"sha": "4a74985b4244caa20711fef837ce6387096d7a97", "log": "bit more pruning; combining 10 key deserializers into one", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/KeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/KeyDeserializers.java\n  */\n public interface KeyDeserializers\n {\n-    public KeyDeserializer findKeyDeserializer(JavaType type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException;\n+    public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n import java.io.IOException;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Method;\n+import java.util.Calendar;\n+import java.util.Date;\n import java.util.Locale;\n import java.util.UUID;\n \n /**\n  * Base class for simple key deserializers.\n  */\n-public abstract class StdKeyDeserializer\n-    extends KeyDeserializer\n+@JacksonStdImpl\n+public class StdKeyDeserializer extends KeyDeserializer\n     implements java.io.Serializable\n {\n     private static final long serialVersionUID = 1L;\n \n+    public final static int TYPE_BOOLEAN = 1;\n+    public final static int TYPE_BYTE = 2;\n+    public final static int TYPE_SHORT = 3;\n+    public final static int TYPE_CHAR = 4;\n+    public final static int TYPE_INT = 5;\n+    public final static int TYPE_LONG = 6;\n+    public final static int TYPE_FLOAT = 7;\n+    public final static int TYPE_DOUBLE = 8;\n+    public final static int TYPE_LOCALE = 9;\n+    public final static int TYPE_DATE = 10;\n+    public final static int TYPE_CALENDAR = 11;\n+    public final static int TYPE_UUID = 12;\n+\n+    final protected int _kind;\n     final protected Class<?> _keyClass;\n \n-    protected StdKeyDeserializer(Class<?> cls) { _keyClass = cls; }\n-\n+    /**\n+     * Some types that are deserialized using a helper deserializer.\n+     */\n+    protected final FromStringDeserializer<?> _deser;\n+    \n+    protected StdKeyDeserializer(int kind, Class<?> cls) {\n+        this(kind, cls, null);\n+    }\n+\n+    protected StdKeyDeserializer(int kind, Class<?> cls, FromStringDeserializer<?> deser) {\n+        _kind = kind;\n+        _keyClass = cls;\n+        _deser = deser;\n+    }\n+\n+    public static StdKeyDeserializer forType(Class<?> raw)\n+    {\n+        int kind;\n+        FromStringDeserializer<?> deser = null;\n+\n+        // first common types:\n+        if (raw == UUID.class) {\n+            kind = TYPE_UUID;\n+        } else if (raw == Integer.class) {\n+            kind = TYPE_INT;\n+        } else if (raw == Long.class) {\n+            kind = TYPE_LONG;\n+        } else if (raw == Date.class) {\n+            kind = TYPE_DATE;\n+        } else if (raw == Calendar.class) {\n+            kind = TYPE_CALENDAR;\n+        // then less common ones...\n+        } else if (raw == Boolean.class) {\n+            kind = TYPE_BOOLEAN;\n+        } else if (raw == Byte.class) {\n+            kind = TYPE_BYTE;\n+        } else if (raw == Character.class) {\n+            kind = TYPE_CHAR;\n+        } else if (raw == Short.class) {\n+            kind = TYPE_SHORT;\n+        } else if (raw == Float.class) {\n+            kind = TYPE_FLOAT;\n+        } else if (raw == Double.class) {\n+            kind = TYPE_DOUBLE;\n+        } else if (raw == Locale.class) {\n+            kind = TYPE_LOCALE;\n+            deser = FromStringDeserializer.findDeserializer(Locale.class);\n+        } else {\n+            return null;\n+        }\n+        return new StdKeyDeserializer(kind, raw, deser);\n+    }\n+    \n     @Override\n-    public final Object deserializeKey(String key, DeserializationContext ctxt)\n+    public Object deserializeKey(String key, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n         if (key == null) { // is this even legal call?\n \n     public Class<?> getKeyClass() { return _keyClass; }\n \n-    protected abstract Object _parse(String key, DeserializationContext ctxt) throws Exception;\n-\n-    /*\n-    /**********************************************************\n-    /* Helper methods for sub-classes\n-    /**********************************************************\n-     */\n-\n-    protected int _parseInt(String key) throws IllegalArgumentException\n-    {\n-        return Integer.parseInt(key);\n-    }\n-\n-    protected long _parseLong(String key) throws IllegalArgumentException\n-    {\n-        return Long.parseLong(key);\n-    }\n-\n-    protected double _parseDouble(String key) throws IllegalArgumentException\n-    {\n-        return NumberInput.parseDouble(key);\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* First: the standard \"String as String\" deserializer\n-    /**********************************************************\n-     */\n-\n-    @JacksonStdImpl\n-    final static class StringKD extends StdKeyDeserializer\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        private final static StringKD sString = new StringKD(String.class);\n-        private final static StringKD sObject = new StringKD(Object.class);\n-        \n-        private StringKD(Class<?> nominalType) { super(nominalType); }\n-\n-        public static StringKD forType(Class<?> nominalType)\n-        {\n-            if (nominalType == String.class) {\n-                return sString;\n-            }\n-            if (nominalType == Object.class) {\n-                return sObject;\n-            }\n-            return new StringKD(nominalType);\n-        }\n-        \n-        @Override\n-        public String _parse(String key, DeserializationContext ctxt) throws JsonMappingException {\n-            return key;\n-        }\n-    }    \n-    \n-    /*\n-    /**********************************************************\n-    /* Key deserializer implementations; wrappers\n-    /**********************************************************\n-     */\n-\n-    @JacksonStdImpl\n-    final static class BoolKD extends StdKeyDeserializer\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        BoolKD() { super(Boolean.class); }\n-\n-        @Override\n-        public Boolean _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n-        {\n+    protected Object _parse(String key, DeserializationContext ctxt) throws Exception\n+    {\n+        switch (_kind) {\n+        case TYPE_BOOLEAN:\n             if (\"true\".equals(key)) {\n                 return Boolean.TRUE;\n             }\n                 return Boolean.FALSE;\n             }\n             throw ctxt.weirdKeyException(_keyClass, key, \"value not 'true' or 'false'\");\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    final static class ByteKD extends StdKeyDeserializer\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        ByteKD() { super(Byte.class); }\n-\n-        @Override\n-\t\tpublic Byte _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n-        {\n-            int value = _parseInt(key);\n-            // as per [JACKSON-804], allow range up to 255, inclusive\n-            if (value < Byte.MIN_VALUE || value > 255) {\n-                throw ctxt.weirdKeyException(_keyClass, key, \"overflow, value can not be represented as 8-bit value\");\n-            }\n-            return Byte.valueOf((byte) value);\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    final static class ShortKD extends StdKeyDeserializer\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        ShortKD() { super(Integer.class); }\n-\n-        @Override\n-\t\tpublic Short _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n-        {\n-            int value = _parseInt(key);\n-            if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n-                throw ctxt.weirdKeyException(_keyClass, key, \"overflow, value can not be represented as 16-bit value\");\n-            }\n-            return Short.valueOf((short) value);\n-        }\n-    }\n-\n-    /**\n-     * Dealing with Characters is bit trickier: let's assume it must be a String, and that\n-     * Unicode numeric value is never used.\n-     */\n-    @JacksonStdImpl\n-    final static class CharKD extends StdKeyDeserializer\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        CharKD() { super(Character.class); }\n-\n-        @Override\n-\t\tpublic Character _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n-        {\n+        case TYPE_BYTE:\n+            {\n+                int value = _parseInt(key);\n+                // as per [JACKSON-804], allow range up to 255, inclusive\n+                if (value < Byte.MIN_VALUE || value > 255) {\n+                    throw ctxt.weirdKeyException(_keyClass, key, \"overflow, value can not be represented as 8-bit value\");\n+                }\n+                return Byte.valueOf((byte) value);\n+            }\n+        case TYPE_SHORT:\n+            {\n+                int value = _parseInt(key);\n+                if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n+                    throw ctxt.weirdKeyException(_keyClass, key, \"overflow, value can not be represented as 16-bit value\");\n+                }\n+                return Short.valueOf((short) value);\n+            }\n+        case TYPE_CHAR:\n             if (key.length() == 1) {\n                 return Character.valueOf(key.charAt(0));\n             }\n             throw ctxt.weirdKeyException(_keyClass, key, \"can only convert 1-character Strings\");\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    final static class IntKD extends StdKeyDeserializer\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        IntKD() { super(Integer.class); }\n-\n-        @Override\n-\t\tpublic Integer _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n-        {\n+        case TYPE_INT:\n             return _parseInt(key);\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    final static class LongKD extends StdKeyDeserializer\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        LongKD() { super(Long.class); }\n-\n-        @Override\n-        public Long _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n-        {\n+\n+        case TYPE_LONG:\n             return _parseLong(key);\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    final static class DoubleKD extends StdKeyDeserializer\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        DoubleKD() { super(Double.class); }\n-\n-        @Override\n-        public Double _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n-        {\n-            return _parseDouble(key);\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    final static class FloatKD extends StdKeyDeserializer\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        FloatKD() { super(Float.class); }\n-\n-        @Override\n-        public Float _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n-        {\n+\n+        case TYPE_FLOAT:\n             /* 22-Jan-2009, tatu: Bounds/range checks would be tricky\n              *   here, so let's not bother even trying...\n              */\n             return Float.valueOf((float) _parseDouble(key));\n-        }\n-    }\n-\n-    @JacksonStdImpl\n-    final static class LocaleKD extends StdKeyDeserializer {\n-        private static final long serialVersionUID = 1L;\n-\n-        protected FromStringDeserializer<?> _deser;\n-\n-        LocaleKD() { super(Locale.class);\n-            _deser = FromStringDeserializer.findDeserializer(Locale.class);\n-        }\n-\n-        @Override\n-        protected Object _parse(String key, DeserializationContext ctxt) throws JsonMappingException {\n+        case TYPE_DOUBLE:\n+            return _parseDouble(key);\n+        case TYPE_LOCALE:\n             try {\n                 return _deser._deserialize(key, ctxt);\n             } catch (IOException e) {\n                 throw ctxt.weirdKeyException(_keyClass, key, \"unable to parse key as locale\");\n             }\n-        }\n-    }\n+\n+        case TYPE_DATE:\n+            return ctxt.parseDate(key);\n+        case TYPE_CALENDAR:\n+            java.util.Date date = ctxt.parseDate(key);\n+            return (date == null)  ? null : ctxt.constructCalendar(date);\n+        case TYPE_UUID:\n+            return UUID.fromString(key);\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for sub-classes\n+    /**********************************************************\n+     */\n+\n+    protected int _parseInt(String key) throws IllegalArgumentException {\n+        return Integer.parseInt(key);\n+    }\n+\n+    protected long _parseLong(String key) throws IllegalArgumentException {\n+        return Long.parseLong(key);\n+    }\n+\n+    protected double _parseDouble(String key) throws IllegalArgumentException {\n+        return NumberInput.parseDouble(key);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* First: the standard \"String as String\" deserializer\n+    /**********************************************************\n+     */\n+\n+    @JacksonStdImpl\n+    final static class StringKD extends StdKeyDeserializer\n+    {\n+        private static final long serialVersionUID = 1L;\n+        private final static StringKD sString = new StringKD(String.class);\n+        private final static StringKD sObject = new StringKD(Object.class);\n+        \n+        private StringKD(Class<?> nominalType) { super(-1, nominalType); }\n+\n+        public static StringKD forType(Class<?> nominalType)\n+        {\n+            if (nominalType == String.class) {\n+                return sString;\n+            }\n+            if (nominalType == Object.class) {\n+                return sObject;\n+            }\n+            return new StringKD(nominalType);\n+        }\n+\n+        @Override\n+        public Object deserializeKey(String key, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n+            return key;\n+        }\n+    }    \n \n     /*\n     /**********************************************************\n         protected final AnnotatedMethod _factory;\n \n         protected EnumKD(EnumResolver<?> er, AnnotatedMethod factory) {\n-            super(er.getEnumClass());\n+            super(-1, er.getEnumClass());\n             _resolver = er;\n             _factory = factory;\n         }\n         protected final Constructor<?> _ctor;\n \n         public StringCtorKeyDeserializer(Constructor<?> ctor) {\n-            super(ctor.getDeclaringClass());\n+            super(-1, ctor.getDeclaringClass());\n             _ctor = ctor;\n         }\n \n         final Method _factoryMethod;\n \n         public StringFactoryKeyDeserializer(Method fm) {\n-            super(fm.getDeclaringClass());\n+            super(-1, fm.getDeclaringClass());\n             _factoryMethod = fm;\n         }\n \n             return _factoryMethod.invoke(null, key);\n         }\n     }\n-\n-    // as per [JACKSON-657]\n-    @JacksonStdImpl\n-    final static class DateKD extends StdKeyDeserializer\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        protected DateKD() {\n-            super(java.util.Date.class);\n-        }\n-\n-        @Override\n-        public Object _parse(String key, DeserializationContext ctxt)\n-            throws IllegalArgumentException, JsonMappingException\n-        {\n-            return ctxt.parseDate(key);\n-        }\n-    }\n-        \n-    // as per [JACKSON-657]\n-    @JacksonStdImpl\n-    final static class CalendarKD extends StdKeyDeserializer\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        protected CalendarKD() {\n-            super(java.util.Calendar.class);\n-        }\n-\n-        @Override\n-        public Object _parse(String key, DeserializationContext ctxt)\n-            throws IllegalArgumentException, JsonMappingException\n-        {\n-            java.util.Date date = ctxt.parseDate(key);\n-            return (date == null)  ? null : ctxt.constructCalendar(date);\n-        }\n-    }\n-\n-    // as per [JACKSON-726]\n-    @JacksonStdImpl\n-    final static class UuidKD extends StdKeyDeserializer\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        protected UuidKD() {\n-            super(UUID.class);\n-        }\n-\n-        @Override\n-        public Object _parse(String key, DeserializationContext ctxt)\n-            throws IllegalArgumentException, JsonMappingException\n-        {\n-            return UUID.fromString(key);\n-        }\n-    }\n }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n \n import java.lang.reflect.Constructor;\n import java.lang.reflect.Method;\n-import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.KeyDeserializers;\n     \n     @Override\n     public KeyDeserializer findKeyDeserializer(JavaType type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException\n+            DeserializationConfig config, BeanDescription beanDesc) throws JsonMappingException\n     {\n         Class<?> raw = type.getRawClass();\n         // First, common types; String/Object/UUID, Int/Long, Dates\n         if (raw == String.class || raw == Object.class) {\n             return StdKeyDeserializer.StringKD.forType(raw);\n         }\n-        if (raw == UUID.class) {\n-            return new StdKeyDeserializer.UuidKD();\n-        }\n-        \n         // 23-Apr-2013, tatu: Map primitive types, just in case one was given\n         if (raw.isPrimitive()) {\n             raw = ClassUtil.wrapperType(raw);\n         }\n-        \n-        if (raw == Integer.class) {\n-            return new StdKeyDeserializer.IntKD();\n-        }\n-        if (raw == Long.class) {\n-            return new StdKeyDeserializer.LongKD();\n-        }\n-        if (raw == Date.class) {\n-            return new StdKeyDeserializer.DateKD();\n-        }\n-        if (raw == Calendar.class) {\n-            return new StdKeyDeserializer.CalendarKD();\n-        }\n-        \n-        // then less common ones...\n-        if (raw == Boolean.class) {\n-            return new StdKeyDeserializer.BoolKD();\n-        }\n-        if (raw == Byte.class) {\n-            return new StdKeyDeserializer.ByteKD();\n-        }\n-        if (raw == Character.class) {\n-            return new StdKeyDeserializer.CharKD();\n-        }\n-        if (raw == Short.class) {\n-            return new StdKeyDeserializer.ShortKD();\n-        }\n-        if (raw == Float.class) {\n-            return new StdKeyDeserializer.FloatKD();\n-        }\n-        if (raw == Double.class) {\n-            return new StdKeyDeserializer.DoubleKD();\n-        }\n-        if (raw == Locale.class) {\n-            return new StdKeyDeserializer.LocaleKD();\n-        }\n-        return null;\n+        return StdKeyDeserializer.forType(raw);\n     }\n }", "timestamp": 1388730650, "metainfo": ""}