{"sha": "7481fda4cb8010e5fc66d0f16673cd97c22f9ce6", "log": "Implemented forward reference resolution for map based deserialization.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;\n import com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;\n-import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n+import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n \n         final KeyDeserializer keyDes = _keyDeserializer;\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+\n+        MapReferring referringAccumulator = null;\n+        if(valueDes.getObjectIdReader() != null){\n+            referringAccumulator = new MapReferring(result);\n+        }\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             // Must point to field name\n             String fieldName = jp.getCurrentName();\n                 jp.skipChildren();\n                 continue;\n             }\n-            // Note: must handle null explicitly here; value deserializers won't\n-            Object value;            \n-            if (t == JsonToken.VALUE_NULL) {\n-                value = null;\n-            } else if (typeDeser == null) {\n-                value = valueDes.deserialize(jp, ctxt);\n-            } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n-            }\n-            /* !!! 23-Dec-2008, tatu: should there be an option to verify\n-             *   that there are no duplicate field names? (and/or what\n-             *   to do, keep-first or keep-last)\n-             */\n-            result.put(key, value);\n+            try{\n+                // Note: must handle null explicitly here; value deserializers won't\n+                Object value;\n+                if (t == JsonToken.VALUE_NULL) {\n+                    value = null;\n+                } else if (typeDeser == null) {\n+                    value = valueDes.deserialize(jp, ctxt);\n+                } else {\n+                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                }\n+                /* !!! 23-Dec-2008, tatu: should there be an option to verify\n+                 *   that there are no duplicate field names? (and/or what\n+                 *   to do, keep-first or keep-last)\n+                 */\n+                result.put(key, value);\n+            } catch(UnresolvedForwardReference reference) {\n+                handleUnresolvedReference(jp, referringAccumulator, key, reference);\n+            }\n         }\n     }\n \n         }\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+        MapReferring referringAccumulator = null;\n+        if(valueDes.getObjectIdReader() != null){\n+            referringAccumulator = new MapReferring(result);\n+        }\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             // Must point to field name\n             String fieldName = jp.getCurrentName();\n                 jp.skipChildren();\n                 continue;\n             }\n-            // Note: must handle null explicitly here; value deserializers won't\n-            Object value;            \n-            if (t == JsonToken.VALUE_NULL) {\n-                value = null;\n-            } else if (typeDeser == null) {\n-                value = valueDes.deserialize(jp, ctxt);\n-            } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n-            }\n-            result.put(fieldName, value);\n+            try {\n+                // Note: must handle null explicitly here; value deserializers won't\n+                Object value;\n+                if (t == JsonToken.VALUE_NULL) {\n+                    value = null;\n+                } else if (typeDeser == null) {\n+                    value = valueDes.deserialize(jp, ctxt);\n+                } else {\n+                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                }\n+                result.put(fieldName, value);\n+            } catch (UnresolvedForwardReference reference) {\n+                handleUnresolvedReference(jp, referringAccumulator, fieldName, reference);\n+            }\n         }\n     }\n     \n         }\n         throw JsonMappingException.wrapWithPath(t, ref, null);\n     }\n+\n+    private void handleUnresolvedReference(JsonParser jp, MapReferring referring, Object key,\n+            UnresolvedForwardReference reference)\n+        throws JsonMappingException\n+    {\n+        if (referring == null) {\n+            throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n+        }\n+        referring.flagUnresolved(reference.getUnresolvedId(), key);\n+        reference.getRoid().appendReferring(referring);\n+    }\n+\n+    private final class MapReferring implements Referring {\n+        private Map<Object,Object> _accumulator = new HashMap<Object,Object>();\n+        private Map<Object,Object> _result;\n+\n+        public MapReferring(Map<Object,Object> result)\n+        {\n+            _result = result;\n+        }\n+\n+        @Override\n+        public void handleResolvedForwardReference(Object id, Object value)\n+            throws IOException\n+        {\n+            if (!_accumulator.containsKey(id)) {\n+                throw new IllegalArgumentException(\"Trying to resolve a forward reference with id [\" + id\n+                        + \"] that wasn't previously seen as unresolved.\");\n+            }\n+            Object key = _accumulator.get(id);\n+            _result.put(key, value);\n+        }\n+\n+        public void flagUnresolved(Object id, Object key)\n+        {\n+            _accumulator.put(id, key);\n+        }\n+    }\n }", "timestamp": 1389625653, "metainfo": ""}