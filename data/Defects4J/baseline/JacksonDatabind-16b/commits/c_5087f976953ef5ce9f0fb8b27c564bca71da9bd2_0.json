{"sha": "5087f976953ef5ce9f0fb8b27c564bca71da9bd2", "log": "yet more config clean up (?)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n     public DeserializationConfig(ClassIntrospector<? extends BeanDescription> intr,\n             AnnotationIntrospector annIntr, VisibilityChecker<?> vc,\n             SubtypeResolver subtypeResolver, PropertyNamingStrategy propertyNamingStrategy,\n-            TypeFactory typeFactory, HandlerInstantiator handlerInstantiator)\n+            TypeFactory typeFactory, HandlerInstantiator handlerInstantiator,\n+            Map<ClassKey,Class<?>> mixins)\n     {\n         super(intr, annIntr, vc, subtypeResolver, propertyNamingStrategy, typeFactory, handlerInstantiator,\n-                collectFeatureDefaults(DeserializationConfig.Feature.class));\n+                collectFeatureDefaults(DeserializationConfig.Feature.class),\n+                mixins);\n         _nodeFactory = JsonNodeFactory.instance;\n     }\n     \n      * Copy constructor used to create a non-shared instance with given mix-in\n      * annotation definitions and subtype resolver.\n      */\n-    private DeserializationConfig(DeserializationConfig src,\n-            HashMap<ClassKey,Class<?>> mixins, SubtypeResolver str)\n+    private DeserializationConfig(DeserializationConfig src, SubtypeResolver str)\n     {\n         this(src, src._base);\n-        _mixInAnnotations = mixins;\n         _subtypeResolver = str;\n     }\n \n-    private DeserializationConfig(DeserializationConfig src,\n-            HashMap<ClassKey,Class<?>> mixins, SubtypeResolver str,\n+    private DeserializationConfig(DeserializationConfig src, SubtypeResolver str,\n             int features)\n     {\n         super(src, src._base, str, features);\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n         _sortPropertiesAlphabetically = src._sortPropertiesAlphabetically;\n-\n-        _mixInAnnotations = mixins;\n     }\n     \n     protected DeserializationConfig(DeserializationConfig src, BaseSettings base)\n     @Override\n     public DeserializationConfig createUnshared(SubtypeResolver subtypeResolver)\n     {\n-        HashMap<ClassKey,Class<?>> mixins = _mixInAnnotations;\n-        // ensure that we assume sharing at this point:\n-        _mixInAnnotationsShared = true;\n-        return new DeserializationConfig(this, mixins, subtypeResolver);\n-    }\n-\n-\n-    @Override\n-    public DeserializationConfig createUnshared(SubtypeResolver subtypeResolver, int features) {\n-        HashMap<ClassKey,Class<?>> mixins = _mixInAnnotations;\n-        // ensure that we assume sharing at this point:\n-        _mixInAnnotationsShared = true;\n-        return new DeserializationConfig(this, mixins, subtypeResolver, features);\n+        return new DeserializationConfig(this, subtypeResolver);\n+    }\n+\n+\n+    @Override\n+    public DeserializationConfig createUnshared(SubtypeResolver subtypeResolver,\n+            int features)\n+    {\n+        return new DeserializationConfig(this, subtypeResolver, features);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import java.net.URL;\n import java.text.DateFormat;\n import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n \n import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n import com.fasterxml.jackson.databind.node.*;\n import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n import com.fasterxml.jackson.databind.type.SimpleType;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.type.TypeModifier;\n      * Provider for values to inject in deserialized POJOs.\n      */\n     protected InjectableValues _injectableValues;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration settings: mix-in annotations\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Mapping that defines how to apply mix-in annotations: key is\n+     * the type to received additional annotations, and value is the\n+     * type that has annotations to \"mix in\".\n+     *<p>\n+     * Annotations associated with the value classes will be used to\n+     * override annotations of the key class, associated with the\n+     * same field or method. They can be further masked by sub-classes:\n+     * you can think of it as injecting annotations between the target\n+     * class and its sub-classes (or interfaces)\n+     */\n+    protected final HashMap<ClassKey,Class<?>> _mixInAnnotations\n+        = new HashMap<ClassKey,Class<?>>();\n     \n     /*\n     /**********************************************************\n         _typeFactory = TypeFactory.defaultInstance();\n         _serializationConfig = (sconfig != null) ? sconfig :\n             new SerializationConfig(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER,\n-                    null, null, _typeFactory, null);\n+                    null, null, _typeFactory, null, _mixInAnnotations);\n         _deserializationConfig = (dconfig != null) ? dconfig :\n             new DeserializationConfig(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER,\n-                    null, null, _typeFactory, null);\n+                    null, null, _typeFactory, null, _mixInAnnotations);\n         _serializerProvider = (sp == null) ? new StdSerializerProvider.Impl() : sp;\n         _deserializerProvider = (dp == null) ? new StdDeserializerProvider() : dp;\n \n \n             @Override\n             public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n-                mapper._deserializationConfig.addMixInAnnotations(target, mixinSource);\n-                mapper._serializationConfig.addMixInAnnotations(target, mixinSource);\n+                mapper.addMixInAnnotations(target, mixinSource);\n             }\n         });\n         return this;\n         _deserializationConfig = cfg;\n         return this;\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Configuration: ser/deser factory, provider access\n     public DeserializerProvider getDeserializerProvider() {\n         return _deserializerProvider;\n     }\n-\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: mix-in annotations\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method to use for defining mix-in annotations to use for augmenting\n+     * annotations that processable (serializable / deserializable)\n+     * classes have.\n+     * Mixing in is done when introspecting class annotations and properties.\n+     * Map passed contains keys that are target classes (ones to augment\n+     * with new annotation overrides), and values that are source classes\n+     * (have annotations to use for augmentation).\n+     * Annotations from source classes (and their supertypes)\n+     * will <b>override</b>\n+     * annotations that target classes (and their super-types) have.\n+     */\n+    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)\n+    {\n+        _mixInAnnotations.clear();\n+        if (sourceMixins != null && sourceMixins.size() > 0) {\n+            for (Map.Entry<Class<?>,Class<?>> en : sourceMixins.entrySet()) {\n+                _mixInAnnotations.put(new ClassKey(en.getKey()), en.getValue());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method to use for adding mix-in annotations to use for augmenting\n+     * specified class or interface. All annotations from\n+     * <code>mixinSource</code> are taken to override annotations\n+     * that <code>target</code> (or its supertypes) has.\n+     *\n+     * @param target Class (or interface) whose annotations to effectively override\n+     * @param mixinSource Class (or interface) whose annotations are to\n+     *   be \"added\" to target's annotations, overriding as necessary\n+     */\n+    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)\n+    {\n+        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n+    }\n+\n+    public final Class<?> findMixInClassFor(Class<?> cls) {\n+        return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n+    }\n+\n+    public final int mixInCount() {\n+        return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Configuration, introspection\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n     /* Configuration settings\n     /**********************************************************\n      */\n-\n+    \n     /**\n      * Which Bean/Map properties are to be included in serialization?\n      * Default settings is to include all regardless of value; can be\n     public SerializationConfig(ClassIntrospector<? extends BeanDescription> intr,\n             AnnotationIntrospector annIntr, VisibilityChecker<?> vc,\n             SubtypeResolver subtypeResolver, PropertyNamingStrategy propertyNamingStrategy,\n-            TypeFactory typeFactory, HandlerInstantiator handlerInstantiator)\n+            TypeFactory typeFactory, HandlerInstantiator handlerInstantiator,\n+            Map<ClassKey,Class<?>> mixins)\n+\n     {\n         super(intr, annIntr, vc, subtypeResolver, propertyNamingStrategy, typeFactory, handlerInstantiator,\n-                collectFeatureDefaults(SerializationConfig.Feature.class));\n+                collectFeatureDefaults(SerializationConfig.Feature.class),\n+                mixins);\n         _filterProvider = null;\n     }\n     \n-    protected SerializationConfig(SerializationConfig src) {\n+    private SerializationConfig(SerializationConfig src) {\n         this(src, src._base);\n     }\n \n-    /**\n-     * Constructor used to make a private copy of specific mix-in definitions.\n-     */\n-    protected SerializationConfig(SerializationConfig src,\n-            HashMap<ClassKey,Class<?>> mixins, SubtypeResolver str)\n-    {\n-        this(src, src._base);\n-        _mixInAnnotations = mixins;\n-        _subtypeResolver = str;\n-    }\n-\n-    /**\n-     * Constructor used to make a private copy of specific mix-in definitions.\n-     */\n-    protected SerializationConfig(SerializationConfig src,\n-            HashMap<ClassKey,Class<?>> mixins, SubtypeResolver str,\n-            int features)\n-    {\n-        super(src, src._base, str, features);\n+    private SerializationConfig(SerializationConfig src, int features) {\n+        super(src, features);\n         _serializationInclusion = src._serializationInclusion;\n         _serializationView = src._serializationView;\n         _filterProvider = src._filterProvider;\n-        _mixInAnnotations = mixins;\n-    }\n-    \n-    protected SerializationConfig(SerializationConfig src, BaseSettings base)\n+    }\n+    \n+    private SerializationConfig(SerializationConfig src, BaseSettings base)\n     {\n         super(src, base, src._subtypeResolver);\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n     }\n \n-    protected SerializationConfig(SerializationConfig src, FilterProvider filters)\n+    private SerializationConfig(SerializationConfig src, FilterProvider filters)\n     {\n         super(src);\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = filters;\n     }\n \n-    protected SerializationConfig(SerializationConfig src, Class<?> view)\n+    private SerializationConfig(SerializationConfig src, Class<?> view)\n     {\n         super(src);\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n     }\n \n-    protected SerializationConfig(SerializationConfig src, JsonInclude.Include incl)\n+    private SerializationConfig(SerializationConfig src, JsonInclude.Include incl)\n     {\n         super(src);\n         _serializationInclusion = incl;\n         _filterProvider = src._filterProvider;\n     }\n \n-    protected SerializationConfig(SerializationConfig src, int features)\n-    {\n-        super(src, features);\n+    private SerializationConfig(SerializationConfig src, SubtypeResolver str,\n+            int features)\n+    {\n+        super(src, str, features);\n         _serializationInclusion = src._serializationInclusion;\n         _serializationView = src._serializationView;\n         _filterProvider = src._filterProvider;\n     @Override\n     public SerializationConfig createUnshared(SubtypeResolver subtypeResolver)\n     {\n-        HashMap<ClassKey,Class<?>> mixins = _mixInAnnotations;\n-        _mixInAnnotationsShared = true;\n-        return new SerializationConfig(this, mixins, subtypeResolver);\n+        return new SerializationConfig(this, subtypeResolver, _featureFlags);\n     }\n \n     @Override\n     public SerializationConfig createUnshared(SubtypeResolver subtypeResolver,\n             int features)\n     {\n-        HashMap<ClassKey,Class<?>> mixins = _mixInAnnotations;\n-        _mixInAnnotationsShared = true;\n-        return new SerializationConfig(this, mixins, subtypeResolver, features);\n+        return new SerializationConfig(this, subtypeResolver, features);\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n package com.fasterxml.jackson.databind.cfg;\n \n import java.text.DateFormat;\n-import java.util.HashMap;\n-import java.util.Map;\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n-import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\n-import com.fasterxml.jackson.databind.type.ClassKey;\n import com.fasterxml.jackson.databind.type.TypeBindings;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n \n     /**\n      * Immutable container object for simple configuration settings.\n-     *<p>\n-     * Note: ideally this would be final, but until we can eliminate\n-     * mutators, must keep it mutable.\n-     */\n-    protected BaseSettings _base;\n-    \n-    /*\n-    /**********************************************************\n-    /* Mix-in annotations\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * Mapping that defines how to apply mix-in annotations: key is\n-     * the type to received additional annotations, and value is the\n-     * type that has annotations to \"mix in\".\n-     *<p>\n-     * Annotations associated with the value classes will be used to\n-     * override annotations of the key class, associated with the\n-     * same field or method. They can be further masked by sub-classes:\n-     * you can think of it as injecting annotations between the target\n-     * class and its sub-classes (or interfaces)\n-     */\n-    protected HashMap<ClassKey,Class<?>> _mixInAnnotations;\n-\n-    /**\n-     * Flag used to detect when a copy if mix-in annotations is\n-     * needed: set when current copy is shared, cleared when a\n-     * fresh copy is made\n-     */\n-    protected boolean _mixInAnnotationsShared;\n-\n-    /*\n-    /**********************************************************\n-    /* \"Late bound\" settings\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Registered concrete subtypes that can be used instead of (or\n-     * in addition to) ones declared using annotations.\n-     * Unlike most other settings, it is not configured as early\n-     * as it is set, but rather only when a non-shared instance\n-     * is constructed by <code>ObjectMapper</code> (or -Reader\n-     * or -Writer)\n-     *<p>\n-     * Note: this is the only property left as non-final, to allow\n-     * lazy construction of the instance as necessary.\n-     */\n-    protected SubtypeResolver _subtypeResolver;\n+     */\n+    protected final BaseSettings _base;\n     \n     /*\n     /**********************************************************\n      */\n \n     protected MapperConfig(ClassIntrospector<? extends BeanDescription> ci, AnnotationIntrospector ai,\n-            VisibilityChecker<?> vc, SubtypeResolver str, PropertyNamingStrategy pns, TypeFactory tf,\n+            VisibilityChecker<?> vc, PropertyNamingStrategy pns, TypeFactory tf,\n             HandlerInstantiator hi)\n     {\n         _base = new BaseSettings(ci, ai, vc, pns, tf, null, DEFAULT_DATE_FORMAT, hi);\n-        _subtypeResolver = str;\n-        // by default, assumed to be shared; only cleared when explicit copy is made\n-        _mixInAnnotationsShared = true;\n-    }\n-\n-    /**\n-     * Simple copy constructor\n-     */\n-    protected MapperConfig(MapperConfig<T> src) {\n-        this(src, src._base, src._subtypeResolver);\n-    }\n-\n-    /**\n-     * Fluent-copy constructor that creates a new slightly modified version, using\n-     * given config object as base for settings not provided.\n-     */\n-    protected MapperConfig(MapperConfig<T> src, BaseSettings base, SubtypeResolver str)\n+    }\n+\n+    protected MapperConfig(BaseSettings base)\n     {\n         _base = base;\n-        _subtypeResolver = str;\n-        // by default, assumed to be shared; only cleared when explicit copy is made\n-        _mixInAnnotationsShared = true;\n-        _mixInAnnotations = src._mixInAnnotations;\n     }\n     \n     /*\n      * (which may be this instance, if it is immutable; if not, a copy\n      * is constructed with same settings)\n      */\n-    public abstract T createUnshared(SubtypeResolver subtypeResolver, int features);\n-    \n+    public abstract T createUnshared(SubtypeResolver subtypeResolver,\n+            int features);\n+\n     /**\n      * Method for constructing and returning a new instance with different\n      * {@link ClassIntrospector}\n     \n     /*\n     /**********************************************************\n-    /* Configuration: mix-in annotations\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * Method to use for defining mix-in annotations to use for augmenting\n-     * annotations that processable (serializable / deserializable)\n-     * classes have.\n-     * Mixing in is done when introspecting class annotations and properties.\n-     * Map passed contains keys that are target classes (ones to augment\n-     * with new annotation overrides), and values that are source classes\n-     * (have annotations to use for augmentation).\n-     * Annotations from source classes (and their supertypes)\n-     * will <b>override</b>\n-     * annotations that target classes (and their super-types) have.\n-     */\n-    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)\n-    {\n-        HashMap<ClassKey,Class<?>> mixins = null;\n-        if (sourceMixins != null && sourceMixins.size() > 0) {\n-            mixins = new HashMap<ClassKey,Class<?>>(sourceMixins.size());\n-            for (Map.Entry<Class<?>,Class<?>> en : sourceMixins.entrySet()) {\n-                mixins.put(new ClassKey(en.getKey()), en.getValue());\n-            }\n-        }\n-        _mixInAnnotationsShared = false;\n-        _mixInAnnotations = mixins;\n-    }\n-\n-    /**\n-     * Method to use for adding mix-in annotations to use for augmenting\n-     * specified class or interface. All annotations from\n-     * <code>mixinSource</code> are taken to override annotations\n-     * that <code>target</code> (or its supertypes) has.\n-     *\n-     * @param target Class (or interface) whose annotations to effectively override\n-     * @param mixinSource Class (or interface) whose annotations are to\n-     *   be \"added\" to target's annotations, overriding as necessary\n-     */\n-    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)\n-    {\n-        if (_mixInAnnotations == null) {\n-            _mixInAnnotationsShared = false;\n-            _mixInAnnotations = new HashMap<ClassKey,Class<?>>();\n-        } else if (_mixInAnnotationsShared) {\n-            _mixInAnnotationsShared = false;\n-            _mixInAnnotations = new HashMap<ClassKey,Class<?>>(_mixInAnnotations);\n-        }\n-        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n-    }\n-\n-    // ClassIntrospector.MixInResolver impl:\n-\n-    /**\n-     * Method that will check if there are \"mix-in\" classes (with mix-in\n-     * annotations) for given class\n-     */\n-    @Override\n-    public final Class<?> findMixInClassFor(Class<?> cls) {\n-        return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n-    }\n-\n-    public final int mixInCount() {\n-        return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n-    }\n-    \n-    /*\n-    /**********************************************************\n     /* Configuration: type and subtype handling\n     /**********************************************************\n      */\n         return _base.getTypeResolverBuilder();\n     }\n     \n-    /**\n-     * Accessor for object used for finding out all reachable subtypes\n-     * for supertypes; needed when a logical type name is used instead\n-     * of class name (or custom scheme).\n-     */\n-    public final SubtypeResolver getSubtypeResolver() {\n-        if (_subtypeResolver == null) {\n-            _subtypeResolver = new StdSubtypeResolver();\n-        }\n-        return _subtypeResolver;\n-    }\n+    public abstract SubtypeResolver getSubtypeResolver();\n \n     public final TypeFactory getTypeFactory() {\n         return _base.getTypeFactory();\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n package com.fasterxml.jackson.databind.cfg;\n+\n+import java.util.Map;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n public abstract class MapperConfigBase<CFG extends MapperConfig.ConfigFeature,\n     T extends MapperConfigBase<CFG,T>>\n     extends MapperConfig<T>\n {\n+    /*\n+    /**********************************************************\n+    /* Immutable config\n+    /**********************************************************\n+     */\n+\n     protected int _featureFlags;\n+\n+    /**\n+     * Mix-in annotation mappings to use, if any: immutable,\n+     * can not be changed once defined.\n+     */\n+    protected final Map<ClassKey,Class<?>> _mixInAnnotations;\n+\n+    /*\n+    /**********************************************************\n+    /* \"Late bound\" settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Registered concrete subtypes that can be used instead of (or\n+     * in addition to) ones declared using annotations.\n+     * Unlike most other settings, it is not configured as early\n+     * as it is set, but rather only when a non-shared instance\n+     * is constructed by <code>ObjectMapper</code> (or -Reader\n+     * or -Writer)\n+     *<p>\n+     * Note: this is the only property left as non-final, to allow\n+     * lazy construction of the instance as necessary.\n+     */\n+    protected SubtypeResolver _subtypeResolver;\n     \n     /*\n     /**********************************************************\n     protected MapperConfigBase(ClassIntrospector<? extends BeanDescription> ci, AnnotationIntrospector ai,\n             VisibilityChecker<?> vc, SubtypeResolver str, PropertyNamingStrategy pns, TypeFactory tf,\n             HandlerInstantiator hi,\n-            int defaultFeatures)\n+            int defaultFeatures, Map<ClassKey,Class<?>> mixins)\n     {\n-        super(ci, ai, vc, str, pns, tf, hi);\n+        super(ci, ai, vc, pns, tf, hi);\n         _featureFlags = defaultFeatures;\n+        _mixInAnnotations = mixins;\n+        _subtypeResolver = str;\n     }\n     \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src) {\n-        super(src);\n+        super(src._base);\n         _featureFlags = src._featureFlags;\n+        _mixInAnnotations = src._mixInAnnotations;\n+        _subtypeResolver = src._subtypeResolver;\n     }\n     \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, int features) {\n-        super(src);\n+        super(src._base);\n         _featureFlags = features;\n+        _mixInAnnotations = src._mixInAnnotations;\n+        _subtypeResolver = src._subtypeResolver;\n     }\n+\n     \n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src, SubtypeResolver str,\n+            int features)\n+    {\n+        super(src._base);\n+        _featureFlags = features;\n+        _mixInAnnotations = src._mixInAnnotations;\n+        _subtypeResolver = str;\n+    }\n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, BaseSettings base, SubtypeResolver str)\n     {\n-        super(src, base, str);\n+        super(base);\n         _featureFlags = src._featureFlags;\n+        _mixInAnnotations = src._mixInAnnotations;\n+        _subtypeResolver = str;\n     }\n     \n     protected MapperConfigBase(MapperConfigBase<CFG,T> src, BaseSettings base, SubtypeResolver str,\n             int features)\n     {\n-        super(src, base, str);\n+        super(base);\n         _featureFlags = features;\n+        _mixInAnnotations = src._mixInAnnotations;\n+        _subtypeResolver = str;\n     }\n     \n     /**\n     public final int getFeatureFlags() {\n         return _featureFlags;\n     }\n+\n+    /**\n+     * Accessor for object used for finding out all reachable subtypes\n+     * for supertypes; needed when a logical type name is used instead\n+     * of class name (or custom scheme).\n+     */\n+    public final SubtypeResolver getSubtypeResolver() {\n+        if (_subtypeResolver == null) {\n+            _subtypeResolver = new StdSubtypeResolver();\n+        }\n+        return _subtypeResolver;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* ClassIntrospector.MixInResolver impl:\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will check if there are \"mix-in\" classes (with mix-in\n+     * annotations) for given class\n+     */\n+    @Override\n+    public final Class<?> findMixInClassFor(Class<?> cls) {\n+        return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n+    }\n+\n+    public final int mixInCount() {\n+        return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCreators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCreators.java\n     public void testFactoryCreatorWithMixin() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.getDeserializationConfig().addMixInAnnotations(CreatorBean.class, MixIn.class);\n+        m.addMixInAnnotations(CreatorBean.class, MixIn.class);\n         CreatorBean bean = m.readValue\n             (\"{ \\\"a\\\" : \\\"xyz\\\", \\\"x\\\" : 12 }\", CreatorBean.class);\n         assertEquals(11, bean.x);\n     public void testFactoryCreatorWithRenamingMixin() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.getDeserializationConfig().addMixInAnnotations(FactoryBean.class, FactoryBeanMixIn.class);\n+        m.addMixInAnnotations(FactoryBean.class, FactoryBeanMixIn.class);\n         // override changes property name from \"f\" to \"mixed\"\n         FactoryBean bean = m.readValue(\"{ \\\"mixed\\\" :  20.5 }\", FactoryBean.class);\n         assertEquals(20.5, bean.d);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArrayDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArrayDeserialization.java\n     {\n         ObjectMapper m = new ObjectMapper();\n         // use class name, WRAPPER_OBJECT\n-        m.getDeserializationConfig().addMixInAnnotations(long[].class, WrapperMixIn.class);\n+        m.addMixInAnnotations(long[].class, WrapperMixIn.class);\n         String JSON = \"{\\\"\"+long[].class.getName()+\"\\\":[5, 6, 7]}\";\n         long[] value = m.readValue(JSON, long[].class);\n         assertNotNull(value);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n     public void testIntArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.getSerializationConfig().addMixInAnnotations(int[].class, WrapperMixIn.class);\n+        m.addMixInAnnotations(int[].class, WrapperMixIn.class);\n         int[] input = new int[] { 1, 2, 3 };\n         String clsName = int[].class.getName();\n         assertEquals(\"{\\\"\"+clsName+\"\\\":[1,2,3]}\", serializeAsString(m, input));\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserialization.java\n     public void testTypeAsWrapper() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.getDeserializationConfig().addMixInAnnotations(Animal.class, TypeWithWrapper.class);\n+        m.addMixInAnnotations(Animal.class, TypeWithWrapper.class);\n         String JSON = \"{\\\".TestTypedDeserialization$Dog\\\" : \"\n             +asJSONObjectValueString(m, \"name\", \"Scooby\", \"boneCount\", \"6\")+\" }\";\n         Animal a = m.readValue(JSON, Animal.class);\n     public void testTypeAsArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.getDeserializationConfig().addMixInAnnotations(Animal.class, TypeWithArray.class);\n+        m.addMixInAnnotations(Animal.class, TypeWithArray.class);\n         // hmmh. Not good idea to rely on exact output, order may change. But...\n         String JSON = \"[\\\"\"+Dog.class.getName()+\"\\\", \"\n             +asJSONObjectValueString(m, \"name\", \"Martti\", \"boneCount\", \"11\")+\" ]\";\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n     public void testTypeAsWrapper() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.getSerializationConfig().addMixInAnnotations(Animal.class, TypeWithWrapper.class);\n+        m.addMixInAnnotations(Animal.class, TypeWithWrapper.class);\n         Map<String,Object> result = writeAndMap(m, new Cat(\"Venla\", \"black\"));\n         // should get a wrapper; keyed by minimal class name (\"Cat\" here)\n         assertEquals(1, result.size());\n     public void testTypeAsArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.getSerializationConfig().addMixInAnnotations(Animal.class, TypeWithArray.class);\n+        m.addMixInAnnotations(Animal.class, TypeWithArray.class);\n         // hmmh. Not good idea to rely on exact output, order may change. But...\n         Map<String,Object> result = writeAndMap(m, new AnimalWrapper(new Dog(\"Amadeus\", 7)));\n         // First level, wrapper\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForClass.java\n          * use field\n          */\n         m = new ObjectMapper();\n-        m.getDeserializationConfig().addMixInAnnotations(LeafClass.class, MixIn.class);\n+        m.addMixInAnnotations(LeafClass.class, MixIn.class);\n         result = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\", LeafClass.class);\n         assertEquals(\"value\", result.a);\n     }\n     public void testClassMixInsMidLevel() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.getDeserializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        m.addMixInAnnotations(BaseClass.class, MixIn.class);\n         {\n             BaseClass result = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\", BaseClass.class);\n             assertEquals(\"value\", result.a);\n     public void testClassMixInsForObjectClass() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.getDeserializationConfig().addMixInAnnotations(Object.class, MixIn.class);\n+        m.addMixInAnnotations(Object.class, MixIn.class);\n         // will be seen for BaseClass\n         {\n             BaseClass result = m.readValue(\"{\\\"a\\\":\\\"\\\"}\", BaseClass.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForCreators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForCreators.java\n     public void testForConstructor() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.getDeserializationConfig().addMixInAnnotations(BaseClassWithPrivateCtor.class, MixInForPrivate.class);\n+        m.addMixInAnnotations(BaseClassWithPrivateCtor.class, MixInForPrivate.class);\n         BaseClassWithPrivateCtor result = m.readValue(\"\\\"?\\\"\", BaseClassWithPrivateCtor.class);\n         assertEquals(\"?...\", result._a);\n     }\n \n         // Then with simple mix-in: should change to use the factory method\n         m = new ObjectMapper();\n-        m.getDeserializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        m.addMixInAnnotations(BaseClass.class, MixIn.class);\n         result = m.readValue(\"\\\"string\\\"\", BaseClass.class);\n         assertEquals(\"stringX\", result._a);\n     }\n     public void testFactoryMixIn() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.getDeserializationConfig().addMixInAnnotations(StringWrapper.class, StringWrapperMixIn.class);\n+        m.addMixInAnnotations(StringWrapper.class, StringWrapperMixIn.class);\n         StringWrapper result = m.readValue(\"\\\"a\\\"\", StringWrapper.class);\n         assertEquals(\"a\", result._value);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForMethods.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForMethods.java\n     public void testWithAnySetter() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.getDeserializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        m.addMixInAnnotations(BaseClass.class, MixIn.class);\n         BaseClass result = m.readValue(\"{ \\\"a\\\" : 3, \\\"b\\\" : true }\", BaseClass.class);\n         assertNotNull(result);\n         assertEquals(2, result.values.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForClass.java\n \n         // then with top-level override\n         mapper = new ObjectMapper();\n-        mapper.getSerializationConfig().addMixInAnnotations(LeafClass.class, MixIn.class);\n+        mapper.addMixInAnnotations(LeafClass.class, MixIn.class);\n         result = writeAndMap(mapper, new LeafClass(\"abc\"));\n         assertEquals(2, result.size());\n         assertEquals(\"abc\", result.get(\"a\"));\n \n         // mid-level override; should not have any effect\n         mapper = new ObjectMapper();\n-        mapper.getSerializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, new LeafClass(\"abc\"));\n         assertEquals(1, result.size());\n         assertEquals(\"abc\", result.get(\"a\"));\n \n         // then with working mid-level override, which effectively suppresses 'a'\n         mapper = new ObjectMapper();\n-        mapper.getSerializationConfig().addMixInAnnotations(BaseClass.class, MixInAutoDetect.class);\n+        mapper.addMixInAnnotations(BaseClass.class, MixInAutoDetect.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(1, result.size());\n         assertEquals(\"c2\", result.get(\"c\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForFields.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForFields.java\n     }\n \n     /*\n-    ///////////////////////////////////////////////////////////\n-    // Unit tests\n-    ///////////////////////////////////////////////////////////\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n      */\n \n     public void testFieldMixInsTopLevel() throws IOException\n \n         // and then with simple mix-in\n         mapper = new ObjectMapper();\n-        mapper.getSerializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(2, result.size());\n         assertEquals(\"1\", result.get(\"a\"));\n     public void testMultipleFieldMixIns() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        Map<String,Object> result;\n         // ordering here shouldn't matter really...\n         HashMap<Class<?>,Class<?>> mixins = new HashMap<Class<?>,Class<?>>();\n-        // first, clear (not strictly needed -- just for fun)\n-        mapper.getSerializationConfig().setMixInAnnotations(null);\n         mixins.put(SubClass.class, MixIn.class);\n         mixins.put(BaseClass.class, MixIn2.class);\n-        mapper.getSerializationConfig().setMixInAnnotations(mixins);\n+        mapper.setMixInAnnotations(mixins);\n \n+        Map<String,Object> result;\n         result = writeAndMap(mapper, new SubClass(\"1\", \"2\"));\n         assertEquals(1, result.size());\n         // 'a' should be suppressed; 'b' mapped to 'banana'\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForMethods.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForMethods.java\n \n         // then with leaf-level mix-in\n         mapper = new ObjectMapper();\n-        mapper.getSerializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(2, result.size());\n         assertEquals(\"b2\", result.get(\"b2\"));\n         Map<String,Object> result;\n         LeafClass bean = new LeafClass(\"XXX\", \"b2\");\n \n-        mapper.getSerializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(1, result.size());\n         assertEquals(\"XXX\", result.get(\"a\"));\n     public void testIntermediateMixin2() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.getSerializationConfig().addMixInAnnotations(EmptyBean.class, MixInForSimple.class);\n+        mapper.addMixInAnnotations(EmptyBean.class, MixInForSimple.class);\n         Map<String,Object> result = writeAndMap(mapper, new SimpleBean());\n         assertEquals(1, result.size());\n         assertEquals(Integer.valueOf(42), result.get(\"x\"));\n     public void testObjectMixin() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.getSerializationConfig().addMixInAnnotations(Object.class, ObjectMixIn.class);\n+        mapper.addMixInAnnotations(Object.class, ObjectMixIn.class);\n \n         // First, with our bean...\n         Map<String,Object> result = writeAndMap(mapper, new BaseClass(\"a\", \"b\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n \n         // Property SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION set to false\n         mapper.configure(SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION, Boolean.FALSE);\n-        mapper.getSerializationConfig().addMixInAnnotations(A.class, AMixInAnnotation.class);\n+        mapper.addMixInAnnotations(A.class, AMixInAnnotation.class);\n         String json = mapper.writerWithView(AView.class).writeValueAsString(a);\n \n         assertTrue(json.indexOf(\"\\\"name\\\"\") > 0);\n       sourceMixins.put( SimpleTestData.class, TestDataJAXBMixin.class );\n       sourceMixins.put( ComplexTestData.class, TestComplexDataJAXBMixin.class );\n       \n-      objectMapper.getSerializationConfig( ).setMixInAnnotations(sourceMixins);\n+      objectMapper.setMixInAnnotations(sourceMixins);\n       return objectMapper;\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n     {\n         String JSON = \"{\\\"leaf\\\":{\\\"value\\\":13}}\";\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.getDeserializationConfig().addMixInAnnotations(Leaf.class, LeafMixIn.class);\n+        mapper.addMixInAnnotations(Leaf.class, LeafMixIn.class);\n         JsonNode root = mapper.readTree(JSON);\n         // Ok, try converting to bean using two mechanisms\n         Root r1 = mapper.treeToValue(root, Root.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n     public void testCustomization() throws Exception\n     {\n         ObjectMapper objectMapper = new ObjectMapper();\n-        objectMapper.getSerializationConfig().addMixInAnnotations(Element.class, ElementMixin.class);\n+        objectMapper.addMixInAnnotations(Element.class, ElementMixin.class);\n         Element element = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument().createElement(\"el\");\n         StringWriter sw = new StringWriter();\n         objectMapper.writeValue(sw, element);\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n \n         // Including class annotation through mix-ins\n         ObjectMapper m2 = new ObjectMapper();\n-        m2.getSerializationConfig().addMixInAnnotations(Empty.class, EmptyWithAnno.class);\n+        m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class);\n         assertEquals(\"{}\", m2.writeValueAsString(new Empty()));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n     public void testEnumsWithJsonValueUsingMixin() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.getSerializationConfig().addMixInAnnotations(TestEnum.class, ToStringMixin.class);\n+        mapper.addMixInAnnotations(TestEnum.class, ToStringMixin.class);\n         assertEquals(\"\\\"b\\\"\", mapper.writeValueAsString(TestEnum.B));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n     public void testOrderWithMixins() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.getSerializationConfig().addMixInAnnotations(BeanWithOrder.class, OrderMixIn.class);\n+        m.addMixInAnnotations(BeanWithOrder.class, OrderMixIn.class);\n         assertEquals(\"{\\\"b\\\":2,\\\"a\\\":1,\\\"c\\\":3,\\\"d\\\":4}\", serializeAsString(m, new BeanWithOrder(1, 2, 3, 4)));\n     }\n ", "timestamp": 1326951378, "metainfo": ""}