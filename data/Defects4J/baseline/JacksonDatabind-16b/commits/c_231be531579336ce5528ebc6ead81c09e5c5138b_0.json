{"sha": "231be531579336ce5528ebc6ead81c09e5c5138b", "log": "Fix issues #94 and #96", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java\n  * from methods (as well as lower-cases initial sequence of capitalized\n  * characters).\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class PropertyNamingStrategy\n+    implements java.io.Serializable\n {\n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n         }\n         // and when we get this far, let's try finalizing the deal:\n         return ext.complete(jp, ctxt, bean);\n-    }        \n+    }\n \n     @SuppressWarnings(\"resource\")\n     protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n                         if (extTypes == null) {\n                             extTypes = new ExternalTypeHandler.Builder();\n                         }\n-                        extTypes.addExternal(prop, typeDeser.getPropertyName());\n+                        extTypes.addExternal(prop, typeDeser);\n                     }\n                 }\n             }\n                     if (extTypes == null) {\n                         extTypes = new ExternalTypeHandler.Builder();\n                     }\n-                    extTypes.addExternal(prop, typeDeser.getPropertyName());\n+                    extTypes.addExternal(prop, typeDeser);\n                     // In fact, remove from list of known properties to simplify later handling\n                     _beanProperties.remove(prop);\n                     continue;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n         if (!prop.hasTypePropertyName(propName)) {\n             return false;\n         }\n-        _typeIds[index] = jp.getText();\n+        String typeId = jp.getText();\n         // note: can NOT skip child values (should always be String anyway)\n         boolean canDeserialize = (bean != null) && (_tokens[index] != null);\n         // Minor optimization: deserialize properties as soon as we have all we need:\n         if (canDeserialize) {\n-            _deserializeAndSet(jp, ctxt, bean, index);\n+            _deserializeAndSet(jp, ctxt, bean, index, typeId);\n             // clear stored data, to avoid deserializing+setting twice:\n-            _typeIds[index] = null;\n             _tokens[index] = null;\n+        } else {\n+            _typeIds[index] = typeId;\n         }\n         return true;\n     }\n          * we have all pertinent information:\n          */\n         if (canDeserialize) {\n-            _deserializeAndSet(jp, ctxt, bean, index);\n+            String typeId = _typeIds[index];\n             // clear stored data, to avoid deserializing+setting twice:\n             _typeIds[index] = null;\n+            _deserializeAndSet(jp, ctxt, bean, index, typeId);\n             _tokens[index] = null;\n         }\n         return true;\n         throws IOException, JsonProcessingException\n     {\n         for (int i = 0, len = _properties.length; i < len; ++i) {\n-            if (_typeIds[i] == null) {\n+            String typeId = _typeIds[i];\n+            if (typeId == null) {\n                 // let's allow missing both type and property (may already have been set, too)\n                 if (_tokens[i] == null) {\n                     continue;\n                 }\n                 // but not just one\n-                throw ctxt.mappingException(\"Missing external type id property '\"+_properties[i].getTypePropertyName());\n+                // 26-Oct-2012, tatu: As per [Issue#94], must allow use of 'defaultImpl'\n+                if (!_properties[i].hasDefaultType()) {\n+                    throw ctxt.mappingException(\"Missing external type id property '\"+_properties[i].getTypePropertyName()+\"'\");\n+                }\n+                typeId = _properties[i].getDefaultTypeId();\n             } else if (_tokens[i] == null) {\n                 SettableBeanProperty prop = _properties[i].getProperty();\n                 throw ctxt.mappingException(\"Missing property '\"+prop.getName()+\"' for external type id '\"+_properties[i].getTypePropertyName());\n             }\n-            _deserializeAndSet(jp, ctxt, bean, i);\n+            _deserializeAndSet(jp, ctxt, bean, i, typeId);\n         }\n         return bean;\n     }\n         final int len = _properties.length;\n         Object[] values = new Object[len];\n         for (int i = 0; i < len; ++i) {\n-            if (_typeIds[i] == null) {\n+            String typeId = _typeIds[i];\n+            if (typeId == null) {\n                 // let's allow missing both type and property (may already have been set, too)\n                 if (_tokens[i] == null) {\n                     continue;\n                 }\n                 // but not just one\n-                throw ctxt.mappingException(\"Missing external type id property '\"+_properties[i].getTypePropertyName());\n+                // 26-Oct-2012, tatu: As per [Issue#94], must allow use of 'defaultImpl'\n+                if (!_properties[i].hasDefaultType()) {\n+                    throw ctxt.mappingException(\"Missing external type id property '\"+_properties[i].getTypePropertyName()+\"'\");\n+                }\n+                typeId = _properties[i].getDefaultTypeId();\n             } else if (_tokens[i] == null) {\n                 SettableBeanProperty prop = _properties[i].getProperty();\n                 throw ctxt.mappingException(\"Missing property '\"+prop.getName()+\"' for external type id '\"+_properties[i].getTypePropertyName());\n             }\n-            values[i] = _deserialize(jp, ctxt, i);\n+            values[i] = _deserialize(jp, ctxt, i, typeId);\n         }\n         // second: fill in creator properties:\n         for (int i = 0; i < len; ++i) {\n     }\n \n     protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt,\n-            int index)\n+            int index, String typeId)\n         throws IOException, JsonProcessingException\n     {\n         TokenBuffer merged = new TokenBuffer(jp.getCodec());\n         merged.writeStartArray();\n-        merged.writeString(_typeIds[index]);\n+        merged.writeString(typeId);\n         JsonParser p2 = _tokens[index].asParser(jp);\n         p2.nextToken();\n         merged.copyCurrentStructure(p2);\n         merged.writeEndArray();\n+\n         // needs to point to START_OBJECT (or whatever first token is)\n         p2 = merged.asParser(jp);\n         p2.nextToken();\n         return _properties[index].getProperty().deserialize(p2, ctxt);\n     }\n     \n-    protected final void _deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean, int index)\n+    protected final void _deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n+            Object bean, int index, String typeId)\n         throws IOException, JsonProcessingException\n     {\n         /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n          */\n         TokenBuffer merged = new TokenBuffer(jp.getCodec());\n         merged.writeStartArray();\n-        merged.writeString(_typeIds[index]);\n+        merged.writeString(typeId);\n         JsonParser p2 = _tokens[index].asParser(jp);\n         p2.nextToken();\n         merged.copyCurrentStructure(p2);\n         merged.writeEndArray();\n+        \n         // needs to point to START_OBJECT (or whatever first token is)\n         p2 = merged.asParser(jp);\n         p2.nextToken();\n     {\n         private final ArrayList<ExtTypedProperty> _properties = new ArrayList<ExtTypedProperty>();\n         private final HashMap<String, Integer> _nameToPropertyIndex = new HashMap<String, Integer>();\n-        \n-        public void addExternal(SettableBeanProperty property, String extPropName)\n+\n+        // note: signature changed between 2.1.0 and 2.1.1 (alas!)\n+        public void addExternal(SettableBeanProperty property, TypeDeserializer typeDeser)\n         {\n             Integer index = _properties.size();\n-            _properties.add(new ExtTypedProperty(property, extPropName));\n+            _properties.add(new ExtTypedProperty(property, typeDeser));\n             _nameToPropertyIndex.put(property.getName(), index);\n-            _nameToPropertyIndex.put(extPropName, index);\n+            _nameToPropertyIndex.put(typeDeser.getPropertyName(), index);\n         }\n         \n         public ExternalTypeHandler build() {\n     private final static class ExtTypedProperty\n     {\n         private final SettableBeanProperty _property;\n+        private final TypeDeserializer _typeDeserializer;\n         private final String _typePropertyName;\n         \n-        public ExtTypedProperty(SettableBeanProperty property, String typePropertyName)\n+        public ExtTypedProperty(SettableBeanProperty property, TypeDeserializer typeDeser)\n         {\n             _property = property;\n-            _typePropertyName = typePropertyName;\n+            _typeDeserializer = typeDeser;\n+            _typePropertyName = typeDeser.getPropertyName();\n         }\n \n         public boolean hasTypePropertyName(String n) {\n             return n.equals(_typePropertyName);\n         }\n \n+        public boolean hasDefaultType() {\n+            return _typeDeserializer.getDefaultImpl() != null;\n+        }\n+\n+        public String getDefaultTypeId() {\n+            Class<?> defaultType = _typeDeserializer.getDefaultImpl();\n+            if (defaultType == null) {\n+                return null;\n+            }\n+            return _typeDeserializer.getTypeIdResolver().idFromValueAndType(null, defaultType);\n+        }\n+        \n         public String getTypePropertyName() { return _typePropertyName; }\n         \n         public SettableBeanProperty getProperty() {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java\n      * conversion.\n      * \n      * @param delegateValue\n-     * @return\n+     * \n+     * @return Result of conversion\n      */\n     protected T convertValue(Object delegateValue) {\n         return _converter.convert(delegateValue);\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n     public abstract Class<?> getDefaultImpl();\n     \n     /*\n-    /*********************************************************\n+    /**********************************************************\n     /* Type deserialization methods\n     /**********************************************************\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n             throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, \"need JSON Array to contain As.WRAPPER_ARRAY type information for class \"+baseTypeName());\n         }\n         // And then type id as a String\n-        if (jp.nextToken() != JsonToken.VALUE_STRING) {\n-            if (_defaultImpl != null) {\n-                return _idResolver.idFromBaseType();\n-            }\n-            throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n+        JsonToken t = jp.nextToken();\n+        if (t == JsonToken.VALUE_STRING) {\n+            String result = jp.getText();\n+            jp.nextToken();\n+            return result;\n         }\n-        String result = jp.getText();\n-        jp.nextToken();\n-        return result;\n+        if (_defaultImpl != null) {\n+            return _idResolver.idFromBaseType();\n+        }\n+        throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n      * The default implementation uses configured {@link Converter} to do\n      * conversion.\n      * \n-     * @param delegateValue\n-     * @return\n+     * @param value Value to convert\n+     * \n+     * @return Result of conversion\n      */\n     protected Object convertValue(Object value) {\n         return _converter.convert(value);\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestInnerClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestInnerClass.java\n package com.fasterxml.jackson.databind.deser;\n \n+import java.util.ArrayList;\n+import java.util.List;\n \n import com.fasterxml.jackson.databind.*;\n \n public class TestInnerClass extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Value classes\n-    /**********************************************************\n-     */\n-\n     // [JACKSON-594]\n     static class Dog\n     {\n         output.name = \"Foo\";\n         assertEquals(\"Foo\", output.brain.parentName());\n     }\n+\n+    // core/[Issue#32]\n+    public void testInnerList() throws Exception\n+    {\n+        Dog2 dog = new Dog2();\n+        dog.name = \"Spike\";\n+        dog.legs = new ArrayList<Dog2.Leg>();\n+        dog.legs.add(dog.new Leg());\n+        dog.legs.add(dog.new Leg());\n+        dog.legs.get(0).length = 5;\n+        dog.legs.get(1).length = 4;\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        String dogJson = mapper.writeValueAsString(dog);\n+        System.out.println(dogJson);\n+      // output: {\"name\":\"Spike\",\"legs\":[{length: 5}, {length: 4}]}\n+\n+        // currently throws JsonMappingException\n+        Dog2 dogCopy = mapper.readValue(dogJson, Dog2.class);\n+        assertEquals(dogCopy.legs.get(1).length, 4);\n+        // prefer fully populated Dog instance\n+    }\n+\n+    public static class Dog2\n+    {\n+      public String name;\n+      public List<Leg> legs;\n+\n+      public class Leg {\n+        public int length;\n+      }\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n \n         public ExternalBean() { }\n         public ExternalBean(int v) {\n+            bean = new ValueBean(v);\n+        }\n+    }\n+\n+    // for [Issue#96]\n+    static class ExternalBeanWithDefault\n+    {\n+        @JsonTypeInfo(use=Id.CLASS, include=As.EXTERNAL_PROPERTY, property=\"extType\",\n+                defaultImpl=ValueBean.class)\n+        public Object bean;\n+\n+        public ExternalBeanWithDefault() { }\n+        public ExternalBeanWithDefault(int v) {\n             bean = new ValueBean(v);\n         }\n     }\n             this.petType = petType;\n         }\n     }    \n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n \n     /*\n     /**********************************************************\n     /* Unit tests, deserialization\n     /**********************************************************\n      */\n-\n+    \n     public void testSimpleDeserialization() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n     // If trying to use with Class, should just become \"PROPERTY\" instead:\n     public void testImproperExternalIdDeserialization() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        FunkyExternalBean result = mapper.readValue(\"{\\\"extType\\\":\\\"funk\\\",\\\"i\\\":3}\", FunkyExternalBean.class);\n+        FunkyExternalBean result = MAPPER.readValue(\"{\\\"extType\\\":\\\"funk\\\",\\\"i\\\":3}\",\n+                FunkyExternalBean.class);\n         assertNotNull(result);\n         assertEquals(3, result.i);\n     }\n \n     public void testIssue798() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-\n         Base base = new Derived1(\"derived1 prop val\", \"base prop val\");\n         BaseContainer baseContainer = new BaseContainer(\"bc prop val\", base);\n-        String generatedJson = mapper.writeValueAsString(baseContainer);\n-        BaseContainer baseContainer2 = mapper.readValue(generatedJson,BaseContainer.class);\n+        String generatedJson = MAPPER.writeValueAsString(baseContainer);\n+        BaseContainer baseContainer2 = MAPPER.readValue(generatedJson,BaseContainer.class);\n         assertEquals(\"bc prop val\", baseContainer.getBaseContainerProperty());\n \n         Base b = baseContainer2.getBase();\n     {\n         final String JSON = \"{ \\\"petType\\\": \\\"dog\\\",\\n\"\n                 +\"\\\"pet\\\": { \\\"name\\\": \\\"Pluto\\\" }\\n}\";\n-        ObjectMapper mapper = new ObjectMapper();\n-        House831 result = mapper.readValue(JSON, House831.class);\n+        House831 result = MAPPER.readValue(JSON, House831.class);\n         assertNotNull(result);\n         assertNotNull(result.pet);\n         assertSame(Dog.class, result.pet.getClass());\n         assertEquals(\"dog\", result.petType);\n     }\n+\n+    // For [Issue#96]: should allow use of default impl, if property missing\n+    public void testWithDefaultAndMissing() throws Exception\n+    {\n+        ExternalBeanWithDefault input = new ExternalBeanWithDefault(13);\n+        // baseline: include type, verify things work:\n+        String fullJson = MAPPER.writeValueAsString(input);\n+        ExternalBeanWithDefault output = MAPPER.readValue(fullJson, ExternalBeanWithDefault.class);\n+        assertNotNull(output);\n+        assertNotNull(output.bean);\n+        // and then try without type info...\n+        ExternalBeanWithDefault defaulted = MAPPER.readValue(\"{\\\"bean\\\":{\\\"value\\\":13}}\",\n+                ExternalBeanWithDefault.class);\n+        assertNotNull(defaulted);\n+        assertNotNull(defaulted.bean);\n+        assertSame(ValueBean.class, defaulted.bean.getClass());\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserializationWithDefault.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserializationWithDefault.java\n  */\n public class TestTypedDeserializationWithDefault extends BaseMapTest\n {\n-  private final ObjectMapper mapper = new ObjectMapper();\n+    private final ObjectMapper mapper = new ObjectMapper();\n \n-  @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\", defaultImpl = LegacyInter.class)\n-  @JsonSubTypes(value = {@JsonSubTypes.Type(name = \"mine\", value = MyInter.class)})\n-  public static interface Inter { }\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\", defaultImpl = LegacyInter.class)\n+    @JsonSubTypes(value = {@JsonSubTypes.Type(name = \"mine\", value = MyInter.class)})\n+    public static interface Inter { }\n \n-  public static class MyInter implements Inter\n-  {\n-    @JsonProperty(\"blah\")\n-    public List<String> blah;\n-  }\n+    public static class MyInter implements Inter {\n+        @JsonProperty(\"blah\") public List<String> blah;\n+    }\n \n   public static class LegacyInter extends MyInter\n   {\n     }\n   }\n \n-  public void testDeserializationWithObject() throws Exception\n-  {\n-    Inter inter = mapper.readValue(\"{\\\"type\\\": \\\"mine\\\", \\\"blah\\\": [\\\"a\\\", \\\"b\\\", \\\"c\\\"]}\", Inter.class);\n+    /*\n+    /**********************************************************\n+    /* Unit tests, deserialization\n+    /**********************************************************\n+     */\n \n-    assertTrue(inter instanceof MyInter);\n-    assertFalse(inter instanceof LegacyInter);\n-    assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), ((MyInter) inter).blah);\n-  }\n+    public void testDeserializationWithObject() throws Exception\n+    {\n+        Inter inter = mapper.readValue(\"{\\\"type\\\": \\\"mine\\\", \\\"blah\\\": [\\\"a\\\", \\\"b\\\", \\\"c\\\"]}\", Inter.class);\n+        assertTrue(inter instanceof MyInter);\n+        assertFalse(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), ((MyInter) inter).blah);\n+    }\n \n   public void testDeserializationWithString() throws Exception\n   {\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeDeserialization.java\n         public void setNode(JsonNode n) { _node = n; }\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n     /**\n      * This test checks that is possible to mix \"regular\" Java objects\n      * and JsonNode.\n         assertTrue(n1.equals(n2));\n         assertTrue(n2.equals(n1));\n     }\n+\n+    public void testReadFromString() throws Exception\n+    {\n+        String json = \"{\\\"field\\\":\\\"{\\\\\\\"name\\\\\\\":\\\\\\\"John Smith\\\\\\\"}\\\"}\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode jNode = mapper.readValue(json, JsonNode.class);\n+\n+        String generated = mapper.writeValueAsString( jNode);  //back slashes are gone\n+        JsonNode out = mapper.readValue( generated, JsonNode.class );   //crashes here\n+        assertTrue(out.isObject());\n+        assertEquals(1, out.size());\n+        String value = out.path(\"field\").asText();\n+        assertNotNull(value);\n+    }\n }", "timestamp": 1351300782, "metainfo": ""}