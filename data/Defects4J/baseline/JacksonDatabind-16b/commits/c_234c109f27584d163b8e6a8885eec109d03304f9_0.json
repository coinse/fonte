{"sha": "234c109f27584d163b8e6a8885eec109d03304f9", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n     @Override\n     public String containedTypeName(int index) { return null; }\n \n+    @Override\n+    public abstract Class<?> getParameterSource();\n+    \n     /*\n     /**********************************************************\n     /* Extended API beyond ResolvedType\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n import java.lang.reflect.Method;\n import java.util.*;\n import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.JsonLocation;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n import com.fasterxml.jackson.databind.deser.std.*;\n+import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n     private final static Class<?> CLASS_STRING = String.class;\n     private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n     private final static Class<?> CLASS_ITERABLE = Iterable.class;\n+    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n \n     /**\n      * We need a placeholder for creator properties that don't have name\n         \n         // Very first thing: is deserializer hard-coded for elements?\n         JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n-        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n+        // Then optional type info: if type has been resolved, we may already know type deserializer:\n         TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n         // but if not, may still be possible to find:\n         if (elemTypeDeser == null) {\n         return deser;\n     }\n \n-    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n-                    beanDesc, elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-    \n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl: Collection(-like) deserializers\n         }\n         return (CollectionType) config.constructSpecializedType(type, collectionClass);\n     }\n-\n-    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n-                    elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n     \n     // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n     @Override\n         return deser;\n     }\n \n-    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n-                    elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-\n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl: Map(-like) deserializers\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt,\n             MapType type, BeanDescription beanDesc)\n         return deser;\n     }\n \n-    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            KeyDeserializer keyDeserializer,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n-                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            KeyDeserializer keyDeserializer,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n-                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-    \n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl: Enum deserializers\n         }\n         return deser;\n     }\n-\n-    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n     \n     /*\n     /**********************************************************\n             return custom;\n         }\n         return JsonNodeDeserializer.getDeserializer(nodeClass);\n-    }\n-\n-    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n     }\n     \n     /*\n         return b.buildTypeDeserializer(config, baseType, subtypes);\n     }\n \n+    /**\n+     * Overridable method called after checking all other types.\n+     * \n+     * @since 2.2\n+     */\n+    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt,\n+            JavaType type, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl (partial): key deserializers\n         if (rawType == CLASS_ITERABLE) {\n             // [Issue#199]: Can and should 'upgrade' to a Collection type:\n             TypeFactory tf = ctxt.getTypeFactory();\n-            JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType();\n+            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n+            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n             CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n             // Should we re-introspect beanDesc? For now let's not...\n             return createCollectionDeserializer(ctxt, ct, beanDesc);\n+        }\n+        if (rawType == CLASS_MAP_ENTRY) {\n+            final DeserializationConfig config = ctxt.getConfig();\n+            TypeFactory tf = ctxt.getTypeFactory();\n+            JavaType[] tps = tf.findTypeParameters(type, CLASS_MAP_ENTRY);\n+            JavaType kt, vt;\n+            if (tps == null || tps.length != 2) {\n+                kt = vt = TypeFactory.unknownType();\n+            } else {\n+                kt = tps[0];\n+                vt = tps[1];\n+            }\n+            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n+            if (vts == null) {\n+                vts = findTypeDeserializer(config, vt);\n+            }\n+            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n+            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n+            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n         }\n         String clsName = rawType.getName();\n         if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n         if (rawType == TokenBuffer.class) {\n             return new TokenBufferDeserializer();\n         }\n+        if (AtomicReference.class.isAssignableFrom(rawType)) {\n+            // Must find parameterization\n+            TypeFactory tf = ctxt.getTypeFactory();\n+            JavaType[] params = tf.findTypeParameters(type, AtomicReference.class);\n+            JavaType referencedType;\n+            if (params == null || params.length < 1) { // untyped (raw)\n+                referencedType = TypeFactory.unknownType();\n+            } else {\n+                referencedType = params[0];\n+            }\n+            TypeDeserializer vts = findTypeDeserializer(ctxt.getConfig(), referencedType);\n+            BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);\n+            JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());\n+            return new AtomicReferenceDeserializer(referencedType, vts, deser);\n+        }\n+        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n+        if (deser != null) {\n+            return deser;\n+        }\n         return JdkDeserializers.find(rawType, clsName);\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Helper methods, finding custom deserializers\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n+                    beanDesc, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n+            if (deser != null) {\n+                return (JsonDeserializer<Object>) deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n+                    elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n+                    elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n+                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n+                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods, value/content/key type introspection\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n \n import java.lang.reflect.Type;\n import java.util.*;\n-import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n import com.fasterxml.jackson.databind.deser.impl.*;\n-import com.fasterxml.jackson.databind.deser.std.AtomicReferenceDeserializer;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n-import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;\n     \n     /*\n     /**********************************************************\n-    /* Overrides for super-class methods used for finding\n-    /* custom deserializers\n-    /**********************************************************\n-     */\n-\n-    // Note: NOT overriding, superclass has no matching method\n-    @SuppressWarnings(\"unchecked\")\n-    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n-            if (deser != null) {\n-                return (JsonDeserializer<Object>) deser;\n-            }\n-        }\n-        return null;\n-    }\n-    \n-    /*\n-    /**********************************************************\n     /* DeserializerFactory API implementation\n     /**********************************************************\n      */\n         // note: we do NOT check for custom deserializers here, caller has already\n         // done that\n         JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n+        // Also: better ensure these are post-processable?\n         if (deser != null) {\n-            return deser;\n-        }\n-        \n-        Class<?> cls = type.getRawClass();\n-        // [JACKSON-283]: AtomicReference is a rather special type...\n-        if (AtomicReference.class.isAssignableFrom(cls)) {\n-            // Must find parameterization\n-            TypeFactory tf = ctxt.getTypeFactory();\n-            JavaType[] params = tf.findTypeParameters(type, AtomicReference.class);\n-            JavaType referencedType;\n-            if (params == null || params.length < 1) { // untyped (raw)\n-                referencedType = TypeFactory.unknownType();\n-            } else {\n-                referencedType = params[0];\n-            }\n-            TypeDeserializer valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), referencedType);\n-            BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);\n-            deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());\n-            return new AtomicReferenceDeserializer(referencedType, valueTypeDeser, deser);\n-        }\n-        return findOptionalStdDeserializer(ctxt, type, beanDesc);\n-    }\n-\n-    /**\n-     * Overridable method called after checking all other types.\n-     * \n-     * @since 2.2\n-     */\n-    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt,\n-            JavaType type, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n+            if (_factoryConfig.hasDeserializerModifiers()) {\n+                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                    deser = mod.modifyDeserializer(ctxt.getConfig(), beanDesc, deser);\n+                }\n+            }\n+        }\n+        return deser;\n     }\n     \n     protected JavaType materializeAbstractType(DeserializationContext ctxt,\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapEntryDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+\n+/**\n+ * Basic serializer that can take JSON \"Object\" structure and\n+ * construct a {@link java.util.Map} instance, with typed contents.\n+ *<p>\n+ * Note: for untyped content (one indicated by passing Object.class\n+ * as the type), {@link UntypedObjectDeserializer} is used instead.\n+ * It can also construct {@link java.util.Map}s, but not with specific\n+ * POJO types, only other containers and primitives/wrappers.\n+ */\n+@JacksonStdImpl\n+public class MapEntryDeserializer\n+    extends ContainerDeserializerBase<Map.Entry<Object,Object>>\n+    implements ContextualDeserializer\n+{\n+    private static final long serialVersionUID = 1;\n+\n+    // // Configuration: typing, deserializers\n+\n+    protected final JavaType _type;\n+\n+    /**\n+     * Key deserializer to use; either passed via constructor\n+     * (when indicated by annotations), or resolved when\n+     * {@link #resolve} is called;\n+     */\n+    protected final KeyDeserializer _keyDeserializer;\n+\n+    /**\n+     * Value deserializer.\n+     */\n+    protected final JsonDeserializer<Object> _valueDeserializer;\n+\n+    /**\n+     * If value instances have polymorphic type information, this\n+     * is the type deserializer that can handle it\n+     */\n+    protected final TypeDeserializer _valueTypeDeserializer;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public MapEntryDeserializer(JavaType type,\n+            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n+            TypeDeserializer valueTypeDeser)\n+    {\n+        super(type);\n+        if (type.containedTypeCount() != 2) { // sanity check\n+            throw new IllegalArgumentException(\"Missing generic type information for \"+type);\n+        }\n+        _type = type;\n+        _keyDeserializer = keyDeser;\n+        _valueDeserializer = valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n+    }\n+\n+    /**\n+     * Copy-constructor that can be used by sub-classes to allow\n+     * copy-on-write styling copying of settings of an existing instance.\n+     */\n+    protected MapEntryDeserializer(MapEntryDeserializer src)\n+    {\n+        super(src._type);\n+        _type = src._type;\n+        _keyDeserializer = src._keyDeserializer;\n+        _valueDeserializer = src._valueDeserializer;\n+        _valueTypeDeserializer = src._valueTypeDeserializer;\n+    }\n+\n+    protected MapEntryDeserializer(MapEntryDeserializer src,\n+            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n+            TypeDeserializer valueTypeDeser)\n+    {\n+        super(src._type);\n+        _type = src._type;\n+        _keyDeserializer = keyDeser;\n+        _valueDeserializer = valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n+    }\n+\n+    /**\n+     * Fluent factory method used to create a copy with slightly\n+     * different settings. When sub-classing, MUST be overridden.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected MapEntryDeserializer withResolved(KeyDeserializer keyDeser,\n+            TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser)\n+    {\n+        \n+        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser)\n+                && (_valueTypeDeserializer == valueTypeDeser)) {\n+            return this;\n+        }\n+        return new MapEntryDeserializer(this,\n+                keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Validation, post-processing (ResolvableDeserializer)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to finalize setup of this deserializer,\n+     * when it is known for which property deserializer is needed for.\n+     */\n+    @Override\n+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        KeyDeserializer kd = _keyDeserializer;\n+        if (kd == null) {\n+            kd = ctxt.findKeyDeserializer(_type.containedType(0), property);\n+        } else {\n+            if (kd instanceof ContextualKeyDeserializer) {\n+                kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property);\n+            }\n+        }\n+        JsonDeserializer<?> vd = _valueDeserializer;\n+        vd = findConvertingContentDeserializer(ctxt, property, vd);\n+        if (vd == null) {\n+            vd = ctxt.findContextualValueDeserializer(_type.containedType(1), property);\n+        } else { // if directly assigned, probably not yet contextual, so:\n+            vd = ctxt.handleSecondaryContextualization(vd, property);\n+        }\n+        TypeDeserializer vtd = _valueTypeDeserializer;\n+        if (vtd != null) {\n+            vtd = vtd.forProperty(property);\n+        }\n+        return withResolved(kd, vtd, vd);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* ContainerDeserializerBase API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _type.containedType(1);\n+    }\n+\n+    @Override\n+    public JsonDeserializer<Object> getContentDeserializer() {\n+        return _valueDeserializer;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Map.Entry<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    {\n+        // Ok: must point to START_OBJECT, FIELD_NAME or END_OBJECT\n+        JsonToken t = jp.getCurrentToken();\n+        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n+            // [JACKSON-620] (empty) String may be ok however:\n+            // slightly redundant (since String was passed above), but\n+            return _deserializeFromEmpty(jp, ctxt);\n+        }\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        }\n+        if (t != JsonToken.FIELD_NAME) {\n+            if (t == JsonToken.END_OBJECT) {\n+                throw ctxt.mappingException(\"Can not deserialize a Map.Entry out of empty JSON Object\");\n+            }\n+            throw ctxt.mappingException(handledType(), t);\n+        }\n+        \n+        final KeyDeserializer keyDes = _keyDeserializer;\n+        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n+        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+\n+        final String keyStr = jp.getCurrentName();\n+        Object key = keyDes.deserializeKey(keyStr, ctxt);\n+        Object value = null;\n+        // And then the value...\n+        t = jp.nextToken();\n+        try {\n+            // Note: must handle null explicitly here; value deserializers won't\n+            if (t == JsonToken.VALUE_NULL) {\n+                value = valueDes.getNullValue();\n+            } else if (typeDeser == null) {\n+                value = valueDes.deserialize(jp, ctxt);\n+            } else {\n+                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+            }\n+        } catch (Exception e) {\n+            wrapAndThrow(e, Map.Entry.class, keyStr);\n+        }\n+\n+        // Close, but also verify that we reached the END_OBJECT\n+        t = jp.nextToken();\n+        if (t != JsonToken.END_OBJECT) {\n+            if (t == JsonToken.FIELD_NAME) { // most likely\n+                throw ctxt.mappingException(\"Problem binding JSON into Map.Entry: more than one entry in JSON (second field: '\"+jp.getCurrentName()+\"')\");\n+            }\n+            // how would this occur?\n+            throw ctxt.mappingException(\"Problem binding JSON into Map.Entry: unexpected content after JSON Object entry: \"+t);\n+        }\n+        return new AbstractMap.SimpleEntry<Object,Object>(key, value);\n+    }\n+\n+    @Override\n+    public Map.Entry<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+            Map.Entry<Object,Object> result) throws IOException\n+    {\n+        throw new IllegalStateException(\"Can not update Map.Entry values\");\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        // In future could check current token... for now this should be enough:\n+        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Other public accessors\n+    /**********************************************************\n+     */\n+\n+    @Override public JavaType getValueType() { return _type; }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n         if (java.util.Date.class.isAssignableFrom(raw)) {\n             return DateSerializer.instance;\n         }\n+        if (Map.Entry.class.isAssignableFrom(raw)) {\n+            JavaType kt, vt;\n+            JavaType[] params = prov.getTypeFactory().findTypeParameters(type, Map.Entry.class);\n+            if (params == null || params.length != 2) { // assume that if we don't get 2, they are wrong...\n+                kt = vt = TypeFactory.unknownType();\n+            } else {\n+                kt = params[0];\n+                vt = params[1];\n+            }\n+            return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt);\n+        }\n         if (ByteBuffer.class.isAssignableFrom(raw)) {\n             return new ByteBufferSerializer();\n         }\n     {\n         Class<?> type = javaType.getRawClass();\n \n-        // These need to be in decreasing order of specificity...\n         if (Iterator.class.isAssignableFrom(type)) {\n-            return buildIteratorSerializer(config, javaType, beanDesc, staticTyping);\n+            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class);\n+            JavaType vt = (params == null || params.length != 1) ?\n+                    TypeFactory.unknownType() : params[0];\n+            return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt);\n         }\n         if (Iterable.class.isAssignableFrom(type)) {\n-            return buildIterableSerializer(config, javaType, beanDesc,  staticTyping);\n+            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class);\n+            JavaType vt = (params == null || params.length != 1) ?\n+                    TypeFactory.unknownType() : params[0];\n+            return buildIterableSerializer(config, javaType, beanDesc,  staticTyping, vt);\n         }\n         if (CharSequence.class.isAssignableFrom(type)) {\n             return ToStringSerializer.instance;\n     /**********************************************************\n      */\n \n+    /**\n+     * @since 2.5\n+     */\n     protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,\n-            JavaType type, BeanDescription beanDesc,\n-            boolean staticTyping)\n-        throws JsonMappingException\n-    {\n-        // if there's generic type, it'll be the first contained type\n-        JavaType valueType = type.containedType(0);\n-        if (valueType == null) {\n-            valueType = TypeFactory.unknownType();\n-        }\n-        TypeSerializer vts = createTypeSerializer(config, valueType);\n-        return new IteratorSerializer(valueType, staticTyping, vts, null);\n-    }\n-\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n+            JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType), null);\n+    }\n+\n+    @Deprecated // since 2.5\n+    protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException\n+    {\n+        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class);\n+        JavaType vt = (params == null || params.length != 1) ?\n+                TypeFactory.unknownType() : params[0];\n+        return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); \n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n+            JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType), null);\n+    }\n+\n+    @Deprecated // since 2.5\n     protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,\n             JavaType type, BeanDescription beanDesc,\n             boolean staticTyping)\n         throws JsonMappingException\n     {\n-        // if there's generic type, it'll be the first contained type\n-        JavaType valueType = type.containedType(0);\n-        if (valueType == null) {\n-            valueType = TypeFactory.unknownType();\n-        }\n-        TypeSerializer vts = createTypeSerializer(config, valueType);\n-        return new IterableSerializer(valueType, staticTyping, vts, null);\n-    }\n-    \n+        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class);\n+        JavaType vt = (params == null || params.length != 1) ?\n+                TypeFactory.unknownType() : params[0];\n+        return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); \n+    }\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config,\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n+            JavaType keyType, JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        return new MapEntrySerializer(valueType, keyType, valueType,\n+                staticTyping, createTypeSerializer(config, valueType), null);\n+    }\n+\n     protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config,\n             JavaType type, BeanDescription beanDesc)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n \n     protected ContainerSerializer(Class<T> t) {\n         super(t);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected ContainerSerializer(JavaType fullType) {\n+        super(fullType);\n     }\n     \n     /**\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n+\n+/**\n+ * @since 2.5\n+ */\n+@JacksonStdImpl\n+public class MapEntrySerializer\n+    extends ContainerSerializer<Map.Entry<?,?>>\n+    implements ContextualSerializer\n+{\n+    /**\n+     * Map-valued property being serialized with this instance\n+     */\n+    protected final BeanProperty _property;\n+\n+    /**\n+     * Whether static types should be used for serialization of values\n+     * or not (if not, dynamic runtime type is used)\n+     */\n+    protected final boolean _valueTypeIsStatic;\n+\n+    protected final JavaType _entryType, _keyType, _valueType;\n+\n+    /**\n+     * Key serializer to use, if it can be statically determined\n+     */\n+    protected JsonSerializer<Object> _keySerializer;\n+    \n+    /**\n+     * Value serializer to use, if it can be statically determined\n+     */\n+    protected JsonSerializer<Object> _valueSerializer;\n+\n+    /**\n+     * Type identifier serializer used for values, if any.\n+     */\n+    protected final TypeSerializer _valueTypeSerializer;\n+\n+    /**\n+     * If value type can not be statically determined, mapping from\n+     * runtime value types to serializers are stored in this object.\n+     */\n+    protected PropertySerializerMap _dynamicValueSerializers;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+    \n+    public MapEntrySerializer(JavaType type, JavaType keyType, JavaType valueType,\n+            boolean staticTyping, TypeSerializer vts,\n+            BeanProperty property)\n+    {\n+        super(type);\n+        _entryType = type;\n+        _keyType = keyType;\n+        _valueType = valueType;\n+        _valueTypeIsStatic = staticTyping;\n+        _valueTypeSerializer = vts;\n+        _property = property;\n+        _dynamicValueSerializers = PropertySerializerMap.emptyMap();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected MapEntrySerializer(MapEntrySerializer src, BeanProperty property,\n+            TypeSerializer vts,\n+            JsonSerializer<?> keySer, JsonSerializer<?> valueSer)\n+    {\n+        super(Map.class, false);\n+        _entryType = src._entryType;\n+        _keyType = src._keyType;\n+        _valueType = src._valueType;\n+        _valueTypeIsStatic = src._valueTypeIsStatic;\n+        _valueTypeSerializer = src._valueTypeSerializer;\n+        _keySerializer = (JsonSerializer<Object>) keySer;\n+        _valueSerializer = (JsonSerializer<Object>) valueSer;\n+        _dynamicValueSerializers = src._dynamicValueSerializers;\n+        _property = src._property;\n+    }\n+\n+    @Override\n+    public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) {\n+        return new MapEntrySerializer(this, _property, vts, _keySerializer, _valueSerializer);\n+    }\n+\n+    public MapEntrySerializer withResolved(BeanProperty property,\n+            JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer) {\n+        return new MapEntrySerializer(this, property, _valueTypeSerializer, keySerializer, valueSerializer);\n+    }\n+\n+    @Override\n+    public JsonSerializer<?> createContextual(SerializerProvider provider,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        JsonSerializer<?> ser = null;\n+        JsonSerializer<?> keySer = null;\n+        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+        final AnnotatedMember propertyAcc = (property == null) ? null : property.getMember();\n+\n+        // First: if we have a property, may have property-annotation overrides\n+        if (propertyAcc != null && intr != null) {\n+            Object serDef = intr.findKeySerializer(propertyAcc);\n+            if (serDef != null) {\n+                keySer = provider.serializerInstance(propertyAcc, serDef);\n+            }\n+            serDef = intr.findContentSerializer(propertyAcc);\n+            if (serDef != null) {\n+                ser = provider.serializerInstance(propertyAcc, serDef);\n+            }\n+        }\n+        if (ser == null) {\n+            ser = _valueSerializer;\n+        }\n+        // [Issue#124]: May have a content converter\n+        ser = findConvertingContentSerializer(provider, property, ser);\n+        if (ser == null) {\n+            // 30-Sep-2012, tatu: One more thing -- if explicit content type is annotated,\n+            //   we can consider it a static case as well.\n+            // 20-Aug-2013, tatu: Need to avoid trying to access serializer for java.lang.Object tho\n+            if ((_valueTypeIsStatic && _valueType.getRawClass() != Object.class)\n+                    || hasContentTypeAnnotation(provider, property)) {\n+                ser = provider.findValueSerializer(_valueType, property);\n+            }\n+        } else {\n+            ser = provider.handleSecondaryContextualization(ser, property);\n+        }\n+        if (keySer == null) {\n+            keySer = _keySerializer;\n+        }\n+        if (keySer == null) {\n+            keySer = provider.findKeySerializer(_keyType, property);\n+        } else {\n+            keySer = provider.handleSecondaryContextualization(keySer, property);\n+        }\n+        MapEntrySerializer mser = withResolved(property, keySer, ser);\n+        // but note: no filtering, ignored entries or sorting (unlike Maps)\n+        return mser;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _valueType;\n+    }\n+\n+    @Override\n+    public JsonSerializer<?> getContentSerializer() {\n+        return _valueSerializer;\n+    }\n+\n+    @Override\n+    public boolean hasSingleElement(Map.Entry<?,?> value) {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isEmpty(Entry<?, ?> value) {\n+        return (value == null);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void serialize(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException\n+    {\n+        jgen.writeStartObject();\n+        if (_valueSerializer != null) {\n+            serializeUsing(value, jgen, provider, _valueSerializer);\n+        } else {\n+            serializeDynamic(value, jgen, provider);\n+        }\n+        jgen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer) throws IOException\n+    {\n+        typeSer.writeTypePrefixForObject(value, jgen);\n+        if (_valueSerializer != null) {\n+            serializeUsing(value, jgen, provider, _valueSerializer);\n+        } else {\n+            serializeDynamic(value, jgen, provider);\n+        }\n+        typeSer.writeTypeSuffixForObject(value, jgen);\n+    }\n+\n+    protected void serializeDynamic(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException\n+    {\n+        final JsonSerializer<Object> keySerializer = _keySerializer;\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n+        final TypeSerializer vts = _valueTypeSerializer;\n+\n+        PropertySerializerMap serializers = _dynamicValueSerializers;\n+\n+        Object valueElem = value.getValue();\n+        Object keyElem = value.getKey();\n+        if (keyElem == null) {\n+            provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n+        } else {\n+            // [JACKSON-314] skip entries with null values?\n+            if (skipNulls && valueElem == null) return;\n+            keySerializer.serialize(keyElem, jgen, provider);\n+        }\n+        // And then value\n+        if (valueElem == null) {\n+            provider.defaultSerializeNull(jgen);\n+        } else {\n+            Class<?> cc = valueElem.getClass();\n+            JsonSerializer<Object> ser = serializers.serializerFor(cc);\n+            if (ser == null) {\n+                if (_valueType.hasGenericTypes()) {\n+                    ser = _findAndAddDynamic(serializers,\n+                            provider.constructSpecializedType(_valueType, cc), provider);\n+                } else {\n+                    ser = _findAndAddDynamic(serializers, cc, provider);\n+                }\n+                serializers = _dynamicValueSerializers;\n+            }\n+            try {\n+                if (vts == null) {\n+                    ser.serialize(valueElem, jgen, provider);\n+                } else {\n+                    ser.serializeWithType(valueElem, jgen, provider, vts);\n+                }\n+            } catch (Exception e) {\n+                // [JACKSON-55] Need to add reference information\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method called to serialize fields, when the value type is statically known,\n+     * so that value serializer is passed and does not need to be fetched from\n+     * provider.\n+     */\n+    protected void serializeUsing(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider,\n+            JsonSerializer<Object> ser)\n+        throws IOException, JsonGenerationException\n+    {\n+        final JsonSerializer<Object> keySerializer = _keySerializer;\n+        final TypeSerializer vts = _valueTypeSerializer;\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n+\n+        Object valueElem = value.getValue();\n+        Object keyElem = value.getKey();\n+        if (keyElem == null) {\n+            provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n+        } else {\n+            // [JACKSON-314] also may need to skip entries with null values\n+            if (skipNulls && valueElem == null) return;\n+            keySerializer.serialize(keyElem, jgen, provider);\n+        }\n+        if (valueElem == null) {\n+            provider.defaultSerializeNull(jgen);\n+        } else {\n+            try {\n+                if (vts == null) {\n+                    ser.serialize(valueElem, jgen, provider);\n+                } else {\n+                    ser.serializeWithType(valueElem, jgen, provider, vts);\n+                }\n+            } catch (Exception e) {\n+                // [JACKSON-55] Need to add reference information\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            Class<?> type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSecondarySerializer(type, provider, _property);\n+        if (map != result.map) {\n+            _dynamicValueSerializers = result.map;\n+        }\n+        return result.serializer;\n+    }\n+\n+    protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            JavaType type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSecondarySerializer(type, provider, _property);\n+        if (map != result.map) {\n+            _dynamicValueSerializers = result.map;\n+        }\n+        return result.serializer;\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n         return new MapSerializer(this, vts);\n     }\n \n-    @Deprecated // since 2.3\n-    public MapSerializer withResolved(BeanProperty property,\n-            JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored) {\n-        return withResolved(property, keySerializer, valueSerializer, ignored, _sortKeys);\n-    }\n-\n     /**\n      * @since 2.4\n      */\n      */\n     public MapSerializer withFilterId(Object filterId) {\n         return (_filterId == filterId) ? this : new MapSerializer(this, filterId, _sortKeys);\n-    }\n-\n-    /**\n-     * @deprecated Since 2.3 use the method that takes `filterId`\n-     */\n-    @Deprecated\n-    public static MapSerializer construct(String[] ignoredList, JavaType mapType,\n-            boolean staticValueType, TypeSerializer vts,\n-            JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer)\n-    {\n-        return construct(ignoredList, mapType, staticValueType, vts,\n-                keySerializer, valueSerializer, null);\n     }\n \n     /**\n     /* JsonSerializer implementation\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public void serialize(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n         if (index == 0) return \"E\";\n         return null;\n     }\n+\n+    /**\n+     * No parameterization for array types themselves; element type\n+     * may obviously have parameterization.\n+     */\n+    @Override\n+    public Class<?> getParameterSource() {\n+        return null;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n         return null;\n     }\n \n+    // TODO: should allow construction of instances that do refer\n+    //  to parameterization, since it is NOT Collection\n+    @Override\n+    public Class<?> getParameterSource() {\n+        return null;\n+    }\n+    \n     @Override\n     public StringBuilder getErasedSignature(StringBuilder sb) {\n         return _classSignature(_class, sb, true);\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\n         return new CollectionType(_class, _elementType.withStaticTyping(),\n                 _valueHandler, _typeHandler, true);\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden accessors\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public Class<?> getParameterSource() {\n+        return java.util.Collection.class;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n         return null;\n     }\n \n+    // TODO: should allow construction of instances that do refer\n+    //  to parameterization, since it is NOT Map\n+    @Override\n+    public Class<?> getParameterSource() {\n+        return null;\n+    }\n+    \n     @Override\n     public StringBuilder getErasedSignature(StringBuilder sb) {\n         return _classSignature(_class, sb, true);\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n \n     /*\n     /**********************************************************\n+    /* Overridden accessors\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public Class<?> getParameterSource() {\n+        return java.util.Map.class;\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Extended API\n     /**********************************************************\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n     private static final long serialVersionUID = -800374828948534376L;\n \n     /**\n+     * In case there are resolved type parameters, this field stores reference\n+     * to that type. It must be {@link #getRawClass()} or its supertype.\n+     * \n+     * @since 2.5\n+     */\n+    protected final Class<?> _typeParametersFor;\n+    \n+    /**\n      * Generic type arguments for this type.\n      */\n     protected final JavaType[] _typeParameters;\n      */\n \n     protected SimpleType(Class<?> cls) {\n-        this(cls, null, null, null, null, false);\n-    }\n-\n+        this(cls, null, null, null, null, false, null);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5 use variant that takes one more argument\n+     */\n+    @Deprecated\n     protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams,\n             Object valueHandler, Object typeHandler, boolean asStatic)\n+    {\n+        this(cls, typeNames, typeParams, valueHandler, typeHandler, asStatic, null);\n+    }\n+\n+    /**\n+     * \n+     * @param parametersFrom Interface or abstract class implemented by this type,\n+     *   and for which type parameters apply. It may be <code>cls</code> itself,\n+     *   but more commonly it is one of its supertypes.\n+     */\n+    protected SimpleType(Class<?> cls,\n+            String[] typeNames, JavaType[] typeParams,\n+            Object valueHandler, Object typeHandler, boolean asStatic,\n+            Class<?> parametersFrom)\n     {\n         super(cls, 0, valueHandler, typeHandler, asStatic);\n         if (typeNames == null || typeNames.length == 0) {\n             _typeNames = typeNames;\n             _typeParameters = typeParams;\n         }\n+        _typeParametersFor = parametersFrom;\n     }\n \n     /**\n      * not in same package\n      */\n     public static SimpleType constructUnsafe(Class<?> raw) {\n-        return new SimpleType(raw, null, null, null, null, false);\n+        return new SimpleType(raw, null, null, null, null, false, null);\n     }\n \n     @Override\n     {\n         // Should we check that there is a sub-class relationship?\n         return new SimpleType(subclass, _typeNames, _typeParameters, _valueHandler, _typeHandler,\n-                _asStatic);\n+                _asStatic, _typeParametersFor);\n     }\n \n     @Override\n     @Override\n     public SimpleType withTypeHandler(Object h)\n     {\n-        return new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, h, _asStatic);\n+        return new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, h, _asStatic, _typeParametersFor);\n     }\n \n     @Override\n         if (h == _valueHandler) {\n             return this;\n         }\n-        return new SimpleType(_class, _typeNames, _typeParameters, h, _typeHandler, _asStatic);\n+        return new SimpleType(_class, _typeNames, _typeParameters, h, _typeHandler, _asStatic, _typeParametersFor);\n     }\n     \n     @Override\n     @Override\n     public SimpleType withStaticTyping() {\n         return _asStatic ? this : new SimpleType(_class,\n-                _typeNames, _typeParameters, _valueHandler, _typeHandler, _asStatic);\n+                _typeNames, _typeParameters, _valueHandler, _typeHandler, _asStatic, _typeParametersFor);\n     }\n \n     @Override\n         }\n         return _typeNames[index];\n     }\n+\n+    @Override\n+    public Class<?> getParameterSource() {\n+        return _typeParametersFor;\n+    }\n     \n     @Override\n     public StringBuilder getErasedSignature(StringBuilder sb) {\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n          * case actually fully works; and former mostly works. In future may need to\n          * rewrite former part, which requires changes to JavaType as well.\n          */\n-        Class<?> raw = type.getRawClass();\n-        if (raw == expType) {\n+        if (expType == type.getParameterSource()) {\n             // Direct type info; good since we can return it as is\n             int count = type.containedTypeCount();\n             if (count == 0) return null;\n          * if/when there are problems; current handling is an improvement over earlier\n          * code.\n          */\n+        Class<?> raw = type.getRawClass();\n         return findTypeParameters(raw, expType, new TypeBindings(this, type));\n     }\n \n     public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n         return findTypeParameters(clz, expType, new TypeBindings(this, clz));\n     }\n-    \n+\n     public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)\n     {\n         // First: find full inheritance chain\n \n         // simple class?\n         if (type instanceof Class<?>) {\n-            Class<?> cls = (Class<?>) type;\n-            resultType = _fromClass(cls, context);\n+            resultType = _fromClass((Class<?>) type, context);\n         }\n         // But if not, need to start resolving.\n         else if (type instanceof ParameterizedType) {\n     \n     /**\n      * Method for constructing a type instance with specified parameterization.\n-     */\n-    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes)\n+     * \n+     * @deprecated Since 2.5, use variant that takes one more argument\n+     */\n+    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n+        return constructSimpleType(rawType, rawType, parameterTypes);\n+    }\n+    \n+    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n+            JavaType[] parameterTypes)\n     {\n         // Quick sanity check: must match numbers of types with expected...\n-        TypeVariable<?>[] typeVars = rawType.getTypeParameters();\n+        TypeVariable<?>[] typeVars = parameterTarget.getTypeParameters();\n         if (typeVars.length != parameterTypes.length) {\n             throw new IllegalArgumentException(\"Parameter type mismatch for \"+rawType.getName()\n-                    +\": expected \"+typeVars.length+\" parameters, was given \"+parameterTypes.length);\n+                    +\" (and target \"+parameterTarget.getName()+\"): expected \"+typeVars.length\n+                    +\" parameters, was given \"+parameterTypes.length);\n         }\n         String[] names = new String[typeVars.length];\n         for (int i = 0, len = typeVars.length; i < len; ++i) {\n             names[i] = typeVars[i].getName();\n         }\n-        JavaType resultType = new SimpleType(rawType, names, parameterTypes, null, null, false);\n-        return resultType;\n+        return new SimpleType(rawType, names, parameterTypes, null, null, false, parameterTarget);\n     } \n \n     /**\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     */\n-    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses)\n+     * \n+     * @param parametrized Type-erased type of instance being constructed\n+     * @param parametersFor class or interface for which type parameters are applied; either\n+     *   <code>parametrized</code> or one of its supertypes\n+     * @parameterClasses Type parameters to apply\n+     * \n+     * @since 2.5\n+     */\n+    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n+            Class<?>... parameterClasses)\n     {\n         int len = parameterClasses.length;\n         JavaType[] pt = new JavaType[len];\n         for (int i = 0; i < len; ++i) {\n             pt[i] = _fromClass(parameterClasses[i], null);\n         }\n-        return constructParametricType(parametrized, pt);\n+        return constructParametrizedType(parametrized, parametersFor, pt);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n+     */\n+    @Deprecated\n+    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n+        return constructParametrizedType(parametrized, parametrized, parameterClasses);\n     }\n \n     /**\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     */\n-    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes)\n+     * \n+     * \n+     * @param parametrized Actual full type\n+     * @param parametersFor class or interface for which type parameters are applied; either\n+     *   <code>parametrized</code> or one of its supertypes\n+     * @parameterClasses Type parameters to apply\n+     * \n+     * @since 2.5\n+     */\n+    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n+            JavaType... parameterTypes)\n     {\n         JavaType resultType;\n         \n             }\n             resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);\n         } else {\n-            resultType = constructSimpleType(parametrized, parameterTypes);\n+            resultType = constructSimpleType(parametrized, parametersFor, parameterTypes);\n         }\n         return resultType;\n     }\n \n+    /**\n+     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n+     */\n+    @Deprecated\n+    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {\n+        return constructParametrizedType(parametrized, parametrized, parameterTypes);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Direct factory methods for \"raw\" variants, used when\n         } else if (Collection.class.isAssignableFrom(clz)) {\n             result =  _collectionType(clz);\n         } else {\n-            result = new SimpleType(clz);\n+            // 29-Sep-2014, tatu: We may want to pre-resolve well-known generic types\n+            if (Map.Entry.class.isAssignableFrom(clz)) {\n+                JavaType[] pts = this.findTypeParameters(clz, Map.Entry.class);\n+                JavaType kt, vt;\n+                if (pts == null || pts.length != 2) {\n+                    kt = vt = unknownType();\n+                } else {\n+                    kt = pts[0];\n+                    vt = pts[1];\n+                }\n+                result = constructSimpleType(clz, Map.Entry.class, new JavaType[] { kt, vt });\n+            } else {\n+                result = new SimpleType(clz);\n+            }\n         }\n         _typeCache.put(key, result); // cache object syncs\n         return result;\n         if (paramTypes.size() == 0) {\n             return new SimpleType(clz);\n         }\n+        // Hmmh. Does this actually occur?\n         JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);\n-        return constructSimpleType(clz, pt);\n+        return constructSimpleType(clz, clz, pt);\n     }\n     \n     /**\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n     public static enum ConcreteType implements ITestType {\n         ONE, TWO;\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Test methods, untyped (Object valued) maps\n      * Simple test to ensure that @JsonDeserialize.using is\n      * recognized\n      */\n-    public void testMapWithDeserializer() throws IOException\n+    public void testMapWithDeserializer() throws Exception\n     {\n         CustomMap result = MAPPER.readValue(quote(\"xyz\"), CustomMap.class);\n         assertEquals(1, result.size());\n         assertEquals(\"xyz\", result.get(\"x\"));\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Test methods, annotated Map.Entry\n+    /**********************************************************\n+     */\n+\n+    public void testMapEntrySimpleTypes() throws Exception\n+    {\n+        List<Map.Entry<String,Long>> stuff = MAPPER.readValue(aposToQuotes(\"[{'a':15},{'b':42}]\"),\n+                new TypeReference<List<Map.Entry<String,Long>>>() { });\n+        assertNotNull(stuff);\n+        assertEquals(2, stuff.size());\n+        assertNotNull(stuff.get(1));\n+        assertEquals(\"b\", stuff.get(1).getKey());\n+        assertEquals(Long.valueOf(42), stuff.get(1).getValue());\n+    }\n+\n+    public void testMapEntryWithStringBean() throws Exception\n+    {\n+        List<Map.Entry<Integer,StringWrapper>> stuff = MAPPER.readValue(aposToQuotes(\"[{'28':'Foo'},{'13':'Bar'}]\"),\n+                new TypeReference<List<Map.Entry<Integer,StringWrapper>>>() { });\n+        assertNotNull(stuff);\n+        assertEquals(2, stuff.size());\n+        assertNotNull(stuff.get(1));\n+        assertEquals(Integer.valueOf(13), stuff.get(1).getKey());\n+        \n+        StringWrapper sw = stuff.get(1).getValue();\n+        assertEquals(\"Bar\", sw.str);\n+    }\n+\n+    public void testMapEntryFail() throws Exception\n+    {\n+        try {\n+            /*List<Map.Entry<Integer,StringWrapper>> stuff =*/ MAPPER.readValue(aposToQuotes(\"[{'28':'Foo','13':'Bar'}]\"),\n+                    new TypeReference<List<Map.Entry<Integer,StringWrapper>>>() { });\n+            fail(\"Should not have passed\");\n+        } catch (Exception e) {\n+            verifyException(e, \"more than one entry in JSON\");\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Error tests\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestAutoDetect.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+\n+public class TestAutoDetect\n+    extends BaseMapTest\n+{\n+    static class PrivateBean {\n+        String a;\n+\n+        private PrivateBean() { }\n+\n+        private PrivateBean(String a) { this.a = a; }\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Unit tests\n+    /********************************************************\n+     */\n+    \n+    public void testPrivateCtor() throws Exception\n+    {\n+        // first, default settings, with which construction works ok\n+        ObjectMapper m = new ObjectMapper();\n+        PrivateBean bean = m.readValue(\"\\\"abc\\\"\", PrivateBean.class);\n+        assertEquals(\"abc\", bean.a);\n+\n+        // then by increasing visibility requirement:\n+        m = new ObjectMapper();\n+        // note: clumsy code, but needed for Eclipse/JDK1.5 compilation (not for 1.6)\n+        VisibilityChecker<?> vc = m.getVisibilityChecker();\n+        vc = vc.withCreatorVisibility(JsonAutoDetect.Visibility.PUBLIC_ONLY);\n+        m.setVisibilityChecker(vc);\n+        try {\n+            m.readValue(\"\\\"abc\\\"\", PrivateBean.class);\n+            fail(\"Expected exception for missing constructor\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"no single-String constructor/factory\");\n+        }\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedContainerSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedContainerSerialization.java\n     {\n             ArrayList<Animal> animals = new ArrayList<Animal>();\n             animals.add(new Dog(\"Spot\"));\n-            JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class);\n+            JavaType rootType = TypeFactory.defaultInstance().constructParametrizedType(Iterator.class, Iterator.class, Animal.class);\n             String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator());\n             if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n                 fail(\"No polymorphic type retained, should be; JSON = '\"+json+\"'\");\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n     {\n         Dog dog = new Dog(\"Fluffy\", 3);\n         ContainerWithGetter<Animal> c2 = new ContainerWithGetter<Animal>(dog);\n-        String json = MAPPER.writerWithType(MAPPER.getTypeFactory().constructParametricType(ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);\n+        String json = MAPPER.writerWithType(MAPPER.getTypeFactory().constructParametrizedType(ContainerWithGetter.class, ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);\n         if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n             fail(\"polymorphic type not kept, result == \"+json+\"; should contain 'object-type':'...'\");\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n public class TestMapSerialization\n     extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n     /**\n      * Class needed for testing [JACKSON-220]\n      */\n         }\n     }\n \n+    // [Databind#565]: Support ser/deser of Map.Entry\n+    static class StringIntMapEntry implements Map.Entry<String,Integer> {\n+        public final String k;\n+        public final Integer v;\n+        public StringIntMapEntry(String k, Integer v) {\n+            this.k = k;\n+            this.v = v;\n+        }\n+\n+        @Override\n+        public String getKey() {\n+            return k;\n+        }\n+\n+        @Override\n+        public Integer getValue() {\n+            return v;\n+        }\n+\n+        @Override\n+        public Integer setValue(Integer value) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Test methods\n         assertEquals(\"{\\\"a\\\":6,\\\"b\\\":3}\", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map));\n     }\n \n-    // [#335[\n+    // [Databind#335]\n     public void testOrderByKeyViaProperty() throws IOException\n     {\n         MapOrderingBean input = new MapOrderingBean(\"c\", \"b\", \"a\");\n         String json = MAPPER.writeValueAsString(input);\n         assertEquals(aposToQuotes(\"{'map':{'a':3,'b':2,'c':1}}\"), json);\n     }        \n+\n+    // [Databind#565]\n+    public void testEnumMapEntry() throws IOException\n+    {\n+        StringIntMapEntry input = new StringIntMapEntry(\"answer\", 42);\n+        String json = MAPPER.writeValueAsString(input);\n+        assertEquals(aposToQuotes(\"{'answer':42}\"), json);\n+\n+        StringIntMapEntry[] array = new StringIntMapEntry[] { input };\n+        json = MAPPER.writeValueAsString(array);\n+        assertEquals(aposToQuotes(\"[{'answer':42}]\"), json);\n+    }        \n }\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayWithBuilder.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayWithBuilder.java\n     {\n         public int x, y;\n         \n-        @SuppressWarnings(\"hiding\")\n         public SimpleBuilderXY withX(int x) {\n             this.x = x;\n             return this;\n         }\n \n-        @SuppressWarnings(\"hiding\")\n         public SimpleBuilderXY withY(int y) {\n             this.y = y;\n             return this;\n--- a/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n         // first, simple class based\n-        JavaType t = tf.constructParametricType(ArrayList.class, String.class); // ArrayList<String>\n+        JavaType t = tf.constructParametrizedType(ArrayList.class, Collection.class, String.class); // ArrayList<String>\n         assertEquals(CollectionType.class, t.getClass());\n         JavaType strC = tf.constructType(String.class);\n         assertEquals(1, t.containedTypeCount());\n         assertNull(t.containedType(1));\n \n         // Then using JavaType\n-        JavaType t2 = tf.constructParametricType(Map.class, strC, t); // Map<String,ArrayList<String>>\n+        JavaType t2 = tf.constructParametrizedType(Map.class, Map.class, strC, t); // Map<String,ArrayList<String>>\n         // should actually produce a MapType\n         assertEquals(MapType.class, t2.getClass());\n         assertEquals(2, t2.containedTypeCount());\n         assertNull(t2.containedType(2));\n \n         // and then custom generic type as well\n-        JavaType custom = tf.constructParametricType(SingleArgGeneric.class, String.class);\n+        JavaType custom = tf.constructParametrizedType(SingleArgGeneric.class, SingleArgGeneric.class,\n+                String.class);\n         assertEquals(SimpleType.class, custom.getClass());\n         assertEquals(1, custom.containedTypeCount());\n         assertEquals(strC, custom.containedType(0));\n         // And finally, ensure that we can't create invalid combinations\n         try {\n             // Maps must take 2 type parameters, not just one\n-            tf.constructParametricType(Map.class, strC);\n+            tf.constructParametrizedType(Map.class, Map.class, strC);\n         } catch (IllegalArgumentException e) {\n             verifyException(e, \"Need exactly 2 parameter types for Map types\");\n         }\n \n         try {\n             // Type only accepts one type param\n-            tf.constructParametricType(SingleArgGeneric.class, strC, strC);\n+            tf.constructParametrizedType(SingleArgGeneric.class, SingleArgGeneric.class, strC, strC);\n         } catch (IllegalArgumentException e) {\n             verifyException(e, \"expected 1 parameters, was given 2\");\n         }\n         assertNull(sup2.getSuperType());\n     }\n \n+    private int _countSupers(HierarchicType t)\n+    {\n+        int depth = 0;\n+        for (HierarchicType sup = t.getSuperType(); sup != null; sup = sup.getSuperType()) {\n+            ++depth;\n+        }\n+        return depth;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests: map/collection type parameter resolution\n+    /**********************************************************\n+     */\n+\n+    public void testMapTypesSimple()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(new TypeReference<Map<String,Boolean>>() { });\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Boolean.class), mapType.getContentType());\n+    }\n+\n+    public void testMapTypesRaw()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(HashMap.class);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(Object.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Object.class), mapType.getContentType());        \n+    }\n+\n+    public void testMapTypesAdvanced()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(MyMap.class);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n+\n+        type = tf.constructType(MapInterface.class);\n+        mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n+\n+        type = tf.constructType(MyStringIntMap.class);\n+        mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n+    }\n+\n+    /**\n+     * Specific test to verify that complicate name mangling schemes\n+     * do not fool type resolver\n+     */\n+    public void testMapTypesSneaky()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(IntLongMap.class);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n+    }    \n+    \n+    /**\n+     * Plus sneaky types may be found via introspection as well.\n+     */\n+    public void testSneakyFieldTypes() throws Exception\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        Field field = SneakyBean.class.getDeclaredField(\"intMap\");\n+        JavaType type = tf.constructType(field.getGenericType());\n+        assertTrue(type instanceof MapType);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n+\n+        field = SneakyBean.class.getDeclaredField(\"longList\");\n+        type = tf.constructType(field.getGenericType());\n+        assertTrue(type instanceof CollectionType);\n+        CollectionType collectionType = (CollectionType) type;\n+        assertEquals(tf.constructType(Long.class), collectionType.getContentType());\n+    }    \n+    \n+    /**\n+     * Looks like type handling actually differs for properties, too.\n+     */\n+    public void testSneakyBeanProperties() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringLongMapBean bean = mapper.readValue(\"{\\\"value\\\":{\\\"a\\\":123}}\", StringLongMapBean.class);\n+        assertNotNull(bean);\n+        Map<String,Long> map = bean.value;\n+        assertEquals(1, map.size());\n+        assertEquals(Long.valueOf(123), map.get(\"a\"));\n+\n+        StringListBean bean2 = mapper.readValue(\"{\\\"value\\\":[\\\"...\\\"]}\", StringListBean.class);\n+        assertNotNull(bean2);\n+        List<String> list = bean2.value;\n+        assertSame(GenericList.class, list.getClass());\n+        assertEquals(1, list.size());\n+        assertEquals(\"...\", list.get(0));\n+    }\n+\n+    public void testSneakySelfRefs() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new SneakyBean2());\n+        assertEquals(\"{\\\"foobar\\\":null}\", json);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests: handling of specific JDK types\n+    /**********************************************************\n+     */\n+\n     public void testAtomicArrayRefParameterDetection()\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n         assertNull(sub.getSuperType());\n     }\n \n-    private int _countSupers(HierarchicType t)\n-    {\n-        int depth = 0;\n-        for (HierarchicType sup = t.getSuperType(); sup != null; sup = sup.getSuperType()) {\n-            ++depth;\n-        }\n-        return depth;\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Unit tests: map/collection type parameter resolution\n-    /**********************************************************\n-     */\n-\n-    public void testMapTypesSimple()\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        JavaType type = tf.constructType(new TypeReference<Map<String,Boolean>>() { });\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Boolean.class), mapType.getContentType());\n-    }\n-\n-    public void testMapTypesRaw()\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        JavaType type = tf.constructType(HashMap.class);\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(Object.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Object.class), mapType.getContentType());        \n-    }\n-\n-    public void testMapTypesAdvanced()\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        JavaType type = tf.constructType(MyMap.class);\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n-\n-        type = tf.constructType(MapInterface.class);\n-        mapType = (MapType) type;\n-        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n-\n-        type = tf.constructType(MyStringIntMap.class);\n-        mapType = (MapType) type;\n-        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n-    }\n-\n-    /**\n-     * Specific test to verify that complicate name mangling schemes\n-     * do not fool type resolver\n-     */\n-    public void testMapTypesSneaky()\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        JavaType type = tf.constructType(IntLongMap.class);\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n-    }    \n-    \n-    /**\n-     * Plus sneaky types may be found via introspection as well.\n-     */\n-    public void testSneakyFieldTypes() throws Exception\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        Field field = SneakyBean.class.getDeclaredField(\"intMap\");\n-        JavaType type = tf.constructType(field.getGenericType());\n-        assertTrue(type instanceof MapType);\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n-\n-        field = SneakyBean.class.getDeclaredField(\"longList\");\n-        type = tf.constructType(field.getGenericType());\n-        assertTrue(type instanceof CollectionType);\n-        CollectionType collectionType = (CollectionType) type;\n-        assertEquals(tf.constructType(Long.class), collectionType.getContentType());\n-    }    \n-    \n-    /**\n-     * Looks like type handling actually differs for properties, too.\n-     */\n-    public void testSneakyBeanProperties() throws Exception\n-    {\n-        ObjectMapper mapper = new ObjectMapper();\n-        StringLongMapBean bean = mapper.readValue(\"{\\\"value\\\":{\\\"a\\\":123}}\", StringLongMapBean.class);\n-        assertNotNull(bean);\n-        Map<String,Long> map = bean.value;\n-        assertEquals(1, map.size());\n-        assertEquals(Long.valueOf(123), map.get(\"a\"));\n-\n-        StringListBean bean2 = mapper.readValue(\"{\\\"value\\\":[\\\"...\\\"]}\", StringListBean.class);\n-        assertNotNull(bean2);\n-        List<String> list = bean2.value;\n-        assertSame(GenericList.class, list.getClass());\n-        assertEquals(1, list.size());\n-        assertEquals(\"...\", list.get(0));\n-    }\n-    \n     public void testAtomicArrayRefParameters()\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n         assertEquals(tf.constructType(long[].class), params[0]);\n     }\n \n-    public void testSneakySelfRefs() throws Exception\n-    {\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(new SneakyBean2());\n-        assertEquals(\"{\\\"foobar\\\":null}\", json);\n-    }\n-\n+    static abstract class StringIntMapEntry implements Map.Entry<String,Integer> { }\n+    \n+    public void testMapEntryResolution()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType t = tf.constructType(StringIntMapEntry.class);\n+        assertTrue(t.hasGenericTypes());\n+        assertEquals(2, t.containedTypeCount());\n+        assertEquals(String.class, t.containedType(0).getRawClass());\n+        assertEquals(Integer.class, t.containedType(1).getRawClass());\n+        // NOTE: no key/content types, at least not as of 2.5\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Unit tests: construction of \"raw\" types\n--- a/src/test/java/com/fasterxml/jackson/failing/TestSetterlessProperties501.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestSetterlessProperties501.java\n \n import com.fasterxml.jackson.databind.*;\n \n-/**\n- * Unit tests for verifying that feature requested\n- * via [JACKSON-88] (\"setterless collections\") work as\n- * expected, similar to how Collections and Maps work\n- * with JAXB.\n- */\n public class TestSetterlessProperties501\n     extends BaseMapTest\n {", "timestamp": 1412046912, "metainfo": ""}