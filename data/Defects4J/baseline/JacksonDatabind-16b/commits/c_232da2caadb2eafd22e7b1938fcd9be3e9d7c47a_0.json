{"sha": "232da2caadb2eafd22e7b1938fcd9be3e9d7c47a", "log": "Changes to work with new and improved TreeNode", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n import java.math.BigInteger;\n import java.util.*;\n \n-import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.core.TreeNode;\n import com.fasterxml.jackson.databind.node.JsonNodeType;\n import com.fasterxml.jackson.databind.util.EmptyIterator;\n      *    children); or, for immutable leaf nodes, node itself.\n      */\n     public abstract <T extends JsonNode> T deepCopy();\n-    \n-    /*\n-    /**********************************************************\n-    /* Public API, type introspection\n-    /**********************************************************\n-     */\n-\n-    // // First high-level division between values, containers and \"missing\"\n-\n-    /**\n-     * Return the type of this node\n-     *\n-     * @return the node type as a {@link JsonNodeType} enum value\n-     */\n-    public abstract JsonNodeType getNodeType();\n-\n-    /**\n-     * Method that returns true for all value nodes: ones that \n-     * are not containers, and that do not represent \"missing\" nodes\n-     * in the path. Such value nodes represent String, Number, Boolean\n-     * and null values from JSON.\n-     *<p>\n-     * Note: one and only one of methods {@link #isValueNode},\n-     * {@link #isContainerNode} and {@link #isMissingNode} ever\n-     * returns true for any given node.\n-     */\n+\n+    /*\n+    /**********************************************************\n+    /* TreeNode implementation\n+    /**********************************************************\n+     */\n+\n+//    public abstract JsonToken asToken();\n+\n+//    public abstract JsonParser.NumberType numberType();\n+\n+//    public abstract JsonParser traverse();\n+    \n+    @Override\n+    public int size() { return 0; }\n+\n+    @Override\n     public final boolean isValueNode()\n     {\n         switch (getNodeType()) {\n         }\n     }\n \n-    /**\n-     * Method that returns true for container nodes: Arrays and Objects.\n-     *<p>\n-     * Note: one and only one of methods {@link #isValueNode},\n-     * {@link #isContainerNode} and {@link #isMissingNode} ever\n-     * returns true for any given node.\n-     */\n-    public final boolean isContainerNode()\n-    {\n+    @Override\n+    public final boolean isContainerNode() {\n         final JsonNodeType type = getNodeType();\n         return type == JsonNodeType.OBJECT || type == JsonNodeType.ARRAY;\n     }\n \n-    /**\n-     * Method that returns true for \"virtual\" nodes which represent\n-     * missing entries constructed by path accessor methods when\n-     * there is no actual node matching given criteria.\n-     *<p>\n-     * Note: one and only one of methods {@link #isValueNode},\n-     * {@link #isContainerNode} and {@link #isMissingNode} ever\n-     * returns true for any given node.\n-     */\n-    public final boolean isMissingNode()\n-    {\n+    @Override\n+    public final boolean isMissingNode() {\n         return getNodeType() == JsonNodeType.MISSING;\n     }\n \n-    // // Then more specific type introspection\n-    // // (along with defaults to be overridden)\n-\n-    /**\n-     * @return True if this node represents JSON Array\n-     */\n-    public final boolean isArray()\n-    {\n+    @Override\n+    public final boolean isArray() {\n         return getNodeType() == JsonNodeType.ARRAY;\n     }\n \n-    /**\n-     * @return True if this node represents JSON Object\n-     */\n-    public final boolean isObject()\n-    {\n+    @Override\n+    public final boolean isObject() {\n         return getNodeType() == JsonNodeType.OBJECT;\n     }\n-\n-    /**\n-     * Method that can be used to check if the node is a wrapper\n-     * for a POJO (\"Plain Old Java Object\" aka \"bean\".\n-     * Returns true only for\n-     * instances of <code>POJONode</code>.\n-     *\n-     * @return True if this node wraps a POJO\n-     */\n-    public final boolean isPojo()\n-    {\n-        return getNodeType() == JsonNodeType.POJO;\n-    }\n-\n-    /**\n-     * @return True if this node represents a numeric JSON\n-     *   value\n-     */\n-    public final boolean isNumber()\n-    {\n-        return getNodeType() == JsonNodeType.NUMBER;\n-    }\n-\n-    /**\n-     * \n-     * @return True if this node represents an integral (integer)\n-     *   numeric JSON value\n-     */\n-    public boolean isIntegralNumber() { return false; }\n-\n-    /**\n-     * @return True if this node represents a non-integral\n-     *   numeric JSON value\n-     */\n-    public boolean isFloatingPointNumber() { return false; }\n-\n-    /**\n-     * Method that can be used to check whether contained value\n-     * is a number represented as Java <code>int</code>.\n-     * Note, however, that even if this method returns false, it\n-     * is possible that conversion would be possible from other numeric\n-     * types -- to check if this is possible, use\n-     * {@link #canConvertToInt()} instead.\n-     * \n-     * @return True if the value contained by this node is stored as Java int\n-     */\n-    public boolean isInt() { return false; }\n-\n-    /**\n-     * Method that can be used to check whether contained value\n-     * is a number represented as Java <code>long</code>.\n-     * Note, however, that even if this method returns false, it\n-     * is possible that conversion would be possible from other numeric\n-     * types -- to check if this is possible, use\n-     * {@link #canConvertToInt()} instead.\n-     * \n-     * @return True if the value contained by this node is stored as Java <code>long</code>\n-     */\n-    public boolean isLong() { return false; }\n-\n-    public boolean isDouble() { return false; }\n-    public boolean isBigDecimal() { return false; }\n-    public boolean isBigInteger() { return false; }\n-\n-    public final boolean isTextual()\n-    {\n-        return getNodeType() == JsonNodeType.STRING;\n-    }\n-\n-    /**\n-     * Method that can be used to check if this node was created from\n-     * JSON boolean value (literals \"true\" and \"false\").\n-     */\n-    public final boolean isBoolean()\n-    {\n-        return getNodeType() == JsonNodeType.BOOLEAN;\n-    }\n-\n-    /**\n-     * Method that can be used to check if this node was created from\n-     * JSON literal null value.\n-     */\n-    public final boolean isNull()\n-    {\n-        return getNodeType() == JsonNodeType.NULL;\n-    }\n-\n-    /**\n-     * Method that can be used to check if this node represents\n-     * binary data (Base64 encoded). Although this will be externally\n-     * written as JSON String value, {@link #isTextual} will\n-     * return false if this method returns true.\n-     *\n-     * @return True if this node represents base64 encoded binary data\n-     */\n-    public final boolean isBinary()\n-    {\n-        return getNodeType() == JsonNodeType.BINARY;\n-    }\n-\n-    /**\n-     * Method that can be used for efficient type detection\n-     * when using stream abstraction for traversing nodes.\n-     * Will return the first {@link JsonToken} that equivalent\n-     * stream event would produce (for most nodes there is just\n-     * one token but for structured/container types multiple)\n-     */\n-    public abstract JsonToken asToken();\n-\n-    /**\n-     * If this node is a numeric type (as per {@link #isNumber}),\n-     * returns native type that node uses to store the numeric value;\n-     * otherwise returns null.\n-     * \n-     * @return Type of number contained, if any; or null if node does not\n-     *  contain numeric value.\n-     */\n-    public abstract JsonParser.NumberType numberType();\n-\n-    /**\n-     * Method that can be used to check whether this node is a numeric\n-     * node ({@link #isNumber} would return true) AND its value fits\n-     * within Java's 32-bit signed integer type, <code>int</code>.\n-     * Note that floating-point numbers are convertible if the integral\n-     * part fits without overflow (as per standard Java coercion rules)\n-     * \n-     * @since 2.0\n-     */\n-    public boolean canConvertToInt() { return false; }\n-\n-    /**\n-     * Method that can be used to check whether this node is a numeric\n-     * node ({@link #isNumber} would return true) AND its value fits\n-     * within Java's 64-bit signed integer type, <code>long</code>.\n-     * Note that floating-point numbers are convertible if the integral\n-     * part fits without overflow (as per standard Java coercion rules)\n-     * \n-     * @since 2.0\n-     */\n-    public boolean canConvertToLong() { return false; }\n-    \n-    /*\n-    /**********************************************************\n-    /* Public API, straight value access\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Method to use for accessing String values.\n-     * Does <b>NOT</b> do any conversions for non-String value nodes;\n-     * for non-String values (ones for which {@link #isTextual} returns\n-     * false) null will be returned.\n-     * For String values, null is never returned (but empty Strings may be)\n-     *\n-     * @return Textual value this node contains, iff it is a textual\n-     *   JSON node (comes from JSON String value entry)\n-     */\n-    public String textValue() { return null; }\n-\n-    /**\n-     * Method to use for accessing binary content of binary nodes (nodes\n-     * for which {@link #isBinary} returns true); or for Text Nodes\n-     * (ones for which {@link #textValue} returns non-null value),\n-     * to read decoded base64 data.\n-     * For other types of nodes, returns null.\n-     *\n-     * @return Binary data this node contains, iff it is a binary\n-     *   node; null otherwise\n-     */\n-    public byte[] binaryValue() throws IOException\n-    {\n-        return null;\n-    }\n-\n-    /**\n-     * Method to use for accessing JSON boolean values (value\n-     * literals 'true' and 'false').\n-     * For other types, always returns false.\n-     *\n-     * @return Textual value this node contains, iff it is a textual\n-     *   json node (comes from JSON String value entry)\n-     */\n-    public boolean booleanValue() { return false; }\n-\n-    /**\n-     * Returns numeric value for this node, <b>if and only if</b>\n-     * this node is numeric ({@link #isNumber} returns true); otherwise\n-     * returns null\n-     *\n-     * @return Number value this node contains, if any (null for non-number\n-     *   nodes).\n-     */\n-    public Number numberValue() { return null; }\n-\n-    /**\n-     * Returns integer value for this node, <b>if and only if</b>\n-     * this node is numeric ({@link #isNumber} returns true). For other\n-     * types returns 0.\n-     * For floating-point numbers, value is truncated using default\n-     * Java coercion, similar to how cast from double to int operates.\n-     *\n-     * @return Integer value this node contains, if any; 0 for non-number\n-     *   nodes.\n-     */\n-    public int intValue() { return 0; }\n-\n-    public long longValue() { return 0L; }\n-    public double doubleValue() { return 0.0; }\n-    public BigDecimal decimalValue() { return BigDecimal.ZERO; }\n-    public BigInteger bigIntegerValue() { return BigInteger.ZERO; }\n \n     /**\n      * Method for accessing value of the specified element of\n      *   if this node is an array and has specified element.\n      *   Null otherwise.\n      */\n+    @Override\n     public abstract JsonNode get(int index);\n \n     /**\n      *   if this node is an object and has value for the specified\n      *   field. Null otherwise.\n      */\n+    @Override\n     public JsonNode get(String fieldName) { return null; }\n+\n+    @Override\n+    public Iterator<String> fieldNames() {\n+        return EmptyIterator.instance();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, type introspection\n+    /**********************************************************\n+     */\n+\n+    // // First high-level division between values, containers and \"missing\"\n+\n+    /**\n+     * Return the type of this node\n+     *\n+     * @return the node type as a {@link JsonNodeType} enum value\n+     */\n+    public abstract JsonNodeType getNodeType();\n+\n+    /**\n+     * Method that can be used to check if the node is a wrapper\n+     * for a POJO (\"Plain Old Java Object\" aka \"bean\".\n+     * Returns true only for\n+     * instances of <code>POJONode</code>.\n+     *\n+     * @return True if this node wraps a POJO\n+     */\n+    public final boolean isPojo() {\n+        return getNodeType() == JsonNodeType.POJO;\n+    }\n+\n+    /**\n+     * @return True if this node represents a numeric JSON\n+     *   value\n+     */\n+    public final boolean isNumber() {\n+        return getNodeType() == JsonNodeType.NUMBER;\n+    }\n+\n+    /**\n+     * \n+     * @return True if this node represents an integral (integer)\n+     *   numeric JSON value\n+     */\n+    public boolean isIntegralNumber() { return false; }\n+\n+    /**\n+     * @return True if this node represents a non-integral\n+     *   numeric JSON value\n+     */\n+    public boolean isFloatingPointNumber() { return false; }\n+\n+    /**\n+     * Method that can be used to check whether contained value\n+     * is a number represented as Java <code>int</code>.\n+     * Note, however, that even if this method returns false, it\n+     * is possible that conversion would be possible from other numeric\n+     * types -- to check if this is possible, use\n+     * {@link #canConvertToInt()} instead.\n+     * \n+     * @return True if the value contained by this node is stored as Java int\n+     */\n+    public boolean isInt() { return false; }\n+\n+    /**\n+     * Method that can be used to check whether contained value\n+     * is a number represented as Java <code>long</code>.\n+     * Note, however, that even if this method returns false, it\n+     * is possible that conversion would be possible from other numeric\n+     * types -- to check if this is possible, use\n+     * {@link #canConvertToInt()} instead.\n+     * \n+     * @return True if the value contained by this node is stored as Java <code>long</code>\n+     */\n+    public boolean isLong() { return false; }\n+\n+    public boolean isDouble() { return false; }\n+    public boolean isBigDecimal() { return false; }\n+    public boolean isBigInteger() { return false; }\n+\n+    public final boolean isTextual() {\n+        return getNodeType() == JsonNodeType.STRING;\n+    }\n+\n+    /**\n+     * Method that can be used to check if this node was created from\n+     * JSON boolean value (literals \"true\" and \"false\").\n+     */\n+    public final boolean isBoolean() {\n+        return getNodeType() == JsonNodeType.BOOLEAN;\n+    }\n+\n+    /**\n+     * Method that can be used to check if this node was created from\n+     * JSON literal null value.\n+     */\n+    public final boolean isNull() {\n+        return getNodeType() == JsonNodeType.NULL;\n+    }\n+\n+    /**\n+     * Method that can be used to check if this node represents\n+     * binary data (Base64 encoded). Although this will be externally\n+     * written as JSON String value, {@link #isTextual} will\n+     * return false if this method returns true.\n+     *\n+     * @return True if this node represents base64 encoded binary data\n+     */\n+    public final boolean isBinary() {\n+        return getNodeType() == JsonNodeType.BINARY;\n+    }\n+\n+    /**\n+     * Method that can be used to check whether this node is a numeric\n+     * node ({@link #isNumber} would return true) AND its value fits\n+     * within Java's 32-bit signed integer type, <code>int</code>.\n+     * Note that floating-point numbers are convertible if the integral\n+     * part fits without overflow (as per standard Java coercion rules)\n+     * \n+     * @since 2.0\n+     */\n+    public boolean canConvertToInt() { return false; }\n+\n+    /**\n+     * Method that can be used to check whether this node is a numeric\n+     * node ({@link #isNumber} would return true) AND its value fits\n+     * within Java's 64-bit signed integer type, <code>long</code>.\n+     * Note that floating-point numbers are convertible if the integral\n+     * part fits without overflow (as per standard Java coercion rules)\n+     * \n+     * @since 2.0\n+     */\n+    public boolean canConvertToLong() { return false; }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, straight value access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method to use for accessing String values.\n+     * Does <b>NOT</b> do any conversions for non-String value nodes;\n+     * for non-String values (ones for which {@link #isTextual} returns\n+     * false) null will be returned.\n+     * For String values, null is never returned (but empty Strings may be)\n+     *\n+     * @return Textual value this node contains, iff it is a textual\n+     *   JSON node (comes from JSON String value entry)\n+     */\n+    public String textValue() { return null; }\n+\n+    /**\n+     * Method to use for accessing binary content of binary nodes (nodes\n+     * for which {@link #isBinary} returns true); or for Text Nodes\n+     * (ones for which {@link #textValue} returns non-null value),\n+     * to read decoded base64 data.\n+     * For other types of nodes, returns null.\n+     *\n+     * @return Binary data this node contains, iff it is a binary\n+     *   node; null otherwise\n+     */\n+    public byte[] binaryValue() throws IOException {\n+        return null;\n+    }\n+\n+    /**\n+     * Method to use for accessing JSON boolean values (value\n+     * literals 'true' and 'false').\n+     * For other types, always returns false.\n+     *\n+     * @return Textual value this node contains, iff it is a textual\n+     *   json node (comes from JSON String value entry)\n+     */\n+    public boolean booleanValue() { return false; }\n+\n+    /**\n+     * Returns numeric value for this node, <b>if and only if</b>\n+     * this node is numeric ({@link #isNumber} returns true); otherwise\n+     * returns null\n+     *\n+     * @return Number value this node contains, if any (null for non-number\n+     *   nodes).\n+     */\n+    public Number numberValue() { return null; }\n+\n+    /**\n+     * Returns integer value for this node, <b>if and only if</b>\n+     * this node is numeric ({@link #isNumber} returns true). For other\n+     * types returns 0.\n+     * For floating-point numbers, value is truncated using default\n+     * Java coercion, similar to how cast from double to int operates.\n+     *\n+     * @return Integer value this node contains, if any; 0 for non-number\n+     *   nodes.\n+     */\n+    public int intValue() { return 0; }\n+\n+    public long longValue() { return 0L; }\n+    public double doubleValue() { return 0.0; }\n+    public BigDecimal decimalValue() { return BigDecimal.ZERO; }\n+    public BigInteger bigIntegerValue() { return BigInteger.ZERO; }\n     \n     /*\n     /**********************************************************\n         JsonNode n = get(index);\n         return (n != null) && !n.isNull();\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, container access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Same as calling {@link #elements}; implemented so that\n+     * convenience \"for-each\" loop can be used for looping over elements\n+     * of JSON Array constructs.\n+     */\n+    public final Iterator<JsonNode> iterator() { return elements(); }\n+\n+    /**\n+     * Method for accessing all value nodes of this Node, iff\n+     * this node is a JSON Array or Object node. In case of Object node,\n+     * field names (keys) are not included, only values.\n+     * For other types of nodes, returns empty iterator.\n+     */\n+    public Iterator<JsonNode> elements() {\n+        return EmptyIterator.instance();\n+    }\n+\n+    /**\n+     * @return Iterator that can be used to traverse all key/value pairs for\n+     *   object nodes; empty iterator (no contents) for other types\n+     */\n+    public Iterator<Map.Entry<String, JsonNode>> fields() {\n+        return EmptyIterator.instance();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, find methods\n+    /**********************************************************\n+     */\n     \n     /**\n      * Method for finding a JSON Object field with specified name in this\n \n     /*\n     /**********************************************************\n-    /* Public API, container access\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Method that returns number of child nodes this node contains:\n-     * for Array nodes, number of child elements, for Object nodes,\n-     * number of fields, and for all other nodes 0.\n-     *\n-     * @return For non-container nodes returns 0; for arrays number of\n-     *   contained elements, and for objects number of fields.\n-     */\n-    public int size() { return 0; }\n-\n-    /**\n-     * Same as calling {@link #elements}; implemented so that\n-     * convenience \"for-each\" loop can be used for looping over elements\n-     * of JSON Array constructs.\n-     */\n-//  @Override\n-    public final Iterator<JsonNode> iterator() { return elements(); }\n-\n-    /**\n-     * Method for accessing all value nodes of this Node, iff\n-     * this node is a JSON Array or Object node. In case of Object node,\n-     * field names (keys) are not included, only values.\n-     * For other types of nodes, returns empty iterator.\n-     */\n-    public Iterator<JsonNode> elements() {\n-        return EmptyIterator.instance();\n-    }\n-\n-    /**\n-     * Method for accessing names of all fields for this Node, iff\n-     * this node is a JSON Object node.\n-     */\n-    public Iterator<String> fieldNames() {\n-        return EmptyIterator.instance();\n-    }\n-\n-    /**\n-     * @return Iterator that can be used to traverse all key/value pairs for\n-     *   object nodes; empty iterator (no contents) for other types\n-     */\n-    public Iterator<Map.Entry<String, JsonNode>> fields() {\n-        return EmptyIterator.instance();\n-    }\n-    \n-    /*\n-    /**********************************************************\n     /* Public API, path handling\n     /**********************************************************\n      */\n         throw new UnsupportedOperationException(\"JsonNode not of type ObjectNode (but \"\n                 +getClass().getName()+\"), can not call withArray() on it\");\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Public API: converting to/from Streaming API\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Method for constructing a {@link JsonParser} instance for\n-     * iterating over contents of the tree that this\n-     * node is root of.\n-     * Functionally equivalent to first serializing tree using\n-     * {@link com.fasterxml.jackson.core.ObjectCodec} and then re-parsing but\n-     * more efficient.\n-     */\n-    public abstract JsonParser traverse();\n \n     /*\n     /**********************************************************", "timestamp": 1360738768, "metainfo": ""}