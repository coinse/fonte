{"sha": "06c20b1814a497cda59d46609ca03bfac20f64f1", "log": "Simplified DeserializationContext handling a bit by removing StdDeserializationContext, demoting functionaliyt", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n package com.fasterxml.jackson.databind;\n \n import java.io.IOException;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n \n+import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n-import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n+import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.LinkedNode;\n import com.fasterxml.jackson.databind.util.ObjectBuffer;\n \n /**\n  * Context for deserialization process. Used to allow passing in configuration\n  * settings and reusable temporary objects (scrap arrays, containers).\n  */\n-public abstract class DeserializationContext\n+public class DeserializationContext\n {\n+    /**\n+     * Let's limit length of error messages, for cases where underlying data\n+     * may be very large -- no point in spamming logs with megs of meaningless\n+     * data.\n+     */\n+    final static int MAX_ERROR_STR_LEN = 500;\n+\n+    // // // Configuration\n+    \n     protected final DeserializationConfig _config;\n \n     protected final int _featureFlags;\n \n     protected final Class<?> _view;\n+\n+    /**\n+     * Currently active parser used for deserialization.\n+     * May be different from the outermost parser\n+     * when content is buffered.\n+     */\n+    protected JsonParser _parser;\n+\n+    protected final DeserializerCache _deserCache;\n+\n+    protected final InjectableValues _injectableValues;\n+    \n+    // // // Helper object recycling\n+\n+    protected ArrayBuilders _arrayBuilders;\n+\n+    protected ObjectBuffer _objectBuffer;\n+\n+    protected DateFormat _dateFormat;\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n     \n-    protected DeserializationContext(DeserializationConfig config)\n+    public DeserializationContext(DeserializationConfig config, JsonParser jp,\n+            DeserializerCache cache, InjectableValues injectableValues)\n     {\n         _config = config;\n         _featureFlags = config.getDeserializationFeatures();\n         _view = config.getActiveView();\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Configuration methods\n+        _parser = jp;\n+        _deserCache = cache;\n+        _injectableValues = injectableValues;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, accessors\n     /**********************************************************\n      */\n \n      */\n     public DeserializationConfig getConfig() { return _config; }\n \n-    public final AnnotationIntrospector getAnnotationIntrospector() {\n-        return _config.getAnnotationIntrospector();\n-    }\n-    \n     /**\n      * Convenience method for checking whether specified on/off\n      * feature is enabled\n \n     public final boolean isEnabled(MapperConfig.Feature feat) {\n         return _config.isEnabled(feat);\n+    }\n+    \n+    public final AnnotationIntrospector getAnnotationIntrospector() {\n+        return _config.getAnnotationIntrospector();\n+    }\n+    \n+    public final DeserializerCache getDeserializerCache() {\n+        return _deserCache;\n+    }\n+\n+    /**\n+     * Method for accessing the currently active parser.\n+     * May be different from the outermost parser\n+     * when content is buffered.\n+     *<p>\n+     * Use of this method is discouraged: if code has direct access\n+     * to the active parser, that should be used instead.\n+     */\n+    public final JsonParser getParser() { return _parser; }\n+\n+    public final Object findInjectableValue(Object valueId,\n+            BeanProperty forProperty, Object beanInstance)\n+    {\n+        if (_injectableValues == null) {\n+            throw new IllegalStateException(\"No 'injectableValues' configured, can not inject value with id [\"+valueId+\"]\");\n+        }\n+        return _injectableValues.findInjectableValue(valueId, this, forProperty, beanInstance);\n     }\n \n     public final Class<?> getActiveView() {\n      *  getConfig().getBase64Variant();\n      *</pre>\n      */\n-    public Base64Variant getBase64Variant() {\n+    public final Base64Variant getBase64Variant() {\n         return _config.getBase64Variant();\n     }\n-\n-    /**\n-     * Accessor for getting access to the underlying JSON parser used\n-     * for deserialization.\n-     */\n-    public abstract JsonParser getParser();\n \n     public final JsonNodeFactory getNodeFactory() {\n         return _config.getNodeFactory();\n         return _config.getTypeFactory();\n     }\n \n-    public abstract Object findInjectableValue(Object valueId,\n-            BeanProperty forProperty, Object beanInstance);\n-\n-    /*\n-    /**********************************************************\n-    /* By-pass methods to DeserializerCache\n-    /**********************************************************\n-     */\n-\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, pass-through to DeserializerCache\n+    /**********************************************************\n+     */\n     /**\n      * Convenience method, functionally same as:\n      *<pre>\n      *  getDeserializerProvider().findValueDeserializer(getConfig(), propertyType, property);\n      *</pre>\n      */\n-    public abstract JsonDeserializer<Object> findValueDeserializer(JavaType propertyType,\n-            BeanProperty property)\n-        throws JsonMappingException;\n+    public final JsonDeserializer<Object> findValueDeserializer(JavaType type,\n+            BeanProperty property) throws JsonMappingException {\n+        return _deserCache.findValueDeserializer(this, type, property);\n+    }\n     \n     /**\n      * Convenience method, functionally same as:\n      *  getDeserializerProvider().findTypedValueDeserializer(getConfig(), propertyType, property);\n      *</pre>\n      */\n-    public abstract JsonDeserializer<Object> findTypedValueDeserializer(JavaType type,\n-            BeanProperty property)\n-        throws JsonMappingException;\n+    public final JsonDeserializer<Object> findTypedValueDeserializer(JavaType type,\n+            BeanProperty property) throws JsonMappingException {\n+        return _deserCache.findTypedValueDeserializer(this, type, property);\n+    }\n \n     /**\n      * Convenience method, functionally same as:\n      *  getDeserializerProvider().findKeyDeserializer(getConfig(), propertyType, property);\n      *</pre>\n      */\n-    public abstract KeyDeserializer findKeyDeserializer(JavaType keyType,\n-            BeanProperty property)\n-        throws JsonMappingException;\n-\n+    public final KeyDeserializer findKeyDeserializer(JavaType keyType,\n+            BeanProperty property) throws JsonMappingException {\n+        return _deserCache.findKeyDeserializer(this, keyType, property);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Extended API: handler instantiation\n     /**********************************************************\n      */\n \n-    public abstract JsonDeserializer<Object> deserializerInstance(Annotated annotated,\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonDeserializer<Object> deserializerInstance(Annotated annotated,\n             BeanProperty property, Object deserDef)\n-        throws JsonMappingException;\n-\n-    public abstract KeyDeserializer keyDeserializerInstance(Annotated annotated,\n-            BeanProperty property, Object keyDeserClass)\n-        throws JsonMappingException;\n-    \n-    /*\n-    /**********************************************************\n-    /* Methods for accessing reusable/recyclable helper objects\n+        throws JsonMappingException\n+    {\n+        if (deserDef == null) {\n+            return null;\n+        }\n+        JsonDeserializer<?> deser;\n+        \n+        if (deserDef instanceof JsonDeserializer) {\n+            deser = (JsonDeserializer<?>) deserDef;\n+        } else {\n+            /* Alas, there's no way to force return type of \"either class\n+             * X or Y\" -- need to throw an exception after the fact\n+             */\n+            if (!(deserDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned deserializer definition of type \"+deserDef.getClass().getName()+\"; expected type JsonDeserializer or Class<JsonDeserializer> instead\");\n+            }\n+            Class<?> deserClass = (Class<?>)deserDef;\n+            // there are some known \"no class\" markers to consider too:\n+            if (deserClass == JsonDeserializer.None.class || deserClass == NoClass.class) {\n+                return null;\n+            }\n+            if (!JsonDeserializer.class.isAssignableFrom(deserClass)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()+\"; expected Class<JsonDeserializer>\");\n+            }\n+            HandlerInstantiator hi = _config.getHandlerInstantiator();\n+            if (hi != null) {\n+                deser = hi.deserializerInstance(_config, annotated, deserClass);\n+            } else {\n+                deser = (JsonDeserializer<?>) ClassUtil.createInstance(deserClass,\n+                        _config.canOverrideAccessModifiers());\n+            }\n+        }\n+        // First: need to resolve\n+        if (deser instanceof ResolvableDeserializer) {\n+            ((ResolvableDeserializer) deser).resolve(this);\n+        }\n+        // Second: contextualize:\n+        if (deser instanceof ContextualDeserializer<?>) {\n+            deser = ((ContextualDeserializer<?>) deser).createContextual(this, property);\n+        }\n+        return (JsonDeserializer<Object>) deser;\n+    }\n+\n+    public final KeyDeserializer keyDeserializerInstance(Annotated annotated,\n+            BeanProperty property, Object deserDef)\n+        throws JsonMappingException\n+    {\n+        if (deserDef == null) {\n+            return null;\n+        }\n+\n+        KeyDeserializer deser;\n+        \n+        if (deserDef instanceof KeyDeserializer) {\n+            deser = (KeyDeserializer) deserDef;\n+        } else {\n+            if (!(deserDef instanceof Class)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned key deserializer definition of type \"\n+                        +deserDef.getClass().getName()\n+                        +\"; expected type KeyDeserializer or Class<KeyDeserializer> instead\");\n+            }\n+            Class<?> deserClass = (Class<?>)deserDef;\n+            // there are some known \"no class\" markers to consider too:\n+            if (deserClass == KeyDeserializer.None.class || deserClass == NoClass.class) {\n+                return null;\n+            }\n+            if (!KeyDeserializer.class.isAssignableFrom(deserClass)) {\n+                throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()\n+                        +\"; expected Class<KeyDeserializer>\");\n+            }\n+            HandlerInstantiator hi = _config.getHandlerInstantiator();\n+            if (hi != null) {\n+                deser = hi.keyDeserializerInstance(_config, annotated, deserClass);\n+            } else {\n+                deser = (KeyDeserializer) ClassUtil.createInstance(deserClass,\n+                        _config.canOverrideAccessModifiers());\n+            }\n+        }\n+        // First: need to resolve\n+        if (deser instanceof ResolvableDeserializer) {\n+            ((ResolvableDeserializer) deser).resolve(this);\n+        }\n+        // Second: contextualize:\n+        if (deser instanceof ContextualKeyDeserializer) {\n+            deser = ((ContextualKeyDeserializer) deser).createContextual(this, property);\n+        }\n+        return deser;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, helper object recycling\n     /**********************************************************\n      */\n \n      * Note that leased buffers should be returned once deserializer\n      * is done, to allow for reuse during same round of deserialization.\n      */\n-    public abstract ObjectBuffer leaseObjectBuffer();\n+    public final ObjectBuffer leaseObjectBuffer()\n+    {\n+        ObjectBuffer buf = _objectBuffer;\n+        if (buf == null) {\n+            buf = new ObjectBuffer();\n+        } else {\n+            _objectBuffer = null;\n+        }\n+        return buf;\n+    }\n \n     /**\n      * Method to call to return object buffer previously leased with\n      * \n      * @param buf Returned object buffer\n      */\n-    public abstract void returnObjectBuffer(ObjectBuffer buf);\n+    public final void returnObjectBuffer(ObjectBuffer buf)\n+    {\n+        /* Already have a reusable buffer? Let's retain bigger one\n+         * (or if equal, favor newer one, shorter life-cycle)\n+         */\n+        if (_objectBuffer == null\n+            || buf.initialCapacity() >= _objectBuffer.initialCapacity()) {\n+            _objectBuffer = buf;\n+        }\n+    }\n \n     /**\n      * Method for accessing object useful for building arrays of\n      * primitive types (such as int[]).\n      */\n-    public abstract ArrayBuilders getArrayBuilders();\n+    public final ArrayBuilders getArrayBuilders()\n+    {\n+        if (_arrayBuilders == null) {\n+            _arrayBuilders = new ArrayBuilders();\n+        }\n+        return _arrayBuilders;\n+    }\n \n     /*\n     /**********************************************************\n      * date format is cloned, and cloned instance will be retained\n      * for use during this deserialization round.\n      */\n-    public abstract java.util.Date parseDate(String dateStr)\n-        throws IllegalArgumentException;\n+    public Date parseDate(String dateStr)\n+        throws IllegalArgumentException\n+    {\n+        try {\n+            return getDateFormat().parse(dateStr);\n+        } catch (ParseException pex) {\n+            throw new IllegalArgumentException(pex.getMessage());\n+        }\n+    }\n \n     /**\n      * Convenience method for constructing Calendar instance set\n      * to specified time, to be modified and used by caller.\n      */\n-    public abstract Calendar constructCalendar(Date d);\n+    public Calendar constructCalendar(Date d)\n+    {\n+        /* 08-Jan-2008, tatu: not optimal, but should work for the\n+         *   most part; let's revise as needed.\n+         */\n+        Calendar c = Calendar.getInstance();\n+        c.setTime(d);\n+        return c;\n+    }\n \n     /*\n     /**********************************************************\n      * @return True if there was a configured problem handler that was able to handle the\n      *   problem\n      */\n-    public abstract boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser, Object instanceOrClass, String propName)\n-        throws IOException, JsonProcessingException;\n+    /**\n+     * Method deserializers can call to inform configured {@link DeserializationProblemHandler}s\n+     * of an unrecognized property.\n+     */\n+    public boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser, Object instanceOrClass, String propName)\n+        throws IOException, JsonProcessingException\n+    {\n+        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n+        if (h != null) {\n+            /* 04-Jan-2009, tatu: Ugh. Need to mess with currently active parser\n+             *   since parser is not explicitly passed to handler... that was a mistake\n+             */\n+            JsonParser oldParser = _parser;\n+            _parser = jp;\n+            try {\n+                while (h != null) {\n+                    // Can bail out if it's handled\n+                    if (h.value().handleUnknownProperty(this, deser, instanceOrClass, propName)) {\n+                        return true;\n+                    }\n+                    h = h.next();\n+                }\n+            } finally {\n+                _parser = oldParser;\n+            }\n+        }\n+        return false;\n+    }\n \n     /**\n      * Helper method for constructing generic mapping exception for specified type\n      */\n-    public abstract JsonMappingException mappingException(Class<?> targetClass);\n-\n-    public abstract JsonMappingException mappingException(Class<?> targetClass, JsonToken t);\n+    public JsonMappingException mappingException(Class<?> targetClass) {\n+        return mappingException(targetClass, _parser.getCurrentToken());\n+    }\n+\n+    public JsonMappingException mappingException(Class<?> targetClass, JsonToken token)\n+    {\n+        String clsName = _calcName(targetClass);\n+        return JsonMappingException.from(_parser, \"Can not deserialize instance of \"+clsName+\" out of \"+token+\" token\");\n+    }\n     \n     /**\n      * Helper method for constructing generic mapping exception with specified\n      * to indicate problem with physically constructing instance of\n      * specified class (missing constructor, exception from constructor)\n      */\n-    public abstract JsonMappingException instantiationException(Class<?> instClass, Throwable t);\n-\n-    public abstract JsonMappingException instantiationException(Class<?> instClass, String msg);\n-    \n-    /**\n-     * Helper method for constructing exception to indicate that input JSON\n-     * String was not in recognized format for deserializing into given type.\n-     */\n-    public abstract JsonMappingException weirdStringException(Class<?> instClass, String msg);\n+    public JsonMappingException instantiationException(Class<?> instClass, Throwable t)\n+    {\n+        return JsonMappingException.from(_parser,\n+                \"Can not construct instance of \"+instClass.getName()+\", problem: \"+t.getMessage(),\n+                t);\n+    }\n+\n+    public JsonMappingException instantiationException(Class<?> instClass, String msg)\n+    {\n+        return JsonMappingException.from(_parser, \"Can not construct instance of \"+instClass.getName()+\", problem: \"+msg);\n+    }\n+    \n+    /**\n+     * Method that will construct an exception suitable for throwing when\n+     * some String values are acceptable, but the one encountered is not.\n+     */\n+    public JsonMappingException weirdStringException(Class<?> instClass, String msg)\n+    {\n+        return JsonMappingException.from(_parser, \"Can not construct instance of \"+instClass.getName()+\" from String value '\"+_valueDesc()+\"': \"+msg);\n+    }\n \n     /**\n      * Helper method for constructing exception to indicate that input JSON\n      * Number was not suitable for deserializing into given type.\n      */\n-    public abstract JsonMappingException weirdNumberException(Class<?> instClass, String msg);\n+    public JsonMappingException weirdNumberException(Class<?> instClass, String msg)\n+    {\n+        return JsonMappingException.from(_parser, \"Can not construct instance of \"+instClass.getName()+\" from number value (\"+_valueDesc()+\"): \"+msg);\n+    }\n \n     /**\n      * Helper method for constructing exception to indicate that given JSON\n      * Object field name was not in format to be able to deserialize specified\n      * key type.\n      */\n-    public abstract JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg);\n+    public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg)\n+    {\n+        return JsonMappingException.from(_parser, \"Can not construct Map key of type \"+keyClass.getName()+\" from String \\\"\"+_desc(keyValue)+\"\\\": \"+msg);\n+    }\n \n     /**\n      * Helper method for indicating that the current token was expected to be another\n      * token.\n      */\n-    public abstract JsonMappingException wrongTokenException(JsonParser jp, JsonToken expToken, String msg);\n+    public JsonMappingException wrongTokenException(JsonParser jp, JsonToken expToken, String msg)\n+    {\n+        return JsonMappingException.from(jp, \"Unexpected token (\"+jp.getCurrentToken()+\"), expected \"+expToken+\": \"+msg);\n+    }\n     \n     /**\n      * Helper method for constructing exception to indicate that JSON Object\n      *   instantiated), or Class that indicates type that would be (or\n      *   have been) instantiated\n      */\n-    public abstract JsonMappingException unknownFieldException(Object instanceOrClass, String fieldName);\n+    public JsonMappingException unknownFieldException(Object instanceOrClass, String fieldName)\n+    {\n+        return UnrecognizedPropertyException.from(_parser, instanceOrClass, fieldName);\n+    }\n \n     /**\n      * Helper method for constructing exception to indicate that given\n      * type id (parsed from JSON) could not be converted to a Java type.\n      */\n-    public abstract JsonMappingException unknownTypeException(JavaType baseType, String id);\n+    public JsonMappingException unknownTypeException(JavaType type, String id)\n+    {\n+        return JsonMappingException.from(_parser, \"Could not resolve type id '\"+id+\"' into a subtype of \"+type);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable internal methods\n+    /**********************************************************\n+     */\n+\n+    protected DateFormat getDateFormat()\n+    {\n+        if (_dateFormat == null) {\n+            // must create a clone since Formats are not thread-safe:\n+            _dateFormat = (DateFormat)_config.getDateFormat().clone();\n+        }\n+        return _dateFormat;\n+    }\n+\n+    protected String determineClassName(Object instance)\n+    {\n+        return ClassUtil.getClassDescription(instance);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other internal methods\n+    /**********************************************************\n+     */\n+\n+    protected String _calcName(Class<?> cls)\n+    {\n+        if (cls.isArray()) {\n+            return _calcName(cls.getComponentType())+\"[]\";\n+        }\n+        return cls.getName();\n+    }\n+    \n+    protected String _valueDesc()\n+    {\n+        try {\n+            return _desc(_parser.getText());\n+        } catch (Exception e) {\n+            return \"[N/A]\";\n+        }\n+    }\n+    protected String _desc(String desc)\n+    {\n+        // !!! should we quote it? (in case there are control chars, linefeeds)\n+        if (desc.length() > MAX_ERROR_STR_LEN) {\n+            desc = desc.substring(0, MAX_ERROR_STR_LEN) + \"]...[\" + desc.substring(desc.length() - MAX_ERROR_STR_LEN);\n+        }\n+        return desc;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n \n     protected DeserializationContext _createDeserializationContext(JsonParser jp, DeserializationConfig cfg)\n     {\n-        return new StdDeserializationContext(cfg, jp, _deserializerCache,\n+        return new DeserializationContext(cfg, jp, _deserializerCache,\n                 _injectableValues);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n \n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.DeserializerCache;\n-import com.fasterxml.jackson.databind.deser.StdDeserializationContext;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.node.NullNode;\n import com.fasterxml.jackson.databind.node.TreeTraversingParser;\n     \n     protected DeserializationContext _createDeserializationContext(JsonParser jp, DeserializationConfig cfg) {\n         // 04-Jan-2010, tatu: we do actually need the provider too... (for polymorphic deser)\n-        return new StdDeserializationContext(cfg, jp, _deserializerCache, _injectableValues);\n+        return new DeserializationContext(cfg, jp, _deserializerCache, _injectableValues);\n     }\n \n     protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n     protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)\n     {\n         if (type == null) {\n-            throw new IllegalArgumentException();\n+            throw new IllegalArgumentException(\"Null JavaType passed\");\n         }\n         return _cachedDeserializers.get(type);\n     }", "timestamp": 1327901812, "metainfo": ""}