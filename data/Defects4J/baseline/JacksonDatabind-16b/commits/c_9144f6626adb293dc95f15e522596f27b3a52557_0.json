{"sha": "9144f6626adb293dc95f15e522596f27b3a52557", "log": "Merge pull request #568 from mressler/master  Adding a Case Insensitive DeserializationFeature", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n     /* Name-related features\n     /******************************************************\n      */\n-\n+    \n+    /**\n+     * Feature that will allow for more forgiving deserialization of incoming JSON.\n+     * If enabled, the bean properties will be matched using their lower-case\n+     * equivalents.\n+     * <p>\n+     * Feature is disabled by default.\n+     */\n+    ACCEPT_CASE_INSENSITIVE_PROPERTIES(false),\n+    \n     /**\n      * Feature that can be enabled to make property names be\n      * overridden by wrapper name (usually detected with annotations\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n \n     final protected boolean _defaultViewInclusion;\n     \n+    final protected boolean _caseInsensitivePropertyComparison;\n+    \n     /*\n     /**********************************************************\n     /* Accumulated information about properties\n     { \n         _beanDesc = beanDesc;\n         _defaultViewInclusion = config.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION);\n+        _caseInsensitivePropertyComparison = config.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES);\n     }\n \n     /**\n     {\n         _beanDesc = src._beanDesc;\n         _defaultViewInclusion = src._defaultViewInclusion;\n+        _caseInsensitivePropertyComparison = src._caseInsensitivePropertyComparison;\n \n         // let's make copy of properties\n         _properties.putAll(src._properties);\n     public JsonDeserializer<?> build()\n     {\n         Collection<SettableBeanProperty> props = _properties.values();\n-        BeanPropertyMap propertyMap = new BeanPropertyMap(props);\n+        BeanPropertyMap propertyMap = new BeanPropertyMap(props, _caseInsensitivePropertyComparison);\n         propertyMap.assignIndexes();\n \n         // view processing must be enabled if:\n         }\n         // And if so, we can try building the deserializer\n         Collection<SettableBeanProperty> props = _properties.values();\n-        BeanPropertyMap propertyMap = new BeanPropertyMap(props);\n+        BeanPropertyMap propertyMap = new BeanPropertyMap(props, _caseInsensitivePropertyComparison);\n         propertyMap.assignIndexes();\n \n         boolean anyViews = !_defaultViewInclusion;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n     private final int _hashMask;\n \n     private final int _size;\n+    \n+    private final boolean _caseInsensitivePropertyComparison;\n \n     /**\n      * Counter we use to keep track of insertion order of properties\n      */\n     private int _nextBucketIndex = 0;\n \n-    public BeanPropertyMap(Collection<SettableBeanProperty> properties)\n-    {\n+    public BeanPropertyMap(Collection<SettableBeanProperty> properties, boolean caseInsensitivePropertyComparison)\n+    {\n+        _caseInsensitivePropertyComparison = caseInsensitivePropertyComparison;\n         _size = properties.size();\n         int bucketCount = findSize(_size);\n         _hashMask = bucketCount-1;\n         Bucket[] buckets = new Bucket[bucketCount];\n         for (SettableBeanProperty property : properties) {\n-            String key = property.getName();\n+            String key = getPropertyName(property);\n             int index = key.hashCode() & _hashMask;\n             buckets[index] = new Bucket(buckets[index], key, property, _nextBucketIndex++);\n         }\n         _buckets = buckets;\n     }\n \n-    private BeanPropertyMap(Bucket[] buckets, int size, int index)\n+    private BeanPropertyMap(Bucket[] buckets, int size, int index, boolean caseInsensitivePropertyComparison)\n     {\n         _buckets = buckets;\n         _size = size;\n         _hashMask = buckets.length-1;\n         _nextBucketIndex = index;\n+        _caseInsensitivePropertyComparison = caseInsensitivePropertyComparison;\n     }\n     \n     /**\n         final int bcount = _buckets.length;\n         Bucket[] newBuckets = new Bucket[bcount];\n         System.arraycopy(_buckets, 0, newBuckets, 0, bcount);\n-        final String propName = newProperty.getName();\n+        final String propName = getPropertyName(newProperty);\n         // and then see if it's add or replace:\n-        SettableBeanProperty oldProp = find(newProperty.getName());\n+        SettableBeanProperty oldProp = find(propName);\n         if (oldProp == null) { // add\n             // first things first: add or replace?\n     \t        // can do a straight copy, since all additions are at the front\n     \t        int index = propName.hashCode() & _hashMask;\n     \t        newBuckets[index] = new Bucket(newBuckets[index],\n     \t                propName, newProperty, _nextBucketIndex++);\n-    \t        return new BeanPropertyMap(newBuckets, _size+1, _nextBucketIndex);\n+    \t        return new BeanPropertyMap(newBuckets, _size+1, _nextBucketIndex, _caseInsensitivePropertyComparison);\n         }\n         // replace: easy, close + replace\n-        BeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex);\n+        BeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex, _caseInsensitivePropertyComparison);\n         newMap.replace(newProperty);\n         return newMap;\n     }\n             newProps.add(prop);\n         }\n         // should we try to re-index? Ordering probably changed but called probably doesn't want changes...\n-        return new BeanPropertyMap(newProps);\n+        return new BeanPropertyMap(newProps, _caseInsensitivePropertyComparison);\n     }\n     \n     public BeanPropertyMap assignIndexes()\n         }\n         return result;\n     }\n+    \n+    // Confining this case insensitivity to this function (and the find method) in case we want to\n+    // apply a particular locale to the lower case function.  For now, using the default.\n+    private String getPropertyName(SettableBeanProperty prop) {\n+    \treturn _caseInsensitivePropertyComparison ? prop.getName().toLowerCase() : prop.getName();\n+    }\n \n     /*\n     /**********************************************************\n         if (key == null) {\n             throw new IllegalArgumentException(\"Can not pass null property name\");\n         }\n+        \n+        if (_caseInsensitivePropertyComparison) {\n+        \tkey = key.toLowerCase();\n+        }\n+        \n         int index = key.hashCode() & _hashMask;\n         Bucket bucket = _buckets[index];\n         // Let's unroll first lookup since that is null or match in 90+% cases\n      */\n     public void replace(SettableBeanProperty property)\n     {\n-        String name = property.getName();\n+        String name = getPropertyName(property);\n         int index = name.hashCode() & (_buckets.length-1);\n \n         /* This is bit tricky just because buckets themselves\n     public void remove(SettableBeanProperty property)\n     {\n         // Mostly this is the same as code with 'replace', just bit simpler...\n-        String name = property.getName();\n+        String name = getPropertyName(property);\n         int index = name.hashCode() & (_buckets.length-1);\n         Bucket tail = null;\n         boolean found = false;\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n         Bean result = r.readValue(JSON);\n         assertNull(result);\n     }\n+\n+    // [Databind#566]\n+    public void testCaseInsensitiveDeserialization() throws Exception\n+    {\n+    \tfinal String JSON = \"{\\\"Value1\\\" : {\\\"nAme\\\" : \\\"fruit\\\", \\\"vALUe\\\" : \\\"apple\\\"}, \\\"valUE2\\\" : {\\\"NAME\\\" : \\\"color\\\", \\\"value\\\" : \\\"red\\\"}}\";\n+        \n+        // first, verify default settings which do not accept improper case\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertFalse(mapper.isEnabled(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES));\n+        \n+        try {\n+            mapper.readValue(JSON, Issue476Bean.class);\n+            \n+            fail(\"Should not accept improper case properties by default\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"Unrecognized field\");\n+            assertValidLocation(e.getLocation());\n+        }\n+\n+        // Definitely not OK to enable dynamically - the BeanPropertyMap (which is the consumer of this particular feature) gets cached.\n+        mapper = new ObjectMapper();\n+        mapper.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);\n+        ObjectReader r = mapper.reader(Issue476Bean.class);\n+        Issue476Bean result = r.readValue(JSON);\n+        assertEquals(result.value1.name, \"fruit\");\n+        assertEquals(result.value1.value, \"apple\");\n+    }\n     \n     // [Issue#120]\n     public void testModifyArrayDeserializer() throws Exception\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n import java.lang.annotation.Annotation;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.Converter;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n     \n     /*\n     /**********************************************************\n-    /* Class annotations for Polymorphic type handling (1.5+)\n+    /* Class annotations for Polymorphic type handling\n     /**********************************************************\n     */\n     \n      * field) defines which Bean/Map properties are to be included in\n      * serialization.\n      * If no annotation is found, method should return given second\n-     * argument; otherwise value indicated by the annotation\n+     * argument; otherwise value indicated by the annotation.\n+     *<p>\n+     * Note that meaning of inclusion value depends on whether it is for\n+     * a Class or property (field/method/constructor): in former case,\n+     * it is the default for all properties; in latter case it is specific\n+     * override for annotated property.\n      *\n      * @return Enumerated value indicating which properties to include\n      *   in serialization\n      */\n     public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) {\n+        return defValue;\n+    }\n+\n+    /**\n+     * Method for checking whether content (entries) of a {@link java.util.Map} property\n+     * are to be included during serialization or not.\n+     * \n+     * @since 2.5\n+     */\n+    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue) {\n         return defValue;\n     }\n \n     public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n         return null;\n     }\n+\n+    /**\n+     * Method for adding possible virtual properties to be serialized along\n+     * with regular properties.\n+     * \n+     * @since 2.5\n+     */\n+    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n+            List<BeanPropertyWriter> properties) { }\n     \n     /*\n     /**********************************************************\n         return false;\n     }\n \n+    /**\n+     * Method for finding indication of creator binding mode for\n+     * a creator (something for which {@link #hasCreatorAnnotation} returns\n+     * true), for cases where there may be ambiguity (currently: single-argument\n+     * creator with implicit but no explicit name for the argument).\n+     * \n+     * @since 2.5\n+     */\n+    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n+        return null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Overridable methods: may be used as low-level extension\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n     /* Basic API for finding properties\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * @return Ordered Map with logical property name as key, and\n      *    matching getter method as value.\n      */\n     public abstract List<BeanPropertyDefinition> findProperties();\n-    \n+\n     /**\n      * Method for locating all back-reference properties (setters, fields) bean has\n      */\n     public abstract Map<String,AnnotatedMember> findBackReferenceProperties();\n \n     public abstract Set<String> getIgnoredPropertyNames();\n-    \n+\n     /*\n     /**********************************************************\n     /* Basic API for finding creator members\n     /**********************************************************\n      */\n-    \n+\n     public abstract List<AnnotatedConstructor> getConstructors();\n-    \n+\n     public abstract List<AnnotatedMethod> getFactoryMethods();\n-    \n+\n     /**\n      * Method that will locate the no-arg constructor for this class,\n      * if it has one, and that constructor has not been marked as\n     public abstract JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue);\n \n     /**\n+     * @since 2.5\n+     */\n+    public abstract JsonInclude.Include findSerializationInclusionForContent(JsonInclude.Include defValue);\n+    \n+    /**\n      * Method for checking what is the expected format for POJO, as\n      * defined by defaults and possible annotations.\n      * Note that this may be further refined by per-property annotations.\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n         @Override public AnnotatedMember getMember() { return _member; }\n \n         /**\n+         *<p>\n+         * TODO: move to {@link BeanProperty} in near future, once all standard\n+         * implementations define it.\n+         * \n+         * @since 2.5\n+         */\n+        public boolean isVirtual() { return false; }\n+\n+        /**\n          * Implementation of this method throws\n          * {@link UnsupportedOperationException}, since instances of this\n          * implementation should not be used as part of actual structure\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n  * \"fluent factory\" methods.\n  * Note also that unlike with Jackson 1, these instances can not be\n  * assigned to {@link ObjectMapper}; in fact, application code should\n- * rarely interact directly with these instance (unlike core Jackson code)\n+ * rarely interact directly with these instances.\n  */\n public final class DeserializationConfig\n     extends MapperConfigBase<DeserializationFeature, DeserializationConfig>\n     implements java.io.Serializable // since 2.1\n {\n-    // for 2.1.0\n-    private static final long serialVersionUID = -4227480407273773599L;\n-\n-    /**\n-     * Set of features enabled; actual type (kind of features)\n-     * depends on sub-classes.\n+    // since 2.5\n+    private static final long serialVersionUID = 1;\n+\n+    /**\n+     * Set of {@link DeserializationFeature}s enabled.\n      */\n     protected final int _deserFeatures;\n \n      * Factory used for constructing {@link com.fasterxml.jackson.databind.JsonNode} instances.\n      */\n     protected final JsonNodeFactory _nodeFactory;\n-    \n+\n+    /**\n+     * States of {@link com.fasterxml.jackson.core.JsonParser.Feature}s to enable/disable.\n+     */\n+    protected final int _parserFeatures;\n+\n+    /**\n+     * Bitflag of {@link com.fasterxml.jackson.core.JsonParser.Feature}s to enable/disable\n+     */\n+    protected final int _parserFeaturesToChange;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle, constructors\n         _deserFeatures = collectFeatureDefaults(DeserializationFeature.class);\n         _nodeFactory = JsonNodeFactory.instance;\n         _problemHandlers = null;\n-    }\n-\n+        _parserFeatures = 0;\n+        _parserFeaturesToChange = 0;\n+    }\n+\n+    private DeserializationConfig(DeserializationConfig src,\n+            int mapperFeatures, int deserFeatures,\n+            int parserFeatures, int parserFeatureMask)\n+    {\n+        super(src, mapperFeatures);\n+        _deserFeatures = deserFeatures;\n+        _nodeFactory = src._nodeFactory;\n+        _problemHandlers = src._problemHandlers;\n+        _parserFeatures = parserFeatures;\n+        _parserFeaturesToChange = parserFeatureMask;\n+    }\n+    \n     /**\n      * Copy constructor used to create a non-shared instance with given mix-in\n      * annotation definitions and subtype resolver.\n         _deserFeatures = src._deserFeatures;\n         _nodeFactory = src._nodeFactory;\n         _problemHandlers = src._problemHandlers;\n-    }\n-\n-    private DeserializationConfig(DeserializationConfig src,\n-            int mapperFeatures, int deserFeatures)\n-    {\n-        super(src, mapperFeatures);\n-        _deserFeatures = deserFeatures;\n-        _nodeFactory = src._nodeFactory;\n-        _problemHandlers = src._problemHandlers;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n     \n     private DeserializationConfig(DeserializationConfig src, BaseSettings base)\n         _deserFeatures = src._deserFeatures;\n         _nodeFactory = src._nodeFactory;\n         _problemHandlers = src._problemHandlers;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n     \n     private DeserializationConfig(DeserializationConfig src, JsonNodeFactory f)\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = f;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     private DeserializationConfig(DeserializationConfig src,\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     private DeserializationConfig(DeserializationConfig src, String rootName)\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     private DeserializationConfig(DeserializationConfig src, Class<?> view)\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     /**\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n \n     /**\n         _deserFeatures = src._deserFeatures;\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n+        _parserFeatures = src._parserFeatures;\n+        _parserFeaturesToChange = src._parserFeaturesToChange;\n     }\n     \n     // for unit tests only:\n             newMapperFlags |= f.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this :\n-            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+                    \n     }\n \n     @Override\n              newMapperFlags &= ~f.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this :\n-            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n     }\n \n     @Override\n             newMapperFlags = _mapperFeatures & ~feature.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this :\n-            new DeserializationConfig(this, newMapperFlags, _deserFeatures);\n+            new DeserializationConfig(this, newMapperFlags, _deserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n     }\n \n     @Override\n     private final DeserializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new DeserializationConfig(this, newBase);\n     }\n-    \n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, DeserializationFeature-based factory methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig with(DeserializationFeature feature)\n+    {\n+        int newDeserFeatures = (_deserFeatures | feature.getMask());\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig with(DeserializationFeature first,\n+            DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures | first.getMask();\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures |= f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     */\n+    public DeserializationConfig withFeatures(DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures;\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures |= f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature disabled.\n+     */\n+    public DeserializationConfig without(DeserializationFeature feature)\n+    {\n+        int newDeserFeatures = _deserFeatures & ~feature.getMask();\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public DeserializationConfig without(DeserializationFeature first,\n+            DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures & ~first.getMask();\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures &= ~f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     */\n+    public DeserializationConfig withoutFeatures(DeserializationFeature... features)\n+    {\n+        int newDeserFeatures = _deserFeatures;\n+        for (DeserializationFeature f : features) {\n+            newDeserFeatures &= ~f.getMask();\n+        }\n+        return (newDeserFeatures == _deserFeatures) ? this :\n+            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures,\n+                    _parserFeatures, _parserFeaturesToChange);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, JsonParser.Feature-based factory methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     *\n+     * @since 2.5\n+     */\n+    public DeserializationConfig with(JsonParser.Feature feature)\n+    {\n+        int newSet = _parserFeatures | feature.getMask();\n+        int newMask = _parserFeaturesToChange | feature.getMask();\n+        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n+            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     *\n+     * @since 2.5\n+     */\n+    public DeserializationConfig withFeatures(JsonParser.Feature... features)\n+    {\n+        int newSet = _parserFeatures;\n+        int newMask = _parserFeaturesToChange;\n+        for (JsonParser.Feature f : features) {\n+            int mask = f.getMask();\n+            newSet |= mask;\n+            newMask |= mask;\n+        }\n+        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n+            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n+                    newSet, newMask);\n+    }\n+    \n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature disabled.\n+     *\n+     * @since 2.5\n+     */\n+    public DeserializationConfig without(JsonParser.Feature feature)\n+    {\n+        int newSet = _parserFeatures & ~feature.getMask();\n+        int newMask = _parserFeaturesToChange | feature.getMask();\n+        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n+            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     *\n+     * @since 2.5\n+     */\n+    public DeserializationConfig withoutFeatures(JsonParser.Feature... features)\n+    {\n+        int newSet = _parserFeatures;\n+        int newMask = _parserFeaturesToChange;\n+        for (JsonParser.Feature f : features) {\n+            int mask = f.getMask();\n+            newSet &= ~mask;\n+            newMask |= mask;\n+        }\n+        return ((_parserFeatures == newSet) && (_parserFeaturesToChange == newMask)) ? this :\n+            new DeserializationConfig(this,  _mapperFeatures, _deserFeatures,\n+                    newSet, newMask);\n+    }    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle, deserialization-specific factory methods\n                 (LinkedNode<DeserializationProblemHandler>) null);\n     }\n \n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features enabled.\n-     */\n-    public DeserializationConfig with(DeserializationFeature feature)\n-    {\n-        int newDeserFeatures = (_deserFeatures | feature.getMask());\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-\n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features enabled.\n-     */\n-    public DeserializationConfig with(DeserializationFeature first,\n-            DeserializationFeature... features)\n-    {\n-        int newDeserFeatures = _deserFeatures | first.getMask();\n-        for (DeserializationFeature f : features) {\n-            newDeserFeatures |= f.getMask();\n-        }\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-\n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features enabled.\n-     */\n-    public DeserializationConfig withFeatures(DeserializationFeature... features)\n-    {\n-        int newDeserFeatures = _deserFeatures;\n-        for (DeserializationFeature f : features) {\n-            newDeserFeatures |= f.getMask();\n-        }\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-    \n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified feature disabled.\n-     */\n-    public DeserializationConfig without(DeserializationFeature feature)\n-    {\n-        int newDeserFeatures = _deserFeatures & ~feature.getMask();\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-\n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features disabled.\n-     */\n-    public DeserializationConfig without(DeserializationFeature first,\n-            DeserializationFeature... features)\n-    {\n-        int newDeserFeatures = _deserFeatures & ~first.getMask();\n-        for (DeserializationFeature f : features) {\n-            newDeserFeatures &= ~f.getMask();\n-        }\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n-    }\n-\n-    /**\n-     * Fluent factory method that will construct and return a new configuration\n-     * object instance with specified features disabled.\n-     */\n-    public DeserializationConfig withoutFeatures(DeserializationFeature... features)\n-    {\n-        int newDeserFeatures = _deserFeatures;\n-        for (DeserializationFeature f : features) {\n-            newDeserFeatures &= ~f.getMask();\n-        }\n-        return (newDeserFeatures == _deserFeatures) ? this :\n-            new DeserializationConfig(this, _mapperFeatures, newDeserFeatures);\n+    /*\n+    /**********************************************************\n+    /* JsonParser initialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called by {@link ObjectMapper} and {@link ObjectReader}\n+     * to modify those {@link com.fasterxml.jackson.core.JsonParser.Feature} settings\n+     * that have been configured via this config instance.\n+     * \n+     * @since 2.5\n+     */\n+    public void initialize(JsonParser p) {\n+        if (_parserFeaturesToChange != 0) {\n+            int orig = p.getFeatureMask();\n+            int newFlags = (orig & ~_parserFeaturesToChange) | _parserFeatures;\n+            if (orig != newFlags) {\n+                p.setFeatureMask(newFlags);\n+            }\n+        }\n     }\n     \n     /*\n         return (_deserFeatures & f.getMask()) != 0;\n     }\n \n+    public final boolean isEnabled(JsonParser.Feature f, JsonFactory factory) {\n+        int mask = f.getMask();\n+        if ((_parserFeaturesToChange & mask) != 0) {\n+            return (_parserFeatures & f.getMask()) != 0;\n+        }\n+        return factory.isEnabled(f);\n+    }\n+    \n     /**\n      * \"Bulk\" access method for checking that all features specified by\n      * mask are enabled.\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n         _attributes = config.getAttributes();\n     }\n \n+    /**\n+     * Copy-constructor for use with <code>copy()</code> by {@link ObjectMapper#copy()}\n+     */\n+    protected DeserializationContext(DeserializationContext src) {\n+        _cache = new DeserializerCache();\n+        _factory = src._factory;\n+\n+        _config = src._config;\n+        _featureFlags = src._featureFlags;\n+        _view = src._view;\n+        _injectableValues = null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* DatabindContext implementation\n     /**\n      * Method for checking whether we could find a deserializer\n      * for given type.\n-     * \n+     *\n      * @param type\n      * @since 2.3\n      */\n     }\n \n     /**\n+     * Variant that will try to locate deserializer for current type, but without\n+     * performing any contextualization (unlike {@link #findContextualValueDeserializer})\n+     * or checking for need to create a {@link TypeDeserializer} (unlike\n+     * {@link #findRootValueDeserializer(JavaType)}.\n+     * This method is usually called from within {@link ResolvableDeserializer#resolve},\n+     * and expectation is that caller then calls either\n+     * {@link #handlePrimaryContextualization(JsonDeserializer, BeanProperty)} or\n+     * {@link #handleSecondaryContextualization(JsonDeserializer, BeanProperty)} at a\n+     * later point, as necessary.\n+     *\n+     * @since 2.5\n+     */\n+    public final JsonDeserializer<Object> findNonContextualValueDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        return _cache.findValueDeserializer(this, _factory, type);\n+    }\n+    \n+    /**\n      * Method for finding a deserializer for root-level value.\n      */\n     @SuppressWarnings(\"unchecked\")\n             BeanProperty prop)\n         throws JsonMappingException\n     {\n-        if (deser != null) {\n-            if (deser instanceof ContextualDeserializer) {\n-                deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n-            }\n+        if (deser instanceof ContextualDeserializer) {\n+            deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n         }\n         return deser;\n     }\n      */\n     public JsonDeserializer<?> handleSecondaryContextualization(JsonDeserializer<?> deser,\n             BeanProperty prop)\n-        throws JsonMappingException {\n-        if (deser != null && (deser instanceof ContextualDeserializer)) {\n+        throws JsonMappingException\n+    {\n+        if (deser instanceof ContextualDeserializer) {\n             deser = ((ContextualDeserializer) deser).createContextual(this, prop);\n         }\n         return deser;\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n     ;\n \n     private final boolean _defaultState;\n+    private final int _mask;\n     \n     private DeserializationFeature(boolean defaultState) {\n         _defaultState = defaultState;\n+        _mask = (1 << ordinal());\n     }\n \n     @Override\n     public boolean enabledByDefault() { return _defaultState; }\n \n     @Override\n-    public int getMask() { return (1 << ordinal()); }\n+    public int getMask() { return _mask; }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n  * and as keys for deserializers.\n  *<p>\n  * Instances can (only) be constructed by\n- * <code>com.fasterxml.jackson.databind.TypeFactory</code>.\n+ * <code>com.fasterxml.jackson.databind.type.TypeFactory</code>.\n  *<p>\n  * Since 2.2 this implements {@link java.lang.reflect.Type} to allow\n  * it to be pushed through interfaces that only expose that type.\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n import java.math.BigInteger;\n import java.util.*;\n \n-import com.fasterxml.jackson.core.JsonPointer;\n-import com.fasterxml.jackson.core.TreeNode;\n+import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.node.JsonNodeType;\n import com.fasterxml.jackson.databind.node.MissingNode;\n import com.fasterxml.jackson.databind.util.EmptyIterator;\n  *<p>\n  * Actual concrete sub-classes can be found from package\n  * {@link com.fasterxml.jackson.databind.node}.\n+ *<p>\n+ * Note that it is possible to \"read\" from nodes, using\n+ * method {@link TreeNode#traverse(ObjectCodec)}, which will result in\n+ * a {@link JsonParser} being constructed. This can be used for (relatively)\n+ * efficient conversations between different representations; and it is what\n+ * core databind uses for methods like {@link ObjectMapper#treeToValue(TreeNode, Class)}\n+ * and {@link ObjectMapper#treeAsTokens(TreeNode)}\n  */\n public abstract class JsonNode\n-    implements TreeNode, Iterable<JsonNode>\n+    implements TreeNode, Iterable<JsonNode>,\n+        JsonSerializable // since 2.5; bit tricky if anyone is sub-classing but...\n {\n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-//    public abstract JsonToken asToken();\n-\n-//    public abstract JsonParser.NumberType numberType();\n-\n-//    public abstract JsonParser traverse();\n+//  public abstract JsonToken asToken();\n+//  public abstract JsonToken traverse();\n+//  public abstract JsonToken traverse(ObjectCodec codec);\n+//  public abstract JsonParser.NumberType numberType();\n \n     @Override\n     public int size() { return 0; }\n--- a/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n      * \n      * @since 2.1\n      */\n-    USE_WRAPPER_NAME_AS_PROPERTY_NAME(false)\n+    USE_WRAPPER_NAME_AS_PROPERTY_NAME(false),\n+    \n+    /*\n+    /******************************************************\n+    /* Other features\n+    /******************************************************\n+     */\n+\n+    /**\n+     * Feature that determines whether multiple registrations of same module\n+     * should be ignored or not; if enabled, only the first registration call\n+     * results in module being called, and possible duplicate calls are silently\n+     * ignored; if disabled, no checking is done and all registration calls are\n+     * dispatched to module.\n+     *<p>\n+     * Definition of \"same module\" is based on using {@link Module#getTypeId()};\n+     * modules with same non-null <code>type id</code> are considered same for\n+     * purposes of duplicate registration. This also avoids having to keep track\n+     * of actual module instances; only ids will be kept track of (and only if\n+     * this feature is enabled).\n+     *<p>\n+     * Feature is enabled by default.\n+     *\n+     * @since 2.5\n+     */\n+    IGNORE_DUPLICATE_MODULE_REGISTRATIONS(true)\n+    \n     ;\n \n     private final boolean _defaultState;\n+    private final int _mask;\n     \n     private MapperFeature(boolean defaultState) {\n         _defaultState = defaultState;\n+        _mask = (1 << ordinal());\n     }\n     \n     @Override\n     public boolean enabledByDefault() { return _defaultState; }\n \n     @Override\n-    public int getMask() { return (1 << ordinal()); }\n+    public int getMask() { return _mask; }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n      */\n     @Deprecated\n     protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt,\n-            JsonDeserializer<?> deser)\n-    {\n+            JsonDeserializer<?> deser) {\n         this(type, jp, ctxt, deser, true, null);\n     }\n \n         try {\n             return hasNextValue();\n         } catch (JsonMappingException e) {\n-            throw new RuntimeJsonMappingException(e.getMessage(), e);\n+            return (Boolean) _handleMappingException(e);\n         } catch (IOException e) {\n-            throw new RuntimeException(e.getMessage(), e);\n-        }\n-    }\n-\n+            return (Boolean) _handleIOException(e);\n+        }\n+    }\n+    \n     @Override\n     public T next()\n     {\n     \n     @Override\n     public void close() throws IOException{\n-        if(_parser != null) {\n+        if (_parser != null) {\n             _parser.close();\n         }\n     }\n         // caller should always call 'hasNext[Value]' first; but let's ensure:\n         if (!_hasNextChecked) {\n             if (!hasNextValue()) {\n-                throw new NoSuchElementException();\n+                return _throwNoSuchElement();\n             }\n         }\n         if (_parser == null) {\n-            throw new NoSuchElementException();\n+            return _throwNoSuchElement();\n         }\n         _hasNextChecked = false;\n         T result;\n \n     /**\n      * Convenience method for reading all entries accessible via\n-     * this iterator\n+     * this iterator; resulting container will be a {@link java.util.ArrayList}.\n      * \n      * @return List of entries read\n      * \n      * \n      * @since 2.2\n      */\n-    public List<T> readAll(List<T> resultList) throws IOException\n+    public <L extends List<? super T>> L readAll(L resultList) throws IOException\n     {\n         while (hasNextValue()) {\n-    \t\t    resultList.add(nextValue());\n+            resultList.add(nextValue());\n         }\n         return resultList;\n+    }\n+\n+    /**\n+     * Convenience method for reading all entries accessible via\n+     * this iterator\n+     * \n+     * @since 2.5\n+     */\n+    public <C extends Collection<? super T>> C readAll(C results) throws IOException\n+    {\n+        while (hasNextValue()) {\n+            results.add(nextValue());\n+        }\n+        return results;\n     }\n     \n     /*\n     public JsonLocation getCurrentLocation() {\n         return _parser.getCurrentLocation();\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected <R> R _throwNoSuchElement() {\n+        throw new NoSuchElementException();\n+    }\n+    \n+    protected <R> R _handleMappingException(JsonMappingException e) {\n+        throw new RuntimeJsonMappingException(e.getMessage(), e);\n+    }\n+\n+    protected <R> R _handleIOException(IOException e) {\n+        throw new RuntimeException(e.getMessage(), e);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/Module.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/Module.java\n      */\n     \n     /**\n-     * Method that returns identifier for module; this can be used by Jackson\n+     * Method that returns a display that can be used by Jackson\n      * for informational purposes, as well as in associating extensions with\n      * module that provides them.\n      */\n     @Override\n     public abstract Version version();\n \n+    /**\n+     * Method that returns an id that may be used to determine if two {@link Module}\n+     * instances are considered to be of same type, for purpose of preventing\n+     * multiple registrations of \"same type of\" module\n+     * (see {@link com.fasterxml.jackson.databind.MapperFeature#IGNORE_DUPLICATE_MODULE_REGISTRATIONS})\n+     * If `null` is returned, every instance is considered unique.\n+     * If non-null value is returned, equality of id Objects is used to check whether\n+     * modules should be considered to be \"of same type\"\n+     *<p>\n+     * Default implementation returns value of class name ({@link Class#getName}).\n+     *\n+     * @since 2.5\n+     */\n+    public Object getTypeId() {\n+        return getClass().getName();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle: registration\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n \n     /*\n     /**********************************************************\n+    /* Module-related\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Set of module types (as per {@link Module#getTypeId()} that have been\n+     * registered; kept track of iff {@link MapperFeature#IGNORE_DUPLICATE_MODULE_REGISTRATIONS}\n+     * is enabled, so that duplicate registration calls can be ignored\n+     * (to avoid adding same handlers multiple times, mostly).\n+     * \n+     * @since 2.5\n+     */\n+    protected Set<Object> _registeredModuleTypes;\n+    \n+    /*\n+    /**********************************************************\n     /* Caching\n     /**********************************************************\n      */\n \n     /**\n      * We will use a separate main-level Map for keeping track\n-     * of root-level deserializers. This is where most succesful\n+     * of root-level deserializers. This is where most successful\n      * cache lookups get resolved.\n      * Map will contain resolvers for all kinds of types, including\n      * container types: this is different from the component cache\n      * Java Beans (based on method names and Jackson-specific annotations),\n      * but does not support JAXB annotations.\n      */\n-    public ObjectMapper()\n-    {\n+    public ObjectMapper() {\n         this(null, null, null);\n     }\n \n      * for constructing necessary {@link JsonParser}s and/or\n      * {@link JsonGenerator}s.\n      */\n-    public ObjectMapper(JsonFactory jf)\n-    {\n+    public ObjectMapper(JsonFactory jf) {\n         this(jf, null, null);\n     }\n \n         _subtypeResolver = src._subtypeResolver;\n         _rootNames = new RootNameLookup();\n         _typeFactory = src._typeFactory;\n-        _serializationConfig = src._serializationConfig;\n         HashMap<ClassKey,Class<?>> mixins = new HashMap<ClassKey,Class<?>>(src._mixInAnnotations);\n         _mixInAnnotations = mixins;\n         _serializationConfig = new SerializationConfig(src._serializationConfig, mixins);\n         _deserializationConfig = new DeserializationConfig(src._deserializationConfig, mixins);\n-        _serializerProvider = src._serializerProvider;\n-        _deserializationContext = src._deserializationContext;\n+        _serializerProvider = src._serializerProvider.copy();\n+        _deserializationContext = src._deserializationContext.copy();\n \n         // Default serializer factory is stateless, can just assign\n         _serializerFactory = src._serializerFactory;\n         // Default serializer factory is stateless, can just assign\n         _serializerFactory = BeanSerializerFactory.instance;\n     }\n+\n+    /**\n+     * Overridable helper method used to construct default {@link ClassIntrospector}\n+     * to use.\n+     * \n+     * @since 2.5\n+     */\n+    protected ClassIntrospector defaultClassIntrospector() {\n+        return new BasicClassIntrospector();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Methods sub-classes MUST override\n+    /**********************************************************\n+     */\n     \n     /**\n      * Method for creating a new {@link ObjectMapper} instance that\n      * \n      * @since 2.1\n      */\n-    public ObjectMapper copy()\n-    {\n+    public ObjectMapper copy() {\n         _checkInvalidCopy(ObjectMapper.class);\n         return new ObjectMapper(this);\n     }\n         }\n     }\n \n-    /**\n-     * Overridable helper method used to construct default {@link ClassIntrospector}\n-     * to use.\n+    /*\n+    /**********************************************************\n+    /* Methods sub-classes MUST override if providing custom\n+    /* ObjectReader/ObjectWriter implementations\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectReader}\n+     * instances of proper sub-type\n      * \n      * @since 2.5\n      */\n-    protected ClassIntrospector defaultClassIntrospector() {\n-        return new BasicClassIntrospector();\n-    }\n-    \n+    protected ObjectReader _newReader(DeserializationConfig config) {\n+        return new ObjectReader(this, config);\n+    }\n+\n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectReader}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _newReader(DeserializationConfig config,\n+            JavaType valueType, Object valueToUpdate,\n+            FormatSchema schema, InjectableValues injectableValues) {\n+        return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues);\n+    }\n+\n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _newWriter(SerializationConfig config) {\n+        return new ObjectWriter(this, config);\n+    }\n+\n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) {\n+        return new ObjectWriter(this, config, schema);\n+    }\n+    \n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _newWriter(SerializationConfig config,\n+            JavaType rootType, PrettyPrinter pp) {\n+        return new ObjectWriter(this, config, rootType, pp);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Versioned impl\n     public Version version() {\n         return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Module registration, discovery\n      */\n     public ObjectMapper registerModule(Module module)\n     {\n+        if (isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS)) {\n+            Object typeId = module.getTypeId();\n+            if (typeId != null) {\n+                if (_registeredModuleTypes == null) {\n+                    _registeredModuleTypes = new HashSet<Object>();\n+                }\n+                // try adding; if already had it, should skip\n+                if (!_registeredModuleTypes.add(typeId)) {\n+                    return this;\n+                }\n+            }\n+        }\n+        \n         /* Let's ensure we have access to name and version information, \n          * even if we do not have immediate use for either. This way we know\n          * that they will be available from beginning\n             \n             @Override\n             public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n-                mapper.addMixInAnnotations(target, mixinSource);\n+                mapper.addMixIn(target, mixinSource);\n             }\n             \n             @Override\n     /* Configuration: mix-in annotations\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Method to use for defining mix-in annotations to use for augmenting\n      * annotations that processable (serializable / deserializable)\n      * Annotations from source classes (and their supertypes)\n      * will <b>override</b>\n      * annotations that target classes (and their super-types) have.\n-     */\n-    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins)\n     {\n         _mixInAnnotations.clear();\n         if (sourceMixins != null && sourceMixins.size() > 0) {\n                 _mixInAnnotations.put(new ClassKey(en.getKey()), en.getValue());\n             }\n         }\n+        return this;\n     }\n \n     /**\n      * @param target Class (or interface) whose annotations to effectively override\n      * @param mixinSource Class (or interface) whose annotations are to\n      *   be \"added\" to target's annotations, overriding as necessary\n-     */\n-    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)\n     {\n         _mixInAnnotations.put(new ClassKey(target), mixinSource);\n-    }\n-\n-    public final Class<?> findMixInClassFor(Class<?> cls) {\n+        return this;\n+    }\n+\n+    public Class<?> findMixInClassFor(Class<?> cls) {\n         return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n     }\n \n-    public final int mixInCount() {\n+    public int mixInCount() {\n         return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n+    }\n+\n+\n+    /**\n+     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #setMixIns}.\n+     */\n+    @Deprecated\n+    public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) {\n+        setMixIns(sourceMixins);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #addMixIn(Class, Class)}.\n+     */\n+    @Deprecated\n+    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n+        addMixIn(target, mixinSource);\n     }\n     \n     /*\n     public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)\n     {\n         /* 18-Sep-2014, tatu: Let's add explicit check to ensure no one tries to\n-         *   use \"As.EXTERNAL_PROPERTY\", since that will not work.\n+         *   use \"As.EXTERNAL_PROPERTY\", since that will not work (with 2.5+)\n          */\n         if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n             throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs);\n     /* Configuration, deserialization\n     /**********************************************************\n      */\n+\n+    /**\n+     * Method that can be used to get hold of {@link JsonNodeFactory}\n+     * that this mapper will use when directly constructing\n+     * root {@link JsonNode} instances for Trees.\n+     *<p>\n+     * Note: this is just a shortcut for calling\n+     *<pre>\n+     *   getDeserializationConfig().getNodeFactory()\n+     *</pre>\n+     */\n+    public JsonNodeFactory getNodeFactory() {\n+        return _deserializationConfig.getNodeFactory();\n+    }\n     \n     /**\n      * Method for specifying {@link JsonNodeFactory} to use for\n      * @since 2.4\n      */\n     public ObjectMapper setConfig(SerializationConfig config) {\n-    \t_serializationConfig = config;\n-    \treturn this;\n+        _serializationConfig = config;\n+        return this;\n     }\n     \n     /*\n     \n     /*\n     /**********************************************************\n-    /* Configuration, simple features\n-    /**********************************************************\n-     */\n-\n+    /* Configuration, simple features: MapperFeature\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given {@link MapperFeature} is enabled.\n+     */\n+    public boolean isEnabled(MapperFeature f) {\n+        // ok to use either one, should be kept in sync\n+        return _serializationConfig.isEnabled(f);\n+    }\n+    \n     /**\n      * Method for changing state of an on/off mapper feature for\n      * this mapper instance.\n                 _deserializationConfig.with(f) : _deserializationConfig.without(f);\n         return this;\n     }\n-    \n+\n+    /**\n+     * Method for enabling specified {@link MapperConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper enable(MapperFeature... f) {\n+        _deserializationConfig = _deserializationConfig.with(f);\n+        _serializationConfig = _serializationConfig.with(f);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper disable(MapperFeature... f) {\n+        _deserializationConfig = _deserializationConfig.without(f);\n+        _serializationConfig = _serializationConfig.without(f);\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: SerializationFeature\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given serialization-specific\n+     * feature is enabled.\n+     */\n+    public boolean isEnabled(SerializationFeature f) {\n+        return _serializationConfig.isEnabled(f);\n+    }\n+\n     /**\n      * Method for changing state of an on/off serialization feature for\n      * this object mapper.\n     }\n \n     /**\n+     * Method for enabling specified {@link DeserializationConfig} feature.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper enable(SerializationFeature f) {\n+        _serializationConfig = _serializationConfig.with(f);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper enable(SerializationFeature first,\n+            SerializationFeature... f) {\n+        _serializationConfig = _serializationConfig.with(first, f);\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper disable(SerializationFeature f) {\n+        _serializationConfig = _serializationConfig.without(f);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     */\n+    public ObjectMapper disable(SerializationFeature first,\n+            SerializationFeature... f) {\n+        _serializationConfig = _serializationConfig.without(first, f);\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: DeserializationFeature\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given deserialization-specific\n+     * feature is enabled.\n+     */\n+    public boolean isEnabled(DeserializationFeature f) {\n+        return _deserializationConfig.isEnabled(f);\n+    }\n+\n+    /**\n      * Method for changing state of an on/off deserialization feature for\n      * this object mapper.\n      */\n     }\n \n     /**\n-     * Method for changing state of an on/off {@link JsonParser} feature for\n-     * {@link JsonFactory} instance this object mapper uses.\n-     *<p>\n-     * This is method is basically a shortcut method for calling\n-     * {@link JsonFactory#enable} on the shared\n-     * {@link JsonFactory} this mapper uses (which is accessible\n-     * using {@link #getJsonFactory}).\n-     */\n-    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n-        _jsonFactory.configure(f, state);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for changing state of an on/off {@link JsonGenerator} feature for\n-     * {@link JsonFactory} instance this object mapper uses.\n-     *<p>\n-     * This is method is basically a shortcut method for calling\n-     * {@link JsonFactory#enable} on the shared\n-     * {@link JsonFactory} this mapper uses (which is accessible\n-     * using {@link #getJsonFactory}).\n-     */\n-    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n-        _jsonFactory.configure(f, state);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for enabling specified {@link MapperConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper enable(MapperFeature... f) {\n-        _deserializationConfig = _deserializationConfig.with(f);\n-        _serializationConfig = _serializationConfig.with(f);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper disable(MapperFeature... f) {\n-        _deserializationConfig = _deserializationConfig.without(f);\n-        _serializationConfig = _serializationConfig.without(f);\n-        return this;\n-    }\n-    \n-    /**\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n      */\n         return this;\n     }\n     \n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} feature.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper enable(SerializationFeature f) {\n-        _serializationConfig = _serializationConfig.with(f);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper enable(SerializationFeature first,\n-            SerializationFeature... f) {\n-        _serializationConfig = _serializationConfig.with(first, f);\n-        return this;\n-    }\n-    \n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper disable(SerializationFeature f) {\n-        _serializationConfig = _serializationConfig.without(f);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for enabling specified {@link DeserializationConfig} features.\n-     * Modifies and returns this instance; no new object is created.\n-     */\n-    public ObjectMapper disable(SerializationFeature first,\n-            SerializationFeature... f) {\n-        _serializationConfig = _serializationConfig.without(first, f);\n-        return this;\n-    }\n-\n-    /**\n-     * Method for checking whether given Mapper\n-     * feature is enabled.\n-     */\n-    public boolean isEnabled(MapperFeature f) {\n-        // ok to use either one, should be kept in sync\n-        return _serializationConfig.isEnabled(f);\n-    }\n-\n-    /**\n-     * Method for checking whether given serialization-specific\n-     * feature is enabled.\n-     */\n-    public boolean isEnabled(SerializationFeature f) {\n-        return _serializationConfig.isEnabled(f);\n-    }\n-    \n-    /**\n-     * Method for checking whether given deserialization-specific\n-     * feature is enabled.\n-     */\n-    public boolean isEnabled(DeserializationFeature f) {\n-        return _deserializationConfig.isEnabled(f);\n-    }\n-\n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: JsonParser.Feature\n+    /**********************************************************\n+     */\n+\n+    public boolean isEnabled(JsonParser.Feature f) {\n+        return _deserializationConfig.isEnabled(f, _jsonFactory);\n+    }\n+\n+    /**\n+     * Method for changing state of specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method\n+     * on {@link #getFactory}.\n+     */\n+    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n+        _jsonFactory.configure(f, state);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper enable(JsonParser.Feature... features) {\n+        for (JsonParser.Feature f : features) {\n+            _jsonFactory.enable(f);\n+        }\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for disabling specified {@link com.fasterxml.jackson.core.JsonParser.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper disable(JsonParser.Feature... features) {\n+        for (JsonParser.Feature f : features) {\n+            _jsonFactory.disable(f);\n+        }\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: JsonGenerator.Feature\n+    /**********************************************************\n+     */\n+\n+    public boolean isEnabled(JsonGenerator.Feature f) {\n+        return _serializationConfig.isEnabled(f, _jsonFactory);\n+    }\n+\n+    /**\n+     * Method for changing state of an on/off {@link JsonGenerator} feature for\n+     * generator instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method\n+     * on {@link #getFactory}.\n+     */\n+    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n+        _jsonFactory.configure(f,  state);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper enable(JsonGenerator.Feature... features) {\n+        for (JsonGenerator.Feature f : features) {\n+            _jsonFactory.enable(f);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for disabling specified {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s\n+     * for parser instances this object mapper creates.\n+     *<p>\n+     * Note that this is equivalent to directly calling same method on {@link #getFactory}.\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper disable(JsonGenerator.Feature... features) {\n+        for (JsonGenerator.Feature f : features) {\n+            _jsonFactory.disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features: JsonFactory.Feature\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Convenience method, equivalent to:\n      *<pre>\n      */\n     public boolean isEnabled(JsonFactory.Feature f) {\n         return _jsonFactory.isEnabled(f);\n-    }\n-\n-    /**\n-     * Convenience method, equivalent to:\n-     *<pre>\n-     *  getJsonFactory().isEnabled(f);\n-     *</pre>\n-     */\n-    public boolean isEnabled(JsonParser.Feature f) {\n-        return _jsonFactory.isEnabled(f);\n-    }\n-    \n-    /**\n-     * Convenience method, equivalent to:\n-     *<pre>\n-     *  getJsonFactory().isEnabled(f);\n-     *</pre>\n-     */\n-    public boolean isEnabled(JsonGenerator.Feature f) {\n-        return _jsonFactory.isEnabled(f);\n-    }\n-    \n-    /**\n-     * Method that can be used to get hold of {@link JsonNodeFactory}\n-     * that this mapper will use when directly constructing\n-     * root {@link JsonNode} instances for Trees.\n-     *<p>\n-     * Note: this is just a shortcut for calling\n-     *<pre>\n-     *   getDeserializationConfig().getNodeFactory()\n-     *</pre>\n-     */\n-    public JsonNodeFactory getNodeFactory() {\n-        return _deserializationConfig.getNodeFactory();\n     }\n \n     /*\n      * @param n Root node of the tree that resulting parser will read from\n      */\n     @Override\n-    public JsonParser treeAsTokens(TreeNode n)\n-    {\n+    public JsonParser treeAsTokens(TreeNode n) {\n         return new TreeTraversingParser((JsonNode) n, this);\n     }\n \n      * Convenience method for constructing {@link ObjectWriter}\n      * with default settings.\n      */\n-    public ObjectWriter writer() {\n-        return new ObjectWriter(this, getSerializationConfig());\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer() {\n+        return (W) _newWriter(getSerializationConfig());\n     }\n \n     /**\n      * specified feature enabled (compared to settings that this\n      * mapper instance has).\n      */\n-    public ObjectWriter writer(SerializationFeature feature) {\n-        return new ObjectWriter(this, getSerializationConfig().with(feature));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(SerializationFeature feature) {\n+        return (W) _newWriter(getSerializationConfig().with(feature));\n     }\n \n     /**\n      * specified features enabled (compared to settings that this\n      * mapper instance has).\n      */\n-    public ObjectWriter writer(SerializationFeature first,\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(SerializationFeature first,\n             SerializationFeature... other) {\n-        return new ObjectWriter(this, getSerializationConfig().with(first, other));\n+        return (W) _newWriter(getSerializationConfig().with(first, other));\n     }\n     \n     /**\n      * serialize objects using specified {@link DateFormat}; or, if\n      * null passed, using timestamp (64-bit number.\n      */\n-    public ObjectWriter writer(DateFormat df) {\n-        return new ObjectWriter(this, getSerializationConfig().with(df));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(DateFormat df) {\n+        return (W) _newWriter(getSerializationConfig().with(df));\n     }\n     \n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified JSON View (filter).\n      */\n-    public ObjectWriter writerWithView(Class<?> serializationView) {\n-        return new ObjectWriter(this, getSerializationConfig().withView(serializationView));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerWithView(Class<?> serializationView) {\n+        return (W) _newWriter(getSerializationConfig().withView(serializationView));\n     }\n     \n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified root type, instead of actual\n-     * runtime type of value. Type must be a super-type of runtime\n-     * type.\n-     */\n-    public ObjectWriter writerWithType(Class<?> rootType) {\n-        return new ObjectWriter(this, getSerializationConfig(),\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     *<p>\n+     * Main reason for using this method is performance, as writer is able\n+     * to pre-fetch serializer to use before write, and if writer is used\n+     * more than once this avoids addition per-value serializer lookups.\n+     * \n+     * @since 2.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerFor(Class<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n+                ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n+                /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified root type, instead of actual\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     *<p>\n+     * Main reason for using this method is performance, as writer is able\n+     * to pre-fetch serializer to use before write, and if writer is used\n+     * more than once this avoids addition per-value serializer lookups.\n+     * \n+     * @since 2.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerFor(TypeReference<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n+                ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n+                /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified root type, instead of actual\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     *<p>\n+     * Main reason for using this method is performance, as writer is able\n+     * to pre-fetch serializer to use before write, and if writer is used\n+     * more than once this avoids addition per-value serializer lookups.\n+     * \n+     * @since 2.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerFor(JavaType rootType) {\n+        return (W) _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5, use {@link #writerFor(Class)} instead\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n+    public <W extends ObjectWriter> W writerWithType(Class<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                 ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                 /*PrettyPrinter*/null);\n     }\n \n     /**\n-     * Factory method for constructing {@link ObjectWriter} that will\n-     * serialize objects using specified root type, instead of actual\n-     * runtime type of value. Type must be a super-type of runtime type.\n-     */\n-    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n-        return new ObjectWriter(this, getSerializationConfig(),\n+     * @deprecated Since 2.5, use {@link #writerFor(TypeReference)} instead\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n+    public <W extends ObjectWriter> W writerWithType(TypeReference<?> rootType) {\n+        return (W) _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                 ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                 /*PrettyPrinter*/null);\n     }\n \n     /**\n-     * Factory method for constructing {@link ObjectWriter} that will\n-     * serialize objects using specified root type, instead of actual\n-     * runtime type of value. Type must be a super-type of runtime type.\n-     */\n-    public ObjectWriter writerWithType(JavaType rootType) {\n-        return new ObjectWriter(this, getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n+     * @deprecated Since 2.5, use {@link #writerFor(JavaType)} instead\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Deprecated\n+    public <W extends ObjectWriter> W writerWithType(JavaType rootType) {\n+        return (W) _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n     }\n     \n     /**\n      * serialize objects using specified pretty printer for indentation\n      * (or if null, no pretty printer)\n      */\n-    public ObjectWriter writer(PrettyPrinter pp) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(PrettyPrinter pp) {\n         if (pp == null) { // need to use a marker to indicate explicit disabling of pp\n             pp = ObjectWriter.NULL_PRETTY_PRINTER;\n         }\n-        return new ObjectWriter(this, getSerializationConfig(), /*root type*/ null, pp);\n+        return (W) _newWriter(getSerializationConfig(), /*root type*/ null, pp);\n     }\n     \n     /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using the default pretty printer for indentation\n      */\n-    public ObjectWriter writerWithDefaultPrettyPrinter() {\n-        return new ObjectWriter(this, getSerializationConfig(),\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writerWithDefaultPrettyPrinter() {\n+        return (W) _newWriter(getSerializationConfig(),\n                 /*root type*/ null, _defaultPrettyPrinter());\n     }\n     \n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified filter provider.\n      */\n-    public ObjectWriter writer(FilterProvider filterProvider) {\n-        return new ObjectWriter(this,\n-                getSerializationConfig().withFilters(filterProvider));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(FilterProvider filterProvider) {\n+        return (W) _newWriter(getSerializationConfig().withFilters(filterProvider));\n     }\n     \n     /**\n      * \n      * @param schema Schema to pass to generator\n      */\n-    public ObjectWriter writer(FormatSchema schema) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(FormatSchema schema) {\n         _verifySchemaType(schema);\n-        return new ObjectWriter(this, getSerializationConfig(), schema);\n+        return (W) _newWriter(getSerializationConfig(), schema);\n     }\n \n     /**\n      * \n      * @since 2.1\n      */\n-    public ObjectWriter writer(Base64Variant defaultBase64) {\n-        return new ObjectWriter(this, getSerializationConfig().with(defaultBase64));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(Base64Variant defaultBase64) {\n+        return (W) _newWriter(getSerializationConfig().with(defaultBase64));\n     }\n \n     /**\n      * \n      * @since 2.3\n      */\n-    public ObjectWriter writer(CharacterEscapes escapes) {\n-        return writer().with(escapes);\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(CharacterEscapes escapes) {\n+        return (W) _newWriter(getSerializationConfig()).with(escapes);\n     }\n \n     /**\n      * \n      * @since 2.3\n      */\n-    public ObjectWriter writer(ContextAttributes attrs) {\n-        return new ObjectWriter(this, getSerializationConfig().with(attrs));\n+    @SuppressWarnings(\"unchecked\")\n+    public <W extends ObjectWriter> W writer(ContextAttributes attrs) {\n+        return (W) _newWriter(getSerializationConfig().with(attrs));\n     }\n     \n     /*\n      * default settings. Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader() {\n-        return new ObjectReader(this, getDeserializationConfig())\n-            .with(_injectableValues);\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader() {\n+        return (T) _newReader(getDeserializationConfig()).with(_injectableValues);\n     }\n \n     /**\n      * Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader(DeserializationFeature feature) {\n-        return new ObjectReader(this, getDeserializationConfig().with(feature));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(DeserializationFeature feature) {\n+        return (T) _newReader(getDeserializationConfig().with(feature));\n     }\n \n     /**\n      * Note that the resulting instance is NOT usable as is,\n      * without defining expected value type.\n      */\n-    public ObjectReader reader(DeserializationFeature first,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(DeserializationFeature first,\n             DeserializationFeature... other) {\n-        return new ObjectReader(this, getDeserializationConfig().with(first, other));\n+        return (T) _newReader(getDeserializationConfig().with(first, other));\n     }\n     \n     /**\n      * Runtime type of value object is used for locating deserializer,\n      * unless overridden by other factory methods of {@link ObjectReader}\n      */\n-    public ObjectReader readerForUpdating(Object valueToUpdate)\n-    {\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T readerForUpdating(Object valueToUpdate) {\n         JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n-        return new ObjectReader(this, getDeserializationConfig(), t, valueToUpdate,\n+        return (T) _newReader(getDeserializationConfig(), t, valueToUpdate,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(JavaType type)\n-    {\n-        return new ObjectReader(this, getDeserializationConfig(), type, null,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(JavaType type) {\n+        return (T) _newReader(getDeserializationConfig(), type, null,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(Class<?> type)\n-    {\n-        return reader(_typeFactory.constructType(type));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(Class<?> type) {\n+        return (T) _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n+                null, _injectableValues);\n     }\n \n     /**\n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(TypeReference<?> type)\n-    {\n-        return reader(_typeFactory.constructType(type));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(TypeReference<?> type) {\n+        return (T)_newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n+                null, _injectableValues);\n     }\n \n     /**\n      * Factory method for constructing {@link ObjectReader} that will\n      * use specified {@link JsonNodeFactory} for constructing JSON trees.\n      */\n-    public ObjectReader reader(JsonNodeFactory f)\n-    {\n-        return new ObjectReader(this, getDeserializationConfig()).with(f);\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(JsonNodeFactory f) {\n+        return (T) _newReader(getDeserializationConfig()).with(f);\n     }\n \n     /**\n      * \n      * @param schema Schema to pass to parser\n      */\n-    public ObjectReader reader(FormatSchema schema) {\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(FormatSchema schema) {\n         _verifySchemaType(schema);\n-        return new ObjectReader(this, getDeserializationConfig(), null, null,\n+        return (T)_newReader(getDeserializationConfig(), null, null,\n                 schema, _injectableValues);\n     }\n \n      * \n      * @param injectableValues Injectable values to use\n      */\n-    public ObjectReader reader(InjectableValues injectableValues) {\n-        return new ObjectReader(this, getDeserializationConfig(), null, null,\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(InjectableValues injectableValues) {\n+        return (T)_newReader(getDeserializationConfig(), null, null,\n                 null, injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * deserialize objects using specified JSON View (filter).\n      */\n-    public ObjectReader readerWithView(Class<?> view) {\n-        return new ObjectReader(this, getDeserializationConfig().withView(view));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T readerWithView(Class<?> view) {\n+        return (T) _newReader(getDeserializationConfig().withView(view));\n     }\n \n     /**\n      * \n      * @since 2.1\n      */\n-    public ObjectReader reader(Base64Variant defaultBase64) {\n-        return new ObjectReader(this, getDeserializationConfig().with(defaultBase64));\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(Base64Variant defaultBase64) {\n+        return (T) _newReader(getDeserializationConfig().with(defaultBase64));\n     }\n \n     /**\n      * \n      * @since 2.3\n      */\n-    public ObjectReader reader(ContextAttributes attrs) {\n-        return new ObjectReader(this, getDeserializationConfig().with(attrs));\n-    }\n-    \n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends ObjectReader> T reader(ContextAttributes attrs) {\n+        return (T) _newReader(getDeserializationConfig().with(attrs));\n+    }\n+\n     /*\n     /**********************************************************\n     /* Extended Public API: convenience type conversion\n     /**********************************************************\n      */\n-   \n+\n     /**\n      * Convenience method for doing two-step conversion from given value, into\n      * instance of given value type. This is functionality equivalent to first\n      * call write functionality\n      */\n     protected final void _configAndWriteValue(JsonGenerator jgen, Object value)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+        throws IOException\n     {\n         SerializationConfig cfg = getSerializationConfig();\n-        // [JACKSON-96]: allow enabling pretty printing for ObjectMapper directly\n-        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n-            jgen.useDefaultPrettyPrinter();\n-        }\n-        // [Issue#232]\n-        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n-            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n-        }\n-        // [JACKSON-282]: consider Closeable\n+        cfg.initialize(jgen); // since 2.5\n         if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             _configAndWriteCloseable(jgen, value, cfg);\n             return;\n     }\n \n     protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+        throws IOException\n     {\n         SerializationConfig cfg = getSerializationConfig().withView(viewClass);\n-        if (cfg.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n-            jgen.useDefaultPrettyPrinter();\n-        }\n-        // [Issue#232]\n-        if (cfg.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN)) {\n-            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n-        }\n+        cfg.initialize(jgen); // since 2.5\n \n         // [JACKSON-282]: consider Closeable\n         if (cfg.isEnabled(SerializationFeature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n             }\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Internal methods for deserialization, overridable\n      * Can be overridden if a custom context is needed.\n      */\n     protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n-            DeserializationConfig cfg)\n-    {\n-        return _deserializationContext.createInstance(cfg,\n-                jp, _injectableValues);\n+            DeserializationConfig cfg) {\n+        return _deserializationContext.createInstance(cfg, jp, _injectableValues);\n     }\n     \n     /**\n      *   content to map (note: Json \"null\" value is considered content;\n      *   enf-of-stream not)\n      */\n-    protected JsonToken _initForReading(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n+    protected JsonToken _initForReading(JsonParser p) throws IOException\n+    {\n+        _deserializationConfig.initialize(p); // since 2.5\n+\n         /* First: must point to a token; if not pointing to one, advance.\n          * This occurs before first read from JsonParser, as well as\n          * after clearing of current token.\n          */\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n         if (t == null) {\n             // and then we must get something...\n-            t = jp.nextToken();\n+            t = p.nextToken();\n             if (t == null) {\n                 /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n                  *   not an actual parsing problem\n                  */\n-                throw JsonMappingException.from(jp, \"No content to map due to end-of-input\");\n+                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n             }\n         }\n         return t;\n     }\n \n-    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt, \n+    protected Object _unwrapAndDeserialize(JsonParser p, DeserializationContext ctxt, \n             DeserializationConfig config,\n             JavaType rootType, JsonDeserializer<Object> deser)\n-        throws IOException, JsonParseException, JsonMappingException\n+        throws IOException\n     {\n         String expName = config.getRootName();\n         if (expName == null) {\n             PropertyName pname = _rootNames.findRootName(rootType, config);\n             expName = pname.getSimpleName();\n         }\n-        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n-            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        String actualName = jp.getCurrentName();\n+        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n+            throw JsonMappingException.from(p, \"Current token not START_OBJECT (needed to unwrap root name '\"\n+                    +expName+\"'), but \"+p.getCurrentToken());\n+        }\n+        if (p.nextToken() != JsonToken.FIELD_NAME) {\n+            throw JsonMappingException.from(p, \"Current token not FIELD_NAME (to contain expected root name '\"\n+                    +expName+\"'), but \"+p.getCurrentToken());\n+        }\n+        String actualName = p.getCurrentName();\n         if (!expName.equals(actualName)) {\n-            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n+            throw JsonMappingException.from(p, \"Root name '\"+actualName+\"' does not match expected ('\"\n                     +expName+\"') for type \"+rootType);\n         }\n         // ok, then move to value itself....\n-        jp.nextToken();\n-        Object result = deser.deserialize(jp, ctxt);\n+        p.nextToken();\n+        Object result = deser.deserialize(p, ctxt);\n         // and last, verify that we now get matching END_OBJECT\n-        if (jp.nextToken() != JsonToken.END_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n+        if (p.nextToken() != JsonToken.END_OBJECT) {\n+            throw JsonMappingException.from(p, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n+                    +expName+\"'), but \"+p.getCurrentToken());\n         }\n         return result;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n     extends ObjectCodec\n     implements Versioned, java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = -4251443320039569153L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n \n     /**\n      * Constructor used by {@link ObjectMapper} for initial instantiation\n      */\n-    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config)\n-    {\n+    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) {\n         this(mapper, config, null, null, null, null);\n     }\n \n         _unwrapRoot = config.useRootWrapping();\n         _dataFormatReaders = base._dataFormatReaders;\n     }\n-\n+    \n     protected ObjectReader(ObjectReader base, JsonFactory f)\n     {\n         // may need to override ordering, based on data format capabilities\n \n     /*\n     /**********************************************************\n-    /* Life-cycle, fluent factory methods\n+    /* Methods sub-classes MUST override, used for constructing\n+    /* reader instances, (re)configuring parser instances\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _new(ObjectReader base, JsonFactory f) {\n+        return new ObjectReader(base, f);\n+    }\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _new(ObjectReader base, DeserializationConfig config) {\n+        return new ObjectReader(base, config);\n+    }\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _new(ObjectReader base, DeserializationConfig config,\n+            JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n+            FormatSchema schema, InjectableValues injectableValues,\n+            DataFormatReaders dataFormatReaders) {\n+        return new ObjectReader(base, config, valueType, rootDeser,  valueToUpdate,\n+                 schema,  injectableValues, dataFormatReaders);\n+    }\n+\n+    /**\n+     * Factory method used to create {@link MappingIterator} instances;\n+     * either default, or custom subtype.\n+     * \n+     * @since 2.5\n+     */\n+    protected <T> MappingIterator<T> _newIterator(JavaType valueType,\n+            JsonParser parser, DeserializationContext ctxt,\n+            JsonDeserializer<?> deser, boolean parserManaged, Object valueToUpdate)\n+    {\n+            return new MappingIterator<T>(valueType, parser, ctxt,\n+                    deser, parserManaged, valueToUpdate);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Methods sub-classes may choose to override, if customized\n+    /* initialization is needed.\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * NOTE: changed from static to non-static in 2.5; unfortunate but\n+     * necessary change to support overridability\n+     */\n+    protected JsonToken _initForReading(JsonParser p) throws IOException\n+    {\n+        if (_schema != null) {\n+            p.setSchema(_schema);\n+        }\n+        _config.initialize(p); // since 2.5\n+\n+        /* First: must point to a token; if not pointing to one, advance.\n+         * This occurs before first read from JsonParser, as well as\n+         * after clearing of current token.\n+         */\n+        JsonToken t = p.getCurrentToken();\n+        if (t == null) { // and then we must get something...\n+            t = p.nextToken();\n+            if (t == null) {\n+                // Throw mapping exception, since it's failure to map, not an actual parsing problem\n+                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    /**\n+     * Alternative to {@link #_initForReading(JsonParser)} used in cases where reading\n+     * of multiple values means that we may or may not want to advance the stream,\n+     * but need to do other initialization.\n+     *<p>\n+     * Base implementation only sets configured {@link FormatSchema}, if any, on parser.\n+     * \n+     * @since 2.5\n+     */\n+    protected void _initForMultiRead(JsonParser p) throws IOException {\n+        if (_schema != null) {\n+            p.setSchema(_schema);\n+        }\n+        _config.initialize(p); // since 2.5\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factory methods for DeserializationFeatures\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified feature enabled.\n+     */\n+    public ObjectReader with(DeserializationFeature feature) {\n+        return _with(_config.with(feature));\n+    }\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features enabled.\n+     */\n+    public ObjectReader with(DeserializationFeature first,\n+            DeserializationFeature... other)\n+    {\n+        return _with(_config.with(first, other));\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features enabled.\n+     */\n+    public ObjectReader withFeatures(DeserializationFeature... features) {\n+        return _with(_config.withFeatures(features));\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified feature disabled.\n+     */\n+    public ObjectReader without(DeserializationFeature feature) {\n+        return _with(_config.without(feature)); \n+    }\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features disabled.\n+     */\n+    public ObjectReader without(DeserializationFeature first,\n+            DeserializationFeature... other) {\n+        return _with(_config.without(first, other));\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features disabled.\n+     */\n+    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n+        return _with(_config.withoutFeatures(features));\n+    }    \n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factory methods for JsonParser.Features\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified feature enabled.\n+     */\n+    public ObjectReader with(JsonParser.Feature feature) {\n+        return _with(_config.with(feature));\n+    }\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features enabled.\n+     */\n+    public ObjectReader withFeatures(JsonParser.Feature... features) {\n+        return _with(_config.withFeatures(features));\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified feature disabled.\n+     */\n+    public ObjectReader without(JsonParser.Feature feature) {\n+        return _with(_config.without(feature)); \n+    }\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features disabled.\n+     */\n+    public ObjectReader withoutFeatures(JsonParser.Feature... features) {\n+        return _with(_config.withoutFeatures(features));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factory methods, other\n     /**********************************************************\n      */\n \n     public ObjectReader with(DeserializationConfig config) {\n         return _with(config);\n     }    \n-    \n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * with specified feature enabled.\n-     */\n-    public ObjectReader with(DeserializationFeature feature) {\n-        return _with(_config.with(feature));\n-    }    \n-\n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * with specified features enabled.\n-     */\n-    public ObjectReader with(DeserializationFeature first,\n-            DeserializationFeature... other)\n-    {\n-        return _with(_config.with(first, other));\n-    }    \n-\n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * with specified features enabled.\n-     */\n-    public ObjectReader withFeatures(DeserializationFeature... features) {\n-        return _with(_config.withFeatures(features));\n-    }    \n-    \n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * with specified feature disabled.\n-     */\n-    public ObjectReader without(DeserializationFeature feature) {\n-        return _with(_config.without(feature)); \n-    }    \n-\n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * with specified features disabled.\n-     */\n-    public ObjectReader without(DeserializationFeature first,\n-            DeserializationFeature... other)\n-    {\n-        return _with(_config.without(first, other));\n-    }    \n-\n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * with specified features disabled.\n-     */\n-    public ObjectReader withoutFeatures(DeserializationFeature... features) {\n-        return _with(_config.withoutFeatures(features));\n-    }    \n-    \n+\n     /**\n      * Method for constructing a new instance with configuration that uses\n      * passed {@link InjectableValues} to provide injectable values.\n         if (_injectableValues == injectableValues) {\n             return this;\n         }\n-        return new ObjectReader(this, _config,\n+        return _new(this, _config,\n                 _valueType, _rootDeserializer, _valueToUpdate,\n                 _schema, injectableValues, _dataFormatReaders);\n     }\n         if (f == _parserFactory) {\n             return this;\n         }\n-        ObjectReader r = new ObjectReader(this, f);\n+        ObjectReader r = _new(this, f);\n         // Also, try re-linking, if possible...\n         if (f.getCodec() == null) {\n             f.setCodec(r);\n             return this;\n         }\n         _verifySchemaType(schema);\n-        return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n+        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                 schema, _injectableValues, _dataFormatReaders);\n     }\n \n      *<p>\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n-     */\n-    public ObjectReader withType(JavaType valueType)\n+     * \n+     * @since 2.5\n+     */\n+    public ObjectReader forType(JavaType valueType)\n     {\n         if (valueType != null && valueType.equals(_valueType)) {\n             return this;\n         if (det != null) {\n             det = det.withType(valueType);\n         }\n-        return new ObjectReader(this, _config, valueType, rootDeser,\n+        return _new(this, _config, valueType, rootDeser,\n                 _valueToUpdate, _schema, _injectableValues, det);\n     }    \n \n      *<p>\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n-     */\n-    public ObjectReader withType(Class<?> valueType) {\n-        return withType(_config.constructType(valueType));\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectReader forType(Class<?> valueType) {\n+        return forType(_config.constructType(valueType));\n     }    \n \n     /**\n      *<p>\n      * Note that the method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n-     */\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectReader forType(TypeReference<?> valueTypeRef) {\n+        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n+    }    \n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(JavaType)} instead\n+     */\n+    @Deprecated\n+    public ObjectReader withType(JavaType valueType) {\n+        return forType(valueType);\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n+     */\n+    @Deprecated\n+    public ObjectReader withType(Class<?> valueType) {\n+        return forType(_config.constructType(valueType));\n+    }    \n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n+     */\n+    @Deprecated\n     public ObjectReader withType(java.lang.reflect.Type valueType) {\n-        return withType(_config.getTypeFactory().constructType(valueType));\n-    }    \n-\n-    /**\n-     * Method for constructing a new reader instance that is configured\n-     * to data bind into specified type.\n-     *<p>\n-     * Note that the method does NOT change state of this reader, but\n-     * rather construct and returns a newly configured instance.\n-     */\n+        return forType(_config.getTypeFactory().constructType(valueType));\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(TypeReference)} instead\n+     */\n+    @Deprecated\n     public ObjectReader withType(TypeReference<?> valueTypeRef) {\n-        return withType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n+        return forType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n     }    \n \n     /**\n         } else {\n             t = _valueType;\n         }\n-        return new ObjectReader(this, _config, t, _rootDeserializer, value,\n+        return _new(this, _config, t, _rootDeserializer, value,\n                 _schema, _injectableValues, _dataFormatReaders);\n     }\n \n      * \n      * @since 2.1\n      */\n-    public ObjectReader withFormatDetection(ObjectReader... readers)\n-    {\n+    public ObjectReader withFormatDetection(ObjectReader... readers) {\n         return withFormatDetection(new DataFormatReaders(readers));\n     }\n \n      * \n      * @since 2.1\n      */\n-    public ObjectReader withFormatDetection(DataFormatReaders readers)\n-    {\n-        return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n+    public ObjectReader withFormatDetection(DataFormatReaders readers) {\n+        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                 _schema, _injectableValues, readers);\n     }\n \n      * @since 2.3\n      */\n     public ObjectReader with(ContextAttributes attrs) {\n-        DeserializationConfig newConfig = _config.with(attrs);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.with(attrs));\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectReader withAttributes(Map<Object,Object> attrs) {\n-        DeserializationConfig newConfig = _config.withAttributes(attrs);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.withAttributes(attrs));\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectReader withAttribute(Object key, Object value) {\n-        DeserializationConfig newConfig = _config.withAttribute(key, value);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with( _config.withAttribute(key, value));\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectReader withoutAttribute(Object key) {\n-        DeserializationConfig newConfig = _config.withoutAttribute(key);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.withoutAttribute(key));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable factory methods may override\n+    /**********************************************************\n+     */\n+    \n+    protected ObjectReader _with(DeserializationConfig newConfig) {\n+        if (newConfig == _config) {\n+            return this;\n+        }\n+        ObjectReader r = _new(this, newConfig);\n+        if (_dataFormatReaders != null) {\n+            r  = r.withFormatDetection(_dataFormatReaders.with(newConfig));\n+        }\n+        return r;\n     }\n     \n     /*\n     public JsonParser treeAsTokens(TreeNode n) {\n         return new TreeTraversingParser((JsonNode) n, this);\n     }\n-     /**\n-      * Convenience method that binds content read using given parser, using\n-      * configuration of this reader, except that content is bound as\n-      * JSON tree instead of configured root value type.\n-      *<p>\n-      * Note: if an object was specified with {@link #withValueToUpdate}, it\n-      * will be ignored.\n-      *<p>\n-      * NOTE: this method never tries to auto-detect format, since actual\n-      * (data-format specific) parser is given.\n-      */\n-     @SuppressWarnings(\"unchecked\")\n-     @Override\n-     public <T extends TreeNode> T readTree(JsonParser jp)\n-         throws IOException, JsonProcessingException\n-     {\n-         return (T) _bindAsTree(jp);\n-     }\n+\n+    /**\n+     * Convenience method that binds content read using given parser, using\n+     * configuration of this reader, except that content is bound as\n+     * JSON tree instead of configured root value type.\n+     *<p>\n+     * Note: if an object was specified with {@link #withValueToUpdate}, it\n+     * will be ignored.\n+     *<p>\n+     * NOTE: this method never tries to auto-detect format, since actual\n+     * (data-format specific) parser is given.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends TreeNode> T readTree(JsonParser jp)\n+            throws IOException, JsonProcessingException\n+    {\n+        return (T) _bindAsTree(jp);\n+    }\n      \n     @Override\n     public void writeTree(JsonGenerator jgen, TreeNode rootNode) {\n     {\n         DeserializationContext ctxt = createDeserializationContext(jp, _config);\n         // false -> do not close as caller gave parser instance\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n+        return _newIterator(_valueType, jp, ctxt,\n                 _findRootDeserializer(ctxt, _valueType),\n                 false, _valueToUpdate);\n     }\n         if (_dataFormatReaders != null) {\n             _reportUndetectableSource(src);\n         }\n-        JsonParser jp = _parserFactory.createParser(src);\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        jp.nextToken();\n-        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n+        JsonParser p = _parserFactory.createParser(src);\n+        _initForMultiRead(p);\n+        p.nextToken();\n+        DeserializationContext ctxt = createDeserializationContext(p, _config);\n+        return _newIterator(_valueType, p, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n     \n         if (_dataFormatReaders != null) {\n             _reportUndetectableSource(json);\n         }\n-        JsonParser jp = _parserFactory.createParser(json);\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        jp.nextToken();\n-        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n+        JsonParser p = _parserFactory.createParser(json);\n+        _initForMultiRead(p);\n+        p.nextToken();\n+        DeserializationContext ctxt = createDeserializationContext(p, _config);\n+        return _newIterator(_valueType, p, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n \n      */\n \n     @Override\n-    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n-        throws JsonProcessingException\n+    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException\n     {\n         try {\n             return readValue(treeAsTokens(n), valueType);\n     }    \n     \n     @Override\n-    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException\n-    {\n+    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException {\n         throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n     }\n \n     /**\n      * Actual implementation of value reading+binding operation.\n      */\n-    protected Object _bind(JsonParser jp, Object valueToUpdate)\n-        throws IOException, JsonParseException, JsonMappingException\n+    protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException\n     {\n         /* First: may need to read the next token, to initialize state (either\n          * before first read from parser, or after previous token has been cleared)\n         return result;\n     }\n     \n-    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n+    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException\n+    {\n         try {\n             Object result;\n             JsonToken t = _initForReading(jp);\n         }\n     }\n \n-    protected JsonNode _bindAsTree(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n+    protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException {\n+        try {\n+            return _bindAsTree(jp);\n+        } finally {\n+            try {\n+                jp.close();\n+            } catch (IOException ioe) { }\n+        }\n+    }\n+    \n+    protected JsonNode _bindAsTree(JsonParser jp) throws IOException\n     {\n         JsonNode result;\n         JsonToken t = _initForReading(jp);\n         return result;\n     }\n     \n-    protected JsonNode _bindAndCloseAsTree(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        try {\n-            return _bindAsTree(jp);\n-        } finally {\n-            try {\n-                jp.close();\n-            } catch (IOException ioe) { }\n-        }\n-    }\n-    \n     /**\n      * @since 2.1\n      */\n-    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p,\n-            Object valueToUpdate)\n-        throws IOException, JsonProcessingException\n-    {\n-        if (_schema != null) {\n-            p.setSchema(_schema);\n-        }\n+    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p, Object valueToUpdate) throws IOException\n+    {\n+        _initForMultiRead(p);\n         p.nextToken();\n         DeserializationContext ctxt = createDeserializationContext(p, _config);\n-        return new MappingIterator<T>(_valueType, p, ctxt, \n-                _findRootDeserializer(ctxt, _valueType),\n-                true, _valueToUpdate);\n-    }\n-    \n-    protected static JsonToken _initForReading(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        /* First: must point to a token; if not pointing to one, advance.\n-         * This occurs before first read from JsonParser, as well as\n-         * after clearing of current token.\n-         */\n-        JsonToken t = jp.getCurrentToken();\n-        if (t == null) { // and then we must get something...\n-            t = jp.nextToken();\n-            if (t == null) {\n-                /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n-                 *   not an actual parsing problem\n-                 */\n-                throw JsonMappingException.from(jp, \"No content to map due to end-of-input\");\n-            }\n-        }\n-        return t;\n-    }\n-\n+        return _newIterator(_valueType, p, ctxt, \n+                _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n+    }\n+\n+    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n+            JavaType rootType, JsonDeserializer<Object> deser) throws IOException\n+    {\n+        String expName = _config.getRootName();\n+        if (expName == null) {\n+            PropertyName pname = _rootNames.findRootName(rootType, _config);\n+            expName = pname.getSimpleName();\n+        }\n+        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n+            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n+            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        String actualName = jp.getCurrentName();\n+        if (!expName.equals(actualName)) {\n+            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n+                    +expName+\"') for type \"+rootType);\n+        }\n+        // ok, then move to value itself....\n+        jp.nextToken();\n+        Object result;\n+        if (_valueToUpdate == null) {\n+            result = deser.deserialize(jp, ctxt);\n+        } else {\n+            deser.deserialize(jp, ctxt, _valueToUpdate);\n+            result = _valueToUpdate;                    \n+        }\n+        // and last, verify that we now get matching END_OBJECT\n+        if (jp.nextToken() != JsonToken.END_OBJECT) {\n+            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        return result;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, locating deserializers etc\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Method called to locate deserializer for the passed root-level value.\n      */\n      * by configuration. Method also is NOT to throw an exception if\n      * access fails.\n      */\n-    protected JsonDeserializer<Object> _prefetchRootDeserializer(\n-            DeserializationConfig config, JavaType valueType)\n+    protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType)\n     {\n         if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n             return null;\n         }\n         return deser;\n     }\n-    \n-    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n-            JavaType rootType, JsonDeserializer<Object> deser)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        String expName = _config.getRootName();\n-        if (expName == null) {\n-            PropertyName pname = _rootNames.findRootName(rootType, _config);\n-            expName = pname.getSimpleName();\n-        }\n-        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n-            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        String actualName = jp.getCurrentName();\n-        if (!expName.equals(actualName)) {\n-            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n-                    +expName+\"') for type \"+rootType);\n-        }\n-        // ok, then move to value itself....\n-        jp.nextToken();\n-        Object result;\n-        if (_valueToUpdate == null) {\n-            result = deser.deserialize(jp, ctxt);\n-        } else {\n-            deser.deserialize(jp, ctxt, _valueToUpdate);\n-            result = _valueToUpdate;                    \n-        }\n-        // and last, verify that we now get matching END_OBJECT\n-        if (jp.nextToken() != JsonToken.END_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        return result;\n-    }\n \n     /*\n     /**********************************************************\n         // 04-Jan-2010, tatu: we do actually need the provider too... (for polymorphic deser)\n         return _context.createInstance(cfg, jp, _injectableValues);\n     }\n-    \n-    protected ObjectReader _with(DeserializationConfig newConfig) {\n-        if (newConfig == _config) {\n-            return this;\n-        }\n-        if (_dataFormatReaders != null) {\n-            return new ObjectReader(this, newConfig)\n-                .withFormatDetection(_dataFormatReaders.with(newConfig));\n-        }\n-        return new ObjectReader(this, newConfig);\n-    }\n \n     protected void _reportUndetectableSource(Object src) throws JsonProcessingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n package com.fasterxml.jackson.databind;\n \n import java.io.*;\n-import java.text.DateFormat;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.TimeZone;\n+import java.text.*;\n+import java.util.*;\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.CharacterEscapes;\n import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n import com.fasterxml.jackson.core.type.TypeReference;\n-import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n-import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n-import com.fasterxml.jackson.core.util.Instantiatable;\n-import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n+import com.fasterxml.jackson.core.util.*;\n+\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n     implements Versioned,\n         java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = -7040667122552707164L;\n+    private static final long serialVersionUID = 1; // since 2.5\n \n     /**\n      * We need to keep track of explicit disabling of pretty printing;\n \n     /*\n     /**********************************************************\n-    /* Derived settings\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * @since 2.3\n-     */\n-    protected final boolean  _cfgBigDecimalAsPlain;\n-\n-    /*\n-    /**********************************************************\n     /* Life-cycle, constructors\n     /**********************************************************\n      */\n             JavaType rootType, PrettyPrinter pp)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n-\n         _serializerProvider = mapper._serializerProvider;\n         _serializerFactory = mapper._serializerFactory;\n         _generatorFactory = mapper._jsonFactory;\n     protected ObjectWriter(ObjectMapper mapper, SerializationConfig config)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n-\n         _serializerProvider = mapper._serializerProvider;\n         _serializerFactory = mapper._serializerFactory;\n         _generatorFactory = mapper._jsonFactory;\n             FormatSchema s)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n \n         _serializerProvider = mapper._serializerProvider;\n         _serializerFactory = mapper._serializerFactory;\n             PrettyPrinter pp, FormatSchema s, CharacterEscapes escapes)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n \n         _serializerProvider = base._serializerProvider;\n         _serializerFactory = base._serializerFactory;\n     protected ObjectWriter(ObjectWriter base, SerializationConfig config)\n     {\n         _config = config;\n-        _cfgBigDecimalAsPlain = _config.isEnabled(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n \n         _serializerProvider = base._serializerProvider;\n         _serializerFactory = base._serializerFactory;\n         // may need to override ordering, based on data format capabilities\n         _config = base._config\n             .with(MapperFeature.SORT_PROPERTIES_ALPHABETICALLY, f.requiresPropertyOrdering());\n-        _cfgBigDecimalAsPlain = base._cfgBigDecimalAsPlain;\n \n         _serializerProvider = base._serializerProvider;\n         _serializerFactory = base._serializerFactory;\n     \n     /*\n     /**********************************************************\n-    /* Life-cycle, fluent factories\n+    /* Life-cycle, fluent factories for SerializationFeature\n     /**********************************************************\n      */\n \n     public ObjectWriter withoutFeatures(SerializationFeature... features) {\n         SerializationConfig newConfig = _config.withoutFeatures(features);\n         return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n-    }    \n-    \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factories for JsonGenerator.Feature\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter with(JsonGenerator.Feature feature)  {\n+        SerializationConfig newConfig = _config.with(feature);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter withFeatures(JsonGenerator.Feature... features) {\n+        SerializationConfig newConfig = _config.withFeatures(features);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter without(JsonGenerator.Feature feature) {\n+        SerializationConfig newConfig = _config.without(feature);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public ObjectWriter withoutFeatures(JsonGenerator.Feature... features) {\n+        SerializationConfig newConfig = _config.withoutFeatures(features);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factories, other\n+    /**********************************************************\n+     */\n+\n     /**\n      * Fluent factory method that will construct a new writer instance that will\n      * use specified date format for serializing dates; or if null passed, one\n      * Note that method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n      */\n-    \n-    public ObjectWriter withSchema(FormatSchema schema) {\n+    public ObjectWriter with(FormatSchema schema) {\n         if (_schema == schema) {\n             return this;\n         }\n         _verifySchemaType(schema);\n         return new ObjectWriter(this, _config, _rootType, _rootSerializer,\n                 _prettyPrinter, schema, _characterEscapes);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5 use {@link #with(FormatSchema)} instead\n+     */\n+    @Deprecated\n+    public ObjectWriter withSchema(FormatSchema schema) {\n+        return with(schema);\n     }\n \n     /**\n      *<p>\n      * Note that method does NOT change state of this reader, but\n      * rather construct and returns a newly configured instance.\n-     */\n-    public ObjectWriter withType(JavaType rootType)\n+     * \n+     * @since 2.5\n+     */\n+    public ObjectWriter forType(JavaType rootType)\n     {\n         JsonSerializer<Object> rootSer;\n         if (rootType == null || rootType.hasRawClass(Object.class)) {\n      * Method that will construct a new instance that uses specific type\n      * as the root type for serialization, instead of runtime dynamic\n      * type of the root object itself.\n-     */\n+     * \n+     * @since 2.5\n+     */\n+    public ObjectWriter forType(Class<?> rootType) {\n+        if (rootType == Object.class) {\n+            return forType((JavaType) null);\n+        }\n+        return forType(_config.constructType(rootType));\n+    }\n+\n+    public ObjectWriter forType(TypeReference<?> rootType) {\n+        return forType(_config.getTypeFactory().constructType(rootType.getType()));\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(JavaType)} instead\n+     */\n+    @Deprecated // since 2.5\n+    public ObjectWriter withType(JavaType rootType) {\n+        return forType(rootType);\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(Class)} instead\n+     */\n+    @Deprecated // since 2.5\n     public ObjectWriter withType(Class<?> rootType) {\n-        if (rootType == Object.class) {\n-            return withType((JavaType) null);\n-        }\n-        return withType(_config.constructType(rootType));\n-    }\n-\n+        return forType(rootType);\n+    }\n+\n+    /**\n+     * @deprecated since 2.5 Use {@link #forType(TypeReference)} instead\n+     */\n+    @Deprecated // since 2.5\n     public ObjectWriter withType(TypeReference<?> rootType) {\n-        return withType(_config.getTypeFactory().constructType(rootType.getType()));\n+        return forType(rootType);\n     }\n \n     /**\n      * method is to be called right after serialization has been called\n      */\n     private final void _writeCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+        throws IOException\n     {\n         Closeable toClose = (Closeable) value;\n         try {\n      * method is to be called right after serialization has been called\n      */\n     private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg)\n-        throws IOException, JsonGenerationException, JsonMappingException\n+        throws IOException\n     {\n         Closeable toClose = (Closeable) value;\n         try {\n      * \n      * @since 2.1\n      */\n-    private void _configureJsonGenerator(JsonGenerator jgen)\n+    protected void _configureJsonGenerator(JsonGenerator gen)\n     {\n         if (_prettyPrinter != null) {\n             PrettyPrinter pp = _prettyPrinter;\n             if (pp == NULL_PRETTY_PRINTER) {\n-                jgen.setPrettyPrinter(null);\n+                gen.setPrettyPrinter(null);\n             } else {\n                 /* [JACKSON-851]: Better take care of stateful PrettyPrinters...\n                  *   like the DefaultPrettyPrinter.\n                 if (pp instanceof Instantiatable<?>) {\n                     pp = (PrettyPrinter) ((Instantiatable<?>) pp).createInstance();\n                 }\n-                jgen.setPrettyPrinter(pp);\n+                gen.setPrettyPrinter(pp);\n             }\n         } else if (_config.isEnabled(SerializationFeature.INDENT_OUTPUT)) {\n-            jgen.useDefaultPrettyPrinter();\n+            gen.useDefaultPrettyPrinter();\n         }\n         if (_characterEscapes != null) {\n-            jgen.setCharacterEscapes(_characterEscapes);\n+            gen.setCharacterEscapes(_characterEscapes);\n         }\n         // [JACKSON-520]: add support for pass-through schema:\n         if (_schema != null) {\n-            jgen.setSchema(_schema);\n-        }\n-        if (_cfgBigDecimalAsPlain) { // should only set if explicitly set; this should work for now:\n-            jgen.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n-        }\n+            gen.setSchema(_schema);\n+        }\n+        _config.initialize(gen); // since 2.5\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n public class PropertyName\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 7930806520033045126L;\n+    private static final long serialVersionUID = 1L; // 2.5\n \n     private final static String _USE_DEFAULT = \"\";\n     private final static String _NO_NAME = \"\";\n     public SerializableString simpleAsEncoded(MapperConfig<?> config) {\n         SerializableString sstr = _encodedSimple;\n         if (sstr == null) {\n-            sstr = config.compileString(_simpleName);\n+            if (config == null) {\n+                sstr = new SerializedString(_simpleName);\n+            } else {\n+                sstr = config.compileString(_simpleName);\n+            }\n             _encodedSimple = sstr;\n         }\n         return sstr;\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n-import com.fasterxml.jackson.core.Base64Variant;\n+import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n import com.fasterxml.jackson.databind.cfg.ContextAttributes;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n     extends MapperConfigBase<SerializationFeature, SerializationConfig>\n     implements java.io.Serializable // since 2.1\n {\n-    // Valid as of 2.4\n-    private static final long serialVersionUID = -1278867172535832879L;\n-\n-    /**\n-     * Set of features enabled; actual type (kind of features)\n-     * depends on sub-classes.\n+    // since 2.5\n+    private static final long serialVersionUID = 1;\n+\n+    /**\n+     * Set of {@link SerializationFeature}s enabled.\n      */\n     protected final int _serFeatures;\n     \n      * Non-null if explicitly defined; null by default.\n      */\n     protected final FilterProvider _filterProvider;\n+\n+    /**\n+     * States of {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s to enable/disable.\n+     */\n+    protected final int _generatorFeatures;\n+\n+    /**\n+     * Bitflag of {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s to enable/disable\n+     */\n+    protected final int _generatorFeaturesToChange;\n     \n     /*\n     /**********************************************************\n         super(base, str, mixins);\n         _serFeatures = collectFeatureDefaults(SerializationFeature.class);\n         _filterProvider = null;\n+        _generatorFeatures = 0;\n+        _generatorFeaturesToChange = 0;\n     }\n     \n     private SerializationConfig(SerializationConfig src, SubtypeResolver str)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n-    }\n-\n-    private SerializationConfig(SerializationConfig src, int mapperFeatures, int serFeatures)\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n+    }\n+\n+    private SerializationConfig(SerializationConfig src,\n+            int mapperFeatures, int serFeatures,\n+            int generatorFeatures, int generatorFeatureMask)\n     {\n         super(src, mapperFeatures);\n         _serFeatures = serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = generatorFeatures;\n+        _generatorFeaturesToChange = generatorFeatureMask;\n     }\n     \n     private SerializationConfig(SerializationConfig src, BaseSettings base)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     private SerializationConfig(SerializationConfig src, FilterProvider filters)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = filters;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     private SerializationConfig(SerializationConfig src, Class<?> view)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     private SerializationConfig(SerializationConfig src, JsonInclude.Include incl)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = incl;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     private SerializationConfig(SerializationConfig src, String rootName)\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     /**\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n \n     /**\n         _serFeatures = src._serFeatures;\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n+        _generatorFeatures = src._generatorFeatures;\n+        _generatorFeaturesToChange = src._generatorFeaturesToChange;\n     }\n     \n     /*\n             newMapperFlags |= f.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this\n-                : new SerializationConfig(this, newMapperFlags, _serFeatures);\n+                : new SerializationConfig(this, newMapperFlags, _serFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n     \n     /**\n              newMapperFlags &= ~f.getMask();\n         }\n         return (newMapperFlags == _mapperFeatures) ? this\n-                : new SerializationConfig(this, newMapperFlags, _serFeatures);\n+                : new SerializationConfig(this, newMapperFlags, _serFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     @Override\n         } else {\n             newMapperFlags = _mapperFeatures & ~feature.getMask();\n         }\n-        return (newMapperFlags == _mapperFeatures) ? this :\n-            new SerializationConfig(this, newMapperFlags, _serFeatures);\n+        return (newMapperFlags == _mapperFeatures) ? this\n+            : new SerializationConfig(this, newMapperFlags, _serFeatures,\n+                    _generatorFeatures, _generatorFeaturesToChange);\n     }\n     \n     @Override\n     public SerializationConfig with(ClassIntrospector ci) {\n         return _withBase(_base.withClassIntrospector(ci));\n     }\n-    \n+\n     /**\n      * In addition to constructing instance with specified date format,\n      * will enable or disable <code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code>\n         }\n         return cfg;\n     }\n-    \n+\n     @Override\n     public SerializationConfig with(HandlerInstantiator hi) {\n         return _withBase(_base.withHandlerInstantiator(hi));\n     }\n-    \n+\n     @Override\n     public SerializationConfig with(PropertyNamingStrategy pns) {\n         return _withBase(_base.withPropertyNamingStrategy(pns));\n     public SerializationConfig with(TypeResolverBuilder<?> trb) {\n         return _withBase(_base.withTypeResolverBuilder(trb));\n     }\n-    \n+\n     @Override\n     public SerializationConfig withView(Class<?> view) {\n         return (_view == view) ? this : new SerializationConfig(this, view);\n     public SerializationConfig with(ContextAttributes attrs) {\n         return (attrs == _attributes) ? this : new SerializationConfig(this, attrs);\n     }\n-    \n+\n     private final SerializationConfig _withBase(BaseSettings newBase) {\n         return (_base == newBase) ? this : new SerializationConfig(this, newBase);\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Life-cycle, SerializationConfig specific factory methods\n-    /**********************************************************\n-     */\n-        \n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods for SerializationFeature\n+    /**********************************************************\n+     */\n+\n     /**\n      * Fluent factory method that will construct and return a new configuration\n      * object instance with specified feature enabled.\n     {\n         int newSerFeatures = _serFeatures | feature.getMask();\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     /**\n             newSerFeatures |= f.getMask();\n         }\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n-    }\n-    \n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n+    }\n+\n     /**\n      * Fluent factory method that will construct and return a new configuration\n      * object instance with specified features enabled.\n             newSerFeatures |= f.getMask();\n         }\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     /**\n     {\n         int newSerFeatures = _serFeatures & ~feature.getMask();\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     /**\n             newSerFeatures &= ~f.getMask();\n         }\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n     }\n \n     /**\n             newSerFeatures &= ~f.getMask();\n         }\n         return (newSerFeatures == _serFeatures) ? this\n-                : new SerializationConfig(this, _mapperFeatures, newSerFeatures);\n-    }\n+                : new SerializationConfig(this, _mapperFeatures, newSerFeatures,\n+                        _generatorFeatures, _generatorFeaturesToChange);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods for JsonGenerator.Feature\n+    /**********************************************************\n+     */\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature enabled.\n+     *\n+     * @since 2.5\n+     */\n+    public SerializationConfig with(JsonGenerator.Feature feature)\n+    {\n+        int newSet = _generatorFeatures | feature.getMask();\n+        int newMask = _generatorFeaturesToChange | feature.getMask();\n+        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n+            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     *\n+     * @since 2.5\n+     */\n+    public SerializationConfig withFeatures(JsonGenerator.Feature... features)\n+    {\n+        int newSet = _generatorFeatures;\n+        int newMask = _generatorFeaturesToChange;\n+        for (JsonGenerator.Feature f : features) {\n+            int mask = f.getMask();\n+            newSet |= mask;\n+            newMask |= mask;\n+        }\n+        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n+            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified feature disabled.\n+     *\n+     * @since 2.5\n+     */\n+    public SerializationConfig without(JsonGenerator.Feature feature)\n+    {\n+        int newSet = _generatorFeatures & ~feature.getMask();\n+        int newMask = _generatorFeaturesToChange | feature.getMask();\n+        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n+            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     *\n+     * @since 2.5\n+     */\n+    public SerializationConfig withoutFeatures(JsonGenerator.Feature... features)\n+    {\n+        int newSet = _generatorFeatures;\n+        int newMask = _generatorFeaturesToChange;\n+        for (JsonGenerator.Feature f : features) {\n+            int mask = f.getMask();\n+            newSet &= ~mask;\n+            newMask |= mask;\n+        }\n+        return ((_generatorFeatures == newSet) && (_generatorFeaturesToChange == newMask)) ? this :\n+            new SerializationConfig(this,  _mapperFeatures, _serFeatures,\n+                    newSet, newMask);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods, other\n+    /**********************************************************\n+     */\n     \n     public SerializationConfig withFilters(FilterProvider filterProvider) {\n         return (filterProvider == _filterProvider) ? this : new SerializationConfig(this, filterProvider);\n     public SerializationConfig withSerializationInclusion(JsonInclude.Include incl) {\n         return (_serializationInclusion == incl) ? this:  new SerializationConfig(this, incl);\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonParser initialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called by {@link ObjectMapper} and {@link ObjectWriter}\n+     * to modify those {@link com.fasterxml.jackson.core.JsonGenerator.Feature} settings\n+     * that have been configured via this config instance.\n+     * \n+     * @since 2.5\n+     */\n+    public void initialize(JsonGenerator g)\n+    {\n+        if (SerializationFeature.INDENT_OUTPUT.enabledIn(_serFeatures)) {\n+            g.useDefaultPrettyPrinter();\n+        }\n+        @SuppressWarnings(\"deprecation\")\n+        boolean useBigDec = SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN.enabledIn(_serFeatures);\n+        if ((_generatorFeaturesToChange != 0) || useBigDec) {\n+            int orig = g.getFeatureMask();\n+            int newFlags = (orig & ~_generatorFeaturesToChange) | _generatorFeatures;\n+            // although deprecated, needs to be supported for now\n+            if (useBigDec) {\n+                newFlags |= JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN.getMask();\n+            }\n+            if (orig != newFlags) {\n+                g.setFeatureMask(newFlags);\n+            }\n+        }\n+    }\n     \n     /*\n     /**********************************************************\n     /* MapperConfig implementation/overrides\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public boolean useRootWrapping()\n     {\n         }\n         return isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n     }\n-    \n+\n     @Override\n     public AnnotationIntrospector getAnnotationIntrospector()\n     {\n-        /* 29-Jul-2009, tatu: it's now possible to disable use of\n-         *   annotations; can be done using \"no-op\" introspector\n-         */\n         if (isEnabled(MapperFeature.USE_ANNOTATIONS)) {\n             return super.getAnnotationIntrospector();\n         }\n     public BeanDescription introspectDirectClassAnnotations(JavaType type) {\n         return getClassIntrospector().forDirectClassAnnotations(this, type, this);\n     }\n-    \n+\n     @Override\n     public VisibilityChecker<?> getDefaultVisibilityChecker()\n     {\n         }\n         return vchecker;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Configuration: other\n         return (_serFeatures & f.getMask()) != 0;\n     }\n \n+    /**\n+     * Accessor method that first checks if we have any overrides\n+     * for feature, and only if not, checks state of passed-in\n+     * factory.\n+     * \n+     * @since 2.5\n+     */\n+    public final boolean isEnabled(JsonGenerator.Feature f, JsonFactory factory) {\n+        int mask = f.getMask();\n+        if ((_generatorFeaturesToChange & mask) != 0) {\n+            return (_generatorFeatures & f.getMask()) != 0;\n+        }\n+        return factory.isEnabled(f);\n+    }\n+    \n     /**\n      * \"Bulk\" access method for checking that all features specified by\n      * mask are enabled.\n     public final int getSerializationFeatures() {\n         return _serFeatures;\n     }\n-    \n+\n     public JsonInclude.Include getSerializationInclusion()\n     {\n         if (_serializationInclusion != null) {\n         }\n         return JsonInclude.Include.ALWAYS;\n     }\n-    \n+\n     /**\n      * Method for getting provider used for locating filters given\n      * id (which is usually provided with filter annotations).\n     public FilterProvider getFilterProvider() {\n         return _filterProvider;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Introspection methods\n     /* Debug support\n     /**********************************************************\n      */\n-    \n-    @Override public String toString()\n-    {\n+\n+    @Override\n+    public String toString() {\n         return \"[SerializationConfig: flags=0x\"+Integer.toHexString(_serFeatures)+\"]\";\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n     /* Generic output features\n     /******************************************************\n      */\n-    \n+\n     /**\n      * Feature that can be enabled to make root value (usually JSON\n      * Object but can be any type) wrapped within a single property\n      * method to use any <code>PrettyPrinter</code> instance.\n      * This feature will only allow using the default implementation.\n      *<p>\n-     * Feature is enabled by default.\n+     * Feature is disabled by default.\n      */\n     INDENT_OUTPUT(false),\n-    \n+\n     /*\n     /******************************************************\n     /* Error handling features\n     /******************************************************\n      */\n-    \n+\n     /**\n      * Feature that determines what happens when no accessors are\n      * found for a type (and there are no annotations to indicate\n      * @since 2.4\n      */\n     FAIL_ON_SELF_REFERENCES(true),\n-    \n+\n     /**\n      * Feature that determines whether Jackson code should catch\n      * and wrap {@link Exception}s (but never {@link Error}s!)\n     /* Output life cycle features\n     /******************************************************\n      */\n-    \n+\n      /**\n       * Feature that determines whether <code>close</code> method of\n       * serialized <b>root level</b> objects (ones for which <code>ObjectMapper</code>'s\n       * writeValue() (or equivalent) method is called)\n-      * that implement {@link java.io.Closeable} \n+      * that implement {@link java.io.Closeable}\n       * is called after serialization or not. If enabled, <b>close()</b> will\n       * be called after serialization completes (whether succesfully, or\n       * due to an error manifested by an exception being thrown). You can\n      * Feature is enabled by default.\n      */\n     FLUSH_AFTER_WRITE_VALUE(true),\n-     \n+\n     /*\n     /******************************************************\n     /* Datatype-specific serialization configuration\n      * Note: whether {@link java.util.Map} keys are serialized as Strings\n      * or not is controlled using {@link #WRITE_DATE_KEYS_AS_TIMESTAMPS}.\n      *<p>\n-     * Feature is enabled by default.\n+     * Feature is enabled by default, so that date/time are by default\n+     * serialized as timestamps.\n      */\n     WRITE_DATES_AS_TIMESTAMPS(true),\n+\n+    /**\n+     * Feature that determines whether time values that represents time periods\n+     * (durations, periods, ranges) are to be serialized by default using\n+     * a numeric (true) or textual (false) representations. Note that numeric\n+     * representation may mean either simple number, or an array of numbers,\n+     * depending on type.\n+     *<p>\n+     * Note: whether {@link java.util.Map} keys are serialized as Strings\n+     * or not is controlled using {@link #WRITE_DATE_KEYS_AS_TIMESTAMPS}.\n+     *<p>\n+     * Feature is enabled by default, so that period/duration are by default\n+     * serialized as timestamps.\n+     * \n+     * @since 2.5\n+     */\n+    WRITE_DURATIONS_AS_TIMESTAMPS(true),\n \n     /**\n      * Feature that determines whether {@link java.util.Date}s\n      * Feature is disabled by default.\n      */\n     WRITE_ENUMS_USING_INDEX(false),\n-    \n+\n     /**\n      * Feature that determines whether Map entries with null values are\n      * to be serialized (true) or not (false).\n      * Feature is enabled by default.\n      */\n     WRITE_EMPTY_JSON_ARRAYS(true),\n-    \n+\n     /**\n      * Feature added for interoperability, to work with oddities of\n      * so-called \"BadgerFish\" convention.\n      * support it.\n      *<p>\n      * Feature is disabled by default.\n-     */\n+     * \n+     * @deprecated Since 2.5: use {@link com.fasterxml.jackson.core.JsonGenerator.Feature#WRITE_BIGDECIMAL_AS_PLAIN} directly\n+     *    (using {@link ObjectWriter#with(com.fasterxml.jackson.core.JsonGenerator.Feature)}).\n+     */\n+    @Deprecated // since 2.5\n     WRITE_BIGDECIMAL_AS_PLAIN(false),\n-    \n+\n     /**\n      * Feature that controls whether numeric timestamp values are\n      * to be written using nanosecond timestamps (enabled) or not (disabled);\n      * This is the counterpart to {@link SerializationFeature#WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS}.\n      *<p>\n      * Feature is enabled by default, to support most accurate time values possible.\n-     * \n+     *\n      * @since 2.2\n      */\n-    WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS(true),    \n-    \n+    WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS(true),\n+\n     /**\n      * Feature that determines whether {@link java.util.Map} entries are first\n      * sorted by key before serialization or not: if enabled, additional sorting\n      * feature: only consider that if there are actual perceived problems.\n      *<p>\n      * Feature is enabled by default.\n-     * \n+     *\n      * @since 2.1\n      */\n     EAGER_SERIALIZER_FETCH(true),\n      *<p>\n      * Feature is disabled by default; meaning that strict identity is used, not\n      * <code>equals()</code>\n-     * \n+     *\n      * @since 2.3\n      */\n     USE_EQUALITY_FOR_OBJECT_ID(false)\n     ;\n \n     private final boolean _defaultState;\n+    private final int _mask;\n     \n     private SerializationFeature(boolean defaultState) {\n         _defaultState = defaultState;\n+        _mask = (1 << ordinal());\n     }\n \n     @Override\n     public boolean enabledByDefault() { return _defaultState; }\n \n+\n     @Override\n-    public int getMask() { return (1 << ordinal()); }\n+    public int getMask() { return _mask; }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n \n     /**\n      * View used for currently active serialization, if any.\n+     * Only set for non-blueprint instances.\n      */\n     final protected Class<?> _serializationView;\n     \n \n     /**\n      * Factory used for constructing actual serializer instances.\n+     * Only set for non-blueprint instances.\n      */\n     final protected SerializerFactory _serializerFactory;\n \n     \n     /**\n      * Lazily-constructed holder for per-call attributes.\n+     * Only set for non-blueprint instances.\n      * \n      * @since 2.3\n      */\n         _unknownTypeSerializer = src._unknownTypeSerializer;\n         _keySerializer = src._keySerializer;\n         _nullValueSerializer = src._nullValueSerializer;\n+        _nullKeySerializer = src._nullKeySerializer;\n+\n         _stdNullValueSerializer = (_nullValueSerializer == DEFAULT_NULL_KEY_SERIALIZER);\n-        _nullKeySerializer = src._nullKeySerializer;\n+\n         _rootNames = src._rootNames;\n-\n+        \n         /* Non-blueprint instances do have a read-only map; one that doesn't\n          * need synchronization for lookups.\n          */\n \n         _serializationView = config.getActiveView();\n         _attributes = config.getAttributes();\n+    }\n+\n+    /**\n+     * Copy-constructor used when making a copy of a blueprint instance.\n+     * \n+     * @since 2.4.4\n+     */\n+    protected SerializerProvider(SerializerProvider src)\n+    {\n+        // since this is assumed to be a blue-print instance, many settings missing:\n+        _config = null;\n+        _serializationView = null;\n+        _serializerFactory = null;\n+        _knownSerializers = null;\n+\n+        // and others initialized to default empty state\n+        _serializerCache = new SerializerCache();\n+        _rootNames = new RootNameLookup();\n+\n+        _unknownTypeSerializer = src._unknownTypeSerializer;\n+        _keySerializer = src._keySerializer;\n+        _nullValueSerializer = src._nullValueSerializer;\n+        _nullKeySerializer = src._nullKeySerializer;\n+\n+        _stdNullValueSerializer = src._stdNullValueSerializer;\n     }\n     \n     /*\n      *   finding any serializer\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public JsonSerializer<Object> findValueSerializer(Class<?> valueType,\n-            BeanProperty property)\n+    public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property)\n         throws JsonMappingException\n     {\n         // Fast lookup from local lookup thingy works?\n                 if (ser == null) {\n                     // If neither, must create\n                     ser = _createAndCacheUntypedSerializer(valueType);\n-                    // Not found? Must use the unknown type serializer\n-                    /* Couldn't create? Need to return the fallback serializer, which\n-                     * most likely will report an error: but one question is whether\n-                     * we should cache it?\n-                     */\n+                    // Not found? Must use the unknown type serializer, which will report error later on\n                     if (ser == null) {\n                         ser = getUnknownTypeSerializer(valueType);\n                         // Should this be added to lookups?\n     public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property)\n         throws JsonMappingException\n     {\n-        // Fast lookup from local lookup thingy works?\n+        // (see comments from above method)\n         JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n         if (ser == null) {\n-            // If not, maybe shared map already has it?\n             ser = _serializerCache.untypedValueSerializer(valueType);\n             if (ser == null) {\n-                // If neither, must create\n                 ser = _createAndCacheUntypedSerializer(valueType);\n-                // Not found? Must use the unknown type serializer\n-                /* Couldn't create? Need to return the fallback serializer, which\n-                 * most likely will report an error: but one question is whether\n-                 * we should cache it?\n-                 */\n                 if (ser == null) {\n                     ser = getUnknownTypeSerializer(valueType.getRawClass());\n-                    // Should this be added to lookups?\n                     if (CACHE_UNKNOWN_MAPPINGS) {\n                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                     }\n         return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);\n     }\n \n+    /**\n+     * Method variant used when we do NOT want contextualization to happen; it will need\n+     * to be handled at a later point, but caller wants to be able to do that\n+     * as needed; sometimes to avoid infinite loops\n+     * \n+     * @since 2.5\n+     */\n+    public JsonSerializer<Object> findValueSerializer(Class<?> valueType) throws JsonMappingException\n+    {\n+        // (see comments from above method)\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType));\n+                if (ser == null) {\n+                    ser = _createAndCacheUntypedSerializer(valueType);\n+                    if (ser == null) {\n+                        ser = getUnknownTypeSerializer(valueType);\n+                        if (CACHE_UNKNOWN_MAPPINGS) {\n+                            _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return ser;\n+    }\n+\n+    /**\n+     * Method variant used when we do NOT want contextualization to happen; it will need\n+     * to be handled at a later point, but caller wants to be able to do that\n+     * as needed; sometimes to avoid infinite loops\n+     * \n+     * @since 2.5\n+     */\n+    public JsonSerializer<Object> findValueSerializer(JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        // (see comments from above method)\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                ser = _createAndCacheUntypedSerializer(valueType);\n+                if (ser == null) {\n+                    ser = getUnknownTypeSerializer(valueType.getRawClass());\n+                    if (CACHE_UNKNOWN_MAPPINGS) {\n+                        _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                    }\n+                }\n+            }\n+        }\n+        return ser;\n+    }\n+    \n     /**\n      * Similar to {@link #findValueSerializer(JavaType, BeanProperty)}, but used\n      * when finding \"primary\" property value serializer (one directly handling\n         // 25-Feb-2011, tatu: As per [JACKSON-519], need to ensure contextuality works here, too\n         return _handleContextualResolvable(ser, property);\n     }\n-    \n+\n     /*\n     /********************************************************\n     /* Accessors for specialized serializers\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonAppend.java\n+package com.fasterxml.jackson.databind.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n+\n+/**\n+ * Annotation that may be used to add \"virtual\" properties to be written\n+ * after regular properties (although ordering may be changed using\n+ * both standard <code>@JsonPropertyOrder</code> annotation, and\n+ * properties of this annotation).\n+ * \n+ * @since 2.5\n+ */\n+@Target({ElementType.ANNOTATION_TYPE, ElementType.TYPE })\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonAppend\n+{\n+    /**\n+     * Set of attribute-backed properties to include when serializing\n+     * a POJO.\n+     */\n+    public Attr[] attrs() default { };\n+\n+    /**\n+     * Set of general virtual properties to include when serializing a POJO.\n+     */\n+    public Prop[] props() default { };\n+\n+    /**\n+     * Indicator used to determine whether properties defined are to be\n+     * appended before (false) or prepended before (true) regular properties.\n+     * Affects all kinds of properties defined using this annotation.\n+     */\n+    public boolean prepend() default false;\n+    \n+    /**\n+     * Definition of a single attribute-backed property.\n+     * Attribute-backed properties will be appended after regular properties\n+     * in specified order, although their placement may be further changed\n+     * by the usual property-ordering functionality (alphabetic sorting;\n+     * explicit ordering)\n+     */\n+    public @interface Attr\n+    {\n+        /**\n+         * Name of attribute of which value to serialize. Is also used as the\n+         * name of external property to write, unless overridden by\n+         * assigning a value for {@link #propName()}.\n+         */\n+        public String value();\n+\n+        /**\n+         * Name to use for serializing value of the attribute; if not defined,\n+         * {@link #value} will be used instead.\n+         */\n+        public String propName() default \"\";\n+\n+        /**\n+         * Optional namespace to use; only relevant for data formats that use\n+         * namespaces (like XML).\n+         */\n+        public String propNamespace() default \"\";\n+\n+        /**\n+         * When to include attribute-property. Default value indicates that\n+         * property should only be written if specified attribute has a non-null\n+         * value.\n+         */\n+        public JsonInclude.Include include() default JsonInclude.Include.NON_NULL;\n+\n+        /**\n+         * Metadata about property, similar to\n+         * {@link com.fasterxml.jackson.annotation.JsonProperty#required()}.\n+         */\n+        public boolean required() default false;\n+    }\n+    \n+    /**\n+     * Definition of a single general virtual property.\n+     */\n+    public @interface Prop\n+    {\n+        /**\n+         * Actual implementation class (a subtype of {@link VirtualBeanPropertyWriter})\n+         * of the property to instantiate (using the no-argument default constructor).\n+         */\n+        public Class<? extends VirtualBeanPropertyWriter> value();\n+\n+        /**\n+         * Name of the property to possibly use for serializing (although implementation\n+         * may choose to not use this information).\n+         */\n+        public String name() default \"\";\n+\n+        /**\n+         * Optional namespace to use along with {@link #name};\n+         * only relevant for data formats that use namespaces (like XML).\n+         */\n+        public String namespace() default \"\";\n+\n+        /**\n+         * When to include  value of the property. Default value indicates that\n+         * property should only be written if specified attribute has a non-null\n+         * value. As with other properties, actual property implementation may or may\n+         * not choose to use this inclusion information.\n+         */\n+        public JsonInclude.Include include() default JsonInclude.Include.NON_NULL;\n+\n+        /**\n+         * Metadata about property, similar to\n+         * {@link com.fasterxml.jackson.annotation.JsonProperty#required()}.\n+         */\n+        public boolean required() default false;\n+\n+        /**\n+         * Nominal type of the property. Passed as type information for related\n+         * virtual objects, and may (or may not be) used by implementation\n+         * for choosing serializer to use.\n+         */\n+        public Class<?> type() default Object.class;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonNaming.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonNaming.java\n @com.fasterxml.jackson.annotation.JacksonAnnotation\n public @interface JsonNaming\n {\n-    public Class<? extends PropertyNamingStrategy> value();\n+    /**\n+     * @return Type of {@link PropertyNamingStrategy} to use, if any; default value of\n+     *    <code>PropertyNamingStrategy.class</code> means \"no strategy specified\"\n+     *    (and may also be used for overriding to remove otherwise applicable\n+     *    naming strategy)\n+     */\n+    public Class<? extends PropertyNamingStrategy> value() default PropertyNamingStrategy.class;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/NoClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/NoClass.java\n  * as either default or explicit values. Hence for class values we must\n  * explicitly use a bogus placeholder to denote equivalent of\n  * \"no class\" (for which 'null' is usually the natural choice).\n- * \n- * @deprecated Since 2.4 use {@link java.lang.Void} instead as the general\n- *   \"no class specified\" marker.\n+ *<p>\n+ * Note that since 2.4, most (but not all!\n+ * {@link com.fasterxml.jackson.annotation.JsonTypeInfo#defaultImpl} is\n+ * a notable exception}) usage should start using\n+ * {@link java.lang.Void} instead as the \"not defined\" marker.\n  */\n-@Deprecated\n public final class NoClass\n {\n     private NoClass() { }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializerFactoryConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializerFactoryConfig.java\n public class DeserializerFactoryConfig\n     implements java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = 3683541151102256824L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     protected final static Deserializers[] NO_DESERIALIZERS = new Deserializers[0];\n     protected final static BeanDeserializerModifier[] NO_MODIFIERS = new BeanDeserializerModifier[0];\n      * are configured and constructed.\n      */\n     protected final BeanDeserializerModifier[] _modifiers;\n-\n \n     /**\n      * List of objects that may be able to resolve abstract types to\n      * or to support post-constructor functionality.\n      */\n     protected final ValueInstantiators[] _valueInstantiators;\n-    \n+\n     /**\n      * Constructor for creating basic configuration with no additional\n      * handlers.\n         return new DeserializerFactoryConfig(all, _additionalKeyDeserializers, _modifiers,\n                 _abstractTypeResolvers, _valueInstantiators);\n     }\n+\n     /**\n      * Fluent/factory method used to construct a configuration object that\n      * has same key deserializer providers as this instance, plus one specified\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n         return null;\n     }\n \n-    public ObjectIdResolver resolverIdGeneratorInstance(MapperConfig<?> config, Annotated annotated, Class<?> implClass)\n-    {\n+    public ObjectIdResolver resolverIdGeneratorInstance(MapperConfig<?> config, Annotated annotated, Class<?> implClass) {\n         return null;\n     }\n \n         return null;\n     }\n \n+    /**\n+     * Method called to construct a {@link VirtualBeanPropertyWriter} instance\n+     * of specified type.\n+     *\n+     * @since 2.5\n+     */\n+    public VirtualBeanPropertyWriter virtualPropertyWriterInstance(MapperConfig<?> config,\n+            Class<?> implClass) {\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfig.java\n     implements ClassIntrospector.MixInResolver,\n         java.io.Serializable\n {\n-    private static final long serialVersionUID = 8891625428805876137L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     /**\n      * Set of shared mapper features enabled.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n     extends JsonDeserializer<Object>\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = -3010349050434697698L;\n+    private static final long serialVersionUID = 1L;\n \n     protected final JavaType _baseType;\n \n      * \n      * @since 2.3\n      */\n-    public static AbstractDeserializer constructForNonPOJO(BeanDescription beanDesc)\n-    {\n+    public static AbstractDeserializer constructForNonPOJO(BeanDescription beanDesc) {\n         return new AbstractDeserializer(beanDesc);\n     }\n     \n     /**********************************************************\n      */\n     \n-    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         /* As per [JACKSON-417], there is a chance we might be \"natural\" types\n          * (String, Boolean, Integer, Double), which do not include any type information...\n          * Finally, we may have to consider possibility of custom handlers for\n          * these values: but for now this should work ok.\n          */\n-        /* 21-Sep-2013, tatu: It may seem odd that I'm not using a switch here.\n-         *   But turns out that a switch on an enum generates an inner class...\n-         *   crazy! So this is to avoid that, simply since new class weighs about 1kB\n-         *   after compression.\n-         */\n-        final JsonToken t = jp.getCurrentToken();\n-        if (t.isScalarValue()) {\n-            if (t == JsonToken.VALUE_STRING) {\n-                if (_acceptString) {\n-                    return jp.getText();\n-                }\n-            } else if (t == JsonToken.VALUE_NUMBER_INT) {\n-                if (_acceptInt) {\n-                    return jp.getIntValue();\n-                }\n-            } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n-                if (_acceptDouble) {\n-                    return Double.valueOf(jp.getDoubleValue());\n-                }\n-            } else if (t == JsonToken.VALUE_TRUE) {\n-                if (_acceptBoolean) {\n-                    return Boolean.TRUE;\n-                }\n-            } else if (t == JsonToken.VALUE_FALSE) {\n-                if (_acceptBoolean) {\n-                    return Boolean.FALSE;\n-                }\n-            }\n+        switch (jp.getCurrentTokenId()) {\n+        case JsonTokenId.ID_STRING:\n+            if (_acceptString) {\n+                return jp.getText();\n+            }\n+            break;\n+        case JsonTokenId.ID_NUMBER_INT:\n+            if (_acceptInt) {\n+                return jp.getIntValue();\n+            }\n+            break;\n+        case JsonTokenId.ID_NUMBER_FLOAT:\n+            if (_acceptDouble) {\n+                return Double.valueOf(jp.getDoubleValue());\n+            }\n+            break;\n+        case JsonTokenId.ID_TRUE:\n+            if (_acceptBoolean) {\n+                return Boolean.TRUE;\n+            }\n+            break;\n+        case JsonTokenId.ID_FALSE:\n+            if (_acceptBoolean) {\n+                return Boolean.FALSE;\n+            }\n+            break;\n         }\n         return null;\n     }\n      * Method called in cases where it looks like we got an Object Id\n      * to parse and use as a reference.\n      */\n-    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeFromObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         Object id = _objectIdReader.readObjectReference(jp, ctxt);\n         ReadableObjectId roid = ctxt.findObjectId(id, _objectIdReader.generator, _objectIdReader.resolver);\n         // do we have it resolved?\n         Object pojo = roid.resolve();\n         if (pojo == null) { // not yet; should wait...\n-            throw new IllegalStateException(\"Could not resolve Object Id [\"+id+\"] -- unresolved forward-reference?\");\n+            throw new UnresolvedForwardReference(\"Could not resolve Object Id [\"+id+\"] -- unresolved forward-reference?\", jp.getCurrentLocation(), roid);\n         }\n         return pojo;\n     }\n }\n \n+\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n import java.util.concurrent.*;\n import java.util.concurrent.atomic.AtomicReference;\n \n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.core.JsonLocation;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n         _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n         _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n \n-        /* 11-Jan-2009, tatu: Let's see if we can still add support for\n-         *    JDK 1.6 interfaces, even if we run on 1.5. Just need to be\n-         *    more careful with typos, since compiler won't notice any\n-         *    problems...\n-         */\n-        _mapFallbacks.put(\"java.util.NavigableMap\", TreeMap.class);\n-        try {\n-            Class<?> key = java.util.concurrent.ConcurrentNavigableMap.class;\n-            Class<?> value = java.util.concurrent.ConcurrentSkipListMap.class;\n-            @SuppressWarnings(\"unchecked\")\n-                Class<? extends Map<?,?>> mapValue = (Class<? extends Map<?,?>>) value;\n-            _mapFallbacks.put(key.getName(), mapValue);\n-        } catch (Throwable e) { // some class loading problems are Errors, others Exceptions\n-            System.err.println(\"Problems with (optional) types: \"+e);\n-        }\n+        _mapFallbacks.put(java.util.NavigableMap.class.getName(), TreeMap.class);\n+        _mapFallbacks.put(java.util.concurrent.ConcurrentNavigableMap.class.getName(),\n+                java.util.concurrent.ConcurrentSkipListMap.class);\n     }\n \n     /* We do some defaulting for abstract Collection classes and\n \n             // some single-arg factory methods (String, number) are auto-detected\n             if (argCount == 1) {\n-                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[0];\n-                boolean hasExplicitName = (propDef != null) && propDef.isExplicitlyNamed();\n-                Object injectId = intr.findInjectableValueId(ctor.getParameter(0));\n-\n-                if (hasExplicitName || (injectId != null)) {\n+                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n+                boolean useProps = _checkIfCreatorPropertyBased(intr, ctor, argDef);\n+\n+                if (useProps) {\n                     CreatorProperty[] properties = new CreatorProperty[1];\n-                    PropertyName name = (propDef == null) ? null : propDef.getFullName();\n-                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, ctor.getParameter(0), injectId);\n+                    PropertyName name = (argDef == null) ? null : argDef.getFullName();\n+                    AnnotatedParameter arg = ctor.getParameter(0);\n+                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, arg,\n+                            intr.findInjectableValueId(arg));\n                     creators.addPropertyCreator(ctor, properties);\n                 } else {\n                     /*boolean added = */ _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n                             ctor, isCreator,\n                             vchecker.isCreatorVisible(ctor));\n+                    // one more thing: sever link to creator property, to avoid possible later\n+                    // problems with \"unresolved\" constructor property\n+                    if (argDef != null) {\n+                        ((POJOPropertyBuilder) argDef).removeConstructors();\n+                    }\n                 }\n                 // regardless, fully handled\n                 continue;\n         }\n     }\n \n+    protected boolean _checkIfCreatorPropertyBased(AnnotationIntrospector intr,\n+            AnnotatedWithParams creator, BeanPropertyDefinition propDef)\n+    {\n+        JsonCreator.Mode mode = intr.findCreatorBinding(creator);\n+\n+        if (mode == JsonCreator.Mode.PROPERTIES) {\n+            return true;\n+        }\n+        if (mode == JsonCreator.Mode.DELEGATING) {\n+            return false;\n+        }\n+        // If explicit name, or inject id, property-based\n+        if (((propDef != null) && propDef.isExplicitlyNamed())\n+                || (intr.findInjectableValueId(creator.getParameter(0)) != null)) {\n+            return true;\n+        }\n+        if (propDef != null) {\n+            // One more thing: if implicit name matches property with a getter\n+            // or field, we'll consider it property-based as well\n+            String implName = propDef.getName();\n+            if (implName != null && !implName.isEmpty()) {\n+                if (propDef.couldSerialize()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        // in absence of everything else, default to delegating\n+        return false;\n+    }\n+    \n     protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt,\n             BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n             AnnotationIntrospector intr, CreatorCollector creators,\n             final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n             // some single-arg factory methods (String, number) are auto-detected\n             if (argCount == 1) {\n-                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[0];\n-                boolean hasExplicitName = (propDef != null) && propDef.isExplicitlyNamed();\n-                final Object injectId = intr.findInjectableValueId(factory.getParameter(0));\n-                if ((injectId == null) && !hasExplicitName) { // not property based\n+                BeanPropertyDefinition argDef = (propDefs == null) ? null : propDefs[0];\n+                boolean useProps = _checkIfCreatorPropertyBased(intr, factory, argDef);\n+                if (!useProps) { // not property based but delegating\n                     /*boolean added=*/ _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n                             factory, isCreator);\n                     // otherwise just ignored\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n     extends BeanDeserializerBase\n     implements java.io.Serializable\n {\n+    /* TODOs for future versions:\n+     * \n+     * For 2.6\n+     * \n+     * - Start using new (2.5) methods in JsonParser, like\n+     *   * 'hasTokenId(xxx)'\n+     *   * 'nextFieldName()'\n+     *   \n+     *   for slightly more efficient property lookups, handling\n+     *   (2-3% faster deserialization)\n+     *   Not done for 2.5 since it was just introduced, trying to\n+     *   keep some level of compatibility between \"adjacent\" minor\n+     *   versions.\n+     *   Also: need to ensure efficient impl of those methods for Smile, CBOR\n+     *   at least (in addition to JSON)\n+     * \n+     */\n+\n     private static final long serialVersionUID = 1L;\n \n     /*\n      * like Afterburner change definition.\n      */\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonToken t = jp.getCurrentToken();\n-        // common case first:\n-        if (t == JsonToken.START_OBJECT) {\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        JsonToken t = p.getCurrentToken();\n+        // common case first\n+        if (t == JsonToken.START_OBJECT) { // TODO: in 2.6, use 'p.hasTokenId()'\n             if (_vanillaProcessing) {\n-                return vanillaDeserialize(jp, ctxt, jp.nextToken());\n-            }\n-            jp.nextToken();\n+                return vanillaDeserialize(p, ctxt, p.nextToken());\n+            }\n+            p.nextToken();\n             if (_objectIdReader != null) {\n-                return deserializeWithObjectId(jp, ctxt);\n-            }\n-            return deserializeFromObject(jp, ctxt);\n-        }\n-        return _deserializeOther(jp, ctxt, t);\n-    }\n-\n-    protected final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt,\n+                return deserializeWithObjectId(p, ctxt);\n+            }\n+            return deserializeFromObject(p, ctxt);\n+        }\n+        return _deserializeOther(p, ctxt, t);\n+    }\n+\n+    protected final Object _deserializeOther(JsonParser p, DeserializationContext ctxt,\n             JsonToken t) throws IOException\n     {\n         // and then others, generally requiring use of @JsonCreator\n         switch (t) {\n         case VALUE_STRING:\n-            return deserializeFromString(jp, ctxt);\n+            return deserializeFromString(p, ctxt);\n         case VALUE_NUMBER_INT:\n-            return deserializeFromNumber(jp, ctxt);\n+            return deserializeFromNumber(p, ctxt);\n         case VALUE_NUMBER_FLOAT:\n-\t    return deserializeFromDouble(jp, ctxt);\n+\t    return deserializeFromDouble(p, ctxt);\n         case VALUE_EMBEDDED_OBJECT:\n-            return deserializeFromEmbedded(jp, ctxt);\n+            return deserializeFromEmbedded(p, ctxt);\n         case VALUE_TRUE:\n         case VALUE_FALSE:\n-            return deserializeFromBoolean(jp, ctxt);\n+            return deserializeFromBoolean(p, ctxt);\n         case START_ARRAY:\n             // these only work if there's a (delegating) creator...\n-            return deserializeFromArray(jp, ctxt);\n+            return deserializeFromArray(p, ctxt);\n         case FIELD_NAME:\n         case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n             if (_vanillaProcessing) {\n-                return vanillaDeserialize(jp, ctxt, t);\n+                return vanillaDeserialize(p, ctxt, t);\n             }\n             if (_objectIdReader != null) {\n-                return deserializeWithObjectId(jp, ctxt);\n-            }\n-            return deserializeFromObject(jp, ctxt);\n+                return deserializeWithObjectId(p, ctxt);\n+            }\n+            return deserializeFromObject(p, ctxt);\n         default:\n             throw ctxt.mappingException(handledType());\n         }\n     }\n \n-    protected Object _missingToken(JsonParser jp, DeserializationContext ctxt)\n+    protected Object _missingToken(JsonParser p, DeserializationContext ctxt)\n         throws JsonProcessingException\n     {\n         throw ctxt.endOfInputException(handledType());\n      * after collecting some or all of the properties to set.\n      */\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n+    {\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         if (_unwrappedPropertyHandler != null) {\n-            return deserializeWithUnwrapped(jp, ctxt, bean);\n+            return deserializeWithUnwrapped(p, ctxt, bean);\n         }\n         if (_externalTypeIdHandler != null) {\n-            return deserializeWithExternalTypeId(jp, ctxt, bean);\n-        }\n-        JsonToken t = jp.getCurrentToken();\n+            return deserializeWithExternalTypeId(p, ctxt, bean);\n+        }\n+        JsonToken t = p.getCurrentToken();\n         // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n         if (t == JsonToken.START_OBJECT) {\n-            t = jp.nextToken();\n+            t = p.nextToken();\n         }\n         if (_needViewProcesing) {\n             Class<?> view = ctxt.getActiveView();\n             if (view != null) {\n-                return deserializeWithView(jp, ctxt, bean, view);\n-            }\n-        }\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+                return deserializeWithView(p, ctxt, bean, view);\n+            }\n+        }\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             \n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+            handleUnknownVanilla(p, ctxt, bean, propName);\n         }\n         return bean;\n     }\n      * Streamlined version that is only used when no \"special\"\n      * features are enabled.\n      */\n-    private final Object vanillaDeserialize(JsonParser jp,\n+    private final Object vanillaDeserialize(JsonParser p,\n     \t\tDeserializationContext ctxt, JsonToken t)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             } else {\n-                handleUnknownVanilla(jp, ctxt, bean, propName);\n+                handleUnknownVanilla(p, ctxt, bean, propName);\n             }\n         }\n         return bean;\n     }\n \n     /**\n-     * General version used when handling needs more advanced\n-     * features.\n+     * General version used when handling needs more advanced features.\n      */\n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n+    {\n+        /* 09-Dec-2014, tatu: As per [#622], we need to allow Object Id references\n+         *   to come in as JSON Objects as well; but for now assume they will\n+         *   be simple, single-property references, which means that we can\n+         *   recognize them without having to buffer anything.\n+         *   Once again, if we must, we can do more complex handling with buffering,\n+         *   but let's only do that if and when that becomes necessary.\n+         */\n+        if (_objectIdReader != null && _objectIdReader.maySerializeAsObject()) {\n+            // TODO: in 2.6, use 'p.hasTokenId()'\n+            if ((p.getCurrentTokenId() == JsonTokenId.ID_FIELD_NAME)\n+                    && _objectIdReader.isValidReferencePropertyName(p.getCurrentName(), p)) {\n+                return deserializeFromObjectId(p, ctxt);\n+            }\n+        }\n         if (_nonStandardCreation) {\n             if (_unwrappedPropertyHandler != null) {\n-                return deserializeWithUnwrapped(jp, ctxt);\n+                return deserializeWithUnwrapped(p, ctxt);\n             }\n             if (_externalTypeIdHandler != null) {\n-                return deserializeWithExternalTypeId(jp, ctxt);\n-            }\n-            Object bean = deserializeFromObjectUsingNonDefault(jp, ctxt);\n+                return deserializeWithExternalTypeId(p, ctxt);\n+            }\n+            Object bean = deserializeFromObjectUsingNonDefault(p, ctxt);\n             if (_injectables != null) {\n                 injectValues(ctxt, bean);\n             }\n             if (_needViewProcesing) {\n                 Class<?> view = ctxt.getActiveView();\n                 if (view != null) {\n-                    return deserializeWithView(jp, ctxt, bean, view);\n+                    return deserializeWithView(p, ctxt, bean, view);\n                 }\n             }\n             */\n             return bean;\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n-        if (jp.canReadObjectId()) {\n-            Object id = jp.getObjectId();\n+        // [databind#631]: Assign current value, to be accessible by custom deserializers\n+        p.setCurrentValue(bean);\n+        if (p.canReadObjectId()) {\n+            Object id = p.getObjectId();\n             if (id != null) {\n-                _handleTypedObjectId(jp, ctxt, bean, id);\n+                _handleTypedObjectId(p, ctxt, bean, id);\n             }\n         }\n         if (_injectables != null) {\n         if (_needViewProcesing) {\n             Class<?> view = ctxt.getActiveView();\n             if (view != null) {\n-                return deserializeWithView(jp, ctxt, bean, view);\n-            }\n-        }\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+                return deserializeWithView(p, ctxt, bean, view);\n+            }\n+        }\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+            handleUnknownVanilla(p, ctxt, bean, propName);\n         }\n         return bean;\n     }\n      */\n     @Override\n     @SuppressWarnings(\"resource\")\n-    protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    { \n+    protected Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n+        throws IOException\n+    {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n         \n         // 04-Jan-2010, tatu: May need to collect unknown properties for polymorphic cases\n         TokenBuffer unknown = null;\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                    jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n                         bean = creator.build(ctxt, buffer);\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         bean = null; // never gets here\n                     }\n+                    if (bean == null) {\n+                        throw ctxt.instantiationException(_beanType.getRawClass(), \"JSON Creator returned null\");\n+                    }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n+\n                     //  polymorphic?\n                     if (bean.getClass() != _beanType.getRawClass()) {\n-                        return handlePolymorphic(jp, ctxt, bean, unknown);\n+                        return handlePolymorphic(p, ctxt, bean, unknown);\n                     }\n                     if (unknown != null) { // nope, just extra unknown stuff...\n                         bean = handleUnknownProperties(ctxt, bean, unknown);\n                     }\n                     // or just clean?\n-                    return deserialize(jp, ctxt, bean);\n+                    return deserialize(p, ctxt, bean);\n                 }\n                 continue;\n             }\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             // As per [JACKSON-313], things marked as ignorable should not be\n             // passed to any setter\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n                 continue;\n             }\n             // Ok then, let's collect the whole field; name and value\n             if (unknown == null) {\n-                unknown = new TokenBuffer(jp);\n+                unknown = new TokenBuffer(p);\n             }\n             unknown.writeFieldName(propName);\n-            unknown.copyCurrentStructure(jp);\n-        }\n-\n+            unknown.copyCurrentStructure(p);\n+        }\n+        \n         // We hit END_OBJECT, so:\n         Object bean;\n         try {\n     /**********************************************************\n      */\n     \n-    protected final Object deserializeWithView(JsonParser jp, DeserializationContext ctxt,\n+    protected final Object deserializeWithView(JsonParser p, DeserializationContext ctxt,\n             Object bean, Class<?> activeView)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n+        throws IOException\n+    {\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n             // Skip field name:\n-            jp.nextToken();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n                 if (!prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n-            handleUnknownVanilla(jp, ctxt, bean, propName);\n+            handleUnknownVanilla(p, ctxt, bean, propName);\n         }\n         return bean;\n     }\n      * which need special handling\n      */\n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n-            return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt);\n-        }\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+            return deserializeUsingPropertyBasedWithUnwrapped(p, ctxt);\n+        }\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n \n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n-        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken();\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // how about any setter? We'll get copies but...\n             if (_anySetter != null) {\n                 try {\n-                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             }\n         }\n         tokens.writeEndObject();\n-        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n         return bean;\n-    }    \n+    }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonToken t = jp.getCurrentToken();\n+    protected Object deserializeWithUnwrapped(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n+    {\n+        JsonToken t = p.getCurrentToken();\n         if (t == JsonToken.START_OBJECT) {\n-            t = jp.nextToken();\n-        }\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+            t = p.nextToken();\n+        }\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            SettableBeanProperty prop = _beanProperties.find(propName);\n-            jp.nextToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            p.nextToken();\n             if (prop != null) { // normal case\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but... others should be passed to unwrapped property deserializers\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // how about any setter? We'll get copies but...\n             if (_anySetter != null) {\n-                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n             }\n         }\n         tokens.writeEndObject();\n-        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n         return bean;\n     }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n-\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n+\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                    t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                     Object bean;\n                     try {\n                         bean = creator.build(ctxt, buffer);\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         continue; // never gets here\n                     }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n-                        jp.nextToken(); // to skip name\n-                        tokens.copyCurrentStructure(jp);\n-                        t = jp.nextToken();\n+                        p.nextToken(); // to skip name\n+                        tokens.copyCurrentStructure(p);\n+                        t = p.nextToken();\n                     }\n                     tokens.writeEndObject();\n                     if (bean.getClass() != _beanType.getRawClass()) {\n                         tokens.close();\n                         throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                     }\n-                    return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n                 }\n                 continue;\n             }\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             /* As per [JACKSON-313], things marked as ignorable should not be\n              * passed to any setter\n              */\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             tokens.writeFieldName(propName);\n-            tokens.copyCurrentStructure(jp);\n+            tokens.copyCurrentStructure(p);\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n             }\n         }\n \n             wrapInstantiationProblem(e, ctxt);\n             return null; // never gets here\n         }\n-        return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n     }\n \n     /*\n     /**********************************************************\n      */\n     \n-    protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_propertyBasedCreator != null) {\n-            return deserializeUsingPropertyBasedWithExternalTypeId(jp, ctxt);\n-        }\n-        return deserializeWithExternalTypeId(jp, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n+            return deserializeUsingPropertyBasedWithExternalTypeId(p, ctxt);\n+        }\n+        return deserializeWithExternalTypeId(p, ctxt, _valueInstantiator.createUsingDefault(ctxt));\n     }\n     \n-    protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt,\n+    protected Object deserializeWithExternalTypeId(JsonParser p, DeserializationContext ctxt,\n             Object bean)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n         final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken();\n+        \n+        for (JsonToken t = p.getCurrentToken(); t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            t = p.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n                 // [JACKSON-831]: may have property AND be used as external type id:\n-                if (jp.getCurrentToken().isScalarValue()) {\n-                    ext.handleTypePropertyValue(jp, ctxt, propName, bean);\n+                if (t.isScalarValue()) {\n+                    ext.handleTypePropertyValue(p, ctxt, propName, bean);\n                 }\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n-                    jp.skipChildren();\n+                    p.skipChildren();\n                     continue;\n                 }\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             }\n             // ignorable things should be ignored\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, bean, propName);\n+                handleIgnoredProperty(p, ctxt, bean, propName);\n                 continue;\n             }\n             // but others are likely to be part of external type id thingy...\n-            if (ext.handlePropertyValue(jp, ctxt, propName, bean)) {\n+            if (ext.handlePropertyValue(p, ctxt, propName, bean)) {\n                 continue;\n             }\n             // if not, the usual fallback handling:\n             if (_anySetter != null) {\n                 try {\n-                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                    _anySetter.deserializeAndSet(p, ctxt, bean, propName);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n                 continue;\n             }\n             // Unknown: let's call handler method\n-            handleUnknownProperty(jp, ctxt, bean, propName);         \n+            handleUnknownProperty(p, ctxt, bean, propName);         \n         }\n         // and when we get this far, let's try finalizing the deal:\n-        return ext.complete(jp, ctxt, bean);\n+        return ext.complete(p, ctxt, bean);\n     }\n \n     @SuppressWarnings(\"resource\")\n-    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n-\n-        TokenBuffer tokens = new TokenBuffer(jp);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n+\n+        TokenBuffer tokens = new TokenBuffer(p);\n         tokens.writeStartObject();\n \n-        JsonToken t = jp.getCurrentToken();\n-        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n-            String propName = jp.getCurrentName();\n-            jp.nextToken(); // to point to value\n+        JsonToken t = p.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n+            String propName = p.getCurrentName();\n+            p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n-                if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) {\n+                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n-                    Object value = creatorProp.deserialize(jp, ctxt);\n+                    Object value = creatorProp.deserialize(p, ctxt);\n                     if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n-                        t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                        t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n                         Object bean;\n                         try {\n                             bean = creator.build(ctxt, buffer);\n                         }\n                         // if so, need to copy all remaining tokens into buffer\n                         while (t == JsonToken.FIELD_NAME) {\n-                            jp.nextToken(); // to skip name\n-                            tokens.copyCurrentStructure(jp);\n-                            t = jp.nextToken();\n+                            p.nextToken(); // to skip name\n+                            tokens.copyCurrentStructure(p);\n+                            t = p.nextToken();\n                         }\n                         if (bean.getClass() != _beanType.getRawClass()) {\n                             // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                             //   it's too complicated, so bail out\n                             throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                         }\n-                        return ext.complete(jp, ctxt, bean);\n+                        return ext.complete(p, ctxt, bean);\n                     }\n                 }\n                 continue;\n             // regular property? needs buffering\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) {\n-                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n                 continue;\n             }\n             // external type id (or property that depends on it)?\n-            if (ext.handlePropertyValue(jp, ctxt, propName, null)) {\n+            if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                 continue;\n             }\n             /* As per [JACKSON-313], things marked as ignorable should not be\n              * passed to any setter\n              */\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-                handleIgnoredProperty(jp, ctxt, handledType(), propName);\n+                handleIgnoredProperty(p, ctxt, handledType(), propName);\n                 continue;\n             }\n             // \"any property\"?\n             if (_anySetter != null) {\n-                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt));\n             }\n         }\n \n         // We hit END_OBJECT; resolve the pieces:\n         try {\n-            return ext.complete(jp, ctxt, buffer, creator);\n+            return ext.complete(p, ctxt, buffer, creator);\n         } catch (Exception e) {\n             wrapInstantiationProblem(e, ctxt);\n             return null; // never gets here\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n-\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.impl.*;\n      * to use have been successfully resolved.\n      */\n     final protected BeanPropertyMap _beanProperties;\n-    \n+\n     /**\n      * List of {@link ValueInjector}s, if any injectable values are\n      * expected by the bean; otherwise null.\n      * and fields, but not ones passed through constructor parameters.\n      */\n     final protected ValueInjector[] _injectables;\n-    \n+\n     /**\n      * Fallback setter used for handling any properties that are not\n      * mapped to regular setters. If setter is not null, it will be\n                 ;\n     }\n \n-    protected BeanDeserializerBase(BeanDeserializerBase src)\n-    {\n+    protected BeanDeserializerBase(BeanDeserializerBase src) {\n         this(src, src._ignoreAllUnknown);\n     }\n \n             BeanProperty.Std property = new BeanProperty.Std(TEMP_PROPERTY_NAME,\n                     delegateType, null, _classAnnotations, delegateCreator,\n                     PropertyMetadata.STD_OPTIONAL);\n-            _delegateDeserializer = findDeserializer(ctxt, delegateType, property);\n+\n+            TypeDeserializer td = delegateType.getTypeHandler();\n+            if (td == null) {\n+                td = ctxt.getConfig().findTypeDeserializer(delegateType);\n+            }\n+            JsonDeserializer<Object> dd = findDeserializer(ctxt, delegateType, property);\n+            if (td != null) {\n+                td = td.forProperty(property);\n+                dd = new TypeWrappedDeserializer(td, dd);\n+            }\n+            _delegateDeserializer = dd;\n         }\n         \n         if (extTypes != null) {\n      * General version used when handling needs more advanced\n      * features.\n      */\n-    public abstract Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException;\n+    public abstract Object deserializeFromObject(JsonParser p, DeserializationContext ctxt)\n+        throws IOException;\n \n     @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // 16-Feb-2012, tatu: ObjectId may be used as well... need to check that first\n         if (_objectIdReader != null) {\n             // 05-Aug-2013, tatu: May use native Object Id\n-            if (jp.canReadObjectId()) {\n-                Object id = jp.getObjectId();\n+            if (p.canReadObjectId()) {\n+                Object id = p.getObjectId();\n                 if (id != null) {\n-                    Object ob = typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n-                    return _handleTypedObjectId(jp, ctxt, ob, id);\n+                    Object ob = typeDeserializer.deserializeTypedFromObject(p, ctxt);\n+                    return _handleTypedObjectId(p, ctxt, ob, id);\n                 }\n             }\n             // or, Object Ids Jackson explicitly sets\n-            JsonToken t = jp.getCurrentToken();\n+            JsonToken t = p.getCurrentToken();\n             // for now (2.2.x) we only allow scalar types (Strings, integral numbers):\n             // NOTE: may  need to allow handling of structured values in future for JSOG\n-            if (t != null && t.isScalarValue()) {\n-                return deserializeFromObjectId(jp, ctxt);\n+            if (t != null && (t.isScalarValue() || _objectIdReader.maySerializeAsObject())) {\n+                return deserializeFromObjectId(p, ctxt);\n             }\n         }\n         // In future could check current token... for now this should be enough:\n-        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+        return typeDeserializer.deserializeTypedFromObject(p, ctxt);\n     }\n \n     /**\n      */\n     protected Object _handleTypedObjectId(JsonParser jp, DeserializationContext ctxt,\n             Object pojo, Object rawId)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         /* 07-Aug-2013, tatu: One more challenge: type of id may not be type\n          *   of property we are expecting later on; specifically, numeric ids\n      * buffering in some cases, but usually just a simple lookup to ensure\n      * that ordering is correct.\n      */\n-    protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException\n-    {\n+    protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n         return deserializeFromObject(jp, ctxt);\n     }\n-    \n+\n     /**\n      * Method called in cases where it looks like we got an Object Id\n      * to parse and use as a reference.\n \n     protected Object deserializeFromObjectUsingNonDefault(JsonParser jp,\n             DeserializationContext ctxt) throws IOException\n-    {        \n+    {\n         if (_delegateDeserializer != null) {\n             return _valueInstantiator.createUsingDelegate(ctxt,\n                     _delegateDeserializer.deserialize(jp, ctxt));\n                     +\" (need to add/enable type information?)\");\n         }\n         throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n-                +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n+                +_beanType+\": can not instantiate from JSON object (missing default constructor or creator, or perhaps need to add/enable type information?)\");\n     }\n \n     protected abstract Object _deserializeUsingPropertyBased(final JsonParser jp,\n             }\n             return bean;\n         }\n-        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON integer number\");\n-    }\n-\n-    public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        throw ctxt.instantiationException(handledType(), \"no suitable creator method found to deserialize from JSON integer number\");\n+    }\n+\n+    public Object deserializeFromString(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         // First things first: id Object Id is used, most likely that's it\n         if (_objectIdReader != null) {\n-            return deserializeFromObjectId(jp, ctxt);\n+            return deserializeFromObjectId(p, ctxt);\n         }\n         \n         /* Bit complicated if we have delegating creator; may need to use it,\n          */\n         if (_delegateDeserializer != null) {\n             if (!_valueInstantiator.canCreateFromString()) {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n                 return bean;\n             }\n         }\n-        return _valueInstantiator.createFromString(ctxt, jp.getText());\n+        return _valueInstantiator.createFromString(ctxt, p.getText());\n     }\n \n     /**\n      * number.\n      */\n     @SuppressWarnings(\"incomplete-switch\")\n-    public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt) throws IOException\n-    {\n-        switch (jp.getNumberType()) {\n+    public Object deserializeFromDouble(JsonParser p, DeserializationContext ctxt) throws IOException\n+    {\n+        switch (p.getNumberType()) {\n         case FLOAT: // no separate methods for taking float...\n         case DOUBLE:\n             if (_delegateDeserializer != null) {\n                 if (!_valueInstantiator.canCreateFromDouble()) {\n-                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                    Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                     if (_injectables != null) {\n                         injectValues(ctxt, bean);\n                     }\n                     return bean;\n                 }\n             }\n-            return _valueInstantiator.createFromDouble(ctxt, jp.getDoubleValue());\n+            return _valueInstantiator.createFromDouble(ctxt, p.getDoubleValue());\n         }\n         // actually, could also be BigDecimal, so:\n         if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-        }\n-        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON floating-point number\");\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n+        }\n+        throw ctxt.instantiationException(handledType(), \"no suitable creator method found to deserialize from JSON floating-point number\");\n     }\n \n     /**\n      * Method called to deserialize POJO value from a JSON boolean value (true, false)\n      */\n-    public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    public Object deserializeFromBoolean(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             if (!_valueInstantiator.canCreateFromBoolean()) {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n                 return bean;\n             }\n         }\n-        boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE);\n+        boolean value = (p.getCurrentToken() == JsonToken.VALUE_TRUE);\n         return _valueInstantiator.createFromBoolean(ctxt, value);\n     }\n \n-    public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    public Object deserializeFromArray(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             try {\n-                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n                 if (_injectables != null) {\n                     injectValues(ctxt, bean);\n                 }\n                 wrapInstantiationProblem(e, ctxt);\n             }\n         } else if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n-            JsonToken t = jp.nextToken();\n+            JsonToken t = p.nextToken();\n             if (t == JsonToken.END_ARRAY && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n                 return null;\n             }\n-            final Object value = deserialize(jp, ctxt);\n-            if (jp.nextToken() != JsonToken.END_ARRAY) {\n-                throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \n+            final Object value = deserialize(p, ctxt);\n+            if (p.nextToken() != JsonToken.END_ARRAY) {\n+                throw ctxt.wrongTokenException(p, JsonToken.END_ARRAY, \n                         \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\");\n             }\n             return value;\n         } else if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n-            JsonToken t = jp.nextToken();\n+            JsonToken t = p.nextToken();\n             if (t == JsonToken.END_ARRAY) {\n                 return null;\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n      * \n      * @since 2.0\n      */\n-    public AbstractDeserializer buildAbstract()\n-    {\n+    public AbstractDeserializer buildAbstract() {\n         return new AbstractDeserializer(this, _beanDesc, _backRefProperties);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n          */\n         AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n         if (am != null) { // should never be null\n-            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am, \"cause\");\n+            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(ctxt.getConfig(), am,\n+                    new PropertyName(\"cause\"));\n             SettableBeanProperty prop = constructSettableProperty(ctxt, beanDesc, propDef,\n                     am.getGenericParameterType(0));\n             if (prop != null) {\n         if (typeStr != null) {\n             throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n         }\n-    \treturn true;\n+        return true;\n     }\n \n     /**\n             Class<?> type, Map<Class<?>,Boolean> ignoredTypes)\n     {\n         Boolean status = ignoredTypes.get(type);\n-        if (status == null) {\n-            BeanDescription desc = config.introspectClassAnnotations(type);\n-            status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n-            // We default to 'false', ie. not ignorable\n-            if (status == null) {\n-                status = Boolean.FALSE;\n-            }\n-        }\n-        return status;\n+        if (status != null) {\n+            return status.booleanValue();\n+        }\n+        BeanDescription desc = config.introspectClassAnnotations(type);\n+        status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n+        // We default to 'false', i.e. not ignorable\n+        return (status == null) ? false : status.booleanValue(); \n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DataFormatReaders.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DataFormatReaders.java\n         final int len = _readers.length;\n         ObjectReader[] r = new ObjectReader[len];\n         for (int i = 0; i < len; ++i) {\n-            r[i] = _readers[i].withType(type);\n+            r[i] = _readers[i].forType(type);\n         }\n         return new DataFormatReaders(r, _optimalMatch, _minimalMatch, _maxInputLookahead);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n package com.fasterxml.jackson.databind.deser;\n \n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n+import java.util.*;\n import java.util.Map.Entry;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n         super(src, factory);\n     }\n \n+    /**\n+     * @since 2.4.4\n+     */\n+    protected DefaultDeserializationContext(DefaultDeserializationContext src) {\n+        super(src);\n+    }\n+    \n+    /**\n+     * Method needed to ensure that {@link ObjectMapper#copy} will work\n+     * properly; specifically, that caches are cleared, but settings\n+     * will otherwise remain identical; and that no sharing of state\n+     * occurs.\n+     * \n+     * @since 2.4.4\n+     */\n+    public DefaultDeserializationContext copy() {\n+        throw new IllegalStateException(\"DefaultDeserializationContext sub-class not overriding copy()\");\n+    }\n+\n     /*\n     /**********************************************************\n     /* Abstract methods impls, Object Id\n     public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType)\n     {\n         final ObjectIdGenerator.IdKey key = gen.key(id);\n+\n         if (_objectIds == null) {\n             _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>();\n         } else {\n             super(src, config, jp, values);\n         }\n \n+        protected Impl(Impl src) { super(src); }\n+        \n         protected Impl(Impl src, DeserializerFactory factory) {\n             super(src, factory);\n+        }\n+\n+        @Override\n+        public DefaultDeserializationContext copy() {\n+            if (getClass() != Impl.class) {\n+                return super.copy();\n+            }\n+           return new Impl(this);\n         }\n         \n         @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.impl.NoClassDefFoundDeserializer;\n import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.type.*;\n     /**\n      * We will also cache some dynamically constructed deserializers;\n      * specifically, ones that are expensive to construct.\n-     * This currently means bean and Enum deserializers; array, List and Map\n-     * deserializers will not be cached.\n+     * This currently means bean and Enum deserializers; starting with\n+     * 2.5, container deserializers will also be cached.\n      *<p>\n      * Given that we don't expect much concurrency for additions\n      * (should very quickly converge to zero after startup), let's\n-     * explicitly define a low concurrency setting.\n+     * define a relatively low concurrency setting.\n      */\n     final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers\n-        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 2);\n+        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 4);\n \n     /**\n      * During deserializer construction process we may need to keep track of partially\n         if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n             type = factory.mapAbstractType(config, type);\n         }\n-        BeanDescription beanDesc = config.introspect(type);\n+        BeanDescription beanDesc;\n+        try {\n+            beanDesc = config.introspect(type);\n+        } catch (NoClassDefFoundError error) {\n+            return new NoClassDefFoundDeserializer<Object>(error);\n+        }\n         // Then: does type define explicit deserializer to use, with annotation(s)?\n         JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n                 beanDesc.getClassInfo());\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n package com.fasterxml.jackson.databind.deser;\n \n import java.io.IOException;\n-import java.lang.reflect.*;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n      * information. Retained to allow contextualization of any properties.\n      */\n     protected final BeanProperty _property;\n-    \n-    /**\n-     * Physical JDK object used for assigning properties.\n-     *<p>\n-     * NOTE: must be marked transient since it is not serializable,\n-     * in case these are to be serialized\n-     */\n-    protected final transient Method _setter;\n+\n+    /**\n+     * Annotated variant is needed for JDK serialization only\n+     */\n+    final protected AnnotatedMethod _setter;\n \n     protected final JavaType _type;\n \n     public SettableAnyProperty(BeanProperty property, AnnotatedMethod setter, JavaType type,\n             JsonDeserializer<Object> valueDeser, TypeDeserializer typeDeser)\n     {\n-        this(property, setter.getAnnotated(), type, valueDeser, typeDeser);\n-    }\n-\n-    public SettableAnyProperty(BeanProperty property, Method rawSetter, JavaType type,\n-            JsonDeserializer<Object> valueDeser, TypeDeserializer typeDeser)\n-    {\n         _property = property;\n+        _setter = setter;\n         _type = type;\n-        _setter = rawSetter;\n         _valueDeserializer = valueDeser;\n         _valueTypeDeserializer = typeDeser;\n     }\n         return new SettableAnyProperty(_property, _setter, _type,\n                 deser, _valueTypeDeserializer);\n     }\n+\n+    /**\n+     * Constructor used for JDK Serialization when reading persisted object\n+     */\n+    protected SettableAnyProperty(SettableAnyProperty src)\n+    {\n+        _property = src._property;\n+        _setter = src._setter;\n+        _type = src._type;\n+        _valueDeserializer = src._valueDeserializer;\n+        _valueTypeDeserializer = src._valueTypeDeserializer;\n+    }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    // TODO (2.3): handle restoring of reference to any-setter method\n-    \n-/*\n+    /**\n+     * Need to define this to verify that we retain actual Method reference\n+     */\n     Object readResolve() {\n-        return new SettableAnyProperty(this, _annotated.getAnnotated());\n-    }\n-    */\n+        // sanity check...\n+        if (_setter == null || _setter.getAnnotated() == null) {\n+            throw new IllegalArgumentException(\"Missing method (broken JDK (de)serialization?)\");\n+        }\n+        return this;\n+    }\n     \n     /*\n     /**********************************************************\n     public void set(Object instance, String propName, Object value) throws IOException\n     {\n         try {\n-            _setter.invoke(instance, propName, value);\n+            // note: can not use 'setValue()' due to taking 2 args\n+            _setter.getAnnotated().invoke(instance, propName, value);\n         } catch (Exception e) {\n             _throwAsIOE(e, propName, value);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n      * @since 2.0\n      */\n     public abstract Object setAndReturn(Object instance, Object value)\n-            throws IOException;\n+        throws IOException;\n     \n     /**\n      * This method is needed by some specialized bean deserializers,\n      * this method should also not be called directly unless you really know\n      * what you are doing (and probably not even then).\n      */\n-    public final Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayBuilderDeserializer.java\n      */\n \n     protected final Object finishBuild(DeserializationContext ctxt, Object builder)\n-            throws IOException\n+        throws IOException\n     {\n         try {\n             return _buildMethod.getMember().invoke(builder);\n     }\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Let's delegate just in case we got a JSON Object (could error out, alternatively?)\n-        if (jp.getCurrentToken() != JsonToken.START_ARRAY) {\n-            return finishBuild(ctxt, _deserializeFromNonArray(jp, ctxt));\n+        if (!p.isExpectedStartArrayToken()) {\n+            return finishBuild(ctxt, _deserializeFromNonArray(p, ctxt));\n         }\n         if (!_vanillaProcessing) {\n-            return finishBuild(ctxt, _deserializeNonVanilla(jp, ctxt));\n+            return finishBuild(ctxt, _deserializeNonVanilla(p, ctxt));\n         }\n         Object builder = _valueInstantiator.createUsingDefault(ctxt);\n         final SettableBeanProperty[] props = _orderedProperties;\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return finishBuild(ctxt, builder);\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, builder, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return finishBuild(ctxt, builder);\n     }\n \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object builder)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object builder)\n+        throws IOException\n     {\n         /* No good way to verify that we have an array... although could I guess\n          * check via JsonParser. So let's assume everything is working fine, for now.\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return finishBuild(ctxt, builder);\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, builder, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return finishBuild(ctxt, builder);\n     }\n \n     // needed since 2.1\n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-    {\n-        return _deserializeFromNonArray(jp, ctxt);\n+    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException\n+    {\n+        return _deserializeFromNonArray(p, ctxt);\n     }\n     \n     /*\n      * \n      * @return Builder object in use.\n      */\n-    protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeNonVanilla(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_nonStandardCreation) {\n-            return _deserializeWithCreator(jp, ctxt);\n+            return _deserializeWithCreator(p, ctxt);\n         }\n         Object builder = _valueInstantiator.createUsingDefault(ctxt);\n         if (_injectables != null) {\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return builder;\n             }\n             if (i == propCount) {\n             if (prop != null) { // normal case\n                 if (activeView == null || prop.visibleInView(activeView)) {\n                     try {\n-                        prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                        prop.deserializeSetAndReturn(p, ctxt, builder);\n                     } catch (Exception e) {\n                         wrapAndThrow(e, builder, prop.getName(), ctxt);\n                     }\n                 }\n             }\n             // otherwise, skip it (view-filtered, no prop etc)\n-            jp.skipChildren();\n+            p.skipChildren();\n         }\n         // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n         if (!_ignoreAllUnknown) {\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return builder;\n     }\n     \n-    protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeWithCreator(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {        \n         if (_delegateDeserializer != null) {\n             return _valueInstantiator.createUsingDelegate(ctxt,\n-                    _delegateDeserializer.deserialize(jp, ctxt));\n+                    _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n-            return _deserializeUsingPropertyBased(jp, ctxt);\n+            return _deserializeUsingPropertyBased(p, ctxt);\n         }\n         // should only occur for abstract types...\n         if (_beanType.isAbstract()) {\n-            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+            throw JsonMappingException.from(p, \"Can not instantiate abstract type \"+_beanType\n                     +\" (need to add/enable type information?)\");\n         }\n-        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+        throw JsonMappingException.from(p, \"No suitable constructor found for type \"\n                 +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n     }\n \n      * as well.\n      */\n     @Override\n-    protected final Object _deserializeUsingPropertyBased(final JsonParser jp,\n+    protected final Object _deserializeUsingPropertyBased(final JsonParser p,\n             final DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n \n         final SettableBeanProperty[] props = _orderedProperties;\n         final int propCount = props.length;\n         int i = 0;\n         Object builder = null;\n         \n-        for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) {\n+        for (; p.nextToken() != JsonToken.END_ARRAY; ++i) {\n             SettableBeanProperty prop = (i < propCount) ? props[i] : null;\n             if (prop == null) { // we get null if there are extra elements; maybe otherwise too?\n-                jp.skipChildren();\n+                p.skipChildren();\n                 continue;\n             }\n             // if we have already constructed POJO, things are simple:\n             if (builder != null) {\n                 try {\n-                    builder = prop.deserializeSetAndReturn(jp, ctxt, builder);\n+                    builder = prop.deserializeSetAndReturn(p, ctxt, builder);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, builder, prop.getName(), ctxt);\n                 }\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                     try {\n                         builder = creator.build(ctxt, buffer);\n                 continue;\n             }\n             // regular property? needs buffering\n-            buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n         }\n \n         // In case we didn't quite get all the creator properties, we may have to do this:\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanAsArrayDeserializer.java\n import java.util.HashSet;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n      */\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Let's delegate just in case we got a JSON Object (could error out, alternatively?)\n-        if (jp.getCurrentToken() != JsonToken.START_ARRAY) {\n-            return _deserializeFromNonArray(jp, ctxt);\n+        if (!p.isExpectedStartArrayToken()) {\n+            return _deserializeFromNonArray(p, ctxt);\n         }\n         if (!_vanillaProcessing) {\n-            return _deserializeNonVanilla(jp, ctxt);\n+            return _deserializeNonVanilla(p, ctxt);\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n+\n         final SettableBeanProperty[] props = _orderedProperties;\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return bean;\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return bean;\n     }\n \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt, Object bean)\n+        throws IOException\n+    {\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n         /* No good way to verify that we have an array... although could I guess\n          * check via JsonParser. So let's assume everything is working fine, for now.\n          */\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return bean;\n             }\n             if (i == propCount) {\n             SettableBeanProperty prop = props[i];\n             if (prop != null) { // normal case\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, prop.getName(), ctxt);\n                 }\n             } else { // just skip?\n-                jp.skipChildren();\n+                p.skipChildren();\n             }\n             ++i;\n         }\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return bean;\n     }\n \n     // needed since 2.1\n     @Override\n-    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-    {\n-        return _deserializeFromNonArray(jp, ctxt);\n+    public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        return _deserializeFromNonArray(p, ctxt);\n     }\n     \n     /*\n      * Alternate deserialization method that has to check many more configuration\n      * aspects than the \"vanilla\" processing.\n      */\n-    protected Object _deserializeNonVanilla(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeNonVanilla(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_nonStandardCreation) {\n-            return _deserializeWithCreator(jp, ctxt);\n+            return _deserializeWithCreator(p, ctxt);\n         }\n         final Object bean = _valueInstantiator.createUsingDefault(ctxt);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(bean);\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         int i = 0;\n         final int propCount = props.length;\n         while (true) {\n-            if (jp.nextToken() == JsonToken.END_ARRAY) {\n+            if (p.nextToken() == JsonToken.END_ARRAY) {\n                 return bean;\n             }\n             if (i == propCount) {\n             if (prop != null) { // normal case\n                 if (activeView == null || prop.visibleInView(activeView)) {\n                     try {\n-                        prop.deserializeAndSet(jp, ctxt, bean);\n+                        prop.deserializeAndSet(p, ctxt, bean);\n                     } catch (Exception e) {\n                         wrapAndThrow(e, bean, prop.getName(), ctxt);\n                     }\n                 }\n             }\n             // otherwise, skip it (view-filtered, no prop etc)\n-            jp.skipChildren();\n+            p.skipChildren();\n         }\n         // Ok; extra fields? Let's fail, unless ignoring extra props is fine\n         if (!_ignoreAllUnknown) {\n             throw ctxt.mappingException(\"Unexpected JSON values; expected at most \"+propCount+\" properties (in JSON Array)\");\n         }\n         // otherwise, skip until end\n-        while (jp.nextToken() != JsonToken.END_ARRAY) {\n-            jp.skipChildren();\n+        while (p.nextToken() != JsonToken.END_ARRAY) {\n+            p.skipChildren();\n         }\n         return bean;\n     }\n     \n-    protected Object _deserializeWithCreator(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected Object _deserializeWithCreator(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {        \n         if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(p, ctxt));\n         }\n         if (_propertyBasedCreator != null) {\n-            return _deserializeUsingPropertyBased(jp, ctxt);\n+            return _deserializeUsingPropertyBased(p, ctxt);\n         }\n         // should only occur for abstract types...\n         if (_beanType.isAbstract()) {\n-            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+            throw JsonMappingException.from(p, \"Can not instantiate abstract type \"+_beanType\n                     +\" (need to add/enable type information?)\");\n         }\n-        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+        throw JsonMappingException.from(p, \"No suitable constructor found for type \"\n                 +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n     }\n \n      * as well.\n      */\n     @Override\n-    protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    protected final Object _deserializeUsingPropertyBased(final JsonParser p, final DeserializationContext ctxt)\n+        throws IOException\n     {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n-        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n+        PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n \n         final SettableBeanProperty[] props = _orderedProperties;\n         final int propCount = props.length;\n         int i = 0;\n         Object bean = null;\n         \n-        for (; jp.nextToken() != JsonToken.END_ARRAY; ++i) {\n+        for (; p.nextToken() != JsonToken.END_ARRAY; ++i) {\n             SettableBeanProperty prop = (i < propCount) ? props[i] : null;\n             if (prop == null) { // we get null if there are extra elements; maybe otherwise too?\n-                jp.skipChildren();\n+                p.skipChildren();\n                 continue;\n             }\n             // if we have already constructed POJO, things are simple:\n             if (bean != null) {\n                 try {\n-                    prop.deserializeAndSet(jp, ctxt, bean);\n+                    prop.deserializeAndSet(p, ctxt, bean);\n                 } catch (Exception e) {\n                     wrapAndThrow(e, bean, prop.getName(), ctxt);\n                 }\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // Last creator property to set?\n-                Object value = creatorProp.deserialize(jp, ctxt);\n+                Object value = creatorProp.deserialize(p, ctxt);\n                 if (buffer.assignParameter(creatorProp.getCreatorIndex(), value)) {\n                     try {\n                         bean = creator.build(ctxt, buffer);\n                         wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n                         continue; // never gets here\n                     }\n+                    // [databind#631]: Assign current value, to be accessible by custom serializers\n+                    p.setCurrentValue(bean);\n+                    \n                     //  polymorphic?\n                     if (bean.getClass() != _beanType.getRawClass()) {\n                         /* 23-Jul-2012, tatu: Not sure if these could ever be properly\n                 continue;\n             }\n             // regular property? needs buffering\n-            buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+            buffer.bufferProperty(prop, prop.deserialize(p, ctxt));\n         }\n \n         // In case we didn't quite get all the creator properties, we may have to do this:\n     /**********************************************************\n      */\n \n-    protected Object _deserializeFromNonArray(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+    protected Object _deserializeFromNonArray(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Let's start with failure\n         throw ctxt.mappingException(\"Can not deserialize a POJO (of type \"+_beanType.getRawClass().getName()\n-                +\") from non-Array representation (token: \"+jp.getCurrentToken()\n+                +\") from non-Array representation (token: \"+p.getCurrentToken()\n                 +\"): type/property designed to be serialized as JSON Array\");\n         // in future, may allow use of \"standard\" POJO serialization as well; if so, do:\n         //return _delegate.deserialize(jp, ctxt);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n package com.fasterxml.jackson.databind.deser.impl;\n \n+import java.io.IOException;\n import java.util.*;\n \n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n     }\n \n     /**\n+     * @since 2.5\n+     */\n+    public boolean findDeserializeAndSet(JsonParser p, DeserializationContext ctxt,\n+            Object bean, String key) throws IOException\n+    {\n+        int index = key.hashCode() & _hashMask;\n+        Bucket bucket = _buckets[index];\n+        // Let's unroll first lookup since that is null or match in 90+% cases\n+        if (bucket == null) {\n+            return false;\n+        }\n+        // Primarily we do just identity comparison as keys should be interned\n+        if (bucket.key == key) {\n+            bucket.value.deserializeAndSet(p, ctxt, bean);\n+            return true;\n+        }\n+        return _findDeserializeAndSet2(p, ctxt, bean, key, index);\n+    }\n+\n+    private final boolean _findDeserializeAndSet2(JsonParser p, DeserializationContext ctxt,\n+            Object bean, String key, int index) throws IOException\n+    {\n+        Bucket bucket = _buckets[index];\n+        while ((bucket = bucket.next) != null) {\n+            if (bucket.key == key) {\n+                bucket.value.deserializeAndSet(p, ctxt, bean);\n+                return true;\n+            }\n+        }\n+        SettableBeanProperty prop = _findWithEquals(key, index);\n+        if (prop == null) {\n+            return false;\n+        }\n+        prop.deserializeAndSet(p, ctxt, bean);\n+        return true;\n+    }\n+\n+    /**\n      * @since 2.3\n      */\n     public SettableBeanProperty find(int propertyIndex)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n      */\n     public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt,\n             String propName, Object bean)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         Integer I = _nameToPropertyIndex.get(propName);\n         if (I == null) {\n      * @return True, if the given property was properly handled\n      */\n     public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt,\n-            String propName, Object bean)\n-        throws IOException, JsonProcessingException\n+            String propName, Object bean) throws IOException\n     {\n         Integer I = _nameToPropertyIndex.get(propName);\n         if (I == null) {\n     \n     @SuppressWarnings(\"resource\")\n     public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         for (int i = 0, len = _properties.length; i < len; ++i) {\n             String typeId = _typeIds[i];\n      */\n     public Object complete(JsonParser jp, DeserializationContext ctxt,\n             PropertyValueBuffer buffer, PropertyBasedCreator creator)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // first things first: deserialize all data buffered:\n         final int len = _properties.length;\n \n     @SuppressWarnings(\"resource\")\n     protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt,\n-            int index, String typeId)\n-        throws IOException, JsonProcessingException\n+            int index, String typeId) throws IOException\n     {\n         TokenBuffer merged = new TokenBuffer(jp);\n         merged.writeStartArray();\n \n     @SuppressWarnings(\"resource\")\n     protected final void _deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-            Object bean, int index, String typeId)\n-        throws IOException, JsonProcessingException\n+            Object bean, int index, String typeId) throws IOException\n     {\n         /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n          * style to ensure we can handle all kinds of JSON constructs.\n         p2.nextToken();\n         merged.copyCurrentStructure(p2);\n         merged.writeEndArray();\n-        \n         // needs to point to START_OBJECT (or whatever first token is)\n         p2 = merged.asParser(jp);\n         p2.nextToken();\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/NoClassDefFoundDeserializer.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+\n+/**\n+ * A deserializer that stores a {@link NoClassDefFoundError} error\n+ * and throws the stored exception when attempting to deserialize\n+ * a value. Null and empty values can be deserialized without error.\n+ */\n+public class NoClassDefFoundDeserializer<T> extends JsonDeserializer<T>\n+{\n+    private final NoClassDefFoundError _cause;\n+\n+    public NoClassDefFoundDeserializer(NoClassDefFoundError cause)\n+    {\n+        _cause = cause;\n+    }\n+\n+    @Override\n+    public T deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        throw _cause;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.annotation.SimpleObjectIdResolver;\n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n \n      */\n     public final ObjectIdGenerator<?> generator;\n \n-    /**\n-     * \n-     */\n     public final ObjectIdResolver resolver;\n \n     /**\n         this(t,propName, gen, deser, idProp, new SimpleObjectIdResolver());\n     }\n \n-    @Deprecated // since 2.3\n-    protected ObjectIdReader(JavaType t, String propName, ObjectIdGenerator<?> gen,\n-            JsonDeserializer<?> deser, SettableBeanProperty idProp)\n-    {\n-        this(t, new PropertyName(propName), gen, deser, idProp);\n-    }\n-\n     /**\n      * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n      * with the initial information based on standard settings for the type\n     {\n         return construct(idType, propName, generator, deser, idProp, new SimpleObjectIdResolver());\n     }\n-    \n-    @Deprecated // since 2.3\n-    public static ObjectIdReader construct(JavaType idType, String propName,\n-            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n-            SettableBeanProperty idProp)\n-    {\n-        return construct(idType, new PropertyName(propName), generator, deser, idProp);\n-    }\n \n     /*\n     /**********************************************************\n     public JavaType getIdType() {\n         return _idType;\n     }\n+\n+    /**\n+     * Convenience method, equivalent to calling:\n+     *<code>\n+     *  readerInstance.generator.maySerializeAsObject();\n+     *</code>\n+     * and used to determine whether Object Ids handled by the underlying\n+     * generator may be in form of (JSON) Objects.\n+     * Used for optimizing handling in cases where method returns false.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean maySerializeAsObject() {\n+        return generator.maySerializeAsObject();\n+    }\n+\n+    /**\n+     * Convenience method, equivalent to calling:\n+     *<code>\n+     *  readerInstance.generator.isValidReferencePropertyName(name, parser);\n+     *</code>\n+     * and used to determine whether Object Ids handled by the underlying\n+     * generator may be in form of (JSON) Objects.\n+     * Used for optimizing handling in cases where method returns false.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isValidReferencePropertyName(String name, JsonParser parser) {\n+        return generator.isValidReferencePropertyName(name, parser);\n+    }\n     \n     /**\n      * Method called to read value that is expected to be an Object Reference\n      * \n      * @since 2.3\n      */\n-    public Object readObjectReference(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object readObjectReference(JsonParser jp, DeserializationContext ctxt) throws IOException {\n         return _deserializer.deserialize(jp, ctxt);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n import java.lang.annotation.Annotation;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.PropertyName;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\n import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n \n public class ObjectIdReferenceProperty extends SettableBeanProperty {\n-    private static final long serialVersionUID = 8465266677345565407L;\n-    private SettableBeanProperty _forward;\n+    private static final long serialVersionUID = 1L;\n+\n+    private final SettableBeanProperty _forward;\n \n     public ObjectIdReferenceProperty(SettableBeanProperty forward, ObjectIdInfo objectIdInfo)\n     {\n     }\n \n     @Override\n-    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance)\n-        throws IOException, JsonProcessingException\n-    {\n+    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n         deserializeSetAndReturn(jp, ctxt, instance);\n     }\n \n     @Override\n     public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n-        boolean usingIdentityInfo = (_objectIdInfo != null) || (_valueDeserializer.getObjectIdReader() != null);\n         try {\n             return setAndReturn(instance, deserialize(jp, ctxt));\n         } catch (UnresolvedForwardReference reference) {\n+            boolean usingIdentityInfo = (_objectIdInfo != null) || (_valueDeserializer.getObjectIdReader() != null);\n             if (!usingIdentityInfo) {\n                 throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdValueProperty.java\n \n     protected final ObjectIdReader _objectIdReader;\n \n-    @Deprecated // since 2.2\n-    public ObjectIdValueProperty(ObjectIdReader objectIdReader) {\n-        this(objectIdReader, PropertyMetadata.STD_REQUIRED);\n-    }\n-    \n     public ObjectIdValueProperty(ObjectIdReader objectIdReader,\n             PropertyMetadata metadata)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n     /**\n      * Helper method called to handle Object Id value collected earlier, if any\n      */\n-    public Object handleIdValue(final DeserializationContext ctxt, Object bean)\n-        throws IOException\n+    public Object handleIdValue(final DeserializationContext ctxt, Object bean) throws IOException\n     {\n         if (_objectIdReader != null) {\n             if (_idValue != null) {\n                 }\n             } else {\n                 // TODO: is this an error case?\n+                throw ctxt.mappingException(\"No _idValue when handleIdValue called, on instance of \"\n+                        +bean.getClass().getName());\n             }\n         }\n         return bean;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java\n \n         // For [#501] fix we need to implement this but:\n         if (_valueTypeDeserializer != null) {\n-            throw new JsonMappingException(\"Problem deserializing 'setterless' property: no way to handle typed deser with setterless yet\");\n+            throw new JsonMappingException(\"Problem deserializing 'setterless' property (\\\"\"+getName()+\"\\\"): no way to handle typed deser with setterless yet\");\n //            return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer);\n         }\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/TypeWrappedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/TypeWrappedDeserializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n /**\n  */\n public final class TypeWrappedDeserializer\n     extends JsonDeserializer<Object>\n+    implements java.io.Serializable // since 2.5\n {\n-    final TypeDeserializer _typeDeserializer;\n-    final JsonDeserializer<Object> _deserializer;\n+    private static final long serialVersionUID = 1L;\n \n-    public TypeWrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<Object> deser)\n+    final protected TypeDeserializer _typeDeserializer;\n+    final protected JsonDeserializer<Object> _deserializer;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public TypeWrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<?> deser)\n     {\n         super();\n         _typeDeserializer = typeDeser;\n-        _deserializer = deser;\n+        _deserializer = (JsonDeserializer<Object>) deser;\n     }\n \n     @Override\n     }\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         return _deserializer.deserializeWithType(jp, ctxt, _typeDeserializer);\n     }\n \n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-        TypeDeserializer typeDeserializer)\n-            throws IOException, JsonProcessingException\n+        TypeDeserializer typeDeserializer) throws IOException\n     {\n         // should never happen? (if it can, could call on that object)\n         throw new IllegalStateException(\"Type-wrapped deserializer's deserializeWithType should never get called\");\n \n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt,\n-            Object intoValue)\n-        throws IOException, JsonProcessingException\n+            Object intoValue) throws IOException\n     {\n         /* 01-Mar-2013, tatu: Hmmh. Tough call as to what to do... need\n          *   to delegate, but will this work reliably? Let's just hope so:\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n     extends ContainerDeserializerBase<Collection<Object>>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = 3917273725180652224L;\n+    private static final long serialVersionUID = -1L; // since 2.5\n \n     // // Configuration\n \n                 (JsonDeserializer<Object>) vd, vtd,\n                 _valueInstantiator, (JsonDeserializer<Object>) dd);\n     }\n-    \n+\n+    // Important: do NOT cache if polymorphic values\n+    @Override // since 2.5\n+    public boolean isCachable() {\n+        return (_valueTypeDeserializer == null);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Validation, post-processing (ResolvableDeserializer)\n     \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n         if (_delegateDeserializer != null) {\n             return (Collection<Object>) _valueInstantiator.createUsingDelegate(ctxt,\n-                    _delegateDeserializer.deserialize(jp, ctxt));\n+                    _delegateDeserializer.deserialize(p, ctxt));\n         }\n         /* [JACKSON-620]: empty String may be ok; bit tricky to check, however, since\n          *  there is also possibility of \"auto-wrapping\" of single-element arrays.\n          *  Hence we only accept empty String here.\n          */\n-        if (jp.getCurrentToken() == JsonToken.VALUE_STRING) {\n-            String str = jp.getText();\n+        if (p.getCurrentToken() == JsonToken.VALUE_STRING) {\n+            String str = p.getText();\n             if (str.length() == 0) {\n                 return (Collection<Object>) _valueInstantiator.createFromString(ctxt, str);\n             }\n         }\n-        return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));\n-    }\n-\n-    @Override\n-    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+        return deserialize(p, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault(ctxt));\n+    }\n+\n+    @Override\n+    public Collection<Object> deserialize(JsonParser p, DeserializationContext ctxt,\n             Collection<Object> result)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // Ok: must point to START_ARRAY (or equivalent)\n-        if (!jp.isExpectedStartArrayToken()) {\n-            return handleNonArray(jp, ctxt, result);\n-        }\n+        if (!p.isExpectedStartArrayToken()) {\n+            return handleNonArray(p, ctxt, result);\n+        }\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(result);\n \n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n                 new CollectionReferringAccumulator(_collectionType.getContentType().getRawClass(), result);\n \n         JsonToken t;\n-        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+        while ((t = p.nextToken()) != JsonToken.END_ARRAY) {\n             try {\n                 Object value;\n                 if (t == JsonToken.VALUE_NULL) {\n                     value = valueDes.getNullValue();\n                 } else if (typeDeser == null) {\n-                    value = valueDes.deserialize(jp, ctxt);\n+                    value = valueDes.deserialize(p, ctxt);\n                 } else {\n-                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                    value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n                 }\n                 if (referringAccumulator != null) {\n                     referringAccumulator.add(value);\n             } catch (UnresolvedForwardReference reference) {\n                 if (referringAccumulator == null) {\n                     throw JsonMappingException\n-                            .from(jp, \"Unresolved forward reference but no identity info\", reference);\n+                            .from(p, \"Unresolved forward reference but no identity info\", reference);\n                 }\n                 Referring ref = referringAccumulator.handleUnresolvedReference(reference);\n                 reference.getRoid().appendReferring(ref);\n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // In future could check current token... for now this should be enough:\n         return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n      * throw an exception, or try to handle value as if member of implicit\n      * array, depending on configuration.\n      */\n-    protected final Collection<Object> handleNonArray(JsonParser jp, DeserializationContext ctxt,\n+    protected final Collection<Object> handleNonArray(JsonParser p, DeserializationContext ctxt,\n             Collection<Object> result)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // [JACKSON-526]: implicit arrays from single values?\n         if (!ctxt.isEnabled(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n         }\n         JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n \n         Object value;\n \n             if (t == JsonToken.VALUE_NULL) {\n                 value = valueDes.getNullValue();\n             } else if (typeDeser == null) {\n-                value = valueDes.deserialize(jp, ctxt);\n+                value = valueDes.deserialize(p, ctxt);\n             } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                value = valueDes.deserializeWithType(p, ctxt, typeDeser);\n             }\n         } catch (Exception e) {\n             // note: pass Object.class, not Object[].class, as we need element type for error info\n         private final CollectionReferringAccumulator _parent;\n         public final List<Object> next = new ArrayList<Object>();\n         \n-        private CollectionReferring(CollectionReferringAccumulator parent,\n+        CollectionReferring(CollectionReferringAccumulator parent,\n                 UnresolvedForwardReference reference, Class<?> contentType)\n         {\n             super(reference, contentType);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n     /* Overrides\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public SettableBeanProperty findBackReference(String refName) {\n         JsonDeserializer<Object> valueDeser = getContentDeserializer();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n import java.lang.reflect.Method;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n \n public class EnumDeserializer\n     extends StdScalarDeserializer<Enum<?>>\n {\n-    private static final long serialVersionUID = -5893263645879532318L;\n+    private static final long serialVersionUID = 1L;\n \n     protected final EnumResolver<?> _resolver;\n     \n     {\n         // note: caller has verified there's just one arg; but we must verify its type\n         Class<?> paramClass = factory.getRawParameterType(0);\n-        if (paramClass == String.class) {\n-            paramClass = null;\n-        } else  if (paramClass == Integer.TYPE || paramClass == Integer.class) {\n-            paramClass = Integer.class;\n-        } else  if (paramClass == Long.TYPE || paramClass == Long.class) {\n-            paramClass = Long.class;\n-        } else {\n-            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory\n-                    +\") not suitable, must be java.lang.String or int/Integer/long/Long\");\n-        }\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(factory.getMember());\n         }\n      * for locating Enum values by String id.\n      */\n     protected static class FactoryBasedDeserializer\n-        extends StdScalarDeserializer<Object>\n-    {\n-        private static final long serialVersionUID = -7775129435872564122L;\n-\n-        protected final Class<?> _enumClass;\n+        extends StdDeserializer<Object>\n+        implements ContextualDeserializer\n+    {\n+        private static final long serialVersionUID = 1;\n+\n         // Marker type; null if String expected; otherwise numeric wrapper\n         protected final Class<?> _inputType;\n         protected final Method _factory;\n+        protected final JsonDeserializer<?> _deser;\n         \n         public FactoryBasedDeserializer(Class<?> cls, AnnotatedMethod f,\n                 Class<?> inputType)\n         {\n-            super(Enum.class);\n-            _enumClass = cls;\n+            super(cls);\n             _factory = f.getAnnotated();\n             _inputType = inputType;\n-        }\n-\n+            _deser = null;\n+        }\n+\n+        protected FactoryBasedDeserializer(FactoryBasedDeserializer base,\n+                JsonDeserializer<?> deser) {\n+            super(base._valueClass);\n+            _inputType = base._inputType;\n+            _factory = base._factory;\n+            _deser = deser;\n+        }\n+        \n         @Override\n-        public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+                BeanProperty property)\n+            throws JsonMappingException\n         {\n-            // couple of accepted types...\n+            if ((_deser == null) && (_inputType != String.class)) {\n+                return new FactoryBasedDeserializer(this,\n+                        ctxt.findContextualValueDeserializer(ctxt.constructType(_inputType), property));\n+            }\n+            return this;\n+        }\n+        \n+        @Override\n+        public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        {\n             Object value;\n-            if (_inputType == null) {\n-                value = jp.getText();\n-            } else  if (_inputType == Integer.class) {\n-                value = Integer.valueOf(jp.getValueAsInt());\n-            } else  if (_inputType == Long.class) {\n-                value = Long.valueOf(jp.getValueAsLong());\n+            if (_deser != null) {\n+                value = _deser.deserialize(jp, ctxt);\n             } else {\n-                throw ctxt.mappingException(_enumClass);\n+                value = jp.getValueAsString();\n             }\n             try {\n-                return _factory.invoke(_enumClass, value);\n+                return _factory.invoke(_valueClass, value);\n             } catch (Exception e) {\n                 Throwable t = ClassUtil.getRootCause(e);\n                 if (t instanceof IOException) {\n                     throw (IOException) t;\n                 }\n-                throw ctxt.instantiationException(_enumClass, t);\n-            }\n+                throw ctxt.instantiationException(_valueClass, t);\n+            }\n+        }\n+\n+        @Override\n+        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n+            if (_deser == null) { // String never has type info\n+                return deserialize(jp, ctxt);\n+            }\n+            return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n     \n     protected final Class<?> _enumClass;\n \n-    protected JsonDeserializer<Enum<?>> _keyDeserializer;\n+    protected KeyDeserializer _keyDeserializer;\n \n     protected JsonDeserializer<Object> _valueDeserializer;\n \n     /**********************************************************\n      */\n \n-    public EnumMapDeserializer(JavaType mapType, JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser, TypeDeserializer valueTypeDeser)\n+    public EnumMapDeserializer(JavaType mapType, KeyDeserializer keyDeserializer, JsonDeserializer<?> valueDeser, TypeDeserializer valueTypeDeser)\n     {\n         super(mapType);\n         _mapType = mapType;\n         _enumClass = mapType.getKeyType().getRawClass();\n-        _keyDeserializer = (JsonDeserializer<Enum<?>>) keyDeserializer;\n+        _keyDeserializer = keyDeserializer;\n         _valueDeserializer = (JsonDeserializer<Object>) valueDeser;\n         _valueTypeDeserializer = valueTypeDeser;\n     }\n \n-    public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n+    public EnumMapDeserializer withResolved(KeyDeserializer keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n     {\n         if ((keyDeserializer == _keyDeserializer) && (valueDeserializer == _valueDeserializer) && (valueTypeDeser == _valueTypeDeserializer)) {\n             return this;\n         // note: instead of finding key deserializer, with enums we actually\n         // work with regular deserializers (less code duplication; but not\n         // quite as clean as it ought to be)\n-        JsonDeserializer<?> kd = _keyDeserializer;\n+        KeyDeserializer kd = _keyDeserializer;\n         if (kd == null) {\n-            kd = ctxt.findContextualValueDeserializer(_mapType.getKeyType(), property);\n+            kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property);\n         }\n         JsonDeserializer<?> vd = _valueDeserializer;\n         if (vd == null) {\n      * let's cache instances by default.\n      */\n     @Override\n-    public boolean isCachable() { return true; }\n+    public boolean isCachable() {\n+        // Important: do NOT cache if polymorphic values\n+        return (_valueTypeDeserializer == null);\n+    }\n \n     /*\n     /**********************************************************\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n \n-        while ((jp.nextToken()) != JsonToken.END_OBJECT) {\n+        while ((jp.nextToken()) == JsonToken.FIELD_NAME) {\n             String keyName = jp.getCurrentName(); // just for error message\n             // but we need to let key deserializer handle it separately, nonetheless\n-            Enum<?> key = _keyDeserializer.deserialize(jp, ctxt);\n+            Enum<?> key = (Enum<?>) _keyDeserializer.deserializeKey(keyName, ctxt);\n             if (key == null) {\n                 if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-                    String value = null;\n-                    try { // bit ugly, but will have to do; works with usual scalars\n-                        if (jp.hasCurrentToken()) {\n-                            value = jp.getText();\n-                        }\n-                    } catch (Exception e) { }\n-                    throw ctxt.weirdStringException(value, _enumClass, \"value not one of declared Enum instance names\");\n+                    throw ctxt.weirdStringException(keyName, _enumClass, \"value not one of declared Enum instance names for \"\n+                            +_mapType.getKeyType());\n                 }\n                 /* 24-Mar-2012, tatu: Null won't work as a key anyway, so let's\n                  *  just skip the entry then. But we must skip the value as well, if so.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n     extends StdDeserializer<EnumSet<?>>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = 3479455075597887177L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     protected final JavaType _enumType;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n             }\n             String msg = \"not a valid textual representation\";\n             if (cause != null) {\n-                msg += \"problem: \"+cause.getMessage();\n+                String m2 = cause.getMessage();\n+                if (m2 != null) {\n+                    msg = msg + \", problem: \"+m2;\n+                }\n             }\n             JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n             if (cause != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n     public BaseNodeDeserializer(Class<T> vc) {\n         super(vc);\n     }\n-    \n+\n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n         return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n     }\n \n+    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes\n+     *   sense to also mark this is cachable, since lookup not exactly free, and\n+     *   since it's not uncommon to \"read anything\"\n+     */\n+    @Override\n+    public boolean isCachable() { return true; }\n+\n     /*\n     /**********************************************************\n     /* Overridable methods\n     /**********************************************************\n      */\n-    \n+\n     protected void _reportProblem(JsonParser jp, String msg) throws JsonMappingException {\n         throw new JsonMappingException(msg, jp.getTokenLocation());\n     }\n-    \n+\n     /**\n      * \n      * @deprecated Since 2.3, use the overloaded variant\n         // Backwards-compatibility; call in case it's overloaded\n         _handleDuplicateField(fieldName, objectNode, oldValue, newValue);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Helper methods\n     /**********************************************************\n      */\n-    \n+\n     protected final ObjectNode deserializeObject(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)            \n-        throws IOException, JsonProcessingException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         ObjectNode node = nodeFactory.objectNode();\n         JsonToken t = jp.getCurrentToken();\n         }\n         return node;\n     }\n-    \n+\n     protected final ArrayNode deserializeArray(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)            \n-        throws IOException, JsonProcessingException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         ArrayNode node = nodeFactory.arrayNode();\n         while (true) {\n             }\n         }\n     }\n-    \n+\n     protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)            \n-        throws IOException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         switch (jp.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n     }\n \n     protected final JsonNode _fromInt(JsonParser jp, DeserializationContext ctxt,\n-            JsonNodeFactory nodeFactory)\n-        throws IOException\n+            JsonNodeFactory nodeFactory) throws IOException\n     {\n         JsonParser.NumberType nt = jp.getNumberType();\n         if (nt == JsonParser.NumberType.BIG_INTEGER\n     }\n \n     protected final JsonNode _fromFloat(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)\n-        throws IOException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         JsonParser.NumberType nt = jp.getNumberType();\n         if (nt == JsonParser.NumberType.BIG_DECIMAL\n     }\n \n     protected final JsonNode _fromEmbedded(JsonParser jp, DeserializationContext ctxt,\n-            JsonNodeFactory nodeFactory)\n-        throws IOException\n+            JsonNodeFactory nodeFactory) throws IOException\n     {\n         // [JACKSON-796]\n         Object ob = jp.getEmbeddedObject();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n     extends ContainerDeserializerBase<Map<Object,Object>>\n     implements ContextualDeserializer, ResolvableDeserializer\n {\n-    private static final long serialVersionUID = -3378654289961736240L;\n+    private static final long serialVersionUID = 1L;\n \n     // // Configuration: typing, deserializers\n \n         return ((rawKeyType == String.class || rawKeyType == Object.class)\n                 && isDefaultKeyDeserializer(keyDeser));\n     }\n-    \n+\n     public void setIgnorableProperties(String[] ignorable) {\n         _ignorableProperties = (ignorable == null || ignorable.length == 0) ?\n             null : ArrayBuilders.arrayToSet(ignorable);\n     /**********************************************************\n      */\n \n+    /**\n+     * Turns out that these are expensive enough to create so that caching\n+     * does make sense.\n+     *<p>\n+     * IMPORTANT: but, note, that instances CAN NOT BE CACHED if there is\n+     * a value type deserializer; this caused an issue with 2.4.4 of\n+     * JAXB Annotations (failing a test).\n+     * It is also possible that some other settings could make deserializers\n+     * un-cacheable; but on the other hand, caching can make a big positive\n+     * difference with performance... so it's a hard choice.\n+     * \n+     * @since 2.4.4\n+     */\n+    @Override\n+    public boolean isCachable() {\n+        return (_valueTypeDeserializer == null) && (_ignorableProperties == null);\n+    }\n+\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n     }\n \n     @Override\n-    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+    public Map<Object,Object> deserialize(JsonParser p, DeserializationContext ctxt,\n             Map<Object,Object> result)\n-        throws IOException, JsonProcessingException\n-    {\n+        throws IOException\n+    {\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        p.setCurrentValue(result);\n+        \n         // Ok: must point to START_OBJECT or FIELD_NAME\n-        JsonToken t = jp.getCurrentToken();\n+        JsonToken t = p.getCurrentToken();\n         if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n             throw ctxt.mappingException(getMapClass());\n         }\n         if (_standardStringKey) {\n-            _readAndBindStringMap(jp, ctxt, result);\n+            _readAndBindStringMap(p, ctxt, result);\n             return result;\n         }\n-        _readAndBind(jp, ctxt, result);\n+        _readAndBind(p, ctxt, result);\n         return result;\n     }\n \n             }\n         }\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\") \n     public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n         wrapAndThrow(t, ref, null);\n     }\n \n-    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator, Object key,\n-            UnresolvedForwardReference reference)\n+    private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator,\n+            Object key, UnresolvedForwardReference reference)\n         throws JsonMappingException\n     {\n         if (accumulator == null) {\n         reference.getRoid().appendReferring(referring);\n     }\n \n-    private final static class MapReferringAccumulator  {\n+    private final static class MapReferringAccumulator {\n         private final Class<?> _valueType;\n         private Map<Object,Object> _result;\n         /**\n      * object associated with {@link #_id} comes before the values in\n      * {@link _next}.\n      */\n-    private final static class MapReferring extends Referring {\n+    final static class MapReferring extends Referring {\n         private final MapReferringAccumulator _parent;\n \n         public final Map<Object, Object> next = new LinkedHashMap<Object, Object>();\n         public final Object key;\n         \n-        private MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n+        MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n                 Class<?> valueType, Object key)\n         {\n             super(ref, valueType);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapEntryDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapEntryDeserializer.java\n     /**\n      * Key deserializer to use; either passed via constructor\n      * (when indicated by annotations), or resolved when\n-     * {@link #resolve} is called;\n+     * {@link #createContextual} is called;\n      */\n     protected final KeyDeserializer _keyDeserializer;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.class, Boolean.FALSE);\n-        private final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.TYPE, null);\n+        final static BooleanDeserializer primitiveInstance = new BooleanDeserializer(Boolean.class, Boolean.FALSE);\n+        final static BooleanDeserializer wrapperInstance = new BooleanDeserializer(Boolean.TYPE, null);\n         \n         public BooleanDeserializer(Class<Boolean> cls, Boolean nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0);\n-        private final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null);\n+        final static ByteDeserializer primitiveInstance = new ByteDeserializer(Byte.TYPE, (byte) 0);\n+        final static ByteDeserializer wrapperInstance = new ByteDeserializer(Byte.class, null);\n         \n         public ByteDeserializer(Class<Byte> cls, Byte nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.class, Short.valueOf((short)0));\n-        private final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.TYPE, null);\n+        final static ShortDeserializer primitiveInstance = new ShortDeserializer(Short.class, Short.valueOf((short)0));\n+        final static ShortDeserializer wrapperInstance = new ShortDeserializer(Short.TYPE, null);\n         \n         public ShortDeserializer(Class<Short> cls, Short nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.class, '\\0');\n-        private final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.TYPE, null);\n+        final static CharacterDeserializer primitiveInstance = new CharacterDeserializer(Character.class, '\\0');\n+        final static CharacterDeserializer wrapperInstance = new CharacterDeserializer(Character.TYPE, null);\n         \n         public CharacterDeserializer(Class<Character> cls, Character nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.class, 0);\n-        private final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.TYPE, null);\n+        final static IntegerDeserializer primitiveInstance = new IntegerDeserializer(Integer.class, 0);\n+        final static IntegerDeserializer wrapperInstance = new IntegerDeserializer(Integer.TYPE, null);\n         \n         public IntegerDeserializer(Class<Integer> cls, Integer nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static LongDeserializer primitiveInstance = new LongDeserializer(Long.class, Long.valueOf(0L));\n-        private final static LongDeserializer wrapperInstance = new LongDeserializer(Long.TYPE, null);\n+        final static LongDeserializer primitiveInstance = new LongDeserializer(Long.class, Long.valueOf(0L));\n+        final static LongDeserializer wrapperInstance = new LongDeserializer(Long.TYPE, null);\n         \n         public LongDeserializer(Class<Long> cls, Long nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.class, 0.f);\n-        private final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.TYPE, null);\n+        final static FloatDeserializer primitiveInstance = new FloatDeserializer(Float.class, 0.f);\n+        final static FloatDeserializer wrapperInstance = new FloatDeserializer(Float.TYPE, null);\n         \n         public FloatDeserializer(Class<Float> cls, Float nvl)\n         {\n     {\n         private static final long serialVersionUID = 1L;\n \n-        private final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.class, 0.d);\n-        private final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.TYPE, null);\n+        final static DoubleDeserializer primitiveInstance = new DoubleDeserializer(Double.class, 0.d);\n+        final static DoubleDeserializer wrapperInstance = new DoubleDeserializer(Double.TYPE, null);\n         \n         public DoubleDeserializer(Class<Double> cls, Double nvl)\n         {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n             elemTypeDeser = elemTypeDeser.forProperty(property);\n         }\n         return withDeserializer(elemTypeDeser, deser);\n+    }\n+\n+    @Override // since 2.5\n+    public boolean isCachable() {\n+        // Important: do NOT cache if polymorphic values\n+        return (_elementTypeDeserializer == null);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDelegatingDeserializer.java\n  *<p>\n  * Note that although types (delegate, target) may be related, they must not be same; trying\n  * to do this will result in an exception.\n+ *<p>\n+ * Since 2.5 There is {@link StdNodeBasedDeserializer} that is a simplified version\n+ * for cases where intermediate type is {@link JsonNode}\n  * \n  * @param <T> Target type to convert to, from delegate type\n  * \n  * @since 2.1\n+ * \n+ * @see StdNodeBasedDeserializer\n+ * @see Converter\n  */\n public class StdDelegatingDeserializer<T>\n     extends StdDeserializer<T>\n     private static final long serialVersionUID = 1L;\n \n     protected final Converter<Object,T> _converter;\n-    \n+\n     /**\n      * Fully resolved delegate type, with generic information if any available.\n      */\n     protected final JavaType _delegateType;\n-    \n+\n     /**\n      * Underlying serializer for type <code>T<.code>.\n      */\n     protected final JsonDeserializer<Object> _delegateDeserializer;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n         _delegateType = null;\n         _delegateDeserializer = null;\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\")\n     public StdDelegatingDeserializer(Converter<Object,T> converter,\n             JavaType delegateType, JsonDeserializer<?> delegateDeserializer)\n     }\n \n     /**\n+     * @since 2.5\n+     */\n+    protected StdDelegatingDeserializer(StdDelegatingDeserializer<T> src)\n+    {\n+        super(src);\n+        _converter = src._converter;\n+        _delegateType = src._delegateType;\n+        _delegateDeserializer = src._delegateDeserializer;\n+    }\n+\n+    /**\n      * Method used for creating resolved contextual instances. Must be\n      * overridden when sub-classing.\n      */\n             ((ResolvableDeserializer) _delegateDeserializer).resolve(ctxt);\n         }\n     }\n-    \n+\n     @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n         throws JsonMappingException\n     public Class<?> handledType() {\n         return _delegateDeserializer.handledType();\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Serialization\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n         _valueClass = (valueType == null) ? null : valueType.getRawClass();\n     }\n \n+    /**\n+     * Copy-constructor for sub-classes to use, most often when creating\n+     * new instances for {@link com.fasterxml.jackson.databind.deser.ContextualDeserializer}.\n+     * \n+     * @since 2.5\n+     */\n+    protected StdDeserializer(StdDeserializer<?> src) {\n+        _valueClass = src._valueClass;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Accessors\n             }\n             throw ctxt.weirdStringException(text, _valueClass, \"only \\\"true\\\" or \\\"false\\\" recognized\");\n         }\n-        // Issue#381\n+        // [databind#381]\n         if (t == JsonToken.START_ARRAY && ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n             jp.nextToken();\n             final boolean parsed = _parseBooleanPrimitive(jp, ctxt);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n import java.io.IOException;\n import java.lang.reflect.Constructor;\n import java.lang.reflect.Method;\n+import java.net.URI;\n+import java.net.URL;\n import java.util.Calendar;\n import java.util.Date;\n import java.util.Locale;\n     public final static int TYPE_DATE = 10;\n     public final static int TYPE_CALENDAR = 11;\n     public final static int TYPE_UUID = 12;\n+    public final static int TYPE_URI = 13;\n+    public final static int TYPE_URL = 14;\n+    public final static int TYPE_CLASS = 15;\n \n     final protected int _kind;\n     final protected Class<?> _keyClass;\n             kind = TYPE_FLOAT;\n         } else if (raw == Double.class) {\n             kind = TYPE_DOUBLE;\n+        } else if (raw == URI.class) {\n+            kind = TYPE_URI;\n+        } else if (raw == URL.class) {\n+            kind = TYPE_URL;\n+        } else if (raw == Class.class) {\n+            kind = TYPE_CLASS;\n         } else if (raw == Locale.class) {\n             FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class);\n             return new StdKeyDeserializer(TYPE_LOCALE, raw, deser);\n             return _parseLong(key);\n \n         case TYPE_FLOAT:\n-            /* 22-Jan-2009, tatu: Bounds/range checks would be tricky\n-             *   here, so let's not bother even trying...\n-             */\n+            // Bounds/range checks would be tricky here, so let's not bother even trying...\n             return Float.valueOf((float) _parseDouble(key));\n         case TYPE_DOUBLE:\n             return _parseDouble(key);\n             return (date == null)  ? null : ctxt.constructCalendar(date);\n         case TYPE_UUID:\n             return UUID.fromString(key);\n+        case TYPE_URI:\n+            return URI.create(key);\n+        case TYPE_URL:\n+            return new URL(key);\n+        case TYPE_CLASS:\n+            try {\n+                return ctxt.findClass(key);\n+            } catch (Exception e) {\n+                throw ctxt.weirdKeyException(_keyClass, key, \"unable to parse key as Class\");\n+            }\n         }\n         return null;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n public class StdKeyDeserializers\n     implements KeyDeserializers, java.io.Serializable\n {\n-    private static final long serialVersionUID = 923268084968181479L;\n+    private static final long serialVersionUID = 1L;\n     \n     public static KeyDeserializer constructEnumKeyDeserializer(EnumResolver<?> enumResolver) {\n         return new StdKeyDeserializer.EnumKD(enumResolver, null);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdNodeBasedDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+\n+/**\n+ * Convenience deserializer that may be used to deserialize values given an\n+ * intermediate tree representation ({@link JsonNode}).\n+ * Note that this is a slightly simplified alternative to {@link StdDelegatingDeserializer}).\n+ *\n+ * @param <T> Target type of this deserializer; that is, type of values that\n+ *   input data is deserialized into.\n+ * \n+ * @since 2.5\n+ */\n+public abstract class StdNodeBasedDeserializer<T>\n+    extends StdDeserializer<T>\n+    implements ResolvableDeserializer\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    protected JsonDeserializer<Object> _treeDeserializer;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    protected StdNodeBasedDeserializer(JavaType targetType) {\n+        super(targetType);\n+    }\n+\n+    protected StdNodeBasedDeserializer(Class<T> targetType) {\n+        super(targetType);\n+    }\n+\n+    /**\n+     * \"Copy-constructor\" used when creating a modified copies, most often\n+     * if sub-class implements {@link com.fasterxml.jackson.databind.deser.ContextualDeserializer}.\n+     */\n+    protected StdNodeBasedDeserializer(StdNodeBasedDeserializer<?> src) {\n+        super(src);\n+        _treeDeserializer = src._treeDeserializer;\n+    }\n+\n+    @Override\n+    public void resolve(DeserializationContext ctxt) throws JsonMappingException {\n+        _treeDeserializer = ctxt.findRootValueDeserializer(ctxt.constructType(JsonNode.class));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Abstract methods for sub-classes\n+    /**********************************************************\n+     */\n+\n+    public abstract T convert(JsonNode root, DeserializationContext ctxt) throws IOException;\n+\n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer impl\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public T deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n+        JsonNode n = (JsonNode) _treeDeserializer.deserialize(jp, ctxt);\n+        return convert(n, ctxt);\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer td)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* 19-Nov-2014, tatu: Quite likely we'd have some issues but... let's\n+         *   try, just in case.\n+         */\n+        JsonNode n = (JsonNode) _treeDeserializer.deserializeWithType(jp, ctxt, td);\n+        return convert(n, ctxt);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java\n \n     protected StdScalarDeserializer(Class<?> vc) { super(vc); }\n     protected StdScalarDeserializer(JavaType valueType) { super(valueType); }\n+\n+    // since 2.5\n+    protected StdScalarDeserializer(StdScalarDeserializer<?> src) { super(src); }\n     \n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.*;\n      */\n     \n     @Override\n-    public Object createUsingDefault(DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object createUsingDefault(DeserializationContext ctxt) throws IOException\n     {\n         if (_defaultCreator == null) { // sanity-check; caller should check\n             throw new IllegalStateException(\"No default constructor for \"+getValueTypeDesc());\n     }\n     \n     @Override\n-    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args)\n-        throws IOException, JsonProcessingException\n+    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException\n     {\n         if (_withArgsCreator == null) { // sanity-check; caller should check\n             throw new IllegalStateException(\"No with-args constructor for \"+getValueTypeDesc());\n     }\n \n     @Override\n-    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate)\n-        throws IOException, JsonProcessingException\n+    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException\n     {\n         if (_delegateCreator == null) { // sanity-check; caller should check\n             throw new IllegalStateException(\"No delegate constructor for \"+getValueTypeDesc());\n      */\n     \n     @Override\n-    public Object createFromString(DeserializationContext ctxt, String value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromString(DeserializationContext ctxt, String value) throws IOException\n     {\n         if (_fromStringCreator != null) {\n             try {\n     }\n     \n     @Override\n-    public Object createFromInt(DeserializationContext ctxt, int value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromInt(DeserializationContext ctxt, int value) throws IOException\n     {\n         try {\n             // First: \"native\" int methods work best:\n     }\n \n     @Override\n-    public Object createFromLong(DeserializationContext ctxt, long value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromLong(DeserializationContext ctxt, long value) throws IOException\n     {\n         try {\n             if (_fromLongCreator != null) {\n     }\n \n     @Override\n-    public Object createFromDouble(DeserializationContext ctxt, double value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException\n     {\n         try {\n             if (_fromDoubleCreator != null) {\n     }\n \n     @Override\n-    public Object createFromBoolean(DeserializationContext ctxt, boolean value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException\n     {\n         try {\n             if (_fromBooleanCreator != null) {\n     public AnnotatedParameter getIncompleteParameter() {\n         return _incompleteParameter;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Internal methods\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n                 _valueInstantiator, delegateDeser, valueDeser);\n     }\n \n+    @Override // since 2.5\n+    public boolean isCachable() {\n+        return true;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Validation, post-processing\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.DeserializationFeature;\n         _stringDeserializer = (JsonDeserializer<Object>) stringDeser;\n         _numberDeserializer = (JsonDeserializer<Object>) numberDeser;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Initialization\n      * to: it can not be done earlier since delegated deserializers almost\n      * certainly require access to this instance (at least \"List\" and \"Map\" ones)\n      */\n+    @SuppressWarnings(\"unchecked\")\n     @Override\n     public void resolve(DeserializationContext ctxt) throws JsonMappingException\n     {\n         JavaType obType = ctxt.constructType(Object.class);\n         JavaType stringType = ctxt.constructType(String.class);\n         TypeFactory tf = ctxt.getTypeFactory();\n+\n+        /* 26-Nov-2014, tatu: This is highly unusual, as in general contextualization\n+         *    should always be called separately, from within \"createContextual()\".\n+         *    But this is a very singular deserializer since it operates on `Object`\n+         *    (and often for `?` type parameter), and as a result, easily and commonly\n+         *    results in cycles, being value deserializer for various Maps and Collections.\n+         *    Because of this, we must somehow break the cycles. This is done here by\n+         *    forcing pseudo-contextualization with null property.\n+         */\n+\n+        // So: first find possible custom instances\n         _mapDeserializer = _findCustomDeser(ctxt, tf.constructMapType(Map.class, stringType, obType));\n         _listDeserializer = _findCustomDeser(ctxt, tf.constructCollectionType(List.class, obType));\n         _stringDeserializer = _findCustomDeser(ctxt, stringType);\n         _numberDeserializer = _findCustomDeser(ctxt, tf.constructType(Number.class));\n+\n+        // and then do bogus contextualization, in case custom ones need to resolve dependencies of\n+        // their own\n+        _mapDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_mapDeserializer, null);\n+        _listDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_listDeserializer, null);\n+        _stringDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_stringDeserializer, null);\n+        _numberDeserializer = (JsonDeserializer<Object>) ctxt.handleSecondaryContextualization(_numberDeserializer, null);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     protected JsonDeserializer<Object> _findCustomDeser(DeserializationContext ctxt, JavaType type)\n         throws JsonMappingException\n     {\n-        // NOTE: since we don't yet have the referring property, this should be fine:\n-        JsonDeserializer<?> deser = ctxt.findRootValueDeserializer(type);\n+        // Since we are calling from `resolve`, we should NOT try to contextualize yet;\n+        // contextualization will only occur at a later point\n+        JsonDeserializer<?> deser = ctxt.findNonContextualValueDeserializer(type);\n         if (ClassUtil.isJacksonStdImpl(deser)) {\n             return null;\n         }\n         return (JsonDeserializer<Object>) deser;\n     }\n-    \n+\n+    /**\n+     * We only use contextualization for optimizing the case where no customization\n+     * occurred; if so, can slip in a more streamlined version.\n+     */\n     @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n             BeanProperty property) throws JsonMappingException\n                 &&  getClass() == UntypedObjectDeserializer.class) {\n             return Vanilla.std;\n         }\n-        JsonDeserializer<?> mapDeserializer = _mapDeserializer;\n-        if (mapDeserializer instanceof ContextualDeserializer) {\n-            mapDeserializer = ((ContextualDeserializer)mapDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> listDeserializer = _listDeserializer;\n-        if (listDeserializer instanceof ContextualDeserializer) {\n-            listDeserializer = ((ContextualDeserializer)listDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> stringDeserializer = _stringDeserializer;\n-        if (stringDeserializer instanceof ContextualDeserializer) {\n-            stringDeserializer = ((ContextualDeserializer)stringDeserializer).createContextual(ctxt, property);\n-        }\n-        JsonDeserializer<?> numberDeserializer = _numberDeserializer;\n-        if (numberDeserializer instanceof ContextualDeserializer) {\n-            numberDeserializer = ((ContextualDeserializer)numberDeserializer).createContextual(ctxt, property);\n-        }\n-\n-        // And if anything changed, we'll need to change too!\n-        if ((mapDeserializer != _mapDeserializer)\n-                || (listDeserializer != _listDeserializer)\n-                || (stringDeserializer != _stringDeserializer)\n-                || (numberDeserializer != _numberDeserializer)\n-                ) {\n-            return _withResolved(mapDeserializer, listDeserializer,\n-                    stringDeserializer, numberDeserializer);\n-        }\n         return this;\n     }\n \n     /* Deserializer API\n     /**********************************************************\n      */\n-    \n+\n+    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes\n+     *   sense to also mark this is cachable, since lookup not exactly free, and\n+     *   since it's not uncommon to \"read anything\"\n+     */\n+    @Override\n+    public boolean isCachable() { return true; }\n+\n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java\n     extends AnnotatedMember\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 7364428299211355871L;\n+    private static final long serialVersionUID = 1L;\n \n     /**\n      * Actual {@link Field} used for access.\n      * Temporary field required for JDK serialization support\n      */\n     protected Serialization _serialization;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n     extends Annotated\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 7364428299211355871L;\n+    private static final long serialVersionUID = 1L; // since 2.5\n \n     // Transient since information not needed after construction, so\n     // no need to persist\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java\n     public Method getMember() { return _method; }\n \n     @Override\n-    public void setValue(Object pojo, Object value)\n-        throws IllegalArgumentException\n+    public void setValue(Object pojo, Object value) throws IllegalArgumentException\n     {\n         try {\n             _method.invoke(pojo, value);\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java\n     public final AnnotationMap getParameterAnnotations(int index)\n     {\n         if (_paramAnnotations != null) {\n-            if (index >= 0 && index <= _paramAnnotations.length) {\n+            if (index >= 0 && index < _paramAnnotations.length) {\n                 return _paramAnnotations[index];\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n import java.util.Collection;\n import java.util.List;\n \n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.NameTransformer;\n \n     public JsonInclude.Include findSerializationInclusion(Annotated a,\n             JsonInclude.Include defValue)\n     {\n-        /* This is bit trickier: need to combine results in a meaningful\n-         * way. Seems like it should be a disjoint; that is, most\n-         * restrictive value should be returned.\n-         * For enumerations, comparison is done by indexes, which\n-         * works: largest value is the last one, which is the most\n-         * restrictive value as well.\n-         */\n-        /* 09-Mar-2010, tatu: Actually, as per [JACKSON-256], it is probably better to just\n-         *    use strict overriding. Simpler, easier to understand.\n-         */\n         // note: call secondary first, to give lower priority\n         defValue = _secondary.findSerializationInclusion(a, defValue);\n         defValue = _primary.findSerializationInclusion(a, defValue);\n         return defValue;\n     }\n+\n+    @Override\n+    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)\n+    {\n+        // note: call secondary first, to give lower priority\n+        defValue = _secondary.findSerializationInclusion(a, defValue);\n+        defValue = _primary.findSerializationInclusion(a, defValue);\n+        return defValue;\n+    }\n     \n     @Override\n     public Class<?> findSerializationType(Annotated a) {\n-    \tClass<?> r = _primary.findSerializationType(a);\n+        Class<?> r = _primary.findSerializationType(a);\n         return (r == null) ? _secondary.findSerializationType(a) : r;\n     }\n \n         Boolean r = _primary.findSerializationSortAlphabetically(ann);\n         return (r == null) ? _secondary.findSerializationSortAlphabetically(ann) : r;\n     }\n-    \n+\n+    @Override\n+    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n+            List<BeanPropertyWriter> properties) {\n+        // first secondary, then primary, to give proper precedence\n+        _primary.findAndAddVirtualProperties(config, ac, properties);\n+        _secondary.findAndAddVirtualProperties(config, ac, properties);\n+    }\n+\n     // // // Serialization: property annotations\n     \n     @Override\n         return _primary.hasCreatorAnnotation(a) || _secondary.hasCreatorAnnotation(a);\n     }\n \n+    @Override\n+    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n+        JsonCreator.Mode mode = _primary.findCreatorBinding(a);\n+        if (mode != null) {\n+            return mode;\n+        }\n+        return _secondary.findCreatorBinding(a);\n+    }\n+    \n     protected boolean _isExplicitClassOrOb(Object maybeCls, Class<?> implicit) {\n         if (maybeCls == null) {\n             return false;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n \n     @Override\n     public ObjectIdInfo getObjectIdInfo() { return  _objectIdInfo; }\n-    \n+\n     @Override\n     public List<BeanPropertyDefinition> findProperties() {\n         return _properties;\n         }\n         return _ignoredPropertyNames;\n     }\n-    \n+\n     @Override\n     public boolean hasKnownClassAnnotations() {\n         return _classInfo.hasAnnotations();\n      * and per-class annotation (highest priority).\n      */\n     @Override\n-    public JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue)\n-    {\n+    public JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue) {\n         if (_annotationIntrospector == null) {\n             return defValue;\n         }\n         return _annotationIntrospector.findSerializationInclusion(_classInfo, defValue);\n+    }\n+\n+    @Override\n+    public JsonInclude.Include findSerializationInclusionForContent(JsonInclude.Include defValue) {\n+        if (_annotationIntrospector == null) {\n+            return defValue;\n+        }\n+        return _annotationIntrospector.findSerializationInclusionForContent(_classInfo, defValue);\n     }\n     \n     /**\n \n         /* Also: must be a recognized factory method, meaning:\n          * (a) marked with @JsonCreator annotation, or\n-         * (a) \"valueOf\" (at this point, need not be public)\n+         * (b) \"valueOf\" (at this point, need not be public)\n          */\n         if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n             return true;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n \n import java.util.Iterator;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.util.EmptyIterator;\n import com.fasterxml.jackson.databind.util.Named;\n \n     @Deprecated // since 2.3\n     public BeanPropertyDefinition withName(String newName) { return withSimpleName(newName); }\n-    \n+\n     /**\n      * Method that can be used to create a definition with\n      * same settings as this one, but with different\n      * @since 2.3\n      */\n     public abstract BeanPropertyDefinition withSimpleName(String newSimpleName);\n-    \n+\n     /*\n     /**********************************************************\n     /* Basic property information, name, type\n \n     /**\n      * Method for accessing additional metadata.\n-     * NOTE: will never return null, so deferencing return value\n+     * NOTE: will never return null, so de-referencing return value\n      * is safe.\n      * \n      * @since 2.3\n      * Method used to find the property member (getter, setter, field) that has\n      * the highest precedence in current context (getter method when serializing,\n      * if available, and so forth), if any.\n+     *<p>\n+     * Note: abstract since 2.5\n      * \n      * @since 2.1\n      */\n-    public AnnotatedMember getPrimaryMember() { return null; }\n+    public abstract AnnotatedMember getPrimaryMember();\n     \n     /*\n     /**********************************************************\n      * fail deserialization), or handled by other means (by providing default\n      * value)\n      */\n-    public final boolean isRequired() {\n+    public boolean isRequired() {\n         PropertyMetadata md = getMetadata();\n         return (md != null)  && md.isRequired();\n     }\n+\n+    /**\n+     * Method used to check if this property has specific inclusion override\n+     * associated with it or not.\n+     * \n+     * @since 2.5\n+     */\n+    public JsonInclude.Include findInclusion() {\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n \n import java.lang.annotation.Annotation;\n-import java.util.ArrayList;\n-import java.util.List;\n+import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter;\n import com.fasterxml.jackson.databind.ser.std.RawSerializer;\n-import com.fasterxml.jackson.databind.util.ClassUtil;\n-import com.fasterxml.jackson.databind.util.Converter;\n-import com.fasterxml.jackson.databind.util.NameTransformer;\n+import com.fasterxml.jackson.databind.util.*;\n \n /**\n  * {@link AnnotationIntrospector} implementation that handles standard\n      * are considered bundles.\n      */\n     @Override\n-    public boolean isAnnotationBundle(Annotation ann)\n-    {\n+    public boolean isAnnotationBundle(Annotation ann) {\n         return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* General annotations\n \n     // default impl is fine:\n     //public String findEnumValue(Enum<?> value) { return value.name(); }\n-    \n+\n     /*\n     /**********************************************************\n     /* General class annotations\n     }\n \n     @Override\n+    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)\n+    {\n+        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n+        return (inc == null) ? defValue : inc.content();\n+    }\n+\n+    @Override\n     public Class<?> findSerializationType(Annotated am)\n     {\n         JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n         JsonPropertyOrder order = _findAnnotation(ann, JsonPropertyOrder.class);\n         return (order == null) ? null : order.alphabetic();\n     }\n-    \n+\n+    @Override\n+    public void findAndAddVirtualProperties(MapperConfig<?> config, AnnotatedClass ac,\n+            List<BeanPropertyWriter> properties) {\n+        JsonAppend ann = _findAnnotation(ac, JsonAppend.class);\n+        if (ann == null) {\n+            return;\n+        }\n+        final boolean prepend = ann.prepend();\n+        JavaType propType = null;\n+\n+        // First: any attribute-backed properties?\n+        JsonAppend.Attr[] attrs = ann.attrs();\n+        for (int i = 0, len = attrs.length; i < len; ++i) {\n+            if (propType == null) {\n+                propType = config.constructType(Object.class);\n+            }\n+            BeanPropertyWriter bpw = _constructVirtualProperty(attrs[i],\n+                    config, ac, propType);\n+            if (prepend) {\n+                properties.add(i, bpw);\n+            } else {\n+                properties.add(bpw);\n+            }\n+        }\n+\n+        // Then: general-purpose virtual properties?\n+        JsonAppend.Prop[] props = ann.props();\n+        for (int i = 0, len = props.length; i < len; ++i) {\n+            BeanPropertyWriter bpw = _constructVirtualProperty(props[i],\n+                    config, ac);\n+            if (prepend) {\n+                properties.add(i, bpw);\n+            } else {\n+                properties.add(bpw);\n+            }\n+        }\n+    }\n+\n+    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Attr attr,\n+            MapperConfig<?> config, AnnotatedClass ac, JavaType type)\n+    {\n+        PropertyMetadata metadata = attr.required() ?\n+                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n+        // could add Index, Description in future, if those matter\n+        String attrName = attr.value();\n+\n+        // allow explicit renaming; if none, default to attribute name\n+        PropertyName propName = _propertyName(attr.propName(), attr.propNamespace());\n+        if (!propName.hasSimpleName()) {\n+            propName = new PropertyName(attrName);\n+        }\n+        // now, then, we need a placeholder for member (no real Field/Method):\n+        AnnotatedMember member = new VirtualAnnotatedMember(ac.getRawType(),\n+                attrName, type.getRawClass());\n+        // and with that and property definition\n+        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n+                member, propName, metadata, attr.include());\n+        // can construct the property writer\n+        return AttributePropertyWriter.construct(attrName, propDef,\n+                ac.getAnnotations(), type);\n+    }\n+\n+    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Prop prop,\n+            MapperConfig<?> config, AnnotatedClass ac)\n+    {\n+        PropertyMetadata metadata = prop.required() ?\n+                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n+        PropertyName propName = _propertyName(prop.name(), prop.namespace());\n+        JavaType type = config.constructType(prop.type());\n+        // now, then, we need a placeholder for member (no real Field/Method):\n+        AnnotatedMember member = new VirtualAnnotatedMember(ac.getRawType(),\n+                propName.getSimpleName(), type.getRawClass());\n+        // and with that and property definition\n+        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n+                member, propName, metadata, prop.include());\n+\n+        Class<?> implClass = prop.value();\n+\n+        HandlerInstantiator hi = config.getHandlerInstantiator();\n+        VirtualBeanPropertyWriter bpw = (hi == null) ? null\n+                : hi.virtualPropertyWriterInstance(config, implClass);\n+        if (bpw == null) {\n+            bpw = (VirtualBeanPropertyWriter) ClassUtil.createInstance(implClass,\n+                    config.canOverrideAccessModifiers());\n+        }\n+\n+        // one more thing: give it necessary contextual information\n+        return bpw.withConfig(config, ac, propDef, type);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Serialization: property annotations\n          */\n         return _hasAnnotation(a, JsonCreator.class);\n     }\n-    \n+\n+    @Override\n+    public JsonCreator.Mode findCreatorBinding(Annotated a) {\n+        JsonCreator ann = _findAnnotation(a, JsonCreator.class);\n+        return (ann == null) ? null : ann.mode();\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper methods\n         cls = _classIfExplicit(cls);\n         return (cls == null || cls == implicit) ? null : cls;\n     }\n-    \n+\n+    protected PropertyName _propertyName(String localName, String namespace) {\n+        if (localName.isEmpty()) {\n+            return PropertyName.USE_DEFAULT;\n+        }\n+        if (namespace == null || namespace.isEmpty()) {\n+            return new PropertyName(localName);\n+        }\n+        return new PropertyName(localName, namespace);\n+    }\n+\n     /**\n      * Helper method called to construct and initialize instance of {@link TypeResolverBuilder}\n      * if given annotated element indicates one is needed.\n      */\n+    @SuppressWarnings(\"deprecation\")\n     protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config,\n             Annotated ann, JavaType baseType)\n     {\n         b = b.inclusion(inclusion);\n         b = b.typeProperty(info.property());\n         Class<?> defaultImpl = info.defaultImpl();\n-        if (defaultImpl != JsonTypeInfo.None.class) {\n+\n+        // 08-Dec-2014, tatu: To deprecated `JsonTypeInfo.None` we need to use other placeholder(s);\n+        //   and since `java.util.Void` has other purpose (to indicate \"deser as null\"), we'll instead\n+        //   use `JsonTypeInfo.class` itself. But any annotation type will actually do, as they have no\n+        //   valid use (can not instantiate as default)\n+        if (defaultImpl != JsonTypeInfo.None.class && !defaultImpl.isAnnotation()) {\n             b = b.defaultImpl(defaultImpl);\n         }\n         b = b.typeIdVisibility(info.visible());\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/MemberKey.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/MemberKey.java\n              *    This happens with generics when a bound is specified.\n              *    I hope this works; check here must be transitive\n              */\n+            /* 14-Oct-2014, tatu: No, doing that is wrong. Conflicts may (and will) be\n+             *    handled at a later point; trying to change definition of equality\n+             *    will just cause problems like [jackson-core#158]\n+             */\n+            /*\n             if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) {\n                 continue;\n             }\n+            */\n             return false;\n         }\n         return true;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n         @Override\n         public Version version() {\n             return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n-       }\n+        }\n     };\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n \n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.util.EmptyIterator;\n \n \n     protected Linked<AnnotatedMethod> _setters;\n \n-    public POJOPropertyBuilder(PropertyName internalName, AnnotationIntrospector ai, boolean forSerialization) {\n+    public POJOPropertyBuilder(PropertyName internalName, AnnotationIntrospector ai,\n+            boolean forSerialization) {\n         this(internalName, internalName, ai, forSerialization);\n     }\n \n             }\n         });\n     }\n-    \n+\n+    @Override\n+    public JsonInclude.Include findInclusion() {\n+        if (_annotationIntrospector == null) {\n+            return null;\n+        }\n+        AnnotatedMember am = getAccessor();\n+        return _annotationIntrospector.findSerializationInclusion(am, null);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Data aggregation\n         }\n     }\n \n+    /**\n+     * Mutator that will simply drop any constructor parameters property may have.\n+     * \n+     * @since 2.5\n+     */\n+    public void removeConstructors() {\n+        _ctorParameters = null;\n+    }\n+    \n     /**\n      * Method called to trim unnecessary entries, such as implicit\n      * getter if there is an explict one available. This is important\n          * Method called to append given node(s) at the end of this\n          * node chain.\n          */\n-        private Linked<T> append(Linked<T> appendable) {\n+        protected Linked<T> append(Linked<T> appendable) {\n             if (next == null) {\n                 return withNext(appendable);\n             }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/VirtualAnnotatedMember.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.*;\n+\n+/**\n+ * Placeholder used by virtual properties as placeholder for\n+ * underlying {@link AnnotatedMember}.\n+ * \n+ * @since 2.5\n+ */\n+public class VirtualAnnotatedMember extends AnnotatedMember\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    protected final Class<?> _declaringClass;\n+\n+    protected final Class<?> _rawType;\n+\n+    protected final String _name;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public VirtualAnnotatedMember(Class<?> declaringClass, String name, Class<?> rawType)\n+    {\n+        super(/* AnnotationMap*/ null);\n+        _declaringClass = declaringClass;\n+        _rawType = rawType;\n+        _name = name;\n+    }\n+\n+    @Override\n+    public Annotated withAnnotations(AnnotationMap fallback) {\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Annotated impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Field getAnnotated() { return null; }\n+\n+    @Override\n+    public int getModifiers() { return 0; }\n+\n+    @Override\n+    public String getName() { return _name; }\n+\n+    @Override\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Type getGenericType() {\n+        return _rawType;\n+    }\n+\n+    @Override\n+    public Class<?> getRawType() {\n+        return _rawType;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* AnnotatedMember impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Class<?> getDeclaringClass() { return _declaringClass; }\n+\n+    @Override\n+    public Member getMember() { return null; }\n+\n+    @Override\n+    public void setValue(Object pojo, Object value) throws IllegalArgumentException {\n+        throw new IllegalArgumentException(\"Can not set virtual property '\"+_name+\"'\");\n+    }\n+\n+    @Override\n+    public Object getValue(Object pojo) throws IllegalArgumentException {\n+        throw new IllegalArgumentException(\"Can not get virtual property '\"+_name+\"'\");\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API, generic\n+    /**********************************************************\n+     */\n+\n+    public String getFullName() {\n+        return getDeclaringClass().getName() + \"#\" + getName();\n+    }\n+\n+    public int getAnnotationCount() { return 0; }\n+\n+    @Override\n+    public int hashCode() {\n+        return _name.hashCode();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        VirtualAnnotatedMember other = (VirtualAnnotatedMember) o;\n+        return (other._declaringClass == _declaringClass)\n+                && other._name.equals(_name);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"[field \"+getFullName()+\"]\";\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java\n package com.fasterxml.jackson.databind.jsontype;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.DatabindContext;\n import com.fasterxml.jackson.databind.JavaType;\n \n /**\n      * available for some reason.\n      */\n     public String idFromBaseType();\n-    \n+\n+    /**\n+     * @deprecated since 2.5; call {@link #typeFromId(DatabindContext, String)} instead\n+     */\n+    @Deprecated // since 2.4\n+    public JavaType typeFromId(String id);\n+\n     /**\n      * Method called to resolve type from given type identifier.\n+     * \n+     * @since 2.5 -- but since 2.3 has existed in {@link com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase}\n      */\n-    public JavaType typeFromId(String id);\n+    public JavaType typeFromId(DatabindContext context, String id);\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n     extends TypeDeserializerBase\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 5345570420394408290L;\n+    private static final long serialVersionUID = 1L;\n \n     public AsArrayTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n             String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n         String typeId = _locateTypeId(jp, ctxt);\n         JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n         // Minor complication: we may need to merge type id in?\n-        if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) {\n+        if (_typeIdVisible\n+                // 06-Oct-2014, tatu: To fix [databind#408], must distinguish between\n+                //   internal and external properties\n+                //  TODO: but does it need to be injected in external case? Why not?\n+                && !_usesExternalId()\n+                && jp.getCurrentToken() == JsonToken.START_OBJECT) {\n             // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n             TokenBuffer tb = new TokenBuffer(null, false);\n             tb.writeStartObject(); // recreate START_OBJECT\n     protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         if (!jp.isExpectedStartArrayToken()) {\n-            // [JACKSON-712] Need to allow even more customized handling, if something unexpected seen...\n+            // Need to allow even more customized handling, if something unexpected seen...\n             // but should there be a way to limit this to likely success cases?\n             if (_defaultImpl != null) {\n                 return _idResolver.idFromBaseType();\n         }\n         throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n     }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected boolean _usesExternalId() {\n+        return false;\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeSerializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type serializer used with {@link As#EXISTING_PROPERTY} inclusion mechanism.\n+ * Expects type information to be a well-defined property on all sub-classes.\n+ * \n+ * @author fleeman (modeled after code by tatus)\n+ */\n+public class AsExistingPropertyTypeSerializer\n+    extends AsPropertyTypeSerializer\n+{\n+\n+    public AsExistingPropertyTypeSerializer(TypeIdResolver idRes, BeanProperty property, String propName)\n+    {\n+        super(idRes, property, propName);\n+    }\n+\n+    @Override\n+    public AsExistingPropertyTypeSerializer forProperty(BeanProperty prop) {\n+        return (_property == prop) ? this : new AsExistingPropertyTypeSerializer(this._idResolver, prop, this._typePropertyName);\n+    }\n+    \n+    @Override\n+    public As getTypeInclusion() { return As.EXISTING_PROPERTY; }\n+    \n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException\n+    {\n+        final String typeId = idFromValue(value);\n+        if (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException\n+    {\n+        final String typeId = idFromValueAndType(value, type);\n+        if (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+    \n+    @Override\n+    public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException\n+    {\n+    \tif (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n     \n     @Override\n     public As getTypeInclusion() { return As.EXTERNAL_PROPERTY; }\n+\n+    // yes, very important distinction...\n+    @Override\n+    protected boolean _usesExternalId() {\n+        return true;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n {\n     private static final long serialVersionUID = 1L;\n \n+    protected final As _inclusion;\n+\n     public AsPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n             String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n     {\n+        this(bt, idRes, typePropertyName, typeIdVisible, defaultImpl, As.PROPERTY);\n+    }\n+    \n+    public AsPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n+            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl,\n+            As inclusion)\n+    {\n         super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl);\n+        _inclusion = inclusion;\n     }\n \n     public AsPropertyTypeDeserializer(AsPropertyTypeDeserializer src, BeanProperty property) {\n         super(src, property);\n+        _inclusion = src._inclusion;\n     }\n     \n     @Override\n     }\n     \n     @Override\n-    public As getTypeInclusion() { return As.PROPERTY; }\n+    public As getTypeInclusion() { return _inclusion; }\n \n     /**\n      * This is the trickiest thing to handle, since property we are looking\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n             return new AsExternalTypeSerializer(idRes, null,\n                     _typeProperty);\n         case EXISTING_PROPERTY:\n-            throw _noExisting();\n+        \t// as per [#528]\n+        \treturn new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n \n     // as per [#368]\n-    private IllegalArgumentException _noExisting() {\n-        return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n-    }\n+    // removed when fix [#528]\n+    //private IllegalArgumentException _noExisting() {\n+    //    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n+    //}\n \n     @Override\n     public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n             return new AsArrayTypeDeserializer(baseType, idRes,\n                     _typeProperty, _typeIdVisible, _defaultImpl);\n         case PROPERTY:\n+        case EXISTING_PROPERTY: // as per [#528] same class as PROPERTY\n             return new AsPropertyTypeDeserializer(baseType, idRes,\n-                    _typeProperty, _typeIdVisible, _defaultImpl);\n+                    _typeProperty, _typeIdVisible, _defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n             return new AsWrapperTypeDeserializer(baseType, idRes,\n                     _typeProperty, _typeIdVisible, _defaultImpl);\n         case EXTERNAL_PROPERTY:\n             return new AsExternalTypeDeserializer(baseType, idRes,\n                     _typeProperty, _typeIdVisible, _defaultImpl);\n-        case EXISTING_PROPERTY:\n-            throw _noExisting();\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n                  * for base class, not via interface. Later on we can add this\n                  * to the interface, assuming deprecation at base class helps.\n                  */\n-                JavaType type;\n-                if (_idResolver instanceof TypeIdResolverBase) {\n-                    type = ((TypeIdResolverBase) _idResolver).typeFromId(ctxt, typeId);\n-                } else {\n-                    type = _idResolver.typeFromId(typeId);\n-                }\n+                JavaType type = _idResolver.typeFromId(ctxt, typeId);\n                 if (type == null) {\n                     // As per [JACKSON-614], use the default impl if no type id available:\n                     deser = _findDefaultImplDeserializer(ctxt);\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n      */\n     @Deprecated\n     @Override\n-    public abstract JavaType typeFromId(String id);\n+    public JavaType typeFromId(String id) {\n+        return typeFromId(null, id);\n+    }\n \n     /**\n      * New method, replacement for {@link #typeFromId(String)}, which is given\n      * \n      * @since 2.3\n      */\n+    @Override\n     public JavaType typeFromId(DatabindContext context, String id) {\n         return typeFromId(id);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeSerializerBase.java\n     protected String idFromValue(Object value) {\n         String id = _idResolver.idFromValue(value);\n         if (id == null) {\n-            String typeDesc = (value == null) ? \"NULL\" : value.getClass().getName();\n-            throw new IllegalArgumentException(\"Can not resolve type id for \"\n-                    +typeDesc+\" (using \"+_idResolver.getClass().getName()+\")\");\n+            handleMissingId(value);\n         }\n         return id;\n     }\n     protected String idFromValueAndType(Object value, Class<?> type) {\n         String id = _idResolver.idFromValueAndType(value, type);\n         if (id == null) {\n-            String typeDesc = (value == null) ? \"NULL\" : value.getClass().getName();\n-            throw new IllegalArgumentException(\"Can not resolve type id for \"\n-                    +typeDesc+\" (using \"+_idResolver.getClass().getName()+\")\");\n+            handleMissingId(value);\n         }\n         return id;\n     }\n+\n+    // As per [databind#633], maybe better just not do anything...\n+    protected void handleMissingId(Object value) {\n+        /*\n+        String typeDesc = (value == null) ? \"NULL\" : value.getClass().getName();\n+        throw new IllegalArgumentException(\"Can not resolve type id for \"\n+                +typeDesc+\" (using \"+_idResolver.getClass().getName()+\")\");\n+                */\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n public class SimpleKeyDeserializers\n     implements KeyDeserializers, java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = -6786398737835438187L;\n+    private static final long serialVersionUID = 1L;\n \n     protected HashMap<ClassKey,KeyDeserializer> _classMappings = null;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n import java.util.Map;\n \n import com.fasterxml.jackson.core.Version;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n     extends Module\n     implements java.io.Serializable\n {\n-    // at 2.4.0:\n-    private static final long serialVersionUID = -8905749147637667249L;\n+    private static final long serialVersionUID = 1L; // 2.5.0\n \n     protected final String _name;\n     protected final Version _version;\n      * use actual name and version number information.\n      */\n     public SimpleModule() {\n-        // when passing 'this', can not chain constructors...\n-        _name = \"SimpleModule-\"+System.identityHashCode(this);\n+        // can't chain when making reference to 'this'\n+        // note: generate different name for direct instantiation, sub-classing\n+        _name = (getClass() == SimpleModule.class) ?\n+                \"SimpleModule-\"+System.identityHashCode(this)\n+                : getClass().getName();\n         _version = Version.unknownVersion();\n     }\n     \n             _serializers = new SimpleSerializers(serializers);\n         }\n     }\n+\n+    /**\n+     * Since instances are likely to be custom, implementation returns\n+     * <code>null</code> if (but only if!) this class is directly instantiated;\n+     * but class name (default impl) for sub-classes.\n+     */\n+    @Override\n+    public Object getTypeId() {\n+        if (getClass() == SimpleModule.class) {\n+            return null;\n+        }\n+        return super.getTypeId();\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n     protected JsonNode _at(JsonPointer ptr) {\n         return get(ptr.getMatchingIndex());\n     }\n-    \n+\n     // note: co-variant to allow caller-side type safety\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     @Override\n     public void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException\n     {\n-        jg.writeStartArray();\n-        for (JsonNode n : _children) {\n-            /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n-             *   extend BaseJsonNode? Or if not, at least implement\n-             *   JsonSerializable? Let's start with former, change if\n-             *   we must.\n-             */\n-            ((BaseJsonNode)n).serialize(jg, provider);\n+    \tfinal List<JsonNode> c = _children;\n+    \tfinal int size = c.size();\n+        jg.writeStartArray(size);\n+        for (int i = 0; i < size; ++i) { // we'll typically have array list\n+        \t// Can we trust that all nodes will always extend BaseJsonNode? Or if not,\n+        \t// at least implement JsonSerializable? Let's start with former, change if must\n+            ((BaseJsonNode) c.get(i)).serialize(jg, provider);\n         }\n         jg.writeEndArray();\n     }\n     protected boolean _childrenEqual(ArrayNode other) {\n         return _children.equals(other._children);\n     }\n-    \n+\n     @Override\n     public int hashCode() {\n         return _children.hashCode();\n     }\n-\n \n     @Override\n     public String toString()\n--- a/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n     public ValueNode numberNode(Integer value) {\n         return (value == null) ? nullNode() : IntNode.valueOf(value.intValue());\n     }\n-    \n+\n     /**\n      * Factory method for getting an instance of JSON numeric value\n      * that expresses given 64-bit integer value\n--- a/src/main/java/com/fasterxml/jackson/databind/node/NodeCursor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NodeCursor.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.JsonNode;\n \n /**\n      * Current field name\n      */\n     protected String _currentName;\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected java.lang.Object _currentValue;\n     \n     public NodeCursor(int contextType, NodeCursor p)\n     {\n     public void overrideCurrentName(String name) {\n         _currentName = name;\n     }\n+\n+    @Override\n+    public java.lang.Object getCurrentValue() {\n+        return _currentValue;\n+    }\n+\n+    @Override\n+    public void setCurrentValue(java.lang.Object v) {\n+        _currentValue = v;\n+    }\n     \n     /*\n     /**********************************************************\n         JsonNode n = currentNode();\n         if (n == null) throw new IllegalStateException(\"No current node\");\n         if (n.isArray()) { // false since we have already returned START_ARRAY\n-            return new Array(n, this);\n+            return new ArrayCursor(n, this);\n         }\n         if (n.isObject()) {\n-            return new Object(n, this);\n+            return new ObjectCursor(n, this);\n         }\n         throw new IllegalStateException(\"Current node of type \"+n.getClass().getName());\n     }\n      * than JSON Object and Array).\n      * Note that context is NOT created for leaf values.\n      */\n-    protected final static class RootValue\n+    protected final static class RootCursor\n         extends NodeCursor\n     {\n         protected JsonNode _node;\n \n         protected boolean _done = false;\n \n-        public RootValue(JsonNode n, NodeCursor p) {\n+        public RootCursor(JsonNode n, NodeCursor p) {\n             super(JsonStreamContext.TYPE_ROOT, p);\n             _node = n;\n         }\n     /**\n      * Cursor used for traversing non-empty JSON Array nodes\n      */\n-    protected final static class Array\n+    protected final static class ArrayCursor\n         extends NodeCursor\n     {\n         protected Iterator<JsonNode> _contents;\n \n         protected JsonNode _currentNode;\n \n-        public Array(JsonNode n, NodeCursor p) {\n+        public ArrayCursor(JsonNode n, NodeCursor p) {\n             super(JsonStreamContext.TYPE_ARRAY, p);\n             _contents = n.elements();\n         }\n     /**\n      * Cursor used for traversing non-empty JSON Object nodes\n      */\n-    protected final static class Object\n+    protected final static class ObjectCursor\n         extends NodeCursor\n     {\n         protected Iterator<Map.Entry<String, JsonNode>> _contents;\n \n         protected boolean _needEntry;\n         \n-        public Object(JsonNode n, NodeCursor p)\n+        public ObjectCursor(JsonNode n, NodeCursor p)\n         {\n             super(JsonStreamContext.TYPE_OBJECT, p);\n             _contents = ((ObjectNode) n).fields();\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n \n     /**\n      * Method for setting value of a field to specified numeric value.\n+     * The underlying {@link JsonNode} that will be added is constructed\n+     * using {@link JsonNodeFactory#numberNode(int)}, and may be\n+     *  \"smaller\" (like {@link ShortNode}) in cases where value fits within\n+     *  range of a smaller integral numeric value.\n      * \n      * @return This node (to allow chaining)\n      */\n     \n     /**\n      * Method for setting value of a field to specified numeric value.\n+     * The underlying {@link JsonNode} that will be added is constructed\n+     * using {@link JsonNodeFactory#numberNode(long)}, and may be\n+     *  \"smaller\" (like {@link IntNode}) in cases where value fits within\n+     *  range of a smaller integral numeric value.\n      * \n      * @return This node (to allow chaining)\n      */\n     }\n \n     /**\n-     * Alternative method that we need to avoid bumping into NPE issues\n-     * with auto-unboxing.\n+     * Method for setting value of a field to specified numeric value.\n+     * The underlying {@link JsonNode} that will be added is constructed\n+     * using {@link JsonNodeFactory#numberNode(Long)}, and may be\n+     *  \"smaller\" (like {@link IntNode}) in cases where value fits within\n+     *  range of a smaller integral numeric value.\n+     * <p>\n+     * Note that this is alternative to {@link #put(String, long)} needed to avoid\n+     * bumping into NPE issues with auto-unboxing.\n      * \n      * @return This node (to allow chaining)\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n         _objectCodec = codec;\n         if (n.isArray()) {\n             _nextToken = JsonToken.START_ARRAY;\n-            _nodeCursor = new NodeCursor.Array(n, null);\n+            _nodeCursor = new NodeCursor.ArrayCursor(n, null);\n         } else if (n.isObject()) {\n             _nextToken = JsonToken.START_OBJECT;\n-            _nodeCursor = new NodeCursor.Object(n, null);\n+            _nodeCursor = new NodeCursor.ObjectCursor(n, null);\n         } else { // value node\n-            _nodeCursor = new NodeCursor.RootValue(n, null);\n+            _nodeCursor = new NodeCursor.RootCursor(n, null);\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n                 throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n                         +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n             }\n-            _serializer.serializeFilteredFields((Map<?,?>) value, jgen, provider, filter);\n+            // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n+            _serializer.serializeFilteredFields((Map<?,?>) value, jgen, provider, filter, null);\n         }\n     \n     // Note: NOT part of ResolvableSerializer...\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\n import com.fasterxml.jackson.databind.ser.impl.*;\n import com.fasterxml.jackson.databind.ser.std.*;\n import com.fasterxml.jackson.databind.type.*;\n-import com.fasterxml.jackson.databind.util.ClassUtil;\n-import com.fasterxml.jackson.databind.util.Converter;\n-import com.fasterxml.jackson.databind.util.EnumValues;\n-import com.fasterxml.jackson.databind.util.TokenBuffer;\n+import com.fasterxml.jackson.databind.util.*;\n \n /**\n  * Factory class that can provide serializers for standard JDK classes,\n         _concrete.put(Boolean.class.getName(), new BooleanSerializer(false));\n \n         // Other numbers, more complicated\n-        final JsonSerializer<?> ns = NumberSerializer.instance;\n-        _concrete.put(BigInteger.class.getName(), ns);\n-        _concrete.put(BigDecimal.class.getName(), ns);\n+        _concrete.put(BigInteger.class.getName(), new NumberSerializer(BigInteger.class));\n+        _concrete.put(BigDecimal.class.getName(),new NumberSerializer(BigDecimal.class));\n \n         // Other discrete non-container types:\n         // First, Date/Time zoo:\n             if (ser != null) { break; }\n         }\n         if (ser == null) {\n-            if (EnumMap.class.isAssignableFrom(type.getRawClass())) {\n+            // 08-Nov-2014, tatu: As per [databind#601], better just use default Map serializer\n+            /*\n+            if (EnumMap.class.isAssignableFrom(type.getRawClass())\n+                    && ((keySerializer == null) || ClassUtil.isJacksonStdImpl(keySerializer))) {\n                 JavaType keyType = type.getKeyType();\n                 // Need to find key enum values...\n                 EnumValues enums = null;\n                 ser = new EnumMapSerializer(type.getContentType(), staticTyping, enums,\n                     elementTypeSerializer, elementValueSerializer);\n             } else {\n-                Object filterId = findFilterId(config, beanDesc);\n-                ser = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()),\n+            */\n+            Object filterId = findFilterId(config, beanDesc);\n+            MapSerializer mapSer = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()),\n                     type, staticTyping, elementTypeSerializer,\n                     keySerializer, elementValueSerializer, filterId);\n-            }\n+            Object suppressableValue = findSuppressableContentValue(config,\n+                    type.getContentType(), beanDesc);\n+            if (suppressableValue != null) {\n+                mapSer = mapSer.withContentInclusion(suppressableValue);\n+            }\n+            ser = mapSer;\n         }\n         // [Issue#120]: Allow post-processing\n         if (_factoryConfig.hasSerializerModifiers()) {\n         return ser;\n     }\n \n+    /**\n+     * @since 2.5\n+     */\n+    protected Object findSuppressableContentValue(SerializationConfig config,\n+            JavaType contentType, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);\n+\n+        if (incl != null) {\n+            switch (incl) {\n+            case NON_DEFAULT:\n+                // 19-Oct-2014, tatu: Not sure what this'd mean; so take it to mean \"NON_EMPTY\"...\n+                incl = JsonInclude.Include.NON_EMPTY;\n+                break;\n+            default:\n+                // all other modes actually good as is, unless we'll find better ways\n+                break;\n+            }\n+            return incl;\n+        }\n+        return null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Factory methods, for Arrays\n             JavaType type, BeanDescription beanDesc)\n         throws JsonMappingException\n     {\n-        /* As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n+        /* As per [databind#24], may want to use alternate shape, serialize as JSON Object.\n          * Challenge here is that EnumSerializer does not know how to produce\n          * POJO style serialization, so we must handle that special case separately;\n          * otherwise pass it to EnumSerializer.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n import java.lang.reflect.Type;\n import java.util.HashMap;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.SerializableString;\n import com.fasterxml.jackson.core.io.SerializedString;\n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n      */\n-    public final static Object MARKER_FOR_EMPTY = new Object();\n-    \n+    public final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;\n+\n     /*\n     /**********************************************************\n     /* Settings for accessing property value to serialize\n      * under which value for the property is written.\n      *<p>\n      * NOTE: do NOT change name of this field; it is accessed by\n-     * Afterburner module.\n+     * Afterburner module (until 2.4; not directly from 2.5)\n      * ALSO NOTE: ... and while it really ought to be `SerializableString`,\n      * changing that is also binary-incompatible change. So nope.\n      */\n     {\n         _member = member;\n         _contextAnnotations = contextAnnotations;\n+\n         _name = new SerializedString(propDef.getName());\n         _wrapperName = propDef.getWrapperName();\n+        _metadata = propDef.getMetadata();\n+        _includeInViews = propDef.findViews();\n+\n         _declaredType = declaredType;\n         _serializer = (JsonSerializer<Object>) ser;\n         _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null;\n         _typeSerializer = typeSer;\n         _cfgSerializationType = serType;\n-        _metadata = propDef.getMetadata();\n \n         if (member instanceof AnnotatedField) {\n             _accessorMethod = null;\n             _accessorMethod = (Method) member.getMember();\n             _field = null;\n         } else {\n-            throw new IllegalArgumentException(\"Can not pass member of type \"+member.getClass().getName());\n+            // 01-Dec-2014, tatu: Used to be illegal, but now explicitly allowed for virtual props\n+            _accessorMethod = null;\n+            _field = null;\n         }\n         _suppressNulls = suppressNulls;\n         _suppressableValue = suppressableValue;\n-        _includeInViews = propDef.findViews();\n \n         // this will be resolved later on, unless nulls are to be suppressed\n         _nullSerializer = null;\n     }\n \n     /**\n+     * Constructor that may be of use to virtual properties, when there is need for\n+     * the zero-arg (\"default\") constructor, and actual initialization is done\n+     * after constructor call.\n+     * \n+     * @since 2.5\n+     */\n+    protected BeanPropertyWriter() {\n+        _member = null;\n+        _contextAnnotations = null;\n+\n+        _name = null;\n+        _wrapperName = null;\n+        _metadata = null;\n+        _includeInViews = null;\n+\n+        _declaredType = null;\n+        _serializer = null;\n+        _dynamicSerializers = null;\n+        _typeSerializer = null;\n+        _cfgSerializationType = null;\n+\n+        _accessorMethod = null;\n+        _field = null;\n+        _suppressNulls = false;\n+        _suppressableValue = null;\n+\n+        _nullSerializer = null;\n+    }\n+\n+    /**\n      * \"Copy constructor\" to be used by filtering sub-classes\n      */\n     protected BeanPropertyWriter(BeanPropertyWriter base) {\n         this(base, base._name);\n     }\n \n-    protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name) {\n-        _name = name;\n+    /**\n+     * @since 2.5\n+     */\n+    protected BeanPropertyWriter(BeanPropertyWriter base, PropertyName name)\n+    {\n+        /* 02-Dec-2014, tatu: This is a big mess, alas, what with dependency\n+         *   to MapperConfig to encode, and Afterburner having heartburn\n+         *   for SerializableString (vs SerializedString).\n+         *   Hope it can be resolved/reworker in 2.6 timeframe, if not for 2.5\n+         */\n+        _name = new SerializedString(name.getSimpleName());\n         _wrapperName = base._wrapperName;\n \n         _member = base._member;\n         _metadata = base._metadata;\n     }\n \n+    protected BeanPropertyWriter(BeanPropertyWriter base, SerializedString name) {\n+        _name = name;\n+        _wrapperName = base._wrapperName;\n+\n+        _member = base._member;\n+        _contextAnnotations = base._contextAnnotations;\n+        _declaredType = base._declaredType;\n+        _accessorMethod = base._accessorMethod;\n+        _field = base._field;\n+        _serializer = base._serializer;\n+        _nullSerializer = base._nullSerializer;\n+        // one more thing: copy internal settings, if any (since 1.7)\n+        if (base._internalSettings != null) {\n+            _internalSettings = new HashMap<Object,Object>(base._internalSettings);\n+        }\n+        _cfgSerializationType = base._cfgSerializationType;\n+        _dynamicSerializers = base._dynamicSerializers;\n+        _suppressNulls = base._suppressNulls;\n+        _suppressableValue = base._suppressableValue;\n+        _includeInViews = base._includeInViews;\n+        _typeSerializer = base._typeSerializer;\n+        _nonTrivialBaseType = base._nonTrivialBaseType;\n+        _metadata = base._metadata;\n+    }\n+\n     public BeanPropertyWriter rename(NameTransformer transformer) {\n         String newName = transformer.transform(_name.getValue());\n         if (newName.equals(_name.toString())) {\n             return this;\n         }\n-        return new BeanPropertyWriter(this, new SerializedString(newName));\n+        return new BeanPropertyWriter(this, new PropertyName(newName));\n     }\n     \n     /**\n     // Note: also part of 'PropertyWriter'\n     @Override\n     public <A extends Annotation> A getAnnotation(Class<A> acls) {\n-        return _member.getAnnotation(acls);\n+        return (_member == null) ? null : _member.getAnnotation(acls);\n     }\n \n     // Note: also part of 'PropertyWriter'\n     @Override\n     public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n-        return _contextAnnotations.get(acls);\n+        return (_contextAnnotations == null) ? null : _contextAnnotations.get(acls);\n     }\n \n     @Override public AnnotatedMember getMember() { return _member; }\n     protected void _depositSchemaProperty(ObjectNode propertiesNode, JsonNode schemaNode) {\n         propertiesNode.set(getName(), schemaNode);\n     }\n+\n+    /**\n+     * Note: will be defined in {@link BeanProperty}; as of now is not yet.\n+     *<p>\n+     * TODO: move to {@link BeanProperty} in near future, once all standard\n+     * implementations define it.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isVirtual() { return false; }\n     \n     /*\n     /**********************************************************\n         if (_accessorMethod != null) {\n             return _accessorMethod.getGenericReturnType();\n         }\n-        return _field.getGenericType();\n+        if (_field != null) {\n+            return _field.getGenericType();\n+        }\n+        return null;\n     }\n \n     public Class<?>[] getViews() { return _includeInViews; }\n         sb.append(\"property '\").append(getName()).append(\"' (\");\n         if (_accessorMethod != null) {\n             sb.append(\"via method \").append(_accessorMethod.getDeclaringClass().getName()).append(\"#\").append(_accessorMethod.getName());\n+        } else if (_field != null) {\n+            sb.append(\"field \\\"\").append(_field.getDeclaringClass().getName()).append(\"#\").append(_field.getName());\n         } else {\n-            sb.append(\"field \\\"\").append(_field.getDeclaringClass().getName()).append(\"#\").append(_field.getName());\n+            sb.append(\"virtual\");\n         }\n         if (_serializer == null) {\n             sb.append(\", no static serializer\");\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.impl.BeanAsArraySerializer;\n import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n         /* Can not:\n          * \n          * - have Object Id (may be allowed in future)\n-         * - have any getter\n-         * \n+         * - have \"any getter\"\n+         * - have per-property filters\n          */\n         if ((_objectIdWriter == null)\n                 && (_anyGetterWriter == null)\n      * {@link BeanPropertyWriter} instances.\n      */\n     @Override\n-    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public final void serialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         if (_objectIdWriter != null) {\n-            _serializeWithObjectId(bean, jgen, provider, true);\n+            _serializeWithObjectId(bean, gen, provider, true);\n             return;\n         }\n-        jgen.writeStartObject();\n+        gen.writeStartObject();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(bean);\n         if (_propertyFilterId != null) {\n-            serializeFieldsFiltered(bean, jgen, provider);\n+            serializeFieldsFiltered(bean, gen, provider);\n         } else {\n-            serializeFields(bean, jgen, provider);\n+            serializeFields(bean, gen, provider);\n         }\n-        jgen.writeEndObject();\n+        gen.writeEndObject();\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         final SerializationConfig config = prov.getConfig();\n         BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n         builder.setConfig(config);\n-        \n+\n         // First: any detectable (auto-detect, annotations) properties to serialize?\n         List<BeanPropertyWriter> props = findBeanProperties(prov, beanDesc, builder);\n         if (props == null) {\n             props = new ArrayList<BeanPropertyWriter>();\n         }\n+        // [databind#638]: Allow injection of \"virtual\" properties:\n+        prov.getAnnotationIntrospector().findAndAddVirtualProperties(config, beanDesc.getClassInfo(), props);\n+\n         // [JACKSON-440] Need to allow modification bean properties to serialize:\n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n                 props = mod.changeProperties(config, beanDesc, props);\n             }\n         }\n-        \n+\n         // Any properties to suppress?\n         props = filterBeanProperties(config, beanDesc, props);\n-        \n+\n         // [JACKSON-440] Need to allow reordering of properties to serialize\n         if (_factoryConfig.hasSerializerModifiers()) {\n             for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n \n     /**\n      * Method that will apply by-type limitations (as per [JACKSON-429]);\n-     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType} annotation but\n-     * can be supplied by module-provided introspectors too.\n+     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType}\n+     * annotation but can be supplied by module-provided introspectors too.\n      */\n     protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc,\n             List<BeanPropertyDefinition> properties)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n package com.fasterxml.jackson.databind.ser;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n \n     {\n         if (property != null) {\n             AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n-            if (intr != null) {\n-                if (intr.findSerializationContentType(property.getMember(), property.getType()) != null) {\n+            AnnotatedMember m = property.getMember();\n+            if ((m != null) && (intr != null)) {\n+                if (intr.findSerializationContentType(m, property.getType()) != null) {\n                     return true;\n                 }\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n-\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n         super(src, config, f);\n     }\n \n+    protected DefaultSerializerProvider(DefaultSerializerProvider src) {\n+        super(src);\n+    }\n+\n+    /**\n+     * Method needed to ensure that {@link ObjectMapper#copy} will work\n+     * properly; specifically, that caches are cleared, but settings\n+     * will otherwise remain identical; and that no sharing of state\n+     * occurs.\n+     * \n+     * @since 2.4.4\n+     */\n+    public DefaultSerializerProvider copy() {\n+        throw new IllegalStateException(\"DefaultSerializerProvider sub-class not overriding copy()\");\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Extended API: methods that ObjectMapper will call\n         private static final long serialVersionUID = 1L;\n \n         public Impl() { super(); }\n+        public Impl(Impl src) { super(src); }\n \n         protected Impl(SerializerProvider src, SerializationConfig config,SerializerFactory f) {\n             super(src, config, f);\n         }\n \n+        @Override\n+        public DefaultSerializerProvider copy()\n+        {\n+            if (getClass() != Impl.class) {\n+                return super.copy();\n+            }\n+            return new Impl(this);\n+        }\n+        \n         @Override\n         public Impl createInstance(SerializationConfig config, SerializerFactory jsf) {\n             return new Impl(this, config, jsf);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n {\n     final protected SerializationConfig _config;\n     final protected BeanDescription _beanDesc;\n-    final protected JsonInclude.Include _outputProps;\n+\n+    /**\n+     * Default inclusion mode for properties of the POJO for which\n+     * properties are collected; possibly overridden on\n+     * per-property basis.\n+     */\n+    final protected JsonInclude.Include _defaultInclusion;\n \n     final protected AnnotationIntrospector _annotationIntrospector;\n \n     {\n         _config = config;\n         _beanDesc = beanDesc;\n-        _outputProps = beanDesc.findSerializationInclusion(config.getSerializationInclusion());\n+        _defaultInclusion = beanDesc.findSerializationInclusion(config.getSerializationInclusion());\n         _annotationIntrospector = _config.getAnnotationIntrospector();\n     }\n \n \n     public Annotations getClassAnnotations() {\n         return _beanDesc.getClassAnnotations();\n-    }\n-\n-    /**\n-     * @deprecated Since 2.3, use variant that takes {@link SerializerProvider} as\n-     *   first argument -- to be removed from 2.4\n-     */\n-    @Deprecated\n-    protected final BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef,\n-            JavaType declaredType, JsonSerializer<?> ser,\n-            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n-            AnnotatedMember am, boolean defaultUseStaticTyping)\n-    {\n-        /* We will only retain this method until 2.4; left for now to explicitly\n-         * cause compilation/linking issue iff anyone has overridden the method\n-         * (hopefully not)\n-         */\n-        throw new IllegalStateException();\n     }\n \n     /**\n             }\n             JavaType ct = serializationType.getContentType();\n             /* 03-Sep-2010, tatu: This is somehow related to [JACKSON-356], but I don't completely\n-             *   yet understand how pieces fit together. Still, better be explicit than rely on\n+             *   yet understand how pieces fit together. Still, better to be explicit than rely on\n              *   NPE to indicate an issue...\n              */\n             if (ct == null) {\n         Object valueToSuppress = null;\n         boolean suppressNulls = false;\n \n-        JsonInclude.Include methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps);\n-        if (methodProps != null) {\n-            switch (methodProps) {\n+        JsonInclude.Include inclusion = propDef.findInclusion();\n+        if (inclusion == null) {\n+            inclusion = _defaultInclusion;\n+        }\n+        if (inclusion != null) {\n+            switch (inclusion) {\n             case NON_DEFAULT:\n                 valueToSuppress = getDefaultValue(propDef.getName(), am);\n                 if (valueToSuppress == null) {\n                 am, _beanDesc.getClassAnnotations(), declaredType,\n                 ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n \n-        // 14-Oct-2013, tatu: And how about custom null serializer?\n+        // How about custom null serializer?\n         Object serDef = _annotationIntrospector.findNullSerializer(am);\n         if (serDef != null) {\n             bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n         }\n-        \n-        // [JACKSON-132]: Unwrapping\n+        // And then, handling of unwrapping\n         NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n         if (unwrapper != null) {\n             bpw = bpw.unwrappingWriter(unwrapper);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * {@link BeanPropertyWriter} implementation used with\n+ * {@link com.fasterxml.jackson.databind.annotation.JsonAppend}\n+ * to add \"virtual\" properties in addition to regular ones.\n+ * \n+ * @since 2.5\n+ * \n+ * @see com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter\n+ */\n+public abstract class VirtualBeanPropertyWriter\n+    extends BeanPropertyWriter\n+{\n+    /**\n+     * Constructor used by most sub-types.\n+     */\n+    protected VirtualBeanPropertyWriter(BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations, JavaType declaredType)\n+    {\n+        this(propDef, contextAnnotations, declaredType, null, null, null,\n+                propDef.findInclusion());\n+    }\n+\n+    /**\n+     * Constructor that may be used by sub-classes for constructing a \"blue-print\" instance;\n+     * one that will only become (or create) actual usable instance when its\n+     * {@link #withConfig} method is called.\n+     */\n+    protected VirtualBeanPropertyWriter() {\n+        super();\n+    }\n+\n+    /**\n+     * Pass-through constructor that may be used by sub-classes that\n+     * want full control over implementation.\n+     */\n+    protected VirtualBeanPropertyWriter(BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations, JavaType declaredType,\n+            JsonSerializer<?> ser, TypeSerializer typeSer, JavaType serType,\n+            JsonInclude.Include inclusion)\n+    {\n+        super(propDef, propDef.getPrimaryMember(), contextAnnotations, declaredType,\n+                ser, typeSer, serType,\n+                _suppressNulls(inclusion), _suppressableValue(inclusion));\n+    }\n+\n+    protected VirtualBeanPropertyWriter(VirtualBeanPropertyWriter base) {\n+        super(base);\n+    }\n+\n+    protected VirtualBeanPropertyWriter(VirtualBeanPropertyWriter base, PropertyName name) {\n+        super(base, name);\n+    }\n+\n+    protected static boolean _suppressNulls(JsonInclude.Include inclusion) {\n+        return (inclusion != JsonInclude.Include.ALWAYS);\n+    }\n+\n+    protected static Object _suppressableValue(JsonInclude.Include inclusion) {\n+        if ((inclusion == JsonInclude.Include.NON_EMPTY)\n+                || (inclusion == JsonInclude.Include.NON_EMPTY)) {\n+            return MARKER_FOR_EMPTY;\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard accessor overrides\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isVirtual() { return true; }\n+\n+    @Override\n+    public Class<?> getPropertyType() {\n+        return _declaredType.getRawClass();\n+    }\n+\n+    @Override\n+    public Type getGenericPropertyType() {\n+        return getPropertyType();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Abstract methods for sub-classes to define\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to figure out the value to serialize. For simple sub-types\n+     * (such as {@link com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter})\n+     * this may be one of few methods to define, although more advanced implementations\n+     * may choose to not even use this method (by overriding {@link #serializeAsField})\n+     * and define a bogus implementation.\n+     */\n+    protected abstract Object value(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception;\n+\n+    /**\n+     * Contextualization method called on a newly constructed virtual bean property.\n+     * Usually a new intance needs to be created due to finality of some of configuration\n+     * members; otherwise while recommended, creating a new instance is not strictly-speaking\n+     * mandatory because calls are made in thread-safe manner, as part of initialization\n+     * before use.\n+     *\n+     * @param config Currenct configuration; guaranteed to be {@link SerializationConfig}\n+     *   (just not typed since caller does not have dependency to serialization-specific types)\n+     * @param declaringClass Class that contains this property writer\n+     * @param propDef Nominal property definition to use\n+     * @param type Declared type for the property\n+     */\n+    public abstract VirtualBeanPropertyWriter withConfig(MapperConfig<?> config,\n+            AnnotatedClass declaringClass, BeanPropertyDefinition propDef, JavaType type);\n+\n+    /*\n+    /**********************************************************\n+    /* PropertyWriter serialization method overrides\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception\n+    {\n+        // NOTE: mostly copied from base class, but off-lined get() access\n+        final Object value = value(bean, gen, prov);\n+\n+        if (value == null) {\n+            if (_nullSerializer != null) {\n+                gen.writeFieldName(_name);\n+                _nullSerializer.serialize(null, gen, prov);\n+            }\n+            return;\n+        }\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap m = _dynamicSerializers;\n+            ser = m.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(m, cls, prov);\n+            }\n+        }\n+        if (_suppressableValue != null) {\n+            if (MARKER_FOR_EMPTY == _suppressableValue) {\n+                if (ser.isEmpty(value)) {\n+                    return;\n+                }\n+            } else if (_suppressableValue.equals(value)) {\n+                return;\n+            }\n+        }\n+        if (value == bean) { // simple check for direct cycles\n+            // three choices: exception; handled by call; or pass-through\n+            if (_handleSelfReference(bean, gen, prov, ser)) {\n+                return;\n+            }\n+        }\n+        gen.writeFieldName(_name);\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, gen, prov);\n+        } else {\n+            ser.serializeWithType(value, gen, prov, _typeSerializer);\n+        }\n+    }\n+\n+    // This one's fine as-is from base class\n+    //public void serializeAsOmittedField(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception\n+    \n+    @Override\n+    public void serializeAsElement(Object bean, JsonGenerator gen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        // NOTE: mostly copied from base class, but off-lined get() access\n+        final Object value = value(bean, gen, prov);\n+\n+        if (value == null) {\n+            if (_nullSerializer != null) {\n+                _nullSerializer.serialize(null, gen, prov);\n+            } else {\n+                gen.writeNull();\n+            }\n+            return;\n+        }\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+        if (_suppressableValue != null) {\n+            if (MARKER_FOR_EMPTY == _suppressableValue) {\n+                if (ser.isEmpty(value)) {\n+                    serializeAsPlaceholder(bean, gen, prov);\n+                    return;\n+                }\n+            } else if (_suppressableValue.equals(value)) {\n+                serializeAsPlaceholder(bean, gen, prov);\n+                return;\n+            }\n+        }\n+        if (value == bean) {\n+            if (_handleSelfReference(bean, gen, prov, ser)) {\n+                return;\n+            }\n+        }\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, gen, prov);\n+        } else {\n+            ser.serializeWithType(value, gen, prov, _typeSerializer);\n+        }\n+    }\n+\n+    // This one's fine as-is from base class\n+    //public void serializeAsPlaceholder(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/AttributePropertyWriter.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * {@link VirtualBeanPropertyWriter} implementation used for\n+ * {@link com.fasterxml.jackson.databind.annotation.JsonAppend},\n+ * to serialize properties backed-by dynamically assignable attribute\n+ * values.\n+ * \n+ * @since 2.5\n+ */\n+public class AttributePropertyWriter\n+    extends VirtualBeanPropertyWriter\n+{\n+    protected final String _attrName;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected AttributePropertyWriter(String attrName, BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations, JavaType declaredType) {\n+        this(attrName, propDef, contextAnnotations, declaredType, propDef.findInclusion());\n+    }\n+\n+    protected AttributePropertyWriter(String attrName, BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations, JavaType declaredType,\n+            JsonInclude.Include inclusion)\n+    {\n+        super(propDef, contextAnnotations, declaredType,\n+                /* value serializer */ null, /* type serializer */ null, /* ser type */ null,\n+                inclusion);\n+        _attrName = attrName;\n+    }\n+\n+    public static AttributePropertyWriter construct(String attrName,\n+            BeanPropertyDefinition propDef,\n+            Annotations contextAnnotations,\n+            JavaType declaredType)\n+    {\n+        return new AttributePropertyWriter(attrName, propDef,\n+                contextAnnotations, declaredType);\n+    }\n+    \n+    protected AttributePropertyWriter(AttributePropertyWriter base) {\n+        super(base);\n+        _attrName = base._attrName;\n+    }\n+\n+    /**\n+     * Since this method should typically not be called on this sub-type,\n+     * default implementation simply throws an {@link IllegalStateException}.\n+     */\n+    @Override\n+    public VirtualBeanPropertyWriter withConfig(MapperConfig<?> config,\n+            AnnotatedClass declaringClass, BeanPropertyDefinition propDef, JavaType type) {\n+        throw new IllegalStateException(\"Should not be called on this type\");\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overrides for actual serialization, value access\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    protected Object value(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception {\n+        return prov.getAttribute(_attrName);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n     /**********************************************************\n      */\n \n-    // Re-defined from base class...\n-    @Override\n-    public void serializeWithType(Object bean, JsonGenerator jgen,\n+    // Re-defined from base class, due to differing prefixes\n+    @Override\n+    public void serializeWithType(Object bean, JsonGenerator gen,\n             SerializerProvider provider, TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n-        /* Should not even get here; but let's be nice and re-route\n-         * if need be.\n+        /* 10-Dec-2014, tatu: Not sure if this can be made to work reliably;\n+         *   but for sure delegating to default implementation will not work. So:\n          */\n-        _defaultSerializer.serializeWithType(bean, jgen, provider, typeSer);\n-    }\n-    \n+        if (_objectIdWriter != null) {\n+            _serializeWithObjectId(bean, gen, provider, typeSer);\n+            return;\n+        }\n+        String typeStr = (_typeId == null) ? null : _customTypeId(bean);\n+        if (typeStr == null) {\n+            typeSer.writeTypePrefixForArray(bean, gen);\n+        } else {\n+            typeSer.writeCustomTypePrefixForArray(bean, gen, typeStr);\n+        }\n+        serializeAsArray(bean, gen, provider);\n+        if (typeStr == null) {\n+            typeSer.writeTypeSuffixForArray(bean, gen);\n+        } else {\n+            typeSer.writeCustomTypeSuffixForArray(bean, gen, typeStr);\n+        }\n+    }\n+\n     /**\n      * Main serialization method that will delegate actual output to\n      * configured\n      * {@link BeanPropertyWriter} instances.\n      */\n     @Override\n-    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public final void serialize(Object bean, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         // [JACKSON-805]\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(provider)) {\n-            serializeAsArray(bean, jgen, provider);\n+            serializeAsArray(bean, gen, provider);\n             return;\n         }\n         /* note: it is assumed here that limitations (type id, object id,\n          * any getter, filtering) have already been checked; so code here\n          * is trivial.\n          */\n-        jgen.writeStartArray();\n-        serializeAsArray(bean, jgen, provider);\n-        jgen.writeEndArray();\n+        gen.writeStartArray();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(bean);\n+        serializeAsArray(bean, gen, provider);\n+        gen.writeEndArray();\n     }\n \n     /*\n         return props.length == 1;\n     }\n \n-    protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    protected final void serializeAsArray(Object bean, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         final BeanPropertyWriter[] props;\n         if (_filteredProps != null && provider.getActiveView() != null) {\n             for (final int len = props.length; i < len; ++i) {\n                 BeanPropertyWriter prop = props[i];\n                 if (prop == null) { // can have nulls in filtered list; but if so, MUST write placeholders\n-                    jgen.writeNull();\n+                    gen.writeNull();\n                 } else {\n-                    prop.serializeAsElement(bean, jgen, provider);\n+                    prop.serializeAsElement(bean, gen, provider);\n                 }\n             }\n             // NOTE: any getters can not be supported either\n             //if (_anyGetterWriter != null) {\n-            //    _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+            //    _anyGetterWriter.getAndSerialize(bean, gen, provider);\n             //}\n         } catch (Exception e) {\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedListSerializer.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n import java.io.IOException;\n-import java.util.LinkedList;\n-import java.util.List;\n+import java.util.*;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n     public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) {\n         return new IndexedListSerializer(_elementType, _staticTyping, vts, _property, _elementSerializer);\n     }\n+\n+    @Override\n+    public final void serialize(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+    \tfinal int len = value.size();\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n     public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider)\n                 }\n             }\n         } catch (Exception e) {\n-            // [JACKSON-55] Need to add reference information\n             wrapAndThrow(provider, e, value, i);\n         }\n     }\n     \n     public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider,\n             JsonSerializer<Object> ser)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         final int len = value.size();\n         if (len == 0) {\n     }\n \n     public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         final int len = value.size();\n         if (len == 0) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n             return;\n         }\n         \n-        jgen.writeStartArray();\n+        jgen.writeStartArray(len);\n         if (_serializer == null) {\n             serializeContents(value, jgen, provider, len);\n         } else {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IteratorSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IteratorSerializer.java\n import java.io.IOException;\n import java.util.Iterator;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n     }\n \n     @Override\n+    public final void serialize(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+        if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray();\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n+    \n+    @Override\n     public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         if (value.hasNext()) {\n             final TypeSerializer typeSer = _valueTypeSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java\n      */\n \n     @Override\n-    public void serialize(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider)\n+    public void serialize(Map.Entry<?, ?> value, JsonGenerator gen, SerializerProvider provider)\n         throws IOException\n     {\n-        jgen.writeStartObject();\n+        gen.writeStartObject();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (_valueSerializer != null) {\n-            serializeUsing(value, jgen, provider, _valueSerializer);\n-        } else {\n-            serializeDynamic(value, jgen, provider);\n-        }\n-        jgen.writeEndObject();\n-    }\n-\n-    @Override\n-    public void serializeWithType(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider,\n+            serializeUsing(value, gen, provider, _valueSerializer);\n+        } else {\n+            serializeDynamic(value, gen, provider);\n+        }\n+        gen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(Map.Entry<?, ?> value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer) throws IOException\n     {\n-        typeSer.writeTypePrefixForObject(value, jgen);\n+        typeSer.writeTypePrefixForObject(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (_valueSerializer != null) {\n-            serializeUsing(value, jgen, provider, _valueSerializer);\n-        } else {\n-            serializeDynamic(value, jgen, provider);\n-        }\n-        typeSer.writeTypeSuffixForObject(value, jgen);\n+            serializeUsing(value, gen, provider, _valueSerializer);\n+        } else {\n+            serializeDynamic(value, gen, provider);\n+        }\n+        typeSer.writeTypeSuffixForObject(value, gen);\n     }\n \n     protected void serializeDynamic(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n     extends FilterProvider\n     implements java.io.Serializable // since 2.1\n {\n-    // for 2.3.0\n-    private static final long serialVersionUID = -6305772546718366447L;\n+    // for 2.5+\n+    private static final long serialVersionUID = 1L;\n \n     /**\n      * Mappings from ids to filters.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n     /* Actual serialization\n     /**********************************************************\n      */\n+    \n+    @Override\n+    public final void serialize(String[] value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+    \tfinal int len = value.length;\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n     public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n         throws IOException, JsonGenerationException\n     {\n         // [JACKSON-805]\n-        if ((value.size() == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+    \tfinal int len = value.size();\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n             _serializeUnwrapped(value, jgen, provider);\n             return;\n         }      \n-        jgen.writeStartArray();\n+        jgen.writeStartArray(len);\n         if (_serializer == null) {\n             serializeContents(value, jgen, provider);\n         } else {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n         super(src._handledType, false);\n         _property = property;\n     }\n-    \n+\n+    // NOTE: as of 2.5, sub-classes SHOULD override (in 2.4 and before, was final),\n+    // at least if they can provide access to actual size of value and use `writeStartArray()`\n+    // variant that passes size of array to output, which is helpful with some data formats\n     @Override\n-    public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serialize(T value, JsonGenerator gen, SerializerProvider provider) throws IOException\n     {\n-        // [JACKSON-805]\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(value)) {\n-            serializeContents(value, jgen, provider);\n+            serializeContents(value, gen, provider);\n             return;\n         }\n-        jgen.writeStartArray();\n-        serializeContents(value, jgen, provider);\n-        jgen.writeEndArray();\n+        gen.writeStartArray();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        gen.writeEndArray();\n+    }\n+\n+    @Override\n+    public final void serializeWithType(T value, JsonGenerator gen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException\n+    {\n+        // note: let's NOT consider [JACKSON-805] here; gets too complicated, and probably just won't work\n+        typeSer.writeTypePrefixForArray(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        typeSer.writeTypeSuffixForArray(value, gen);\n     }\n     \n-    @Override\n-    public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n-    {\n-        // note: let's NOT consider [JACKSON-805] here; gets too complicated, and probably just won't work\n-        typeSer.writeTypePrefixForArray(value, jgen);\n-        serializeContents(value, jgen, provider);\n-        typeSer.writeTypeSuffixForArray(value, jgen);\n-    }\n-\n     protected abstract void serializeContents(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n     /* Serialization\n     /**********************************************************\n      */\n-    \n-    @Override\n-    public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n-        // [JACKSON-805]\n+\n+    // NOTE: as of 2.5, sub-classes SHOULD override (in 2.4 and before, was final),\n+    // at least if they can provide access to actual size of value and use `writeStartArray()`\n+    // variant that passes size of array to output, which is helpful with some data formats\n+    @Override\n+    public void serialize(T value, JsonGenerator gen, SerializerProvider provider) throws IOException\n+    {\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(value)) {\n-            serializeContents(value, jgen, provider);\n+            serializeContents(value, gen, provider);\n             return;\n         }\n-        jgen.writeStartArray();\n-        serializeContents(value, jgen, provider);\n-        jgen.writeEndArray();\n-    }\n-\n-    // Note: was 'final' modifier in 2.2 and before; no real need to be, removed\n-    @Override\n-    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        gen.writeStartArray();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        gen.writeEndArray();\n+    }\n+\n+    @Override\n+    public void serializeWithType(T value, JsonGenerator gen, SerializerProvider provider,\n+            TypeSerializer typeSer) throws IOException\n     {\n         // note: let's NOT consider [JACKSON-805] here; gets too complicated, and probably just won't work\n-        typeSer.writeTypePrefixForArray(value, jgen);\n-        serializeContents(value, jgen, provider);\n-        typeSer.writeTypeSuffixForArray(value, jgen);\n-    }\n-\n-    protected abstract void serializeContents(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException;\n+        typeSer.writeTypePrefixForArray(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n+        serializeContents(value, gen, provider);\n+        typeSer.writeTypeSuffixForArray(value, gen);\n+    }\n+\n+    protected abstract void serializeContents(T value, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException;\n \n     @SuppressWarnings(\"deprecation\")\n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n      * reference to that member.\n      */\n     final protected AnnotatedMember _typeId;\n-    \n+\n     /**\n      * If this POJO can be alternatively serialized using just an object id\n      * to denote a reference to previously serialized object,\n      * Requested shape from bean class annotations.\n      */\n     final protected JsonFormat.Shape _serializationShape;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle: constructors\n     {\n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n         if (intr != null) {\n-            Object convDef = intr.findSerializationConverter(prop.getMember());\n-            if (convDef != null) {\n-                Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n-                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n-                JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n-                return new StdDelegatingSerializer(conv, delegateType, ser);\n+            AnnotatedMember m = prop.getMember();\n+            if (m != null) {\n+                Object convDef = intr.findSerializationConverter(m);\n+                if (convDef != null) {\n+                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n+                    JsonSerializer<?> ser = provider.findValueSerializer(delegateType, prop);\n+                    return new StdDelegatingSerializer(conv, delegateType, ser);\n+                }\n             }\n         }\n         return null;\n     }\n \n+    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n     {\n+        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+        final AnnotatedMember accessor = (property == null || intr == null)\n+                ? null : property.getMember();\n+        final SerializationConfig config = provider.getConfig();\n+        \n+        // Let's start with one big transmutation: Enums that are annotated\n+        // to serialize as Objects may want to revert\n+        JsonFormat.Shape shape = null;\n+        if (accessor != null) {\n+            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+\n+            if (format != null) {\n+                shape = format.getShape();\n+                // or, alternatively, asked to revert \"back to\" other representations...\n+                if (shape != _serializationShape) {\n+                    if (_handledType.isEnum()) {\n+                        switch (shape) {\n+                        case STRING:\n+                        case NUMBER:\n+                        case NUMBER_INT:\n+                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n+                            //   for now, just do class ones\n+                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n+                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType,\n+                                    provider.getConfig(), desc, format);\n+                            return provider.handlePrimaryContextualization(ser, property);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         ObjectIdWriter oiw = _objectIdWriter;\n         String[] ignorals = null;\n         Object newFilterId = null;\n-        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n-        final AnnotatedMember accessor = (property == null || intr == null)\n-                ? null : property.getMember();\n         \n-        // First: may have an override for Object Id:\n+        // Then we may have an override for Object Id\n         if (accessor != null) {\n             ignorals = intr.findPropertiesToIgnore(accessor);\n             ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n         if (newFilterId != null) {\n             contextual = contextual.withFilterId(newFilterId);\n         }\n-        \n-        // One more thing: are we asked to serialize POJO as array?\n-        JsonFormat.Shape shape = null;\n-        if (accessor != null) {\n-            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n-\n-            if (format != null) {\n-                shape = format.getShape();\n-            }\n-        }\n         if (shape == null) {\n             shape = _serializationShape;\n         }\n         if (shape == JsonFormat.Shape.ARRAY) {\n-            contextual = contextual.asArraySerializer();\n+            return contextual.asArraySerializer();\n         }\n         return contextual;\n     }\n     // Main serialization method left unimplemented\n     @Override\n     public abstract void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n \n     // Type-info-augmented case implemented as it does not usually differ between impls\n     @Override\n-    public void serializeWithType(Object bean, JsonGenerator jgen,\n+    public void serializeWithType(Object bean, JsonGenerator gen,\n             SerializerProvider provider, TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         if (_objectIdWriter != null) {\n-            _serializeWithObjectId(bean, jgen, provider, typeSer);\n+            _serializeWithObjectId(bean, gen, provider, typeSer);\n             return;\n         }\n \n-        String typeStr = (_typeId == null) ? null :_customTypeId(bean);\n+        String typeStr = (_typeId == null) ? null : _customTypeId(bean);\n         if (typeStr == null) {\n-            typeSer.writeTypePrefixForObject(bean, jgen);\n-        } else {\n-            typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr);\n+            typeSer.writeTypePrefixForObject(bean, gen);\n+        } else {\n+            typeSer.writeCustomTypePrefixForObject(bean, gen, typeStr);\n         }\n         if (_propertyFilterId != null) {\n-            serializeFieldsFiltered(bean, jgen, provider);\n-        } else {\n-            serializeFields(bean, jgen, provider);\n+            serializeFieldsFiltered(bean, gen, provider);\n+        } else {\n+            serializeFields(bean, gen, provider);\n         }\n         if (typeStr == null) {\n-            typeSer.writeTypeSuffixForObject(bean, jgen);\n-        } else {\n-            typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr);\n+            typeSer.writeTypeSuffixForObject(bean, gen);\n+        } else {\n+            typeSer.writeCustomTypeSuffixForObject(bean, gen, typeStr);\n         }\n     }\n \n         }\n     }\n     \n-    private final String _customTypeId(Object bean)\n+    protected final String _customTypeId(Object bean)\n     {\n         final Object typeId = _typeId.getValue(bean);\n         if (typeId == null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n         it.next();\n         return !it.hasNext();\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Actual serialization\n     /**********************************************************\n      */\n+\n+    @Override\n+    public final void serialize(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+    \tfinal int len = value.size();\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n-    public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n         if (_elementSerializer != null) {\n             serializeContentsUsing(value, jgen, provider, _elementSerializer);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n         //todo: (ryan) add a format for the date in the schema?\n         return createSchemaNode(_asTimestamp(provider) ? \"number\" : \"string\", true);\n     }\n-    \n+\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n  * Specialized serializer for {@link EnumMap}s. Somewhat tricky to\n  * implement because actual Enum value type may not be available;\n  * and if not, it can only be gotten from actual instance.\n+ * \n+ * @deprecated Since 2.4.4; standard {@link MapSerializer} works better.\n+ *   (to be removed from 2.6)\n  */\n @JacksonStdImpl\n+@Deprecated\n public class EnumMapSerializer\n     extends ContainerSerializer<EnumMap<? extends Enum<?>, ?>>\n     implements ContextualSerializer\n         }\n     }\n     \n-    @SuppressWarnings({ \"unchecked\", \"deprecation\" })\n+    @SuppressWarnings({ \"unchecked\" })\n     @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n      * \n      * @since 2.1\n      */\n-    public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config,\n+    @SuppressWarnings(\"unchecked\")\n+    public static EnumSerializer construct(Class<?> enumClass, SerializationConfig config,\n             BeanDescription beanDesc, JsonFormat.Value format)\n     {\n         // [JACKSON-212]: If toString() is to be used instead, leave EnumValues null\n-        EnumValues v = EnumValues.construct(config, enumClass);\n+        EnumValues v = EnumValues.construct(config, (Class<Enum<?>>) enumClass);\n         Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);\n         return new EnumSerializer(v, serializeAsIndex);\n     }\n     \n     @Override\n     public final void serialize(Enum<?> en, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         // [JACKSON-684]: serialize as index?\n         if (_serializeAsIndex(provider)) {\n     \n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-            throws JsonMappingException\n+        throws JsonMappingException\n     {\n         // [JACKSON-684]: serialize as index?\n-        if (visitor.getProvider().isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n+        if (_serializeAsIndex(visitor.getProvider())) {\n             JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n             if (v2 != null) { // typically serialized as a small number (byte or int)\n                 v2.numberType(JsonParser.NumberType.INT);\n         if (shape == Shape.STRING) {\n             return Boolean.FALSE;\n         }\n-        if (shape.isNumeric()) {\n+        // 01-Oct-2014, tatu: For convenience, consider \"as-array\" to also mean 'yes, use index')\n+        if (shape.isNumeric() || (shape == Shape.ARRAY)) {\n             return Boolean.TRUE;\n         }\n         throw new IllegalArgumentException(\"Unsupported serialization shape (\"+shape+\") for Enum \"+enumClass.getName()\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.util.EnumSet;\n+import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n     public boolean hasSingleElement(EnumSet<? extends Enum<?>> value) {\n         return value.size() == 1;\n     }\n+\n+    @Override\n+    public final void serialize(EnumSet<? extends Enum<?>> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+    \tfinal int len = value.size();\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n     public void serializeContents(EnumSet<? extends Enum<?>> value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.util.Iterator;\n+import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n         }\n         return false;\n     }\n+\n+    @Override\n+    public final void serialize(Iterable<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+        if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray();\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n     public void serializeContents(Iterable<?> value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n import java.lang.reflect.Type;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.ser.PropertyFilter;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.ArrayBuilders;\n \n /**\n  * Standard serializer implementation for serializing {link java.util.Map} types.\n     implements ContextualSerializer\n {\n     protected final static JavaType UNSPECIFIED_TYPE = TypeFactory.unknownType();\n-    \n+\n     /**\n      * Map-valued property being serialized with this instance\n      */\n     protected final BeanProperty _property;\n-    \n+\n     /**\n      * Set of entries to omit during serialization, if any\n      */\n      * Key serializer to use, if it can be statically determined\n      */\n     protected JsonSerializer<Object> _keySerializer;\n-    \n+\n     /**\n      * Value serializer to use, if it can be statically determined\n      */\n      * @since 2.4\n      */\n     protected final boolean _sortKeys;\n-    \n+\n+    /**\n+     * Value that indicates suppression mechanism to use; either one of\n+     * values of {@link com.fasterxml.jackson.annotation.JsonInclude.Include}, or actual object to compare\n+     * against (\"default value\")\n+     * \n+     * @since 2.5\n+     */\n+    protected final Object _suppressableValue;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n     /**********************************************************\n      */\n     \n+    /**\n+     * @since 2.5\n+     */\n     @SuppressWarnings(\"unchecked\")\n     protected MapSerializer(HashSet<String> ignoredEntries,\n             JavaType keyType, JavaType valueType, boolean valueTypeIsStatic,\n         _property = null;\n         _filterId = null;\n         _sortKeys = false;\n-    }\n-\n+        _suppressableValue = null;\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected void _ensureOverride() {\n+        if (getClass() != MapSerializer.class) {\n+            throw new IllegalStateException(\"Missing override in class \"+getClass().getName());\n+        }\n+    }\n+    \n     @SuppressWarnings(\"unchecked\")\n     protected MapSerializer(MapSerializer src, BeanProperty property,\n             JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer,\n         _property = property;\n         _filterId = src._filterId;\n         _sortKeys = src._sortKeys;\n-    }\n-\n-    protected MapSerializer(MapSerializer src, TypeSerializer vts)\n+        _suppressableValue = src._suppressableValue;\n+    }\n+\n+    @Deprecated // since 2.5\n+    protected MapSerializer(MapSerializer src, TypeSerializer vts) {\n+        this(src, vts, src._suppressableValue);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected MapSerializer(MapSerializer src, TypeSerializer vts,\n+            Object suppressableValue)\n     {\n         super(Map.class, false);\n         _ignoredEntries = src._ignoredEntries;\n         _property = src._property;\n         _filterId = src._filterId;\n         _sortKeys = src._sortKeys;\n+        _suppressableValue = suppressableValue;\n     }\n \n     protected MapSerializer(MapSerializer src, Object filterId, boolean sortKeys)\n         _property = src._property;\n         _filterId = filterId;\n         _sortKeys = sortKeys;\n-    }\n-    \n+        _suppressableValue = src._suppressableValue;\n+    }\n+\n     @Override\n     public MapSerializer _withValueTypeSerializer(TypeSerializer vts) {\n-        return new MapSerializer(this, vts);\n+        if (_valueTypeSerializer == vts) {\n+            return this;\n+        }\n+        _ensureOverride();\n+        return new MapSerializer(this, vts, null);\n     }\n \n     /**\n             JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer,\n             HashSet<String> ignored, boolean sortKeys)\n     {\n+        _ensureOverride();\n         MapSerializer ser = new MapSerializer(this, property, keySerializer, valueSerializer, ignored);\n         if (sortKeys != ser._sortKeys) {\n             ser = new MapSerializer(ser, _filterId, sortKeys);\n         }\n         return ser;\n     }\n-    \n+\n     /**\n      * @since 2.3\n      */\n     public MapSerializer withFilterId(Object filterId) {\n-        return (_filterId == filterId) ? this : new MapSerializer(this, filterId, _sortKeys);\n-    }\n-\n+        if (_filterId == filterId) {\n+            return this;\n+        }\n+        _ensureOverride();\n+        return new MapSerializer(this, filterId, _sortKeys);\n+    }\n+\n+    /**\n+     * Mutant factory for constructing an instance with different inclusion strategy\n+     * for content (Map values).\n+     * \n+     * @since 2.5\n+     */\n+    public MapSerializer withContentInclusion(Object suppressableValue) {\n+        if (suppressableValue == _suppressableValue) {\n+            return this;\n+        }\n+        _ensureOverride();\n+        return new MapSerializer(this, _valueTypeSerializer, suppressableValue);\n+    }                \n+    \n     /**\n      * @since 2.3\n      */\n             JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer,\n             Object filterId)\n     {\n-        HashSet<String> ignoredEntries = toSet(ignoredList);\n+        HashSet<String> ignoredEntries = (ignoredList == null || ignoredList.length == 0)\n+                ? null : ArrayBuilders.arrayToSet(ignoredList);\n+\n         JavaType keyType, valueType;\n         \n         if (mapType == null) {\n             ser = ser.withFilterId(filterId);\n         }\n         return ser;\n-    }\n-\n-    private static HashSet<String> toSet(String[] ignoredEntries) {\n-        if (ignoredEntries == null || ignoredEntries.length == 0) {\n-            return null;\n-        }\n-        HashSet<String> result = new HashSet<String>(ignoredEntries.length);\n-        for (String prop : ignoredEntries) {\n-            result.add(prop);\n-        }\n-        return result;\n     }\n \n     /*\n         JsonSerializer<?> keySer = null;\n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n         final AnnotatedMember propertyAcc = (property == null) ? null : property.getMember();\n+        Object suppressableValue = _suppressableValue;\n \n         // First: if we have a property, may have property-annotation overrides\n         if (propertyAcc != null && intr != null) {\n             serDef = intr.findContentSerializer(propertyAcc);\n             if (serDef != null) {\n                 ser = provider.serializerInstance(propertyAcc, serDef);\n+            }\n+            JsonInclude.Include incl = intr.findSerializationInclusionForContent(propertyAcc, null);\n+            if (incl != null) {\n+                suppressableValue = incl;\n             }\n         }\n         if (ser == null) {\n             sortKeys = (b != null) && b.booleanValue();\n         }\n         MapSerializer mser = withResolved(property, keySer, ser, ignored, sortKeys);\n+        if (suppressableValue != _suppressableValue) {\n+            mser = mser.withContentInclusion(suppressableValue);\n+        }\n \n         // [Issue#307]: allow filtering\n         if (property != null) {\n-            Object filterId = intr.findFilterId(property.getMember());\n-            if (filterId != null) {\n-                mser = mser.withFilterId(filterId);\n+            AnnotatedMember m = property.getMember();\n+            if (m != null) {\n+                Object filterId = intr.findFilterId(m);\n+                if (filterId != null) {\n+                    mser = mser.withFilterId(filterId);\n+                }\n             }\n         }\n         return mser;\n      */\n \n     @Override\n-    public void serialize(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n-        jgen.writeStartObject();\n+    public void serialize(Map<?,?> value, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n+    {\n+        gen.writeStartObject();\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (!value.isEmpty()) {\n-            if (_filterId != null) {\n-                serializeFilteredFields(value, jgen, provider,\n-                        findPropertyFilter(provider, _filterId, value));\n-                jgen.writeEndObject();\n-                return;\n+            Object suppressableValue = _suppressableValue;\n+            if (suppressableValue == null) {\n+                if (!provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)) {\n+                    suppressableValue = JsonInclude.Include.NON_NULL;\n+                }\n+            } else if (suppressableValue == JsonInclude.Include.ALWAYS) {\n+                suppressableValue = null;\n             }\n             if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n                 value = _orderEntries(value);\n             }\n-            if (_valueSerializer != null) {\n-                serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n-            } else {\n-                serializeFields(value, jgen, provider);\n-            }\n-        }\n-        jgen.writeEndObject();\n-    }\n-\n-    @Override\n-    public void serializeWithType(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+            if (_filterId != null) {\n+                serializeFilteredFields(value, gen, provider,\n+                        findPropertyFilter(provider, _filterId, value), suppressableValue);\n+            } else if (suppressableValue != null) {\n+                serializeOptionalFields(value, gen, provider, suppressableValue);\n+            } else if (_valueSerializer != null) {\n+                serializeFieldsUsing(value, gen, provider, _valueSerializer);\n+            } else {\n+                serializeFields(value, gen, provider);\n+            }\n+        }\n+        gen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n-    {\n-        typeSer.writeTypePrefixForObject(value, jgen);\n+        throws IOException\n+    {\n+        typeSer.writeTypePrefixForObject(value, gen);\n+        // [databind#631]: Assign current value, to be accessible by custom serializers\n+        gen.setCurrentValue(value);\n         if (!value.isEmpty()) {\n+            Object suppressableValue = _suppressableValue;\n+            if (suppressableValue == null) {\n+                if (!provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)) {\n+                    suppressableValue = JsonInclude.Include.NON_NULL;\n+                }\n+            } else if (suppressableValue == JsonInclude.Include.ALWAYS) {\n+                suppressableValue = null;\n+            }\n             if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n                 value = _orderEntries(value);\n             }\n-            if (_valueSerializer != null) {\n-                serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n-            } else {\n-                serializeFields(value, jgen, provider);\n-            }\n-        }\n-        typeSer.writeTypeSuffixForObject(value, jgen);\n+            if (_filterId != null) {\n+                serializeFilteredFields(value, gen, provider,\n+                        findPropertyFilter(provider, _filterId, value), suppressableValue);\n+            } else if (suppressableValue != null) {\n+                serializeOptionalFields(value, gen, provider, suppressableValue);\n+            } else if (_valueSerializer != null) {\n+                serializeFieldsUsing(value, gen, provider, _valueSerializer);\n+            } else {\n+                serializeFields(value, gen, provider);\n+            }\n+        }\n+        typeSer.writeTypeSuffixForObject(value, gen);\n     }\n \n     /*\n      */\n     \n     /**\n-     * Method called to serialize fields, when the value type is not statically known.\n-     */\n-    public void serializeFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+     * Method called to serialize fields, when the value type is not statically known;\n+     * but we know that no value suppression is needed (which simplifies processing a bit)\n+     */\n+    public void serializeFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException\n     {\n         // If value type needs polymorphic type handling, some more work needed:\n         if (_valueTypeSerializer != null) {\n-            serializeTypedFields(value, jgen, provider);\n+            serializeTypedFields(value, gen, provider, null);\n             return;\n         }\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n-        \n         final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         PropertySerializerMap serializers = _dynamicValueSerializers;\n \n             // First, serialize key\n             Object keyElem = entry.getKey();\n             if (keyElem == null) {\n-                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n-            } else {\n-                // [JACKSON-314] skip entries with null values?\n-                if (skipNulls && valueElem == null) continue;\n+                provider.findNullKeySerializer(_keyType, _property).serialize(null, gen, provider);\n+            } else {\n                 // One twist: is entry ignorable? If so, skip\n                 if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySerializer.serialize(keyElem, jgen, provider);\n+                keySerializer.serialize(keyElem, gen, provider);\n             }\n \n             // And then value\n             if (valueElem == null) {\n-                provider.defaultSerializeNull(jgen);\n+                provider.defaultSerializeNull(gen);\n             } else {\n                 Class<?> cc = valueElem.getClass();\n                 JsonSerializer<Object> serializer = serializers.serializerFor(cc);\n                     serializers = _dynamicValueSerializers;\n                 }\n                 try {\n-                    serializer.serialize(valueElem, jgen, provider);\n+                    serializer.serialize(valueElem, gen, provider);\n                 } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n+                    // Add reference information\n                     String keyDesc = \"\"+keyElem;\n                     wrapAndThrow(provider, e, value, keyDesc);\n                 }\n         }\n     }\n \n+    public void serializeOptionalFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n+            Object suppressableValue)\n+        throws IOException\n+    {\n+        // If value type needs polymorphic type handling, some more work needed:\n+        if (_valueTypeSerializer != null) {\n+            serializeTypedFields(value, gen, provider, suppressableValue);\n+            return;\n+        }\n+        final HashSet<String> ignored = _ignoredEntries;\n+        PropertySerializerMap serializers = _dynamicValueSerializers;\n+\n+        for (Map.Entry<?,?> entry : value.entrySet()) {\n+            // First find key serializer\n+            final Object keyElem = entry.getKey();\n+            JsonSerializer<Object> keySerializer;\n+            if (keyElem == null) {\n+                keySerializer = provider.findNullKeySerializer(_keyType, _property);\n+            } else {\n+                if (ignored != null && ignored.contains(keyElem)) continue;\n+                keySerializer = _keySerializer;\n+            }\n+\n+            // Then value serializer\n+            final Object valueElem = entry.getValue();\n+            JsonSerializer<Object> valueSer;\n+            if (valueElem == null) {\n+                if (suppressableValue != null) { // all suppressions include null-suppression\n+                    continue;\n+                }\n+                valueSer = provider.getDefaultNullValueSerializer();\n+            } else {\n+                valueSer = _valueSerializer;\n+                if (valueSer == null) {\n+                    Class<?> cc = valueElem.getClass();\n+                    valueSer = serializers.serializerFor(cc);\n+                    if (valueSer == null) {\n+                        if (_valueType.hasGenericTypes()) {\n+                            valueSer = _findAndAddDynamic(serializers,\n+                                    provider.constructSpecializedType(_valueType, cc), provider);\n+                        } else {\n+                            valueSer = _findAndAddDynamic(serializers, cc, provider);\n+                        }\n+                        serializers = _dynamicValueSerializers;\n+                    }\n+                }\n+                // also may need to skip non-empty values:\n+                if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n+                        && valueSer.isEmpty(valueElem)) {\n+                    continue;\n+                }\n+            }\n+            // and then serialize, if all went well\n+            try {\n+                keySerializer.serialize(keyElem, gen, provider);\n+                valueSer.serialize(valueElem, gen, provider);\n+            } catch (Exception e) {\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+    \n     /**\n      * Method called to serialize fields, when the value type is statically known,\n      * so that value serializer is passed and does not need to be fetched from\n      * provider.\n      */\n-    protected void serializeFieldsUsing(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+    protected void serializeFieldsUsing(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n             JsonSerializer<Object> ser)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n         final HashSet<String> ignored = _ignoredEntries;\n         final TypeSerializer typeSer = _valueTypeSerializer;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n-            Object valueElem = entry.getValue();\n             Object keyElem = entry.getKey();\n+            if (ignored != null && ignored.contains(keyElem)) continue;\n+\n             if (keyElem == null) {\n-                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n-            } else {\n-                // [JACKSON-314] also may need to skip entries with null values\n-                if (skipNulls && valueElem == null) continue;\n-                if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySerializer.serialize(keyElem, jgen, provider);\n-            }\n+                provider.findNullKeySerializer(_keyType, _property).serialize(null, gen, provider);\n+            } else {\n+                keySerializer.serialize(keyElem, gen, provider);\n+            }\n+            final Object valueElem = entry.getValue();\n             if (valueElem == null) {\n-                provider.defaultSerializeNull(jgen);\n+                provider.defaultSerializeNull(gen);\n             } else {\n                 try {\n                     if (typeSer == null) {\n-                        ser.serialize(valueElem, jgen, provider);\n+                        ser.serialize(valueElem, gen, provider);\n                     } else {\n-                        ser.serializeWithType(valueElem, jgen, provider, typeSer);\n+                        ser.serializeWithType(valueElem, gen, provider, typeSer);\n                     }\n                 } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n                     String keyDesc = \"\"+keyElem;\n                     wrapAndThrow(provider, e, value, keyDesc);\n                 }\n     /**\n      * Helper method used when we have a JSON Filter to use for potentially\n      * filtering out Map entries.\n-     *<p>\n-     * NOTE: initially only called externally, by <code>AnyGetterWriter</code>\n      * \n-     * @since 2.3\n-     */\n-    public void serializeFilteredFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n-            PropertyFilter filter)\n-        throws IOException, JsonGenerationException\n+     * @since 2.5\n+     */\n+    public void serializeFilteredFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n+            PropertyFilter filter,\n+            Object suppressableValue) // since 2.5\n+        throws IOException\n     {\n         final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         PropertySerializerMap serializers = _dynamicValueSerializers;\n         final MapProperty prop = new MapProperty(_valueTypeSerializer, _property);\n \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n-            // First, serialize key\n+            // First, serialize key; unless ignorable by key\n             final Object keyElem = entry.getKey();\n+            if (ignored != null && ignored.contains(keyElem)) continue;\n+\n+            JsonSerializer<Object> keySerializer;\n+            if (keyElem == null) {\n+                keySerializer = provider.findNullKeySerializer(_keyType, _property);\n+            } else {\n+                keySerializer = _keySerializer;\n+            }\n+            // or by value; nulls often suppressed\n             final Object valueElem = entry.getValue();\n-            JsonSerializer<Object> keySer;\n-            if (keyElem == null) {\n-                keySer = provider.findNullKeySerializer(_keyType, _property);\n-            } else {\n-                // [JACKSON-314] skip entries with null values?\n-                if (skipNulls && valueElem == null) continue;\n-                // One twist: is entry ignorable? If so, skip\n-                if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySer = _keySerializer;\n-            }\n+\n             JsonSerializer<Object> valueSer;\n             // And then value\n             if (valueElem == null) {\n+                if (suppressableValue != null) { // all suppressions include null-suppression\n+                    continue;\n+                }\n                 valueSer = provider.getDefaultNullValueSerializer();\n             } else {\n+                valueSer = _valueSerializer;\n+                if (valueSer == null) {\n+                    Class<?> cc = valueElem.getClass();\n+                    valueSer = serializers.serializerFor(cc);\n+                    if (valueSer == null) {\n+                        if (_valueType.hasGenericTypes()) {\n+                            valueSer = _findAndAddDynamic(serializers,\n+                                    provider.constructSpecializedType(_valueType, cc), provider);\n+                        } else {\n+                            valueSer = _findAndAddDynamic(serializers, cc, provider);\n+                        }\n+                        serializers = _dynamicValueSerializers;\n+                    }\n+                }\n+                // also may need to skip non-empty values:\n+                if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n+                        && valueSer.isEmpty(valueElem)) {\n+                    continue;\n+                }\n+            }\n+            // and with that, ask filter to handle it\n+            prop.reset(keyElem, keySerializer, valueSer);\n+            try {\n+                filter.serializeAsField(valueElem, gen, provider, prop);\n+            } catch (Exception e) {\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+\n+    @Deprecated // since 2.5\n+    public void serializeFilteredFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n+            PropertyFilter filter) throws IOException {\n+        serializeFilteredFields(value, gen, provider, filter,\n+                provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES) ? null : JsonInclude.Include.NON_NULL);\n+    }\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    protected void serializeTypedFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n+            Object suppressableValue) // since 2.5\n+        throws IOException\n+    {\n+        final HashSet<String> ignored = _ignoredEntries;\n+        PropertySerializerMap serializers = _dynamicValueSerializers;\n+\n+        for (Map.Entry<?,?> entry : value.entrySet()) {\n+            Object keyElem = entry.getKey();\n+            JsonSerializer<Object> keySerializer;\n+            if (keyElem == null) {\n+                keySerializer = provider.findNullKeySerializer(_keyType, _property);\n+            } else {\n+                // One twist: is entry ignorable? If so, skip\n+                if (ignored != null && ignored.contains(keyElem)) continue;\n+                keySerializer = _keySerializer;\n+            }\n+            final Object valueElem = entry.getValue();\n+    \n+            // And then value\n+            JsonSerializer<Object> valueSer;\n+            if (valueElem == null) {\n+                if (suppressableValue != null) { // all suppression include null suppression\n+                    continue;\n+                }\n+                valueSer = provider.getDefaultNullValueSerializer();\n+                keySerializer.serialize(keyElem, gen, provider);\n+                provider.defaultSerializeNull(gen);\n+            } else {\n+                valueSer = _valueSerializer;\n                 Class<?> cc = valueElem.getClass();\n                 valueSer = serializers.serializerFor(cc);\n                 if (valueSer == null) {\n                     }\n                     serializers = _dynamicValueSerializers;\n                 }\n-            }\n-            prop.reset(keyElem, keySer, valueSer);\n+                // also may need to skip non-empty values:\n+                if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n+                        && valueSer.isEmpty(valueElem)) {\n+                    continue;\n+                }\n+            }\n+            keySerializer.serialize(keyElem, gen, provider);\n             try {\n-                filter.serializeAsField(valueElem, jgen, provider, prop);\n+                valueSer.serializeWithType(valueElem, gen, provider, _valueTypeSerializer);\n             } catch (Exception e) {\n-                // [JACKSON-55] Need to add reference information\n                 String keyDesc = \"\"+keyElem;\n                 wrapAndThrow(provider, e, value, keyDesc);\n             }\n         }\n     }\n-    \n-    protected void serializeTypedFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n-        final JsonSerializer<Object> keySerializer = _keySerializer;\n-        JsonSerializer<Object> prevValueSerializer = null;\n-        Class<?> prevValueClass = null;\n-        final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n-    \n-        for (Map.Entry<?,?> entry : value.entrySet()) {\n-            Object valueElem = entry.getValue();\n-            // First, serialize key\n-            Object keyElem = entry.getKey();\n-            if (keyElem == null) {\n-                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n-            } else {\n-                // [JACKSON-314] also may need to skip entries with null values\n-                if (skipNulls && valueElem == null) continue;\n-                // One twist: is entry ignorable? If so, skip\n-                if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySerializer.serialize(keyElem, jgen, provider);\n-            }\n-    \n-            // And then value\n-            if (valueElem == null) {\n-                provider.defaultSerializeNull(jgen);\n-            } else {\n-                Class<?> cc = valueElem.getClass();\n-                JsonSerializer<Object> currSerializer;\n-                if (cc == prevValueClass) {\n-                    currSerializer = prevValueSerializer;\n-                } else {\n-                    if (_valueType.hasGenericTypes()) {\n-                        currSerializer = provider.findValueSerializer(provider.constructSpecializedType(_valueType, cc), _property);\n-                    } else {\n-                        currSerializer = provider.findValueSerializer(cc, _property);\n-                    }\n-                    prevValueSerializer = currSerializer;\n-                    prevValueClass = cc;\n-                }\n-                try {\n-                    currSerializer.serializeWithType(valueElem, jgen, provider, _valueTypeSerializer);\n-                } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n-                    String keyDesc = \"\"+keyElem;\n-                    wrapAndThrow(provider, e, value, keyDesc);\n-                }\n-            }\n-        }\n-    }\n+\n+    @Deprecated // since 2.5\n+    protected void serializeTypedFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException {\n+        serializeTypedFields(value, gen, provider,\n+                provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES) ? null : JsonInclude.Include.NON_NULL);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Schema related functionality\n+    /**********************************************************\n+     */\n     \n     @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n \n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.JsonParser;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\n \n /**\n  * like {@link BigInteger} and {@link BigDecimal}.\n  */\n @JacksonStdImpl\n-public final class NumberSerializer\n+public class NumberSerializer\n     extends StdScalarSerializer<Number>\n {\n-    public final static NumberSerializer instance = new NumberSerializer();\n+    /**\n+     * Static instance that is only to be used for {@link java.lang.Number}.\n+     */\n+    public final static NumberSerializer instance = new NumberSerializer(Number.class);\n \n-    public NumberSerializer() { super(Number.class); }\n+    protected final boolean _isInt;\n+\n+    @Deprecated // since 2.5\n+    public NumberSerializer() {\n+        super(Number.class);\n+        _isInt = false;\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public NumberSerializer(Class<? extends Number> rawType) {\n+        super(rawType, false);\n+        // since this will NOT be constructed for Integer or Long, only case is:\n+        _isInt = (rawType == BigInteger.class);\n+    }\n \n     @Override\n     public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n+        // should mostly come in as one of these two:\n         if (value instanceof BigDecimal) {\n             jgen.writeNumber((BigDecimal) value);\n         } else if (value instanceof BigInteger) {\n \n     @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint) {\n-        return createSchemaNode(\"number\", true);\n+        return createSchemaNode(_isInt ? \"integer\" : \"number\", true);\n     }\n-    \n+\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n-        // Hmmh. What should it be? Ideally should probably indicate BIG_DECIMAL\n-        // to ensure no information is lost? But probably won't work that well...\n-        JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n-        if (v2 != null) {\n-            v2.numberType(JsonParser.NumberType.BIG_DECIMAL);\n+        if (_isInt) {\n+            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n+            if (v2 != null) {\n+                v2.numberType(JsonParser.NumberType.BIG_INTEGER);\n+            }\n+        } else {\n+            JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n+            if (v2 != null) {\n+                Class<?> h = handledType();\n+                if (h == BigDecimal.class) {\n+                    v2.numberType(JsonParser.NumberType.BIG_DECIMAL);\n+                } // otherwise it's for Number... anything we could do there?\n+            }\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonNumberFormatVisitor;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n \n     {\n         protected final JsonParser.NumberType _numberType;\n         protected final String _schemaType;\n+        protected final boolean _isInt;\n \n         protected Base(Class<T> cls, JsonParser.NumberType numberType, String schemaType) {\n             super(cls);\n             _numberType = numberType;\n             _schemaType = schemaType;\n+            _isInt = (numberType == JsonParser.NumberType.INT)\n+                    || (numberType == JsonParser.NumberType.LONG)\n+                    || (numberType == JsonParser.NumberType.BIG_INTEGER)\n+                    ;\n         }\n \n         @Override\n         @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n         {\n-            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n-            if (v2 != null) {\n-                v2.numberType(_numberType);\n+            if (_isInt) {\n+                JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n+                if (v2 != null) {\n+                    v2.numberType(_numberType);\n+                }\n+            } else {\n+                JsonNumberFormatVisitor v2 = visitor.expectNumberFormat(typeHint);\n+                if (v2 != null) {\n+                    v2.numberType(_numberType);\n+                }\n             }\n         }\n \n                 BeanProperty property) throws JsonMappingException\n         {\n             if (property != null) {\n-                JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(property.getMember());\n-                if (format != null) {\n-                    switch (format.getShape()) {\n-                    case STRING:\n-                        return ToStringSerializer.instance;\n-                    default:\n+                AnnotatedMember m = property.getMember();\n+                if (m != null) {\n+                    JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(m);\n+                    if (format != null) {\n+                        switch (format.getShape()) {\n+                        case STRING:\n+                            return ToStringSerializer.instance;\n+                        default:\n+                        }\n                     }\n                 }\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n     /* Actual serialization\n     /**********************************************************\n      */\n+\n+    @Override\n+    public final void serialize(Object[] value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+    \tfinal int len = value.length;\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n     public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n import java.util.HashMap;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n         public boolean hasSingleElement(boolean[] value) {\n             return (value.length == 1);\n         }\n+\n+        @Override\n+        public final void serialize(boolean[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n         \n         @Override\n         public void serializeContents(boolean[] value, JsonGenerator jgen, SerializerProvider provider)\n         public boolean hasSingleElement(short[] value) {\n             return (value.length == 1);\n         }\n+\n+        @Override\n+        public final void serialize(short[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n         \n         @SuppressWarnings(\"cast\")\n         @Override\n         {\n             // [JACKSON-289] allows serializing as 'sparse' char array too:\n             if (provider.isEnabled(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {\n-                jgen.writeStartArray();\n+                jgen.writeStartArray(value.length);\n                 _writeArrayContents(jgen, value);\n                 jgen.writeEndArray();\n             } else {\n         }\n \n         @Override\n+        public final void serialize(int[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n+\n+        @Override\n         public void serializeContents(int[] value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n+            throws IOException\n         {\n             for (int i = 0, len = value.length; i < len; ++i) {\n                 jgen.writeNumber(value[i]);\n         public boolean hasSingleElement(long[] value) {\n             return (value.length == 1);\n         }\n+\n+        @Override\n+        public final void serialize(long[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n         \n         @Override\n         public void serializeContents(long[] value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n+            throws IOException\n         {\n             if (_valueTypeSerializer != null) {\n                 for (int i = 0, len = value.length; i < len; ++i) {\n         public boolean hasSingleElement(float[] value) {\n             return (value.length == 1);\n         }\n+\n+        @Override\n+        public final void serialize(float[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n         \n         @Override\n         public void serializeContents(float[] value, JsonGenerator jgen, SerializerProvider provider)\n         public boolean hasSingleElement(double[] value) {\n             return (value.length == 1);\n         }\n-        \n-        @Override\n-        public void serializeContents(double[] value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n+\n+        @Override\n+        public final void serialize(double[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n+        \n+        @Override\n+        public void serializeContents(double[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n         {\n             for (int i = 0, len = value.length; i < len; ++i) {\n                 jgen.writeNumber(value[i]);\n         \n         @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-                throws JsonMappingException\n+            throws JsonMappingException\n         {\n             if (visitor != null) {\n                 JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n  *<p>\n  * Note that although types may be related, they must not be same; trying\n  * to do this will result in an exception.\n- * \n+ *\n  * @since 2.1\n  */\n public class StdDelegatingSerializer\n     public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)\n         throws JsonMappingException\n     {\n-        // First: if already got serializer to delegate to, contextualize it:\n-        if (_delegateSerializer != null) {\n-            if (_delegateSerializer instanceof ContextualSerializer) {\n-                JsonSerializer<?> ser = provider.handleSecondaryContextualization(_delegateSerializer, property);\n-                if (ser == _delegateSerializer) {\n-                    return this;\n-                }\n-                return withDelegate(_converter, _delegateType, ser);\n+        JsonSerializer<?> delSer = _delegateSerializer;\n+        JavaType delegateType = _delegateType;\n+\n+        if (delSer == null) {\n+            // Otherwise, need to locate serializer to delegate to. For that we need type information...\n+            if (delegateType == null) {\n+                delegateType = _converter.getOutputType(provider.getTypeFactory());\n             }\n-            return this;\n-        }\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        JavaType delegateType = _delegateType;\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n-        }\n-        // and then find the thing...\n-        return withDelegate(_converter, delegateType,\n-                provider.findValueSerializer(delegateType, property));\n+            delSer = provider.findValueSerializer(delegateType);\n+        }\n+        if (delSer instanceof ContextualSerializer) {\n+            delSer = provider.handleSecondaryContextualization(delSer, property);\n+        }\n+        return (delSer == _delegateSerializer) ? this\n+                : withDelegate(_converter, delegateType, delSer);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n             BeanProperty prop, JsonSerializer<?> existingSerializer)\n         throws JsonMappingException\n     {\n+        /* 19-Oct-2014, tatu: As per [databind#357], need to avoid infinite loop\n+         *   when applying contextual content converter; this is not ideal way,\n+         *   but should work for most cases.\n+         */\n+\n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n         if (intr != null && prop != null) {\n-            Object convDef = intr.findSerializationContentConverter(prop.getMember());\n-            if (convDef != null) {\n-                Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n-                JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n-                if (existingSerializer == null) {\n-                    existingSerializer = provider.findValueSerializer(delegateType, prop);\n+            AnnotatedMember m = prop.getMember();\n+            if (m != null) {\n+                Object convDef = intr.findSerializationContentConverter(m);\n+                if (convDef != null) {\n+                    Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n+                    JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n+                    if (existingSerializer == null) {\n+                        existingSerializer = provider.findValueSerializer(delegateType);\n+                    }\n+                    return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n                 }\n-                return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n             }\n         }\n         return existingSerializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n      */\n     public ToStringSerializer() { super(Object.class); }\n \n+    /**\n+     * Sometimes it may actually make sense to retain actual handled type, so...\n+     * \n+     * @since 2.5\n+     */\n+    public ToStringSerializer(Class<?> handledType) {\n+        super(handledType, false);\n+    }\n+    \n     @Override\n     public boolean isEmpty(Object value) {\n         if (value == null) {\n             return true;\n         }\n         String str = value.toString();\n-        // would use String.isEmpty(), but that's JDK 1.6\n-        return (str == null) || (str.length() == 0);\n+        return str.isEmpty();\n     }\n     \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         jgen.writeString(value.toString());\n     }\n     @Override\n     public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider,\n             TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         typeSer.writeTypePrefixForScalar(value, jgen);\n         serialize(value, jgen, provider);\n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n-    {\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n         return createSchemaNode(\"string\", true);\n     }\n     \n     @Override\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-            throws JsonMappingException\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n         if (visitor != null) {\n             visitor.expectStringFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n      * @param parametrized Type-erased type of instance being constructed\n      * @param parametersFor class or interface for which type parameters are applied; either\n      *   <code>parametrized</code> or one of its supertypes\n-     * @parameterClasses Type parameters to apply\n+     * @param parameterClasses Type parameters to apply\n      * \n      * @since 2.5\n      */\n      * @param parametrized Actual full type\n      * @param parametersFor class or interface for which type parameters are applied; either\n      *   <code>parametrized</code> or one of its supertypes\n-     * @parameterClasses Type parameters to apply\n+     * @param parameterTypes Type parameters to apply\n      * \n      * @since 2.5\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n import java.util.Collections;\n import java.util.Iterator;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.PropertyMetadata;\n import com.fasterxml.jackson.databind.PropertyName;\n      * Member that defines logical property. Assumption is that it\n      * should be a 'simple' accessor; meaning a zero-argument getter,\n      * single-argument setter or constructor parameter.\n+     *<p>\n+     * NOTE: for \"virtual\" properties, this is null.\n      */\n     protected final AnnotatedMember _member;\n \n+    /**\n+     * @since 2.5\n+     */\n+    protected final PropertyMetadata _metadata;\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    protected final PropertyName _fullName;\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    protected final JsonInclude.Include _inclusion;\n+    \n+    /**\n+     * @deprecated Since 2.5 use <code>_fullName</code> instead.\n+     */\n+    @Deprecated\n     protected final String _name;\n     \n     /*\n      */\n     @Deprecated\n     public SimpleBeanPropertyDefinition(AnnotatedMember member, String name) {\n-        this(member, name, null);\n-    }\n-    \n-    private SimpleBeanPropertyDefinition(AnnotatedMember member, String name,\n-    \t\tAnnotationIntrospector intr) {\n+        this(member, new PropertyName(name), null, null, null);\n+    }\n+\n+    protected SimpleBeanPropertyDefinition(AnnotatedMember member, PropertyName fullName,\n+            AnnotationIntrospector intr, PropertyMetadata metadata,\n+            JsonInclude.Include inclusion)\n+    {\n         _introspector = intr;\n         _member = member;\n-        _name = name;\n+        _fullName = fullName;\n+        _name = fullName.getSimpleName();\n+        _metadata = (metadata == null) ? PropertyMetadata.STD_OPTIONAL: metadata;\n+        _inclusion = inclusion;\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5 Use variant that takes PropertyName\n+     */\n+    @Deprecated\n+    protected SimpleBeanPropertyDefinition(AnnotatedMember member, String name,\n+    \t\tAnnotationIntrospector intr) {\n+        this(member, new PropertyName(name), intr, null, null);\n     }\n \n     /**\n      */\n     public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n     \t\tAnnotatedMember member) {\n-        return new SimpleBeanPropertyDefinition(member, member.getName(),\n-                (config == null) ? null : config.getAnnotationIntrospector());\n-    }\n-    \n-    /**\n-     * @since 2.2\n-     */\n+        return new SimpleBeanPropertyDefinition(member, new PropertyName(member.getName()),\n+                (config == null) ? null : config.getAnnotationIntrospector(),\n+                        null, null);\n+    }\n+    \n+    /**\n+     * @deprecated Since 2.5\n+     */\n+    @Deprecated\n     public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n     \t\tAnnotatedMember member, String name) {\n-        return new SimpleBeanPropertyDefinition(member, name,\n-                (config == null) ? null : config.getAnnotationIntrospector());\n-    }\n+        return new SimpleBeanPropertyDefinition(member, new PropertyName(name),\n+                (config == null) ? null : config.getAnnotationIntrospector(),\n+                        null, null);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n+            AnnotatedMember member, PropertyName name) {\n+        return construct(config, member, name, null, null);\n+    }\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n+            AnnotatedMember member, PropertyName name, PropertyMetadata metadata,\n+            JsonInclude.Include inclusion) {\n+          return new SimpleBeanPropertyDefinition(member, name,\n+                  (config == null) ? null : config.getAnnotationIntrospector(),\n+                          metadata, inclusion);\n+      }\n     \n     /*\n     /**********************************************************\n \n     @Deprecated // since 2.3\n     @Override\n-    public SimpleBeanPropertyDefinition withName(String newName) {\n+    public BeanPropertyDefinition withName(String newName) {\n         return withSimpleName(newName);\n     }\n \n     @Override\n-    public SimpleBeanPropertyDefinition withSimpleName(String newName) {\n-        if (_name.equals(newName)) {\n+    public BeanPropertyDefinition withSimpleName(String newName) {\n+        if (_fullName.hasSimpleName(newName) && !_fullName.hasNamespace()) {\n             return this;\n         }\n-        return new SimpleBeanPropertyDefinition(_member, newName, _introspector);\n-    }\n-\n-    @Override\n-    public SimpleBeanPropertyDefinition withName(PropertyName newName) {\n-        return withSimpleName(newName.getSimpleName());\n+        return new SimpleBeanPropertyDefinition(_member, new PropertyName(newName),\n+                _introspector, _metadata, _inclusion);\n+    }\n+\n+    @Override\n+    public BeanPropertyDefinition withName(PropertyName newName) {\n+        if (_fullName.equals(newName)) {\n+            return this;\n+        }\n+        return new SimpleBeanPropertyDefinition(_member, newName,\n+                _introspector, _metadata, _inclusion);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public BeanPropertyDefinition withMetadata(PropertyMetadata metadata) {\n+        if (metadata.equals(_metadata)) {\n+            return this;\n+        }\n+        return new SimpleBeanPropertyDefinition(_member, _fullName,\n+                _introspector, metadata, _inclusion);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public BeanPropertyDefinition withInclusion(JsonInclude.Include inclusion) {\n+        if (_inclusion == inclusion) {\n+            return this;\n+        }\n+        return new SimpleBeanPropertyDefinition(_member, _fullName,\n+                _introspector, _metadata, inclusion);\n     }\n     \n     /*\n      */\n \n     @Override\n-    public String getName() { return _name; }\n-\n-    @Override\n-    public PropertyName getFullName() { return new PropertyName(_name); }\n-    \n+    public String getName() { return _fullName.getSimpleName(); }\n+\n+    @Override\n+    public PropertyName getFullName() { return _fullName; }\n+\n     @Override\n     public String getInternalName() { return getName(); }\n \n     @Override\n     public PropertyName getWrapperName() {\n-        return (_introspector == null) ? null : _introspector.findWrapperName(_member);\n-    }\n-    \n+        return ((_introspector == null) && (_member != null))\n+                ? null : _introspector.findWrapperName(_member);\n+    }\n+\n     // hmmh. what should we claim here?\n \n     @Override public boolean isExplicitlyIncluded() { return false; }\n      */\n     @Override\n     public PropertyMetadata getMetadata() {\n-        return PropertyMetadata.STD_OPTIONAL;\n-    }\n-    \n+        return _metadata;\n+    }\n+\n+    @Override\n+    public JsonInclude.Include findInclusion() {\n+        return _inclusion;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Access to accessors (fields, methods etc)\n--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n      * JDK date parsing is awfully brittle, and ISO-8601 is quite\n      * permissive. The two don't mix, need to write a better one.\n      */\n+    // 02-Oct-2014, tatu: Alas. While spit'n'polished a few times, still\n+    //   not really robust\n \n     /**\n      * Defines a commonly used date format that conforms\n                     // let's just append '00'\n                     dateStr += \"00\";\n                 }\n-                // [JACKSON-334]: may be missing milliseconds... if so, add\n+                // Milliseconds partial or missing; and even seconds are optional\n                 len = dateStr.length();\n-                // '+0000' (5 chars); should come after '.000' (4 chars) of milliseconds, so:\n-                c = dateStr.charAt(len-9);\n-                if (Character.isDigit(c)) {\n+                // remove 'T', '+'/'-' and 4-digit timezone-offset\n+                int timeLen = len - dateStr.lastIndexOf('T') - 6;\n+                if (timeLen < 12) { // 8 for hh:mm:ss, 4 for .sss\n+                    int offset = len - 5; // insertion offset, before tz-offset\n                     StringBuilder sb = new StringBuilder(dateStr);\n-                    sb.insert(len-5, \".000\");\n+                    switch (timeLen) {\n+                    case 11:\n+                        sb.insert(offset, '0'); break;\n+                    case 10:\n+                        sb.insert(offset, \"00\"); break;\n+                    case 9: // is this legal? (just second fraction marker)\n+                        sb.insert(offset, \"000\"); break;\n+                    case 8:\n+                        sb.insert(offset, \".000\"); break;\n+                    case 7: // not legal to have single-digit second\n+                        break;\n+                    case 6: // probably not legal, but let's allow\n+                        sb.insert(offset, \"00.000\");\n+                    case 5: // is legal to omit seconds\n+                        sb.insert(offset, \":00.000\");\n+                    }\n                     dateStr = sb.toString();\n                 }\n-                \n                 df = _formatISO8601;\n                 if (_formatISO8601 == null) {\n                     df = _formatISO8601 = _cloneFormat(DATE_FORMAT_ISO8601, DATE_FORMAT_STR_ISO8601, _timezone, _locale);\n                 }\n             } else {\n-                /* 24-Nov-2009, tatu: Ugh. This is getting pretty\n-                 *   ugly. Need to rewrite!\n-                 */\n-\n                 // If not, plain date. Easiest to just patch 'Z' in the end?\n                 StringBuilder sb = new StringBuilder(dateStr);\n                 // And possible also millisecond part if missing\n                 int timeLen = len - dateStr.lastIndexOf('T') - 1;\n-                if (timeLen <= 8) {\n-                    sb.append(\".000\");\n+                if (timeLen < 12) { // missing, or partial\n+                    switch (timeLen) {\n+                    case 11: sb.append('0');\n+                    case 10: sb.append('0');\n+                    case 9: sb.append('0');\n+                        break;\n+                    default:\n+                        sb.append(\".000\");\n+                    }\n                 }\n                 sb.append('Z');\n                 dateStr = sb.toString();\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n      * \n      * @since 2.3\n      */\n-    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        copyCurrentStructure(jp);\n+    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    {\n+        if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) {\n+            copyCurrentStructure(jp);\n+            return this;\n+        }\n+        /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from\n+         *    FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need\n+         *    to assume one did exist.\n+         */\n+        JsonToken t;\n+        writeStartObject();\n+        do {\n+            copyCurrentStructure(jp);\n+        } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME);\n+        if (t != JsonToken.END_OBJECT) {\n+            throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t);\n+        }\n+        writeEndObject();\n         return this;\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n     {\n         return readAndMapFromString(SHARED_MAPPER, input, cls);\n     }\n-    \n-    protected <T> T readAndMapFromString(ObjectMapper m, String input, Class<T> cls)\n-        throws IOException\n+\n+    protected <T> T readAndMapFromString(ObjectMapper m, String input, Class<T> cls) throws IOException\n     {\n         return (T) m.readValue(\"\\\"\"+input+\"\\\"\", cls);\n     }\n     /* Helper methods, other\n     /**********************************************************\n      */\n-    \n+\n     protected TimeZone getUTCTimeZone() {\n         return TimeZone.getTimeZone(\"GMT\");\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/BrokenStringReader.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+\n+public class BrokenStringReader\n+    extends FilterReader\n+{\n+    final String _message;\n+\n+    public BrokenStringReader(String content, String msg)\n+    {\n+        super(new StringReader(content));\n+        _message = msg;\n+    }\n+\n+    @Override\n+    public int read(char[] cbuf, int off, int len)\n+        throws IOException\n+    {\n+        int i = super.read(cbuf, off, len);\n+        if (i < 0) {\n+            throw new IOException(_message);\n+        }\n+        return i;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/BrokenStringWriter.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+\n+public class BrokenStringWriter\n+    extends FilterWriter\n+{\n+    final String _message;\n+\n+    public BrokenStringWriter(String msg) {\n+        super(new StringWriter());\n+        _message = msg;\n+    }\n+\n+    @Override\n+    public void write(char[] cbuf, int off, int len) throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+    \n+    @Override\n+    public void write(int c) throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+    \n+    @Override\n+    public void write(String str, int off, int len)  throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n         StringReader r = new StringReader(\"{}\");\n         //  bit ugly, but can't think of cleaner simple way to check this...\n         try {\n-            mapper.reader(s).withType(Object.class).readValue(r);\n+            mapper.reader(s).forType(Object.class).readValue(r);\n             fail(\"Excpected exception\");\n         } catch (SchemaException e) {\n             assertSame(s, e._schema);\n--- a/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n-\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n public class TestHandlerInstantiation extends BaseMapTest\n     }\n     \n     // copied from \"TestCustomTypeIdResolver\"\n-    static class CustomIdResolver implements TypeIdResolver\n+    static class CustomIdResolver extends TypeIdResolverBase\n     {\n         static List<JavaType> initTypes;\n \n             }\n         }\n         @Override\n-        public JavaType typeFromId(String id)\n+        public JavaType typeFromId(DatabindContext context, String id)\n         {\n             if (id.equals(_id)) {\n                 return TypeFactory.defaultInstance().constructType(TypeIdBean.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n {\n     static class MyPojo {\n         public int x;\n-        private int y;\n+        protected int y;\n         \n         public MyPojo() { }\n         public MyPojo(int x0, int y0) {\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n package com.fasterxml.jackson.databind;\n \n import java.io.*;\n+import java.util.*;\n \n import com.fasterxml.jackson.core.JsonFactory;\n import com.fasterxml.jackson.core.JsonParser;\n-\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\n import com.fasterxml.jackson.databind.node.*;\n     public void testProviderConfig() throws Exception   \n     {\n         ObjectMapper m = new ObjectMapper();\n+        final String JSON = \"{ \\\"x\\\" : 3 }\";\n \n         assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n         // and then should get one constructed for:\n-        Bean bean = m.readValue(\"{ \\\"x\\\" : 3 }\", Bean.class);\n+        Bean bean = m.readValue(JSON, Bean.class);\n         assertNotNull(bean);\n         assertEquals(1, m._deserializationContext._cache.cachedDeserializersCount());\n         m._deserializationContext._cache.flushCachedDeserializers();\n         assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n+\n+        // 07-Nov-2014, tatu: As per [databind#604] verify that Maps also get cached\n+        m = new ObjectMapper();\n+        List<?> stuff = m.readValue(\"[ ]\", List.class);\n+        assertNotNull(stuff);\n+        // may look odd, but due to \"Untyped\" deserializer thing, we actually have\n+        // 3 deserializers (List<?>, Map<?,?>, Object)\n+        assertEquals(3, m._deserializationContext._cache.cachedDeserializersCount());\n     }\n     \n     // [Issue#28]: ObjectMapper.copy()\n         assertEquals(0, m.getDeserializationConfig().mixInCount());\n         assertEquals(0, m2.getDeserializationConfig().mixInCount());\n \n-        m.addMixInAnnotations(String.class, Integer.class);\n+        m.addMixIn(String.class, Integer.class);\n         assertEquals(1, m.getSerializationConfig().mixInCount());\n         assertEquals(0, m2.getSerializationConfig().mixInCount());\n         assertEquals(1, m.getDeserializationConfig().mixInCount());\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanSerializer.java\n         THIS_IS_AN_ENUM_VALUE_3,\n     }\n \n-    @SuppressWarnings(\"unused\")\n-    private static class FixtureObjectBase\n+    static class FixtureObjectBase\n     {\n         public static final String       VALUE_STRING = \"foobar\";\n         public static final EFixtureEnum VALUE_ENUM   = EFixtureEnum.THIS_IS_AN_ENUM_VALUE_2;\n         }\n     }\n \n-    @SuppressWarnings(\"unused\")\n-    private static class FixtureObject extends FixtureObjectBase\n-    {\n-        public Exception getTestError()\n-        {\n+    static class FixtureObject extends FixtureObjectBase\n+    {\n+        public Exception getTestError() {\n             return new Exception(VALUE_ERRTXT);\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);\n-        assertEquals(quote(\"\\\\u0101\"), mapper.writeValueAsString(String.valueOf((char) 257)));\n+        mapper.writeValueAsString(String.valueOf((char) 257));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestReadValues.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestReadValues.java\n \n     static class Bean {\n         public int a;\n-    }\n-    \n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == null || o.getClass() != getClass()) return false;\n+            Bean other = (Bean) o;\n+            return other.a == this.a;\n+        }\n+        @Override public int hashCode() { return a; }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests; root-level value sequences via Mapper\n     public void testRootBeans() throws Exception\n     {\n         final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n-        Iterator<Bean> it = MAPPER.reader(Bean.class).readValues(JSON);\n-\n-        assertNotNull(((MappingIterator<?>) it).getCurrentLocation());\n+\n+        MappingIterator<Bean> it = MAPPER.reader(Bean.class).readValues(JSON);\n+\n+        assertNotNull(it.getCurrentLocation());\n         assertTrue(it.hasNext());\n         Bean b = it.next();\n         assertEquals(3, b.a);\n         b = it.next();\n         assertEquals(27, b.a);\n         assertFalse(it.hasNext());\n+        it.close();\n+\n+        // Also, test 'readAll()'\n+        it = MAPPER.reader(Bean.class).readValues(JSON);\n+        List<Bean> all = it.readAll();\n+        assertEquals(2, all.size());\n+        it.close();\n+\n+        it = MAPPER.reader(Bean.class).readValues(\"{\\\"a\\\":3}{\\\"a\\\":3}\");\n+        Set<Bean> set = it.readAll(new HashSet<Bean>());\n+        assertEquals(HashSet.class, set.getClass());\n+        assertEquals(1, set.size());\n+        assertEquals(3, set.iterator().next().a);\n     }\n \n     public void testRootMaps() throws Exception\n             +\"{\\\"boy\\\": \\\"howdy\\\", \\\"huh\\\": \\\"what\\\"}]\";\n         final MappingIterator<Map<String, Object>> iterator = MAPPER\n                 .reader()\n-                .withType(new TypeReference<Map<String, Object>>(){})\n+                .forType(new TypeReference<Map<String, Object>>(){})\n                 .readValues(JSON);\n \n         Map<String,Object> map;\n--- a/src/test/java/com/fasterxml/jackson/databind/access/TestSerAnyGetter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/access/TestSerAnyGetter.java\n         }\n     }\n \n-    private static class PrivateThing\n+    static class PrivateThing\n     {\n         @JsonAnyGetter\n         public Map<?,?> getProperties()\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextAttributeWithDeser.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextAttributeWithDeser.java\n \n         // as above, should not carry on state\n         TestPOJO pojo2 = MAPPER.reader(TestPOJO.class)\n-                .withAttribute(KEY, Integer.valueOf(3))\n+                .withAttribute(KEY, Integer.valueOf(5))\n                 .readValue(INPUT);\n-        assertEquals(\"x/3\", pojo2.value);\n+        assertEquals(\"x/5\", pojo2.value);\n     }\n \n     public void testHierarchic() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualKeyTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualKeyTypes.java\n         mapper.registerModule(module);\n         Map<String,Object> input = new HashMap<String,Object>();\n         input.put(\"a\", Integer.valueOf(3));\n-        String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class))\n+        String json = mapper.writerFor(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class))\n             .writeValueAsString(input);\n         assertEquals(\"{\\\"prefix:a\\\":3}\", json);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java\n \n public class SingleArgCreatorTest extends BaseMapTest\n {\n-    // [Issue#430]: single arg BUT named; should not delegate\n+    // [databind#430]: single arg BUT named; should not delegate\n \n     static class SingleNamedStringBean {\n-\n         final String _ss;\n \n         @JsonCreator\n         public String getSs() { return _ss; }\n     }\n \n-    // [Databind#557]\n+    // For [databind#614]\n+    static class SingleNamedButStillDelegating {\n+        protected final String value;\n+\n+        @JsonCreator(mode=JsonCreator.Mode.DELEGATING)\n+        public SingleNamedButStillDelegating(@JsonProperty(\"foobar\") String v){\n+            value = v;\n+        }\n+\n+        public String getFoobar() { return \"x\"; }\n+    }\n+    \n+    // [databind#557]\n     \n     static class StringyBean\n     {\n         }\n     }\n \n+    static class StringyBeanWithProps\n+    {\n+        public final String value;\n+\n+        @JsonCreator\n+        private StringyBeanWithProps(String v) { value = v; }\n+\n+        public String getValue() {\n+            return value;\n+        }\n+    }\n+    \n     @SuppressWarnings(\"serial\")\n     static class MyParamIntrospector extends JacksonAnnotationIntrospector\n     {\n+        private final String name;\n+        \n+        public MyParamIntrospector(String n) { name = n; }\n+        \n         @Override\n         public String findImplicitPropertyName(AnnotatedMember param) {\n             if (param instanceof AnnotatedParameter) {\n                 AnnotatedParameter ap = (AnnotatedParameter) param;\n                 switch (ap.getIndex()) {\n-                case 0: return \"value\";\n+                case 0: return name;\n                 }\n                 return \"param\"+ap.getIndex();\n             }\n     public void testSingleStringArgWithImplicitName() throws Exception\n     {\n         final ObjectMapper mapper = new ObjectMapper();\n-        mapper.setAnnotationIntrospector(new MyParamIntrospector());\n+        mapper.setAnnotationIntrospector(new MyParamIntrospector(\"value\"));\n         StringyBean bean = mapper.readValue(quote(\"foobar\"), StringyBean.class);\n         assertEquals(\"foobar\", bean.getValue());\n     }    \n+\n+    // [databind#714]\n+    public void testSingleImplicitlyNamedNotDelegating() throws Exception\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.setAnnotationIntrospector(new MyParamIntrospector(\"value\"));\n+        StringyBeanWithProps bean = mapper.readValue(\"{\\\"value\\\":\\\"x\\\"}\", StringyBeanWithProps.class);\n+        assertEquals(\"x\", bean.getValue());\n+    }    \n+    \n+    // [databind#714]\n+    public void testSingleExplicitlyNamedButDelegating() throws Exception\n+    {\n+        SingleNamedButStillDelegating bean = MAPPER.readValue(quote(\"xyz\"),\n+                SingleNamedButStillDelegating.class);\n+        assertEquals(\"xyz\", bean.value);\n+    }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorNullValue.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorNullValue.java\n package com.fasterxml.jackson.databind.creators;\n \n+import java.io.IOException;\n+import java.util.UUID;\n+\n import com.fasterxml.jackson.annotation.*;\n-\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.*;\n \n-// Mostly for [JACSON-774]\n public class TestCreatorNullValue extends BaseMapTest\n {\n     protected static class Container {\n         }\n     }\n \n-    private static interface Contained<T> {}\n+    protected static interface Contained<T> {}\n \n-    private static class NullContained implements Contained<Object> {}\n+    protected static class NullContained implements Contained<Object> {}\n \n-    private static final NullContained NULL_CONTAINED = new NullContained();\n+    protected static final NullContained NULL_CONTAINED = new NullContained();\n \n-    private static class ContainedDeserializer extends JsonDeserializer<Contained<?>> {\n+    protected static class ContainedDeserializer extends JsonDeserializer<Contained<?>> {\n         @Override\n         public Contained<?> deserialize(JsonParser jp, DeserializationContext ctxt) throws JsonProcessingException {\n             return null;\n         }\n     }\n \n-    private static class ContainerDeserializerResolver extends Deserializers.Base {\n+    protected static class ContainerDeserializerResolver extends Deserializers.Base {\n         @Override\n         public JsonDeserializer<?> findBeanDeserializer(JavaType type,\n                 DeserializationConfig config, BeanDescription beanDesc)\n         {\n             if (!Contained.class.isAssignableFrom(type.getRawClass())) {\n                 return null;\n-            } else {\n-                return new ContainedDeserializer();\n             }\n+            return new ContainedDeserializer();\n         }\n     }\n \n-    private static class TestModule extends Module\n+    protected static class TestModule extends Module\n     {\n         @Override\n         public String getModuleName() {\n         }\n     }\n \n+    // [databind#597]\n+    static class JsonEntity {\n+        protected final String type;\n+        protected final UUID id;\n+\n+        private JsonEntity(String type, UUID id) {\n+            this.type = type;\n+            this.id = id;\n+        }\n+\n+        @JsonCreator\n+        public static JsonEntity create(@JsonProperty(\"type\") String type, @JsonProperty(\"id\") UUID id) {\n+            if (type != null && !type.contains(\" \") && (id != null)) {\n+                return new JsonEntity(type, id);\n+            }\n+\n+            return null;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         Container container = mapper.readValue(\"{}\", Container.class);\n         assertEquals(NULL_CONTAINED, container.contained);\n     }\n+\n+    // [databind#597]: ensure that a useful exception is thrown\n+    public void testCreatorReturningNull() throws IOException {\n+        ObjectMapper objectMapper = new ObjectMapper();\n+        String json = \"{ \\\"type\\\" : \\\"     \\\", \\\"id\\\" : \\\"000c0ffb-a0d6-4d2e-a379-4aeaaf283599\\\" }\";\n+        try {\n+            objectMapper.readValue(json, JsonEntity.class);\n+            fail(\"Should not have succeeded\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"JSON creator returned null\");\n+        }\n+    }    \n }\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators.java\n     public void testFactoryCreatorWithMixin() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(CreatorBean.class, MixIn.class);\n+        m.addMixIn(CreatorBean.class, MixIn.class);\n         CreatorBean bean = m.readValue\n             (\"{ \\\"a\\\" : \\\"xyz\\\", \\\"x\\\" : 12 }\", CreatorBean.class);\n         assertEquals(11, bean.x);\n     public void testFactoryCreatorWithRenamingMixin() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(FactoryBean.class, FactoryBeanMixIn.class);\n+        m.addMixIn(FactoryBean.class, FactoryBeanMixIn.class);\n         // override changes property name from \"f\" to \"mixed\"\n         FactoryBean bean = m.readValue(\"{ \\\"mixed\\\" :  20.5 }\", FactoryBean.class);\n         assertEquals(20.5, bean.d);\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators541.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestCreators541 extends BaseMapTest\n+{\n+    static final class Foo {\n+\n+        @JsonProperty(\"foo\")\n+        protected Map<Integer, Bar> foo;\n+        @JsonProperty(\"anumber\")\n+        protected long anumber;\n+\n+        public Foo() {\n+            anumber = 0;\n+        }\n+\n+        public Map<Integer, Bar> getFoo() {\n+            return foo;\n+        }\n+\n+        public long getAnumber() {\n+            return anumber;\n+        }\n+    }\n+\n+    static final class Bar {\n+\n+        private final long p;\n+        private final List<String> stuff;\n+\n+        @JsonCreator\n+        public Bar(@JsonProperty(\"p\") long p, @JsonProperty(\"stuff\") List<String> stuff) {\n+            this.p = p;\n+            this.stuff = stuff;\n+        }\n+\n+        @JsonProperty(\"s\")\n+        public List<String> getStuff() {\n+            return stuff;\n+        }\n+\n+        @JsonProperty(\"stuff\")\n+        private List<String> getStuffDeprecated() {\n+            return stuff;\n+        }\n+\n+        public long getP() {\n+            return p;\n+        }\n+    }    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testCreator541() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n+        mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);\n+        mapper.disable(\n+                MapperFeature.AUTO_DETECT_CREATORS,\n+                MapperFeature.AUTO_DETECT_FIELDS,\n+                MapperFeature.AUTO_DETECT_GETTERS,\n+                MapperFeature.AUTO_DETECT_IS_GETTERS,\n+                MapperFeature.AUTO_DETECT_SETTERS,\n+                MapperFeature.USE_GETTERS_AS_SETTERS\n+        );\n+        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);  \n+\n+        final String JSON = \"{\\n\"\n+                + \"    \\\"foo\\\": {\\n\"\n+                + \"        \\\"0\\\": {\\n\"\n+                + \"            \\\"p\\\": 0,\\n\"\n+                + \"            \\\"stuff\\\": [\\n\"\n+                + \"              \\\"a\\\", \\\"b\\\" \\n\"\n+                + \"            ]   \\n\"\n+                + \"        },\\n\"\n+                + \"        \\\"1\\\": {\\n\"\n+                + \"            \\\"p\\\": 1000,\\n\"\n+                + \"            \\\"stuff\\\": [\\n\"\n+                + \"              \\\"c\\\", \\\"d\\\" \\n\"\n+                + \"            ]   \\n\"\n+                + \"        },\\n\"\n+                + \"        \\\"2\\\": {\\n\"\n+                + \"            \\\"p\\\": 2000,\\n\"\n+                + \"            \\\"stuff\\\": [\\n\"\n+                + \"            ]   \\n\"\n+                + \"        }\\n\"\n+                + \"    },\\n\"\n+                + \"    \\\"anumber\\\": 25385874\\n\"\n+                + \"}\";\n+\n+        Foo obj = mapper.readValue(JSON, Foo.class);\n+        assertNotNull(obj);\n+        assertNotNull(obj.foo);\n+        assertEquals(3, obj.foo.size());\n+        assertEquals(25385874L, obj.getAnumber());\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorsDelegating.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorsDelegating.java\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JacksonInject;\n \n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n public class TestCreatorsDelegating extends BaseMapTest\n {\n             return new FactoryBean711(a, n1, n2);\n         }\n     }\n-    \n+\n+    static class Value592\n+    {\n+        protected Object stuff;\n+\n+        protected Value592(Object ob, boolean bogus) {\n+            stuff = ob;\n+        }\n+        \n+        @JsonCreator\n+        public static Value592 from(TokenBuffer buffer) {\n+            return new Value592(buffer, false);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertEquals(\"Fygar\", bean.name1);\n         assertEquals(\"Fygar\", bean.name2);\n     }\n+\n+    // [databind#592]\n+    public void testDelegateWithTokenBuffer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Value592 value = mapper.readValue(\"{\\\"a\\\":1,\\\"b\\\":2}\", Value592.class);\n+        assertNotNull(value);\n+        Object ob = value.stuff;\n+        assertEquals(TokenBuffer.class, ob.getClass());\n+        JsonParser jp = ((TokenBuffer) ob).asParser();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"a\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(1, jp.getIntValue());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"b\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(2, jp.getIntValue());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestPolymorphicCreators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestPolymorphicCreators.java\n public class TestPolymorphicCreators\n     extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper beans\n-    /**********************************************************\n-     */\n-\n     static class Animal\n     {\n         // All animals have names, for our demo purposes...\n \n     abstract static class AbstractRoot\n     {\n-        private final String opt;\n+        protected final String opt;\n \n-        private AbstractRoot(String opt) {\n+        protected AbstractRoot(String opt) {\n             this.opt = opt;\n         }\n \n         @JsonCreator\n         public static final AbstractRoot make(@JsonProperty(\"which\") int which,\n             @JsonProperty(\"opt\") String opt) {\n-            if(1 == which) {\n+            if (1 == which) {\n                 return new One(opt);\n             }\n             throw new RuntimeException(\"cannot instantiate \" + which);\n         abstract public int getWhich();\n \n         public final String getOpt() {\n-                return opt;\n+            return opt;\n         }\n     }\n \n     static final class One extends AbstractRoot {\n-        private One(String opt) {\n+        protected One(String opt) {\n             super(opt);\n         }\n \n \n     public void testManualPolymorphicWithNumbered() throws Exception\n     {\n-         final ObjectWriter w = MAPPER.writerWithType(AbstractRoot.class);\n+         final ObjectWriter w = MAPPER.writerFor(AbstractRoot.class);\n          final ObjectReader r = MAPPER.reader(AbstractRoot.class);\n \n          AbstractRoot input = AbstractRoot.make(1, \"oh hai!\");\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestPolymorphicDelegating.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestPolymorphicDelegating extends BaseMapTest\n+{\n+\n+    // For [databind#580]\n+    \n+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)\n+    static abstract class Issue580Base {\n+    }\n+\n+    static class Issue580Impl extends Issue580Base {\n+        public int id = 3;\n+\n+        public Issue580Impl() { }\n+        public Issue580Impl(int id) { this.id = id; }\n+    }\n+\n+    static class Issue580Bean {\n+        public Issue580Base value;\n+\n+        @JsonCreator\n+        public Issue580Bean(Issue580Base v) {\n+            value = v;\n+        }\n+\n+        @JsonValue\n+        public Issue580Base value() {\n+            return value;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testAbstractDelegateWithCreator() throws Exception\n+    {\n+        Issue580Bean input = new Issue580Bean(new Issue580Impl(13));\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(input);\n+\n+        Issue580Bean result = mapper.readValue(json, Issue580Bean.class);\n+        assertNotNull(result);\n+        assertNotNull(result.value);\n+        assertEquals(13, ((Issue580Impl) result.value).id);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBasicAnnotations.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBasicAnnotations.java\n \n     static class Issue442Bean {\n         @JsonUnwrapped\n-        private IntWrapper w = new IntWrapper(13);\n+        protected IntWrapper w = new IntWrapper(13);\n     }\n     \n     final static class SizeClassSetter2\n     }\n \n     static class BeanWithDeserialize {\n-        @JsonDeserialize private int a;\n+        @JsonDeserialize protected int a;\n     }\n     \n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n     public void testFromEmptyString() throws Exception\n     {\n         ObjectReader r = MAPPER.reader(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n-        List<?> result = r.withType(List.class).readValue(quote(\"\"));\n+        List<?> result = r.forType(List.class).readValue(quote(\"\"));\n         assertNull(result);\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomDeserializers.java\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.fasterxml.jackson.databind.deser.std.StdDelegatingDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.deser.std.*;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.util.StdConverter;\n \n         }\n         \n     }\n-    \n+\n+    // for [databind#631]\n+    static class Issue631Bean\n+    {\n+        @JsonDeserialize(using=ParentClassDeserializer.class)\n+        public Object prop;\n+    }\n+    \n+    static class ParentClassDeserializer\n+        extends StdScalarDeserializer<Object>\n+    {\n+        protected ParentClassDeserializer() {\n+            super(Object.class);\n+        }\n+\n+        @Override\n+        public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+                throws IOException {\n+            Object parent = p.getCurrentValue();\n+            String desc = (parent == null) ? \"NULL\" : parent.getClass().getSimpleName();\n+            return \"prop/\"+ desc;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertEquals(7, imm.y);\n     }\n \n+    // [databind#623]\n+    public void testJsonNodeDelegating() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addDeserializer(Immutable.class,\n+            new StdNodeBasedDeserializer<Immutable>(Immutable.class) {\n+                @Override\n+                public Immutable convert(JsonNode root, DeserializationContext ctxt) throws IOException {\n+                    int x = root.path(\"x\").asInt();\n+                    int y = root.path(\"y\").asInt();\n+                    return new Immutable(x, y);\n+                }\n+        });\n+        mapper.registerModule(module);\n+        Immutable imm = mapper.readValue(\"{\\\"x\\\":-10,\\\"y\\\":3}\", Immutable.class);\n+        assertEquals(-10, imm.x);\n+        assertEquals(3, imm.y);\n+    }\n+    \n     public void testIssue882() throws Exception\n     {\n         Model original = new Model(Collections.singletonMap(new CustomKey(123), \"test\"));\n         assertNotNull(w.value.inner);\n         assertEquals(-13, w.value.inner.x);\n     }\n+\n+    // [#631]: \"current value\" access\n+    public void testCurrentValueAccess() throws Exception\n+    {\n+        Issue631Bean bean = MAPPER.readValue(aposToQuotes(\"{'prop':'stuff'}\"),\n+                Issue631Bean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"prop/Issue631Bean\", bean.prop);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCyclicTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCyclicTypes.java\n     }\n \n     static class LinkB {\n-        private LinkA a;\n+        protected LinkA a;\n \n         public void setA(LinkA a) { this.a = a; }\n         public LinkA getA() { return a; }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n         assertEquals(30, c.get(Calendar.DAY_OF_MONTH));\n     }\n \n+    // [Databind#570]\n+    public void testISO8601PartialMilliseconds() throws Exception\n+    {\n+        String inputStr;\n+        Date inputDate;\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+        \n+        inputStr = \"2014-10-03T18:00:00.6-05:00\";\n+        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n+        c.setTime(inputDate);\n+        assertEquals(2014, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));\n+        assertEquals(3, c.get(Calendar.DAY_OF_MONTH));\n+        assertEquals(600, c.get(Calendar.MILLISECOND));\n+\n+        inputStr = \"2014-10-03T18:00:00.61-05:00\";\n+        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n+        c.setTime(inputDate);\n+        assertEquals(2014, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.OCTOBER, c.get(Calendar.MONTH));\n+        assertEquals(3, c.get(Calendar.DAY_OF_MONTH));\n+        assertEquals(18 + 5, c.get(Calendar.HOUR_OF_DAY));\n+        assertEquals(0, c.get(Calendar.MINUTE));\n+        assertEquals(0, c.get(Calendar.SECOND));\n+        assertEquals(610, c.get(Calendar.MILLISECOND));\n+\n+        inputStr = \"1997-07-16T19:20:30.45+01:00\";\n+        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n+        c.setTime(inputDate);\n+        assertEquals(1997, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));\n+        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));\n+        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));\n+        assertEquals(20, c.get(Calendar.MINUTE));\n+        assertEquals(30, c.get(Calendar.SECOND));\n+        assertEquals(450, c.get(Calendar.MILLISECOND));\n+    }\n+\n+    public void testISO8601MissingSeconds() throws Exception\n+    {\n+        String inputStr;\n+        Date inputDate;\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+    \n+        inputStr = \"1997-07-16T19:20+01:00\";\n+        inputDate = MAPPER.readValue(quote(inputStr), java.util.Date.class);\n+        c.setTime(inputDate);\n+        assertEquals(1997, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));\n+        assertEquals(16, c.get(Calendar.DAY_OF_MONTH));\n+        assertEquals(19 - 1, c.get(Calendar.HOUR_OF_DAY));\n+        assertEquals(0, c.get(Calendar.SECOND));\n+        assertEquals(0, c.get(Calendar.MILLISECOND));\n+}\n+\n     public void testDateUtilISO8601NoTimezone() throws Exception\n     {\n         // Timezone itself is optional as well... \n         assertEquals(0, c.get(Calendar.MILLISECOND));\n \n         // 03-Nov-2013, tatu: This wouldn't work, and is the nominal reason\n-        //    for #338 I thinl\n+        //    for #338 I think\n         /*\n         inputDate =  ISO8601Utils.parse(INPUT_STR);\n         c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n package com.fasterxml.jackson.databind.deser;\n \n import java.io.IOException;\n+import java.math.BigDecimal;\n import java.util.EnumMap;\n import java.util.EnumSet;\n import java.util.Map;\n import java.util.concurrent.TimeUnit;\n \n import com.fasterxml.jackson.annotation.*;\n-\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.*;\n             return TestEnum.valueOf(jp.getText().toUpperCase());\n         }\n     }\n-    \n+\n     protected enum EnumWithCreator {\n         A, B;\n \n         public static EnumWithCreator fromEnum(String str) {\n             if (\"enumA\".equals(str)) return A;\n             if (\"enumB\".equals(str)) return B;\n+            return null;\n+        }\n+    }\n+\n+    protected enum EnumWithBDCreator {\n+        E5, E8;\n+\n+        @JsonCreator\n+        public static EnumWithBDCreator create(BigDecimal bd) {\n+            if (bd.longValue() == 5L) return E5;\n+            if (bd.longValue() == 8L) return E8;\n             return null;\n         }\n     }\n     }\n \n     // [JACKSON-193]\n-    public void testCreatorEnums() throws Exception\n-    {\n+    public void testCreatorEnums() throws Exception {\n         EnumWithCreator value = MAPPER.readValue(\"\\\"enumA\\\"\", EnumWithCreator.class);\n         assertEquals(EnumWithCreator.A, value);\n+    }\n+\n+    public void testCreatorEnumsFromBigDecimal() throws Exception {\n+        EnumWithBDCreator value = MAPPER.readValue(\"\\\"8.0\\\"\", EnumWithBDCreator.class);\n+        assertEquals(EnumWithBDCreator.E8, value);\n     }\n     \n     // [JACKSON-212]\n     {\n         // can not use shared mapper when changing configs...\n         ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);\n-        assertNull(reader.withType(TestEnum.class).readValue(\"\\\"NO-SUCH-VALUE\\\"\"));\n-        assertNull(reader.withType(TestEnum.class).readValue(\" 4343 \"));\n+        assertNull(reader.forType(TestEnum.class).readValue(\"\\\"NO-SUCH-VALUE\\\"\"));\n+        assertNull(reader.forType(TestEnum.class).readValue(\" 4343 \"));\n     }\n \n     public void testAllowUnknownEnumValuesForEnumSets() throws Exception\n     {\n         ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);\n-        EnumSet<TestEnum> result = reader.withType(new TypeReference<EnumSet<TestEnum>>() { })\n+        EnumSet<TestEnum> result = reader.forType(new TypeReference<EnumSet<TestEnum>>() { })\n                 .readValue(\"[\\\"NO-SUCH-VALUE\\\"]\");\n         assertEquals(0, result.size());\n     }\n     public void testAllowUnknownEnumValuesAsMapKeysReadAsNull() throws Exception\n     {\n         ObjectReader reader = MAPPER.reader(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL);\n-        ClassWithEnumMapKey result = reader.withType(ClassWithEnumMapKey.class)\n+        ClassWithEnumMapKey result = reader.forType(ClassWithEnumMapKey.class)\n                 .readValue(\"{\\\"map\\\":{\\\"NO-SUCH-VALUE\\\":\\\"val\\\"}}\");\n         assertTrue(result.map.containsKey(null));\n     }\n     // [JACKSON-834]\n     public void testEnumsFromInts() throws Exception\n     {\n-        TestEnumFor834 res = MAPPER.readValue(\"1 \", TestEnumFor834.class);\n-        assertSame(TestEnumFor834.ENUM_A, res);\n+        Object ob = MAPPER.readValue(\"1 \", TestEnumFor834.class);\n+        assertEquals(TestEnumFor834.class, ob.getClass());\n+        assertSame(TestEnumFor834.ENUM_A, ob);\n     }\n \n     // [Issue#141]: allow mapping of empty String into null\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n-import com.fasterxml.jackson.test.BrokenStringReader;\n \n /**\n  * Unit test for verifying that exceptions are properly handled (caught,\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestInjectables.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestInjectables.java\n \n     static class IssueGH471Bean {\n \n-        private final Object constructorInjected;\n-        private final String constructorValue;\n+        protected final Object constructorInjected;\n+        protected final String constructorValue;\n \n-        @JacksonInject(\"field_injected\") private Object fieldInjected;\n-        @JsonProperty(\"field_value\")     private String fieldValue;\n+        @JacksonInject(\"field_injected\") protected Object fieldInjected;\n+        @JsonProperty(\"field_value\")     protected String fieldValue;\n \n-        private Object methodInjected;\n-        private String methodValue;\n+        protected Object methodInjected;\n+        protected String methodValue;\n \n         public int x;\n         \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n \n         @JsonProperty(\"Location\")\n         @JsonDeserialize(using=MyStackTraceElementDeserializer.class)\n-        private StackTraceElement location;    \n+        protected StackTraceElement location;    \n     }\n \n     @SuppressWarnings(\"serial\")\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n     public static enum ConcreteType implements ITestType {\n         ONE, TWO;\n     }\n+\n+    static class ClassStringMap extends HashMap<Class<?>,String> { }\n     \n     /*\n     /**********************************************************\n         Map<?,?> result = r.readValue(JSON);\n         assertNull(result);\n \n-        EnumMap<?,?> result2 = r.withType(new TypeReference<EnumMap<Key,String>>() { })\n+        EnumMap<?,?> result2 = r.forType(new TypeReference<EnumMap<Key,String>>() { })\n                 .readValue(JSON);\n         assertNull(result2);\n     }\n         key = map.keySet().iterator().next();\n         assertEquals(\"foo\", key.value);\n     }\n+\n+    public void testClassKeyMap() throws Exception {\n+        ClassStringMap map = MAPPER.readValue(aposToQuotes(\"{'java.lang.String':'foo'}\"),\n+                ClassStringMap.class);\n+        assertNotNull(map);\n+        assertEquals(1, map.size());\n+        assertEquals(\"foo\", map.get(String.class));\n+    }\n     \n     /*\n     /**********************************************************\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestNoClassDefFoundDeserializer.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import javax.measure.Measure;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestNoClassDefFoundDeserializer extends BaseMapTest {\n+\n+    public static class Parent {\n+        public List<Child> child;\n+    }\n+\n+    public static class Child {\n+        public Measure<?> measure;\n+    }\n+\n+    public void testClassIsMissing()\n+    {\n+        boolean missing = false;\n+        try {\n+            Class.forName(\"javax.measure.Measure\");\n+        } catch (ClassNotFoundException ex) {\n+            missing = true;\n+        }\n+        assertTrue(\"javax.measure.Measure is not in classpath\", missing);\n+    }\n+\n+    public void testDeserialize() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Parent result = m.readValue(\" { } \", Parent.class);\n+        assertNotNull(result);\n+    }\n+\n+    public void testUseMissingClass() throws Exception\n+    {\n+        boolean missing = false;\n+        try {\n+            ObjectMapper m = new ObjectMapper();\n+            m.readValue(\" { \\\"child\\\" : [{}] } \", Parent.class);\n+        } catch (NoClassDefFoundError ex) {\n+            missing = true;\n+        }\n+        assertTrue(\"cannot instantiate a missing class\", missing);\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestNumbers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestNumbers.java\n /**\n  * Tests related to [JACKSON-139]\n  */\n-public class TestNumbers\n-    extends BaseMapTest\n+public class TestNumbers extends BaseMapTest\n {\n     /*\n     /**********************************************************************\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestObjectReader.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestObjectReader extends BaseMapTest\n+{\n+    final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testParserFeatures() throws Exception\n+    {\n+        final String JSON = \"[ /* foo */ 7 ]\";\n+        // default won't accept comments, let's change that:\n+        ObjectReader reader = MAPPER.reader(int[].class)\n+                .with(JsonParser.Feature.ALLOW_COMMENTS);\n+\n+        int[] value = reader.readValue(JSON);\n+        assertNotNull(value);\n+        assertEquals(1, value.length);\n+        assertEquals(7, value[0]);\n+\n+        // but also can go back\n+        try {\n+            reader.without(JsonParser.Feature.ALLOW_COMMENTS).readValue(JSON);\n+            fail(\"Should not have passed\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"foo\");\n+        }\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUntypedDeserialization.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n-\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n \n /**\n- * Unit tests for verifying \"old\" data binding from JSON to JDK objects;\n+ * Unit tests for verifying \"raw\" (or \"untyped\") data binding from JSON to JDK objects;\n  * one that only uses core JDK types; wrappers, Maps and Lists.\n  */\n+@SuppressWarnings(\"serial\")\n public class TestUntypedDeserialization\n     extends BaseMapTest\n {\n-    @SuppressWarnings(\"serial\")\n     static class UCStringDeserializer\n         extends StdScalarDeserializer<String>\n     {\n         public UCStringDeserializer() { super(String.class); }\n \n         @Override\n-        public String deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n+        public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n             return jp.getText().toUpperCase();\n         }\n     }\n \n-    @SuppressWarnings(\"serial\")\n     static class CustomNumberDeserializer\n         extends StdScalarDeserializer<Number>\n     {\n         }\n \n         @Override\n-        public Number deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n+        public Number deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n             return value;\n         }\n     }\n \n-    @SuppressWarnings(\"serial\")\n+    // Let's make this Contextual, to tease out cyclic resolution issues, if any\n     static class ListDeserializer extends StdDeserializer<List<Object>>\n+        implements ContextualDeserializer\n     {\n         public ListDeserializer() { super(List.class); }\n \n             }\n             return list;\n         }\n-    }\n-\n-    @SuppressWarnings(\"serial\")\n+\n+        @Override\n+        public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+                BeanProperty property) throws JsonMappingException\n+        {\n+            // For now, we just need to access \"untyped\" deserializer; not use it.\n+            \n+            /*JsonDeserializer<Object> ob = */\n+            ctxt.findContextualValueDeserializer(ctxt.constructType(Object.class), property);\n+            return this;\n+        }\n+    }\n+\n     static class MapDeserializer extends StdDeserializer<Map<String,Object>>\n     {\n         public MapDeserializer() { super(Map.class); }\n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestFormatDetection.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestFormatDetection.java\n     \n     public void testSimpleWithJSON() throws Exception\n     {\n-        ObjectReader detecting = READER.withType(POJO.class);\n+        ObjectReader detecting = READER.forType(POJO.class);\n         detecting = detecting.withFormatDetection(detecting);\n         POJO pojo = detecting.readValue(utf8Bytes(\"{\\\"x\\\":1}\"));\n         assertNotNull(pojo);\n \n     public void testInvalid() throws Exception\n     {\n-        ObjectReader detecting = READER.withType(POJO.class);\n+        ObjectReader detecting = READER.forType(POJO.class);\n         detecting = detecting.withFormatDetection(detecting);\n         try {\n             detecting.readValue(utf8Bytes(\"<POJO><x>1</x></POJO>\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestInferredMutators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestInferredMutators.java\n public class TestInferredMutators extends BaseMapTest\n {\n     public static class Point {\n-        private int x;\n+        protected int x;\n         \n         public int getX() { return x; }\n     }\n \n     public static class FixedPoint {\n-        private final int x;\n+        protected final int x;\n \n         public FixedPoint() { x = 0; }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java\n \n     public static class JacksonExample\n     {\n-        private String attributeProperty;\n-        private String elementProperty;\n-        private List<String> wrappedElementProperty;\n-        private EnumExample enumProperty;\n-        private QName qname;\n+        protected String attributeProperty;\n+        protected String elementProperty;\n+        protected List<String> wrappedElementProperty;\n+        protected EnumExample enumProperty;\n+        protected QName qname;\n \n         @JsonSerialize(using=QNameSerializer.class)\n         public QName getQname()\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestNameConflicts.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestNameConflicts.java\n \n public class TestNameConflicts extends BaseMapTest\n {\n+    @JsonAutoDetect\n+    (fieldVisibility= JsonAutoDetect.Visibility.NONE,getterVisibility= JsonAutoDetect.Visibility.NONE, setterVisibility= JsonAutoDetect.Visibility.NONE, isGetterVisibility= JsonAutoDetect.Visibility.NONE)\n+    static class CoreBean158 {\n+        protected String bar = \"x\";\n+\n+        @JsonProperty\n+        public String getBar() {\n+            return bar;\n+        }\n+\n+        @JsonProperty\n+        public void setBar(String bar) {\n+            this.bar = bar;\n+        }\n+\n+        public void setBar(java.io.Serializable bar) {\n+            this.bar = bar.toString();\n+        }\n+    }\n+    \n     static class Bean193\n     {\n         @JsonProperty(\"val1\")\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = objectMapper();\n+    \n     // [Issue#193]\n     public void testIssue193() throws Exception\n     {\n     // [Issue#327]\n     public void testNonConflict() throws Exception\n     {\n-        String json = objectMapper().writeValueAsString(new BogusConflictBean());\n+        String json = MAPPER.writeValueAsString(new BogusConflictBean());\n         assertEquals(aposToQuotes(\"{'prop1':2,'prop2':1}\"), json);\n     }    \n \n         String json = objectWriter().writeValueAsString(new MultipleTheoreticalGetters());\n         assertEquals(aposToQuotes(\"{'a':3}\"), json);\n     }\n+\n+    // for [jackson-core#158]\n+    public void testOverrideName() throws Exception\n+    {\n+        final ObjectMapper mapper = objectMapper();\n+        String json = mapper.writeValueAsString(new CoreBean158());\n+        assertEquals(aposToQuotes(\"{'bar':'x'}\"), json);\n+\n+        // and back\n+        CoreBean158 result = null;\n+        try {\n+            result = mapper.readValue(aposToQuotes(\"{'bar':'y'}\"), CoreBean158.class);\n+        } catch (Exception e) {\n+            fail(\"Unexpected failure when reading CoreBean158: \"+e);\n+        }\n+        assertNotNull(result);\n+        assertEquals(\"y\", result.bar);\n+    }    \n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractContainers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractContainers.java\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testAbstractLists() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         ListWrapper w = new ListWrapper();\n         w.list.add(\"x\");\n \n-        String json = mapper.writeValueAsString(w);\n-        Object o = mapper.readValue(json, ListWrapper.class);\n+        String json = MAPPER.writeValueAsString(w);\n+        Object o = MAPPER.readValue(json, ListWrapper.class);\n         assertEquals(ListWrapper.class, o.getClass());\n         ListWrapper out = (ListWrapper) o;\n+        assertNotNull(out.list);\n         assertEquals(1, out.list.size());\n         assertEquals(\"x\", out.list.get(0));\n    }\n     \n     public void testAbstractMaps() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         MapWrapper w = new MapWrapper();\n         w.map.put(\"key1\", \"name1\");\n \n-        String json = mapper.writeValueAsString(w);\n-        Object o = mapper.readValue(json, MapWrapper.class);\n+        String json = MAPPER.writeValueAsString(w);\n+        Object o = MAPPER.readValue(json, MapWrapper.class);\n         assertEquals(MapWrapper.class, o.getClass());\n         MapWrapper out = (MapWrapper) o;\n         assertEquals(1, out.map.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n \n-import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver;\n-import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.impl.TypeIdResolverBase;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n public class TestCustomTypeIdResolver extends BaseMapTest\n         }\n     }\n \n-    static class CustomResolverBase implements TypeIdResolver\n+    static class CustomResolverBase extends TypeIdResolverBase\n     {\n         protected final Class<?> superType;\n         protected final Class<?> subType;\n         public void init(JavaType baseType) { }\n \n         @Override\n-        public JavaType typeFromId(String id)\n+        public JavaType typeFromId(DatabindContext context, String id)\n         {\n             if (\"*\".equals(id)) {\n                 return TypeFactory.defaultInstance().constructType(subType);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n                 \".hype\");\n         // note: need to wrap, to get declared as Object\n         String json = m.writeValueAsString(new StringBean(\"abc\"));\n-\n-        System.err.println(\"JSON == \"+json);\n         \n         // Ok: serialization seems to work as expected. Now deserialize:\n         Object result = m.readValue(json, Object.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n \n import com.fasterxml.jackson.annotation.*;\n \n-import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.core.type.TypeReference;\n \n import com.fasterxml.jackson.databind.*;\n     public void testSubTypesFor356() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        /* 06-Sep-2010, tatus: This was not fixed for 1.6; and to keep junit test\n-         *   suite green, let's not run it for versions prior to 1.7...\n-         */\n-        Version v = mapper.version();\n-        if (v.getMajorVersion() == 1 && v.getMinorVersion() == 6) {\n-            System.err.println(\"Note: skipping test for Jackson 1.6\");\n-            return;\n-        }\n         \n         JSONResponse<List<Parent>> input = new JSONResponse<List<Parent>>();\n \n         mapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n \n         JavaType rootType = TypeFactory.defaultInstance().constructType(new TypeReference<JSONResponse<List<Parent>>>() { });\n-        byte[] json = mapper.writerWithType(rootType).writeValueAsBytes(input);\n-//        byte[] json = mapper.writeValueAsBytes(input);\n-\n-//        System.out.println(\"After Serialization: \" + new String(json));\n+        byte[] json = mapper.writerFor(rootType).writeValueAsBytes(input);\n         \n         JSONResponse<List<Parent>> out = mapper.readValue(json, 0, json.length, rootType);\n \n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestNoTypeInfo.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestNoTypeInfo.java\n {\n     @JsonTypeInfo(use=JsonTypeInfo.Id.NONE)\n     @JsonDeserialize(as=NoType.class)\n-    private static interface NoTypeInterface {\n+    static interface NoTypeInterface {\n     }\n     \n-    private final static class NoType implements NoTypeInterface {\n+    final static class NoType implements NoTypeInterface {\n         public int a = 3;\n     }\n     \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPolymorphicWithDefaultImpl.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+\n+/**\n+ * Unit tests related to specialized handling of \"default implementation\"\n+ * ({@link JsonTypeInfo#defaultImpl}), as well as related\n+ * cases that allow non-default settings (such as missing type id).\n+ */\n+public class TestPolymorphicWithDefaultImpl extends BaseMapTest\n+{\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\", defaultImpl = LegacyInter.class)\n+    @JsonSubTypes(value = {@JsonSubTypes.Type(name = \"mine\", value = MyInter.class)})\n+    public static interface Inter { }\n+\n+    public static class MyInter implements Inter {\n+        @JsonProperty(\"blah\") public List<String> blah;\n+    }\n+\n+    public static class LegacyInter extends MyInter\n+    {\n+        @JsonCreator\n+        LegacyInter(Object obj)\n+        {\n+            if (obj instanceof List) {\n+                blah = new ArrayList<String>();\n+                for (Object o : (List<?>) obj) {\n+                    blah.add(o.toString());\n+                }\n+            }\n+            else if (obj instanceof String) {\n+                blah = Arrays.asList(((String) obj).split(\",\"));\n+            }\n+            else {\n+                throw new IllegalArgumentException(\"Unknown type: \" + obj.getClass());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Note: <code>NoClass</code> here has special meaning, of mapping invalid\n+     * types into null instances.\n+     */\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\",\n+            defaultImpl = NoClass.class)\n+    public static class DefaultWithNoClass { }\n+\n+    /**\n+     * Also another variant to verify that from 2.5 on, can use non-deprecated\n+     * value for the same.\n+     */\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\",\n+            defaultImpl = Void.class)\n+    public static class DefaultWithVoidAsDefault { }\n+\n+    // and then one with no defaultImpl nor listed subtypes\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\")\n+    abstract static class MysteryPolymorphic { }\n+\n+    // [Databind#511] types\n+\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.WRAPPER_OBJECT)\n+    @JsonSubTypes(@JsonSubTypes.Type(name=\"sub1\", value = BadSub1.class))\n+    public static class BadItem {}\n+\n+    public static class BadSub1 extends BadItem {\n+        public String a ;\n+    }\n+\n+    public static class Good {\n+        public List<GoodItem> many;\n+    }\n+\n+    public static class Bad {\n+        public List<BadItem> many;\n+    }\n+ \n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.WRAPPER_OBJECT)\n+    @JsonSubTypes({@JsonSubTypes.Type(name=\"sub1\", value = GoodSub1.class),\n+            @JsonSubTypes.Type(name=\"sub2\", value = GoodSub2.class) })\n+    public static class GoodItem {}\n+\n+    public static class GoodSub1 extends GoodItem {\n+        public String a ;\n+    }\n+    public static class GoodSub2 extends GoodItem {\n+        public String b ;\n+\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests, deserialization\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testDeserializationWithObject() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"{\\\"type\\\": \\\"mine\\\", \\\"blah\\\": [\\\"a\\\", \\\"b\\\", \\\"c\\\"]}\");\n+        assertTrue(inter instanceof MyInter);\n+        assertFalse(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), ((MyInter) inter).blah);\n+    }\n+\n+    public void testDeserializationWithString() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"\\\"a,b,c,d\\\"\");\n+        assertTrue(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\"), ((MyInter) inter).blah);\n+    }\n+\n+    public void testDeserializationWithArray() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"[\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"]\");\n+        assertTrue(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\"), ((MyInter) inter).blah);\n+    }\n+\n+    public void testDeserializationWithArrayOfSize2() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"[\\\"a\\\", \\\"b\\\"]\");\n+        assertTrue(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\"), ((MyInter) inter).blah);\n+    }\n+\n+    // [Databind#148]\n+    public void testDefaultAsNoClass() throws Exception\n+    {\n+        Object ob = MAPPER.reader(DefaultWithNoClass.class).readValue(\"{ }\");\n+        assertNull(ob);\n+        ob = MAPPER.reader(DefaultWithNoClass.class).readValue(\"{ \\\"bogus\\\":3 }\");\n+        assertNull(ob);\n+    }\n+\n+    // same, with 2.5 and Void.class\n+    public void testDefaultAsVoid() throws Exception\n+    {\n+        Object ob = MAPPER.reader(DefaultWithVoidAsDefault.class).readValue(\"{ }\");\n+        assertNull(ob);\n+        ob = MAPPER.reader(DefaultWithVoidAsDefault.class).readValue(\"{ \\\"bogus\\\":3 }\");\n+        assertNull(ob);\n+    }\n+\n+    // [Databind#148]\n+    public void testBadTypeAsNull() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.disable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);\n+        Object ob = mapper.readValue(\"{}\", MysteryPolymorphic.class);\n+        assertNull(ob);\n+        ob = mapper.readValue(\"{ \\\"whatever\\\":13}\", MysteryPolymorphic.class);\n+        assertNull(ob);\n+    }\n+\n+    // [Databind#511]\n+    public void testInvalidTypeId511() throws Exception {\n+        ObjectReader reader = MAPPER.reader().without(\n+                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE,\n+                DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,\n+                DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES\n+        );\n+        String json = \"{\\\"many\\\":[{\\\"sub1\\\":{\\\"a\\\":\\\"foo\\\"}},{\\\"sub2\\\":{\\\"b\\\":\\\"bar\\\"}}]}\" ;\n+        Good goodResult = reader.forType(Good.class).readValue(json) ;\n+        assertNotNull(goodResult) ;\n+        Bad badResult = reader.forType(Bad.class).readValue(json);\n+        assertNotNull(badResult);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests, serialization\n+    /**********************************************************\n+     */\n+\n+    /*\n+    public void testDontWriteIfDefaultImpl() throws Exception {\n+        String json = MAPPER.writeValueAsString(new MyInter());\n+        assertEquals(\"{\\\"blah\\\":null}\", json);\n+    }\n+    */\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPropertyTypeInfo.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPropertyTypeInfo.java\n     \n     static class MethodWrapperBean\n     {\n-        private Object value;\n+        protected Object value;\n         \n         @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)\n         public Object getValue() { return value; }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypesExistingProperty.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestSubtypesExistingProperty extends BaseMapTest {\n+\n+    /**\n+     * Polymorphic base class - existing property as simple property on subclasses\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\",\n+\t        visible=true)\n+\t@JsonSubTypes({\n+\t\t@Type(value = Apple.class, name = \"apple\") ,\n+\t\t@Type(value = Orange.class, name = \"orange\") \n+\t\t})\n+\tstatic abstract class Fruit {\n+        public String name;\n+        protected Fruit(String n)  { name = n; }\n+    }\n+\n+    @JsonTypeName(\"apple\")\n+    static class Apple extends Fruit\n+    {\n+        public int seedCount;\n+        public String type;\n+\n+        private Apple() { super(null);; }\n+        public Apple(String name, int b) {\n+            super(name);\n+            seedCount = b;\n+            type = \"apple\";\n+        }\n+    }\n+    \n+    @JsonTypeName(\"orange\")\n+    static class Orange extends Fruit\n+    {\n+        public String color;\n+        public String type;\n+        \n+        private Orange() { super(null); }\n+        public Orange(String name, String c) {\n+            super(name);\n+            color = c;\n+            type = \"orange\";\n+        }\n+    }\n+\n+    static class FruitWrapper {\n+        public Fruit fruit;\n+        public FruitWrapper() {}\n+        public FruitWrapper(Fruit f) { fruit = f; }\n+    }\n+    \n+    /**\n+     * Polymorphic base class - existing property forced by abstract method\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Dog.class, name = \"doggie\") ,\n+\t\t@Type(value = Cat.class, name = \"kitty\") \n+\t\t})\n+\tstatic abstract class Animal {\n+        public String name;\n+        \n+        protected Animal(String n)  { name = n; }\n+        \n+        public abstract String getType();\n+    }\n+\n+    @JsonTypeName(\"doggie\")\n+    static class Dog extends Animal\n+    {\n+        public int boneCount;\n+        \n+        private Dog() { super(null); }\n+        public Dog(String name, int b) {\n+            super(name);\n+            boneCount = b;\n+        }\n+        \n+ \t\t@Override\n+\t\tpublic String getType() {\n+        \treturn \"doggie\";\n+        }        \n+    }\n+    \n+    @JsonTypeName(\"kitty\")\n+    static class Cat extends Animal\n+    {\n+        public String furColor;\n+        \n+        private Cat() { super(null); }\n+        public Cat(String name, String c) {\n+            super(name);\n+            furColor = c;\n+        }\n+        \n+\t\t@Override\n+\t\tpublic String getType() {\n+        \treturn \"kitty\";\n+        }        \n+    }\n+\n+    static class AnimalWrapper {\n+        public Animal animal;\n+        public AnimalWrapper() {}\n+        public AnimalWrapper(Animal a) { animal = a; }\n+    }\n+\n+\n+    /**\n+     * Polymorphic base class - existing property NOT forced by abstract method on base class\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Accord.class, name = \"accord\") ,\n+\t\t@Type(value = Camry.class, name = \"camry\") \n+\t\t})\n+\tstatic abstract class Car {\n+        public String name;        \n+        protected Car(String n)  { name = n; }\n+    }\n+\n+    @JsonTypeName(\"accord\")\n+    static class Accord extends Car\n+    {\n+        public int speakerCount;\n+        \n+        private Accord() { super(null); }\n+        public Accord(String name, int b) {\n+            super(name);\n+            speakerCount = b;\n+        }\n+        \n+\t\tpublic String getType() {\n+        \treturn \"accord\";\n+        }        \n+    }\n+    \n+    @JsonTypeName(\"camry\")\n+    static class Camry extends Car\n+    {\n+        public String exteriorColor;\n+        \n+        private Camry() { super(null); }\n+        public Camry(String name, String c) {\n+            super(name);\n+            exteriorColor = c;\n+        }\n+        \n+\t\tpublic String getType() {\n+        \treturn \"camry\";\n+        }        \n+    }\n+\n+    static class CarWrapper {\n+        public Car car;\n+        public CarWrapper() {}\n+        public CarWrapper(Car c) { car = c; }\n+    }\n+    \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    /*\n+    /**********************************************************\n+    /* Mock data\n+    /**********************************************************\n+     */\n+\n+\tprivate static final Orange mandarin = new Orange(\"Mandarin Orange\", \"orange\");\n+\tprivate static final String mandarinJson = \"{\\\"name\\\":\\\"Mandarin Orange\\\",\\\"color\\\":\\\"orange\\\",\\\"type\\\":\\\"orange\\\"}\";\t\n+\tprivate static final Apple pinguo = new Apple(\"Apple-A-Day\", 16);\n+\tprivate static final String pinguoJson = \"{\\\"name\\\":\\\"Apple-A-Day\\\",\\\"seedCount\\\":16,\\\"type\\\":\\\"apple\\\"}\";\n+\tprivate static final FruitWrapper pinguoWrapper = new FruitWrapper(pinguo);\n+\tprivate static final String pinguoWrapperJson = \"{\\\"fruit\\\":\" + pinguoJson + \"}\";\n+\tprivate static final List<Fruit> fruitList = Arrays.asList(pinguo, mandarin);\n+\tprivate static final String fruitListJson = \"[\" + pinguoJson + \",\" + mandarinJson + \"]\";\n+\n+\tprivate static final Cat beelzebub = new Cat(\"Beelzebub\", \"tabby\");\n+\tprivate static final String beelzebubJson = \"{\\\"name\\\":\\\"Beelzebub\\\",\\\"furColor\\\":\\\"tabby\\\",\\\"type\\\":\\\"kitty\\\"}\";\t\n+\tprivate static final Dog rover = new Dog(\"Rover\", 42);\n+\tprivate static final String roverJson = \"{\\\"name\\\":\\\"Rover\\\",\\\"boneCount\\\":42,\\\"type\\\":\\\"doggie\\\"}\";\n+\tprivate static final AnimalWrapper beelzebubWrapper = new AnimalWrapper(beelzebub);\n+\tprivate static final String beelzebubWrapperJson = \"{\\\"animal\\\":\" + beelzebubJson + \"}\";\n+\tprivate static final List<Animal> animalList = Arrays.asList(beelzebub, rover);\n+\tprivate static final String animalListJson = \"[\" + beelzebubJson + \",\" + roverJson + \"]\";\n+\n+\tprivate static final Camry camry = new Camry(\"Sweet Ride\", \"candy-apple-red\");\n+\tprivate static final String camryJson = \"{\\\"name\\\":\\\"Sweet Ride\\\",\\\"exteriorColor\\\":\\\"candy-apple-red\\\",\\\"type\\\":\\\"camry\\\"}\";\t\n+\tprivate static final Accord accord = new Accord(\"Road Rage\", 6);\n+\tprivate static final String accordJson = \"{\\\"name\\\":\\\"Road Rage\\\",\\\"speakerCount\\\":6,\\\"type\\\":\\\"accord\\\"}\";\n+\tprivate static final CarWrapper camryWrapper = new CarWrapper(camry);\n+\tprivate static final String camryWrapperJson = \"{\\\"car\\\":\" + camryJson + \"}\";\n+\tprivate static final List<Car> carList = Arrays.asList(camry, accord);\n+\tprivate static final String carListJson = \"[\" + camryJson + \",\" + accordJson + \"]\";\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fruits - serialization tests for simple property on sub-classes\n+     */\n+    public void testExistingPropertySerializationFruits() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, pinguo);\n+        assertEquals(3, result.size());\n+        assertEquals(pinguo.name, result.get(\"name\"));\n+        assertEquals(pinguo.seedCount, result.get(\"seedCount\"));\n+        assertEquals(pinguo.type, result.get(\"type\"));\n+        \n+        result = writeAndMap(MAPPER, mandarin);\n+        assertEquals(3, result.size());\n+        assertEquals(mandarin.name, result.get(\"name\"));\n+        assertEquals(mandarin.color, result.get(\"color\"));\n+        assertEquals(mandarin.type, result.get(\"type\"));\n+        \n+        String pinguoSerialized = MAPPER.writeValueAsString(pinguo);\n+        assertEquals(pinguoSerialized, pinguoJson);\n+\n+        String mandarinSerialized = MAPPER.writeValueAsString(mandarin);\n+        assertEquals(mandarinSerialized, mandarinJson);\n+\n+        String fruitWrapperSerialized = MAPPER.writeValueAsString(pinguoWrapper);\n+        assertEquals(fruitWrapperSerialized, pinguoWrapperJson);\n+\n+        String fruitListSerialized = MAPPER.writeValueAsString(fruitList);\n+        assertEquals(fruitListSerialized, fruitListJson);\n+    }\n+\n+    /**\n+     * Fruits - deserialization tests for simple property on sub-classes\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationFruits() throws Exception\n+    {\n+        Fruit pinguoDeserialized = MAPPER.readValue(pinguoJson, Fruit.class);\n+        assertTrue(pinguoDeserialized instanceof Apple);\n+        assertSame(pinguoDeserialized.getClass(), Apple.class);\n+        assertEquals(pinguo.name, pinguoDeserialized.name);\n+        assertEquals(pinguo.seedCount, ((Apple) pinguoDeserialized).seedCount);\n+        assertEquals(pinguo.type, ((Apple) pinguoDeserialized).type);\n+\n+        FruitWrapper pinguoWrapperDeserialized = MAPPER.readValue(pinguoWrapperJson, FruitWrapper.class);\n+        Fruit pinguoExtracted = pinguoWrapperDeserialized.fruit;\n+        assertTrue(pinguoExtracted instanceof Apple);\n+        assertSame(pinguoExtracted.getClass(), Apple.class);\n+        assertEquals(pinguo.name, pinguoExtracted.name);\n+        assertEquals(pinguo.seedCount, ((Apple) pinguoExtracted).seedCount);\n+        assertEquals(pinguo.type, ((Apple) pinguoExtracted).type);\n+\n+        Fruit[] fruits = MAPPER.readValue(fruitListJson, Fruit[].class);\n+        assertEquals(2, fruits.length);\n+        assertEquals(Apple.class, fruits[0].getClass());\n+        assertEquals(\"apple\", ((Apple) fruits[0]).type);\n+        assertEquals(Orange.class, fruits[1].getClass());\n+        assertEquals(\"orange\", ((Orange) fruits[1]).type);\n+        \n+        List<Fruit> f2 = MAPPER.readValue(fruitListJson,\n+                new TypeReference<List<Fruit>>() { });\n+        assertNotNull(f2);\n+        assertTrue(f2.size() == 2);\n+        assertEquals(Apple.class, f2.get(0).getClass());\n+        assertEquals(Orange.class, f2.get(1).getClass());\n+    }\n+\n+    /**\n+     * Animals - serialization tests for abstract method in base class\n+     */\n+    public void testExistingPropertySerializationAnimals() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, beelzebub);\n+        assertEquals(3, result.size());\n+        assertEquals(beelzebub.name, result.get(\"name\"));\n+        assertEquals(beelzebub.furColor, result.get(\"furColor\"));\n+        assertEquals(beelzebub.getType(), result.get(\"type\"));\n+\n+        result = writeAndMap(MAPPER, rover);\n+        assertEquals(3, result.size());\n+        assertEquals(rover.name, result.get(\"name\"));\n+        assertEquals(rover.boneCount, result.get(\"boneCount\"));\n+        assertEquals(rover.getType(), result.get(\"type\"));\n+        \n+        String beelzebubSerialized = MAPPER.writeValueAsString(beelzebub);\n+        assertEquals(beelzebubSerialized, beelzebubJson);\n+        \n+        String roverSerialized = MAPPER.writeValueAsString(rover);\n+        assertEquals(roverSerialized, roverJson);\n+        \n+        String animalWrapperSerialized = MAPPER.writeValueAsString(beelzebubWrapper);\n+        assertEquals(animalWrapperSerialized, beelzebubWrapperJson);\n+\n+        String animalListSerialized = MAPPER.writeValueAsString(animalList);\n+        assertEquals(animalListSerialized, animalListJson);\n+    }\n+\n+    /**\n+     * Animals - deserialization tests for abstract method in base class\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationAnimals() throws Exception\n+    {\n+        Animal beelzebubDeserialized = MAPPER.readValue(beelzebubJson, Animal.class);\n+        assertTrue(beelzebubDeserialized instanceof Cat);\n+        assertSame(beelzebubDeserialized.getClass(), Cat.class);\n+        assertEquals(beelzebub.name, beelzebubDeserialized.name);\n+        assertEquals(beelzebub.furColor, ((Cat) beelzebubDeserialized).furColor);\n+        assertEquals(beelzebub.getType(), beelzebubDeserialized.getType());\n+\n+        AnimalWrapper beelzebubWrapperDeserialized = MAPPER.readValue(beelzebubWrapperJson, AnimalWrapper.class);\n+        Animal beelzebubExtracted = beelzebubWrapperDeserialized.animal;\n+        assertTrue(beelzebubExtracted instanceof Cat);\n+        assertSame(beelzebubExtracted.getClass(), Cat.class);\n+        assertEquals(beelzebub.name, beelzebubExtracted.name);\n+        assertEquals(beelzebub.furColor, ((Cat) beelzebubExtracted).furColor);\n+        assertEquals(beelzebub.getType(), beelzebubExtracted.getType());\n+    \t\n+        @SuppressWarnings(\"unchecked\")\n+        List<Animal> animalListDeserialized = MAPPER.readValue(animalListJson, List.class);\n+        assertNotNull(animalListDeserialized);\n+        assertTrue(animalListDeserialized.size() == 2);\n+        Animal cat = MAPPER.convertValue(animalListDeserialized.get(0), Animal.class);\n+        assertTrue(cat instanceof Cat);\n+        assertSame(cat.getClass(), Cat.class);\n+        Animal dog = MAPPER.convertValue(animalListDeserialized.get(1), Animal.class);\n+        assertTrue(dog instanceof Dog);\n+        assertSame(dog.getClass(), Dog.class);\n+    }\n+\n+    /**\n+     * Cars - serialization tests for no abstract method or type variable in base class\n+     */\n+    public void testExistingPropertySerializationCars() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, camry);\n+        assertEquals(3, result.size());\n+        assertEquals(camry.name, result.get(\"name\"));\n+        assertEquals(camry.exteriorColor, result.get(\"exteriorColor\"));\n+        assertEquals(camry.getType(), result.get(\"type\"));\n+\n+        result = writeAndMap(MAPPER, accord);\n+        assertEquals(3, result.size());\n+        assertEquals(accord.name, result.get(\"name\"));\n+        assertEquals(accord.speakerCount, result.get(\"speakerCount\"));\n+        assertEquals(accord.getType(), result.get(\"type\"));\n+        \n+        String camrySerialized = MAPPER.writeValueAsString(camry);\n+        assertEquals(camrySerialized, camryJson);\n+        \n+        String accordSerialized = MAPPER.writeValueAsString(accord);\n+        assertEquals(accordSerialized, accordJson);\n+        \n+        String carWrapperSerialized = MAPPER.writeValueAsString(camryWrapper);\n+        assertEquals(carWrapperSerialized, camryWrapperJson);\n+\n+        String carListSerialized = MAPPER.writeValueAsString(carList);\n+        assertEquals(carListSerialized, carListJson);\n+    }\n+\n+    /**\n+     * Cars - deserialization tests for no abstract method or type variable in base class\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationCars() throws Exception\n+    {\n+        Car camryDeserialized = MAPPER.readValue(camryJson, Camry.class);\n+        assertTrue(camryDeserialized instanceof Camry);\n+        assertSame(camryDeserialized.getClass(), Camry.class);\n+        assertEquals(camry.name, camryDeserialized.name);\n+        assertEquals(camry.exteriorColor, ((Camry) camryDeserialized).exteriorColor);\n+        assertEquals(camry.getType(), ((Camry) camryDeserialized).getType());\n+\n+        CarWrapper camryWrapperDeserialized = MAPPER.readValue(camryWrapperJson, CarWrapper.class);\n+        Car camryExtracted = camryWrapperDeserialized.car;\n+        assertTrue(camryExtracted instanceof Camry);\n+        assertSame(camryExtracted.getClass(), Camry.class);\n+        assertEquals(camry.name, camryExtracted.name);\n+        assertEquals(camry.exteriorColor, ((Camry) camryExtracted).exteriorColor);\n+        assertEquals(camry.getType(), ((Camry) camryExtracted).getType());\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<Car> carListDeserialized = MAPPER.readValue(carListJson, List.class);\n+        assertNotNull(carListDeserialized);\n+        assertTrue(carListDeserialized.size() == 2);\n+        Car result = MAPPER.convertValue(carListDeserialized.get(0), Car.class);\n+        assertTrue(result instanceof Camry);\n+        assertSame(result.getClass(), Camry.class);\n+\n+        result = MAPPER.convertValue(carListDeserialized.get(1), Car.class);\n+        assertTrue(result instanceof Accord);\n+        assertSame(result.getClass(), Accord.class);\n+    }\n+}    \n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArrayDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArrayDeserialization.java\n     {\n         ObjectMapper m = new ObjectMapper();\n         // use class name, WRAPPER_OBJECT\n-        m.addMixInAnnotations(long[].class, WrapperMixIn.class);\n+        m.addMixIn(long[].class, WrapperMixIn.class);\n         String JSON = \"{\\\"\"+long[].class.getName()+\"\\\":[5, 6, 7]}\";\n         long[] value = m.readValue(JSON, long[].class);\n         assertNotNull(value);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n     public void testIntArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(int[].class, WrapperMixIn.class);\n+        m.addMixIn(int[].class, WrapperMixIn.class);\n         int[] input = new int[] { 1, 2, 3 };\n         String clsName = int[].class.getName();\n         assertEquals(\"{\\\"\"+clsName+\"\\\":[1,2,3]}\", serializeAsString(m, input));\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedContainerSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedContainerSerialization.java\n             ArrayList<Animal> animals = new ArrayList<Animal>();\n             animals.add(new Dog(\"Spot\"));\n             JavaType rootType = TypeFactory.defaultInstance().constructParametrizedType(Iterator.class, Iterator.class, Animal.class);\n-            String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator());\n+            String json = mapper.writerFor(rootType).writeValueAsString(animals.iterator());\n             if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n                 fail(\"No polymorphic type retained, should be; JSON = '\"+json+\"'\");\n             }\n             l2.add(new Issue508A());\n             l.add(l2);\n             TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() {};\n-            String json = mapper.writerWithType(typeRef).writeValueAsString(l);\n+            String json = mapper.writerFor(typeRef).writeValueAsString(l);\n \n             List<?> output = mapper.readValue(json, typeRef);\n             assertEquals(1, output.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserialization.java\n     public void testTypeAsWrapper() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Animal.class, TypeWithWrapper.class);\n+        m.addMixIn(Animal.class, TypeWithWrapper.class);\n         String JSON = \"{\\\".TestTypedDeserialization$Dog\\\" : \"\n             +asJSONObjectValueString(m, \"name\", \"Scooby\", \"boneCount\", \"6\")+\" }\";\n         Animal a = m.readValue(JSON, Animal.class);\n     public void testTypeAsArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Animal.class, TypeWithArray.class);\n+        m.addMixIn(Animal.class, TypeWithArray.class);\n         // hmmh. Not good idea to rely on exact output, order may change. But...\n         String JSON = \"[\\\"\"+Dog.class.getName()+\"\\\", \"\n             +asJSONObjectValueString(m, \"name\", \"Martti\", \"boneCount\", \"11\")+\" ]\";\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n     public void testTypeAsWrapper() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Animal.class, TypeWithWrapper.class);\n+        m.addMixIn(Animal.class, TypeWithWrapper.class);\n         Map<String,Object> result = writeAndMap(m, new Cat(\"Venla\", \"black\"));\n         // should get a wrapper; keyed by minimal class name (\"Cat\" here)\n         assertEquals(1, result.size());\n     public void testTypeAsArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Animal.class, TypeWithArray.class);\n+        m.addMixIn(Animal.class, TypeWithArray.class);\n         // hmmh. Not good idea to rely on exact output, order may change. But...\n         Map<String,Object> result = writeAndMap(m, new AnimalWrapper(new Dog(\"Amadeus\", 7)));\n         // First level, wrapper\n         List<Super> list = new ArrayList<Super>();\n         list.add(new A());\n         map.put(1L, list);\n-        String json = mapper.writerWithType(new TypeReference<Map<Long, Collection<Super>>>() {}).writeValueAsString(map);\n+        String json = mapper.writerFor(new TypeReference<Map<Long, Collection<Super>>>() {}).writeValueAsString(map);\n         assertTrue(\"JSON does not contain '@class': \"+json, json.contains(\"@class\"));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestVisibleTypeId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestVisibleTypeId.java\n package com.fasterxml.jackson.databind.jsontype;\n \n-import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n-import com.fasterxml.jackson.annotation.JsonSubTypes;\n-import com.fasterxml.jackson.annotation.JsonTypeId;\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n-import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n import com.fasterxml.jackson.databind.*;\n \n /**\n         public void setType(String t) { type = t; }\n     }\n \n-    // as external id, bit trickier\n-    static class ExternalIdWrapper {\n-        @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.EXTERNAL_PROPERTY,\n-                property=\"type\", visible=true)\n-        public ExternalIdBean bean = new ExternalIdBean();\n-    }\n-    \n     @JsonTypeName(\"ExternalType\")\n     static class ExternalIdBean {\n         public int a = 2;\n         public String getName() { return \"bob\"; }\n         \n         public int age = 41;\n+    }\n+\n+    // [databind#408]\n+    static class ExternalBeanWithId\n+    {\n+        protected String _type;\n+        \n+        @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property=\"type\", visible=true)\n+        public ValueBean bean;\n+\n+        public ExternalBeanWithId() { }\n+        public ExternalBeanWithId(int v) {\n+            bean = new ValueBean(v);\n+        }\n+\n+        public void setType(String t) {\n+            _type = t;\n+        }\n+    }\n+\n+    @JsonTypeName(\"vbean\")\n+    static class ValueBean {\n+        public int value;\n+        \n+        public ValueBean() { }\n+        public ValueBean(int v) { value = v; }\n     }\n     \n     /*\n         assertEquals(\"ObjectType\", result.type);\n     }\n \n-    public void testVisibleWithExternalId() throws Exception\n-    {\n-        String json = MAPPER.writeValueAsString(new ExternalIdWrapper());\n-        // but then expect to read it back\n-        ExternalIdWrapper result = MAPPER.readValue(json, ExternalIdWrapper.class);\n-        assertEquals(\"ExternalType\", result.bean.type);\n-        assertEquals(2, result.bean.a);\n-    }\n-\n-    // [JACKSON-762]\n-\n     public void testTypeIdFromProperty() throws Exception\n     {\n         assertEquals(\"{\\\"type\\\":\\\"SomeType\\\",\\\"a\\\":3}\",\n         I263Base result = MAPPER.readValue(\"{\\\"age\\\":19,\\\"name\\\":\\\"bob\\\"}\", I263Base.class);\n         assertTrue(result instanceof I263Impl);\n         assertEquals(19, ((I263Impl) result).age);\n+    }\n+\n+    // [databind#408]\n+    /* NOTE: Handling changed between 2.4 and 2.5; earlier, type id was 'injected'\n+     *  inside POJO; but with 2.5 this was fixed so it would remain outside, similar\n+     *  to how JSON structure is.\n+     */\n+    public void testVisibleTypeId408() throws Exception\n+    {\n+        String json = MAPPER.writeValueAsString(new ExternalBeanWithId(3));\n+        ExternalBeanWithId result = MAPPER.readValue(json, ExternalBeanWithId.class);\n+        assertNotNull(result);\n+        assertNotNull(result.bean);\n+        assertEquals(3, result.bean.value);\n+        assertEquals(\"vbean\", result._type);\n     }\n     \n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n         public MyParam(T v) { value = v; }\n     }\n \n-    private static class SomeObject {\n-        @SuppressWarnings(\"unused\")\n+    static class SomeObject {\n         public String someValue = UUID.randomUUID().toString();\n     }\n     \n     {\n         Dog dog = new Dog(\"Fluffy\", 3);\n         ContainerWithGetter<Animal> c2 = new ContainerWithGetter<Animal>(dog);\n-        String json = MAPPER.writerWithType(MAPPER.getTypeFactory().constructParametrizedType(ContainerWithGetter.class, ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);\n+        String json = MAPPER.writerFor(MAPPER.getTypeFactory().constructParametrizedType(ContainerWithGetter.class, ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);\n         if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n             fail(\"polymorphic type not kept, result == \"+json+\"; should contain 'object-type':'...'\");\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForClass.java\n          * use field\n          */\n         m = new ObjectMapper();\n-        m.addMixInAnnotations(LeafClass.class, MixIn.class);\n+        m.addMixIn(LeafClass.class, MixIn.class);\n         result = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\", LeafClass.class);\n         assertEquals(\"value\", result.a);\n     }\n     public void testClassMixInsMidLevel() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        m.addMixIn(BaseClass.class, MixIn.class);\n         {\n             BaseClass result = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\", BaseClass.class);\n             assertEquals(\"value\", result.a);\n     public void testClassMixInsForObjectClass() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Object.class, MixIn.class);\n+        m.addMixIn(Object.class, MixIn.class);\n         // will be seen for BaseClass\n         {\n             BaseClass result = m.readValue(\"{\\\"a\\\":\\\"\\\"}\", BaseClass.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForCreators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForCreators.java\n     public void testForConstructor() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(BaseClassWithPrivateCtor.class, MixInForPrivate.class);\n+        m.addMixIn(BaseClassWithPrivateCtor.class, MixInForPrivate.class);\n         BaseClassWithPrivateCtor result = m.readValue(\"\\\"?\\\"\", BaseClassWithPrivateCtor.class);\n         assertEquals(\"?...\", result._a);\n     }\n \n         // Then with simple mix-in: should change to use the factory method\n         m = new ObjectMapper();\n-        m.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        m.addMixIn(BaseClass.class, MixIn.class);\n         result = m.readValue(\"\\\"string\\\"\", BaseClass.class);\n         assertEquals(\"stringX\", result._a);\n     }\n     public void testFactoryMixIn() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(StringWrapper.class, StringWrapperMixIn.class);\n+        m.addMixIn(StringWrapper.class, StringWrapperMixIn.class);\n         StringWrapper result = m.readValue(\"\\\"a\\\"\", StringWrapper.class);\n         assertEquals(\"a\", result._value);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForMethods.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForMethods.java\n     public void testWithAnySetter() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        m.addMixIn(BaseClass.class, MixIn.class);\n         BaseClass result = m.readValue(\"{ \\\"a\\\" : 3, \\\"b\\\" : true }\", BaseClass.class);\n         assertNotNull(result);\n         assertEquals(2, result.values.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinInheritance.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinInheritance.java\n     public void testMixinFieldInheritance() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(Beano.class, BeanoMixinSub.class);\n+        mapper.addMixIn(Beano.class, BeanoMixinSub.class);\n         Map<String,Object> result;\n         result = writeAndMap(mapper, new Beano());\n         assertEquals(2, result.size());\n     public void testMixinMethodInheritance() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(Beano2.class, BeanoMixinSub2.class);\n+        mapper.addMixIn(Beano2.class, BeanoMixinSub2.class);\n         Map<String,Object> result;\n         result = writeAndMap(mapper, new Beano2());\n         assertEquals(2, result.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForClass.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n-\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n \n public class TestMixinSerForClass\n     extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper bean classes\n-    /**********************************************************\n-     */\n-\n-    @JsonSerialize(include=JsonSerialize.Inclusion.ALWAYS)\n+    @JsonInclude(JsonInclude.Include.ALWAYS)\n     static class BaseClass\n     {\n         protected String _a, _b;\n         public String getC() { return _c; }\n     }\n \n-    @JsonSerialize(include=JsonSerialize.Inclusion.NON_DEFAULT)\n+    @JsonInclude(JsonInclude.Include.NON_DEFAULT)\n     static class LeafClass\n         extends BaseClass\n     {\n      * annotations it has can be virtually added to mask annotations\n      * of other classes\n      */\n-    @JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)\n+    @JsonInclude(JsonInclude.Include.NON_NULL)\n     interface MixIn { }\n \n     // test disabling of autodetect...\n     @JsonAutoDetect(getterVisibility=Visibility.NONE, fieldVisibility=Visibility.NONE)\n     interface MixInAutoDetect { }\n+\n+    // [databind#245]\n+    @JsonFilter(PortletRenderExecutionEventFilterMixIn.FILTER_NAME)\n+    private interface PortletRenderExecutionEventFilterMixIn {\n+        static final String FILTER_NAME = \"PortletRenderExecutionEventFilter\";\n+    }\n \n     /*\n     /**********************************************************\n \n         // then with top-level override\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(LeafClass.class, MixIn.class);\n+        mapper.addMixIn(LeafClass.class, MixIn.class);\n         result = writeAndMap(mapper, new LeafClass(\"abc\"));\n         assertEquals(2, result.size());\n         assertEquals(\"abc\", result.get(\"a\"));\n \n         // mid-level override; should not have any effect\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixIn(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, new LeafClass(\"abc\"));\n         assertEquals(1, result.size());\n         assertEquals(\"abc\", result.get(\"a\"));\n \n         // then with working mid-level override, which effectively suppresses 'a'\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(BaseClass.class, MixInAutoDetect.class);\n+        mapper.addMixIn(BaseClass.class, MixInAutoDetect.class);\n         result = writeAndMap(mapper, bean);\n+        assertEquals(1, result.size());\n+        assertEquals(\"c2\", result.get(\"c\"));\n+\n+        // and related to [databind#245], apply mix-ins to a copy of ObjectMapper\n+        ObjectMapper mapper2 = new ObjectMapper();\n+        result = writeAndMap(mapper2, bean);\n+        assertEquals(2, result.size());\n+        ObjectMapper mapper3 = mapper2.copy();\n+        mapper3.addMixIn(BaseClass.class, MixInAutoDetect.class);\n+        result = writeAndMap(mapper3, bean);\n         assertEquals(1, result.size());\n         assertEquals(\"c2\", result.get(\"c\"));\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForFields.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForFields.java\n \n         // and then with simple mix-in\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixIn(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(2, result.size());\n         assertEquals(\"1\", result.get(\"a\"));\n         HashMap<Class<?>,Class<?>> mixins = new HashMap<Class<?>,Class<?>>();\n         mixins.put(SubClass.class, MixIn.class);\n         mixins.put(BaseClass.class, MixIn2.class);\n-        mapper.setMixInAnnotations(mixins);\n+        mapper.setMixIns(mixins);\n \n         Map<String,Object> result;\n         result = writeAndMap(mapper, new SubClass(\"1\", \"2\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForMethods.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForMethods.java\n \n         // then with leaf-level mix-in\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixIn(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(2, result.size());\n         assertEquals(\"b2\", result.get(\"b2\"));\n         Map<String,Object> result;\n         LeafClass bean = new LeafClass(\"XXX\", \"b2\");\n \n-        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixIn(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(1, result.size());\n         assertEquals(\"XXX\", result.get(\"a\"));\n     public void testIntermediateMixin2() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(EmptyBean.class, MixInForSimple.class);\n+        mapper.addMixIn(EmptyBean.class, MixInForSimple.class);\n         Map<String,Object> result = writeAndMap(mapper, new SimpleBean());\n         assertEquals(1, result.size());\n         assertEquals(Integer.valueOf(42), result.get(\"x\"));\n     public void testObjectMixin() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(Object.class, ObjectMixIn.class);\n+        mapper.addMixIn(Object.class, ObjectMixIn.class);\n \n         // First, with our bean...\n         Map<String,Object> result = writeAndMap(mapper, new BaseClass(\"a\", \"b\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n \n         // Property SerializationConfig.SerializationFeature.DEFAULT_VIEW_INCLUSION set to false\n         mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, Boolean.FALSE);\n-        mapper.addMixInAnnotations(A.class, AMixInAnnotation.class);\n+        mapper.addMixIn(A.class, AMixInAnnotation.class);\n         String json = mapper.writerWithView(AView.class).writeValueAsString(a);\n \n         assertTrue(json.indexOf(\"\\\"name\\\"\") > 0);\n       sourceMixins.put( SimpleTestData.class, TestDataJAXBMixin.class );\n       sourceMixins.put( ComplexTestData.class, TestComplexDataJAXBMixin.class );\n       \n-      objectMapper.setMixInAnnotations(sourceMixins);\n+      objectMapper.setMixIns(sourceMixins);\n       return objectMapper;\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestDuplicateRegistration.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestDuplicateRegistration extends BaseMapTest\n+{\n+    static class MyModule extends Module {\n+        public int regCount;\n+        \n+        public MyModule() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getModuleName() {\n+            return \"TestModule\";\n+        }\n+\n+        @Override\n+        public Version version() {\n+            return Version.unknownVersion();\n+        }\n+\n+        @Override\n+        public void setupModule(SetupContext context) {\n+            ++regCount;\n+        }\n+    }\n+\n+    public void testDuplicateRegistration() throws Exception\n+    {\n+        // by default, duplicate registration should be prevented\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertTrue(mapper.isEnabled(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS));\n+        MyModule module = new MyModule();\n+        mapper.registerModule(module);\n+        mapper.registerModule(module);\n+        mapper.registerModule(module);\n+        assertEquals(1, module.regCount);\n+\n+        // but may be allowed by changing setting\n+        mapper.disable(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS);\n+        mapper.registerModule(module);\n+        assertEquals(2, module.regCount);\n+\n+        // and ditto for a new instance\n+        ObjectMapper mapper2 = new ObjectMapper();\n+        mapper2.disable(MapperFeature.IGNORE_DUPLICATE_MODULE_REGISTRATIONS);\n+        MyModule module2 = new MyModule();\n+        mapper.registerModule(module2);\n+        mapper.registerModule(module2);\n+        mapper.registerModule(module2);\n+        assertEquals(3, module2.regCount);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n             assertNotNull(m);\n         }\n     }\n-    \n+\n+    static class TestModule626 extends SimpleModule {\n+        final Class<?> mixin, target;\n+        public TestModule626(Class<?> t, Class<?> m) {\n+            super(\"Test\");\n+            target = t;\n+            mixin = m;\n+        }\n+\n+        @Override\n+        public void setupModule(SetupContext context) {\n+            context.setMixInAnnotations(target, mixin);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests; first, verifying need for custom handlers\n             verifyException(e, \"No suitable constructor found\");\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Unit tests; simple serializers\n     /**********************************************************\n      */\n-    \n+\n     public void testSimpleBeanSerializer() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         ObjectMapper mapper = new ObjectMapper();\n         mapper.registerModule(module);\n     }\n+\n+    // [databind#626]\n+    public void testMixIns626() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // no real annotations, but nominally add ones from 'String' to 'Object', just for testing\n+        mapper.registerModule(new TestModule626(Object.class, String.class));\n+        Class<?> found = mapper.findMixInClassFor(Object.class);\n+        assertEquals(String.class, found);\n+    }\n }\n-\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifierNameResolution.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifierNameResolution.java\n \t{\n \t\tObjectMapper mapper = new ObjectMapper();\n \t\tmapper.setTypeFactory(mapper.getTypeFactory().withModifier(new CustomTypeModifier()));\n-\t\tmapper.addMixInAnnotations(MyType.class, Mixin.class);\n+\t\tmapper.addMixIn(MyType.class, Mixin.class);\n \n \t\tMyType obj = new MyTypeImpl();\n \t\tobj.setData(\"something\");\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n     {\n         String JSON = \"{\\\"leaf\\\":{\\\"value\\\":13}}\";\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(Leaf.class, LeafMixIn.class);\n+        mapper.addMixIn(Leaf.class, LeafMixIn.class);\n         JsonNode root = mapper.readTree(JSON);\n         // Ok, try converting to bean using two mechanisms\n         Root r1 = mapper.treeToValue(root, Root.class);\n     public void testBigDecimalAsPlainStringTreeConversion() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.enable(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n+        mapper.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n         Map<String, Object> map = new HashMap<String, Object>();\n         String PI_STR = \"3.00000000\";\n         map.put(\"pi\", new BigDecimal(PI_STR));\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n import java.math.BigDecimal;\n import java.math.BigInteger;\n \n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonToken;\n-\n import com.fasterxml.jackson.databind.*;\n \n /**\n     {\n         ObjectMapper mapper = new ObjectMapper()\n                 .enable(DeserializationFeature.USE_BIG_DECIMAL_FOR_FLOATS)\n-                .enable(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n+                .enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n         final String INPUT = \"{\\\"x\\\":1e2}\";\n         final JsonNode node = mapper.readTree(INPUT);\n         String result = mapper.writeValueAsString(node);\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnyGetter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnyGetter.java\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializationFeature;\n \n-public class TestAnyGetter\n-    extends BaseMapTest\n+public class TestAnyGetter extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper bean classes\n-    /**********************************************************\n-     */\n-\n     static class Bean\n     {\n         final static Map<String,Boolean> extra = new HashMap<String,Boolean>();\n         }\n     }\n \n+    static class MapAsAny\n+    {\n+        protected Map<String,Object> stuff = new LinkedHashMap<String,Object>();\n+        \n+        @JsonAnyGetter\n+        public Map<String,Object> any() {\n+            return stuff;\n+        }\n+\n+        public void add(String key, Object value) {\n+            stuff.put(key, value);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Test cases\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testSimpleJsonValue() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        String json = serializeAsString(m, new Bean());\n-        Map<?,?> map = m.readValue(json, Map.class);\n+        String json = MAPPER.writeValueAsString(new Bean());\n+        Map<?,?> map = MAPPER.readValue(json, Map.class);\n         assertEquals(2, map.size());\n         assertEquals(Integer.valueOf(3), map.get(\"x\"));\n         assertEquals(Boolean.TRUE, map.get(\"a\"));\n         json = serializeAsString(m, new AnyOnlyBean());\n         assertEquals(\"{\\\"a\\\":3}\", json);\n     }\n+\n+    // Trying to repro [databind#577]\n+    public void testAnyWithNull() throws Exception\n+    {\n+        MapAsAny input = new MapAsAny();\n+        input.add(\"bar\", null);\n+        assertEquals(aposToQuotes(\"{'bar':null}\"),\n+                MAPPER.writeValueAsString(input));\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n         public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\n                 BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n         {\n-            System.err.println(\"DEBUG: changeProperties!\");\n             return beanProperties;\n         }\n         \n         @Override\n         public JsonSerializer<?> modifySerializer(SerializationConfig config,\n                 BeanDescription beanDesc, JsonSerializer<?> serializer) {\n-System.err.println(\"DEBUG: modifySer!\");            \n             return new BogusBeanSerializer(42);\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.ser.std.CollectionSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\n+import com.fasterxml.jackson.databind.ser.std.StdScalarSerializer;\n import com.fasterxml.jackson.databind.util.StdConverter;\n \n /**\n         }\n     }\n \n+    // for [databind#631]\n+    static class Issue631Bean\n+    {\n+        @JsonSerialize(using=ParentClassSerializer.class)\n+        public Object prop;\n+\n+        public Issue631Bean(Object o) {\n+            prop = o;\n+        }\n+    }\n+    \n+    static class ParentClassSerializer\n+        extends StdScalarSerializer<Object>\n+    {\n+        protected ParentClassSerializer() {\n+            super(Object.class);\n+        }\n+\n+        @Override\n+        public void serialize(Object value, JsonGenerator gen,\n+                SerializerProvider provider) throws IOException {\n+            Object parent = gen.getCurrentValue();\n+            String desc = (parent == null) ? \"NULL\" : parent.getClass().getSimpleName();\n+            gen.writeString(desc+\"/\"+value);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Unit tests\n     public void testCustomization() throws Exception\n     {\n         ObjectMapper objectMapper = new ObjectMapper();\n-        objectMapper.addMixInAnnotations(Element.class, ElementMixin.class);\n+        objectMapper.addMixIn(Element.class, ElementMixin.class);\n         Element element = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument().createElement(\"el\");\n         StringWriter sw = new StringWriter();\n         objectMapper.writeValue(sw, element);\n     // [Issue#215]: Allow registering CharacterEscapes via ObjectWriter\n     public void testCustomEscapes() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         assertEquals(quote(\"foo\\\\u0062\\\\Ar\"),\n-                mapper.writer(new CustomEscapes()).writeValueAsString(\"foobar\"));\n+                MAPPER.writer(new CustomEscapes()).writeValueAsString(\"foobar\"));\n     }\n     \n     public void testNumberSubclass() throws Exception\n         assertEquals(aposToQuotes(\"{'x':42}\"),\n                 MAPPER.writeValueAsString(new LikeNumber(42)));\n     }\n+\n+    public void testWithCurrentValue() throws Exception\n+    {\n+        assertEquals(aposToQuotes(\"{'prop':'Issue631Bean/42'}\"),\n+                MAPPER.writeValueAsString(new Issue631Bean(42)));\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n \n         // Including class annotation through mix-ins\n         ObjectMapper m2 = new ObjectMapper();\n-        m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class);\n+        m2.addMixIn(Empty.class, EmptyWithAnno.class);\n         assertEquals(\"{}\", m2.writeValueAsString(new Empty()));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.annotation.JsonValue;\n-\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n         public OK text = OK.V1;\n     }\n     \n-    @JsonFormat(shape=JsonFormat.Shape.ARRAY) // not supported as of now\n-    static enum BrokenPoNum\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY) // alias for 'number', as of 2.5\n+    static enum PoAsArray\n     {\n         A, B;\n     }\n                 SerializerProvider provider) throws IOException {\n             jgen.writeString(value.name().toLowerCase());\n         }\n+    }\n+\n+    // for [databind#572]\n+    static class PoOverrideAsString\n+    {\n+        @JsonFormat(shape=Shape.STRING)\n+        public PoNUM value = PoNUM.B;\n+    }\n+\n+    static class PoOverrideAsNumber\n+    {\n+        @JsonFormat(shape=Shape.NUMBER)\n+        public PoNUM value = PoNUM.B;\n     }\n     \n     /*\n         assertEquals(\"\\\"B\\\"\", mapper.writeValueAsString(EnumWithSubClass.B));\n     }\n \n-    // [JACKSON-193]\n     public void testEnumsWithJsonValue() throws Exception\n     {\n         assertEquals(\"\\\"bar\\\"\", mapper.writeValueAsString(EnumWithJsonValue.B));\n     }\n \n-    // also, for [JACKSON-193], needs to work via mix-ins\n     public void testEnumsWithJsonValueUsingMixin() throws Exception\n     {\n         // can't share, as new mix-ins are added\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(TestEnum.class, ToStringMixin.class);\n+        m.addMixIn(TestEnum.class, ToStringMixin.class);\n         assertEquals(\"\\\"b\\\"\", m.writeValueAsString(TestEnum.B));\n     }\n \n+    // [databind#601]\n+    public void testEnumsWithJsonValueInMap() throws Exception\n+    {\n+        EnumMap<EnumWithJsonValue,String> input = new EnumMap<EnumWithJsonValue,String>(EnumWithJsonValue.class);\n+        input.put(EnumWithJsonValue.B, \"x\");\n+        assertEquals(\"{\\\"\"+EnumWithJsonValue.B.toString()+\"\\\":\\\"x\\\"}\", mapper.writeValueAsString(input));\n+    }\n+    \n     /**\n      * Test for ensuring that @JsonSerializable is used with Enum types as well\n      * as with any other types.\n     public void testEnumAsIndexViaAnnotations() throws Exception {\n         assertEquals(\"{\\\"text\\\":0}\", mapper.writeValueAsString(new PoNUMContainer()));\n     }\n-    \n+\n+    // As of 2.5, use of Shape.ARRAY is legal alias for \"write as number\"\n     public void testEnumAsObjectBroken() throws Exception\n     {\n-        try {\n-            String json = mapper.writeValueAsString(BrokenPoNum.A);\n-            fail(\"Should not have succeeded, produced: \"+json);\n-        } catch (JsonMappingException e) {\n-            verifyException(e, \"Unsupported serialization shape\");\n-        }\n+        assertEquals(\"0\", mapper.writeValueAsString(PoAsArray.A));\n     }\n     \n     // [Issue#227]\n         module.addSerializer(Enum.class, new LowerCasingEnumSerializer());\n         m.registerModule(module);\n         assertEquals(quote(\"b\"), m.writeValueAsString(TestEnum.B));\n+    }\n+\n+    // [databind#572]\n+    public void testOverrideEnumAsString() throws Exception {\n+        assertEquals(\"{\\\"value\\\":\\\"B\\\"}\", mapper.writeValueAsString(new PoOverrideAsString()));\n+    }\n+\n+    public void testOverrideEnumAsNumber() throws Exception {\n+        assertEquals(\"{\\\"value\\\":1}\", mapper.writeValueAsString(new PoOverrideAsNumber()));\n     }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestExceptionHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestExceptionHandling.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n-import com.fasterxml.jackson.test.BrokenStringWriter;\n \n /**\n  * Unit test for verifying that exceptions are properly handled (caught,\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n \n         // also: let's ensure that ObjectWriter won't interfere with it\n         bean = new CloseableBean();\n-        m.writerWithType(CloseableBean.class).writeValueAsString(bean);\n+        m.writerFor(CloseableBean.class).writeValueAsString(bean);\n         assertTrue(bean.wasClosed);\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestGenericTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestGenericTypes.java\n         public Person1(String name) { this.name = name; }\n \n         public String getName() {\n-                return name;\n+            return name;\n         }\n \n         public Key<Account> getAccount() {\n-                return account;\n+            return account;\n         }\n \n         public Long getId() {\n-                return id;\n+            return id;\n         }\n \n         public void setAccount(Key<Account> account) {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n import java.util.*;\n import java.util.regex.Pattern;\n \n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n \n /**\n     public void testBigDecimalAsPlainString()\n         throws Exception\n     {\n-        MAPPER.enable(SerializationFeature.WRITE_BIGDECIMAL_AS_PLAIN);\n+        final ObjectMapper mapper = new ObjectMapper();\n+\n+        mapper.enable(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN);\n         Map<String, Object> map = new HashMap<String, Object>();\n         String PI_STR = \"3.00000000\";\n         map.put(\"pi\", new BigDecimal(PI_STR));\n-        String str = MAPPER.writeValueAsString(map);\n+        String str = mapper.writeValueAsString(map);\n         assertEquals(\"{\\\"pi\\\":3.00000000}\", str);\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonRawValue.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonRawValue.java\n     @JsonPropertyOrder(alphabetic=true)\n     final static class ClassGetter<T>\n     {\n-    \tprivate final T _value;\n+        protected final T _value;\n     \t\n-        private ClassGetter(T value) { _value = value;}\n+        protected ClassGetter(T value) { _value = value;}\n  \n         public T getNonRaw() { return _value; }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java\n     }\n \n     static class Bar294{\n-        @JsonProperty private String id;\n-        @JsonProperty private String name;\n+        @JsonProperty protected String id;\n+        @JsonProperty protected String name;\n \n         public Bar294() { }\n         public Bar294(String id) {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerializeAs.java\n public class TestJsonSerializeAs extends BaseMapTest\n {\n     // [JACKSON-799] stuff:\n-    \n     public interface Fooable {\n         public int getFoo();\n     }\n             return new FooImpl();\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Test methods\n      */\n \n     private final ObjectWriter WRITER = objectWriter();\n-    \n+\n     // [JACKSON-799]\n     public void testSerializeAsInClass() throws IOException\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestKeySerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestKeySerializers.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n \n public class TestKeySerializers extends BaseMapTest\n {\n         public Map<String,Integer> map = new HashMap<String,Integer>();\n         {\n             map.put(\"Not Karl\", 1);\n+        }\n+    }\n+\n+    enum ABC {\n+        A, B, C\n+    }\n+\n+    static class ABCSerializer extends JsonSerializer<ABC> {\n+        @Override\n+        public void serialize(ABC value, JsonGenerator jgen,\n+                SerializerProvider provider) throws IOException {\n+            jgen.writeFieldName(\"xxx\"+value);\n+        }\n+    }\n+\n+    static class ABCMapWrapper {\n+        public Map<ABC,String> stuff = new HashMap<ABC,String>();\n+        public ABCMapWrapper() {\n+            stuff.put(ABC.B, \"bar\");\n         }\n     }\n \n         final String value2 = mapper.writeValueAsString(new KarlBean());\n         assertEquals(\"{\\\"map\\\":{\\\"Karl\\\":1}}\", value2);\n     }\n+\n+    // Test custom key serializer for enum\n+    public void testCustomForEnum() throws IOException\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\");\n+        mod.addKeySerializer(ABC.class, new ABCSerializer());\n+        mapper.registerModule(mod);\n+\n+        String json = mapper.writeValueAsString(new ABCMapWrapper());\n+        assertEquals(\"{\\\"stuff\\\":{\\\"xxxB\\\":\\\"bar\\\"}}\", json);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n import java.util.*;\n import java.util.concurrent.ConcurrentHashMap;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n             throw new UnsupportedOperationException();\n         }\n     }\n-    \n+\n+    // [databind#527]\n+    static class NoNullValuesMapContainer {\n+        @JsonInclude(content=JsonInclude.Include.NON_NULL)\n+        public Map<String,String> stuff = new LinkedHashMap<String,String>();\n+        \n+        public NoNullValuesMapContainer add(String key, String value) {\n+            stuff.put(key, value);\n+            return this;\n+        }\n+    }\n+\n+    // [databind#527]\n+    @JsonInclude(content=JsonInclude.Include.NON_NULL)\n+    static class NoNullsStringMap extends LinkedHashMap<String,String> {\n+        public NoNullsStringMap add(String key, String value) {\n+            put(key, value);\n+            return this;\n+        }\n+    }\n+\n+    @JsonInclude(content=JsonInclude.Include.NON_EMPTY)\n+    static class NoEmptyStringsMap extends LinkedHashMap<String,String> {\n+        public NoEmptyStringsMap add(String key, String value) {\n+            put(key, value);\n+            return this;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n     /**********************************************************\n      */\n \n-    final ObjectMapper MAPPER = objectMapper();\n+    final private ObjectMapper MAPPER = objectMapper();\n \n     public void testUsingObjectWriter() throws IOException\n     {\n-        ObjectWriter w = MAPPER.writerWithType(Object.class);\n+        ObjectWriter w = MAPPER.writerFor(Object.class);\n         Map<String,Object> map = new LinkedHashMap<String,Object>();\n         map.put(\"a\", 1);\n         String json = w.writeValueAsString(map);\n         json = MAPPER.writeValueAsString(array);\n         assertEquals(aposToQuotes(\"[{'answer':42}]\"), json);\n     }        \n+\n+    // [databind#527]\n+    public void testNonNullValueMap() throws IOException\n+    {\n+        String json = MAPPER.writeValueAsString(new NoNullsStringMap()\n+            .add(\"a\", \"foo\")\n+            .add(\"b\", null)\n+            .add(\"c\", \"bar\"));\n+        assertEquals(aposToQuotes(\"{'a':'foo','c':'bar'}\"), json);\n+    }\n+\n+    // [databind#527]\n+    public void testNonEmptyValueMap() throws IOException\n+    {\n+        String json = MAPPER.writeValueAsString(new NoEmptyStringsMap()\n+            .add(\"a\", \"foo\")\n+            .add(\"b\", \"bar\")\n+            .add(\"c\", \"\"));\n+        assertEquals(aposToQuotes(\"{'a':'foo','b':'bar'}\"), json);\n+    }\n+    \n+    // [databind#527]\n+    public void testNonNullValueMapViaProp() throws IOException\n+    {\n+        String json = MAPPER.writeValueAsString(new NoNullValuesMapContainer()\n+            .add(\"a\", \"foo\")\n+            .add(\"b\", null)\n+            .add(\"c\", \"bar\"));\n+        assertEquals(aposToQuotes(\"{'stuff':{'a':'foo','c':'bar'}}\"), json);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n         public MyNullProvider() { super(); }\n         public MyNullProvider(MyNullProvider base, SerializationConfig config, SerializerFactory jsf) {\n             super(base, config, jsf);\n+        }\n+\n+        // not really a proper impl, but has to do\n+        @Override\n+        public DefaultSerializerProvider copy() {\n+            return this;\n         }\n         \n         @Override\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestNumbers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNumbers.java\n {\n     private final ObjectMapper MAPPER = objectMapper();\n \n-    private static class IntAsString {\n+    static class IntAsString {\n         @JsonFormat(shape=JsonFormat.Shape.STRING)\n         public int value = 3;\n     }\n \n-    private static class LongAsString {\n+    static class LongAsString {\n         @JsonFormat(shape=JsonFormat.Shape.STRING)\n         public long value = 4;\n     }\n-    \n-    private static class DoubleAsString {\n+\n+    static class DoubleAsString {\n         @JsonFormat(shape=JsonFormat.Shape.STRING)\n         public double value = -0.5;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Test methods\n     /**********************************************************\n      */\n-    \n+\n     public void testDouble() throws Exception\n     {\n         double[] values = new double[] {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestObjectWriter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestObjectWriter.java\n \n import java.util.*;\n \n-\n-import com.fasterxml.jackson.core.PrettyPrinter;\n+import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n \n /**\n  * Unit tests for checking features added to {@link ObjectWriter}, such\n public class TestObjectWriter\n     extends BaseMapTest\n {\n+    final ObjectMapper MAPPER = new ObjectMapper();\n+\n     public void testPrettyPrinter() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        ObjectWriter writer = mapper.writer();\n+        ObjectWriter writer = MAPPER.writer();\n         HashMap<String, Integer> data = new HashMap<String,Integer>();\n         data.put(\"a\", 1);\n         \n \n     public void testPrefetch() throws Exception\n     {\n-        ObjectWriter writer = objectWriter();\n+        ObjectWriter writer = MAPPER.writer();\n         assertFalse(writer.hasPrefetchedSerializer());\n-        writer = objectWriter().withType(String.class);\n+        writer = writer.forType(String.class);\n         assertTrue(writer.hasPrefetchedSerializer());\n     }\n-} \n+\n+    public void testObjectWriterFeatures() throws Exception\n+    {\n+        ObjectWriter writer = MAPPER.writer()\n+                .without(JsonGenerator.Feature.QUOTE_FIELD_NAMES);                \n+        Map<String,Integer> map = new HashMap<String,Integer>();\n+        map.put(\"a\", 1);\n+        assertEquals(\"{a:1}\", writer.writeValueAsString(map));\n+        // but can also reconfigure\n+        assertEquals(\"{\\\"a\\\":1}\", writer.with(JsonGenerator.Feature.QUOTE_FIELD_NAMES)\n+                .writeValueAsString(map));\n+    }\n+\n+    public void testObjectWriterWithNode() throws Exception\n+    {\n+        ObjectNode stuff = MAPPER.createObjectNode();\n+        stuff.put(\"a\", 5);\n+        ObjectWriter writer = MAPPER.writerFor(JsonNode.class);\n+        String json = writer.writeValueAsString(stuff);\n+        assertEquals(\"{\\\"a\\\":5}\", json);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n         assertEquals(Boolean.TRUE, result.get(\"b2\"));\n \n         // and then using specified typed writer\n-        ObjectWriter w = mapper.writerWithType(BaseType.class);\n+        ObjectWriter w = mapper.writerFor(BaseType.class);\n         String json = w.writeValueAsString(bean);\n         result = (Map<String,Object>)mapper.readValue(json, Map.class);\n         assertEquals(2, result.size());\n         SubType bean = new SubType();\n \n         // let's constrain by interface:\n-        ObjectWriter w = mapper.writerWithType(BaseInterface.class);\n+        ObjectWriter w = mapper.writerFor(BaseInterface.class);\n         String json = w.writeValueAsString(bean);\n         @SuppressWarnings(\"unchecked\")\n         Map<String,Object> result = mapper.readValue(json, Map.class);\n         // must force static typing, otherwise won't matter a lot\n         mapper.configure(MapperFeature.USE_STATIC_TYPING, true);\n         SubType[] ob = new SubType[] { new SubType() };\n-        String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob);\n+        String json = mapper.writerFor(BaseInterface[].class).writeValueAsString(ob);\n         // should propagate interface type through due to root declaration; static typing\n         assertEquals(\"[{\\\"b\\\":3}]\", json);\n     }\n         SubType bean = new SubType();\n \n         // and then let's try using incompatible type\n-        ObjectWriter w = mapper.writerWithType(HashMap.class);\n+        ObjectWriter w = mapper.writerFor(HashMap.class);\n         try {\n             w.writeValueAsString(bean);\n             fail(\"Should have failed due to incompatible type\");\n         final String EXP = \"[{\\\"beanClass\\\":\\\"TestRootType$TestClass398\\\",\\\"property\\\":\\\"aa\\\"}]\";\n         \n         // First simplest way:\n-        String json = mapper.writerWithType(collectionType).writeValueAsString(typedList);\n+        String json = mapper.writerFor(collectionType).writeValueAsString(typedList);\n         assertEquals(EXP, json);\n \n         StringWriter out = new StringWriter();\n         JsonFactory f = new JsonFactory();\n-        mapper.writerWithType(collectionType).writeValue(f.createGenerator(out), typedList);\n+        mapper.writerFor(collectionType).writeValue(f.createGenerator(out), typedList);\n \n         assertEquals(EXP, out.toString());\n     }\n     public void testIssue456WrapperPart() throws Exception\n     {\n         ObjectMapper mapper = objectMapper();\n-        assertEquals(\"123\", mapper.writerWithType(Integer.TYPE).writeValueAsString(Integer.valueOf(123)));\n-        assertEquals(\"456\", mapper.writerWithType(Long.TYPE).writeValueAsString(Long.valueOf(456L)));\n+        assertEquals(\"123\", mapper.writerFor(Integer.TYPE).writeValueAsString(Integer.valueOf(123)));\n+        assertEquals(\"456\", mapper.writerFor(Long.TYPE).writeValueAsString(Long.valueOf(456L)));\n     }\n \n     // [JACKSON-630] also, allow annotation to define root name\n         cmd.uuid = \"1234\";\n         cmd.type = 1;\n \n-        ObjectWriter writer = WRAP_ROOT_MAPPER.writerWithType(TestCommandParent.class);\n+        ObjectWriter writer = WRAP_ROOT_MAPPER.writerFor(TestCommandParent.class);\n         String json =  writer.writeValueAsString(cmd);\n \n         assertEquals(json, \"{\\\"TestCommandParent\\\":{\\\"uuid\\\":\\\"1234\\\",\\\"type\\\":1}}\");\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n     public void testOrderWithMixins() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(BeanWithOrder.class, OrderMixIn.class);\n+        m.addMixIn(BeanWithOrder.class, OrderMixIn.class);\n         assertEquals(\"{\\\"b\\\":2,\\\"a\\\":1,\\\"c\\\":3,\\\"d\\\":4}\",\n                 serializeAsString(m, new BeanWithOrder(1, 2, 3, 4)));\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestTypedRootValueSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestTypedRootValueSerialization.java\n     public void testTypedSerialization() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        String singleJson = mapper.writerWithType(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n+        String singleJson = mapper.writerFor(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n         // start with specific value case:\n         assertEquals(\"{\\\"a\\\":3}\", singleJson);\n     }\n         ObjectMapper mapper = new ObjectMapper();\n // Work-around when real solution not yet implemented:        \n //        mapper.enable(MapperFeature.USE_STATIC_TYPING);\n-        assertEquals(\"[{\\\"a\\\":3}]\", mapper.writerWithType(Issue822Interface[].class).writeValueAsString(\n+        assertEquals(\"[{\\\"a\\\":3}]\", mapper.writerFor(Issue822Interface[].class).writeValueAsString(\n                 new Issue822Interface[] { new Issue822Impl() }));\n     }\n     \n \n         List<Issue822Interface> list = new ArrayList<Issue822Interface>();\n         list.add(new Issue822Impl());\n-        String listJson = mapper.writerWithType(new TypeReference<List<Issue822Interface>>(){})\n+        String listJson = mapper.writerFor(new TypeReference<List<Issue822Interface>>(){})\n                 .writeValueAsString(list);\n         assertEquals(\"[{\\\"a\\\":3}]\", listJson);\n     }\n         ObjectMapper mapper = new ObjectMapper();\n         Map<String,Issue822Interface> map = new HashMap<String,Issue822Interface>();\n         map.put(\"a\", new Issue822Impl());\n-        String listJson = mapper.writerWithType(new TypeReference<Map<String,Issue822Interface>>(){})\n+        String listJson = mapper.writerFor(new TypeReference<Map<String,Issue822Interface>>(){})\n                 .writeValueAsString(map);\n         assertEquals(\"{\\\"a\\\":{\\\"a\\\":3}}\", listJson);\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestVirtualProperties.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonAppend;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * Tests for verifying that one can append virtual properties after regular ones.\n+ * \n+ * @since 2.5\n+ */\n+public class TestVirtualProperties extends BaseMapTest\n+{\n+    @JsonAppend(attrs={ @JsonAppend.Attr(\"id\"),\n+        @JsonAppend.Attr(value=\"internal\", propName=\"extra\", required=true)\n+    })\n+    static class SimpleBean\n+    {\n+        public int value = 13;\n+    }\n+\n+    @JsonAppend(prepend=true, attrs={ @JsonAppend.Attr(\"id\"),\n+            @JsonAppend.Attr(value=\"internal\", propName=\"extra\")\n+        })\n+    static class SimpleBeanPrepend\n+    {\n+        public int value = 13;\n+    }\n+\n+    enum ABC {\n+        A, B, C;\n+    }\n+\n+    @JsonAppend(attrs=@JsonAppend.Attr(value=\"desc\", include=JsonInclude.Include.NON_EMPTY))\n+    static class OptionalsBean\n+    {\n+        public int value = 28;\n+    }\n+\n+    static class CustomVProperty\n+        extends VirtualBeanPropertyWriter\n+    {\n+        private CustomVProperty() { super(); }\n+\n+        private CustomVProperty(BeanPropertyDefinition propDef,\n+                Annotations ctxtAnn, JavaType type) {\n+            super(propDef, ctxtAnn, type);\n+        }\n+\n+        @Override\n+        protected Object value(Object bean, JsonGenerator jgen, SerializerProvider prov) {\n+            if (_name.toString().equals(\"id\")) {\n+                return \"abc123\";\n+            }\n+            if (_name.toString().equals(\"extra\")) {\n+                return new int[] { 42 };\n+            }\n+            return \"???\";\n+        }\n+\n+        @Override\n+        public VirtualBeanPropertyWriter withConfig(MapperConfig<?> config,\n+                AnnotatedClass declaringClass, BeanPropertyDefinition propDef,\n+                JavaType type)\n+        {\n+            return new CustomVProperty(propDef, declaringClass.getAnnotations(), type);\n+        }\n+    }\n+\n+    @JsonAppend(prepend=true, props={ @JsonAppend.Prop(value=CustomVProperty.class, name=\"id\"),\n+            @JsonAppend.Prop(value=CustomVProperty.class, name=\"extra\")\n+        })\n+    static class CustomVBean\n+    {\n+        public int value = 72;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final ObjectWriter WRITER = objectWriter();\n+\n+    public void testAttributeProperties() throws Exception\n+    {\n+        Map<String,Object> stuff = new LinkedHashMap<String,Object>();\n+        stuff.put(\"x\", 3);\n+        stuff.put(\"y\", ABC.B);\n+\n+        String json = WRITER.withAttribute(\"id\", \"abc123\")\n+                .withAttribute(\"internal\", stuff)\n+                .writeValueAsString(new SimpleBean());\n+        assertEquals(aposToQuotes(\"{'value':13,'id':'abc123','extra':{'x':3,'y':'B'}}\"), json);\n+\n+        json = WRITER.withAttribute(\"id\", \"abc123\")\n+                .withAttribute(\"internal\", stuff)\n+                .writeValueAsString(new SimpleBeanPrepend());\n+        assertEquals(aposToQuotes(\"{'id':'abc123','extra':{'x':3,'y':'B'},'value':13}\"), json);\n+    }\n+\n+    public void testAttributePropInclusion() throws Exception\n+    {\n+        // first, with desc\n+        String json = WRITER.withAttribute(\"desc\", \"nice\")\n+                .writeValueAsString(new OptionalsBean());\n+        assertEquals(aposToQuotes(\"{'value':28,'desc':'nice'}\"), json);\n+\n+        // then with null (not defined)\n+        json = WRITER.writeValueAsString(new OptionalsBean());\n+        assertEquals(aposToQuotes(\"{'value':28}\"), json);\n+\n+        // and finally \"empty\"\n+        json = WRITER.withAttribute(\"desc\", \"\")\n+                .writeValueAsString(new OptionalsBean());\n+        assertEquals(aposToQuotes(\"{'value':28}\"), json);\n+    }\n+\n+    public void testCustomProperties() throws Exception\n+    {\n+        String json = WRITER.withAttribute(\"desc\", \"nice\")\n+                .writeValueAsString(new CustomVBean());\n+        assertEquals(aposToQuotes(\"{'id':'abc123','extra':[42],'value':72}\"), json);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/JSOGDeserialize622Test.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit test(s) for [databind#622], supporting non-scalar-Object-ids,\n+ * to support things like JSOG.\n+ */\n+public class JSOGDeserialize622Test extends BaseMapTest\n+{\n+    /** the key of the property that holds the ref */\n+    public static final String REF_KEY = \"@ref\";\n+\n+    /**\n+     * JSON input\n+     */\n+    private static final String EXP_EXAMPLE_JSOG =  aposToQuotes(\n+            \"{'@id':'1','foo':66,'next':{'\"+REF_KEY+\"':'1'}}\");\n+\n+    /**\n+     * Customer IdGenerator\n+     */\n+    static class JSOGGenerator extends ObjectIdGenerator<JSOGRef>  {\n+\n+    private static final long serialVersionUID = 1L;\n+    protected transient int _nextValue;\n+    protected final Class<?> _scope;\n+\n+    protected JSOGGenerator() { this(null, -1); }\n+\n+    protected JSOGGenerator(Class<?> scope, int nextValue) {\n+        _scope = scope;\n+        _nextValue = nextValue;\n+    }\n+\n+    @Override\n+    public Class<?> getScope() {\n+        return _scope;\n+    }\n+\n+    @Override\n+    public boolean canUseFor(ObjectIdGenerator<?> gen) {\n+        return (gen.getClass() == getClass()) && (gen.getScope() == _scope);\n+    }\n+\n+    @Override\n+    public ObjectIdGenerator<JSOGRef> forScope(Class<?> scope) {\n+          return (_scope == scope) ? this : new JSOGGenerator(scope, _nextValue);\n+    }\n+\n+    @Override\n+    public ObjectIdGenerator<JSOGRef> newForSerialization(Object context) {\n+          return new JSOGGenerator(_scope, 1);\n+    }\n+\n+    @Override\n+    public com.fasterxml.jackson.annotation.ObjectIdGenerator.IdKey key(Object key) {\n+          return new IdKey(getClass(), _scope, key);\n+    }\n+\n+    // important: otherwise won't get proper handling\n+    @Override\n+    public boolean maySerializeAsObject() { return true; }\n+\n+    // ditto: needed for handling Object-valued Object references\n+    @Override\n+    public boolean isValidReferencePropertyName(String name, Object parser) {\n+        return REF_KEY.equals(name);\n+    }\n+\n+    @Override\n+    public JSOGRef generateId(Object forPojo) {\n+          int id = _nextValue;\n+          ++_nextValue;\n+          return new JSOGRef(id);\n+    }\n+    }\n+\n+    /**\n+     * The reference deserializer\n+     */\n+    static class JSOGRefDeserializer extends JsonDeserializer<JSOGRef>\n+    {\n+      @Override\n+      public JSOGRef deserialize(JsonParser jp, DeserializationContext ctx) throws IOException {\n+          JsonNode node = jp.readValueAsTree();\n+          return node.isTextual()\n+                  ? new JSOGRef(node.asInt()) : new JSOGRef(node.get(REF_KEY).asInt());\n+      }\n+    }\n+\n+    /**\n+     * The reference object\n+     */\n+    @JsonDeserialize(using=JSOGRefDeserializer.class)\n+    static class JSOGRef\n+    {\n+        @JsonProperty(REF_KEY)\n+        public int ref;\n+\n+        public JSOGRef() { }\n+\n+        public JSOGRef(int val) {\n+            ref = val;\n+        }\n+\n+        @Override\n+        public String toString() { return \"[JSOGRef#\"+ref+\"]\"; }\n+\n+        @Override\n+        public int hashCode() {\n+            return ref;\n+        }\n+        \n+        @Override\n+        public boolean equals(Object other) {\n+            return (other instanceof JSOGRef)\n+                    && ((JSOGRef) other).ref == this.ref;\n+        }\n+    }\n+\n+    /**\n+     * Example class using JSOGGenerator\n+     */\n+    @JsonIdentityInfo(generator=JSOGGenerator.class, property=\"@id\")\n+    public static class IdentifiableExampleJSOG {\n+        public int foo;\n+        public IdentifiableExampleJSOG next;\n+\n+        protected IdentifiableExampleJSOG() { }\n+        public IdentifiableExampleJSOG(int v) {\n+            foo = v;\n+        }\n+    }\n+\n+    public static class JSOGWrapper {\n+        public int value;\n+\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)\n+        public Object jsog;\n+\n+        JSOGWrapper() { }\n+        public JSOGWrapper(int v) { value = v; }\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Test methods\n+    /**********************************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n+    // Basic for [#622]\n+    public void testStructJSOGRef() throws Exception\n+    {\n+        IdentifiableExampleJSOG result = MAPPER.readValue(EXP_EXAMPLE_JSOG,\n+                IdentifiableExampleJSOG.class);\n+        assertEquals(66, result.foo);\n+        assertSame(result, result.next);\n+    }\n+\n+    // polymorphic alternative for [#622]\n+    public void testPolymorphicRoundTrip() throws Exception\n+    {\n+        JSOGWrapper w = new JSOGWrapper(15);\n+        // create a nice little loop\n+        IdentifiableExampleJSOG ex = new IdentifiableExampleJSOG(123);\n+        ex.next = ex;\n+        w.jsog = ex;\n+\n+        String json = MAPPER.writeValueAsString(w);\n+\n+        JSOGWrapper out = MAPPER.readValue(json, JSOGWrapper.class);\n+        assertNotNull(out);\n+        assertEquals(15, out.value);\n+        assertTrue(out.jsog instanceof IdentifiableExampleJSOG);\n+        IdentifiableExampleJSOG jsog = (IdentifiableExampleJSOG) out.jsog;\n+        assertEquals(123, jsog.foo);\n+        assertSame(jsog, jsog.next);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/PojoAsArray646Test.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class PojoAsArray646Test extends BaseMapTest\n+{\n+    @JsonFormat(shape = JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder(alphabetic = true)\n+    static class Outer {\n+\n+        private Map<String, TheItem> attributes;\n+\n+        public Outer() {\n+            attributes = new HashMap<String, TheItem>();\n+        }\n+\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.WRAPPER_ARRAY)\n+        public Map<String, TheItem> getAttributes() {\n+            return attributes;\n+        }\n+    }\n+\n+    @JsonFormat(shape = JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder(alphabetic = true)\n+    static class TheItem {\n+\n+        @JsonFormat(shape = JsonFormat.Shape.ARRAY)\n+        @JsonPropertyOrder(alphabetic = true)\n+        public static class NestedItem {\n+            public String nestedStrValue;\n+\n+            @JsonCreator\n+            public NestedItem(@JsonProperty(\"nestedStrValue\") String nestedStrValue) {\n+                this.nestedStrValue = nestedStrValue;\n+            }\n+        }\n+\n+        private String strValue;\n+        private boolean boolValue;\n+        private List<NestedItem> nestedItems;\n+\n+        @JsonCreator\n+        public TheItem(@JsonProperty(\"strValue\") String strValue, @JsonProperty(\"boolValue\") boolean boolValue, @JsonProperty(\"nestedItems\") List<NestedItem> nestedItems) {\n+            this.strValue = strValue;\n+            this.boolValue = boolValue;\n+            this.nestedItems = nestedItems;\n+        }\n+\n+        public String getStrValue() {\n+            return strValue;\n+        }\n+\n+        public void setStrValue(String strValue) {\n+            this.strValue = strValue;\n+        }\n+\n+        public boolean isBoolValue() {\n+            return boolValue;\n+        }\n+\n+        public void setBoolValue(boolean boolValue) {\n+            this.boolValue = boolValue;\n+        }\n+\n+        public List<NestedItem> getNestedItems() {\n+            return nestedItems;\n+        }\n+\n+        public void setNestedItems(List<NestedItem> nestedItems) {\n+            this.nestedItems = nestedItems;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testWithCustomTypeId() throws Exception {\n+\n+        List<TheItem.NestedItem> nestedList = new ArrayList<TheItem.NestedItem>();\n+        nestedList.add(new TheItem.NestedItem(\"foo1\"));\n+        nestedList.add(new TheItem.NestedItem(\"foo2\"));\n+        TheItem item = new TheItem(\"first\", false, nestedList);\n+        Outer outer = new Outer();\n+        outer.getAttributes().put(\"entry1\", item);\n+\n+        String json = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(outer);\n+\n+        Outer result = MAPPER.readValue(json, Outer.class);\n+        assertNotNull(result);\n+        assertNotNull(result.attributes);\n+        assertEquals(1, result.attributes.size());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestForwardReference.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+\n+/**\n+ * Test for testing forward reference handling\n+ */\n+public class TestForwardReference extends BaseMapTest {\n+\n+\tprivate final ObjectMapper MAPPER = new ObjectMapper()\n+\t\t\t.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)\n+\t\t\t.enable(SerializationFeature.INDENT_OUTPUT)\n+\t\t\t.setSerializationInclusion(JsonInclude.Include.NON_NULL);\n+\n+\t/** Tests that we can read a hierarchical structure with forward references*/\n+\tpublic void testForwardRef() throws IOException {\n+\t\tMAPPER.readValue(\"{\" +\n+\t\t\t\t\"  \\\"@type\\\" : \\\"TestForwardReference$ForwardReferenceContainerClass\\\",\" +\n+\t\t\t\t\"  \\\"frc\\\" : \\\"willBeForwardReferenced\\\",\" +\n+\t\t\t\t\"  \\\"yac\\\" : {\" +\n+\t\t\t\t\"    \\\"@type\\\" : \\\"TestForwardReference$YetAnotherClass\\\",\" +\n+\t\t\t\t\"    \\\"frc\\\" : {\" +\n+\t\t\t\t\"      \\\"@type\\\" : \\\"One\\\",\" +\n+\t\t\t\t\"      \\\"id\\\" : \\\"willBeForwardReferenced\\\"\" +\n+\t\t\t\t\"    },\" +\n+\t\t\t\t\"    \\\"id\\\" : \\\"anId\\\"\" +\n+\t\t\t\t\"  },\" +\n+\t\t\t\t\"  \\\"id\\\" : \\\"ForwardReferenceContainerClass1\\\"\" +\n+\t\t\t\t\"}\", ForwardReferenceContainerClass.class);\n+\n+\n+\t}\n+\n+\t@JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include= JsonTypeInfo.As.PROPERTY)\n+\tpublic static class ForwardReferenceContainerClass\n+\t{\n+\t\tpublic ForwardReferenceClass frc;\n+\t\tpublic YetAnotherClass yac;\n+\t\tpublic String id;\n+\t}\n+\n+\t@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)\n+\t@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")\n+\t@JsonSubTypes({\n+\t\t\t@JsonSubTypes.Type(value = ForwardReferenceClassOne.class, name = \"One\"),\n+\t\t\t@JsonSubTypes.Type(value = ForwardReferenceClassTwo.class, name = \"Two\")})\n+\tstatic abstract class ForwardReferenceClass\n+\t{\n+\t\tpublic String id;\n+\t\tpublic void setId(String id) {\n+\t\t\tthis.id = id;\n+\t\t}\n+\t}\n+\n+\t@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY)\n+\tstatic class YetAnotherClass\n+\t{\n+\t\tpublic YetAnotherClass() {}\n+\t\tpublic ForwardReferenceClass frc;\n+\t\tpublic String id;\n+\t}\n+\n+\tpublic static class ForwardReferenceClassOne extends ForwardReferenceClass { }\n+\n+\tpublic static class ForwardReferenceClassTwo extends ForwardReferenceClass { }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n     private static final String POOL_KEY = \"POOL\";\n \n     // // Classes for external id use\n-    \n+\n     @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"id\")\n     static class Identifiable\n     {\n         public int value;\n \n         public Identifiable next;\n-        \n+\n         public Identifiable() { this(0); }\n         public Identifiable(int v) {\n             value = v;\n         public UUIDNode() { this(0); }\n         public UUIDNode(int v) { value = v; }\n     }\n-    \n+\n     // // Classes for external id from property annotations:\n-    \n+\n     static class IdWrapper\n     {\n         @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"@id\")\n     static class ValueNodeExt\n     {\n         public int value;\n-        private int customId;\n+        protected int customId;\n         public IdWrapperExt next;\n         \n         public ValueNodeExt() { this(0); }\n \n     @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)\n     static class AnySetterObjectId {\n-        private Map<String, AnySetterObjectId> values = new HashMap<String, AnySetterObjectId>();\n+        protected Map<String, AnySetterObjectId> values = new HashMap<String, AnySetterObjectId>();\n \n         @JsonAnySetter\n         public void anySet(String field, AnySetterObjectId value) {\n             return new PoolResolver(pool);\n         }\n     }\n+    \n+    /*\n+    /*****************************************************\n+    /* Unit tests, external id deserialization\n+    /*****************************************************\n+     */\n \n     private final ObjectMapper mapper = new ObjectMapper();\n     \n-    /*\n-    /*****************************************************\n-    /* Unit tests, external id deserialization\n-    /*****************************************************\n-     */\n-\n     private final static String EXP_SIMPLE_INT_CLASS = \"{\\\"id\\\":1,\\\"value\\\":13,\\\"next\\\":1}\";\n \n     public void testSimpleDeserializationClass() throws Exception\n         assertSame(result, result.next);\n     }\n \n+    // Should be ok NOT to have Object id, as well\n+    public void testMissingObjectId() throws Exception\n+    {\n+        Identifiable result = mapper.readValue(aposToQuotes(\"{'value':28, 'next':{'value':29}}\"),\n+                Identifiable.class);\n+        assertNotNull(result);\n+        assertEquals(28, result.value);\n+        assertNotNull(result.next);\n+        assertEquals(29, result.next.value);\n+    }\n+    \n     public void testSimpleUUIDForClassRoundTrip() throws Exception\n     {\n         UUIDNode root = new UUIDNode(1);\n         }\n     }\n \n-    public void testKeepCollectionOrdering()\n-        throws Exception\n+    public void testKeepCollectionOrdering() throws Exception\n     {\n         String json = \"{\\\"employees\\\":[2,1,\"\n                 + \"{\\\"id\\\":1,\\\"name\\\":\\\"First\\\",\\\"manager\\\":null,\\\"reports\\\":[2]},\"\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdWithPolymorphic.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdWithPolymorphic.java\n     static abstract class Base\n     {\n         public int value;\n+        public Base next;\n \n-        public Base next;\n-        \n         public Base() { this(0); }\n         public Base(int v) {\n             value = v;\n         public int id;\n         public Base811 owner;\n             \n-        private Base811() {}\n+        protected Base811() {}\n         public Base811(Process owner) {\n             this.owner = owner;\n             if (owner == null) {\n                 super(owner);\n                 this.parent = parent;\n         }\n-        private Activity() {\n-                super();\n+        protected Activity() {\n+            super();\n         }\n     }\n     \n         public Scope(Process owner, Activity parent) {\n             super(owner, parent);\n         }\n-        private Scope() {\n+        protected Scope() {\n             super();\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArray.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArray.java\n package com.fasterxml.jackson.databind.struct;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n-\n-import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n \n         public String bar = null;\n         public String foo = \"bar\";\n     }\n-    \n+\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+    @JsonPropertyOrder(alphabetic=true)\n+    static class AsArrayWithMap\n+    {\n+        public Map<Integer,Integer> attrs;\n+\n+        public AsArrayWithMap() { }\n+        public AsArrayWithMap(int x, int y) {\n+            attrs = new HashMap<Integer,Integer>();\n+            attrs.put(x, y);\n+        }\n+    }\n+\n     /*\n     /*****************************************************\n     /* Basic tests\n         String json = mapper.writeValueAsString(new SingleBean());\n         assertEquals(\"\\\"foo\\\"\", json);\n     }\n-    \n+\n+    public void testBeanAsArrayUnwrapped() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n+        SingleBean result = mapper.readValue(\"[\\\"foobar\\\"]\", SingleBean.class);\n+        assertNotNull(result);\n+        assertEquals(\"foobar\", result.name);\n+    }\n+\n     /*\n     /*****************************************************\n     /* Round-trip tests\n         mapper2.setAnnotationIntrospector(new ForceArraysIntrospector());\n         assertEquals(\"[[1,2]]\", mapper2.writeValueAsString(new A()));\n     }\n+\n+    public void testWithMaps() throws Exception\n+    {\n+        AsArrayWithMap input = new AsArrayWithMap(1, 2);\n+        String json = MAPPER.writeValueAsString(input);\n+        AsArrayWithMap output = MAPPER.readValue(json, AsArrayWithMap.class);\n+        assertNotNull(output);\n+        assertNotNull(output.attrs);\n+        assertEquals(1, output.attrs.size());\n+        assertEquals(Integer.valueOf(2), output.attrs.get(1));\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayAdvanced.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayAdvanced.java\n package com.fasterxml.jackson.databind.struct;\n \n import com.fasterxml.jackson.annotation.*;\n-\n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n         public int b;\n         public int c;\n     }\n-    \n+\n     /*\n     /*****************************************************\n     /* Basic tests\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestParentChildReferences.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestParentChildReferences\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Test classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * First, a simple 'tree': just parent/child linkage\n+     */\n+    static class SimpleTreeNode\n+    {\n+        public String name;\n+        \n+        // Reference back to parent; reference, ignored during ser,\n+        // re-constructed during deser\n+        @JsonBackReference\n+        public SimpleTreeNode parent;\n+\n+        // Reference that is serialized normally during ser, back\n+        // reference within pointed-to instance assigned to point to\n+        // referring bean (\"this\")\n+        @JsonManagedReference\n+        public SimpleTreeNode child;\n+\n+        public SimpleTreeNode() { this(null); }\n+        public SimpleTreeNode(String n) { name = n; }\n+    }\n+\n+    static class SimpleTreeNode2\n+    {\n+        public String name;\n+        protected SimpleTreeNode2 parent;\n+        protected SimpleTreeNode2 child;\n+\n+        public SimpleTreeNode2() { this(null); }\n+        public SimpleTreeNode2(String n) { name = n; }\n+\n+        @JsonBackReference\n+        public SimpleTreeNode2 getParent() { return parent; }\n+        public void setParent(SimpleTreeNode2 p) { parent = p; }\n+\n+        @JsonManagedReference\n+        public SimpleTreeNode2 getChild() { return child; }\n+        public void setChild(SimpleTreeNode2 c) { child = c; }\n+    }\n+    \n+    /**\n+     * Then nodes with two separate linkages; parent/child\n+     * and prev/next-sibling\n+     */\n+    static class FullTreeNode\n+    {\n+        public String name;\n+\n+        // parent-child links\n+        @JsonBackReference(\"parent\")\n+        public FullTreeNode parent;\n+        @JsonManagedReference(\"parent\")\n+        public FullTreeNode firstChild;\n+\n+        // sibling-links\n+        @JsonManagedReference(\"sibling\")\n+        public FullTreeNode next;\n+        @JsonBackReference(\"sibling\")\n+        protected FullTreeNode prev;\n+        \n+        public FullTreeNode() { this(null); }\n+        public FullTreeNode(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    /**\n+     * Class for testing managed references via arrays\n+     */\n+    static class NodeArray\n+    {\n+        @JsonManagedReference(\"arr\")\n+        public ArrayNode[] nodes;\n+    }\n+\n+    static class ArrayNode\n+    {\n+        public String name;\n+        \n+        @JsonBackReference(\"arr\")\n+        public NodeArray parent;\n+\n+        public ArrayNode() { this(null); }\n+        public ArrayNode(String n) { name = n; }\n+    }\n+    \n+    /**\n+     * Class for testing managed references via Collections\n+     */\n+    static class NodeList\n+    {\n+        @JsonManagedReference\n+        public List<NodeForList> nodes;\n+    }\n+\n+    static class NodeForList\n+    {\n+        public String name;\n+        \n+        @JsonBackReference\n+        public NodeList parent;\n+\n+        public NodeForList() { this(null); }\n+        public NodeForList(String n) { name = n; }\n+    }\n+    \n+    static class NodeMap\n+    {\n+        @JsonManagedReference\n+        public Map<String,NodeForMap> nodes;\n+    }\n+\n+    static class NodeForMap\n+    {\n+        public String name;\n+        \n+        @JsonBackReference\n+        public NodeMap parent;\n+\n+        public NodeForMap() { this(null); }\n+        public NodeForMap(String n) { name = n; }\n+    }\n+\n+    public static class Parent {\n+        @JsonManagedReference\n+        protected final List<Child> children = new ArrayList<Child>();\n+\n+        public List<Child> getChildren() { return children; }\n+\n+        public void addChild(Child child) { children.add(child); child.setParent(this); }\n+    }\n+\n+    public static class Child {\n+        protected Parent parent;\n+        protected final String value; // So that the bean is not empty of properties\n+\n+        public Child(@JsonProperty(\"value\") String value) { this.value = value; }\n+\n+        public String getValue() { return value; }\n+\n+        @JsonBackReference\n+        public Parent getParent() { return parent; }\n+\n+        public void setParent(Parent parent) { this.parent = parent; }\n+    }\n+\n+    @JsonTypeInfo(use=Id.NAME)\n+    @JsonSubTypes({@JsonSubTypes.Type(ConcreteNode.class)})\n+    static abstract class AbstractNode\n+    {\n+        public String id;\n+        \n+        @JsonManagedReference public AbstractNode next;\n+        @JsonBackReference public AbstractNode prev;\n+    }\n+\n+    @JsonTypeName(\"concrete\")\n+    static class ConcreteNode extends AbstractNode {\n+        public ConcreteNode() { }\n+        public ConcreteNode(String id) { this.id = id; }\n+    }\n+    \n+    // [JACKSON-708]\n+    static class Model708 { }\n+    \n+    static class Advertisement708 extends Model708 {\n+        public String title;\n+        @JsonManagedReference public List<Photo708> photos;\n+    }\n+\n+    static class Photo708 extends Model708 {\n+        public int id;\n+        @JsonBackReference public Advertisement708 advertisement;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = objectMapper();\n+    \n+    public void testSimpleRefs() throws Exception\n+    {\n+        SimpleTreeNode root = new SimpleTreeNode(\"root\");\n+        SimpleTreeNode child = new SimpleTreeNode(\"kid\");\n+        root.child = child;\n+        child.parent = root;\n+        \n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        SimpleTreeNode resultNode = MAPPER.readValue(json, SimpleTreeNode.class);\n+        assertEquals(\"root\", resultNode.name);\n+        SimpleTreeNode resultChild = resultNode.child;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+    }\n+\n+    // [JACKSON-693]\n+    public void testSimpleRefsWithGetter() throws Exception\n+    {\n+        SimpleTreeNode2 root = new SimpleTreeNode2(\"root\");\n+        SimpleTreeNode2 child = new SimpleTreeNode2(\"kid\");\n+        root.child = child;\n+        child.parent = root;\n+        \n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        SimpleTreeNode2 resultNode = MAPPER.readValue(json, SimpleTreeNode2.class);\n+        assertEquals(\"root\", resultNode.name);\n+        SimpleTreeNode2 resultChild = resultNode.child;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+    }\n+    \n+    public void testFullRefs() throws Exception\n+    {\n+        FullTreeNode root = new FullTreeNode(\"root\");\n+        FullTreeNode child1 = new FullTreeNode(\"kid1\");\n+        FullTreeNode child2 = new FullTreeNode(\"kid2\");\n+        root.firstChild = child1;\n+        child1.parent = root;\n+        child1.next = child2;\n+        child2.prev = child1;\n+        \n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        FullTreeNode resultNode = MAPPER.readValue(json, FullTreeNode.class);\n+        assertEquals(\"root\", resultNode.name);\n+        FullTreeNode resultChild = resultNode.firstChild;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid1\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+\n+        // and then sibling linkage\n+        assertNull(resultChild.prev);\n+        FullTreeNode resultChild2 = resultChild.next;\n+        assertNotNull(resultChild2);\n+        assertEquals(\"kid2\", resultChild2.name);\n+        assertSame(resultChild, resultChild2.prev);\n+        assertNull(resultChild2.next);\n+    }\n+\n+    public void testArrayOfRefs() throws Exception\n+    {\n+        NodeArray root = new NodeArray();\n+        ArrayNode node1 = new ArrayNode(\"a\");\n+        ArrayNode node2 = new ArrayNode(\"b\");\n+        root.nodes = new ArrayNode[] { node1, node2 };\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeArray result = MAPPER.readValue(json, NodeArray.class);\n+        ArrayNode[] kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.length);\n+        assertEquals(\"a\", kids[0].name);\n+        assertEquals(\"b\", kids[1].name);\n+        assertSame(result, kids[0].parent);\n+        assertSame(result, kids[1].parent);\n+    }\n+\n+    public void testListOfRefs() throws Exception\n+    {\n+        NodeList root = new NodeList();\n+        NodeForList node1 = new NodeForList(\"a\");\n+        NodeForList node2 = new NodeForList(\"b\");\n+        root.nodes = Arrays.asList(node1, node2);\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeList result = MAPPER.readValue(json, NodeList.class);\n+        List<NodeForList> kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.size());\n+        assertEquals(\"a\", kids.get(0).name);\n+        assertEquals(\"b\", kids.get(1).name);\n+        assertSame(result, kids.get(0).parent);\n+        assertSame(result, kids.get(1).parent);\n+    }\n+\n+    public void testMapOfRefs() throws Exception\n+    {\n+        NodeMap root = new NodeMap();\n+        NodeForMap node1 = new NodeForMap(\"a\");\n+        NodeForMap node2 = new NodeForMap(\"b\");\n+        Map<String,NodeForMap> nodes = new HashMap<String, NodeForMap>();\n+        nodes.put(\"a1\", node1);\n+        nodes.put(\"b2\", node2);\n+        root.nodes = nodes;\n+        String json = MAPPER.writeValueAsString(root);\n+        \n+        NodeMap result = MAPPER.readValue(json, NodeMap.class);\n+        Map<String,NodeForMap> kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.size());\n+        assertNotNull(kids.get(\"a1\"));\n+        assertNotNull(kids.get(\"b2\"));\n+        assertEquals(\"a\", kids.get(\"a1\").name);\n+        assertEquals(\"b\", kids.get(\"b2\").name);\n+        assertSame(result, kids.get(\"a1\").parent);\n+        assertSame(result, kids.get(\"b2\").parent);\n+    }\n+\n+    // for [JACKSON-368]\n+    public void testAbstract368() throws Exception\n+    {\n+        AbstractNode parent = new ConcreteNode(\"p\");\n+        AbstractNode child = new ConcreteNode(\"c\");\n+        parent.next = child;\n+        child.prev = parent;\n+\n+        // serialization ought to be ok\n+        String json = MAPPER.writeValueAsString(parent);\n+\n+        AbstractNode root = MAPPER.readValue(json, AbstractNode.class);\n+\n+        assertEquals(ConcreteNode.class, root.getClass());\n+        assertEquals(\"p\", root.id);\n+        assertNull(root.prev);\n+        AbstractNode leaf = root.next;\n+        assertNotNull(leaf);\n+        assertEquals(\"c\", leaf.id);\n+        assertSame(root, leaf.prev);\n+    }\n+    \n+    public void testIssue693() throws Exception\n+    {\n+        Parent parent = new Parent();\n+        parent.addChild(new Child(\"foo\"));\n+        parent.addChild(new Child(\"bar\"));\n+        byte[] bytes = MAPPER.writeValueAsBytes(parent);\n+        Parent value = MAPPER.readValue(bytes, Parent.class); \n+        for (Child child : value.children) {\n+            assertEquals(value, child.getParent());\n+        }\n+    }\n+\n+    public void testIssue708() throws Exception\n+    {\n+        Advertisement708 ad = MAPPER.readValue(\"{\\\"title\\\":\\\"Hroch\\\",\\\"photos\\\":[{\\\"id\\\":3}]}\", Advertisement708.class);      \n+        assertNotNull(ad);\n+    }   \n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrapped.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrapped.java\n         public String first, last;\n     }\n \n+    // [databind#615]\n+    static class Parent {\n+        @JsonUnwrapped\n+        public Child c1;\n+\n+        public Parent() { }\n+        public Parent(String str) { c1 = new Child(str); }\n+    }\n+\n+    static class Child {\n+        public String field;\n+\n+        public Child() { }\n+        public Child(String f) { field = f; }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Tests, serialization\n         assertEquals(2, loc.y);\n     }\n \n+    public void testIssue615() throws Exception\n+    {\n+        Parent input = new Parent(\"name\");\n+        String json = MAPPER.writeValueAsString(input);\n+        Parent output = MAPPER.readValue(json, Parent.class);\n+        assertEquals(\"name\", output.c1.field);\n+    }\n+\n     // 22-Apr-2013, tatu: Commented out as it can't be simply fixed; requires implementing\n     //    deep-update/merge. But leaving here to help with that effort, if/when it proceeds.\n-    \n+\n     /*\n-    \n     // [Issue#211]: Actually just variant of #160\n-    \n+\n     static class Issue211Bean {\n         public String test1;\n \n         public String test3;\n         public String test4;\n     }\n-    \n+\n     public void testIssue211() throws Exception\n     {\n          Issue211Bean bean = new Issue211Bean();\n          assertNotNull(result.unwrapped);\n          assertEquals(\"Field 3 merged\", result.unwrapped.test3);\n          assertEquals(\"Field 4\", result.unwrapped.test4);\n-    }  \n+    }\n     */\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/views/TestViewDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/views/TestViewDeserialization.java\n         \n         // but with different views, different contents\n         bean = mapper.readerWithView(ViewAA.class)\n-                .withType(Bean.class)\n+                .forType(Bean.class)\n                 .readValue(\"{\\\"a\\\":3, \\\"aa\\\":\\\"foo\\\", \\\"b\\\": 9 }\");\n         // should include 'a' and 'aa' (as per view)\n         assertEquals(3, bean.a);\n         assertEquals(0, bean.b);\n \n         bean = mapper.readerWithView(ViewA.class)\n-                .withType(Bean.class)\n+                .forType(Bean.class)\n                 .readValue(\"{\\\"a\\\":1, \\\"aa\\\":\\\"x\\\", \\\"b\\\": 3 }\");\n         assertEquals(1, bean.a);\n         assertNull(bean.aa);\n \n         // but with, say, AA, will not get 'b'\n         bean = myMapper.readerWithView(ViewAA.class)\n-                .withType(DefaultsBean.class)\n+                .forType(DefaultsBean.class)\n                 .readValue(\"{\\\"a\\\":1, \\\"b\\\": 2 }\");\n         // 'a' not there any more\n         assertEquals(0, bean.a);\n--- a/src/test/java/com/fasterxml/jackson/failing/TestConvertingSerializer357.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestConvertingSerializer357.java\n     extends com.fasterxml.jackson.databind.BaseMapTest\n {\n     // [Issue#357]\n-    static class A { }\n+    static class Value { }\n \n-    static class B {\n-        @JsonSerialize(contentConverter = AToStringConverter.class)\n-        public List<A> list = Arrays.asList(new A());\n+    static class ListWrapper {\n+        @JsonSerialize(contentConverter = ValueToStringListConverter.class)\n+        public List<Value> list = Arrays.asList(new Value());\n     }\n \n-    static class AToStringConverter extends StdConverter<A, List<String>> {\n+    static class ValueToStringListConverter extends StdConverter<Value, List<String>> {\n         @Override\n-        public List<String> convert(A value) {\n+        public List<String> convert(Value value) {\n             return Arrays.asList(\"Hello world!\");\n         }\n     }\n \n     // [Issue#357]\n     public void testConverterForList357() throws Exception {\n-        String json = objectWriter().writeValueAsString(new B());\n+        String json = objectWriter().writeValueAsString(new ListWrapper());\n         assertEquals(\"{\\\"list\\\":[[\\\"Hello world!\\\"]]}\", json);\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId222.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestExternalTypeId222 extends BaseMapTest\n+{\n+\t@SuppressWarnings(\"unused\")\n+\tpublic void testTypes() throws IOException {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+        final Point _date = new Point(new Date());\n+        final Point _integer = new Point(12231321);\n+        final Point _boolean = new Point(Boolean.TRUE);\n+        final Point _long = new Point(1234L);\n+\n+        final Point _pojo = new Point(new Pojo(1));\n+        final String s_date = mapper.writeValueAsString(_date);\n+        final String s_integer = mapper.writeValueAsString(_integer);\n+\n+//System.err.println(\"Int -> \"+s_integer);   \n+    \n+        final String s_boolean = mapper.writeValueAsString(_boolean);\n+        final String s_long = mapper.writeValueAsString(_long);\n+        final String s_pojo = mapper.writeValueAsString(_pojo);\n+\n+        final Point d_date = mapper.readValue(s_date, Point.class);\n+        final Point d_long = mapper.readValue(s_long, Point.class);\n+        final Point d_pojo = mapper.readValue(s_pojo, Point.class);\n+        final Point d_integer = mapper.readValue(s_integer, Point.class);\n+        final Point d_boolean = mapper.readValue(s_boolean, Point.class);\n+    }\n+\n+    @JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY,\n+        getterVisibility = JsonAutoDetect.Visibility.NONE,\n+        setterVisibility = JsonAutoDetect.Visibility.NONE)\n+    static class Point {\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+        property = \"t\",\n+        visible = true,\n+        include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+        defaultImpl = String.class)\n+        @JsonSubTypes({\n+        @JsonSubTypes.Type(value = Date.class, name = \"date\"),\n+        @JsonSubTypes.Type(value = Integer.class, name = \"int\"),\n+        @JsonSubTypes.Type(value = Long.class, name = \"long\"),\n+        @JsonSubTypes.Type(value = Boolean.class, name = \"bool\"),\n+        @JsonSubTypes.Type(value = Pojo.class, name = \"pojo\"),\n+        @JsonSubTypes.Type(value = String.class, name = \"\")\n+        })\n+        private final Object v;\n+    \n+        @JsonCreator\n+        public Point(@JsonProperty(\"v\") Object v) {\n+            this.v = v;\n+        }\n+    \n+        public Object getValue() {\n+            return v;\n+        }\n+    }\n+     \n+\n+    static class Pojo {\n+        public final int p;\n+\n+        @JsonCreator\n+        Pojo(@JsonProperty(\"p\") int p) {\n+            this.p = p;\n+        }\n+    }\n+\n+    // [Issue#222]\n+    static class Issue222Bean\n+    {\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+                property = \"type\",\n+                include = JsonTypeInfo.As.EXTERNAL_PROPERTY)\n+        public Issue222BeanB value;\n+\n+        public String type = \"foo\";\n+        \n+        public Issue222Bean() { }\n+        public Issue222Bean(int v) {\n+            value = new Issue222BeanB(v);\n+        }\n+    }\n+\n+    static class Issue222BeanB\n+    {\n+        public int x;\n+        \n+        public Issue222BeanB() { }\n+        public Issue222BeanB(int value) { x = value; }\n+    }\n+\n+    public void testIssue222() throws Exception\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        Issue222Bean input = new Issue222Bean(13);\n+        String json = mapper.writeValueAsString(input);\n+        assertEquals(\"{\\\"value\\\":{\\\"x\\\":13},\\\"type\\\":\\\"foo\\\"}\", json);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/failing/TestJavaType76.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestJavaType76.java\n \n import java.util.*;\n \n-import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestLocalType609.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Failing test related to [databind#609]\n+ */\n+public class TestLocalType609 extends BaseMapTest\n+{\n+    static class EntityContainer {\n+        RuleForm entity;\n+        \n+        @SuppressWarnings(\"unchecked\")\n+        public <T extends RuleForm> T getEntity() { return (T) entity; }\n+        public <T extends RuleForm> void setEntity(T e) { entity = e; }\n+    }\n+\n+    static class RuleForm {\n+        public int value;\n+\n+        public RuleForm() { }\n+        public RuleForm(int v) { value = v; }\n+    }\n+\n+    public void testLocalPartialType609() throws Exception {\n+        ObjectMapper mapper = new ObjectMapper();\n+        \n+        EntityContainer input = new EntityContainer(); \n+        input.entity = new RuleForm(12);\n+        String json = mapper.writeValueAsString(input);\n+        \n+        EntityContainer output = mapper.readValue(json, EntityContainer.class);\n+        assertEquals(12, output.getEntity().value);\n+    }\n+}\n+\n--- a/src/test/java/com/fasterxml/jackson/failing/TestMapJsonValueKey47.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestMapJsonValueKey47.java\n package com.fasterxml.jackson.failing;\n \n import java.util.HashMap;\n-import java.util.Map;\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonValue;\n         }\n     }\n \n+    @SuppressWarnings(\"serial\")\n+    static class WatMap extends HashMap<Wat,Boolean> { }\n+    \n     public void testMapJsonValueKey()\n     throws Exception\n     {\n-        Map<Wat, Boolean> input = new HashMap<Wat, Boolean>();\n+        WatMap input = new WatMap();\n         input.put(new Wat(\"3\"), true);\n \n         ObjectMapper mapper = new ObjectMapper();\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestMapSerialization588.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.io.IOException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestMapSerialization588 extends BaseMapTest\n+{\n+    static class NoEmptiesMapContainer {\n+        @JsonInclude(value=JsonInclude.Include.NON_EMPTY,\n+                content=JsonInclude.Include.NON_EMPTY)\n+        public Map<String,String> stuff = new LinkedHashMap<String,String>();\n+        \n+        public NoEmptiesMapContainer add(String key, String value) {\n+            stuff.put(key, value);\n+            return this;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    final private ObjectMapper MAPPER = objectMapper();\n+\n+    // [databind#588]\n+    public void testNonNullValueMapViaProp() throws IOException\n+    {\n+        String json = MAPPER.writeValueAsString(new NoEmptiesMapContainer()\n+            .add(\"a\", null)\n+            .add(\"b\", \"\"));\n+        assertEquals(aposToQuotes(\"{}\"), json);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestMultipleExternalIds291.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestMultipleExternalIds291 extends BaseMapTest\n+{\n+    // For [Issue#291]\n+    interface F1 {}\n+\n+    static class A implements F1 {\n+        public String a;\n+    }\n+\n+    static class B implements F1 {\n+        public String b;\n+    }\n+\n+    static interface F2 {}\n+\n+    static class C implements F2 {\n+        public String c;\n+    }\n+\n+    static class D implements F2{\n+        public String d;\n+    }\n+\n+    static class Container {\n+        public String type;\n+\n+        @JsonTypeInfo(use = Id.NAME, property = \"type\", include = As.EXTERNAL_PROPERTY)\n+        @JsonSubTypes({\n+                @JsonSubTypes.Type(value = A.class, name = \"1\"),\n+                @JsonSubTypes.Type(value = B.class, name = \"2\")})\n+        public F1 field1;\n+\n+        @JsonTypeInfo(use = Id.NAME, property = \"type\", include = As.EXTERNAL_PROPERTY)\n+        @JsonSubTypes({\n+                @JsonSubTypes.Type(value = C.class, name = \"1\"),\n+                @JsonSubTypes.Type(value = D.class, name = \"2\")})\n+        public F2 field2;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    // [Issue#291]\n+    public void testMultiple() throws Exception\n+    {\n+        final ObjectMapper mapper = objectMapper();\n+        final String JSON =\n+\"{\\\"type\\\" : \\\"1\\\",\\n\"\n++\"\\\"field1\\\" : {\\n\"\n++\"  \\\"a\\\" : \\\"AAA\\\"\\n\"\n++\"}, \\\"field2\\\" : {\\n\"\n++\"  \\\"c\\\" : \\\"CCC\\\"\\n\"\n++\"}\\n\"\n++\"}\";\n+\n+        Container c = mapper.readValue(JSON, Container.class);\n+        assertNotNull(c);\n+        assertTrue(c.field1 instanceof A);\n+        assertTrue(c.field2 instanceof C);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestObjectIdWithInjectables538.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestObjectIdWithInjectables538 extends BaseMapTest\n+{\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)\n+    public static class A {\n+        public B b;\n+\n+        public A(@JacksonInject(\"i1\") String injected) {\n+        }\n+    }\n+\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)\n+    public static class B {\n+        public A a;\n+\n+        public B(@JacksonInject(\"i2\") String injected) {\n+        }\n+    } \n+\n+    /*\n+    /*****************************************************\n+    /* Test methods\n+    /*****************************************************\n+     */\n+    \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testWithInjectables538() throws Exception\n+    {\n+        A a = new A(\"a\");\n+        B b = new B(\"b\");\n+        a.b = b;\n+        b.a = a;\n+\n+        String json = MAPPER.writeValueAsString(a);\n+\n+        InjectableValues.Std inject = new InjectableValues.Std();\n+        inject.addValue(\"i1\", \"e1\");\n+        inject.addValue(\"i2\", \"e2\");\n+        A output = null;\n+\n+        try {\n+            output = MAPPER.reader(inject).forType(A.class).readValue(json);\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Failed to deserialize from JSON '\"+json+\"'\", e);\n+        }\n+        assertNotNull(output);\n+\n+        assertNotNull(output.b);\n+    }\n+}\n+\n--- a/src/test/java/com/fasterxml/jackson/failing/TestPolymorphicDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestPolymorphicDeserialization.java\n  * deserializer comes to different conclusion (using default implementation class),\n  * resulting in a <code>ClassCastException</code>.\n  * Whether this is wrong, and if so, can we fix it, is unknown at this point\n- * (2.3.0-SNAPSHOT): quite possibly this can not be changed.\n+ * (2.3): quite possibly this can not be changed.\n  */\n public class TestPolymorphicDeserialization extends BaseMapTest\n {\n--- a/src/test/java/com/fasterxml/jackson/failing/TestScalaLikeImplicitProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestScalaLikeImplicitProperties.java\n                 if (name.endsWith(\"\u203f\")) {\n                     return name.substring(0, name.length()-1);\n                 }\n-            } else if (member instanceof AnnotatedField) {\n+            } else if (member instanceof AnnotatedMethod) {\n                 name = member.getName();\n                 if (name.endsWith(\"_\u2040\")) {\n                     return name.substring(0, name.length()-2);\n                 }\n+                if (!name.startsWith(\"get\") && !name.startsWith(\"set\")) {\n+                    return name;\n+                }\n+            } else if (member instanceof AnnotatedParameter) {\n+                // A placeholder for legitimate property name detection\n+                // such as what the JDK8 module provides\n+                return \"prop\";\n             }\n             return null;\n+        }\n+\n+        @Override\n+        public boolean hasCreatorAnnotation(Annotated a) {\n+            // A placeholder for legitmate creator detection.\n+            // In Scala, all primary constructors should be creators,\n+            // but I can't obtain a reference to the AnnotatedClass from the\n+            // AnnotatedConstructor, so it's simulated here.\n+            return (a instanceof AnnotatedConstructor);\n         }\n     }\n     \n     static class ValProperty\n     {\n-        public final String prop\u203f;\n+        private final String prop\u203f;\n         public String prop() { return prop\u203f; }\n \n         public ValProperty(String prop) {\n \n     static class ValWithBeanProperty\n     {\n-        public final String prop\u203f;\n+        private final String prop\u203f;\n         public String prop() { return prop\u203f; }\n         public String getProp() { return prop\u203f; }\n \n \n     static class VarProperty\n     {\n-        public String prop\u203f;\n+        private String prop\u203f;\n         public String prop() { return prop\u203f; }\n         public void prop_\u2040(String p) { prop\u203f = p; }\n-\n-        // tatu: this is needed, unless single-arg ctor auto-detected\n-        //  ... or, with JDK8, implicit ctor arg name used along with creator\n-        public VarProperty() { }\n \n         public VarProperty(String prop) {\n             prop\u203f = prop;\n \n     static class VarWithBeanProperty\n     {\n-        public String prop\u203f;\n+        private String prop\u203f;\n         public String prop() { return prop\u203f; }\n         public void prop_\u2040(String p) { prop\u203f = p; }\n         public String getProp() { return prop\u203f; }\n     {\n         ObjectMapper m = manglingMapper();\n \n-        // TODO: Activate whatever handler implements the property detection style\n-\n         assertEquals(\"{\\\"prop\\\":\\\"val\\\"}\", m.writeValueAsString(new ValProperty(\"val\")));\n     }\n \n     {\n         ObjectMapper m = manglingMapper();\n \n-        // TODO: Activate whatever handler implements the property detection style\n-\n         assertEquals(\"{\\\"prop\\\":\\\"val\\\"}\", m.writeValueAsString(new ValWithBeanProperty(\"val\")));\n     }\n \n     public void testVarProperty() throws Exception\n     {\n         ObjectMapper m = manglingMapper();\n-\n-        // TODO: Activate whatever handler implements the property detection style\n \n         assertEquals(\"{\\\"prop\\\":\\\"var\\\"}\", m.writeValueAsString(new VarProperty(\"var\")));\n         VarProperty result = m.readValue(\"{\\\"prop\\\":\\\"read\\\"}\", VarProperty.class);\n     {\n         ObjectMapper m = manglingMapper();\n \n-        // TODO: Activate whatever handler implements the property detection style\n-\n         assertEquals(\"{\\\"prop\\\":\\\"var\\\"}\", m.writeValueAsString(new VarWithBeanProperty(\"var\")));\n         VarWithBeanProperty result = m.readValue(\"{\\\"prop\\\":\\\"read\\\"}\", VarWithBeanProperty.class);\n         assertEquals(\"read\", result.prop());\n     public void testGetterSetterProperty() throws Exception\n     {\n         ObjectMapper m = manglingMapper();\n-\n-        // TODO: Activate whatever handler implements the property detection style\n \n         assertEquals(\"{\\\"prop\\\":\\\"get/set\\\"}\", m.writeValueAsString(new GetterSetterProperty()));\n         GetterSetterProperty result = m.readValue(\"{\\\"prop\\\":\\\"read\\\"}\", GetterSetterProperty.class);\n--- a/src/test/java/com/fasterxml/jackson/failing/TestUnwrappedWithCreator.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestUnwrappedWithCreator.java\n public class TestUnwrappedWithCreator extends BaseMapTest\n {\n     static class JAddress {\n-        private String address;\n-        private String city;\n-        private String state;\n+        protected String address;\n+        protected String city;\n+        protected String state;\n          \n         @JsonCreator\n-        public JAddress(\n-                @JsonProperty(\"address\") String address,\n+        public JAddress( @JsonProperty(\"address\") String address,\n                 @JsonProperty(\"city\") String city,\n                 @JsonProperty(\"state\") String state\n         ){\n     }\n \n     static class JPerson {\n-        private String _name;\n-        private JAddress _address;\n-        private String _alias;\n+        protected String _name;\n+        protected JAddress _address;\n+        protected String _alias;\n          \n         @JsonCreator\n-        public JPerson(\n-        @JsonProperty(\"name\") String name,\n+        public JPerson(@JsonProperty(\"name\") String name,\n         @JsonUnwrapped JAddress address,\n-        @JsonProperty(\"alias\") String alias\n-        ) {\n+        @JsonProperty(\"alias\") String alias) {\n             _name = name;\n             _address = address;\n             _alias = alias;\n--- a/src/test/java/perf/ObjectReaderTestBase.java\n+++ b/src/test/java/perf/ObjectReaderTestBase.java\n         System.out.print(\"Warming up\");\n \n         final ObjectReader jsonReader = mapper1.reader()\n-                .withType(inputClass1);\n+                .forType(inputClass1);\n         final ObjectReader arrayReader = mapper2.reader()\n-                .withType(inputClass2);\n+                .forType(inputClass2);\n         \n         int i = 0;\n         final int TYPES = 2;\n \n         final ObjectReader jsonReader = mapper1.reader()\n                 .with(DeserializationFeature.EAGER_DESERIALIZER_FETCH)\n-                .withType(inputClass1);\n+                .forType(inputClass1);\n         final ObjectReader arrayReader = mapper2.reader()\n                 .with(DeserializationFeature.EAGER_DESERIALIZER_FETCH)\n-                .withType(inputClass2);\n+                .forType(inputClass2);\n         \n         int i = 0;\n         final int TYPES = 2;\n--- a/src/test/java/perf/ObjectWriterTestBase.java\n+++ b/src/test/java/perf/ObjectWriterTestBase.java\n         }\n \n         final ObjectWriter writer0 = mapper.writer().with(SerializationFeature.EAGER_SERIALIZER_FETCH);\n-        final ObjectWriter writer1 = writer0.withType(inputClass1);\n-        final ObjectWriter writer2 = writer0.withType(inputClass2);\n+        final ObjectWriter writer1 = writer0.forType(inputClass1);\n+        final ObjectWriter writer2 = writer0.forType(inputClass2);\n         \n         int i = 0;\n         int roundsDone = 0;", "timestamp": 1418354415, "metainfo": ""}