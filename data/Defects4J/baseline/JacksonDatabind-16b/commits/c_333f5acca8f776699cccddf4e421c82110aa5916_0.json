{"sha": "333f5acca8f776699cccddf4e421c82110aa5916", "log": "Complete initial SequenceWriter implementation. To be tested.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/SequenceWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SequenceWriter.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n \n /**\n  * Writer class similar to {@link ObjectWriter}, except that it can be used\n     /* State\n     /**********************************************************\n      */\n+\n+    /**\n+     * If {@link #_rootSerializer} is not defined (no root type\n+     * was used for constructing {@link ObjectWriter}), we will\n+     * use simple scheme for keeping track of serializers needed.\n+     * Assumption is that\n+     */\n+    protected PropertySerializerMap _dynamicSerializers;\n     \n     /**\n      * State flag for keeping track of need to write matching END_ARRAY,\n         _config = prov.getConfig();\n         _cfgFlush = _config.isEnabled(SerializationFeature.FLUSH_AFTER_WRITE_VALUE);\n         _cfgCloseCloseable = _config.isEnabled(SerializationFeature.CLOSE_CLOSEABLE);\n+        // important: need to cache \"root value\" serializers, to handle polymorphic\n+        // types properly\n+        _dynamicSerializers = PropertySerializerMap.emptyForRootValues();\n     }\n \n     public SequenceWriter init(boolean wrapInArray) throws IOException\n     /**********************************************************\n      */\n \n+    /**\n+     * Method for writing given value into output, as part of sequence\n+     * to write. If root type was specified for {@link ObjectWriter},\n+     * value must be of compatible type (same or subtype).\n+     */\n     public void writeValue(Object value) throws IOException\n     {\n+        if (value == null) {\n+            _provider.serializeValue(_generator, null);\n+            return;\n+        }\n+        \n         if (_cfgCloseCloseable && (value instanceof Closeable)) {\n             _writeCloseableValue(value);\n-        } else {\n-            if (_rootType == null) {\n-                _provider.serializeValue(_generator, value);\n-            } else {\n-                _provider.serializeValue(_generator, value, _rootType, _rootSerializer);\n-            }\n-            if (_cfgFlush) {\n-                _generator.flush();\n-            }\n-        }\n-    }\n+            return;\n+        }\n+        JsonSerializer<Object> ser = _rootSerializer;\n+        if (ser == null) {\n+            Class<?> type = value.getClass();\n+            ser = _dynamicSerializers.serializerFor(type);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(type);\n+            }\n+        }\n+        _provider.serializeValue(_generator, value, _rootType, ser);\n+        if (_cfgFlush) {\n+            _generator.flush();\n+        }\n+    }\n+\n+    /**\n+     * Method for writing given value into output, as part of sequence\n+     * to write; further, full type (often generic, like {@link java.util.Map}\n+     * is passed in case a new\n+     * {@link JsonSerializer} needs to be fetched to handle type\n+     * \n+     * If root type was specified for {@link ObjectWriter},\n+     * value must be of compatible type (same or subtype).\n+     */\n+    public void writeValue(Object value, JavaType type) throws IOException\n+    {\n+        if (value == null) {\n+            _provider.serializeValue(_generator, null);\n+            return;\n+        }\n+        \n+        if (_cfgCloseCloseable && (value instanceof Closeable)) {\n+            _writeCloseableValue(value, type);\n+            return;\n+        }\n+        /* 15-Dec-2014, tatu: I wonder if this could be come problematic. It shouldn't\n+         *   really, since trying to use differently paramterized types in a sequence\n+         *   is likely to run into other issues. But who knows; if it does become an\n+         *   issue, may need to implement alternative, JavaType-based map.\n+         */\n+        JsonSerializer<Object> ser = _dynamicSerializers.serializerFor(type.getRawClass());\n+        if (ser == null) {\n+            ser = _findAndAddDynamic(type);\n+        }\n+        _provider.serializeValue(_generator, value, type, ser);\n+        if (_cfgFlush) {\n+            _generator.flush();\n+        }\n+    }\n+    \n+    @Override\n+    public void close() throws IOException\n+    {\n+        if (!_closed) {\n+            _closed = true;\n+            if (_openArray) {\n+                _openArray = false;\n+                _generator.writeEndArray();\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal helper methods, serializer lookups\n+    /**********************************************************\n+     */\n \n     protected void _writeCloseableValue(Object value) throws IOException\n     {\n         Closeable toClose = (Closeable) value;\n         try {\n-            if (_rootType == null) {\n-                _provider.serializeValue(_generator, value);\n-            } else {\n-                _provider.serializeValue(_generator, value, _rootType, _rootSerializer);\n-            }\n+            JsonSerializer<Object> ser = _rootSerializer;\n+            if (ser == null) {\n+                Class<?> type = value.getClass();\n+                ser = _dynamicSerializers.serializerFor(type);\n+                if (ser == null) {\n+                    ser = _findAndAddDynamic(type);\n+                }\n+                _provider.serializeValue(_generator, value, null, ser);\n+            }\n+            _provider.serializeValue(_generator, value, _rootType, ser);\n             if (_cfgFlush) {\n                 _generator.flush();\n             }\n             }\n         }\n     }\n-    \n-    @Override\n-    public void close() throws IOException\n-    {\n-        if (!_closed) {\n-            _closed = true;\n-            if (_openArray) {\n-                _openArray = false;\n-                _generator.writeEndArray();\n-            }\n-        }\n+\n+    protected void _writeCloseableValue(Object value, JavaType type) throws IOException\n+    {\n+        Closeable toClose = (Closeable) value;\n+        try {\n+            // 15-Dec-2014, tatu: As per above, could be problem that we do not pass generic type\n+            JsonSerializer<Object >ser = _dynamicSerializers.serializerFor(type.getRawClass());\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(type);\n+            }\n+            _provider.serializeValue(_generator, value, type, ser);\n+            if (_cfgFlush) {\n+                _generator.flush();\n+            }\n+            Closeable tmpToClose = toClose;\n+            toClose = null;\n+            tmpToClose.close();\n+        } finally {\n+            if (toClose != null) {\n+                try {\n+                    toClose.close();\n+                } catch (IOException ioe) { }\n+            }\n+        }\n+    }\n+\n+    protected final JsonSerializer<Object> _findAndAddDynamic(Class<?> type) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result\n+            = _dynamicSerializers.findAndAddPrimarySerializer(type, _provider, null);\n+        _dynamicSerializers = result.map;\n+        return result.serializer;\n+    }\n+\n+    protected final JsonSerializer<Object> _findAndAddDynamic(JavaType type) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result\n+            = _dynamicSerializers.findAndAddPrimarySerializer(type, _provider, null);\n+        _dynamicSerializers = result.map;\n+        return result.serializer;\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n \n         _declaredType = declaredType;\n         _serializer = (JsonSerializer<Object>) ser;\n-        _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null;\n+        _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyForProperties() : null;\n         _typeSerializer = typeSer;\n         _cfgSerializationType = serType;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n      * properly; specifically, that caches are cleared, but settings\n      * will otherwise remain identical; and that no sharing of state\n      * occurs.\n-     * \n-     * @since 2.4.4\n+     *\n+     * @since 2.5\n      */\n     public DefaultSerializerProvider copy() {\n         throw new IllegalStateException(\"DefaultSerializerProvider sub-class not overriding copy()\");\n      * this provider has access to (via caching and/or creating new serializers\n      * as need be).\n      */\n-    public void serializeValue(JsonGenerator jgen, Object value) throws IOException\n+    public void serializeValue(JsonGenerator gen, Object value) throws IOException\n     {\n         if (value == null) {\n-            _serializeNull(jgen);\n+            _serializeNull(gen);\n             return;\n         }\n         Class<?> cls = value.getClass();\n             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n             if (wrap) {\n                 PropertyName pname = _rootNames.findRootName(value.getClass(), _config);\n-                jgen.writeStartObject();\n-                jgen.writeFieldName(pname.simpleAsEncoded(_config));\n+                gen.writeStartObject();\n+                gen.writeFieldName(pname.simpleAsEncoded(_config));\n             }\n         } else if (rootName.length() == 0) {\n             wrap = false;\n         } else { // [JACKSON-764]\n             // empty String means explicitly disabled; non-empty that it is enabled\n             wrap = true;\n-            jgen.writeStartObject();\n-            jgen.writeFieldName(rootName);\n+            gen.writeStartObject();\n+            gen.writeFieldName(rootName);\n         }\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n             if (wrap) {\n-                jgen.writeEndObject();\n+                gen.writeEndObject();\n             }\n         } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n             throw ioe;\n      * @param rootType Type to use for locating serializer to use, instead of actual\n      *    runtime type. Must be actual type, or one of its super types\n      */\n-    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType) throws IOException\n+    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType) throws IOException\n     {\n         if (value == null) {\n-            _serializeNull(jgen);\n+            _serializeNull(gen);\n             return;\n         }\n         // Let's ensure types are compatible at this point\n             // [JACKSON-163]\n             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n             if (wrap) {\n-                jgen.writeStartObject();\n+                gen.writeStartObject();\n                 PropertyName pname = _rootNames.findRootName(value.getClass(), _config);\n-                jgen.writeFieldName(pname.simpleAsEncoded(_config));\n+                gen.writeFieldName(pname.simpleAsEncoded(_config));\n             }\n         } else if (rootName.length() == 0) {\n             wrap = false;\n         } else { // [JACKSON-764]\n             // empty String means explicitly disabled; non-empty that it is enabled\n             wrap = true;\n-            jgen.writeStartObject();\n-            jgen.writeFieldName(rootName);\n+            gen.writeStartObject();\n+            gen.writeFieldName(rootName);\n         }\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n             if (wrap) {\n-                jgen.writeEndObject();\n+                gen.writeEndObject();\n             }\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n      * \n      * @since 2.1\n      */\n-    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException\n+    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType, JsonSerializer<Object> ser) throws IOException\n     {\n         if (value == null) {\n-            _serializeNull(jgen);\n+            _serializeNull(gen);\n             return;\n         }\n         // Let's ensure types are compatible at this point\n             // [JACKSON-163]\n             wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n             if (wrap) {\n-                jgen.writeStartObject();\n+                gen.writeStartObject();\n                 PropertyName pname = (rootType == null)\n                         ? _rootNames.findRootName(value.getClass(), _config)\n                         : _rootNames.findRootName(rootType, _config);\n-                jgen.writeFieldName(pname.simpleAsEncoded(_config));\n+                gen.writeFieldName(pname.simpleAsEncoded(_config));\n             }\n         } else if (rootName.length() == 0) {\n             wrap = false;\n         } else { // [JACKSON-764]\n             // empty String means explicitly disabled; non-empty that it is enabled\n             wrap = true;\n-            jgen.writeStartObject();\n-            jgen.writeFieldName(rootName);\n+            gen.writeStartObject();\n+            gen.writeFieldName(rootName);\n         }\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n             if (wrap) {\n-                jgen.writeEndObject();\n+                gen.writeEndObject();\n             }\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n      * \n      * @since 2.3\n      */\n-    protected void _serializeNull(JsonGenerator jgen) throws IOException\n+    protected void _serializeNull(JsonGenerator gen) throws IOException\n     {\n         JsonSerializer<Object> ser = getDefaultNullValueSerializer();\n         try {\n-            ser.serialize(null, jgen, this);\n+            ser.serialize(null, gen, this);\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n         } catch (Exception e) { // but others do need to be, to get path etc\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java\n         _valueTypeIsStatic = staticTyping;\n         _valueTypeSerializer = vts;\n         _property = property;\n-        _dynamicValueSerializers = PropertySerializerMap.emptyMap();\n+        _dynamicValueSerializers = PropertySerializerMap.emptyForProperties();\n     }\n \n     @SuppressWarnings(\"unchecked\")\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.util.Arrays;\n \n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n-\n \n /**\n  * Helper container used for resolving serializers for dynamic (possibly but not\n public abstract class PropertySerializerMap\n {\n     /**\n+     * Configuration setting that determines whether we are caching\n+     * \"root value\" serializers (true), or \"property\" serializers (false);\n+     * former will have embedded {@link TypeSerializer}, whereas latter not.\n+     *\n+     * @since 2.5\n+     */\n+    protected final boolean _findRootSerializers;\n+\n+    /**\n+     * Configuration setting that determines what happens when maximum\n+     * size (currently 8) is reached: if true, will \"start from beginning\";\n+     * if false, will simply stop adding new entries.\n+     *\n+     * @since 2.5\n+     */\n+    protected final boolean _resetWhenFull;\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected PropertySerializerMap(boolean rootSerializers, boolean resetWhenFull) {\n+        _findRootSerializers = rootSerializers;\n+        _resetWhenFull = resetWhenFull;\n+    }\n+\n+    protected PropertySerializerMap(PropertySerializerMap base) {\n+        _findRootSerializers = base._findRootSerializers;\n+        _resetWhenFull = base._resetWhenFull;\n+    }\n+    \n+    /**\n      * Main lookup method. Takes a \"raw\" type since usage is always from\n      * place where parameterization is fixed such that there can not be\n      * type-parametric variations.\n      */\n     public abstract JsonSerializer<Object> serializerFor(Class<?> type);\n-\n-    /**\n-     * @deprecated Since 2.3; use either <code>findAndAddPrimarySerializer</code> or\n-     *    <code>findAndAddSecondarySerializer</code>.\n-     *    To be removed from 2.4\n-     */\n-    @Deprecated\n-    public final SerializerAndMapResult findAndAddSerializer(Class<?> type,\n-            SerializerProvider provider, BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        return findAndAddSecondarySerializer(type, provider, property);\n-    }\n-\n-    /**\n-     * @deprecated Since 2.3; use either <code>findAndAddPrimarySerializer</code> or\n-     *    <code>findAndAddSecondarySerializer</code>.\n-     *    To be removed from 2.4\n-     */\n-    @Deprecated\n-    public final SerializerAndMapResult findAndAddSerializer(JavaType type,\n-            SerializerProvider provider, BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        return findAndAddSecondarySerializer(type, provider, property);\n-    }\n \n     /**\n      * Method called if initial lookup fails, when looking for a primary\n         JsonSerializer<Object> serializer = provider.findPrimaryPropertySerializer(type, property);\n         return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));\n     }\n-    \n+\n     /**\n      * Method called if initial lookup fails, when looking for a non-primary\n      * serializer (one that is not directly attached to a property).\n         JsonSerializer<Object> serializer = provider.findValueSerializer(type, property);\n         return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));\n     }\n-    \n+\n     public abstract PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer);\n-    \n+\n+    /**\n+     * @deprecated Since 2.5 Use {@link #emptyForProperties} instead\n+     */\n+    @Deprecated\n     public static PropertySerializerMap emptyMap() {\n-        return Empty.instance;\n-    }\n-    \n+        return emptyForProperties();\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public static PropertySerializerMap emptyForProperties() {\n+        return Empty.FOR_PROPERTIES;\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    public static PropertySerializerMap emptyForRootValues() {\n+        return Empty.FOR_ROOT_VALUES;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Helper classes\n      */\n     private final static class Empty extends PropertySerializerMap\n     {\n-        protected final static Empty instance = new Empty();\n-\n+        // No root serializers; do not reset when full\n+        public final static Empty FOR_PROPERTIES = new Empty(false, false);\n+\n+        // Yes, root serializers; do reset when full\n+        public final static Empty FOR_ROOT_VALUES = new Empty(true, true);\n+\n+        protected Empty(boolean rootSerializers, boolean resetWhenFull) {\n+            super(rootSerializers, resetWhenFull);\n+        }\n+        \n         @Override\n         public JsonSerializer<Object> serializerFor(Class<?> type) {\n             return null; // empty, nothing to find\n \n         @Override\n         public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) {\n-            return new Single(type, serializer);\n+            return new Single(this, type, serializer);\n         }\n     }\n \n         private final Class<?> _type;\n         private final JsonSerializer<Object> _serializer;\n \n-        public Single(Class<?> type, JsonSerializer<Object> serializer) {\n+        public Single(PropertySerializerMap base, Class<?> type, JsonSerializer<Object> serializer) {\n+            super(base);\n             _type = type;\n             _serializer = serializer;\n         }\n \n         @Override\n         public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) {\n-            return new Double(_type, _serializer, type, serializer);\n+            return new Double(this, _type, _serializer, type, serializer);\n         }\n     }\n \n         private final Class<?> _type1, _type2;\n         private final JsonSerializer<Object> _serializer1, _serializer2;\n \n-        public Double(Class<?> type1, JsonSerializer<Object> serializer1,\n+        public Double(PropertySerializerMap base,\n+                Class<?> type1, JsonSerializer<Object> serializer1,\n                 Class<?> type2, JsonSerializer<Object> serializer2)\n         {\n+            super(base);\n             _type1 = type1;\n             _serializer1 = serializer1;\n             _type2 = type2;\n         @Override\n         public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) {\n             // Ok: let's just create generic one\n-            TypeAndSerializer[] ts = new TypeAndSerializer[2];\n+            TypeAndSerializer[] ts = new TypeAndSerializer[3];\n             ts[0] = new TypeAndSerializer(_type1, _serializer1);\n             ts[1] = new TypeAndSerializer(_type2, _serializer2);\n-            return new Multi(ts);\n+            ts[2] = new TypeAndSerializer(type, serializer);\n+            return new Multi(this, ts);\n         }\n     }\n     \n         \n         private final TypeAndSerializer[] _entries;\n \n-        public Multi(TypeAndSerializer[] entries) {\n+        public Multi(PropertySerializerMap base, TypeAndSerializer[] entries) {\n+            super(base);\n             _entries = entries;\n         }\n \n         public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer)\n         {\n             int len = _entries.length;\n-            // Will only grow up to N entries\n+            // Will only grow up to N entries. We could consider couple of alternatives after\n+            // this if we wanted to... but for now, two main choices make most sense\n             if (len == MAX_ENTRIES) {\n+                if (_resetWhenFull) {\n+                    return new Single(this, type, serializer);\n+                }\n                 return this;\n             }\n-            // 1.6 has nice resize methods but we are still 1.5\n-            TypeAndSerializer[] entries = new TypeAndSerializer[len+1];\n-            System.arraycopy(_entries, 0, entries, 0, len);\n+            TypeAndSerializer[] entries = Arrays.copyOf(_entries, len+1);\n             entries[len] = new TypeAndSerializer(type, serializer);\n-            return new Multi(entries);\n+            return new Multi(this, entries);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n      * runtime type to serializer is handled using this object\n      */\n     protected PropertySerializerMap _dynamicSerializers;\n-    \n+\n     /*\n     /**********************************************************\n     /* Life-cycle\n         _valueTypeSerializer = vts;\n         _property = property;\n         _elementSerializer = elementSerializer;\n-        _dynamicSerializers = PropertySerializerMap.emptyMap();\n+        _dynamicSerializers = PropertySerializerMap.emptyForProperties();\n     }\n \n     @SuppressWarnings(\"unchecked\")\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n         _valueTypeSerializer = vts;\n         _keySerializer = (JsonSerializer<Object>) keySerializer;\n         _valueSerializer = (JsonSerializer<Object>) valueSerializer;\n-        _dynamicValueSerializers = PropertySerializerMap.emptyMap();\n+        _dynamicValueSerializers = PropertySerializerMap.emptyForProperties();\n         _property = null;\n         _filterId = null;\n         _sortKeys = false;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n         _elementType = elemType;\n         _staticTyping = staticTyping;\n         _valueTypeSerializer = vts;\n-        _dynamicSerializers = PropertySerializerMap.emptyMap();\n+        _dynamicSerializers = PropertySerializerMap.emptyForProperties();\n         _elementSerializer = elementSerializer;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n         return (implClass.getAnnotation(JacksonStdImpl.class) != null);\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n     public final static boolean isBogusClass(Class<?> cls) {\n         return (cls == Void.class || cls == Void.TYPE\n                 || cls == com.fasterxml.jackson.databind.annotation.NoClass.class);\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/seq/ReadValuesTest.java\n+package com.fasterxml.jackson.databind.seq;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.MappingIterator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+@SuppressWarnings(\"resource\")\n+public class ReadValuesTest extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static class Bean {\n+        public int a;\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (o == null || o.getClass() != getClass()) return false;\n+            Bean other = (Bean) o;\n+            return other.a == this.a;\n+        }\n+        @Override public int hashCode() { return a; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests; root-level value sequences via Mapper\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testRootBeans() throws Exception\n+    {\n+        final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n+\n+        MappingIterator<Bean> it = MAPPER.reader(Bean.class).readValues(JSON);\n+\n+        assertNotNull(it.getCurrentLocation());\n+        assertTrue(it.hasNext());\n+        Bean b = it.next();\n+        assertEquals(3, b.a);\n+        assertTrue(it.hasNext());\n+        b = it.next();\n+        assertEquals(27, b.a);\n+        assertFalse(it.hasNext());\n+        it.close();\n+\n+        // Also, test 'readAll()'\n+        it = MAPPER.reader(Bean.class).readValues(JSON);\n+        List<Bean> all = it.readAll();\n+        assertEquals(2, all.size());\n+        it.close();\n+\n+        it = MAPPER.reader(Bean.class).readValues(\"{\\\"a\\\":3}{\\\"a\\\":3}\");\n+        Set<Bean> set = it.readAll(new HashSet<Bean>());\n+        assertEquals(HashSet.class, set.getClass());\n+        assertEquals(1, set.size());\n+        assertEquals(3, set.iterator().next().a);\n+    }\n+\n+    public void testRootMaps() throws Exception\n+    {\n+        final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n+        Iterator<Map<?,?>> it = MAPPER.reader(Map.class).readValues(JSON);\n+\n+        assertNotNull(((MappingIterator<?>) it).getCurrentLocation());\n+        assertTrue(it.hasNext());\n+        Map<?,?> map = it.next();\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(3), map.get(\"a\"));\n+        assertTrue(it.hasNext());\n+        assertNotNull(((MappingIterator<?>) it).getCurrentLocation());\n+        map = it.next();\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(27), map.get(\"a\"));\n+        assertFalse(it.hasNext());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests; root-level value sequences via JsonParser\n+    /**********************************************************\n+     */\n+\n+    public void testRootBeansWithParser() throws Exception\n+    {\n+        final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n+        JsonParser jp = MAPPER.getFactory().createParser(JSON);\n+        \n+        Iterator<Bean> it = jp.readValuesAs(Bean.class);\n+\n+        assertTrue(it.hasNext());\n+        Bean b = it.next();\n+        assertEquals(3, b.a);\n+        assertTrue(it.hasNext());\n+        b = it.next();\n+        assertEquals(27, b.a);\n+        assertFalse(it.hasNext());\n+    }\n+\n+    public void testRootArraysWithParser() throws Exception\n+    {\n+        final String JSON = \"[1][3]\";\n+        JsonParser jp = MAPPER.getFactory().createParser(JSON);\n+\n+        // NOTE: We must point JsonParser to the first element; if we tried to\n+        // use \"managed\" accessor, it would try to advance past START_ARRAY.\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        \n+        Iterator<int[]> it = MAPPER.reader(int[].class).readValues(jp);\n+        assertTrue(it.hasNext());\n+        int[] array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(1, array[0]);\n+        assertTrue(it.hasNext());\n+        array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(3, array[0]);\n+        assertFalse(it.hasNext());\n+    }\n+    \n+    public void testHasNextWithEndArray() throws Exception {\n+        final String JSON = \"[1,3]\";\n+        JsonParser jp = MAPPER.getFactory().createParser(JSON);\n+\n+        // NOTE: We must point JsonParser to the first element; if we tried to\n+        // use \"managed\" accessor, it would try to advance past START_ARRAY.\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        jp.nextToken();\n+        \n+        Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(jp);\n+        assertTrue(it.hasNext());\n+        int value = it.next();\n+        assertEquals(1, value);\n+        assertTrue(it.hasNext());\n+        value = it.next();\n+        assertEquals(3, value);\n+        assertFalse(it.hasNext());\n+        assertFalse(it.hasNext());\n+    }\n+    \n+    public void testHasNextWithEndArrayManagedParser() throws Exception {\n+        final String JSON = \"[1,3]\";\n+\n+        Iterator<Integer> it = MAPPER.reader(Integer.class).readValues(JSON);\n+        assertTrue(it.hasNext());\n+        int value = it.next();\n+        assertEquals(1, value);\n+        assertTrue(it.hasNext());\n+        value = it.next();\n+        assertEquals(3, value);\n+        assertFalse(it.hasNext());\n+        assertFalse(it.hasNext());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests; non-root arrays\n+    /**********************************************************\n+     */\n+\n+    public void testNonRootBeans() throws Exception\n+    {\n+        final String JSON = \"{\\\"leaf\\\":[{\\\"a\\\":3},{\\\"a\\\":27}]}\";\n+        JsonParser jp = MAPPER.getFactory().createParser(JSON);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        // can either advance to first START_OBJECT, or clear current token;\n+        // explicitly passed JsonParser MUST point to the first token of\n+        // the first element\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        \n+        Iterator<Bean> it = MAPPER.reader(Bean.class).readValues(jp);\n+\n+        assertTrue(it.hasNext());\n+        Bean b = it.next();\n+        assertEquals(3, b.a);\n+        assertTrue(it.hasNext());\n+        b = it.next();\n+        assertEquals(27, b.a);\n+        assertFalse(it.hasNext());\n+        jp.close();\n+    }\n+\n+    public void testNonRootMapsWithParser() throws Exception\n+    {\n+        final String JSON = \"[{\\\"a\\\":3},{\\\"a\\\":27}]\";\n+        JsonParser jp = MAPPER.getFactory().createParser(JSON);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        // can either advance to first START_OBJECT, or clear current token;\n+        // explicitly passed JsonParser MUST point to the first token of\n+        // the first element\n+        jp.clearCurrentToken();\n+        \n+        Iterator<Map<?,?>> it = MAPPER.reader(Map.class).readValues(jp);\n+\n+        assertTrue(it.hasNext());\n+        Map<?,?> map = it.next();\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(3), map.get(\"a\"));\n+        assertTrue(it.hasNext());\n+        map = it.next();\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(27), map.get(\"a\"));\n+        assertFalse(it.hasNext());\n+        jp.close();\n+    }\n+\n+    public void testNonRootMapsWithObjectReader() throws Exception\n+    {\n+        String JSON = \"[{ \\\"hi\\\": \\\"ho\\\", \\\"neighbor\\\": \\\"Joe\\\" },\\n\"\n+            +\"{\\\"boy\\\": \\\"howdy\\\", \\\"huh\\\": \\\"what\\\"}]\";\n+        final MappingIterator<Map<String, Object>> iterator = MAPPER\n+                .reader()\n+                .forType(new TypeReference<Map<String, Object>>(){})\n+                .readValues(JSON);\n+\n+        Map<String,Object> map;\n+        assertTrue(iterator.hasNext());\n+        map = iterator.nextValue();\n+        assertEquals(2, map.size());\n+        assertTrue(iterator.hasNext());\n+        map = iterator.nextValue();\n+        assertEquals(2, map.size());\n+        assertFalse(iterator.hasNext());\n+    }\n+    \n+    public void testNonRootArraysUsingParser() throws Exception\n+    {\n+        final String JSON = \"[[1],[3]]\";\n+        JsonParser jp = MAPPER.getFactory().createParser(JSON);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        \n+        // Important: as of 2.1, START_ARRAY can only be skipped if the\n+        // target type is NOT a Collection or array Java type.\n+        // So we have to explicitly skip it in this particular case.\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        \n+        Iterator<int[]> it = MAPPER.readValues(jp, int[].class);\n+\n+        assertTrue(it.hasNext());\n+        int[] array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(1, array[0]);\n+        assertTrue(it.hasNext());\n+        array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(3, array[0]);\n+        assertFalse(it.hasNext());\n+        jp.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/seq/SequenceWriterTest.java\n+package com.fasterxml.jackson.databind.seq;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+\n+public class SequenceWriterTest extends BaseMapTest\n+{\n+    // !!! TBI\n+\n+    public void testJustJoking() { }\n+}", "timestamp": 1418710601, "metainfo": ""}