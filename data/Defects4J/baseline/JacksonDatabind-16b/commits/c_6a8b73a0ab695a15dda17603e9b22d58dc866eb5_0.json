{"sha": "6a8b73a0ab695a15dda17603e9b22d58dc866eb5", "log": "Yet more pruning", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ByteBufferBackedInputStream.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ByteBufferBackedInputStream.java\n  * Simple {@link InputStream} implementation that exposes currently\n  * available content of a {@link ByteBuffer}.\n  */\n-public class ByteBufferBackedInputStream extends InputStream\n-{\n-    protected final ByteBuffer _buffer;\n+public class ByteBufferBackedInputStream extends InputStream {\n+    protected final ByteBuffer _b;\n \n-    public ByteBufferBackedInputStream(ByteBuffer buf) {\n-        _buffer = buf;\n-    }\n+    public ByteBufferBackedInputStream(ByteBuffer buf) { _b = buf; }\n+\n+    @Override public int available() { return _b.remaining(); }\n+    \n+    @Override\n+    public int read() throws IOException { return _b.hasRemaining() ? (_b.get() & 0xFF) : -1; }\n \n     @Override\n-    public int available() {\n-        return _buffer.remaining();\n-    }\n-    \n-    @Override\n-    public int read() throws IOException {\n-        return _buffer.hasRemaining() ? (_buffer.get() & 0xFF) : -1;\n-    }\n-\n-    @Override\n-    public int read(byte[] bytes, int off, int len) throws IOException\n-    {\n-        if (!_buffer.hasRemaining()) {\n-            return -1;\n-        }\n-        len = Math.min(len, _buffer.remaining());\n-        _buffer.get(bytes, off, len);\n+    public int read(byte[] bytes, int off, int len) throws IOException {\n+        if (!_b.hasRemaining()) return -1;\n+        len = Math.min(len, _b.remaining());\n+        _b.get(bytes, off, len);\n         return len;\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ByteBufferBackedOutputStream.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ByteBufferBackedOutputStream.java\n  * Simple {@link OutputStream} implementation that appends content\n  * written in given {@link ByteBuffer} instance.\n  */\n-public class ByteBufferBackedOutputStream extends OutputStream\n-{\n-    protected final ByteBuffer _buffer;\n+public class ByteBufferBackedOutputStream extends OutputStream {\n+    protected final ByteBuffer _b;\n \n-    public ByteBufferBackedOutputStream(ByteBuffer buf) {\n-        this._buffer = buf;\n-    }\n+    public ByteBufferBackedOutputStream(ByteBuffer buf) { _b = buf; }\n \n-    @Override\n-    public void write(int b) throws IOException {\n-        _buffer.put((byte) b);\n-    }\n-\n-    @Override\n-    public void write(byte[] bytes, int off, int len) throws IOException {\n-        _buffer.put(bytes, off, len);\n-    }\n+    @Override public void write(int b) throws IOException { _b.put((byte) b); }\n+    @Override public void write(byte[] bytes, int off, int len) throws IOException { _b.put(bytes, off, len); }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n      * @param endBefore Super-type to NOT include in results, if any; when\n      *    encountered, will be ignored (and no super types are checked).\n      */\n-    public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore)\n-    {\n+    public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore) {\n         return findSuperTypes(cls, endBefore, new ArrayList<Class<?>>(8));\n     }\n     \n-    public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result)\n-    {\n+    public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result) {\n         _addSuperTypes(cls, endBefore, result, false);\n         return result;\n     }\n     \n-    private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself)\n-    {\n-        if (cls == endBefore || cls == null || cls == Object.class) {\n-            return;\n-        }\n+    private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself) {\n+        if (cls == endBefore || cls == null || cls == Object.class) { return; }\n         if (addClassItself) {\n             if (result.contains(cls)) { // already added, no need to check supers\n                 return;\n--- a/src/main/java/com/fasterxml/jackson/databind/util/EmptyIterator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/EmptyIterator.java\n  * \n  * @since 2.2 (before, we had embedded instances)\n  */\n-public class EmptyIterator<T> implements Iterator<T>\n-{\n+public class EmptyIterator<T> implements Iterator<T> {\n     private final static EmptyIterator<?> instance = new EmptyIterator<Object>();\n \n-    private EmptyIterator() { }\n-\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> Iterator<T> instance() {\n-        return (Iterator<T>) instance;\n-    }\n+    public static <T> Iterator<T> instance() { return (Iterator<T>) instance; }\n     \n-    @Override\n-    public boolean hasNext() { return false; }\n-    @Override\n-    public T next() { throw new NoSuchElementException(); }\n-\n-    @Override\n-    public void remove() {\n-        throw new UnsupportedOperationException();\n-    }\n+    @Override public boolean hasNext() { return false; }\n+    @Override public T next() { throw new NoSuchElementException(); }\n+    @Override public void remove() { throw new UnsupportedOperationException(); }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java\n  * Helper class used to resolve String values (either JSON Object field\n  * names or regular String values) into Java Enum instances.\n  */\n-public class EnumResolver<T extends Enum<T>>\n-    implements java.io.Serializable\n+public class EnumResolver<T extends Enum<T>> implements java.io.Serializable\n {\n     private static final long serialVersionUID = 1L;\n \n         return constructUsingMethod(enumCls, accessor);\n     }\n     \n-    public T findEnum(String key)\n-    {\n-        return _enumsById.get(key);\n-    }\n+    public T findEnum(String key) { return _enumsById.get(key); }\n \n-    public T getEnum(int index)\n-    {\n+    public T getEnum(int index) {\n         if (index < 0 || index >= _enums.length) {\n             return null;\n         }\n         return _enums[index];\n     }\n \n-    public List<T> getEnums()\n-    {\n+    public List<T> getEnums() {\n         ArrayList<T> enums = new ArrayList<T>(_enums.length);\n         for (T e : _enums) {\n             enums.add(e);\n--- a/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java\n  */\n public final class EnumValues\n {\n-    /**\n-     * @since 2.2\n-     */\n     private final Class<Enum<?>> _enumClass;\n     \n     /**\n         _values = new EnumMap(v);\n     }\n \n-    public static EnumValues construct(Class<Enum<?>> enumClass, AnnotationIntrospector intr)\n-    {\n+    public static EnumValues construct(Class<Enum<?>> enumClass, AnnotationIntrospector intr) {\n         return constructFromName(enumClass, intr);\n     }\n \n         throw new IllegalArgumentException(\"Can not determine enum constants for Class \"+enumClass.getName());\n     }\n \n-    public SerializedString serializedValueFor(Enum<?> key)\n-    {\n-        return _values.get(key);\n-    }\n-    \n-    public Collection<SerializedString> values() {\n-        return _values.values();\n-    }\n+    public SerializedString serializedValueFor(Enum<?> key) { return _values.get(key); }\n+    public Collection<SerializedString> values() { return _values.values(); }\n \n     /**\n-     * Method used for serialization and introspection by core Jackson\n-     * code.\n-     * \n-     * @since 2.1\n+     * Method used for serialization and introspection by core Jackson code.\n      */\n-    public EnumMap<?,SerializedString> internalMap() {\n-        return _values;\n-    }\n+    public EnumMap<?,SerializedString> internalMap() { return _values; }\n \n     /**\n      * @since 2.2\n      */\n-    public Class<Enum<?>> getEnumClass() {\n-        return _enumClass;\n-    }\n-    \n+    public Class<Enum<?>> getEnumClass() { return _enumClass; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601DateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601DateFormat.java\n     }\n \n     @Override\n-    public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition)\n-    {\n+    public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition) {\n         String value = ISO8601Utils.format(date);\n         toAppendTo.append(value);\n         return toAppendTo;\n     }\n \n     @Override\n-    public Date parse(String source, ParsePosition pos)\n-    {\n+    public Date parse(String source, ParsePosition pos) {\n         // index must be set to other than 0, I would swear this requirement is not there in\n         // some version of jdk 6.\n         /* 03-Nov-2013, tatu: I can't see this having any direct effect\n     }\n \n     @Override\n-    public String toString() {\n-        return getClass().getName();\n-    }\n+    public String toString() { return getClass().getName(); }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n     /**\n      * Accessor for static GMT timezone instance.\n      */\n-    public static TimeZone timeZoneGMT() {\n-        return TIMEZONE_GMT;\n-    }\n+    public static TimeZone timeZoneGMT() { return TIMEZONE_GMT; }\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/util/JSONWrappedObject.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/JSONWrappedObject.java\n  * function name and parenthesis are used with JSONP).\n  * \n  * @see com.fasterxml.jackson.databind.util.JSONPObject\n- * \n- * @author tatu\n  */\n-public class JSONWrappedObject\n-    implements JsonSerializable\n+public class JSONWrappedObject implements JsonSerializable\n {\n     /**\n      * Literal String to output before serialized value.\n--- a/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n /**\n  * Helper class for caching resolved root names.\n  */\n-public class RootNameLookup\n-    implements java.io.Serializable\n+public class RootNameLookup implements java.io.Serializable\n {\n     private static final long serialVersionUID = 1L;\n \n \n     public RootNameLookup() { }\n \n-    public SerializedString findRootName(JavaType rootType, MapperConfig<?> config)\n-    {\n+    public SerializedString findRootName(JavaType rootType, MapperConfig<?> config) {\n         return findRootName(rootType.getRawClass(), config);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n      */\n \n     @Override\n-    public boolean hasGetter() {\n-        return (getGetter() != null);\n-    }\n-\n-    @Override\n-    public boolean hasSetter() {\n-        return (getSetter() != null);\n-    }\n-\n-    @Override\n-    public boolean hasField() {\n-        return (_member instanceof AnnotatedField);\n-    }\n-\n-    @Override\n-    public boolean hasConstructorParameter() {\n-        return (_member instanceof AnnotatedParameter);\n-    }\n+    public boolean hasGetter() { return (getGetter() != null); }\n+\n+    @Override\n+    public boolean hasSetter() { return (getSetter() != null); }\n+\n+    @Override\n+    public boolean hasField() { return (_member instanceof AnnotatedField); }\n+\n+    @Override\n+    public boolean hasConstructorParameter() { return (_member instanceof AnnotatedParameter); }\n     \n     @Override\n     public AnnotatedMethod getGetter() {\n \n     @Override\n     public AnnotatedField getField() {\n-        return (_member instanceof AnnotatedField) ?\n-                (AnnotatedField) _member : null;\n+        return (_member instanceof AnnotatedField) ? (AnnotatedField) _member : null;\n     }\n \n     @Override\n     public AnnotatedParameter getConstructorParameter() {\n-        return (_member instanceof AnnotatedParameter) ?\n-                (AnnotatedParameter) _member : null;\n+        return (_member instanceof AnnotatedParameter) ? (AnnotatedParameter) _member : null;\n     }\n \n     /**\n     }\n \n     @Override\n-    public AnnotatedMember getPrimaryMember() {\n-        return _member;\n-    }\n+    public AnnotatedMember getPrimaryMember() { return _member; }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/StdConverter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdConverter.java\n     /* Partial Converter API implementation\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public abstract OUT convert(IN value);\n \n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n     /**\n      * Offset within last segment, \n      */\n-    protected int _appendOffset;\n+    protected int _appendAt;\n \n     /**\n      * If native type ids supported, this is the id for following\n         _writeContext = JsonWriteContext.createRootContext(null);\n         // at first we have just one segment\n         _first = _last = new Segment();\n-        _appendOffset = 0;\n+        _appendAt = 0;\n         _hasNativeTypeIds = hasNativeIds;\n         _hasNativeObjectIds = hasNativeIds;\n \n         _writeContext = JsonWriteContext.createRootContext(null);\n         // at first we have just one segment\n         _first = _last = new Segment();\n-        _appendOffset = 0;\n+        _appendAt = 0;\n         _hasNativeTypeIds = jp.canReadTypeId();\n         _hasNativeObjectIds = jp.canReadObjectId();\n         _mayHaveNativeIds = _hasNativeTypeIds | _hasNativeObjectIds;\n \n     private final void _appendNativeIds(StringBuilder sb)\n     {\n-        Object objectId = _last.findObjectId(_appendOffset-1);\n+        Object objectId = _last.findObjectId(_appendAt-1);\n         if (objectId != null) {\n             sb.append(\"[objectId=\").append(String.valueOf(objectId)).append(']');\n         }\n-        Object typeId = _last.findTypeId(_appendOffset-1);\n+        Object typeId = _last.findTypeId(_appendAt-1);\n         if (typeId != null) {\n             sb.append(\"[typeId=\").append(String.valueOf(typeId)).append(']');\n         }\n     protected final void _append(JsonToken type)\n     {\n         Segment next = _hasNativeId\n-                ? _last.append(_appendOffset, type, _objectId, _typeId)\n-                : _last.append(_appendOffset, type);\n+                ? _last.append(_appendAt, type, _objectId, _typeId)\n+                : _last.append(_appendAt, type);\n         if (next == null) {\n-            ++_appendOffset;\n+            ++_appendAt;\n         } else {\n             _last = next;\n-            _appendOffset = 1; // since we added first at 0\n+            _appendAt = 1; // since we added first at 0\n         }\n     }\n \n     protected final void _append(JsonToken type, Object value)\n     {\n         Segment next = _hasNativeId\n-                ? _last.append(_appendOffset, type, value, _objectId, _typeId)\n-                : _last.append(_appendOffset, type, value);\n+                ? _last.append(_appendAt, type, value, _objectId, _typeId)\n+                : _last.append(_appendAt, type, value);\n         if (next == null) {\n-            ++_appendOffset;\n+            ++_appendAt;\n         } else {\n             _last = next;\n-            _appendOffset = 1;\n+            _appendAt = 1;\n         }\n     }\n \n     protected final void _appendRaw(int rawType, Object value)\n     {\n         Segment next = _hasNativeId\n-                ? _last.appendRaw(_appendOffset, rawType, value, _objectId, _typeId)\n-                : _last.appendRaw(_appendOffset, rawType, value);\n+                ? _last.appendRaw(_appendAt, rawType, value, _objectId, _typeId)\n+                : _last.appendRaw(_appendAt, rawType, value);\n         if (next == null) {\n-            ++_appendOffset;\n+            ++_appendAt;\n         } else {\n             _last = next;\n-            _appendOffset = 1;\n+            _appendAt = 1;\n         }\n     }\n \n             _tokenTypes |= typeCode;\n         }\n \n-        private void set(int index, int rawTokenType, Object value,\n-                Object objectId, Object typeId)\n+        private void set(int index, int rawTokenType, Object value, Object objectId, Object typeId)\n         {\n             _tokens[index] = value;\n             long typeCode = (long) rawTokenType;\n             assignNativeIds(index, objectId, typeId);\n         }\n \n-        private final void assignNativeIds(int index,\n-                Object objectId, Object typeId)\n+        private final void assignNativeIds(int index, Object objectId, Object typeId)\n         {\n             if (_nativeIds == null) {\n                 _nativeIds = new TreeMap<Integer,Object>();\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ViewMatcher.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ViewMatcher.java\n  * Helper class used for checking whether a property is visible\n  * in the active view\n  */\n-public abstract class ViewMatcher\n+public class ViewMatcher implements java.io.Serializable\n {\n-    public abstract boolean isVisibleForView(Class<?> activeView);\n+    private static final long serialVersionUID = 1L;\n+\n+    protected final static ViewMatcher EMPTY = new ViewMatcher();\n+    \n+    public boolean isVisibleForView(Class<?> activeView) { return false; }\n \n     public static ViewMatcher construct(Class<?>[] views)\n     {\n         if (views == null) {\n-            return Empty.instance;\n+            return EMPTY;\n         }\n         switch (views.length) {\n         case 0:\n-            return Empty.instance;\n+            return EMPTY;\n         case 1:\n             return new Single(views[0]);\n         }\n     /**********************************************************\n      */\n \n-    private final static class Empty extends ViewMatcher\n-        implements java.io.Serializable\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        final static Empty instance = new Empty();\n-        @Override\n-        public boolean isVisibleForView(Class<?> activeView) {\n-            return false;\n-        }\n-    }\n-\n     private final static class Single extends ViewMatcher\n-        implements java.io.Serializable\n     {\n         private static final long serialVersionUID = 1L;\n ", "timestamp": 1388729245, "metainfo": ""}