{"sha": "6f5cf623ba7a3e7a9e27917955ab388e35769687", "log": "Further work on general-purpose virtual properties (not quite complete yet)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonAppend.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonAppend.java\n      * Set of general virtual properties to include when serializing a POJO.\n      */\n     public Prop[] props() default { };\n+\n+    /**\n+     * Indicator used to determine whether properties defined are to be\n+     * appended before (false) or prepended before (true) regular properties.\n+     * Affects all kinds of properties defined using this annotation.\n+     */\n+    public boolean prepend() default false;\n     \n     /**\n      * Definition of a single attribute-backed property.\n          * assigning a value for {@link #propName()}.\n          */\n         public String value();\n-        \n+\n         /**\n          * Name to use for serializing value of the attribute; if not defined,\n          * {@link #value} will be used instead.\n      */\n     public @interface Prop\n     {\n+        /**\n+         * Actual implementation class (a subtype of {@link VirtualBeanPropertyWriter})\n+         * of the property to instantiate (using the no-argument default constructor).\n+         */\n         public Class<? extends VirtualBeanPropertyWriter> value();\n+\n+        /**\n+         * Name of the property to possibly use for serializing (although implementation\n+         * may choose to not use this information).\n+         */\n+        public String name() default \"\";\n+\n+        /**\n+         * Optional namespace to use along with {@link #name};\n+         * only relevant for data formats that use namespaces (like XML).\n+         */\n+        public String namespace() default \"\";\n+\n+        /**\n+         * When to include  value of the property. Default value indicates that\n+         * property should only be written if specified attribute has a non-null\n+         * value. As with other properties, actual property implementation may or may\n+         * not choose to use this inclusion information.\n+         */\n+        public JsonInclude.Include include() default JsonInclude.Include.NON_NULL;\n+\n+        /**\n+         * Metadata about property, similar to\n+         * {@link com.fasterxml.jackson.annotation.JsonProperty#required()}.\n+         */\n+        public boolean required() default false;\n+\n+        /**\n+         * Nominal type of the property. Passed as type information for related\n+         * virtual objects, and may (or may not be) used by implementation\n+         * for choosing serializer to use.\n+         */\n+        public Class<?> type() default Object.class;\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/NoClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/NoClass.java\n  * as either default or explicit values. Hence for class values we must\n  * explicitly use a bogus placeholder to denote equivalent of\n  * \"no class\" (for which 'null' is usually the natural choice).\n- * \n- * @deprecated Since 2.4 use {@link java.lang.Void} instead as the general\n- *   \"no class specified\" marker.\n+ *<p>\n+ * Note that since 2.4, most (but not all!\n+ * {@link com.fasterxml.jackson.annotation.JsonTypeInfo#defaultImpl} is\n+ * a notable exception}) usage should start using\n+ * {@link java.lang.Void} instead as the \"not defined\" marker.\n  */\n-@Deprecated\n public final class NoClass\n {\n     private NoClass() { }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/HandlerInstantiator.java\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.Converter;\n \n /**\n         return null;\n     }\n \n-    public ObjectIdResolver resolverIdGeneratorInstance(MapperConfig<?> config, Annotated annotated, Class<?> implClass)\n-    {\n+    public ObjectIdResolver resolverIdGeneratorInstance(MapperConfig<?> config, Annotated annotated, Class<?> implClass) {\n         return null;\n     }\n \n         return null;\n     }\n \n+    /**\n+     * Method called to construct a {@link VirtualBeanPropertyWriter} instance\n+     * of specified type.\n+     *\n+     * @since 2.5\n+     */\n+    public VirtualBeanPropertyWriter virtualPropertyWriterInstance(MapperConfig<?> config,\n+            Class<?> implClass) {\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n import com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter;\n import com.fasterxml.jackson.databind.ser.std.RawSerializer;\n import com.fasterxml.jackson.databind.util.*;\n      * are considered bundles.\n      */\n     @Override\n-    public boolean isAnnotationBundle(Annotation ann)\n-    {\n+    public boolean isAnnotationBundle(Annotation ann) {\n         return ann.annotationType().getAnnotation(JacksonAnnotationsInside.class) != null;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* General annotations\n \n     // default impl is fine:\n     //public String findEnumValue(Enum<?> value) { return value.name(); }\n-    \n+\n     /*\n     /**********************************************************\n     /* General class annotations\n         if (ann == null) {\n             return;\n         }\n+        final boolean prepend = ann.prepend();\n         JavaType propType = null;\n-        for (JsonAppend.Attr attr : ann.attrs()) {\n-            PropertyMetadata metadata = attr.required() ?\n-                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n-            // could add Index, Description in future, if those matter\n-            String attrName = attr.value();\n-\n-            // allow explicit renaming; if none, default to attribute name\n-            PropertyName propName = _propertyName(attr.propName(), attr.propNamespace());\n-            if (!propName.hasSimpleName()) {\n-                propName = new PropertyName(attrName);\n-            }\n-            // should there be a way to specify expected type?\n+\n+        // First: any attribute-backed properties?\n+        JsonAppend.Attr[] attrs = ann.attrs();\n+        for (int i = 0, len = attrs.length; i < len; ++i) {\n             if (propType == null) {\n                 propType = config.constructType(Object.class);\n             }\n-            // now, then, we need a placeholder for member (no real Field/Method):\n-            AnnotatedMember member = new VirtualAnnotatedMember(ac.getRawType(),\n-                    attrName, propType.getRawClass());\n-            // and with that and property definition\n-            SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n-                    member, propName, metadata, attr.include());\n-            // can construct the property writer\n-            properties.add(AttributePropertyWriter.construct(attrName, propDef,\n-                    ac.getAnnotations(), propType));\n-        }\n+            BeanPropertyWriter bpw = _constructVirtualProperty(attrs[i],\n+                    config, ac, propType);\n+            if (prepend) {\n+                properties.add(i, bpw);\n+            } else {\n+                properties.add(bpw);\n+            }\n+        }\n+\n+        // Then: general-purpose virtual properties?\n+        JsonAppend.Prop[] props = ann.props();\n+        for (int i = 0, len = props.length; i < len; ++i) {\n+            BeanPropertyWriter bpw = _constructVirtualProperty(props[i],\n+                    config, ac);\n+            if (prepend) {\n+                properties.add(i, bpw);\n+            } else {\n+                properties.add(bpw);\n+            }\n+        }\n+    }\n+\n+    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Attr attr,\n+            MapperConfig<?> config, AnnotatedClass ac, JavaType type)\n+    {\n+        PropertyMetadata metadata = attr.required() ?\n+                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n+        // could add Index, Description in future, if those matter\n+        String attrName = attr.value();\n+\n+        // allow explicit renaming; if none, default to attribute name\n+        PropertyName propName = _propertyName(attr.propName(), attr.propNamespace());\n+        if (!propName.hasSimpleName()) {\n+            propName = new PropertyName(attrName);\n+        }\n+        // now, then, we need a placeholder for member (no real Field/Method):\n+        AnnotatedMember member = new VirtualAnnotatedMember(ac.getRawType(),\n+                attrName, type.getRawClass());\n+        // and with that and property definition\n+        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n+                member, propName, metadata, attr.include());\n+        // can construct the property writer\n+        return AttributePropertyWriter.construct(attrName, propDef,\n+                ac.getAnnotations(), type);\n+    }\n+\n+    protected BeanPropertyWriter _constructVirtualProperty(JsonAppend.Prop prop,\n+            MapperConfig<?> config, AnnotatedClass ac)\n+    {\n+        PropertyMetadata metadata = prop.required() ?\n+                    PropertyMetadata.STD_REQUIRED : PropertyMetadata.STD_OPTIONAL;\n+        PropertyName propName = _propertyName(prop.name(), prop.namespace());\n+        JavaType type = config.constructType(prop.type());\n+        // now, then, we need a placeholder for member (no real Field/Method):\n+        AnnotatedMember member = new VirtualAnnotatedMember(ac.getRawType(),\n+                propName.getSimpleName(), type.getRawClass());\n+        // and with that and property definition\n+        SimpleBeanPropertyDefinition propDef = SimpleBeanPropertyDefinition.construct(config,\n+                member, propName, metadata, prop.include());\n+\n+        Class<?> implClass = prop.value();\n+\n+        HandlerInstantiator hi = config.getHandlerInstantiator();\n+        VirtualBeanPropertyWriter bpw = (hi == null) ? null\n+                : hi.virtualPropertyWriterInstance(config, implClass);\n+        if (bpw == null) {\n+            bpw = (VirtualBeanPropertyWriter) ClassUtil.createInstance(implClass,\n+                    config.canOverrideAccessModifiers());\n+        }\n+\n+        // one more thing: give it necessary contextual information\n+        return bpw.withConfig(config, ac, propDef, type);\n     }\n \n     /*\n         b = b.inclusion(inclusion);\n         b = b.typeProperty(info.property());\n         Class<?> defaultImpl = info.defaultImpl();\n-        if (defaultImpl != JsonTypeInfo.None.class) {\n+        if (defaultImpl != Void.class && defaultImpl != JsonTypeInfo.None.class) {\n             b = b.defaultImpl(defaultImpl);\n         }\n         b = b.typeIdVisibility(info.visible());\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n \n     /**\n      * Method that will apply by-type limitations (as per [JACKSON-429]);\n-     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType} annotation but\n-     * can be supplied by module-provided introspectors too.\n+     * by default this is based on {@link com.fasterxml.jackson.annotation.JsonIgnoreType}\n+     * annotation but can be supplied by module-provided introspectors too.\n      */\n     protected void removeIgnorableTypes(SerializationConfig config, BeanDescription beanDesc,\n             List<BeanPropertyDefinition> properties)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/VirtualBeanPropertyWriter.java\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n \n     /*\n     /**********************************************************\n+    /* Abstract methods for sub-classes to define\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to figure out the value to serialize. For simple sub-types\n+     * (such as {@link com.fasterxml.jackson.databind.ser.impl.AttributePropertyWriter})\n+     * this may be one of few methods to define, although more advanced implementations\n+     * may choose to not even use this method (by overriding {@link #serializeAsField})\n+     * and define a bogus implementation.\n+     */\n+    protected abstract Object value(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception;\n+\n+    /**\n+     * Contextualization method called on a newly constructed virtual bean property.\n+     * If information is used to change behavior, it is recommended that a new instance\n+     * is constructed with given information and returned; however, this is not mandatory\n+     * and modifying (and returning) this instance is legal as well as calls are made\n+     * in thread-safe manner.\n+     *\n+     * @param config Currenct configuration; guaranteed to be {@link SerializationConfig}\n+     *   (but not typed since caller does not have full typing)\n+     * @param declaringClass Class that contains this property writer\n+     * @param propDef Nominal property definition to use\n+     * @param type Declared type for the property\n+     */\n+    public abstract VirtualBeanPropertyWriter withConfig(MapperConfig<?> config,\n+            AnnotatedClass declaringClass, BeanPropertyDefinition propDef, JavaType type);\n+\n+    /*\n+    /**********************************************************\n     /* PropertyWriter serialization method overrides\n     /**********************************************************\n      */\n-\n-    /**\n-     * Method called to \n-     */\n-    protected abstract Object value(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception;\n     \n     @Override\n     public void serializeAsField(Object bean, JsonGenerator gen, SerializerProvider prov) throws Exception\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/AttributePropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/AttributePropertyWriter.java\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n import com.fasterxml.jackson.databind.ser.VirtualBeanPropertyWriter;\n import com.fasterxml.jackson.databind.util.Annotations;\n         super(base);\n         _attrName = base._attrName;\n     }\n+\n+    /**\n+     * Since this method should typically not be called on this sub-type,\n+     * default implementation simply throws an {@link IllegalStateException}.\n+     */\n+    @Override\n+    public VirtualBeanPropertyWriter withConfig(MapperConfig<?> config,\n+            AnnotatedClass declaringClass, BeanPropertyDefinition propDef, JavaType type) {\n+        throw new IllegalStateException(\"Should not be called on this type\");\n+    }\n     \n     /*\n     /**********************************************************\n      */\n     \n     @Override\n-    protected Object value(Object bean, JsonGenerator jgen, SerializerProvider prov)\n-        throws Exception\n-    {\n+    protected Object value(Object bean, JsonGenerator jgen, SerializerProvider prov) throws Exception {\n         return prov.getAttribute(_attrName);\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractContainers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractContainers.java\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testAbstractLists() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         ListWrapper w = new ListWrapper();\n         w.list.add(\"x\");\n \n-        String json = mapper.writeValueAsString(w);\n-        Object o = mapper.readValue(json, ListWrapper.class);\n+        String json = MAPPER.writeValueAsString(w);\n+        Object o = MAPPER.readValue(json, ListWrapper.class);\n         assertEquals(ListWrapper.class, o.getClass());\n         ListWrapper out = (ListWrapper) o;\n+        assertNotNull(out.list);\n         assertEquals(1, out.list.size());\n         assertEquals(\"x\", out.list.get(0));\n    }\n     \n     public void testAbstractMaps() throws Exception\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         MapWrapper w = new MapWrapper();\n         w.map.put(\"key1\", \"name1\");\n \n-        String json = mapper.writeValueAsString(w);\n-        Object o = mapper.readValue(json, MapWrapper.class);\n+        String json = MAPPER.writeValueAsString(w);\n+        Object o = MAPPER.readValue(json, MapWrapper.class);\n         assertEquals(MapWrapper.class, o.getClass());\n         MapWrapper out = (MapWrapper) o;\n         assertEquals(1, out.map.size());\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPolymorphicWithDefaultImpl.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationFeature;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+\n+/**\n+ * Unit tests related to specialized handling of \"default implementation\"\n+ * ({@link JsonTypeInfo#defaultImpl()}), as well as related\n+ * cases that allow non-default settings (such as missing type id).\n+ */\n+public class TestPolymorphicWithDefaultImpl extends BaseMapTest\n+{\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\", defaultImpl = LegacyInter.class)\n+    @JsonSubTypes(value = {@JsonSubTypes.Type(name = \"mine\", value = MyInter.class)})\n+    public static interface Inter { }\n+\n+    public static class MyInter implements Inter {\n+        @JsonProperty(\"blah\") public List<String> blah;\n+    }\n+\n+    public static class LegacyInter extends MyInter\n+    {\n+        @JsonCreator\n+        LegacyInter(Object obj)\n+        {\n+            if (obj instanceof List) {\n+                blah = new ArrayList<String>();\n+                for (Object o : (List<?>) obj) {\n+                    blah.add(o.toString());\n+                }\n+            }\n+            else if (obj instanceof String) {\n+                blah = Arrays.asList(((String) obj).split(\",\"));\n+            }\n+            else {\n+                throw new IllegalArgumentException(\"Unknown type: \" + obj.getClass());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Note: <code>NoClass</code> here has special meaning, of mapping invalid\n+     * types into null instances.\n+     */\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\",\n+            defaultImpl = NoClass.class)\n+    public static class DefaultWithNoClass { }\n+\n+    // and then one with no defaultImpl nor listed subtypes\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = \"type\")\n+    abstract static class MysteryPolymorphic { }\n+\n+    // [Databind#511] types\n+\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.WRAPPER_OBJECT)\n+    @JsonSubTypes(@JsonSubTypes.Type(name=\"sub1\", value = BadSub1.class))\n+    public static class BadItem {}\n+\n+    public static class BadSub1 extends BadItem {\n+        public String a ;\n+    }\n+\n+    public static class Good {\n+        public List<GoodItem> many;\n+    }\n+\n+    public static class Bad {\n+        public List<BadItem> many;\n+    }\n+ \n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.WRAPPER_OBJECT)\n+    @JsonSubTypes({@JsonSubTypes.Type(name=\"sub1\", value = GoodSub1.class),\n+            @JsonSubTypes.Type(name=\"sub2\", value = GoodSub2.class) })\n+    public static class GoodItem {}\n+\n+    public static class GoodSub1 extends GoodItem {\n+        public String a ;\n+    }\n+    public static class GoodSub2 extends GoodItem {\n+        public String b ;\n+\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests, deserialization\n+    /**********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testDeserializationWithObject() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"{\\\"type\\\": \\\"mine\\\", \\\"blah\\\": [\\\"a\\\", \\\"b\\\", \\\"c\\\"]}\");\n+        assertTrue(inter instanceof MyInter);\n+        assertFalse(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\"), ((MyInter) inter).blah);\n+    }\n+\n+    public void testDeserializationWithString() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"\\\"a,b,c,d\\\"\");\n+        assertTrue(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\"), ((MyInter) inter).blah);\n+    }\n+\n+    public void testDeserializationWithArray() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"[\\\"a\\\", \\\"b\\\", \\\"c\\\", \\\"d\\\"]\");\n+        assertTrue(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\", \"c\", \"d\"), ((MyInter) inter).blah);\n+    }\n+\n+    public void testDeserializationWithArrayOfSize2() throws Exception\n+    {\n+        Inter inter = MAPPER.reader(Inter.class).readValue(\"[\\\"a\\\", \\\"b\\\"]\");\n+        assertTrue(inter instanceof LegacyInter);\n+        assertEquals(Arrays.asList(\"a\", \"b\"), ((MyInter) inter).blah);\n+    }\n+\n+    // [Databind#148]\n+    public void testDefaultAsNoClass() throws Exception\n+    {\n+        Object ob = MAPPER.reader(DefaultWithNoClass.class).readValue(\"{ }\");\n+        assertNull(ob);\n+        ob = MAPPER.reader(DefaultWithNoClass.class).readValue(\"{ \\\"bogus\\\":3 }\");\n+        assertNull(ob);\n+    }\n+\n+    // [Databind#148]\n+    public void testBadTypeAsNull() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.disable(DeserializationFeature.FAIL_ON_INVALID_SUBTYPE);\n+        Object ob = mapper.readValue(\"{}\", MysteryPolymorphic.class);\n+        assertNull(ob);\n+        ob = mapper.readValue(\"{ \\\"whatever\\\":13}\", MysteryPolymorphic.class);\n+        assertNull(ob);\n+    }\n+\n+    // [Databind#511]\n+    public void testInvalidTypeId511() throws Exception {\n+        ObjectReader reader = MAPPER.reader().without(\n+                DeserializationFeature.FAIL_ON_INVALID_SUBTYPE,\n+                DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES,\n+                DeserializationFeature.FAIL_ON_IGNORED_PROPERTIES\n+        );\n+        String json = \"{\\\"many\\\":[{\\\"sub1\\\":{\\\"a\\\":\\\"foo\\\"}},{\\\"sub2\\\":{\\\"b\\\":\\\"bar\\\"}}]}\" ;\n+        Good goodResult = reader.forType(Good.class).readValue(json) ;\n+        assertNotNull(goodResult) ;\n+        Bad badResult = reader.forType(Bad.class).readValue(json);\n+        assertNotNull(badResult);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests, serialization\n+    /**********************************************************\n+     */\n+\n+    /*\n+    public void testDontWriteIfDefaultImpl() throws Exception {\n+        String json = MAPPER.writeValueAsString(new MyInter());\n+        assertEquals(\"{\\\"blah\\\":null}\", json);\n+    }\n+    */\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestVirtualProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestVirtualProperties.java\n         public int value = 13;\n     }\n \n+    @JsonAppend(prepend=true, attrs={ @JsonAppend.Attr(\"id\"),\n+            @JsonAppend.Attr(value=\"internal\", propName=\"extra\")\n+        })\n+        static class SimpleBeanPrepend\n+        {\n+            public int value = 13;\n+        }\n+\n     enum ABC {\n         A, B, C;\n     }\n         Map<String,Object> stuff = new LinkedHashMap<String,Object>();\n         stuff.put(\"x\", 3);\n         stuff.put(\"y\", ABC.B);\n+\n         String json = WRITER.withAttribute(\"id\", \"abc123\")\n                 .withAttribute(\"internal\", stuff)\n                 .writeValueAsString(new SimpleBean());\n         assertEquals(aposToQuotes(\"{'value':13,'id':'abc123','extra':{'x':3,'y':'B'}}\"), json);\n+\n+        json = WRITER.withAttribute(\"id\", \"abc123\")\n+                .withAttribute(\"internal\", stuff)\n+                .writeValueAsString(new SimpleBeanPrepend());\n+        assertEquals(aposToQuotes(\"{'id':'abc123','extra':{'x':3,'y':'B'},'value':13}\"), json);\n     }\n \n     public void testAttributePropInclusion() throws Exception", "timestamp": 1418022709, "metainfo": ""}