{"sha": "8c7f3cdf92a7479699a92505bcd0379874abb10b", "log": "Further improve caching, so that all kinds of collection deserializer are cached, as well as \"untyped\" (Object) and JsonNode deserializers.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n     /**\n      * We will also cache some dynamically constructed deserializers;\n      * specifically, ones that are expensive to construct.\n-     * This currently means bean and Enum deserializers; array, List and Map\n-     * deserializers will not be cached.\n+     * This currently means bean and Enum deserializers; starting with\n+     * 2.5, container deserializers will also be cached.\n      *<p>\n      * Given that we don't expect much concurrency for additions\n      * (should very quickly converge to zero after startup), let's\n-     * explicitly define a low concurrency setting.\n+     * define a relatively low concurrency setting.\n      */\n     final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers\n-        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 2);\n+        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 4);\n \n     /**\n      * During deserializer construction process we may need to keep track of partially\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n     /* Overrides\n     /**********************************************************\n      */\n+\n+    /**\n+     * Turns out that these are expensive enough to create so that caching\n+     * does make sense (in addition to Bean, Enum deserializers).\n+     * \n+     * @since 2.5\n+     */\n+    @Override\n+    public boolean isCachable() { return true; }\n \n     @Override\n     public SettableBeanProperty findBackReference(String refName) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n     public BaseNodeDeserializer(Class<T> vc) {\n         super(vc);\n     }\n-    \n+\n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n         return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n     }\n \n+    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes\n+     *   sense to also mark this is cachable, since lookup not exactly free, and\n+     *   since it's not uncommon to \"read anything\"\n+     */\n+    @Override\n+    public boolean isCachable() { return true; }\n+\n     /*\n     /**********************************************************\n     /* Overridable methods\n     /**********************************************************\n      */\n-    \n+\n     protected void _reportProblem(JsonParser jp, String msg) throws JsonMappingException {\n         throw new JsonMappingException(msg, jp.getTokenLocation());\n     }\n-    \n+\n     /**\n      * \n      * @deprecated Since 2.3, use the overloaded variant\n         // Backwards-compatibility; call in case it's overloaded\n         _handleDuplicateField(fieldName, objectNode, oldValue, newValue);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Helper methods\n     /**********************************************************\n      */\n-    \n+\n     protected final ObjectNode deserializeObject(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)            \n-        throws IOException, JsonProcessingException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         ObjectNode node = nodeFactory.objectNode();\n         JsonToken t = jp.getCurrentToken();\n         }\n         return node;\n     }\n-    \n+\n     protected final ArrayNode deserializeArray(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)            \n-        throws IOException, JsonProcessingException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         ArrayNode node = nodeFactory.arrayNode();\n         while (true) {\n             }\n         }\n     }\n-    \n+\n     protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)            \n-        throws IOException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         switch (jp.getCurrentTokenId()) {\n         case JsonTokenId.ID_START_OBJECT:\n     }\n \n     protected final JsonNode _fromInt(JsonParser jp, DeserializationContext ctxt,\n-            JsonNodeFactory nodeFactory)\n-        throws IOException\n+            JsonNodeFactory nodeFactory) throws IOException\n     {\n         JsonParser.NumberType nt = jp.getNumberType();\n         if (nt == JsonParser.NumberType.BIG_INTEGER\n     }\n \n     protected final JsonNode _fromFloat(JsonParser jp, DeserializationContext ctxt,\n-            final JsonNodeFactory nodeFactory)\n-        throws IOException\n+            final JsonNodeFactory nodeFactory) throws IOException\n     {\n         JsonParser.NumberType nt = jp.getNumberType();\n         if (nt == JsonParser.NumberType.BIG_DECIMAL\n     }\n \n     protected final JsonNode _fromEmbedded(JsonParser jp, DeserializationContext ctxt,\n-            JsonNodeFactory nodeFactory)\n-        throws IOException\n+            JsonNodeFactory nodeFactory) throws IOException\n     {\n         // [JACKSON-796]\n         Object ob = jp.getEmbeddedObject();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n     /**********************************************************\n      */\n \n-    /**\n-     * Turns out that these are expensive enough to create so that caching\n-     * does make sense.\n-     * \n-     * @since 2.4.4\n-     */\n-    @Override\n-    public boolean isCachable() { return true; }\n-\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n             }\n         }\n     }\n-    \n+\n     @SuppressWarnings(\"unchecked\") \n     public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n      * object associated with {@link #_id} comes before the values in\n      * {@link _next}.\n      */\n-    private final static class MapReferring extends Referring {\n+    final static class MapReferring extends Referring {\n         private final MapReferringAccumulator _parent;\n \n         public final Map<Object, Object> next = new LinkedHashMap<Object, Object>();\n         public final Object key;\n         \n-        private MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n+        MapReferring(MapReferringAccumulator parent, UnresolvedForwardReference ref,\n                 Class<?> valueType, Object key)\n         {\n             super(ref, valueType);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.DeserializationFeature;\n     /* Deserializer API\n     /**********************************************************\n      */\n+\n+    /* 07-Nov-2014, tatu: When investigating [databind#604], realized that it makes\n+     *   sense to also mark this is cachable, since lookup not exactly free, and\n+     *   since it's not uncommon to \"read anything\"\n+     */\n+    @Override\n+    public boolean isCachable() { return true; }\n     \n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n package com.fasterxml.jackson.databind;\n \n import java.io.*;\n+import java.util.*;\n \n import com.fasterxml.jackson.core.JsonFactory;\n import com.fasterxml.jackson.core.JsonParser;\n-\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\n import com.fasterxml.jackson.databind.node.*;\n     public void testProviderConfig() throws Exception   \n     {\n         ObjectMapper m = new ObjectMapper();\n+        final String JSON = \"{ \\\"x\\\" : 3 }\";\n \n         assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n         // and then should get one constructed for:\n-        Bean bean = m.readValue(\"{ \\\"x\\\" : 3 }\", Bean.class);\n+        Bean bean = m.readValue(JSON, Bean.class);\n         assertNotNull(bean);\n         assertEquals(1, m._deserializationContext._cache.cachedDeserializersCount());\n         m._deserializationContext._cache.flushCachedDeserializers();\n         assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n+\n+        // 07-Nov-2014, tatu: As per [databind#604] verify that Maps also get cached\n+        m = new ObjectMapper();\n+        List<?> stuff = m.readValue(\"[ ]\", List.class);\n+        assertNotNull(stuff);\n+        // may look odd, but due to \"Untyped\" deserializer thing, we actually have\n+        // 3 deserializers (List<?>, Map<?,?>, Object)\n+        assertEquals(3, m._deserializationContext._cache.cachedDeserializersCount());\n     }\n     \n     // [Issue#28]: ObjectMapper.copy()", "timestamp": 1415409211, "metainfo": ""}