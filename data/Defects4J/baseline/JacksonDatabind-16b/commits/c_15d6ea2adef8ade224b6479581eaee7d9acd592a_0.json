{"sha": "15d6ea2adef8ade224b6479581eaee7d9acd592a", "log": "Implemented [Issue#25] (enums as JSON Object); started implementation of [Issue#40] (Collections as JSON Objects)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n     {\n         return new BasicBeanDescription(config, type,\n                 ac, Collections.<BeanPropertyDefinition>emptyList());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Limited modifications by core databind functionality\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to prune unwanted properties, during\n+     * construction of serializers and deserializers.\n+     * Use with utmost care, if at all...\n+     * \n+     * @since 2.1\n+     */\n+    public boolean removeProperty(String propName)\n+    {\n+        Iterator<BeanPropertyDefinition> it = _properties.iterator();\n+        while (it.hasNext()) {\n+            BeanPropertyDefinition prop = it.next();\n+            if (prop.getName().equals(propName)) {\n+                it.remove();\n+                return true;\n+            }\n+        }\n+        return false;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import java.net.InetAddress;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n         }\n         return b.buildTypeSerializer(config, baseType, subtypes);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Additional API for other core classes\n             return NumberSerializers.NumberSerializer.instance;\n         }\n         if (Enum.class.isAssignableFrom(raw)) {\n-            @SuppressWarnings(\"unchecked\")\n-            Class<Enum<?>> enumClass = (Class<Enum<?>>) raw;\n-            return EnumSerializer.construct(enumClass, prov.getConfig(), beanDesc);\n+            /* As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n+             * Challenge here is that EnumSerializer does not know how to produce\n+             * POJO style serialization, so we must handle that special case separately;\n+             * otherwise pass it to EnumSerializer.\n+             */\n+            JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n+            if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n+                // one special case: suppress serialization of \"getDeclaringClass()\"...\n+                ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\");\n+            } else {\n+                @SuppressWarnings(\"unchecked\")\n+                Class<Enum<?>> enumClass = (Class<Enum<?>>) raw;\n+                return EnumSerializer.construct(enumClass, prov.getConfig(), beanDesc, format);\n+            }\n         }\n         if (Calendar.class.isAssignableFrom(raw)) {\n             return CalendarSerializer.instance;\n         if (type.isCollectionLikeType()) {\n             CollectionLikeType clt = (CollectionLikeType) type;\n             if (clt.isTrueCollectionType()) { // only have custom ones, if any:\n-                return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, property, staticTyping,\n-                        elementTypeSerializer, elementValueSerializer);\n-            }\n-            // Only custom variants for this:\n-            for (Serializers serializers : customSerializers()) {\n-                JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config,\n-                        (CollectionLikeType) type, beanDesc, elementTypeSerializer, elementValueSerializer);\n-                if (ser != null) {\n-                    return ser;\n-                }\n-            }\n-            return null;\n+                CollectionType trueCT = (CollectionType) clt;\n+                // Module-provided custom collection serializers?\n+                for (Serializers serializers : customSerializers()) {\n+                    JsonSerializer<?> ser = serializers.findCollectionSerializer(config,\n+                            trueCT, beanDesc, elementTypeSerializer, elementValueSerializer);\n+                    if (ser != null) {\n+                        return ser;\n+                    }\n+                }\n+\n+                // As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n+                // Challenge here is that EnumSerializer does not know how to produce\n+                // POJO style serialization, so we must handle that special case separately;\n+                // otherwise pass it to EnumSerializer.\n+                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n+\n+                if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) {\n+                    return buildCollectionSerializer(config, trueCT, beanDesc, property, staticTyping,\n+                            elementTypeSerializer, elementValueSerializer);\n+                }\n+            } else {\n+                // Only custom variants for this:\n+                for (Serializers serializers : customSerializers()) {\n+                    JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config,\n+                            (CollectionLikeType) type, beanDesc, elementTypeSerializer, elementValueSerializer);\n+                    if (ser != null) {\n+                        return ser;\n+                    }\n+                }\n+                // fall through either way (whether shape dictates serialization as POJO or not)\n+                return null;\n+            }\n         }\n         if (type.isArrayType()) {\n             return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n         throws JsonMappingException\n     {\n-        // Module-provided custom collection serializers?\n-        for (Serializers serializers : customSerializers()) {\n-            JsonSerializer<?> ser = serializers.findCollectionSerializer(config,\n-                    type, beanDesc, elementTypeSerializer, elementValueSerializer);\n-            if (ser != null) {\n-                return ser;\n-            }\n-        }\n         Class<?> raw = type.getRawClass();\n         if (EnumSet.class.isAssignableFrom(raw)) {\n             // this may or may not be available (Class doesn't; type of field/method does)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n                 }\n                 */\n             }\n-            return (JsonSerializer<Object>) buildContainerSerializer(prov,\n-                    type, beanDesc, property, staticTyping);\n-        }\n-\n-        // Modules may provide serializers of POJO types:\n-        for (Serializers serializers : customSerializers()) {\n-            ser = serializers.findSerializer(config, type, beanDesc);\n+            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...\n+            ser =  buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n             if (ser != null) {\n                 return (JsonSerializer<Object>) ser;\n+            }\n+        } else {\n+            // Modules may provide serializers of POJO types:\n+            for (Serializers serializers : customSerializers()) {\n+                ser = serializers.findSerializer(config, type, beanDesc);\n+                if (ser != null) {\n+                    return (JsonSerializer<Object>) ser;\n+                }\n             }\n         }\n         \n     {\n         // First things first: we know some types are not beans...\n         if (!isPotentialBeanType(type.getRawClass())) {\n-            return null;\n+            // 03-Aug-2012, tatu: Except we do need to allow serializers for Enums,\n+            //   as per [Issue#24]\n+            if (!type.isEnumType()) {\n+                return null;\n+            }\n         }\n         JsonSerializer<Object> serializer = constructBeanSerializer(prov, beanDesc, property);\n         // [JACKSON-440] Need to allow overriding actual serializer, as well...\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n import java.io.IOException;\n import java.lang.reflect.Type;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.SerializedString;\n \n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.node.ArrayNode;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.util.EnumValues;\n \n /**\n @JacksonStdImpl\n public class EnumSerializer\n     extends StdScalarSerializer<Enum<?>>\n+    implements ContextualSerializer\n {\n     /**\n      * This map contains pre-resolved values (since there are ways\n      */\n     protected final EnumValues _values;\n \n+    /**\n+     * Flag that is set if we statically know serialization choice\n+     * between index and textual format (null if it needs to be dynamically\n+     * checked).\n+     * \n+     * @since 2.1\n+     */\n+    protected final Boolean _serializeAsIndex;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @deprecated Since 2.1\n+     */\n+    @Deprecated\n     public EnumSerializer(EnumValues v) {\n+        this(v, null);\n+    }\n+\n+    public EnumSerializer(EnumValues v, Boolean serializeAsIndex)\n+    {\n         super(Enum.class, false);\n         _values = v;\n-    }\n-\n+        _serializeAsIndex = serializeAsIndex;\n+    }\n+    \n+    /**\n+     * Factory method used by {@link com.fasterxml.jackson.databind.ser.BasicSerializerFactory}\n+     * for constructing serializer instance of Enum types.\n+     * \n+     * @since 2.1\n+     */\n     public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config,\n-            BeanDescription beanDesc)\n+            BeanDescription beanDesc, JsonFormat.Value format)\n     {\n         // [JACKSON-212]: If toString() is to be used instead, leave EnumValues null\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n         EnumValues v = config.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)\n             ? EnumValues.constructFromToString(enumClass, intr) : EnumValues.constructFromName(enumClass, intr);\n-        return new EnumSerializer(v);\n-    }\n+        Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);\n+        return new EnumSerializer(v, serializeAsIndex);\n+    }\n+    \n+    /**\n+     * @deprecated Since 2.1 use the variant that takes in <code>format</code> argument.\n+     */\n+    @Deprecated\n+    public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config,\n+            BeanDescription beanDesc)\n+    {\n+        return construct(enumClass, config, beanDesc, beanDesc.findExpectedFormat(null));\n+    }\n+\n+    /**\n+     * To support some level of per-property configuration, we will need\n+     * to make things contextual. We are limited to \"textual vs index\"\n+     * choice here, however.\n+     */\n+    public JsonSerializer<?> createContextual(SerializerProvider prov,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        if (property != null) {\n+            JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember());\n+            if (format != null) {\n+                Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false);\n+                if (serializeAsIndex != _serializeAsIndex) {\n+                    return new EnumSerializer(_values, serializeAsIndex);\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API for Jackson databind core\n+    /**********************************************************\n+     */\n+    \n+    public EnumValues getEnumValues() { return _values; }\n+\n+    /*\n+    /**********************************************************\n+    /* Actual serialization\n+    /**********************************************************\n+     */\n     \n     @Override\n     public final void serialize(Enum<?> en, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n         // [JACKSON-684]: serialize as index?\n-        if (provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n+        if (_serializeAsIndex(provider)) {\n             jgen.writeNumber(en.ordinal());\n             return;\n         }\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n     {\n         // [JACKSON-684]: serialize as index?\n-        if (provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n+        if (_serializeAsIndex(provider)) {\n             return createSchemaNode(\"integer\", true);\n         }\n         ObjectNode objectNode = createSchemaNode(\"string\", true);\n         return objectNode;\n     }\n \n-    public EnumValues getEnumValues() { return _values; }\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected final boolean _serializeAsIndex(SerializerProvider provider)\n+    {\n+        if (_serializeAsIndex != null) {\n+            return _serializeAsIndex.booleanValue();\n+        }\n+        return provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX);\n+        \n+    }\n+\n+    /**\n+     * Helper method called to check whether \n+     */\n+    protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass,\n+            JsonFormat.Value format, boolean fromClass)\n+    {\n+        JsonFormat.Shape shape = (format == null) ? null : format.getShape();\n+        if (shape == null) {\n+            return null;\n+        }\n+        if (shape == Shape.ANY || shape == Shape.SCALAR) { // i.e. \"default\", check dynamically\n+            return null;\n+        }\n+        if (shape == Shape.STRING) {\n+            return Boolean.FALSE;\n+        }\n+        if (shape.isNumeric()) {\n+            return Boolean.TRUE;\n+        }\n+        throw new IllegalArgumentException(\"Unsupported serialization shape (\"+shape+\") for Enum \"+enumClass.getName()\n+                    +\", not supported as \"\n+                    + (fromClass? \"class\" : \"property\")\n+                    +\" annotation\");\n+    }\n }\n \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestKeyDeserializers.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.KeyDeserializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestKeyDeserializers extends BaseMapTest\n+{\n+    static class FooKeyDeserializer extends KeyDeserializer\n+    {\n+        @Override\n+        public Foo deserializeKey(String key, DeserializationContext ctxt)\n+        {\n+            return new Foo(key);\n+        }\n+    }\n+    \n+    static class Foo {\n+        public String value;\n+        \n+        public Foo(String v) { value = v; }\n+    }\n+    \n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testKeyDeserializers() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\", Version.unknownVersion());\n+        mod.addKeyDeserializer(Foo.class, new FooKeyDeserializer());\n+        mapper.registerModule(mod);\n+        Map<Foo,Integer> map = mapper.readValue(\"{\\\"a\\\":3}\",\n+                new TypeReference<Map<Foo,Integer>>() {} );\n+        assertNotNull(map);\n+        assertEquals(1, map.size());\n+        Foo foo = map.keySet().iterator().next();\n+        assertEquals(\"a\", foo.value);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n         public String[] empty = new String[0];\n     }\n \n-    // [JACKSIN-689]\n+    // [JACKSON-689]\n     static class BeanWithIterable {\n         private final ArrayList<String> values = new ArrayList<String>();\n         {\n \n         public Iterable<String> getValues() { return values; }\n     }\n-    \n+\n+    // [issue#40]: Allow serialization 'as POJO' (resulting in JSON Object) \n+    @JsonPropertyOrder({ \"size\", \"value\" })\n+    @JsonFormat(shape=Shape.OBJECT)\n+    @JsonIgnoreProperties({ \"empty\" }) // from 'isEmpty()'\n+    static class CollectionAsPOJO\n+        extends ArrayList<String>\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        @JsonProperty(\"size\")\n+        public int foo() { return size(); }\n+        \n+        public String[] getValues() {\n+            return toArray(new String[size()]);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n         assertEquals(\"{\\\"values\\\":[\\\"value\\\"]}\",\n                 MAPPER.writeValueAsString(new BeanWithIterable()));\n     }\n+\n+    // [Issue#40]\n+    public void testListAsObject() throws Exception\n+    {\n+        CollectionAsPOJO list = new CollectionAsPOJO();\n+        list.add(\"a\");\n+        list.add(\"b\");\n+        String json = MAPPER.writeValueAsString(list);\n+        assertEquals(\"{\\\"size\\\":2,\\\"values\\\":[\\\"a\\\",\\\"b\\\"]}\", json);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n import java.io.*;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.annotation.JsonValue;\n \n         OK(String key) { this.key = key; }\n     }\n     \n+    // Types for [https://github.com/FasterXML/jackson-databind/issues/24]\n+    // (Enums as JSON Objects)\n+\n+    @JsonFormat(shape=JsonFormat.Shape.OBJECT)\n+    static enum PoNUM {\n+        A(\"a1\"), B(\"b2\");\n+\n+        @JsonProperty\n+        protected final String value;\n+        \n+        private PoNUM(String v) { value = v; }\n+\n+        public String getValue() { return value; }\n+    }\n+\n+    static class PoNUMContainer {\n+        @JsonFormat(shape=Shape.NUMBER)\n+        public OK text = OK.V1;\n+    }\n+    \n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY) // not supported as of now\n+    static enum BrokenPoNum\n+    {\n+        A, B;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Tests\n         assertEquals(quote(\"V1\"), mapper.writeValueAsString(OK.V1));\n         assertEquals(quote(\"V1\"), mapper.writeValueAsString(NOT_OK.V1));\n         assertEquals(quote(\"V2\"), mapper.writeValueAsString(NOT_OK2.V2));\n+    }\n+\n+    // Tests for [issue#24]\n+\n+    public void testEnumAsObjectValid() throws Exception {\n+        assertEquals(\"{\\\"value\\\":\\\"a1\\\"}\", mapper.writeValueAsString(PoNUM.A));\n+    }\n+\n+    public void testEnumAsIndexViaAnnotations() throws Exception {\n+        assertEquals(\"{\\\"text\\\":0}\", mapper.writeValueAsString(new PoNUMContainer()));\n+    }\n+    \n+    public void testEnumAsObjectBroken() throws Exception\n+    {\n+        try {\n+            String json = mapper.writeValueAsString(BrokenPoNum.A);\n+            fail(\"Should not have succeeded, produced: \"+json);\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Unsupported serialization shape\");\n+        }\n     }\n }\n ", "timestamp": 1344043763, "metainfo": ""}