{"sha": "4fdbd54e9e5c5d3cb5ce539f48ba6f1019decdab", "log": "Cleaning up AnnotatedClass implementation", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n      */\n     protected AnnotationMap _classAnnotations;\n \n+    /**\n+     * Flag to indicate whether creator information has been resolved\n+     * or not.\n+     */\n+    protected boolean _creatorsResolved = false;\n+    \n     /**\n      * Default constructor of the annotated class, if it has one.\n      */\n             AnnotationIntrospector aintr, MixInResolver mir)\n     {\n         List<Class<?>> st = ClassUtil.findSuperTypes(cls, null);\n-        AnnotatedClass ac = new AnnotatedClass(cls, st, aintr, mir, null);\n-        ac.resolveClassAnnotations();\n-        return ac;\n+        return new AnnotatedClass(cls, st, aintr, mir, null);\n     }\n \n     /**\n             AnnotationIntrospector aintr, MixInResolver mir)\n     {\n         List<Class<?>> empty = Collections.emptyList();\n-        AnnotatedClass ac = new AnnotatedClass(cls, empty, aintr, mir, null);\n-        ac.resolveClassAnnotations();\n-        return ac;\n+        return new AnnotatedClass(cls, empty, aintr, mir, null);\n     }\n     \n     /*\n     public <A extends Annotation> A getAnnotation(Class<A> acls)\n     {\n         if (_classAnnotations == null) {\n-            return null;\n+            resolveClassAnnotations();\n         }\n         return _classAnnotations.get(acls);\n     }\n \n     @Override\n     protected AnnotationMap getAllAnnotations() {\n+        if (_classAnnotations == null) {\n+            resolveClassAnnotations();\n+        }\n         return _classAnnotations;\n     }\n     \n     /**********************************************************\n      */\n \n-    public Annotations getAnnotations() { return _classAnnotations; }\n-    \n-    public boolean hasAnnotations() { return _classAnnotations.size() > 0; }\n-\n-    public AnnotatedConstructor getDefaultConstructor() { return _defaultConstructor; }\n+    public Annotations getAnnotations() {\n+        if (_classAnnotations == null) {\n+            resolveClassAnnotations();\n+        }\n+        return _classAnnotations;\n+    }\n+    \n+    public boolean hasAnnotations() {\n+        if (_classAnnotations == null) {\n+            resolveClassAnnotations();\n+        }\n+        return _classAnnotations.size() > 0;\n+    }\n+\n+    public AnnotatedConstructor getDefaultConstructor()\n+    {\n+        if (!_creatorsResolved) {\n+            resolveCreators();\n+        }\n+        return _defaultConstructor;\n+    }\n \n     public List<AnnotatedConstructor> getConstructors()\n     {\n-        if (_constructors == null) {\n-            return Collections.emptyList();\n+        if (!_creatorsResolved) {\n+            resolveCreators();\n         }\n         return _constructors;\n     }\n \n     public List<AnnotatedMethod> getStaticMethods()\n     {\n-        if (_creatorMethods == null) {\n-            return Collections.emptyList();\n+        if (!_creatorsResolved) {\n+            resolveCreators();\n         }\n         return _creatorMethods;\n     }\n      * annotations for this class and all super classes and\n      * interfaces.\n      */\n-    public void resolveClassAnnotations()\n+    private void resolveClassAnnotations()\n     {\n         _classAnnotations = new AnnotationMap();\n         // [JACKSON-659] Should skip processing if annotation processing disabled\n-        if (_annotationIntrospector == null) {\n-            return;\n-        }\n-        \n-        // add mix-in annotations first (overrides)\n-        if (_primaryMixIn != null) {\n-            _addClassMixIns(_classAnnotations, _class, _primaryMixIn);\n-        }\n-        // first, annotations from the class itself:\n-        _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations());\n-\n-        // and then from super types\n-        for (Class<?> cls : _superTypes) {\n-            // and mix mix-in annotations in-between\n-            _addClassMixIns(_classAnnotations, cls);\n-            _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations());\n-        }\n-\n-        /* and finally... any annotations there might be for plain\n-         * old Object.class: separate because for all other purposes\n-         * it is just ignored (not included in super types)\n-         */\n-        /* 12-Jul-2009, tatu: Should this be done for interfaces too?\n-         *   For now, yes, seems useful for some cases, and not harmful\n-         *   for any?\n-         */\n-        _addClassMixIns(_classAnnotations, Object.class);\n+        if (_annotationIntrospector != null) {\n+            // add mix-in annotations first (overrides)\n+            if (_primaryMixIn != null) {\n+                _addClassMixIns(_classAnnotations, _class, _primaryMixIn);\n+            }\n+            // first, annotations from the class itself:\n+            _addAnnotationsIfNotPresent(_classAnnotations, _class.getDeclaredAnnotations());\n+    \n+            // and then from super types\n+            for (Class<?> cls : _superTypes) {\n+                // and mix mix-in annotations in-between\n+                _addClassMixIns(_classAnnotations, cls);\n+                _addAnnotationsIfNotPresent(_classAnnotations, cls.getDeclaredAnnotations());\n+            }\n+            /* and finally... any annotations there might be for plain\n+             * old Object.class: separate because for all other purposes\n+             * it is just ignored (not included in super types)\n+             */\n+            /* 12-Jul-2009, tatu: Should this be done for interfaces too?\n+             *   For now, yes, seems useful for some cases, and not harmful for any?\n+             */\n+            _addClassMixIns(_classAnnotations, Object.class);\n+        }\n     }\n     \n     /**\n      * Initialization method that will find out all constructors\n      * and potential static factory methods the class has.\n-     *\n-     * @param includeAll If true, includes all creator methods; if false,\n-     *   will only include the no-arguments \"default\" constructor\n-     */\n-    public void resolveCreators(boolean includeAll)\n+     */\n+    private void resolveCreators()\n     {\n         // Then see which constructors we have\n-        _constructors = null;\n+        List<AnnotatedConstructor> constructors = null;\n         Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n         for (Constructor<?> ctor : declaredCtors) {\n             if (ctor.getParameterTypes().length == 0) {\n                 _defaultConstructor = _constructConstructor(ctor, true);\n             } else {\n-                if (includeAll) {\n-                    if (_constructors == null) {\n-                        _constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n-                    }\n-                    _constructors.add(_constructConstructor(ctor, false));\n-                }\n-            }\n+                if (constructors == null) {\n+                    constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n+                }\n+                constructors.add(_constructConstructor(ctor, false));\n+            }\n+        }\n+        if (constructors == null) {\n+            _constructors = Collections.emptyList();\n+        } else {\n+            _constructors = constructors;\n         }\n         // and if need be, augment with mix-ins\n         if (_primaryMixIn != null) {\n-            if (_defaultConstructor != null || _constructors != null) {\n+            if (_defaultConstructor != null || !_constructors.isEmpty()) {\n                 _addConstructorMixIns(_primaryMixIn);\n             }\n         }\n                 }\n             }\n         }\n-\n-        _creatorMethods = null;\n+        List<AnnotatedMethod> creatorMethods = null;\n         \n-        if (includeAll) {\n-            // Then static methods which are potential factory methods\n-            for (Method m : _class.getDeclaredMethods()) {\n-                if (!Modifier.isStatic(m.getModifiers())) {\n-                    continue;\n-                }\n-                int argCount = m.getParameterTypes().length;\n-                // factory methods take at least one arg:\n-                if (argCount < 1) {\n-                    continue;\n-                }\n-                if (_creatorMethods == null) {\n-                    _creatorMethods = new ArrayList<AnnotatedMethod>(8);\n-                }\n-                _creatorMethods.add(_constructCreatorMethod(m));\n-            }\n+        // Then static methods which are potential factory methods\n+        for (Method m : _class.getDeclaredMethods()) {\n+            if (!Modifier.isStatic(m.getModifiers())) {\n+                continue;\n+            }\n+            int argCount = m.getParameterTypes().length;\n+            // factory methods take at least one arg:\n+            if (argCount < 1) {\n+                continue;\n+            }\n+            if (creatorMethods == null) {\n+                creatorMethods = new ArrayList<AnnotatedMethod>(8);\n+            }\n+            creatorMethods.add(_constructCreatorMethod(m));\n+        }\n+        if (creatorMethods == null) {\n+            _creatorMethods = Collections.emptyList();\n+        } else {\n+            _creatorMethods = creatorMethods;\n             // mix-ins to mix in?\n-            if (_primaryMixIn != null && _creatorMethods != null) {\n+            if (_primaryMixIn != null) {\n                 _addFactoryMixIns(_primaryMixIn);\n             }\n             // anything to ignore at this point?\n             if (_annotationIntrospector != null) {\n-                if (_creatorMethods != null) {\n-                    // count down to allow safe removal\n-                    for (int i = _creatorMethods.size(); --i >= 0; ) {\n-                        if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n-                            _creatorMethods.remove(i);\n-                        }\n+                // count down to allow safe removal\n+                for (int i = _creatorMethods.size(); --i >= 0; ) {\n+                    if (_annotationIntrospector.hasIgnoreMarker(_creatorMethods.get(i))) {\n+                        _creatorMethods.remove(i);\n                     }\n                 }\n             }\n         }\n+        _creatorsResolved = true;\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n         AnnotationIntrospector ai = config.getAnnotationIntrospector();\n         AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), (useAnnotations ? ai : null), r);\n         ac.resolveMemberMethods(MINIMAL_FILTER);\n-        // true -> include all creators, not just default constructor\n-        ac.resolveCreators(true);\n         return ac;\n     }\n     ", "timestamp": 1327297468, "metainfo": ""}