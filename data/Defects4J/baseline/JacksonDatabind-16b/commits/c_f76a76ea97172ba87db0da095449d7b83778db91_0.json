{"sha": "f76a76ea97172ba87db0da095449d7b83778db91", "log": "Merge branch '2.4'", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n             if (cause != null) {\n                 String m2 = cause.getMessage();\n                 if (m2 != null) {\n-                    msg += m2;\n+                    msg = msg + \", problem: \"+m2;\n                 }\n             }\n             JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonInclude;\n-\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.core.Versioned;\n-\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n      * field) defines which Bean/Map properties are to be included in\n      * serialization.\n      * If no annotation is found, method should return given second\n-     * argument; otherwise value indicated by the annotation\n+     * argument; otherwise value indicated by the annotation.\n+     *<p>\n+     * Note that meaning of inclusion value depends on whether it is for\n+     * a Class or property (field/method/constructor): in former case,\n+     * it is the default for all properties; in latter case it is specific\n+     * override for annotated property.\n      *\n      * @return Enumerated value indicating which properties to include\n      *   in serialization\n      */\n     public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue) {\n+        return defValue;\n+    }\n+\n+    /**\n+     * Method for checking whether content (entries) of a {@link java.util.Map} property\n+     * are to be included during serialization or not.\n+     * \n+     * @since 2.5\n+     */\n+    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue) {\n         return defValue;\n     }\n \n     public boolean hasCreatorAnnotation(Annotated a) {\n         return false;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable methods: may be used as low-level extension\n+    /* points.\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that should be used by sub-classes for ALL\n+     * annotation access;\n+     * overridable so \n+     * that sub-classes may, if they choose to, mangle actual access to\n+     * block access (\"hide\" annotations) or perhaps change it.\n+     *<p>\n+     * Default implementation is simply:\n+     *<code>\n+     *  return annotated.getAnnotation(annoClass);\n+     *</code>\n+     * \n+     * @since 2.5\n+     */\n+    protected <A extends Annotation> A _findAnnotation(Annotated annotated,\n+            Class<A> annoClass) {\n+        return annotated.getAnnotation(annoClass);\n+    }\n+\n+    /**\n+     * Method that should be used by sub-classes for ALL\n+     * annotation existence access;\n+     * overridable so  that sub-classes may, if they choose to, mangle actual access to\n+     * block access (\"hide\" annotations) or perhaps change value seen.\n+     *<p>\n+     * Default implementation is simply:\n+     *<code>\n+     *  return annotated.hasAnnotation(annoClass);\n+     *</code>\n+     * \n+     * @since 2.5\n+     */\n+    protected boolean _hasAnnotation(Annotated annotated, Class<? extends Annotation> annoClass) {\n+        return annotated.hasAnnotation(annoClass);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n     public abstract JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue);\n \n     /**\n+     * @since 2.5\n+     */\n+    public abstract JsonInclude.Include findSerializationInclusionForContent(JsonInclude.Include defValue);\n+    \n+    /**\n      * Method for checking what is the expected format for POJO, as\n      * defined by defaults and possible annotations.\n      * Note that this may be further refined by per-property annotations.\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n      * If disabled, standard POJOs can only be bound from JSON null or\n      * JSON Object (standard meaning that no custom deserializers or\n      * constructors are defined; both of which can add support for other\n-     * kinds of JSON values); if enable, empty JSON String can be taken\n+     * kinds of JSON values); if enabled, empty JSON String can be taken\n      * to be equivalent of JSON null.\n      *<p>\n      * Feature is disabled by default.\n      */\n     ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false),\n+\n+    /**\n+     * Feature that can be enabled to allow empty JSON Array\n+     * value (that is, <code>[ ]</code>) to be bound to POJOs as null.\n+     * If disabled, standard POJOs can only be bound from JSON null or\n+     * JSON Object (standard meaning that no custom deserializers or\n+     * constructors are defined; both of which can add support for other\n+     * kinds of JSON values); if enabled, empty JSON Array will be taken\n+     * to be equivalent of JSON null.\n+     *<p>\n+     * Feature is disabled by default.\n+     * \n+     * @since 2.5\n+     */\n+    ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT(false),\n     \n     /**\n      * Feature that allows unknown Enum values to be parsed as null values. \n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n import java.lang.reflect.Modifier;\n \n import com.fasterxml.jackson.core.type.ResolvedType;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Base class for type token classes used both to contain information\n \n     @Override\n     public JavaType containedType(int index) { return null; }\n-\n+       \n     @Override\n     public String containedTypeName(int index) { return null; }\n+\n+    @Override\n+    public abstract Class<?> getParameterSource();\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API beyond ResolvedType\n+    /**********************************************************\n+     */\n+    \n+    // NOTE: not defined in Resolved type\n+    /**\n+     * Convenience method that is functionally same as:\n+     *<code>\n+     * JavaType t = containedType(index);\n+     * if (t == null) {\n+     *    t = TypeFactory.unknownType();\n+     * }\n+     *</code>\n+     * and typically used to eliminate need for null checks for common case\n+     * where we just want to check if containedType is available first; and\n+     * if not, use \"unknown type\" (which translates to <code>java.lang.Object</code>\n+     * basically).\n+     *\n+     * @since 2.5\n+     */\n+    public JavaType containedTypeOrUnknown(int index) {\n+        JavaType t = containedType(index);\n+        return (t == null)  ? TypeFactory.unknownType() : t;\n+    }\n \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n      * explicitly annotated for such use.\n      *<p>\n      * Feature is enabled by default, for backwards compatibility reasons.\n+     * \n+     * @since 2.2\n      */\n     ALLOW_FINAL_FIELDS_AS_MUTATORS(true),\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     // Quick little shortcut, to avoid having to use global TypeFactory instance...\n     private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n \n-    /* !!! 03-Apr-2009, tatu: Should try to avoid direct reference... but not\n-     *   sure what'd be simple and elegant way. So until then:\n-     */\n-    protected final static ClassIntrospector DEFAULT_INTROSPECTOR = BasicClassIntrospector.instance;\n-\n     // 16-May-2009, tatu: Ditto ^^^\n     protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector();\n \n      * Base settings contain defaults used for all {@link ObjectMapper}\n      * instances.\n      */\n-    protected final static BaseSettings DEFAULT_BASE = new BaseSettings(DEFAULT_INTROSPECTOR,\n-            DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n+    protected final static BaseSettings DEFAULT_BASE = new BaseSettings(\n+            null, // can not share global ClassIntrospector any more (2.5+)\n+            DEFAULT_ANNOTATION_INTROSPECTOR,\n+            STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n             null, StdDateFormat.instance, null,\n             Locale.getDefault(),\n //            TimeZone.getDefault()\n \n     /**\n      * We will use a separate main-level Map for keeping track\n-     * of root-level deserializers. This is where most succesful\n+     * of root-level deserializers. This is where most successful\n      * cache lookups get resolved.\n      * Map will contain resolvers for all kinds of types, including\n      * container types: this is different from the component cache\n      * Java Beans (based on method names and Jackson-specific annotations),\n      * but does not support JAXB annotations.\n      */\n-    public ObjectMapper()\n-    {\n+    public ObjectMapper() {\n         this(null, null, null);\n     }\n \n      * for constructing necessary {@link JsonParser}s and/or\n      * {@link JsonGenerator}s.\n      */\n-    public ObjectMapper(JsonFactory jf)\n-    {\n+    public ObjectMapper(JsonFactory jf) {\n         this(jf, null, null);\n     }\n \n \n         HashMap<ClassKey,Class<?>> mixins = new HashMap<ClassKey,Class<?>>();\n         _mixInAnnotations = mixins;\n-        _serializationConfig = new SerializationConfig(DEFAULT_BASE,\n+\n+        BaseSettings base = DEFAULT_BASE.withClassIntrospector(defaultClassIntrospector());\n+        _serializationConfig = new SerializationConfig(base,\n                     _subtypeResolver, mixins);\n-        _deserializationConfig = new DeserializationConfig(DEFAULT_BASE,\n+        _deserializationConfig = new DeserializationConfig(base,\n                     _subtypeResolver, mixins);\n \n         // Some overrides we may need\n         _serializerFactory = BeanSerializerFactory.instance;\n     }\n \n+    /**\n+     * Overridable helper method used to construct default {@link ClassIntrospector}\n+     * to use.\n+     * \n+     * @since 2.5\n+     */\n+    protected ClassIntrospector defaultClassIntrospector() {\n+        return new BasicClassIntrospector();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Methods sub-classes MUST override\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Method for creating a new {@link ObjectMapper} instance that\n      * has same initial configuration as this instance. Note that this\n      * \n      * @since 2.1\n      */\n-    public ObjectMapper copy()\n-    {\n+    public ObjectMapper copy() {\n         _checkInvalidCopy(ObjectMapper.class);\n         return new ObjectMapper(this);\n     }\n \n     /**\n      * @since 2.1\n-     * @param exp\n      */\n     protected void _checkInvalidCopy(Class<?> exp)\n     {\n                     +\" (version: \"+version()+\") does not override copy(); it has to\");\n         }\n     }\n-    \n+\n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectReader}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _newReader(DeserializationConfig config) {\n+        return new ObjectReader(this, config);\n+    }\n+\n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectReader}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _newReader(DeserializationConfig config,\n+            JavaType valueType, Object valueToUpdate,\n+            FormatSchema schema, InjectableValues injectableValues) {\n+        return new ObjectReader(this, config, valueType, valueToUpdate, schema, injectableValues);\n+    }\n+\n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _newWriter(SerializationConfig config) {\n+        return new ObjectWriter(this, config);\n+    }\n+\n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _newWriter(SerializationConfig config, FormatSchema schema) {\n+        return new ObjectWriter(this, config, schema);\n+    }\n+    \n+    /**\n+     * Factory method sub-classes must override, to produce {@link ObjectWriter}\n+     * instances of proper sub-type\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectWriter _newWriter(SerializationConfig config,\n+            JavaType rootType, PrettyPrinter pp) {\n+        return new ObjectWriter(this, config, rootType, pp);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Versioned impl\n     public Version version() {\n         return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Module registration, discovery\n     /* Configuration: mix-in annotations\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Method to use for defining mix-in annotations to use for augmenting\n      * annotations that processable (serializable / deserializable)\n      * Annotations from source classes (and their supertypes)\n      * will <b>override</b>\n      * annotations that target classes (and their super-types) have.\n-     */\n-    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper setMixIns(Map<Class<?>, Class<?>> sourceMixins)\n     {\n         _mixInAnnotations.clear();\n         if (sourceMixins != null && sourceMixins.size() > 0) {\n                 _mixInAnnotations.put(new ClassKey(en.getKey()), en.getValue());\n             }\n         }\n+        return this;\n     }\n \n     /**\n      * @param target Class (or interface) whose annotations to effectively override\n      * @param mixinSource Class (or interface) whose annotations are to\n      *   be \"added\" to target's annotations, overriding as necessary\n-     */\n-    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)\n+     *\n+     * @since 2.5\n+     */\n+    public ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)\n     {\n         _mixInAnnotations.put(new ClassKey(target), mixinSource);\n-    }\n-\n-    /**\n-     * Method to use for adding mix-in annotations to use for augmenting\n-     * specified class or interface. All annotations from\n-     * <code>mixinSource</code> are taken to override annotations\n-     * that <code>target</code> (or its supertypes) has.\n-     *\n-     * @param target Class (or interface) whose annotations to effectively override\n-     * @param mixinSource Class (or interface) whose annotations are to\n-     *   be \"added\" to target's annotations, overriding as necessary\n-     */\n-    public final ObjectMapper addMixIn(Class<?> target, Class<?> mixinSource)\n-    {\n-        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n-        return this;\n-    }\n-\n-    public final Class<?> findMixInClassFor(Class<?> cls) {\n+        return this;\n+    }\n+\n+    public Class<?> findMixInClassFor(Class<?> cls) {\n         return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n     }\n \n-    public final int mixInCount() {\n+    public int mixInCount() {\n         return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n+    }\n+\n+\n+    /**\n+     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #setMixIns}.\n+     */\n+    @Deprecated\n+    public void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins) {\n+        setMixIns(sourceMixins);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5: replaced by a fluent form of the method; {@link #addMixIn(Class, Class)}.\n+     */\n+    @Deprecated\n+    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n+        addMixIn(target, mixinSource);\n     }\n     \n     /*\n     }\n \n     /**\n+     * @since 2.5\n+     */\n+    public PropertyNamingStrategy getPropertyNamingStrategy() {\n+        // arbitrary choice but let's do:\n+        return _serializationConfig.getPropertyNamingStrategy();\n+    }\n+    \n+    /**\n      * Method for setting defalt POJO property inclusion strategy for serialization.\n      */\n     public ObjectMapper setSerializationInclusion(JsonInclude.Include incl) {\n      * Method for enabling automatic inclusion of type information, needed\n      * for proper deserialization of polymorphic types (unless types\n      * have been annotated with {@link com.fasterxml.jackson.annotation.JsonTypeInfo}).\n+     *<P>\n+     * NOTE: use of <code>JsonTypeInfo.As#EXTERNAL_PROPERTY</code> <b>NOT SUPPORTED</b>;\n+     * and attempts of do so will throw an {@link IllegalArgumentException} to make\n+     * this limitation explicit.\n      * \n      * @param applicability Defines kinds of types for which additional type information\n      *    is added; see {@link DefaultTyping} for more information.\n      */\n     public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)\n     {\n+        /* 18-Sep-2014, tatu: Let's add explicit check to ensure no one tries to\n+         *   use \"As.EXTERNAL_PROPERTY\", since that will not work (with 2.5+)\n+         */\n+        if (includeAs == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n+            throw new IllegalArgumentException(\"Can not use includeAs of \"+includeAs);\n+        }\n+        \n         TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n         // we'll always use full class name, when using defaulting\n         typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n         return this;\n     }\n \n+    /**\n+     * @since 2.5\n+     */\n+    public DateFormat getDateFormat() {\n+        // arbitrary choice but let's do:\n+        return _serializationConfig.getDateFormat();\n+    }\n+    \n     /**\n      * Method for configuring {@link HandlerInstantiator} to use for creating\n      * instances of handlers (such as serializers, deserializers, type and type\n      * @param n Root node of the tree that resulting parser will read from\n      */\n     @Override\n-    public JsonParser treeAsTokens(TreeNode n)\n-    {\n+    public JsonParser treeAsTokens(TreeNode n) {\n         return new TreeTraversingParser((JsonNode) n, this);\n     }\n \n      *<p>\n      * NOTE: since this method does NOT throw exceptions, but internal\n      * processing may, caller usually has little information as to why\n-     * serialization would fail.\n+     * serialization would fail. If you want access to internal {@link Exception},\n+     * call {@link #canSerialize(Class, AtomicReference)} instead.\n      *\n      * @return True if mapper can find a serializer for instances of\n      *  given class (potentially serializable), false otherwise (not\n     /**\n      * Method that can be called to check whether mapper thinks\n      * it could deserialize an Object of given type.\n-     * Check is done\n-     * by checking whether a deserializer can be found for the type.\n+     * Check is done by checking whether a registered deserializer can\n+     * be found or built for the type; if not (either by no mapping being\n+     * found, or through an <code>Exception</code> being thrown, false\n+     * is returned.\n+     *<p>\n+     * <b>NOTE</b>: in case an exception is thrown during course of trying\n+     * co construct matching deserializer, it will be effectively swallowed.\n+     * If you want access to that exception, call\n+     * {@link #canDeserialize(JavaType, AtomicReference)} instead.\n      *\n      * @return True if mapper can find a serializer for instances of\n      *  given class (potentially serializable), false otherwise (not\n      * with default settings.\n      */\n     public ObjectWriter writer() {\n-        return new ObjectWriter(this, getSerializationConfig());\n+        return _newWriter(getSerializationConfig());\n     }\n \n     /**\n      * mapper instance has).\n      */\n     public ObjectWriter writer(SerializationFeature feature) {\n-        return new ObjectWriter(this, getSerializationConfig().with(feature));\n+        return _newWriter(getSerializationConfig().with(feature));\n     }\n \n     /**\n      */\n     public ObjectWriter writer(SerializationFeature first,\n             SerializationFeature... other) {\n-        return new ObjectWriter(this, getSerializationConfig().with(first, other));\n+        return _newWriter(getSerializationConfig().with(first, other));\n     }\n     \n     /**\n      * null passed, using timestamp (64-bit number.\n      */\n     public ObjectWriter writer(DateFormat df) {\n-        return new ObjectWriter(this, getSerializationConfig().with(df));\n+        return _newWriter(getSerializationConfig().with(df));\n     }\n     \n     /**\n      * serialize objects using specified JSON View (filter).\n      */\n     public ObjectWriter writerWithView(Class<?> serializationView) {\n-        return new ObjectWriter(this, getSerializationConfig().withView(serializationView));\n+        return _newWriter(getSerializationConfig().withView(serializationView));\n     }\n     \n     /**\n      * type.\n      */\n     public ObjectWriter writerWithType(Class<?> rootType) {\n-        return new ObjectWriter(this, getSerializationConfig(),\n+        return _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                 ((rootType == null) ? null :_typeFactory.constructType(rootType)),\n                 /*PrettyPrinter*/null);\n      * runtime type of value. Type must be a super-type of runtime type.\n      */\n     public ObjectWriter writerWithType(TypeReference<?> rootType) {\n-        return new ObjectWriter(this, getSerializationConfig(),\n+        return _newWriter(getSerializationConfig(),\n                 // 15-Mar-2013, tatu: Important! Indicate that static typing is needed:\n                 ((rootType == null) ? null : _typeFactory.constructType(rootType)),\n                 /*PrettyPrinter*/null);\n      * runtime type of value. Type must be a super-type of runtime type.\n      */\n     public ObjectWriter writerWithType(JavaType rootType) {\n-        return new ObjectWriter(this, getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n+        return _newWriter(getSerializationConfig(), rootType, /*PrettyPrinter*/null);\n     }\n     \n     /**\n         if (pp == null) { // need to use a marker to indicate explicit disabling of pp\n             pp = ObjectWriter.NULL_PRETTY_PRINTER;\n         }\n-        return new ObjectWriter(this, getSerializationConfig(), /*root type*/ null, pp);\n+        return _newWriter(getSerializationConfig(), /*root type*/ null, pp);\n     }\n     \n     /**\n      * serialize objects using the default pretty printer for indentation\n      */\n     public ObjectWriter writerWithDefaultPrettyPrinter() {\n-        return new ObjectWriter(this, getSerializationConfig(),\n+        return _newWriter(getSerializationConfig(),\n                 /*root type*/ null, _defaultPrettyPrinter());\n     }\n     \n      * serialize objects using specified filter provider.\n      */\n     public ObjectWriter writer(FilterProvider filterProvider) {\n-        return new ObjectWriter(this,\n-                getSerializationConfig().withFilters(filterProvider));\n+        return _newWriter(getSerializationConfig().withFilters(filterProvider));\n     }\n     \n     /**\n      */\n     public ObjectWriter writer(FormatSchema schema) {\n         _verifySchemaType(schema);\n-        return new ObjectWriter(this, getSerializationConfig(), schema);\n+        return _newWriter(getSerializationConfig(), schema);\n     }\n \n     /**\n      * @since 2.1\n      */\n     public ObjectWriter writer(Base64Variant defaultBase64) {\n-        return new ObjectWriter(this, getSerializationConfig().with(defaultBase64));\n+        return _newWriter(getSerializationConfig().with(defaultBase64));\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectWriter writer(CharacterEscapes escapes) {\n-        return writer().with(escapes);\n+        return _newWriter(getSerializationConfig()).with(escapes);\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectWriter writer(ContextAttributes attrs) {\n-        return new ObjectWriter(this, getSerializationConfig().with(attrs));\n+        return _newWriter(getSerializationConfig().with(attrs));\n     }\n     \n     /*\n      * without defining expected value type.\n      */\n     public ObjectReader reader() {\n-        return new ObjectReader(this, getDeserializationConfig())\n-            .with(_injectableValues);\n+        return _newReader(getDeserializationConfig()).with(_injectableValues);\n     }\n \n     /**\n      * without defining expected value type.\n      */\n     public ObjectReader reader(DeserializationFeature feature) {\n-        return new ObjectReader(this, getDeserializationConfig().with(feature));\n+        return _newReader(getDeserializationConfig().with(feature));\n     }\n \n     /**\n      */\n     public ObjectReader reader(DeserializationFeature first,\n             DeserializationFeature... other) {\n-        return new ObjectReader(this, getDeserializationConfig().with(first, other));\n+        return _newReader(getDeserializationConfig().with(first, other));\n     }\n     \n     /**\n      * Runtime type of value object is used for locating deserializer,\n      * unless overridden by other factory methods of {@link ObjectReader}\n      */\n-    public ObjectReader readerForUpdating(Object valueToUpdate)\n-    {\n+    public ObjectReader readerForUpdating(Object valueToUpdate) {\n         JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n-        return new ObjectReader(this, getDeserializationConfig(), t, valueToUpdate,\n+        return _newReader(getDeserializationConfig(), t, valueToUpdate,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(JavaType type)\n-    {\n-        return new ObjectReader(this, getDeserializationConfig(), type, null,\n+    public ObjectReader reader(JavaType type) {\n+        return _newReader(getDeserializationConfig(), type, null,\n                 null, _injectableValues);\n     }\n \n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(Class<?> type)\n-    {\n-        return reader(_typeFactory.constructType(type));\n+    public ObjectReader reader(Class<?> type) {\n+        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n+                null, _injectableValues);\n     }\n \n     /**\n      * Factory method for constructing {@link ObjectReader} that will\n      * read or update instances of specified type\n      */\n-    public ObjectReader reader(TypeReference<?> type)\n-    {\n-        return reader(_typeFactory.constructType(type));\n+    public ObjectReader reader(TypeReference<?> type) {\n+        return _newReader(getDeserializationConfig(), _typeFactory.constructType(type), null,\n+                null, _injectableValues);\n     }\n \n     /**\n      * Factory method for constructing {@link ObjectReader} that will\n      * use specified {@link JsonNodeFactory} for constructing JSON trees.\n      */\n-    public ObjectReader reader(JsonNodeFactory f)\n-    {\n-        return new ObjectReader(this, getDeserializationConfig()).with(f);\n+    public ObjectReader reader(JsonNodeFactory f) {\n+        return _newReader(getDeserializationConfig()).with(f);\n     }\n \n     /**\n      */\n     public ObjectReader reader(FormatSchema schema) {\n         _verifySchemaType(schema);\n-        return new ObjectReader(this, getDeserializationConfig(), null, null,\n+        return _newReader(getDeserializationConfig(), null, null,\n                 schema, _injectableValues);\n     }\n \n      * @param injectableValues Injectable values to use\n      */\n     public ObjectReader reader(InjectableValues injectableValues) {\n-        return new ObjectReader(this, getDeserializationConfig(), null, null,\n+        return _newReader(getDeserializationConfig(), null, null,\n                 null, injectableValues);\n     }\n \n      * deserialize objects using specified JSON View (filter).\n      */\n     public ObjectReader readerWithView(Class<?> view) {\n-        return new ObjectReader(this, getDeserializationConfig().withView(view));\n+        return _newReader(getDeserializationConfig().withView(view));\n     }\n \n     /**\n      * @since 2.1\n      */\n     public ObjectReader reader(Base64Variant defaultBase64) {\n-        return new ObjectReader(this, getDeserializationConfig().with(defaultBase64));\n+        return _newReader(getDeserializationConfig().with(defaultBase64));\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectReader reader(ContextAttributes attrs) {\n-        return new ObjectReader(this, getDeserializationConfig().with(attrs));\n-    }\n-    \n+        return _newReader(getDeserializationConfig().with(attrs));\n+    }\n+\n     /*\n     /**********************************************************\n     /* Extended Public API: convenience type conversion\n     /**********************************************************\n      */\n-   \n+\n     /**\n      * Convenience method for doing two-step conversion from given value, into\n      * instance of given value type. This is functionality equivalent to first\n             }\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Internal methods for deserialization, overridable\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n     /**\n      * Constructor used by {@link ObjectMapper} for initial instantiation\n      */\n-    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config)\n-    {\n+    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config) {\n         this(mapper, config, null, null, null, null);\n     }\n \n \n     /*\n     /**********************************************************\n+    /* Methods sub-classes MUST override, used for constructing\n+    /* reader instances, (re)configuring parser instances\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _new(ObjectReader base, JsonFactory f) {\n+        return new ObjectReader(base, f);\n+    }\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _new(ObjectReader base, DeserializationConfig config) {\n+        return new ObjectReader(base, config);\n+    }\n+\n+    /**\n+     * Overridable factory method called by various \"withXxx()\" methods\n+     * \n+     * @since 2.5\n+     */\n+    protected ObjectReader _new(ObjectReader base, DeserializationConfig config,\n+            JavaType valueType, JsonDeserializer<Object> rootDeser, Object valueToUpdate,\n+            FormatSchema schema, InjectableValues injectableValues,\n+            DataFormatReaders dataFormatReaders) {\n+        return new ObjectReader(base, config, valueType, rootDeser,  valueToUpdate,\n+                 schema,  injectableValues, dataFormatReaders);\n+    }\n+\n+    /**\n+     * NOTE: changed from static to non-static in 2.5; unfortunate but\n+     * necessary change to support overridability\n+     */\n+    protected JsonToken _initForReading(JsonParser p) throws IOException\n+    {\n+        if (_schema != null) {\n+            p.setSchema(_schema);\n+        }\n+        /* First: must point to a token; if not pointing to one, advance.\n+         * This occurs before first read from JsonParser, as well as\n+         * after clearing of current token.\n+         */\n+        JsonToken t = p.getCurrentToken();\n+        if (t == null) { // and then we must get something...\n+            t = p.nextToken();\n+            if (t == null) {\n+                // Throw mapping exception, since it's failure to map, not an actual parsing problem\n+                throw JsonMappingException.from(p, \"No content to map due to end-of-input\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    /**\n+     * Alternative to {@link #_initForReading(JsonParser)} used in cases where reading\n+     * of multiple values means that we may or may not want to advance the stream,\n+     * but need to do other initialization.\n+     *<p>\n+     * Base implementation only sets configured {@link FormatSchema}, if any, on parser.\n+     * \n+     * @since 2.5\n+     */\n+    protected void _initForMultiRead(JsonParser p) throws IOException {\n+        if (_schema != null) {\n+            p.setSchema(_schema);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Life-cycle, fluent factory methods\n     /**********************************************************\n      */\n      */\n     public ObjectReader with(DeserializationFeature feature) {\n         return _with(_config.with(feature));\n-    }    \n+    }\n \n     /**\n      * Method for constructing a new reader instance that is configured\n     public ObjectReader withFeatures(DeserializationFeature... features) {\n         return _with(_config.withFeatures(features));\n     }    \n-    \n+\n     /**\n      * Method for constructing a new reader instance that is configured\n      * with specified feature disabled.\n      */\n     public ObjectReader without(DeserializationFeature feature) {\n         return _with(_config.without(feature)); \n-    }    \n+    }\n \n     /**\n      * Method for constructing a new reader instance that is configured\n      * with specified features disabled.\n      */\n     public ObjectReader without(DeserializationFeature first,\n-            DeserializationFeature... other)\n-    {\n+            DeserializationFeature... other) {\n         return _with(_config.without(first, other));\n     }    \n \n         if (_injectableValues == injectableValues) {\n             return this;\n         }\n-        return new ObjectReader(this, _config,\n+        return _new(this, _config,\n                 _valueType, _rootDeserializer, _valueToUpdate,\n                 _schema, injectableValues, _dataFormatReaders);\n     }\n         if (f == _parserFactory) {\n             return this;\n         }\n-        ObjectReader r = new ObjectReader(this, f);\n+        ObjectReader r = _new(this, f);\n         // Also, try re-linking, if possible...\n         if (f.getCodec() == null) {\n             f.setCodec(r);\n             return this;\n         }\n         _verifySchemaType(schema);\n-        return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n+        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                 schema, _injectableValues, _dataFormatReaders);\n     }\n \n         if (det != null) {\n             det = det.withType(valueType);\n         }\n-        return new ObjectReader(this, _config, valueType, rootDeser,\n+        return _new(this, _config, valueType, rootDeser,\n                 _valueToUpdate, _schema, _injectableValues, det);\n     }    \n \n         } else {\n             t = _valueType;\n         }\n-        return new ObjectReader(this, _config, t, _rootDeserializer, value,\n+        return _new(this, _config, t, _rootDeserializer, value,\n                 _schema, _injectableValues, _dataFormatReaders);\n     }\n \n      * \n      * @since 2.1\n      */\n-    public ObjectReader withFormatDetection(ObjectReader... readers)\n-    {\n+    public ObjectReader withFormatDetection(ObjectReader... readers) {\n         return withFormatDetection(new DataFormatReaders(readers));\n     }\n \n      * \n      * @since 2.1\n      */\n-    public ObjectReader withFormatDetection(DataFormatReaders readers)\n-    {\n-        return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n+    public ObjectReader withFormatDetection(DataFormatReaders readers) {\n+        return _new(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                 _schema, _injectableValues, readers);\n     }\n \n      * @since 2.3\n      */\n     public ObjectReader with(ContextAttributes attrs) {\n-        DeserializationConfig newConfig = _config.with(attrs);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.with(attrs));\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectReader withAttributes(Map<Object,Object> attrs) {\n-        DeserializationConfig newConfig = _config.withAttributes(attrs);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.withAttributes(attrs));\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectReader withAttribute(Object key, Object value) {\n-        DeserializationConfig newConfig = _config.withAttribute(key, value);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with( _config.withAttribute(key, value));\n     }\n \n     /**\n      * @since 2.3\n      */\n     public ObjectReader withoutAttribute(Object key) {\n-        DeserializationConfig newConfig = _config.withoutAttribute(key);\n-        return (newConfig == _config) ? this :  new ObjectReader(this, newConfig);\n+        return _with(_config.withoutAttribute(key));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable factory methods that sub-classes MUST override\n+    /**********************************************************\n+     */\n+    \n+    protected ObjectReader _with(DeserializationConfig newConfig) {\n+        if (newConfig == _config) {\n+            return this;\n+        }\n+        ObjectReader r = _new(this, newConfig);\n+        if (_dataFormatReaders != null) {\n+            r  = r.withFormatDetection(_dataFormatReaders.with(newConfig));\n+        }\n+        return r;\n     }\n     \n     /*\n     public JsonParser treeAsTokens(TreeNode n) {\n         return new TreeTraversingParser((JsonNode) n, this);\n     }\n-     /**\n-      * Convenience method that binds content read using given parser, using\n-      * configuration of this reader, except that content is bound as\n-      * JSON tree instead of configured root value type.\n-      *<p>\n-      * Note: if an object was specified with {@link #withValueToUpdate}, it\n-      * will be ignored.\n-      *<p>\n-      * NOTE: this method never tries to auto-detect format, since actual\n-      * (data-format specific) parser is given.\n-      */\n-     @SuppressWarnings(\"unchecked\")\n-     @Override\n-     public <T extends TreeNode> T readTree(JsonParser jp)\n-         throws IOException, JsonProcessingException\n-     {\n-         return (T) _bindAsTree(jp);\n-     }\n+\n+    /**\n+     * Convenience method that binds content read using given parser, using\n+     * configuration of this reader, except that content is bound as\n+     * JSON tree instead of configured root value type.\n+     *<p>\n+     * Note: if an object was specified with {@link #withValueToUpdate}, it\n+     * will be ignored.\n+     *<p>\n+     * NOTE: this method never tries to auto-detect format, since actual\n+     * (data-format specific) parser is given.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends TreeNode> T readTree(JsonParser jp)\n+            throws IOException, JsonProcessingException\n+    {\n+        return (T) _bindAsTree(jp);\n+    }\n      \n     @Override\n     public void writeTree(JsonGenerator jgen, TreeNode rootNode) {\n         if (_dataFormatReaders != null) {\n             _reportUndetectableSource(src);\n         }\n-        JsonParser jp = _parserFactory.createParser(src);\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        jp.nextToken();\n-        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n+        JsonParser p = _parserFactory.createParser(src);\n+        _initForMultiRead(p);\n+        p.nextToken();\n+        DeserializationContext ctxt = createDeserializationContext(p, _config);\n+        return new MappingIterator<T>(_valueType, p, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n     \n         if (_dataFormatReaders != null) {\n             _reportUndetectableSource(json);\n         }\n-        JsonParser jp = _parserFactory.createParser(json);\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        jp.nextToken();\n-        DeserializationContext ctxt = createDeserializationContext(jp, _config);\n-        return new MappingIterator<T>(_valueType, jp, ctxt,\n+        JsonParser p = _parserFactory.createParser(json);\n+        _initForMultiRead(p);\n+        p.nextToken();\n+        DeserializationContext ctxt = createDeserializationContext(p, _config);\n+        return new MappingIterator<T>(_valueType, p, ctxt,\n                 _findRootDeserializer(ctxt, _valueType), true, _valueToUpdate);\n     }\n \n      */\n \n     @Override\n-    public <T> T treeToValue(TreeNode n, Class<T> valueType)\n-        throws JsonProcessingException\n+    public <T> T treeToValue(TreeNode n, Class<T> valueType) throws JsonProcessingException\n     {\n         try {\n             return readValue(treeAsTokens(n), valueType);\n     }    \n     \n     @Override\n-    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException\n-    {\n+    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException {\n         throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n     }\n \n     /**\n      * Actual implementation of value reading+binding operation.\n      */\n-    protected Object _bind(JsonParser jp, Object valueToUpdate)\n-        throws IOException, JsonParseException, JsonMappingException\n+    protected Object _bind(JsonParser jp, Object valueToUpdate) throws IOException\n     {\n         /* First: may need to read the next token, to initialize state (either\n          * before first read from parser, or after previous token has been cleared)\n         return result;\n     }\n     \n-    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n+    protected Object _bindAndClose(JsonParser jp, Object valueToUpdate) throws IOException\n+    {\n         try {\n             Object result;\n             JsonToken t = _initForReading(jp);\n         }\n     }\n \n-    protected JsonNode _bindAsTree(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n+    protected JsonNode _bindAndCloseAsTree(JsonParser jp) throws IOException {\n+        try {\n+            return _bindAsTree(jp);\n+        } finally {\n+            try {\n+                jp.close();\n+            } catch (IOException ioe) { }\n+        }\n+    }\n+    \n+    protected JsonNode _bindAsTree(JsonParser jp) throws IOException\n     {\n         JsonNode result;\n         JsonToken t = _initForReading(jp);\n         return result;\n     }\n     \n-    protected JsonNode _bindAndCloseAsTree(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        if (_schema != null) {\n-            jp.setSchema(_schema);\n-        }\n-        try {\n-            return _bindAsTree(jp);\n-        } finally {\n-            try {\n-                jp.close();\n-            } catch (IOException ioe) { }\n-        }\n-    }\n-    \n     /**\n      * @since 2.1\n      */\n-    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p,\n-            Object valueToUpdate)\n-        throws IOException, JsonProcessingException\n-    {\n-        if (_schema != null) {\n-            p.setSchema(_schema);\n-        }\n+    protected <T> MappingIterator<T> _bindAndReadValues(JsonParser p, Object valueToUpdate) throws IOException\n+    {\n+        _initForMultiRead(p);\n         p.nextToken();\n         DeserializationContext ctxt = createDeserializationContext(p, _config);\n         return new MappingIterator<T>(_valueType, p, ctxt, \n                 _findRootDeserializer(ctxt, _valueType),\n                 true, _valueToUpdate);\n     }\n-    \n-    protected static JsonToken _initForReading(JsonParser jp)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        /* First: must point to a token; if not pointing to one, advance.\n-         * This occurs before first read from JsonParser, as well as\n-         * after clearing of current token.\n-         */\n-        JsonToken t = jp.getCurrentToken();\n-        if (t == null) { // and then we must get something...\n-            t = jp.nextToken();\n-            if (t == null) {\n-                /* [JACKSON-546] Throw mapping exception, since it's failure to map,\n-                 *   not an actual parsing problem\n-                 */\n-                throw JsonMappingException.from(jp, \"No content to map due to end-of-input\");\n-            }\n-        }\n-        return t;\n-    }\n-\n+\n+    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n+            JavaType rootType, JsonDeserializer<Object> deser) throws IOException\n+    {\n+        String expName = _config.getRootName();\n+        if (expName == null) {\n+            PropertyName pname = _rootNames.findRootName(rootType, _config);\n+            expName = pname.getSimpleName();\n+        }\n+        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n+            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n+            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        String actualName = jp.getCurrentName();\n+        if (!expName.equals(actualName)) {\n+            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n+                    +expName+\"') for type \"+rootType);\n+        }\n+        // ok, then move to value itself....\n+        jp.nextToken();\n+        Object result;\n+        if (_valueToUpdate == null) {\n+            result = deser.deserialize(jp, ctxt);\n+        } else {\n+            deser.deserialize(jp, ctxt, _valueToUpdate);\n+            result = _valueToUpdate;                    \n+        }\n+        // and last, verify that we now get matching END_OBJECT\n+        if (jp.nextToken() != JsonToken.END_OBJECT) {\n+            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n+                    +expName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        return result;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, locating deserializers etc\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Method called to locate deserializer for the passed root-level value.\n      */\n      * by configuration. Method also is NOT to throw an exception if\n      * access fails.\n      */\n-    protected JsonDeserializer<Object> _prefetchRootDeserializer(\n-            DeserializationConfig config, JavaType valueType)\n+    protected JsonDeserializer<Object> _prefetchRootDeserializer(DeserializationConfig config, JavaType valueType)\n     {\n         if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n             return null;\n         }\n         return deser;\n     }\n-    \n-    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n-            JavaType rootType, JsonDeserializer<Object> deser)\n-        throws IOException, JsonParseException, JsonMappingException\n-    {\n-        String expName = _config.getRootName();\n-        if (expName == null) {\n-            PropertyName pname = _rootNames.findRootName(rootType, _config);\n-            expName = pname.getSimpleName();\n-        }\n-        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n-            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        String actualName = jp.getCurrentName();\n-        if (!expName.equals(actualName)) {\n-            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"\n-                    +expName+\"') for type \"+rootType);\n-        }\n-        // ok, then move to value itself....\n-        jp.nextToken();\n-        Object result;\n-        if (_valueToUpdate == null) {\n-            result = deser.deserialize(jp, ctxt);\n-        } else {\n-            deser.deserialize(jp, ctxt, _valueToUpdate);\n-            result = _valueToUpdate;                    \n-        }\n-        // and last, verify that we now get matching END_OBJECT\n-        if (jp.nextToken() != JsonToken.END_OBJECT) {\n-            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n-                    +expName+\"'), but \"+jp.getCurrentToken());\n-        }\n-        return result;\n-    }\n \n     /*\n     /**********************************************************\n         // 04-Jan-2010, tatu: we do actually need the provider too... (for polymorphic deser)\n         return _context.createInstance(cfg, jp, _injectableValues);\n     }\n-    \n-    protected ObjectReader _with(DeserializationConfig newConfig) {\n-        if (newConfig == _config) {\n-            return this;\n-        }\n-        if (_dataFormatReaders != null) {\n-            return new ObjectReader(this, newConfig)\n-                .withFormatDetection(_dataFormatReaders.with(newConfig));\n-        }\n-        return new ObjectReader(this, newConfig);\n-    }\n \n     protected void _reportUndetectableSource(Object src) throws JsonProcessingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n public abstract class SerializerProvider\n     extends DatabindContext\n {\n-    @Deprecated // since 2.3, not used by anything it seems\n-    protected final static JavaType TYPE_OBJECT = TypeFactory.defaultInstance().uncheckedSimpleType(Object.class);\n-\n     /**\n      * Setting for determining whether mappings for \"unknown classes\" should be\n      * cached for faster resolution. Usually this isn't needed, but maybe it\n      *   finding any serializer\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public JsonSerializer<Object> findValueSerializer(Class<?> valueType,\n-            BeanProperty property)\n+    public JsonSerializer<Object> findValueSerializer(Class<?> valueType, BeanProperty property)\n         throws JsonMappingException\n     {\n         // Fast lookup from local lookup thingy works?\n                 if (ser == null) {\n                     // If neither, must create\n                     ser = _createAndCacheUntypedSerializer(valueType);\n-                    // Not found? Must use the unknown type serializer\n-                    /* Couldn't create? Need to return the fallback serializer, which\n-                     * most likely will report an error: but one question is whether\n-                     * we should cache it?\n-                     */\n+                    // Not found? Must use the unknown type serializer, which will report error later on\n                     if (ser == null) {\n                         ser = getUnknownTypeSerializer(valueType);\n                         // Should this be added to lookups?\n     public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property)\n         throws JsonMappingException\n     {\n-        // Fast lookup from local lookup thingy works?\n+        // (see comments from above method)\n         JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n         if (ser == null) {\n-            // If not, maybe shared map already has it?\n             ser = _serializerCache.untypedValueSerializer(valueType);\n             if (ser == null) {\n-                // If neither, must create\n                 ser = _createAndCacheUntypedSerializer(valueType);\n-                // Not found? Must use the unknown type serializer\n-                /* Couldn't create? Need to return the fallback serializer, which\n-                 * most likely will report an error: but one question is whether\n-                 * we should cache it?\n-                 */\n                 if (ser == null) {\n                     ser = getUnknownTypeSerializer(valueType.getRawClass());\n-                    // Should this be added to lookups?\n                     if (CACHE_UNKNOWN_MAPPINGS) {\n                         _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n                     }\n         return (JsonSerializer<Object>) handleSecondaryContextualization(ser, property);\n     }\n \n+    /**\n+     * Method variant used when we do NOT want contextualization to happen; it will need\n+     * to be handled at a later point, but caller wants to be able to do that\n+     * as needed; sometimes to avoid infinite loops\n+     * \n+     * @since 2.5\n+     */\n+    public JsonSerializer<Object> findValueSerializer(Class<?> valueType) throws JsonMappingException\n+    {\n+        // (see comments from above method)\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType));\n+                if (ser == null) {\n+                    ser = _createAndCacheUntypedSerializer(valueType);\n+                    if (ser == null) {\n+                        ser = getUnknownTypeSerializer(valueType);\n+                        if (CACHE_UNKNOWN_MAPPINGS) {\n+                            _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return ser;\n+    }\n+\n+    /**\n+     * Method variant used when we do NOT want contextualization to happen; it will need\n+     * to be handled at a later point, but caller wants to be able to do that\n+     * as needed; sometimes to avoid infinite loops\n+     * \n+     * @since 2.5\n+     */\n+    public JsonSerializer<Object> findValueSerializer(JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        // (see comments from above method)\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                ser = _createAndCacheUntypedSerializer(valueType);\n+                if (ser == null) {\n+                    ser = getUnknownTypeSerializer(valueType.getRawClass());\n+                    if (CACHE_UNKNOWN_MAPPINGS) {\n+                        _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                    }\n+                }\n+            }\n+        }\n+        return ser;\n+    }\n+    \n     /**\n      * Similar to {@link #findValueSerializer(JavaType, BeanProperty)}, but used\n      * when finding \"primary\" property value serializer (one directly handling\n         return _unknownTypeSerializer;\n     }\n \n+    /**\n+     * Helper method called to see if given serializer is considered to be\n+     * something returned by {@link #getUnknownTypeSerializer}, that is, something\n+     * for which no regular serializer was found or constructed.\n+     * \n+     * @since 2.5\n+     */\n+    public boolean isUnknownTypeSerializer(JsonSerializer<?> ser) {\n+        return (ser == _unknownTypeSerializer) || (ser == null);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Methods for creating instances based on annotations\n     /**********************************************************\n      */\n \n-    /**\n-     * @deprecated Since 2.3 (and to be removed from 2.4); use\n-     *   {@link #handlePrimaryContextualization} or {@link #handleSecondaryContextualization}\n-     *   instead\n-     */\n-    @Deprecated\n-    public JsonSerializer<?> handleContextualization(JsonSerializer<?> ser,\n-            BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        return handleSecondaryContextualization(ser, property);\n-    }\n-    \n     /**\n      * Method called for primary property serializers (ones\n      * directly created to serialize values of a POJO property),\n      * @return Serializer if one can be found, null if not.\n      */\n     protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType)\n-\t\tthrows JsonMappingException\n+        throws JsonMappingException\n     {        \n         // Fast lookup from local lookup thingy works?\n         JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(runtimeType);\n-        if (ser != null) {\n-            return ser;\n-        }\n-        // If not, maybe shared map already has it?\n-        ser = _serializerCache.untypedValueSerializer(runtimeType);\n-        if (ser != null) {\n-            return ser;\n-        }\n-        return _createAndCacheUntypedSerializer(runtimeType);\n+        if (ser == null) {\n+            // If not, maybe shared map already has it?\n+            ser = _serializerCache.untypedValueSerializer(runtimeType);\n+            if (ser == null) {\n+                ser = _createAndCacheUntypedSerializer(runtimeType);\n+                /* 18-Sep-2014, tatu: This is unfortunate patch over related change\n+                 *    that pushes creation of \"unknown type\" serializer deeper down\n+                 *    in BeanSerializerFactory; as a result, we need to \"undo\" creation\n+                 *    here.\n+                 */\n+                if (isUnknownTypeSerializer(ser)) {\n+                    return null;\n+                }\n+            }\n+        }\n+        return ser;\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/annotation/JsonNaming.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotation/JsonNaming.java\n @com.fasterxml.jackson.annotation.JacksonAnnotation\n public @interface JsonNaming\n {\n-    public Class<? extends PropertyNamingStrategy> value();\n+    /**\n+     * @return Type of {@link PropertyNamingStrategy} to use, if any; default value of\n+     *    <code>PropertyNamingStrategy.class</code> means \"no strategy specified\"\n+     *    (and may also be used for overriding to remove otherwise applicable\n+     *    naming strategy)\n+     */\n+    public Class<? extends PropertyNamingStrategy> value() default PropertyNamingStrategy.class;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n      * \n      * @since 2.3\n      */\n-    public static AbstractDeserializer constructForNonPOJO(BeanDescription beanDesc)\n-    {\n+    public static AbstractDeserializer constructForNonPOJO(BeanDescription beanDesc) {\n         return new AbstractDeserializer(beanDesc);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n import java.lang.reflect.Method;\n import java.util.*;\n import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.JsonLocation;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n import com.fasterxml.jackson.databind.deser.std.*;\n+import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n     private final static Class<?> CLASS_STRING = String.class;\n     private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n     private final static Class<?> CLASS_ITERABLE = Iterable.class;\n+    private final static Class<?> CLASS_MAP_ENTRY = Map.Entry.class;\n \n     /**\n      * We need a placeholder for creator properties that don't have name\n         VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n         vchecker = intr.findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n \n+        /* 24-Sep-2014, tatu: Tricky part first; need to merge resolved property information\n+         *  (which has creator parameters sprinkled around) with actual creator\n+         *  declarations (which are needed to access creator annotation, amongst other things).\n+         *  Easiest to combine that info first, then pass it to remaining processing.\n+         */\n+        Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorDefs = _findCreatorsFromProperties(ctxt,\n+                beanDesc);\n+        \n         /* Important: first add factory methods; then constructors, so\n          * latter can override former!\n          */\n-        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators);\n+        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n         // constructors only usable on concrete types:\n         if (beanDesc.getType().isConcrete()) {\n-            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators);\n+            _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators, creatorDefs);\n         }\n         return creators.constructValueInstantiator(config);\n     }\n \n+    protected Map<AnnotatedWithParams,BeanPropertyDefinition[]> _findCreatorsFromProperties(DeserializationContext ctxt,\n+            BeanDescription beanDesc) throws JsonMappingException\n+    {\n+        Map<AnnotatedWithParams,BeanPropertyDefinition[]> result = Collections.emptyMap();\n+        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n+            Iterator<AnnotatedParameter> it = propDef.getConstructorParameters();\n+            while (it.hasNext()) {\n+                AnnotatedParameter param = it.next();\n+                AnnotatedWithParams owner = param.getOwner();\n+                BeanPropertyDefinition[] defs = result.get(owner);\n+                final int index = param.getIndex();\n+                \n+                if (defs == null) {\n+                    if (result.isEmpty()) {\n+                        result = new LinkedHashMap<AnnotatedWithParams,BeanPropertyDefinition[]>();\n+                    }\n+                    defs = new BeanPropertyDefinition[owner.getParameterCount()];\n+                    result.put(owner, defs);\n+                } else {\n+                    if (defs[index] != null) {\n+                        throw new IllegalStateException(\"Conflict: parameter #\"+index+\" of \"+owner\n+                                +\" bound to more than one property; \"+defs[index]+\" vs \"+propDef);\n+                    }\n+                }\n+                defs[index] = propDef;\n+            }\n+        }\n+        return result;\n+    }\n+    \n     public ValueInstantiator _valueInstantiatorInstance(DeserializationConfig config,\n             Annotated annotated, Object instDef)\n         throws JsonMappingException\n         return (ValueInstantiator) ClassUtil.createInstance(instClass,\n                 config.canOverrideAccessModifiers());\n     }\n+\n+    @Deprecated // since 2.5.0, removed from 2.6.0\n+    protected void _addDeserializerConstructors(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+            AnnotationIntrospector intr, CreatorCollector creators)\n+        throws JsonMappingException\n+    {\n+        _addDeserializerConstructors(ctxt, beanDesc, vchecker, intr, creators,\n+                Collections.<AnnotatedWithParams,BeanPropertyDefinition[]>emptyMap());\n+    }\n     \n     protected void _addDeserializerConstructors\n         (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n-         AnnotationIntrospector intr, CreatorCollector creators)\n-        throws JsonMappingException\n-    {\n-        /* First things first: the \"default constructor\" (zero-arg\n-         * constructor; whether implicit or explicit) is NOT included\n-         * in list of constructors, so needs to be handled separately.\n-         */\n+         AnnotationIntrospector intr, CreatorCollector creators,\n+         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n+        throws JsonMappingException\n+    {\n+        // First things first: the \"default constructor\" (zero-arg\n+        // constructor; whether implicit or explicit) is NOT included\n+        // in list of constructors, so needs to be handled separately.\n         AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n         if (defaultCtor != null) {\n             if (!creators.hasDefaultCreator() || intr.hasCreatorAnnotation(defaultCtor)) {\n                 creators.setDefaultCreator(defaultCtor);\n             }\n         }\n-\n-        PropertyName[] ctorPropNames = null;\n-        AnnotatedConstructor propertyCtor = null;\n-        for (BeanPropertyDefinition propDef : beanDesc.findProperties()) {\n-            if (propDef.getConstructorParameter() != null) {\n-                AnnotatedParameter param = propDef.getConstructorParameter();\n-                AnnotatedWithParams owner = param.getOwner();\n-                if (owner instanceof AnnotatedConstructor) {\n-                    if (propertyCtor == null) {\n-                        propertyCtor = (AnnotatedConstructor) owner;\n-                        ctorPropNames = new PropertyName[propertyCtor.getParameterCount()];\n-                    }\n-                    ctorPropNames[param.getIndex()] = propDef.getFullName();\n-                }\n-            }\n-        }\n-\n         for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n-            int argCount = ctor.getParameterCount();\n-            boolean isCreator = intr.hasCreatorAnnotation(ctor) || ctor == propertyCtor;\n-            boolean isVisible =  vchecker.isCreatorVisible(ctor);\n-            // some single-arg constructors (String, number) are auto-detected\n+            final boolean isCreator = intr.hasCreatorAnnotation(ctor);\n+            BeanPropertyDefinition[] propDefs = creatorParams.get(ctor);\n+            final int argCount = ctor.getParameterCount();\n+\n+            // some single-arg factory methods (String, number) are auto-detected\n             if (argCount == 1) {\n-                PropertyName name = (ctor == propertyCtor) ? ctorPropNames[0] : null;\n-                _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n-                        ctor, isCreator, isVisible, name);\n+                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[0];\n+                boolean hasExplicitName = (propDef != null) && propDef.isExplicitlyNamed();\n+                Object injectId = intr.findInjectableValueId(ctor.getParameter(0));\n+\n+                if (hasExplicitName || (injectId != null)) {\n+                    CreatorProperty[] properties = new CreatorProperty[1];\n+                    PropertyName name = (propDef == null) ? null : propDef.getFullName();\n+                    properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, ctor.getParameter(0), injectId);\n+                    creators.addPropertyCreator(ctor, properties);\n+                } else {\n+                    /*boolean added = */ _handleSingleArgumentConstructor(ctxt, beanDesc, vchecker, intr, creators,\n+                            ctor, isCreator,\n+                            vchecker.isCreatorVisible(ctor));\n+                }\n+                // regardless, fully handled\n                 continue;\n             }\n-            if (!isCreator && !isVisible) {\n-                continue;\n-            }\n-\n-            // [JACKSON-541] improved handling a bit so:\n-            // 2 or more args; all params must have name annotations\n-            // ... or @JacksonInject (or equivalent)\n-            /* [JACKSON-711] One more possibility; can have 1 or more injectables, and\n-             * exactly one non-annotated parameter: if so, it's still delegating.\n-             */\n-            AnnotatedParameter nonAnnotatedParam = null;\n-            int namedCount = 0;\n-            int injectCount = 0;\n+\n+            // 2 or more args; all params must have names or be injectable\n+            AnnotatedParameter nonAnnotatedParam = null;            \n             CreatorProperty[] properties = new CreatorProperty[argCount];\n+            int explicitNameCount = 0;\n+            int implicitNameCount = 0;\n+            int injectCount = 0;            \n             for (int i = 0; i < argCount; ++i) {\n-                AnnotatedParameter param = ctor.getParameter(i);\n-                PropertyName name = null;\n-                if (ctor == propertyCtor) {\n-                    name = ctorPropNames[i];\n-                }\n-                if (name == null) {\n-                    name = _findParamName(param, intr);\n-                }\n+                final AnnotatedParameter param = ctor.getParameter(i);\n+                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                 Object injectId = intr.findInjectableValueId(param);\n-                if (name != null && name.hasSimpleName()) {\n-                    ++namedCount;\n+                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n+                if (propDef != null && propDef.isExplicitlyNamed()) {\n+                    ++explicitNameCount;\n                     properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else if (injectId != null) { // injectable\n+                    continue;\n+                }\n+                if (injectId != null) {\n                     ++injectCount;\n                     properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else {\n-                    NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n-                    if (unwrapper != null) { // [Issue#265]: allow unwrapped properties\n-                        properties[i] = constructCreatorProperty(ctxt, beanDesc,\n-                                UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n-                        ++namedCount;\n-                    } else {\n-                        if (nonAnnotatedParam == null) {\n-                            nonAnnotatedParam = param;\n-                        }\n+                    continue;\n+                }\n+                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n+                if (unwrapper != null) {\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n+                    ++explicitNameCount;\n+                    continue;\n+                }\n+                // One more thing: implicit names are ok iff ctor has creator annotation\n+                if (isCreator) {\n+                    if (name != null && !name.isEmpty()) {\n+                        ++implicitNameCount;\n+                        properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n+                        continue;\n                     }\n                 }\n-            }\n-\n+                if (nonAnnotatedParam == null) {\n+                    nonAnnotatedParam = param;\n+                }\n+            }\n+\n+            final int namedCount = explicitNameCount + implicitNameCount;\n             // Ok: if named or injectable, we have more work to do\n-            if (isCreator || namedCount > 0 || injectCount > 0) {\n+            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                 // simple case; everything covered:\n                 if ((namedCount + injectCount) == argCount) {\n                     creators.addPropertyCreator(ctor, properties);\n-                } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) {\n+                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                     // [712] secondary: all but one injectable, one un-annotated (un-named)\n                     creators.addDelegatingCreator(ctor, properties);\n-                } else { // otherwise, record the incomplete parameter for later error messaging.\n-                    creators.addIncompeteParameter(nonAnnotatedParam);\n+                } else { // otherwise, epic fail\n+                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()\n+                            +\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-parameter constructor annotated as Creator\");\n                 }\n             }\n         }\n     protected boolean _handleSingleArgumentConstructor(DeserializationContext ctxt,\n             BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n             AnnotationIntrospector intr, CreatorCollector creators,\n-            AnnotatedConstructor ctor, boolean isCreator, boolean isVisible,\n-            PropertyName name)\n-        throws JsonMappingException\n-    {\n-        // note: if we do have parameter name, it'll be \"property constructor\":\n-        AnnotatedParameter param = ctor.getParameter(0);\n-        if (name == null) {\n-            name = _findParamName(param, intr);\n-        }\n-        Object injectId = intr.findInjectableValueId(param);\n-    \n-        if ((injectId != null) || (name != null && name.hasSimpleName())) { // property-based\n-            // We know there's a name and it's only 1 parameter.\n-            CreatorProperty[] properties = new CreatorProperty[1];\n-            properties[0] = constructCreatorProperty(ctxt, beanDesc, name, 0, param, injectId);\n-            creators.addPropertyCreator(ctor, properties);\n-            return true;\n-        }\n-    \n+            AnnotatedConstructor ctor, boolean isCreator, boolean isVisible)\n+        throws JsonMappingException\n+    {\n         // otherwise either 'simple' number, String, or general delegate:\n         Class<?> type = ctor.getRawParameterType(0);\n         if (type == String.class) {\n         return false;\n     }\n \n+    @Deprecated // since 2.5, remove from 2.6\n+    protected void _addDeserializerFactoryMethods(DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+            AnnotationIntrospector intr, CreatorCollector creators)\n+        throws JsonMappingException\n+    {\n+        _addDeserializerFactoryMethods(ctxt, beanDesc, vchecker, intr, creators,\n+                Collections.<AnnotatedWithParams,BeanPropertyDefinition[]>emptyMap());\n+    }\n+\n     protected void _addDeserializerFactoryMethods\n         (DeserializationContext ctxt, BeanDescription beanDesc, VisibilityChecker<?> vchecker,\n-         AnnotationIntrospector intr, CreatorCollector creators)\n+         AnnotationIntrospector intr, CreatorCollector creators,\n+         Map<AnnotatedWithParams,BeanPropertyDefinition[]> creatorParams)\n         throws JsonMappingException\n     {\n         final DeserializationConfig config = ctxt.getConfig();\n         for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n-            boolean isCreator = intr.hasCreatorAnnotation(factory);\n-            int argCount = factory.getParameterCount();\n+            final boolean isCreator = intr.hasCreatorAnnotation(factory);\n+            final int argCount = factory.getParameterCount();\n             // zero-arg methods must be annotated; if so, are \"default creators\" [JACKSON-850]\n             if (argCount == 0) {\n                 if (isCreator) {\n                 }\n                 continue;\n             }\n+\n+            final BeanPropertyDefinition[] propDefs = creatorParams.get(factory);\n             // some single-arg factory methods (String, number) are auto-detected\n             if (argCount == 1) {\n-                AnnotatedParameter param = factory.getParameter(0);\n-                PropertyName pn = _findParamName(param, intr);\n-                String name = (pn == null) ? null : pn.getSimpleName();\n-                Object injectId = intr.findInjectableValueId(param);\n-\n-                if ((injectId == null) && (name == null || name.length() == 0)) { // not property based\n-                    _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n+                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[0];\n+                boolean hasExplicitName = (propDef != null) && propDef.isExplicitlyNamed();\n+                final Object injectId = intr.findInjectableValueId(factory.getParameter(0));\n+                if ((injectId == null) && !hasExplicitName) { // not property based\n+                    /*boolean added=*/ _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n                             factory, isCreator);\n                     // otherwise just ignored\n                     continue;\n                 }\n                 // fall through if there's name\n             } else {\n-                // more than 2 args, must be @JsonCreator\n-                if (!intr.hasCreatorAnnotation(factory)) {\n+                // more than 2 args, must have @JsonCreator\n+                if (!isCreator) {\n                     continue;\n                 }\n             }\n             // 1 or more args; all params must have name annotations\n             AnnotatedParameter nonAnnotatedParam = null;            \n             CreatorProperty[] properties = new CreatorProperty[argCount];\n-            int namedCount = 0;\n-            int injectCount = 0;            \n+            int implicitNameCount = 0;\n+            int explicitNameCount = 0;\n+            int injectCount = 0;\n+            \n             for (int i = 0; i < argCount; ++i) {\n-                AnnotatedParameter param = factory.getParameter(i);\n-                PropertyName name = _findParamName(param, intr);\n+                final AnnotatedParameter param = factory.getParameter(i);\n+                BeanPropertyDefinition propDef = (propDefs == null) ? null : propDefs[i];\n                 Object injectId = intr.findInjectableValueId(param);\n-                if (name != null && name.hasSimpleName()) {\n-                    ++namedCount;\n+                final PropertyName name = (propDef == null) ? null : propDef.getFullName();\n+\n+                if (propDef != null && propDef.isExplicitlyNamed()) {\n+                    ++explicitNameCount;\n                     properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else if (injectId != null) {\n+                    continue;\n+                }\n+                if (injectId != null) {\n                     ++injectCount;\n                     properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n-                } else {\n-                    NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n-                    if (unwrapper != null) {\n-                        properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n-                        ++namedCount;\n-                    } else {\n-                        if (nonAnnotatedParam == null) {\n-                            nonAnnotatedParam = param;\n-                        }\n+                    continue;\n+                }\n+                NameTransformer unwrapper = intr.findUnwrappingNameTransformer(param);\n+                if (unwrapper != null) {\n+                    properties[i] = constructCreatorProperty(ctxt, beanDesc, UNWRAPPED_CREATOR_PARAM_NAME, i, param, null);\n+                    ++implicitNameCount;\n+                    continue;\n+                }\n+                // One more thing: implicit names are ok iff ctor has creator annotation\n+                if (isCreator) {\n+                    if (name != null && !name.isEmpty()) {\n+                        ++implicitNameCount;\n+                        properties[i] = constructCreatorProperty(ctxt, beanDesc, name, i, param, injectId);\n+                        continue;\n                     }\n                 }\n-            }\n-\n+                /* 25-Sep-2014, tatu: Actually, we may end up \"losing\" naming due to higher-priority constructor\n+                 *  (see TestCreators#testConstructorCreator() test). And just to avoid running into that problem,\n+                 *  let's add one more work around\n+                 */\n+                /*\n+                PropertyName name2 = _findExplicitParamName(param, intr);\n+                if (name2 != null && !name2.isEmpty()) {\n+                    // Hmmh. Ok, fine. So what are we to do with it... ?\n+                    // For now... skip. May need to revisit this, should this become problematic\n+                    continue main_loop;\n+                }\n+                */\n+                if (nonAnnotatedParam == null) {\n+                    nonAnnotatedParam = param;\n+                }\n+            }\n+            final int namedCount = explicitNameCount + implicitNameCount;\n+            \n             // Ok: if named or injectable, we have more work to do\n-            if (isCreator || namedCount > 0 || injectCount > 0) {\n+            if (isCreator || explicitNameCount > 0 || injectCount > 0) {\n                 // simple case; everything covered:\n                 if ((namedCount + injectCount) == argCount) {\n                     creators.addPropertyCreator(factory, properties);\n-                } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) {\n+                } else if ((explicitNameCount == 0) && ((injectCount + 1) == argCount)) {\n                     // [712] secondary: all but one injectable, one un-annotated (un-named)\n                     creators.addDelegatingCreator(factory, properties);\n                 } else { // otherwise, epic fail\n             }\n             return true;\n         }\n-        if (intr.hasCreatorAnnotation(factory)) {\n+        if (isCreator) {\n             creators.addDelegatingCreator(factory, null);\n             return true;\n         }\n         }\n         return prop;\n     }\n-\n+    \n     protected PropertyName _findParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n     {\n         if (param != null && intr != null) {\n         }\n         return null;\n     }\n+\n+    protected PropertyName _findExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n+    {\n+        if (param != null && intr != null) {\n+            return intr.findNameForDeserialization(param);\n+        }\n+        return null;\n+    }\n+\n+    protected PropertyName _findImplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n+    {\n+        String str = intr.findImplicitPropertyName(param);\n+        if (str != null && !str.isEmpty()) {\n+            return new PropertyName(str);\n+        }\n+        return null;\n+    }\n+    \n+    protected boolean _hasExplicitParamName(AnnotatedParameter param, AnnotationIntrospector intr)\n+    {\n+        if (param != null && intr != null) {\n+            PropertyName n = intr.findNameForDeserialization(param);\n+            return (n != null) && n.hasSimpleName();\n+        }\n+        return false;\n+    }\n     \n     /*\n     /**********************************************************\n         \n         // Very first thing: is deserializer hard-coded for elements?\n         JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n-        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n+        // Then optional type info: if type has been resolved, we may already know type deserializer:\n         TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n         // but if not, may still be possible to find:\n         if (elemTypeDeser == null) {\n         return deser;\n     }\n \n-    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n-                    beanDesc, elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-    \n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl: Collection(-like) deserializers\n         }\n         return (CollectionType) config.constructSpecializedType(type, collectionClass);\n     }\n-\n-    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n-                    elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n     \n     // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n     @Override\n         return deser;\n     }\n \n-    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n-                    elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-\n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl: Map(-like) deserializers\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public JsonDeserializer<?> createMapDeserializer(DeserializationContext ctxt,\n             MapType type, BeanDescription beanDesc)\n         return deser;\n     }\n \n-    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            KeyDeserializer keyDeserializer,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n-                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n-            DeserializationConfig config, BeanDescription beanDesc,\n-            KeyDeserializer keyDeserializer,\n-            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n-                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n-    \n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl: Enum deserializers\n         }\n         return deser;\n     }\n-\n-    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n-    }\n     \n     /*\n     /**********************************************************\n             return custom;\n         }\n         return JsonNodeDeserializer.getDeserializer(nodeClass);\n-    }\n-\n-    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n-            if (deser != null) {\n-                return deser;\n-            }\n-        }\n-        return null;\n     }\n     \n     /*\n         return b.buildTypeDeserializer(config, baseType, subtypes);\n     }\n \n+    /**\n+     * Overridable method called after checking all other types.\n+     * \n+     * @since 2.2\n+     */\n+    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt,\n+            JavaType type, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JsonDeserializerFactory impl (partial): key deserializers\n         if (rawType == CLASS_ITERABLE) {\n             // [Issue#199]: Can and should 'upgrade' to a Collection type:\n             TypeFactory tf = ctxt.getTypeFactory();\n-            JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType();\n+            JavaType[] tps = tf.findTypeParameters(type, CLASS_ITERABLE);\n+            JavaType elemType = (tps == null || tps.length != 1) ? TypeFactory.unknownType() : tps[0];\n             CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n             // Should we re-introspect beanDesc? For now let's not...\n             return createCollectionDeserializer(ctxt, ct, beanDesc);\n+        }\n+        if (rawType == CLASS_MAP_ENTRY) {\n+            final DeserializationConfig config = ctxt.getConfig();\n+            TypeFactory tf = ctxt.getTypeFactory();\n+            JavaType[] tps = tf.findTypeParameters(type, CLASS_MAP_ENTRY);\n+            JavaType kt, vt;\n+            if (tps == null || tps.length != 2) {\n+                kt = vt = TypeFactory.unknownType();\n+            } else {\n+                kt = tps[0];\n+                vt = tps[1];\n+            }\n+            TypeDeserializer vts = (TypeDeserializer) vt.getTypeHandler();\n+            if (vts == null) {\n+                vts = findTypeDeserializer(config, vt);\n+            }\n+            JsonDeserializer<Object> valueDeser = vt.getValueHandler();\n+            KeyDeserializer keyDes = (KeyDeserializer) kt.getValueHandler();\n+            return new MapEntryDeserializer(type, keyDes, valueDeser, vts);\n         }\n         String clsName = rawType.getName();\n         if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n         if (rawType == TokenBuffer.class) {\n             return new TokenBufferDeserializer();\n         }\n+        if (AtomicReference.class.isAssignableFrom(rawType)) {\n+            // Must find parameterization\n+            TypeFactory tf = ctxt.getTypeFactory();\n+            JavaType[] params = tf.findTypeParameters(type, AtomicReference.class);\n+            JavaType referencedType;\n+            if (params == null || params.length < 1) { // untyped (raw)\n+                referencedType = TypeFactory.unknownType();\n+            } else {\n+                referencedType = params[0];\n+            }\n+            TypeDeserializer vts = findTypeDeserializer(ctxt.getConfig(), referencedType);\n+            BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);\n+            JsonDeserializer<?> deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());\n+            return new AtomicReferenceDeserializer(referencedType, vts, deser);\n+        }\n+        JsonDeserializer<?> deser = findOptionalStdDeserializer(ctxt, type, beanDesc);\n+        if (deser != null) {\n+            return deser;\n+        }\n         return JdkDeserializers.find(rawType, clsName);\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Helper methods, finding custom deserializers\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config,\n+                    beanDesc, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n+            if (deser != null) {\n+                return (JsonDeserializer<Object>) deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, beanDesc,\n+                    elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, beanDesc,\n+                    elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, beanDesc,\n+                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n+            DeserializationConfig config, BeanDescription beanDesc,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, beanDesc,\n+                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, beanDesc);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods, value/content/key type introspection\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n     @SuppressWarnings(\"resource\")\n     protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n-    { \n+    {\n         final PropertyBasedCreator creator = _propertyBasedCreator;\n         PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt, _objectIdReader);\n         \n             unknown.writeFieldName(propName);\n             unknown.copyCurrentStructure(jp);\n         }\n-\n+        \n         // We hit END_OBJECT, so:\n         Object bean;\n         try {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n     implements ContextualDeserializer, ResolvableDeserializer,\n         java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = 2960120955735322578L;\n+    private static final long serialVersionUID = 1;\n \n     protected final static PropertyName TEMP_PROPERTY_NAME = new PropertyName(\"#temporary-name\");\n \n      * to use have been successfully resolved.\n      */\n     final protected BeanPropertyMap _beanProperties;\n-    \n+\n     /**\n      * List of {@link ValueInjector}s, if any injectable values are\n      * expected by the bean; otherwise null.\n      * and fields, but not ones passed through constructor parameters.\n      */\n     final protected ValueInjector[] _injectables;\n-    \n+\n     /**\n      * Fallback setter used for handling any properties that are not\n      * mapped to regular setters. If setter is not null, it will be\n                 ;\n     }\n \n-    protected BeanDeserializerBase(BeanDeserializerBase src)\n-    {\n+    protected BeanDeserializerBase(BeanDeserializerBase src) {\n         this(src, src._ignoreAllUnknown);\n     }\n \n             }\n             JsonDeserializer<Object> dd = findDeserializer(ctxt, delegateType, property);\n             if (td != null) {\n+                td = td.forProperty(property);\n                 dd = new TypeWrappedDeserializer(td, dd);\n             }\n             _delegateDeserializer = dd;\n      * buffering in some cases, but usually just a simple lookup to ensure\n      * that ordering is correct.\n      */\n-    protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException\n-    {\n+    protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt) throws IOException {\n         return deserializeFromObject(jp, ctxt);\n     }\n     \n                 wrapInstantiationProblem(e, ctxt);\n             }\n         } else if (ctxt.isEnabled(DeserializationFeature.UNWRAP_SINGLE_VALUE_ARRAYS)) {\n-            jp.nextToken();\n+            JsonToken t = jp.nextToken();\n+            if (t == JsonToken.END_ARRAY && ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n+                return null;\n+            }\n             final Object value = deserialize(jp, ctxt);\n             if (jp.nextToken() != JsonToken.END_ARRAY) {\n                 throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \n                         \"Attempted to unwrap single value array for single '\" + _valueClass.getName() + \"' value but there was more than a single value in the array\");\n             }\n             return value;\n-        }\n-        throw ctxt.mappingException(getBeanClass());\n+        } else if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n+            JsonToken t = jp.nextToken();\n+            if (t == JsonToken.END_ARRAY) {\n+                return null;\n+            }\n+            throw ctxt.mappingException(handledType(), JsonToken.START_ARRAY);\n+        }\n+        throw ctxt.mappingException(handledType());\n     }\n \n     public Object deserializeFromEmbedded(JsonParser jp, DeserializationContext ctxt) throws IOException\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n         //   For now, won't add, since it is inferred, not explicit...\n     }\n \n-    @Deprecated // since 2.3\n-    public void addInjectable(String propName, JavaType propType,\n-            Annotations contextAnnotations, AnnotatedMember member,\n-            Object valueId)\n-    {\n-        addInjectable(new PropertyName(propName), propType, contextAnnotations, member, valueId);\n-    }\n-    \n     public void addInjectable(PropertyName propName, JavaType propType,\n             Annotations contextAnnotations, AnnotatedMember member,\n             Object valueId)\n         return _properties.values().iterator();\n     }\n \n-    /**\n-     * @since 2.3\n-     */\n     public SettableBeanProperty findProperty(PropertyName propertyName) {\n         return _properties.get(propertyName.getSimpleName());\n     }\n \n-    @Deprecated // since 2.3\n-    public SettableBeanProperty findProperty(String propertyName) {\n-        return _properties.get(propertyName);\n-    }\n-\n-    /**\n-     * @since 2.3\n-     */\n     public boolean hasProperty(PropertyName propertyName) {\n         return findProperty(propertyName) != null;\n     }\n-    \n-    @Deprecated // since 2.3\n-    public boolean hasProperty(String propertyName) {\n-        return findProperty(propertyName) != null;\n-    }\n-\n-    /**\n-     * @since 2.3\n-     */\n+\n     public SettableBeanProperty removeProperty(PropertyName name) {\n         return _properties.remove(name.getSimpleName());\n-    }\n-    \n-    @Deprecated // since 2.3\n-    public SettableBeanProperty removeProperty(String name) {\n-        return _properties.remove(name);\n     }\n \n     public SettableAnyProperty getAnySetter() {\n      * \n      * @since 2.0\n      */\n-    public AbstractDeserializer buildAbstract()\n-    {\n+    public AbstractDeserializer buildAbstract() {\n         return new AbstractDeserializer(this, _beanDesc, _backRefProperties);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n \n import java.lang.reflect.Type;\n import java.util.*;\n-import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.DeserializerFactoryConfig;\n import com.fasterxml.jackson.databind.deser.impl.*;\n-import com.fasterxml.jackson.databind.deser.std.AtomicReferenceDeserializer;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n-import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.SimpleBeanPropertyDefinition;\n     \n     /*\n     /**********************************************************\n-    /* Overrides for super-class methods used for finding\n-    /* custom deserializers\n-    /**********************************************************\n-     */\n-\n-    // Note: NOT overriding, superclass has no matching method\n-    @SuppressWarnings(\"unchecked\")\n-    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type,\n-            DeserializationConfig config, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        for (Deserializers d  : _factoryConfig.deserializers()) {\n-            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, beanDesc);\n-            if (deser != null) {\n-                return (JsonDeserializer<Object>) deser;\n-            }\n-        }\n-        return null;\n-    }\n-    \n-    /*\n-    /**********************************************************\n     /* DeserializerFactory API implementation\n     /**********************************************************\n      */\n         // note: we do NOT check for custom deserializers here, caller has already\n         // done that\n         JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n+        // Also: better ensure these are post-processable?\n         if (deser != null) {\n-            return deser;\n-        }\n-        \n-        Class<?> cls = type.getRawClass();\n-        // [JACKSON-283]: AtomicReference is a rather special type...\n-        if (AtomicReference.class.isAssignableFrom(cls)) {\n-            // Must find parameterization\n-            TypeFactory tf = ctxt.getTypeFactory();\n-            JavaType[] params = tf.findTypeParameters(type, AtomicReference.class);\n-            JavaType referencedType;\n-            if (params == null || params.length < 1) { // untyped (raw)\n-                referencedType = TypeFactory.unknownType();\n-            } else {\n-                referencedType = params[0];\n-            }\n-            TypeDeserializer valueTypeDeser = findTypeDeserializer(ctxt.getConfig(), referencedType);\n-            BeanDescription refdDesc = ctxt.getConfig().introspectClassAnnotations(referencedType);\n-            deser = findDeserializerFromAnnotation(ctxt, refdDesc.getClassInfo());\n-            return new AtomicReferenceDeserializer(referencedType, valueTypeDeser, deser);\n-        }\n-        return findOptionalStdDeserializer(ctxt, type, beanDesc);\n-    }\n-\n-    /**\n-     * Overridable method called after checking all other types.\n-     * \n-     * @since 2.2\n-     */\n-    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt,\n-            JavaType type, BeanDescription beanDesc)\n-        throws JsonMappingException\n-    {\n-        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n+            if (_factoryConfig.hasDeserializerModifiers()) {\n+                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                    deser = mod.modifyDeserializer(ctxt.getConfig(), beanDesc, deser);\n+                }\n+            }\n+        }\n+        return deser;\n     }\n     \n     protected JavaType materializeAbstractType(DeserializationContext ctxt,\n     {\n         final SettableBeanProperty[] creatorProps =\n                 builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig());\n+        final boolean isConcrete = !beanDesc.getType().isAbstract();\n         \n         // Things specified as \"ok to ignore\"? [JACKSON-77]\n         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n         if (anySetter != null) {\n             builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetter));\n         }\n-        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any setter\n+        // NOTE: we do NOT add @JsonIgnore'd properties into blocked ones if there's any-setter\n         // Implicit ones via @JsonIgnore and equivalent?\n         if (anySetter == null) {\n             Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n                     prop = constructSetterlessProperty(ctxt, beanDesc, propDef);\n                 }\n             }\n-            if (propDef.hasConstructorParameter()) {\n+            // 25-Sep-2014, tatu: No point in finding constructor parameters for abstract types\n+            //   (since they are never used anyway)\n+            if (isConcrete && propDef.hasConstructorParameter()) {\n                 /* [JACKSON-700] If property is passed via constructor parameter, we must\n                  *   handle things in special way. Not sure what is the most optimal way...\n                  *   for now, let's just call a (new) method in builder, which does nothing.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n     public ReadableObjectId findObjectId(Object id, ObjectIdGenerator<?> gen, ObjectIdResolver resolverType)\n     {\n         final ObjectIdGenerator.IdKey key = gen.key(id);\n+\n         if (_objectIds == null) {\n             _objectIds = new LinkedHashMap<ObjectIdGenerator.IdKey,ReadableObjectId>();\n         } else {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n package com.fasterxml.jackson.databind.deser;\n \n import java.io.IOException;\n-import java.lang.reflect.*;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n      * information. Retained to allow contextualization of any properties.\n      */\n     protected final BeanProperty _property;\n-    \n-    /**\n-     * Physical JDK object used for assigning properties.\n-     *<p>\n-     * NOTE: must be marked transient since it is not serializable,\n-     * in case these are to be serialized\n-     */\n-    protected final transient Method _setter;\n+\n+    /**\n+     * Annotated variant is needed for JDK serialization only\n+     */\n+    final protected AnnotatedMethod _setter;\n \n     protected final JavaType _type;\n \n     /* Life-cycle\n     /**********************************************************\n      */\n-\n-    @Deprecated // since 2.3\n-    public SettableAnyProperty(BeanProperty property, AnnotatedMethod setter, JavaType type,\n-            JsonDeserializer<Object> valueDeser) {\n-        this(property, setter, type, valueDeser, null);\n-    }\n \n     public SettableAnyProperty(BeanProperty property, AnnotatedMethod setter, JavaType type,\n             JsonDeserializer<Object> valueDeser, TypeDeserializer typeDeser)\n     {\n-        this(property, setter.getAnnotated(), type, valueDeser, typeDeser);\n-    }\n-    \n-    @Deprecated // since 2.3\n-    public SettableAnyProperty(BeanProperty property, Method rawSetter, JavaType type,\n-            JsonDeserializer<Object> valueDeser) {\n-        this(property, rawSetter, type, valueDeser, null);\n-    }\n-    \n-    public SettableAnyProperty(BeanProperty property, Method rawSetter, JavaType type,\n-            JsonDeserializer<Object> valueDeser, TypeDeserializer typeDeser)\n-    {\n         _property = property;\n+        _setter = setter;\n         _type = type;\n-        _setter = rawSetter;\n         _valueDeserializer = valueDeser;\n         _valueTypeDeserializer = typeDeser;\n     }\n         return new SettableAnyProperty(_property, _setter, _type,\n                 deser, _valueTypeDeserializer);\n     }\n+\n+    /**\n+     * Constructor used for JDK Serialization when reading persisted object\n+     */\n+    protected SettableAnyProperty(SettableAnyProperty src)\n+    {\n+        _property = src._property;\n+        _setter = src._setter;\n+        _type = src._type;\n+        _valueDeserializer = src._valueDeserializer;\n+        _valueTypeDeserializer = src._valueTypeDeserializer;\n+    }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    // TODO (2.3): handle restoring of reference to any-setter method\n-    \n-/*\n+    /**\n+     * Need to define this to verify that we retain actual Method reference\n+     */\n     Object readResolve() {\n-        return new SettableAnyProperty(this, _annotated.getAnnotated());\n-    }\n-    */\n+        // sanity check...\n+        if (_setter == null || _setter.getAnnotated() == null) {\n+            throw new IllegalArgumentException(\"Missing method (broken JDK (de)serialization?)\");\n+        }\n+        return this;\n+    }\n     \n     /*\n     /**********************************************************\n     public void set(Object instance, String propName, Object value) throws IOException\n     {\n         try {\n-            _setter.invoke(instance, propName, value);\n+            // note: can not use 'setValue()' due to taking 2 args\n+            _setter.getAnnotated().invoke(instance, propName, value);\n         } catch (Exception e) {\n             _throwAsIOE(e, propName, value);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n                 contextAnnotations, propDef.getMetadata());\n     }\n \n-    @Deprecated // since 2.2\n-    protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper,\n-            TypeDeserializer typeDeser, Annotations contextAnnotations)\n-    {\n-        this(new PropertyName(propName), type, wrapper, typeDeser, contextAnnotations,\n-                PropertyMetadata.STD_OPTIONAL);\n-    }\n-\n     @Deprecated // since 2.3\n     protected SettableBeanProperty(String propName, JavaType type, PropertyName wrapper,\n             TypeDeserializer typeDeser, Annotations contextAnnotations,\n      * @since 2.0\n      */\n     public abstract Object setAndReturn(Object instance, Object value)\n-            throws IOException;\n+        throws IOException;\n     \n     /**\n      * This method is needed by some specialized bean deserializers,\n      * this method should also not be called directly unless you really know\n      * what you are doing (and probably not even then).\n      */\n-    public final Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public final Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n      */\n     public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt,\n             String propName, Object bean)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         Integer I = _nameToPropertyIndex.get(propName);\n         if (I == null) {\n      * @return True, if the given property was properly handled\n      */\n     public boolean handlePropertyValue(JsonParser jp, DeserializationContext ctxt,\n-            String propName, Object bean)\n-        throws IOException, JsonProcessingException\n+            String propName, Object bean) throws IOException\n     {\n         Integer I = _nameToPropertyIndex.get(propName);\n         if (I == null) {\n     \n     @SuppressWarnings(\"resource\")\n     public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         for (int i = 0, len = _properties.length; i < len; ++i) {\n             String typeId = _typeIds[i];\n      */\n     public Object complete(JsonParser jp, DeserializationContext ctxt,\n             PropertyValueBuffer buffer, PropertyBasedCreator creator)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         // first things first: deserialize all data buffered:\n         final int len = _properties.length;\n \n     @SuppressWarnings(\"resource\")\n     protected final Object _deserialize(JsonParser jp, DeserializationContext ctxt,\n-            int index, String typeId)\n-        throws IOException, JsonProcessingException\n+            int index, String typeId) throws IOException\n     {\n         TokenBuffer merged = new TokenBuffer(jp);\n         merged.writeStartArray();\n \n     @SuppressWarnings(\"resource\")\n     protected final void _deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-            Object bean, int index, String typeId)\n-        throws IOException, JsonProcessingException\n+            Object bean, int index, String typeId) throws IOException\n     {\n         /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n          * style to ensure we can handle all kinds of JSON constructs.\n         p2.nextToken();\n         merged.copyCurrentStructure(p2);\n         merged.writeEndArray();\n-        \n         // needs to point to START_OBJECT (or whatever first token is)\n         p2 = merged.asParser(jp);\n         p2.nextToken();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java\n     /**\n      * Constructor used for JDK Serialization when reading persisted object\n      */\n-    protected FieldProperty(FieldProperty src, Field f)\n+    protected FieldProperty(FieldProperty src)\n     {\n         super(src);\n         _annotated = src._annotated;\n+        Field f = _annotated.getAnnotated();\n         if (f == null) {\n-            throw new IllegalArgumentException(\"No Field passed for property '\"+src.getName()\n-                    +\"' (class \"+src.getDeclaringClass().getName()+\")\");\n+            throw new IllegalArgumentException(\"Missing field (broken JDK (de)serialization?)\");\n         }\n         _field = f;\n     }\n      */\n \n     Object readResolve() {\n-        return new FieldProperty(this, _annotated.getAnnotated());\n+        return new FieldProperty(this);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/InnerClassProperty.java\n import java.lang.annotation.Annotation;\n import java.lang.reflect.Constructor;\n \n-import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.core.JsonToken;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.PropertyName;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n     protected final SettableBeanProperty _delegate;\n \n     /**\n-     * Single-arg constructor we use for value instantiation.\n+     * Constructor used when deserializing this property.\n+     * Transient since there is no need to persist; only needed during\n+     * construction of objects.\n      */\n-    protected final Constructor<?> _creator;\n+    final protected transient Constructor<?> _creator;\n     \n+    /**\n+     * Serializable version of single-arg constructor we use for value instantiation.\n+     */\n+    protected AnnotatedConstructor _annotated;\n+\n     public InnerClassProperty(SettableBeanProperty delegate,\n             Constructor<?> ctor)\n     {\n         _creator = ctor;\n     }\n \n+    /**\n+     * Constructor used with JDK Serialization; needed to handle transient\n+     * Constructor, wrap/unwrap in/out-of Annotated variant.\n+     */\n+    protected InnerClassProperty(InnerClassProperty src, AnnotatedConstructor ann)\n+    {\n+        super(src);\n+        _delegate = src._delegate;\n+        _annotated = ann;\n+        _creator = (_annotated == null) ? null : _annotated.getAnnotated();\n+        if (_creator == null) {\n+            throw new IllegalArgumentException(\"Missing constructor (broken JDK (de)serialization?)\");\n+        }\n+    }\n+    \n     protected InnerClassProperty(InnerClassProperty src, JsonDeserializer<?> deser)\n     {\n         super(src, deser);\n      */\n \n     @Override\n-    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n-            Object bean)\n-        throws IOException, JsonProcessingException\n+    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object bean)\n+        throws IOException\n     {\n         JsonToken t = jp.getCurrentToken();\n         Object value;\n     @Override\n     public Object deserializeSetAndReturn(JsonParser jp,\n     \t\tDeserializationContext ctxt, Object instance)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         return setAndReturn(instance, deserialize(jp, ctxt));\n     }\n     \n     @Override\n-    public final void set(Object instance, Object value) throws IOException\n-    {\n+    public final void set(Object instance, Object value) throws IOException {\n         _delegate.set(instance, value);\n     }\n \n     @Override\n-    public Object setAndReturn(Object instance, Object value)\n-            throws IOException\n-    {\n-    \treturn _delegate.setAndReturn(instance, value);\n+    public Object setAndReturn(Object instance, Object value) throws IOException {\n+        return _delegate.setAndReturn(instance, value);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JDK serialization handling\n+    /**********************************************************\n+     */\n+\n+    // When reading things back, \n+    Object readResolve() {\n+        return new InnerClassProperty(this, _annotated);\n+    }\n+\n+    Object writeReplace() {\n+        // need to construct a fake instance to support serialization\n+        if (_annotated != null) {\n+            return this;\n+        }\n+        return new InnerClassProperty(this, new AnnotatedConstructor(_creator, null, null));\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReader.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdResolver;\n import com.fasterxml.jackson.annotation.SimpleObjectIdResolver;\n+\n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n \n      */\n     public final ObjectIdGenerator<?> generator;\n \n-    /**\n-     * \n-     */\n     public final ObjectIdResolver resolver;\n \n     /**\n         this(t,propName, gen, deser, idProp, new SimpleObjectIdResolver());\n     }\n \n-    @Deprecated // since 2.3\n-    protected ObjectIdReader(JavaType t, String propName, ObjectIdGenerator<?> gen,\n-            JsonDeserializer<?> deser, SettableBeanProperty idProp)\n-    {\n-        this(t, new PropertyName(propName), gen, deser, idProp);\n-    }\n-\n     /**\n      * Factory method called by {@link com.fasterxml.jackson.databind.ser.std.BeanSerializerBase}\n      * with the initial information based on standard settings for the type\n             SettableBeanProperty idProp)\n     {\n         return construct(idType, propName, generator, deser, idProp, new SimpleObjectIdResolver());\n-    }\n-    \n-    @Deprecated // since 2.3\n-    public static ObjectIdReader construct(JavaType idType, String propName,\n-            ObjectIdGenerator<?> generator, JsonDeserializer<?> deser,\n-            SettableBeanProperty idProp)\n-    {\n-        return construct(idType, new PropertyName(propName), generator, deser, idProp);\n     }\n \n     /*\n      * \n      * @since 2.3\n      */\n-    public Object readObjectReference(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n+    public Object readObjectReference(JsonParser jp, DeserializationContext ctxt) throws IOException {\n         return _deserializer.deserialize(jp, ctxt);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ObjectIdReferenceProperty.java\n import java.lang.annotation.Annotation;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.PropertyName;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.deser.UnresolvedForwardReference;\n import com.fasterxml.jackson.databind.deser.impl.ReadableObjectId.Referring;\n import com.fasterxml.jackson.databind.introspect.ObjectIdInfo;\n \n public class ObjectIdReferenceProperty extends SettableBeanProperty {\n-    private static final long serialVersionUID = 8465266677345565407L;\n-    private SettableBeanProperty _forward;\n+    private static final long serialVersionUID = 1L;\n+\n+    private final SettableBeanProperty _forward;\n \n     public ObjectIdReferenceProperty(SettableBeanProperty forward, ObjectIdInfo objectIdInfo)\n     {\n     }\n \n     @Override\n-    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance)\n-        throws IOException, JsonProcessingException\n-    {\n+    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt, Object instance) throws IOException {\n         deserializeSetAndReturn(jp, ctxt, instance);\n     }\n \n     @Override\n     public Object deserializeSetAndReturn(JsonParser jp, DeserializationContext ctxt, Object instance)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n-        boolean usingIdentityInfo = (_objectIdInfo != null) || (_valueDeserializer.getObjectIdReader() != null);\n         try {\n             return setAndReturn(instance, deserialize(jp, ctxt));\n         } catch (UnresolvedForwardReference reference) {\n+            boolean usingIdentityInfo = (_objectIdInfo != null) || (_valueDeserializer.getObjectIdReader() != null);\n             if (!usingIdentityInfo) {\n                 throw JsonMappingException.from(jp, \"Unresolved forward reference but no identity info.\", reference);\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n     /**\n      * Helper method called to handle Object Id value collected earlier, if any\n      */\n-    public Object handleIdValue(final DeserializationContext ctxt, Object bean)\n-        throws IOException\n+    public Object handleIdValue(final DeserializationContext ctxt, Object bean) throws IOException\n     {\n         if (_objectIdReader != null) {\n             if (_idValue != null) {\n                 }\n             } else {\n                 // TODO: is this an error case?\n+                throw ctxt.mappingException(\"No _idValue when handleIdValue called, on instance of \"\n+                        +bean.getClass().getName());\n             }\n         }\n         return bean;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/SetterlessProperty.java\n \n         // For [#501] fix we need to implement this but:\n         if (_valueTypeDeserializer != null) {\n-            throw new JsonMappingException(\"Problem deserializing 'setterless' property: no way to handle typed deser with setterless yet\");\n+            throw new JsonMappingException(\"Problem deserializing 'setterless' property (\\\"\"+getName()+\"\\\"): no way to handle typed deser with setterless yet\");\n //            return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer);\n         }\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/TypeWrappedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/TypeWrappedDeserializer.java\n import java.io.IOException;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.databind.DeserializationContext;\n-import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n /**\n  */\n public final class TypeWrappedDeserializer\n     extends JsonDeserializer<Object>\n+    implements java.io.Serializable // since 2.5\n {\n-    final TypeDeserializer _typeDeserializer;\n-    final JsonDeserializer<Object> _deserializer;\n+    private static final long serialVersionUID = 1L;\n \n-    public TypeWrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<Object> deser)\n+    final protected TypeDeserializer _typeDeserializer;\n+    final protected JsonDeserializer<Object> _deserializer;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public TypeWrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<?> deser)\n     {\n         super();\n         _typeDeserializer = typeDeser;\n-        _deserializer = deser;\n+        _deserializer = (JsonDeserializer<Object>) deser;\n     }\n \n     @Override\n     }\n     \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         return _deserializer.deserializeWithType(jp, ctxt, _typeDeserializer);\n     }\n \n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-        TypeDeserializer typeDeserializer)\n-            throws IOException, JsonProcessingException\n+        TypeDeserializer typeDeserializer) throws IOException\n     {\n         // should never happen? (if it can, could call on that object)\n         throw new IllegalStateException(\"Type-wrapped deserializer's deserializeWithType should never get called\");\n \n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt,\n-            Object intoValue)\n-        throws IOException, JsonProcessingException\n+            Object intoValue) throws IOException\n     {\n         /* 01-Mar-2013, tatu: Hmmh. Tough call as to what to do... need\n          *   to delegate, but will this work reliably? Let's just hope so:\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n \n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n \n /**\n      * Accesor for deserializer use for deserializing content values.\n      */\n     public abstract JsonDeserializer<Object> getContentDeserializer();\n+\n+    /*\n+    /**********************************************************\n+    /* Shared methods for sub-classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method called by various Map(-like) deserializers.\n+     */\n+    protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException\n+    {\n+        // to handle StackOverflow:\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors and \"plain\" IOExceptions to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        // ... except for mapping exceptions\n+        if (t instanceof IOException && !(t instanceof JsonMappingException)) {\n+            throw (IOException) t;\n+        }\n+        throw JsonMappingException.wrapWithPath(t, ref, key);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n import java.lang.reflect.Method;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n \n public class EnumDeserializer\n     extends StdScalarDeserializer<Enum<?>>\n {\n-    private static final long serialVersionUID = -5893263645879532318L;\n+    private static final long serialVersionUID = 1L;\n \n     protected final EnumResolver<?> _resolver;\n     \n     {\n         // note: caller has verified there's just one arg; but we must verify its type\n         Class<?> paramClass = factory.getRawParameterType(0);\n-        if (paramClass == String.class) {\n-            paramClass = null;\n-        } else  if (paramClass == Integer.TYPE || paramClass == Integer.class) {\n-            paramClass = Integer.class;\n-        } else  if (paramClass == Long.TYPE || paramClass == Long.class) {\n-            paramClass = Long.class;\n-        } else {\n-            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory\n-                    +\") not suitable, must be java.lang.String or int/Integer/long/Long\");\n-        }\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(factory.getMember());\n         }\n      * for locating Enum values by String id.\n      */\n     protected static class FactoryBasedDeserializer\n-        extends StdScalarDeserializer<Object>\n-    {\n-        private static final long serialVersionUID = -7775129435872564122L;\n-\n-        protected final Class<?> _enumClass;\n+        extends StdDeserializer<Object>\n+        implements ContextualDeserializer\n+    {\n+        private static final long serialVersionUID = 1;\n+\n         // Marker type; null if String expected; otherwise numeric wrapper\n         protected final Class<?> _inputType;\n         protected final Method _factory;\n+        protected final JsonDeserializer<?> _deser;\n         \n         public FactoryBasedDeserializer(Class<?> cls, AnnotatedMethod f,\n                 Class<?> inputType)\n         {\n-            super(Enum.class);\n-            _enumClass = cls;\n+            super(cls);\n             _factory = f.getAnnotated();\n             _inputType = inputType;\n-        }\n-\n+            _deser = null;\n+        }\n+\n+        protected FactoryBasedDeserializer(FactoryBasedDeserializer base,\n+                JsonDeserializer<?> deser) {\n+            super(base._valueClass);\n+            _inputType = base._inputType;\n+            _factory = base._factory;\n+            _deser = deser;\n+        }\n+        \n         @Override\n-        public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n+        public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+                BeanProperty property)\n+            throws JsonMappingException\n         {\n-            // couple of accepted types...\n+            if ((_deser == null) && (_inputType != String.class)) {\n+                return new FactoryBasedDeserializer(this,\n+                        ctxt.findContextualValueDeserializer(ctxt.constructType(_inputType), property));\n+            }\n+            return this;\n+        }\n+        \n+        @Override\n+        public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        {\n             Object value;\n-            if (_inputType == null) {\n-                value = jp.getText();\n-            } else  if (_inputType == Integer.class) {\n-                value = Integer.valueOf(jp.getValueAsInt());\n-            } else  if (_inputType == Long.class) {\n-                value = Long.valueOf(jp.getValueAsLong());\n+            if (_deser != null) {\n+                value = _deser.deserialize(jp, ctxt);\n             } else {\n-                throw ctxt.mappingException(_enumClass);\n+                value = jp.getValueAsString();\n             }\n             try {\n-                return _factory.invoke(_enumClass, value);\n+                return _factory.invoke(_valueClass, value);\n             } catch (Exception e) {\n                 Throwable t = ClassUtil.getRootCause(e);\n                 if (t instanceof IOException) {\n                     throw (IOException) t;\n                 }\n-                throw ctxt.instantiationException(_enumClass, t);\n-            }\n+                throw ctxt.instantiationException(_valueClass, t);\n+            }\n+        }\n+\n+        @Override\n+        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer) throws IOException {\n+            if (_deser == null) { // String never has type info\n+                return deserialize(jp, ctxt);\n+            }\n+            return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n         }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n /**\n  * <p>\n  * Note: casting within this class is all messed up -- just could not figure out a way\n  * to properly deal with recursive definition of \"EnumMap<K extends Enum<K>, V>\n- * \n- * @author tsaloranta\n  */\n @SuppressWarnings({ \"unchecked\", \"rawtypes\" }) \n public class EnumMapDeserializer\n-    extends StdDeserializer<EnumMap<?,?>>\n+    extends ContainerDeserializerBase<EnumMap<?,?>>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = 4564890642370311174L;\n+    private static final long serialVersionUID = 1;\n \n     protected final JavaType _mapType;\n     \n     protected final Class<?> _enumClass;\n \n-    protected JsonDeserializer<Enum<?>> _keyDeserializer;\n+    protected KeyDeserializer _keyDeserializer;\n \n     protected JsonDeserializer<Object> _valueDeserializer;\n \n     /**********************************************************\n      */\n \n-    public EnumMapDeserializer(JavaType mapType, JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeser, TypeDeserializer valueTypeDeser)\n+    public EnumMapDeserializer(JavaType mapType, KeyDeserializer keyDeserializer, JsonDeserializer<?> valueDeser, TypeDeserializer valueTypeDeser)\n     {\n-        super(EnumMap.class);\n+        super(mapType);\n         _mapType = mapType;\n         _enumClass = mapType.getKeyType().getRawClass();\n-        _keyDeserializer = (JsonDeserializer<Enum<?>>) keyDeserializer;\n+        _keyDeserializer = keyDeserializer;\n         _valueDeserializer = (JsonDeserializer<Object>) valueDeser;\n         _valueTypeDeserializer = valueTypeDeser;\n     }\n \n-    public EnumMapDeserializer withResolved(JsonDeserializer<?> keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n+    public EnumMapDeserializer withResolved(KeyDeserializer keyDeserializer, JsonDeserializer<?> valueDeserializer, TypeDeserializer valueTypeDeser)\n     {\n         if ((keyDeserializer == _keyDeserializer) && (valueDeserializer == _valueDeserializer) && (valueTypeDeser == _valueTypeDeserializer)) {\n             return this;\n         // note: instead of finding key deserializer, with enums we actually\n         // work with regular deserializers (less code duplication; but not\n         // quite as clean as it ought to be)\n-        JsonDeserializer<?> kd = _keyDeserializer;\n+        KeyDeserializer kd = _keyDeserializer;\n         if (kd == null) {\n-            kd = ctxt.findContextualValueDeserializer(_mapType.getKeyType(), property);\n+            kd = ctxt.findKeyDeserializer(_mapType.getKeyType(), property);\n         }\n         JsonDeserializer<?> vd = _valueDeserializer;\n         if (vd == null) {\n      */\n     @Override\n     public boolean isCachable() { return true; }\n-    \n+\n+    /*\n+    /**********************************************************\n+    /* ContainerDeserializerBase API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _mapType.getContentType();\n+    }\n+\n+    @Override\n+    public JsonDeserializer<Object> getContentDeserializer() {\n+        return _valueDeserializer;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Actual deserialization\n     /**********************************************************\n      */\n-\n+    \n     @Override\n-    public EnumMap<?,?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException\n+    public EnumMap<?,?> deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException\n     {\n         // Ok: must point to START_OBJECT\n         if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.mappingException(EnumMap.class);\n+            return _deserializeFromEmpty(jp, ctxt);\n         }\n         EnumMap result = constructMap();\n         final JsonDeserializer<Object> valueDes = _valueDeserializer;\n         final TypeDeserializer typeDeser = _valueTypeDeserializer;\n \n-        while ((jp.nextToken()) != JsonToken.END_OBJECT) {\n-            Enum<?> key = _keyDeserializer.deserialize(jp, ctxt);\n+        while ((jp.nextToken()) == JsonToken.FIELD_NAME) {\n+            String keyName = jp.getCurrentName(); // just for error message\n+            // but we need to let key deserializer handle it separately, nonetheless\n+            Enum<?> key = (Enum<?>) _keyDeserializer.deserializeKey(keyName, ctxt);\n             if (key == null) {\n                 if (!ctxt.isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-                    String value = null;\n-                    try { // bit ugly, but will have to do; works with usual scalars\n-                        if (jp.hasCurrentToken()) {\n-                            value = jp.getText();\n-                        }\n-                    } catch (Exception e) { }\n-                    throw ctxt.weirdStringException(value, _enumClass, \"value not one of declared Enum instance names\");\n+                    throw ctxt.weirdStringException(keyName, _enumClass, \"value not one of declared Enum instance names for \"\n+                            +_mapType.getKeyType());\n                 }\n                 /* 24-Mar-2012, tatu: Null won't work as a key anyway, so let's\n-                 *  just skip the entry then. But we must skip the value then.\n+                 *  just skip the entry then. But we must skip the value as well, if so.\n                  */\n                 jp.nextToken();\n                 jp.skipChildren();\n              * not handle them (and maybe fail or return bogus data)\n              */\n             Object value;\n-            \n-            if (t == JsonToken.VALUE_NULL) {\n-                value = valueDes.getNullValue();\n-            } else if (typeDeser == null) {\n-                value =  valueDes.deserialize(jp, ctxt);\n-            } else {\n-                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+\n+            try {\n+                if (t == JsonToken.VALUE_NULL) {\n+                    value = valueDes.getNullValue();\n+                } else if (typeDeser == null) {\n+                    value =  valueDes.deserialize(jp, ctxt);\n+                } else {\n+                    value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+                }\n+            } catch (Exception e) {\n+                wrapAndThrow(e, result, keyName);\n+                return null;\n             }\n             result.put(key, value);\n         }\n     }\n \n     @Override\n-   public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer)\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt, TypeDeserializer typeDeserializer)\n         throws IOException, JsonProcessingException\n     {\n         // In future could check current token... for now this should be enough:\n         return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n     }\n     \n-    private EnumMap<?,?> constructMap() {\n+    protected EnumMap<?,?> constructMap() {\n         return new EnumMap(_enumClass);\n     }\n }\n+\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n package com.fasterxml.jackson.databind.deser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n     extends ContainerDeserializerBase<Map<Object,Object>>\n     implements ContextualDeserializer, ResolvableDeserializer\n {\n-    private static final long serialVersionUID = -3378654289961736240L;\n+    private static final long serialVersionUID = 1L;\n \n     // // Configuration: typing, deserializers\n \n         }\n         return withResolved(kd, vtd, vd, ignored);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* ContainerDeserializerBase API\n             if (t == JsonToken.VALUE_STRING) {\n                 return (Map<Object,Object>) _valueInstantiator.createFromString(ctxt, jp.getText());\n             }\n-            throw ctxt.mappingException(getMapClass());\n+            // slightly redundant (since String was passed above), but\n+            return _deserializeFromEmpty(jp, ctxt);\n         }\n         final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault(ctxt);\n         if (_standardStringKey) {\n     protected void wrapAndThrow(Throwable t, Object ref) throws IOException {\n         wrapAndThrow(t, ref, null);\n     }\n-    \n-    // note: copied from BeanDeserializer; should try to share somehow...\n-    protected void wrapAndThrow(Throwable t, Object ref, String key) throws IOException\n-    {\n-        // to handle StackOverflow:\n-        while (t instanceof InvocationTargetException && t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        // Errors and \"plain\" IOExceptions to be passed as is\n-        if (t instanceof Error) {\n-            throw (Error) t;\n-        }\n-        // ... except for mapping exceptions\n-        if (t instanceof IOException && !(t instanceof JsonMappingException)) {\n-            throw (IOException) t;\n-        }\n-        throw JsonMappingException.wrapWithPath(t, ref, key);\n-    }\n \n     private void handleUnresolvedReference(JsonParser jp, MapReferringAccumulator accumulator, Object key,\n             UnresolvedForwardReference reference)\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapEntryDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+\n+/**\n+ * Basic serializer that can take JSON \"Object\" structure and\n+ * construct a {@link java.util.Map} instance, with typed contents.\n+ *<p>\n+ * Note: for untyped content (one indicated by passing Object.class\n+ * as the type), {@link UntypedObjectDeserializer} is used instead.\n+ * It can also construct {@link java.util.Map}s, but not with specific\n+ * POJO types, only other containers and primitives/wrappers.\n+ */\n+@JacksonStdImpl\n+public class MapEntryDeserializer\n+    extends ContainerDeserializerBase<Map.Entry<Object,Object>>\n+    implements ContextualDeserializer\n+{\n+    private static final long serialVersionUID = 1;\n+\n+    // // Configuration: typing, deserializers\n+\n+    protected final JavaType _type;\n+\n+    /**\n+     * Key deserializer to use; either passed via constructor\n+     * (when indicated by annotations), or resolved when\n+     * {@link #resolve} is called;\n+     */\n+    protected final KeyDeserializer _keyDeserializer;\n+\n+    /**\n+     * Value deserializer.\n+     */\n+    protected final JsonDeserializer<Object> _valueDeserializer;\n+\n+    /**\n+     * If value instances have polymorphic type information, this\n+     * is the type deserializer that can handle it\n+     */\n+    protected final TypeDeserializer _valueTypeDeserializer;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public MapEntryDeserializer(JavaType type,\n+            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n+            TypeDeserializer valueTypeDeser)\n+    {\n+        super(type);\n+        if (type.containedTypeCount() != 2) { // sanity check\n+            throw new IllegalArgumentException(\"Missing generic type information for \"+type);\n+        }\n+        _type = type;\n+        _keyDeserializer = keyDeser;\n+        _valueDeserializer = valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n+    }\n+\n+    /**\n+     * Copy-constructor that can be used by sub-classes to allow\n+     * copy-on-write styling copying of settings of an existing instance.\n+     */\n+    protected MapEntryDeserializer(MapEntryDeserializer src)\n+    {\n+        super(src._type);\n+        _type = src._type;\n+        _keyDeserializer = src._keyDeserializer;\n+        _valueDeserializer = src._valueDeserializer;\n+        _valueTypeDeserializer = src._valueTypeDeserializer;\n+    }\n+\n+    protected MapEntryDeserializer(MapEntryDeserializer src,\n+            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n+            TypeDeserializer valueTypeDeser)\n+    {\n+        super(src._type);\n+        _type = src._type;\n+        _keyDeserializer = keyDeser;\n+        _valueDeserializer = valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n+    }\n+\n+    /**\n+     * Fluent factory method used to create a copy with slightly\n+     * different settings. When sub-classing, MUST be overridden.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected MapEntryDeserializer withResolved(KeyDeserializer keyDeser,\n+            TypeDeserializer valueTypeDeser, JsonDeserializer<?> valueDeser)\n+    {\n+        \n+        if ((_keyDeserializer == keyDeser) && (_valueDeserializer == valueDeser)\n+                && (_valueTypeDeserializer == valueTypeDeser)) {\n+            return this;\n+        }\n+        return new MapEntryDeserializer(this,\n+                keyDeser, (JsonDeserializer<Object>) valueDeser, valueTypeDeser);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Validation, post-processing (ResolvableDeserializer)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to finalize setup of this deserializer,\n+     * when it is known for which property deserializer is needed for.\n+     */\n+    @Override\n+    public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        KeyDeserializer kd = _keyDeserializer;\n+        if (kd == null) {\n+            kd = ctxt.findKeyDeserializer(_type.containedType(0), property);\n+        } else {\n+            if (kd instanceof ContextualKeyDeserializer) {\n+                kd = ((ContextualKeyDeserializer) kd).createContextual(ctxt, property);\n+            }\n+        }\n+        JsonDeserializer<?> vd = _valueDeserializer;\n+        vd = findConvertingContentDeserializer(ctxt, property, vd);\n+        if (vd == null) {\n+            vd = ctxt.findContextualValueDeserializer(_type.containedType(1), property);\n+        } else { // if directly assigned, probably not yet contextual, so:\n+            vd = ctxt.handleSecondaryContextualization(vd, property);\n+        }\n+        TypeDeserializer vtd = _valueTypeDeserializer;\n+        if (vtd != null) {\n+            vtd = vtd.forProperty(property);\n+        }\n+        return withResolved(kd, vtd, vd);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* ContainerDeserializerBase API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _type.containedType(1);\n+    }\n+\n+    @Override\n+    public JsonDeserializer<Object> getContentDeserializer() {\n+        return _valueDeserializer;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Map.Entry<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    {\n+        // Ok: must point to START_OBJECT, FIELD_NAME or END_OBJECT\n+        JsonToken t = jp.getCurrentToken();\n+        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n+            // [JACKSON-620] (empty) String may be ok however:\n+            // slightly redundant (since String was passed above), but\n+            return _deserializeFromEmpty(jp, ctxt);\n+        }\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        }\n+        if (t != JsonToken.FIELD_NAME) {\n+            if (t == JsonToken.END_OBJECT) {\n+                throw ctxt.mappingException(\"Can not deserialize a Map.Entry out of empty JSON Object\");\n+            }\n+            throw ctxt.mappingException(handledType(), t);\n+        }\n+        \n+        final KeyDeserializer keyDes = _keyDeserializer;\n+        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n+        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+\n+        final String keyStr = jp.getCurrentName();\n+        Object key = keyDes.deserializeKey(keyStr, ctxt);\n+        Object value = null;\n+        // And then the value...\n+        t = jp.nextToken();\n+        try {\n+            // Note: must handle null explicitly here; value deserializers won't\n+            if (t == JsonToken.VALUE_NULL) {\n+                value = valueDes.getNullValue();\n+            } else if (typeDeser == null) {\n+                value = valueDes.deserialize(jp, ctxt);\n+            } else {\n+                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+            }\n+        } catch (Exception e) {\n+            wrapAndThrow(e, Map.Entry.class, keyStr);\n+        }\n+\n+        // Close, but also verify that we reached the END_OBJECT\n+        t = jp.nextToken();\n+        if (t != JsonToken.END_OBJECT) {\n+            if (t == JsonToken.FIELD_NAME) { // most likely\n+                throw ctxt.mappingException(\"Problem binding JSON into Map.Entry: more than one entry in JSON (second field: '\"+jp.getCurrentName()+\"')\");\n+            }\n+            // how would this occur?\n+            throw ctxt.mappingException(\"Problem binding JSON into Map.Entry: unexpected content after JSON Object entry: \"+t);\n+        }\n+        return new AbstractMap.SimpleEntry<Object,Object>(key, value);\n+    }\n+\n+    @Override\n+    public Map.Entry<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+            Map.Entry<Object,Object> result) throws IOException\n+    {\n+        throw new IllegalStateException(\"Can not update Map.Entry values\");\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        // In future could check current token... for now this should be enough:\n+        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Other public accessors\n+    /**********************************************************\n+     */\n+\n+    @Override public JavaType getValueType() { return _type; }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n                 chunk[ix++] = value;\n             }\n         } catch (Exception e) {\n-            throw JsonMappingException.wrapWithPath(e, chunk, ix);\n+            throw JsonMappingException.wrapWithPath(e, chunk, buffer.bufferedSize() + ix);\n         }\n \n         Object[] result;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n                     chunk[ix++] = value;\n                 }\n             } catch (Exception e) {\n-                throw JsonMappingException.wrapWithPath(e, chunk, ix);\n+                throw JsonMappingException.wrapWithPath(e, chunk, builder.bufferedSize() + ix);\n             }\n             return builder.completeAndClearBuffer(chunk, ix);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n         throw ctxt.mappingException(String.class, jp.getCurrentToken());\n     }\n \n+    /**\n+     * Helper method that may be used to support fallback for Empty String / Empty Array\n+     * non-standard representations; usually for things serialized as JSON Objects.\n+     * \n+     * @since 2.5\n+     */\n+    protected T _deserializeFromEmpty(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.START_ARRAY) {\n+            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT)) {\n+                t = jp.nextToken();\n+                if (t == JsonToken.END_ARRAY) {\n+                    return null;\n+                }\n+                throw ctxt.mappingException(handledType(), JsonToken.START_ARRAY);\n+            }\n+        } else if (t == JsonToken.VALUE_STRING) {\n+            if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                String str = jp.getText().trim();\n+                if (str.isEmpty()) {\n+                    return null;\n+                }\n+            }\n+        }\n+        throw ctxt.mappingException(handledType());\n+    }\n+    \n     /**\n      * Helper method called to determine if we are seeing String value of\n      * \"null\", and, further, that it should be coerced to null just like\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n             return _parseLong(key);\n \n         case TYPE_FLOAT:\n-            /* 22-Jan-2009, tatu: Bounds/range checks would be tricky\n-             *   here, so let's not bother even trying...\n-             */\n+            // Bounds/range checks would be tricky here, so let's not bother even trying...\n             return Float.valueOf((float) _parseDouble(key));\n         case TYPE_DOUBLE:\n             return _parseDouble(key);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n public class StdKeyDeserializers\n     implements KeyDeserializers, java.io.Serializable\n {\n-    private static final long serialVersionUID = 923268084968181479L;\n+    private static final long serialVersionUID = 1L;\n     \n     public static KeyDeserializer constructEnumKeyDeserializer(EnumResolver<?> enumResolver) {\n         return new StdKeyDeserializer.EnumKD(enumResolver, null);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n \n import java.io.IOException;\n \n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.deser.*;\n      */\n     \n     @Override\n-    public Object createUsingDefault(DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object createUsingDefault(DeserializationContext ctxt) throws IOException\n     {\n         if (_defaultCreator == null) { // sanity-check; caller should check\n             throw new IllegalStateException(\"No default constructor for \"+getValueTypeDesc());\n     }\n     \n     @Override\n-    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args)\n-        throws IOException, JsonProcessingException\n+    public Object createFromObjectWith(DeserializationContext ctxt, Object[] args) throws IOException\n     {\n         if (_withArgsCreator == null) { // sanity-check; caller should check\n             throw new IllegalStateException(\"No with-args constructor for \"+getValueTypeDesc());\n     }\n \n     @Override\n-    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate)\n-        throws IOException, JsonProcessingException\n+    public Object createUsingDelegate(DeserializationContext ctxt, Object delegate) throws IOException\n     {\n         if (_delegateCreator == null) { // sanity-check; caller should check\n             throw new IllegalStateException(\"No delegate constructor for \"+getValueTypeDesc());\n      */\n     \n     @Override\n-    public Object createFromString(DeserializationContext ctxt, String value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromString(DeserializationContext ctxt, String value) throws IOException\n     {\n         if (_fromStringCreator != null) {\n             try {\n     }\n     \n     @Override\n-    public Object createFromInt(DeserializationContext ctxt, int value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromInt(DeserializationContext ctxt, int value) throws IOException\n     {\n         try {\n             // First: \"native\" int methods work best:\n     }\n \n     @Override\n-    public Object createFromLong(DeserializationContext ctxt, long value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromLong(DeserializationContext ctxt, long value) throws IOException\n     {\n         try {\n             if (_fromLongCreator != null) {\n     }\n \n     @Override\n-    public Object createFromDouble(DeserializationContext ctxt, double value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromDouble(DeserializationContext ctxt, double value) throws IOException\n     {\n         try {\n             if (_fromDoubleCreator != null) {\n     }\n \n     @Override\n-    public Object createFromBoolean(DeserializationContext ctxt, boolean value)\n-            throws IOException, JsonProcessingException\n+    public Object createFromBoolean(DeserializationContext ctxt, boolean value) throws IOException\n     {\n         try {\n             if (_fromBooleanCreator != null) {\n     public AnnotatedParameter getIncompleteParameter() {\n         return _incompleteParameter;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Internal methods\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n     extends StdDeserializer<String[]>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = -7589512013334920693L;\n+    private static final long serialVersionUID = 1L;\n \n     public final static StringArrayDeserializer instance = new StringArrayDeserializer();\n     \n                 chunk[ix++] = value;\n             }\n         } catch (Exception e) {\n-            throw JsonMappingException.wrapWithPath(e, chunk, ix);\n+            throw JsonMappingException.wrapWithPath(e, chunk, buffer.bufferedSize() + ix);\n         }\n         String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n         ctxt.returnObjectBuffer(buffer);\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java\n      * not exposed to developers since instances are mutable.\n      */\n     protected abstract AnnotationMap getAllAnnotations();\n+\n+    // Also: ensure we can use #equals, #hashCode\n+    \n+    @Override\n+    public abstract boolean equals(Object o);\n+\n+    @Override\n+    public abstract int hashCode();\n+\n+    @Override\n+    public abstract String toString();\n }\n-\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (_isAnnotationBundle(ann)) {\n+                // note: we will NOT filter out non-Jackson anns any more\n+                boolean wasNotPresent = result.addIfNotPresent(ann);\n+                if (wasNotPresent && _isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                     bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                } else { // note: we will NOT filter out non-Jackson anns any more\n-                    result.addIfNotPresent(ann);\n                 }\n             }\n             if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (_isAnnotationBundle(ann)) {\n+                // note: we will NOT filter out non-Jackson anns any more\n+                boolean wasNotPresent = target.addIfNotPresent(ann);\n+                if (wasNotPresent && _isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                     bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                } else { // note: we will NOT filter out non-Jackson anns any more\n-                    target.addIfNotPresent(ann);\n                 }\n             }\n             if (bundles != null) { // and secondarily handle bundles, if any found: precedence important\n         if (anns != null) {\n             List<Annotation[]> bundles = null;\n             for (Annotation ann : anns) { // first: direct annotations\n-                if (_isAnnotationBundle(ann)) {\n+                // note: we will NOT filter out non-Jackson anns any more\n+                boolean wasModified = target.addOrOverride(ann);\n+                if (wasModified && _isAnnotationBundle(ann)) {\n                     if (bundles == null) {\n                         bundles = new LinkedList<Annotation[]>();\n                     }\n                     bundles.add(ann.annotationType().getDeclaredAnnotations());\n-                } else { // note: no filtering by jackson-annotations\n-                    target.addOrOverride(ann);\n                 }\n             }\n             if (bundles != null) { // and then bundles, if any: important for precedence\n         _addAnnotationsIfNotPresent(target, src.getDeclaredAnnotations());\n     }\n \n-   private final boolean _isAnnotationBundle(Annotation ann)\n-   {\n+   private final boolean _isAnnotationBundle(Annotation ann) {\n        return (_annotationIntrospector != null) && _annotationIntrospector.isAnnotationBundle(ann);\n    }\n    \n      */\n \n     @Override\n-    public String toString()\n-    {\n+    public String toString() {\n         return \"[AnnotedClass \"+_class.getName()+\"]\";\n     }\n+\n+    @Override\n+    public int hashCode() {\n+        return _class.getName().hashCode();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        return ((AnnotatedClass) o)._class == _class;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java\n         return \"[constructor for \"+getName()+\", annotations: \"+_annotations+\"]\";\n     }\n \n+    @Override\n+    public int hashCode() {\n+        return _constructor.getName().hashCode();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        return ((AnnotatedConstructor) o)._constructor == _constructor;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JDK serialization handling\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java\n     public String getName() { return _field.getName(); }\n \n     @Override\n-    public <A extends Annotation> A getAnnotation(Class<A> acls)\n-    {\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n         return (_annotations == null) ? null : _annotations.get(acls);\n     }\n \n     public int getAnnotationCount() { return _annotations.size(); }\n \n     @Override\n-    public String toString()\n-    {\n+    public int hashCode() {\n+        return _field.getName().hashCode();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        return ((AnnotatedField) o)._field == _field;\n+    }\n+\n+    @Override\n+    public String toString() {\n         return \"[field \"+getFullName()+\"]\";\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n  * a class; fields, methods and constructors. This is a superset\n  * of things that can represent logical properties as it contains\n  * constructors in addition to fields and methods.\n- * \n- * @author tatu\n  */\n public abstract class AnnotatedMember\n     extends Annotated\n      * annotation masking or overriding an annotation 'real' constructor\n      * has.\n      */\n-    public final void addOrOverride(Annotation a) {\n-        _annotations.add(a);\n+    public final boolean addOrOverride(Annotation a) {\n+        return _annotations.add(a);\n     }\n \n     /**\n      * annotation if and only if it is not yet present in the\n      * annotation map we have.\n      */\n-    public final void addIfNotPresent(Annotation a) {\n-        _annotations.addIfNotPresent(a);\n+    public final boolean addIfNotPresent(Annotation a) {\n+        return _annotations.addIfNotPresent(a);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java\n     public Method getMember() { return _method; }\n \n     @Override\n-    public void setValue(Object pojo, Object value)\n-        throws IllegalArgumentException\n+    public void setValue(Object pojo, Object value) throws IllegalArgumentException\n     {\n         try {\n             _method.invoke(pojo, value);\n      */\n \n     @Override\n-    public String toString()\n-    {\n+    public String toString() {\n         return \"[method \"+getFullName()+\"]\";\n     }\n \n+    @Override\n+    public int hashCode() {\n+        return _method.getName().hashCode();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        return ((AnnotatedMethod) o)._method == _method;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JDK serialization handling\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java\n import java.lang.reflect.AnnotatedElement;\n import java.lang.reflect.Member;\n import java.lang.reflect.Type;\n-\n \n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n      */\n     \n     @Override\n-    public String toString()\n-    {\n+    public int hashCode() {\n+        return _owner.hashCode() + _index;\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null || o.getClass() != getClass()) return false;\n+        AnnotatedParameter other = (AnnotatedParameter) o;\n+        return other._owner.equals(_owner) && (other._index == _index);\n+    }\n+    \n+    @Override\n+    public String toString() {\n         return \"[parameter #\"+getIndex()+\", annotations: \"+_annotations+\"]\";\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n     public JsonInclude.Include findSerializationInclusion(Annotated a,\n             JsonInclude.Include defValue)\n     {\n-        /* This is bit trickier: need to combine results in a meaningful\n-         * way. Seems like it should be a disjoint; that is, most\n-         * restrictive value should be returned.\n-         * For enumerations, comparison is done by indexes, which\n-         * works: largest value is the last one, which is the most\n-         * restrictive value as well.\n-         */\n-        /* 09-Mar-2010, tatu: Actually, as per [JACKSON-256], it is probably better to just\n-         *    use strict overriding. Simpler, easier to understand.\n-         */\n         // note: call secondary first, to give lower priority\n         defValue = _secondary.findSerializationInclusion(a, defValue);\n         defValue = _primary.findSerializationInclusion(a, defValue);\n         return defValue;\n     }\n+\n+    @Override\n+    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)\n+    {\n+        // note: call secondary first, to give lower priority\n+        defValue = _secondary.findSerializationInclusion(a, defValue);\n+        defValue = _primary.findSerializationInclusion(a, defValue);\n+        return defValue;\n+    }\n     \n     @Override\n     public Class<?> findSerializationType(Annotated a) {\n-    \tClass<?> r = _primary.findSerializationType(a);\n+        Class<?> r = _primary.findSerializationType(a);\n         return (r == null) ? _secondary.findSerializationType(a) : r;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n      * Method called to add specified annotation in the Map, but\n      * only if it didn't yet exist.\n      */\n-    public void addIfNotPresent(Annotation ann)\n+    public boolean addIfNotPresent(Annotation ann)\n     {\n         if (_annotations == null || !_annotations.containsKey(ann.annotationType())) {\n             _add(ann);\n+            return true;\n         }\n+        return false;\n     }\n \n     /**\n      * Method called to add specified annotation in the Map.\n      */\n-    public void add(Annotation ann) {\n-        _add(ann);\n+    public boolean add(Annotation ann) {\n+        return _add(ann);\n     }\n \n     @Override\n     /**********************************************************\n      */\n \n-    protected final void _add(Annotation ann) {\n+    protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n-        _annotations.put(ann.annotationType(), ann);\n+        Annotation previous = _annotations.put(ann.annotationType(), ann);\n+        return (previous != null) && previous.equals(ann);\n     }\n }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n      * and per-class annotation (highest priority).\n      */\n     @Override\n-    public JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue)\n-    {\n+    public JsonInclude.Include findSerializationInclusion(JsonInclude.Include defValue) {\n         if (_annotationIntrospector == null) {\n             return defValue;\n         }\n         return _annotationIntrospector.findSerializationInclusion(_classInfo, defValue);\n+    }\n+\n+    @Override\n+    public JsonInclude.Include findSerializationInclusionForContent(JsonInclude.Include defValue) {\n+        if (_annotationIntrospector == null) {\n+            return defValue;\n+        }\n+        return _annotationIntrospector.findSerializationInclusionForContent(_classInfo, defValue);\n     }\n     \n     /**\n     public Map<String,AnnotatedMember> findBackReferenceProperties()\n     {\n         HashMap<String,AnnotatedMember> result = null;\n+//        boolean hasIgnored = (_ignoredPropertyNames != null);\n+\n         for (BeanPropertyDefinition property : _properties) {\n+            /* 23-Sep-2014, tatu: As per [Databind#426], we _should_ try to avoid\n+             *   calling accessor, as it triggers exception from seeming conflict.\n+             *   But the problem is that _ignoredPropertyNames here only contains\n+             *   ones ignored on per-property annotations, but NOT class annotations...\n+             *   so commented out part does not work, alas\n+             */\n+            /*\n+            if (hasIgnored && _ignoredPropertyNames.contains(property.getName())) {\n+                continue;\n+            }\n+            */\n             AnnotatedMember am = property.getMutator();\n             if (am == null) {\n                 continue;\n \n         /* Also: must be a recognized factory method, meaning:\n          * (a) marked with @JsonCreator annotation, or\n-         * (a) \"valueOf\" (at this point, need not be public)\n+         * (b) \"valueOf\" (at this point, need not be public)\n          */\n         if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n             return true;\n     }\n \n     /**\n-     * @deprecated Since 2.4, use {@link #findCreatorParameterNames()} instead.\n+     * @deprecated Since 2.4, use <code>findCreatorParameterNames()</code> instead.\n      */\n     @Deprecated\n     public List<String> findCreatorPropertyNames()\n     }\n     \n     /**\n-     * Method for getting ordered list of named Creator properties.\n-     * Returns an empty list is none found. If multiple Creator\n-     * methods are defined, order between properties from different\n-     * methods is undefined; however, properties for each such\n-     * Creator are ordered properly relative to each other.\n-     * For the usual case of just a single Creator, named properties are\n-     * thus properly ordered.\n-     * \n-     * @since 2.4\n-     */\n+     * @deprecated Since 2.5, does not seem to be used at all.\n+     */\n+    @Deprecated\n     public List<PropertyName> findCreatorParameterNames()\n     {\n         for (int i = 0; i < 2; ++i) {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n+\n+import java.util.Collection;\n+import java.util.Map;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.type.SimpleType;\n+import com.fasterxml.jackson.databind.util.LRUMap;\n \n public class BasicClassIntrospector\n     extends ClassIntrospector\n      * This is strictly performance optimization to reduce what is\n      * usually one-time cost, but seems useful for some cases considering\n      * simplicity.\n+     * \n+     * @since 2.4\n      */\n     \n     protected final static BasicBeanDescription STRING_DESC;\n     /**********************************************************\n      */\n \n+    @Deprecated // since 2.5: construct instance directly\n     public final static BasicClassIntrospector instance = new BasicClassIntrospector();\n \n-    public BasicClassIntrospector() { }\n+    /**\n+     * Looks like 'forClassAnnotations()' gets called so frequently that we\n+     * should consider caching to avoid some of the lookups.\n+     * \n+     * @since 2.5\n+     */\n+    protected final LRUMap<JavaType,BasicBeanDescription> _cachedFCA;\n+\n+    public BasicClassIntrospector() {\n+        // a small cache should go a long way here\n+        _cachedFCA = new LRUMap<JavaType,BasicBeanDescription>(16, 64);\n+    }\n     \n     /*\n     /**********************************************************\n     public BasicBeanDescription forSerialization(SerializationConfig cfg,\n             JavaType type, MixInResolver r)\n     {\n-        // minor optimization: for JDK types do minimal introspection\n-        BasicBeanDescription desc = _findCachedDesc(type);\n-        if (desc == null) {\n-            desc = BasicBeanDescription.forSerialization(collectProperties(cfg,\n-            \t\ttype, r, true, \"set\"));\n+        // minor optimization: for some JDK types do minimal introspection\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+            // As per [Databind#550], skip full introspection for some of standard\n+            // structured types as well\n+            desc = _findStdJdkCollectionDesc(cfg, type, r);\n+            if (desc == null) {\n+                desc = BasicBeanDescription.forSerialization(collectProperties(cfg,\n+                        type, r, true, \"set\"));\n+            }\n+            // Also: this is a superset of \"forClassAnnotations\", so may optimize by optional add:\n+            _cachedFCA.putIfAbsent(type, desc);\n         }\n         return desc;\n     }\n     public BasicBeanDescription forDeserialization(DeserializationConfig cfg,\n             JavaType type, MixInResolver r)\n     {\n-        // minor optimization: for JDK types do minimal introspection\n-        BasicBeanDescription desc = _findCachedDesc(type);\n-        if (desc == null) {\n-            desc = BasicBeanDescription.forDeserialization(collectProperties(cfg,\n-            \t\ttype, r, false, \"set\"));\n+        // minor optimization: for some JDK types do minimal introspection\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+            // As per [Databind#550], skip full introspection for some of standard\n+            // structured types as well\n+            desc = _findStdJdkCollectionDesc(cfg, type, r);\n+            if (desc == null) {\n+                desc = BasicBeanDescription.forDeserialization(collectProperties(cfg,\n+                        \t\ttype, r, false, \"set\"));\n+            }\n+            // Also: this is a superset of \"forClassAnnotations\", so may optimize by optional add:\n+            _cachedFCA.putIfAbsent(type, desc);\n         }\n         return desc;\n     }\n     public BasicBeanDescription forDeserializationWithBuilder(DeserializationConfig cfg,\n             JavaType type, MixInResolver r)\n     {\n-    \t// no caching for Builders (no standard JDK builder types):\n-    \treturn BasicBeanDescription.forDeserialization(collectPropertiesWithBuilder(cfg,\n-            \t\ttype, r, false));\n+        // no std JDK types with Builders, so:\n+\n+        BasicBeanDescription desc = BasicBeanDescription.forDeserialization(collectPropertiesWithBuilder(cfg,\n+                type, r, false));\n+        // this is still a superset of \"forClassAnnotations\", so may optimize by optional add:\n+        _cachedFCA.putIfAbsent(type, desc);\n+        return desc;\n     }\n     \n     @Override\n     public BasicBeanDescription forCreation(DeserializationConfig cfg,\n             JavaType type, MixInResolver r)\n     {\n-        BasicBeanDescription desc = _findCachedDesc(type);\n-        if (desc == null) {\n-            desc = BasicBeanDescription.forDeserialization(\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+\n+            // As per [Databind#550], skip full introspection for some of standard\n+            // structured types as well\n+            desc = _findStdJdkCollectionDesc(cfg, type, r);\n+            if (desc == null) {\n+                desc = BasicBeanDescription.forDeserialization(\n             \t\tcollectProperties(cfg, type, r, false, \"set\"));\n-        }\n+            }\n+        }\n+        // should this be cached for FCA?\n         return desc;\n     }\n \n     public BasicBeanDescription forClassAnnotations(MapperConfig<?> cfg,\n             JavaType type, MixInResolver r)\n     {\n-        boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n-        AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),\n-                (useAnnotations ? cfg.getAnnotationIntrospector() : null), r);\n-        return BasicBeanDescription.forOtherUse(cfg, type, ac);\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+            desc = _cachedFCA.get(type);\n+            if (desc == null) {\n+                boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n+                AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),\n+                        (useAnnotations ? cfg.getAnnotationIntrospector() : null), r);\n+                desc = BasicBeanDescription.forOtherUse(cfg, type, ac);\n+                _cachedFCA.put(type, desc);\n+            }\n+        }\n+        return desc;\n     }\n \n     @Override\n     public BasicBeanDescription forDirectClassAnnotations(MapperConfig<?> cfg,\n             JavaType type, MixInResolver r)\n     {\n-        boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n-        AnnotationIntrospector ai =  cfg.getAnnotationIntrospector();\n-        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(type.getRawClass(),\n-                (useAnnotations ? ai : null), r);\n-        return BasicBeanDescription.forOtherUse(cfg, type, ac);\n+        BasicBeanDescription desc = _findStdTypeDesc(type);\n+        if (desc == null) {\n+            boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n+            AnnotationIntrospector ai =  cfg.getAnnotationIntrospector();\n+            AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(type.getRawClass(),\n+                    (useAnnotations ? ai : null), r);\n+            desc = BasicBeanDescription.forOtherUse(cfg, type, ac);\n+        }\n+        return desc;\n     }\n     \n     /*\n      * Method called to see if type is one of core JDK types\n      * that we have cached for efficiency.\n      */\n-    protected BasicBeanDescription _findCachedDesc(JavaType type)\n+    protected BasicBeanDescription _findStdTypeDesc(JavaType type)\n     {\n         Class<?> cls = type.getRawClass();\n-        if (cls == String.class) {\n-            return STRING_DESC;\n-        }\n-        if (cls == Boolean.TYPE) {\n-            return BOOLEAN_DESC;\n-        }\n-        if (cls == Integer.TYPE) {\n-            return INT_DESC;\n-        }\n-        if (cls == Long.TYPE) {\n-            return LONG_DESC;\n+        if (cls.isPrimitive()) {\n+            if (cls == Boolean.TYPE) {\n+                return BOOLEAN_DESC;\n+            }\n+            if (cls == Integer.TYPE) {\n+                return INT_DESC;\n+            }\n+            if (cls == Long.TYPE) {\n+                return LONG_DESC;\n+            }\n+        } else {\n+            if (cls == String.class) {\n+                return STRING_DESC;\n+            }\n         }\n         return null;\n     }\n+\n+    /**\n+     * Helper method used to decide whether we can omit introspection\n+     * for members (methods, fields, constructors); we may do so for\n+     * a limited number of container types JDK provides.\n+     */\n+    protected boolean _isStdJDKCollection(JavaType type)\n+    {\n+        if (!type.isContainerType() || type.isArrayType()) {\n+            return false;\n+        }\n+        Class<?> raw = type.getRawClass();\n+        Package pkg = raw.getPackage();\n+        if (pkg != null) {\n+            String pkgName = pkg.getName();\n+            if (pkgName.startsWith(\"java.lang\")\n+                    || pkgName.startsWith(\"java.util\")) {\n+                /* 23-Sep-2014, tatu: Should we be conservative here (minimal number\n+                 *    of matches), or ambitious? Let's do latter for now.\n+                 */\n+                if (Collection.class.isAssignableFrom(raw)\n+                        || Map.class.isAssignableFrom(raw)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected BasicBeanDescription _findStdJdkCollectionDesc(MapperConfig<?> cfg,\n+            JavaType type, MixInResolver r)\n+    {\n+        if (_isStdJDKCollection(type)) {\n+            AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(),\n+                    (cfg.isAnnotationProcessingEnabled() ? cfg.getAnnotationIntrospector() : null), r);\n+            return BasicBeanDescription.forOtherUse(cfg, type, ac);\n+        }\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n package com.fasterxml.jackson.databind.introspect;\n \n-import com.fasterxml.jackson.databind.AnnotationIntrospector;\n-import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.PropertyMetadata;\n-import com.fasterxml.jackson.databind.PropertyName;\n+import java.util.Iterator;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.EmptyIterator;\n import com.fasterxml.jackson.databind.util.Named;\n \n /**\n     public abstract AnnotatedParameter getConstructorParameter();\n \n     /**\n+     * Additional method that may be called instead of {@link #getConstructorParameter()}\n+     * to get access to all constructor parameters, not just the highest priority one.\n+     * \n+     * @since 2.5\n+     */\n+    public Iterator<AnnotatedParameter> getConstructorParameters() {\n+        return EmptyIterator.instance();\n+    }\n+    \n+    /**\n      * Method used to find accessor (getter, field to access) to use for accessing\n      * value of the property.\n      * Null if no such member exists.\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n     @Override\n     public PropertyName findRootName(AnnotatedClass ac)\n     {\n-        JsonRootName ann = ac.getAnnotation(JsonRootName.class);\n+        JsonRootName ann = _findAnnotation(ac, JsonRootName.class);\n         if (ann == null) {\n             return null;\n         }\n \n     @Override\n     public String[] findPropertiesToIgnore(Annotated ac) {\n-        JsonIgnoreProperties ignore = ac.getAnnotation(JsonIgnoreProperties.class);\n+        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n         return (ignore == null) ? null : ignore.value();\n     }\n \n     @Override\n     public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n-        JsonIgnoreProperties ignore = ac.getAnnotation(JsonIgnoreProperties.class);\n+        JsonIgnoreProperties ignore = _findAnnotation(ac, JsonIgnoreProperties.class);\n         return (ignore == null) ? null : ignore.ignoreUnknown();\n     }\n \n     @Override\n     public Boolean isIgnorableType(AnnotatedClass ac) {\n-        JsonIgnoreType ignore = ac.getAnnotation(JsonIgnoreType.class);\n+        JsonIgnoreType ignore = _findAnnotation(ac, JsonIgnoreType.class);\n         return (ignore == null) ? null : ignore.value();\n     }\n \n \n     protected final Object _findFilterId(Annotated a)\n     {\n-        JsonFilter ann = a.getAnnotation(JsonFilter.class);\n+        JsonFilter ann = _findAnnotation(a, JsonFilter.class);\n         if (ann != null) {\n             String id = ann.value();\n             // Empty String is same as not having annotation, to allow overrides\n     @Override\n     public Object findNamingStrategy(AnnotatedClass ac)\n     {\n-        JsonNaming ann = ac.getAnnotation(JsonNaming.class);\n+        JsonNaming ann = _findAnnotation(ac, JsonNaming.class);\n         return (ann == null) ? null : ann.value();\n     } \n \n     public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n         VisibilityChecker<?> checker)\n     {\n-        JsonAutoDetect ann = ac.getAnnotation(JsonAutoDetect.class);\n+        JsonAutoDetect ann = _findAnnotation(ac, JsonAutoDetect.class);\n         return (ann == null) ? checker : checker.with(ann);\n     }\n \n     @Override        \n     public ReferenceProperty findReferenceType(AnnotatedMember member)\n     {\n-        JsonManagedReference ref1 = member.getAnnotation(JsonManagedReference.class);\n+        JsonManagedReference ref1 = _findAnnotation(member, JsonManagedReference.class);\n         if (ref1 != null) {\n             return AnnotationIntrospector.ReferenceProperty.managed(ref1.value());\n         }\n-        JsonBackReference ref2 = member.getAnnotation(JsonBackReference.class);\n+        JsonBackReference ref2 = _findAnnotation(member, JsonBackReference.class);\n         if (ref2 != null) {\n             return AnnotationIntrospector.ReferenceProperty.back(ref2.value());\n         }\n     @Override\n     public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)\n     {\n-        JsonUnwrapped ann = member.getAnnotation(JsonUnwrapped.class);\n+        JsonUnwrapped ann = _findAnnotation(member, JsonUnwrapped.class);\n         // if not enabled, just means annotation is not enabled; not necessarily\n         // that unwrapping should not be done (relevant when using chained introspectors)\n         if (ann == null || !ann.enabled()) {\n     @Override\n     public Boolean hasRequiredMarker(AnnotatedMember m)\n     {\n-        JsonProperty ann = m.getAnnotation(JsonProperty.class);\n+        JsonProperty ann = _findAnnotation(m, JsonProperty.class);\n         if (ann != null) {\n             return ann.required();\n         }\n     @Override\n     public Object findInjectableValueId(AnnotatedMember m)\n     {\n-        JacksonInject ann = m.getAnnotation(JacksonInject.class);\n+        JacksonInject ann = _findAnnotation(m, JacksonInject.class);\n         if (ann == null) {\n             return null;\n         }\n     @Override\n     public List<NamedType> findSubtypes(Annotated a)\n     {\n-        JsonSubTypes t = a.getAnnotation(JsonSubTypes.class);\n+        JsonSubTypes t = _findAnnotation(a, JsonSubTypes.class);\n         if (t == null) return null;\n         JsonSubTypes.Type[] types = t.value();\n         ArrayList<NamedType> result = new ArrayList<NamedType>(types.length);\n     @Override        \n     public String findTypeName(AnnotatedClass ac)\n     {\n-        JsonTypeName tn = ac.getAnnotation(JsonTypeName.class);\n+        JsonTypeName tn = _findAnnotation(ac, JsonTypeName.class);\n         return (tn == null) ? null : tn.value();\n     }\n \n     @Override\n     public Object findSerializer(Annotated a)\n     {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         if (ann != null) {\n             Class<? extends JsonSerializer<?>> serClass = ann.using();\n             if (serClass != JsonSerializer.None.class) {\n          *  if we need to get raw indicator from other sources need to add\n          *  separate accessor within {@link AnnotationIntrospector} interface.\n          */\n-        JsonRawValue annRaw =  a.getAnnotation(JsonRawValue.class);\n+        JsonRawValue annRaw =  _findAnnotation(a, JsonRawValue.class);\n         if ((annRaw != null) && annRaw.value()) {\n             // let's construct instance with nominal type:\n             Class<?> cls = a.getRawType();\n     @Override\n     public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a)\n     {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         if (ann != null) {\n             Class<? extends JsonSerializer<?>> serClass = ann.keyUsing();\n             if (serClass != JsonSerializer.None.class) {\n     @Override\n     public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a)\n     {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         if (ann != null) {\n             Class<? extends JsonSerializer<?>> serClass = ann.contentUsing();\n             if (serClass != JsonSerializer.None.class) {\n     @Override\n     public Object findNullSerializer(Annotated a)\n     {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         if (ann != null) {\n             Class<? extends JsonSerializer<?>> serClass = ann.nullsUsing();\n             if (serClass != JsonSerializer.None.class) {\n     @Override\n     public JsonInclude.Include findSerializationInclusion(Annotated a, JsonInclude.Include defValue)\n     {\n-        JsonInclude inc = a.getAnnotation(JsonInclude.class);\n+        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n         if (inc != null) {\n             return inc.value();\n         }\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         if (ann != null) {\n             @SuppressWarnings(\"deprecation\")\n             JsonSerialize.Inclusion i2 = ann.include();\n     }\n \n     @Override\n+    public JsonInclude.Include findSerializationInclusionForContent(Annotated a, JsonInclude.Include defValue)\n+    {\n+        JsonInclude inc = _findAnnotation(a, JsonInclude.class);\n+        return (inc == null) ? defValue : inc.content();\n+    }\n+\n+    @Override\n     public Class<?> findSerializationType(Annotated am)\n     {\n-        JsonSerialize ann = am.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.as());\n     }\n     \n     @Override\n     public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n     {\n-        JsonSerialize ann = am.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n     }\n \n     @Override\n     public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n     {\n-        JsonSerialize ann = am.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(am, JsonSerialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n     }\n     \n     @Override\n     public JsonSerialize.Typing findSerializationTyping(Annotated a)\n     {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         return (ann == null) ? null : ann.typing();\n     }\n \n     @Override\n     public Object findSerializationConverter(Annotated a) {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n     }\n \n     @Override\n     public Object findSerializationContentConverter(AnnotatedMember a) {\n-        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        JsonSerialize ann = _findAnnotation(a, JsonSerialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n     }\n     \n     @Override\n     public Class<?>[] findViews(Annotated a)\n     {\n-        JsonView ann = a.getAnnotation(JsonView.class);\n+        JsonView ann = _findAnnotation(a, JsonView.class);\n         return (ann == null) ? null : ann.value();\n     }\n \n     @Override\n     public Boolean isTypeId(AnnotatedMember member) {\n-        return member.hasAnnotation(JsonTypeId.class);\n+        return _hasAnnotation(member, JsonTypeId.class);\n     }\n \n     @Override\n     public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n-        JsonIdentityInfo info = ann.getAnnotation(JsonIdentityInfo.class);\n+        JsonIdentityInfo info = _findAnnotation(ann, JsonIdentityInfo.class);\n         if (info == null || info.generator() == ObjectIdGenerators.None.class) {\n             return null;\n         }\n \n     @Override\n     public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-        JsonIdentityReference ref = ann.getAnnotation(JsonIdentityReference.class);\n+        JsonIdentityReference ref = _findAnnotation(ann, JsonIdentityReference.class);\n         if (ref != null) {\n             objectIdInfo = objectIdInfo.withAlwaysAsId(ref.alwaysAsId());\n         }\n     }\n     \n     @Override\n-    public JsonFormat.Value findFormat(Annotated annotated) {\n-        JsonFormat ann = annotated.getAnnotation(JsonFormat.class);\n-        return (ann == null)  ? null : new JsonFormat.Value(ann);\n-    }\n-\n-    @Override\n-    public String findPropertyDescription(Annotated annotated) {\n-        JsonPropertyDescription desc = annotated.getAnnotation(JsonPropertyDescription.class);\n+    public JsonFormat.Value findFormat(Annotated ann) {\n+        JsonFormat f = _findAnnotation(ann, JsonFormat.class);\n+        return (f == null)  ? null : new JsonFormat.Value(f);\n+    }\n+\n+    @Override\n+    public String findPropertyDescription(Annotated ann) {\n+        JsonPropertyDescription desc = _findAnnotation(ann, JsonPropertyDescription.class);\n         return (desc == null) ? null : desc.value();\n     }\n \n     @Override\n-    public Integer findPropertyIndex(Annotated annotated) {\n-        JsonProperty ann = annotated.getAnnotation(JsonProperty.class);\n-        if (ann != null) {\n-        \tint ix = ann.index();\n+    public Integer findPropertyIndex(Annotated ann) {\n+        JsonProperty prop = _findAnnotation(ann, JsonProperty.class);\n+        if (prop != null) {\n+        \tint ix = prop.index();\n         \tif (ix != JsonProperty.INDEX_UNKNOWN) {\n         \t\treturn Integer.valueOf(ix);\n         \t}\n \n     @Override\n     public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n-        JsonPropertyOrder order = ac.getAnnotation(JsonPropertyOrder.class);\n+        JsonPropertyOrder order = _findAnnotation(ac, JsonPropertyOrder.class);\n         return (order == null) ? null : order.value();\n     }\n \n     }\n \n     private final Boolean _findSortAlpha(Annotated ann) {\n-        JsonPropertyOrder order = ann.getAnnotation(JsonPropertyOrder.class);\n+        JsonPropertyOrder order = _findAnnotation(ann, JsonPropertyOrder.class);\n         return (order == null) ? null : order.alphabetic();\n     }\n     \n     {\n         String name = null;\n \n-        JsonGetter jg = a.getAnnotation(JsonGetter.class);\n+        JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n         if (jg != null) {\n             name = jg.value();\n         } else {\n-            JsonProperty pann = a.getAnnotation(JsonProperty.class);\n+            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n             if (pann != null) {\n                 name = pann.value();\n-            } else if (a.hasAnnotation(JsonSerialize.class) || a.hasAnnotation(JsonView.class)) {\n+            } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class)) {\n                 name = \"\";\n             } else {\n                 return null;\n \n     @Override\n     public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n-        JsonValue ann = am.getAnnotation(JsonValue.class);\n+        JsonValue ann = _findAnnotation(am, JsonValue.class);\n         // value of 'false' means disabled...\n         return (ann != null && ann.value());\n     }\n     @Override\n     public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a)\n     {\n-        JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n         if (ann != null) {\n             Class<? extends JsonDeserializer<?>> deserClass = ann.using();\n             if (deserClass != JsonDeserializer.None.class) {\n     @Override\n     public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a)\n     {\n-        JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n         if (ann != null) {\n             Class<? extends KeyDeserializer> deserClass = ann.keyUsing();\n             if (deserClass != KeyDeserializer.None.class) {\n     @Override\n     public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a)\n     {\n-        JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n         if (ann != null) {\n             Class<? extends JsonDeserializer<?>> deserClass = ann.contentUsing();\n             if (deserClass != JsonDeserializer.None.class) {\n \n     @Override\n     public Class<?> findDeserializationType(Annotated am, JavaType baseType) {\n-        JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.as());\n     }\n \n     @Override\n     public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType) {\n-        JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.keyAs());\n     }\n \n     @Override\n     public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)\n     {\n-        JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(am, JsonDeserialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.contentAs());\n     }\n \n     @Override\n     public Object findDeserializationConverter(Annotated a)\n     {\n-        JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.converter(), Converter.None.class);\n     }\n \n     @Override\n     public Object findDeserializationContentConverter(AnnotatedMember a)\n     {\n-        JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(a, JsonDeserialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.contentConverter(), Converter.None.class);\n     }\n \n     @Override\n     public Object findValueInstantiator(AnnotatedClass ac)\n     {\n-        JsonValueInstantiator ann = ac.getAnnotation(JsonValueInstantiator.class);\n+        JsonValueInstantiator ann = _findAnnotation(ac, JsonValueInstantiator.class);\n         // no 'null' marker yet, so:\n         return (ann == null) ? null : ann.value();\n     }\n     @Override\n     public Class<?> findPOJOBuilder(AnnotatedClass ac)\n     {\n-        JsonDeserialize ann = ac.getAnnotation(JsonDeserialize.class);\n+        JsonDeserialize ann = _findAnnotation(ac, JsonDeserialize.class);\n         return (ann == null) ? null : _classIfExplicit(ann.builder());\n     }\n \n     @Override\n     public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)\n     {\n-        JsonPOJOBuilder ann = ac.getAnnotation(JsonPOJOBuilder.class);\n+        JsonPOJOBuilder ann = _findAnnotation(ac, JsonPOJOBuilder.class);\n         return (ann == null) ? null : new JsonPOJOBuilder.Value(ann);\n     }\n     \n \n         // @JsonSetter has precedence over @JsonProperty, being more specific\n         // @JsonDeserialize implies that there is a property, but no name\n-        JsonSetter js = a.getAnnotation(JsonSetter.class);\n+        JsonSetter js = _findAnnotation(a, JsonSetter.class);\n         if (js != null) {\n             name = js.value();\n         } else {\n-            JsonProperty pann = a.getAnnotation(JsonProperty.class);\n+            JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n             if (pann != null) {\n                 name = pann.value();\n                 /* 22-Apr-2014, tatu: Should figure out a better way to do this, but\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n-            } else if (a.hasAnnotation(JsonDeserialize.class)\n-                    || a.hasAnnotation(JsonView.class)\n-                    || a.hasAnnotation(JsonUnwrapped.class) // [#442]\n-                    || a.hasAnnotation(JsonBackReference.class)\n-                    || a.hasAnnotation(JsonManagedReference.class)) {\n+            } else if (_hasAnnotation(a, JsonDeserialize.class)\n+                    || _hasAnnotation(a, JsonView.class)\n+                    || _hasAnnotation(a, JsonUnwrapped.class) // [#442]\n+                    || _hasAnnotation(a, JsonBackReference.class)\n+                    || _hasAnnotation(a, JsonManagedReference.class)) {\n                     name = \"\";\n             } else {\n                 return null;\n          * if needs to be ignored (and if so, is handled prior\n          * to this method getting called)\n          */\n-        return am.hasAnnotation(JsonAnySetter.class);\n+        return _hasAnnotation(am, JsonAnySetter.class);\n     }\n \n     @Override\n         /* No dedicated disabling; regular @JsonIgnore used\n          * if needs to be ignored (handled separately\n          */\n-        return am.hasAnnotation(JsonAnyGetter.class);\n+        return _hasAnnotation(am, JsonAnyGetter.class);\n     }\n     \n     @Override\n          * if needs to be ignored (and if so, is handled prior\n          * to this method getting called)\n          */\n-        return a.hasAnnotation(JsonCreator.class);\n-    }\n-\n+        return _hasAnnotation(a, JsonCreator.class);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods\n \n     protected boolean _isIgnorable(Annotated a)\n     {\n-        JsonIgnore ann = a.getAnnotation(JsonIgnore.class);\n+        JsonIgnore ann = _findAnnotation(a, JsonIgnore.class);\n         return (ann != null && ann.value());\n     }\n \n      * Helper method called to construct and initialize instance of {@link TypeResolverBuilder}\n      * if given annotated element indicates one is needed.\n      */\n+    @SuppressWarnings(\"deprecation\")\n     protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config,\n             Annotated ann, JavaType baseType)\n     {\n         // First: maybe we have explicit type resolver?\n         TypeResolverBuilder<?> b;\n-        JsonTypeInfo info = ann.getAnnotation(JsonTypeInfo.class);\n-        JsonTypeResolver resAnn = ann.getAnnotation(JsonTypeResolver.class);\n+        JsonTypeInfo info = _findAnnotation(ann, JsonTypeInfo.class);\n+        JsonTypeResolver resAnn = _findAnnotation(ann, JsonTypeResolver.class);\n         \n         if (resAnn != null) {\n             if (info == null) {\n             b = _constructStdTypeResolverBuilder();\n         }\n         // Does it define a custom type id resolver?\n-        JsonTypeIdResolver idResInfo = ann.getAnnotation(JsonTypeIdResolver.class);\n+        JsonTypeIdResolver idResInfo = _findAnnotation(ann, JsonTypeIdResolver.class);\n         TypeIdResolver idRes = (idResInfo == null) ? null\n                 : config.typeIdResolverInstance(ann, idResInfo.value());\n         if (idRes != null) { // [JACKSON-359]\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n         if (!expl) {\n             if (impl.isEmpty()) {\n                 /* Important: if neither implicit nor explicit name, can not make use\n-                 * of this creator paramter -- may or may not be a problem, verified\n+                 * of this creator parameter -- may or may not be a problem, verified\n                  * at a later point.\n                  */\n+                return;\n+            }\n+            // Also: if this occurs, there MUST be explicit annotation on creator itself\n+            if (!_annotationIntrospector.hasCreatorAnnotation(param.getOwner())) {\n                 return;\n             }\n             pn = new PropertyName(impl);\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.EmptyIterator;\n \n /**\n  * Helper class used for aggregating information about a single\n         _annotationIntrospector = annotationIntrospector;\n         _forSerialization = forSerialization;\n     }\n-    \n-    @Deprecated // since 2.3\n-    public POJOPropertyBuilder(String simpleInternalName,\n-            AnnotationIntrospector annotationIntrospector, boolean forSerialization)\n-    {\n-        this(new PropertyName(simpleInternalName), annotationIntrospector, forSerialization);\n-    }\n \n     public POJOPropertyBuilder(POJOPropertyBuilder src, PropertyName newName)\n     {\n     /* Fluent factory methods\n     /**********************************************************\n      */\n-\n-    @Deprecated // since 2.3\n-    @Override\n-    public POJOPropertyBuilder withName(String newName) {\n-        return withSimpleName(newName);\n-    }\n \n     @Override\n     public POJOPropertyBuilder withName(PropertyName newName) {\n             curr = curr.next;\n         } while (curr != null);\n         return _ctorParameters.value;\n+    }\n+\n+    @Override\n+    public Iterator<AnnotatedParameter> getConstructorParameters() {\n+        if (_ctorParameters == null) {\n+            return EmptyIterator.instance();\n+        }\n+        return new MemberIterator<AnnotatedParameter>(_ctorParameters);\n     }\n     \n     @Override\n     private interface WithMember<T> {\n         public T withMember(AnnotatedMember member);\n     }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected static class MemberIterator<T extends AnnotatedMember>\n+        implements Iterator<T>\n+    {\n+        private Linked<T> next;\n+        \n+        public MemberIterator(Linked<T> first) {\n+            next = first;\n+        }\n+        \n+        @Override\n+        public boolean hasNext() {\n+            return (next != null);\n+        }\n+\n+        @Override\n+        public T next() {\n+            if (next == null) throw new NoSuchElementException();\n+            T result = next.value;\n+            next = next.next;\n+            return result;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+        \n+    }\n     \n     /**\n      * Node used for creating simple linked lists to efficiently store small sets\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n  *<p>\n  * Note on type declaration: funky recursive type is necessary to\n  * support builder/fluent pattern.\n- * \n- * @author tatu\n  */\n public interface VisibilityChecker<T extends VisibilityChecker<T>>\n {\n         implements VisibilityChecker<Std>,\n             java.io.Serializable\n     {\n-        private static final long serialVersionUID = -7073939237187922755L;\n+        private static final long serialVersionUID = 1;\n \n         /**\n          * This is the canonical base instance, configured with default\n         }\n \n         /**\n-         * Costructor that will assign given visibility value for all\n+         * Constructor that will assign given visibility value for all\n          * properties.\n          * \n          * @param v level to use for all property types\n         /********************************************************\n          */\n \n-    @Override\n-    public Std with(JsonAutoDetect ann)\n-    {\n-        Std curr = this;\n-        if (ann != null) {\n-    \t    curr = curr.withGetterVisibility(ann.getterVisibility());\n-    \t    curr = curr.withIsGetterVisibility(ann.isGetterVisibility());\n-                curr  = curr.withSetterVisibility(ann.setterVisibility());\n-                curr = curr.withCreatorVisibility(ann.creatorVisibility());\n-                curr = curr.withFieldVisibility(ann.fieldVisibility());\n-\t    }\n-\t    return curr;\n-\t}\n-\n-    @Override\n-    public Std with(Visibility v)\n-    {\n-        if (v == Visibility.DEFAULT) {\n-            return DEFAULT;\n-        }\n-        return new Std(v);\n-    }\n-\n-    @Override\n-    public Std withVisibility(PropertyAccessor method, Visibility v)\n-    {\n-\t    switch (method) {\n-\t    case GETTER:\n-\t        return withGetterVisibility(v);\n-\t    case SETTER:\n-\t        return withSetterVisibility(v);\n-\t    case CREATOR:\n-\t        return withCreatorVisibility(v);\n-\t    case FIELD:\n-\t        return withFieldVisibility(v);\n-\t    case IS_GETTER:\n-\t        return withIsGetterVisibility(v);\n+        @Override\n+        public Std with(JsonAutoDetect ann)\n+        {\n+            Std curr = this;\n+            if (ann != null) {\n+        \t    curr = curr.withGetterVisibility(ann.getterVisibility());\n+        \t    curr = curr.withIsGetterVisibility(ann.isGetterVisibility());\n+                    curr  = curr.withSetterVisibility(ann.setterVisibility());\n+                    curr = curr.withCreatorVisibility(ann.creatorVisibility());\n+                    curr = curr.withFieldVisibility(ann.fieldVisibility());\n+            }\n+            return curr;\n+        }\n+\n+        @Override\n+        public Std with(Visibility v)\n+        {\n+            if (v == Visibility.DEFAULT) {\n+                return DEFAULT;\n+            }\n+            return new Std(v);\n+        }\n+    \n+        @Override\n+        public Std withVisibility(PropertyAccessor method, Visibility v)\n+        {\n+            switch (method) {\n+            case GETTER:\n+                return withGetterVisibility(v);\n+            case SETTER:\n+                return withSetterVisibility(v);\n+            case CREATOR:\n+                return withCreatorVisibility(v);\n+            case FIELD:\n+                return withFieldVisibility(v);\n+            case IS_GETTER:\n+                return withIsGetterVisibility(v);\n             case ALL:\n                 return with(v);\n-        //case NONE:\n-        default:\n-            // break;\n-            return this;\n-\t    }\n-\t}\n+            //case NONE:\n+            default:\n+                // break;\n+                return this;\n+            }\n+        }\n \t\n-    @Override\n-\tpublic Std withGetterVisibility(Visibility v) {\n-\t    if (v == Visibility.DEFAULT)  v = DEFAULT._getterMinLevel;\n+        @Override\n+        public Std withGetterVisibility(Visibility v) {\n+            if (v == Visibility.DEFAULT)  v = DEFAULT._getterMinLevel;\n             if (_getterMinLevel == v) return this;\n-\t    return new Std(v, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, _fieldMinLevel);\n-\t}\n-\n-    @Override\n+            return new Std(v, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, _fieldMinLevel);\n+        }\n+\n+        @Override\n         public Std withIsGetterVisibility(Visibility v) {\n             if (v == Visibility.DEFAULT)  v = DEFAULT._isGetterMinLevel;\n             if (_isGetterMinLevel == v) return this;\n             return new Std(_getterMinLevel, v, _setterMinLevel, _creatorMinLevel, _fieldMinLevel);\n         }\n+\n+        @Override\n+        public Std withSetterVisibility(Visibility v) {\n+            if (v == Visibility.DEFAULT)  v = DEFAULT._setterMinLevel;\n+            if (_setterMinLevel == v) return this;\n+            return new Std(_getterMinLevel, _isGetterMinLevel, v, _creatorMinLevel, _fieldMinLevel);\n+        }\n+    \n+        @Override\n+        public Std withCreatorVisibility(Visibility v) {\n+            if (v == Visibility.DEFAULT)  v = DEFAULT._creatorMinLevel;\n+            if (_creatorMinLevel == v) return this;\n+            return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, v, _fieldMinLevel);\n+        }\n+    \n+        @Override\n+        public Std withFieldVisibility(Visibility v) {\n+            if (v == Visibility.DEFAULT)  v = DEFAULT._fieldMinLevel;\n+            if (_fieldMinLevel == v) return this;\n+            return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, v);\n+        }\n \t\t\n-    @Override\n-    public Std withSetterVisibility(Visibility v) {\n-        if (v == Visibility.DEFAULT)  v = DEFAULT._setterMinLevel;\n-        if (_setterMinLevel == v) return this;\n-        return new Std(_getterMinLevel, _isGetterMinLevel, v, _creatorMinLevel, _fieldMinLevel);\n-    }\n-\n-    @Override\n-    public Std withCreatorVisibility(Visibility v) {\n-        if (v == Visibility.DEFAULT)  v = DEFAULT._creatorMinLevel;\n-        if (_creatorMinLevel == v) return this;\n-        return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, v, _fieldMinLevel);\n-    }\n-\n-    @Override\n-    public Std withFieldVisibility(Visibility v) {\n-        if (v == Visibility.DEFAULT)  v = DEFAULT._fieldMinLevel;\n-        if (_fieldMinLevel == v) return this;\n-        return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, v);\n-    }\n-\t\t\n-    /*\n-    /********************************************************\n-    /* Public API impl\n-    /********************************************************\n-     */\n-\n-    @Override\n-    public boolean isCreatorVisible(Member m) {\n-        return _creatorMinLevel.isVisible(m);\n-    }\n-\t\n-    @Override\n-    public boolean isCreatorVisible(AnnotatedMember m) {\n-        return isCreatorVisible(m.getMember());\n-    }\n-    \n-    @Override\n-    public boolean isFieldVisible(Field f) {\n-        return _fieldMinLevel.isVisible(f);\n-    }\n-    \n-    @Override\n-    public boolean isFieldVisible(AnnotatedField f) {\n-        return isFieldVisible(f.getAnnotated());\n-    }\n-    \n-    @Override\n-    public boolean isGetterVisible(Method m) {\n-        return _getterMinLevel.isVisible(m);\n-    }\n-\n-    @Override\n-    public boolean isGetterVisible(AnnotatedMethod m) {\n-         return isGetterVisible(m.getAnnotated());\n-    }\n-\n-    @Override\n-    public boolean isIsGetterVisible(Method m) {\n-        return _isGetterMinLevel.isVisible(m);\n-    }    \n-\n-    @Override\n-    public boolean isIsGetterVisible(AnnotatedMethod m) {\n-        return isIsGetterVisible(m.getAnnotated());\n-    }\n-\n-    @Override\n-    public boolean isSetterVisible(Method m) {\n-        return _setterMinLevel.isVisible(m);\n-    }\n-    \n-    @Override\n-    public boolean isSetterVisible(AnnotatedMethod m) {\n-        return isSetterVisible(m.getAnnotated());\n-    }\n-\n-    /*\n-    /********************************************************\n-    /* Standard methods\n-    /********************************************************\n-     */\n-\n-    @Override\n-    public String toString() {\n-        return new StringBuilder(\"[Visibility:\")\n-        .append(\" getter: \").append(_getterMinLevel)\n-        .append(\", isGetter: \").append(_isGetterMinLevel)\n-        .append(\", setter: \").append(_setterMinLevel)\n-        .append(\", creator: \").append(_creatorMinLevel)\n-        .append(\", field: \").append(_fieldMinLevel)\n-        .append(\"]\").toString();\n-    }\n+        /*\n+        /********************************************************\n+        /* Public API impl\n+        /********************************************************\n+         */\n+\n+        @Override\n+        public boolean isCreatorVisible(Member m) {\n+            return _creatorMinLevel.isVisible(m);\n+        }\n+    \t\n+        @Override\n+        public boolean isCreatorVisible(AnnotatedMember m) {\n+            return isCreatorVisible(m.getMember());\n+        }\n+\n+        @Override\n+        public boolean isFieldVisible(Field f) {\n+            return _fieldMinLevel.isVisible(f);\n+        }\n+        \n+        @Override\n+        public boolean isFieldVisible(AnnotatedField f) {\n+            return isFieldVisible(f.getAnnotated());\n+        }\n+        \n+        @Override\n+        public boolean isGetterVisible(Method m) {\n+            return _getterMinLevel.isVisible(m);\n+        }\n+    \n+        @Override\n+        public boolean isGetterVisible(AnnotatedMethod m) {\n+             return isGetterVisible(m.getAnnotated());\n+        }\n+    \n+        @Override\n+        public boolean isIsGetterVisible(Method m) {\n+            return _isGetterMinLevel.isVisible(m);\n+        }    \n+    \n+        @Override\n+        public boolean isIsGetterVisible(AnnotatedMethod m) {\n+            return isIsGetterVisible(m.getAnnotated());\n+        }\n+    \n+        @Override\n+        public boolean isSetterVisible(Method m) {\n+            return _setterMinLevel.isVisible(m);\n+        }\n+        \n+        @Override\n+        public boolean isSetterVisible(AnnotatedMethod m) {\n+            return isSetterVisible(m.getAnnotated());\n+        }\n+\n+        /*\n+        /********************************************************\n+        /* Standard methods\n+        /********************************************************\n+         */\n+    \n+        @Override\n+        public String toString() {\n+            return new StringBuilder(\"[Visibility:\")\n+            .append(\" getter: \").append(_getterMinLevel)\n+            .append(\", isGetter: \").append(_isGetterMinLevel)\n+            .append(\", setter: \").append(_setterMinLevel)\n+            .append(\", creator: \").append(_creatorMinLevel)\n+            .append(\", field: \").append(_fieldMinLevel)\n+            .append(\"]\").toString();\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n     extends TypeDeserializerBase\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 5345570420394408290L;\n+    private static final long serialVersionUID = 1L;\n \n     public AsArrayTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n             String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n         String typeId = _locateTypeId(jp, ctxt);\n         JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n         // Minor complication: we may need to merge type id in?\n-        if (_typeIdVisible && jp.getCurrentToken() == JsonToken.START_OBJECT) {\n+        if (_typeIdVisible\n+                // 06-Oct-2014, tatu: To fix [databind#408], must distinguish between\n+                //   internal and external properties\n+                //  TODO: but does it need to be injected in external case? Why not?\n+                && !_usesExternalId()\n+                && jp.getCurrentToken() == JsonToken.START_OBJECT) {\n             // but what if there's nowhere to add it in? Error? Or skip? For now, skip.\n             TokenBuffer tb = new TokenBuffer(null, false);\n             tb.writeStartObject(); // recreate START_OBJECT\n     protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         if (!jp.isExpectedStartArrayToken()) {\n-            // [JACKSON-712] Need to allow even more customized handling, if something unexpected seen...\n+            // Need to allow even more customized handling, if something unexpected seen...\n             // but should there be a way to limit this to likely success cases?\n             if (_defaultImpl != null) {\n                 return _idResolver.idFromBaseType();\n         }\n         throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING, \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n     }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected boolean _usesExternalId() {\n+        return false;\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExistingPropertyTypeSerializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type serializer used with {@link As#EXISTING_PROPERTY} inclusion mechanism.\n+ * Expects type information to be a well-defined property on all sub-classes.\n+ * \n+ * @author fleeman (modeled after code by tatus)\n+ */\n+public class AsExistingPropertyTypeSerializer\n+    extends AsPropertyTypeSerializer\n+{\n+\n+    public AsExistingPropertyTypeSerializer(TypeIdResolver idRes, BeanProperty property, String propName)\n+    {\n+        super(idRes, property, propName);\n+    }\n+\n+    @Override\n+    public AsExistingPropertyTypeSerializer forProperty(BeanProperty prop) {\n+        return (_property == prop) ? this : new AsExistingPropertyTypeSerializer(this._idResolver, prop, this._typePropertyName);\n+    }\n+    \n+    @Override\n+    public As getTypeInclusion() { return As.EXISTING_PROPERTY; }\n+    \n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen) throws IOException\n+    {\n+        final String typeId = idFromValue(value);\n+        if (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type) throws IOException\n+    {\n+        final String typeId = idFromValueAndType(value, type);\n+        if (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+    \n+    @Override\n+    public void writeCustomTypePrefixForObject(Object value, JsonGenerator jgen, String typeId) throws IOException\n+    {\n+    \tif (jgen.canWriteTypeId()) {\n+            jgen.writeTypeId(typeId);\n+            jgen.writeStartObject();\n+        } else {\n+            jgen.writeStartObject();\n+        }\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n     \n     @Override\n     public As getTypeInclusion() { return As.EXTERNAL_PROPERTY; }\n+\n+    // yes, very important distinction...\n+    @Override\n+    protected boolean _usesExternalId() {\n+        return true;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n {\n     private static final long serialVersionUID = 1L;\n \n+    protected final As _inclusion;\n+\n     public AsPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n             String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl)\n     {\n+        this(bt, idRes, typePropertyName, typeIdVisible, defaultImpl, As.PROPERTY);\n+    }\n+    \n+    public AsPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes,\n+            String typePropertyName, boolean typeIdVisible, Class<?> defaultImpl,\n+            As inclusion)\n+    {\n         super(bt, idRes, typePropertyName, typeIdVisible, defaultImpl);\n+        _inclusion = inclusion;\n     }\n \n     public AsPropertyTypeDeserializer(AsPropertyTypeDeserializer src, BeanProperty property) {\n         super(src, property);\n+        _inclusion = src._inclusion;\n     }\n     \n     @Override\n     }\n     \n     @Override\n-    public As getTypeInclusion() { return As.PROPERTY; }\n+    public As getTypeInclusion() { return _inclusion; }\n \n     /**\n      * This is the trickiest thing to handle, since property we are looking\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n         return this;\n     }\n \n-    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public TypeSerializer buildTypeSerializer(SerializationConfig config,\n             JavaType baseType, Collection<NamedType> subtypes)\n         case EXTERNAL_PROPERTY:\n             return new AsExternalTypeSerializer(idRes, null,\n                     _typeProperty);\n+        case EXISTING_PROPERTY:\n+        \t// as per [#528]\n+        \treturn new AsExistingPropertyTypeSerializer(idRes, null, _typeProperty);\n         }\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n \n-    @SuppressWarnings(\"incomplete-switch\")\n+    // as per [#368]\n+    // removed when fix [#528]\n+    //private IllegalArgumentException _noExisting() {\n+    //    return new IllegalArgumentException(\"Inclusion type \"+_includeAs+\" not yet supported\");\n+    //}\n+\n     @Override\n     public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n             JavaType baseType, Collection<NamedType> subtypes)\n             return new AsArrayTypeDeserializer(baseType, idRes,\n                     _typeProperty, _typeIdVisible, _defaultImpl);\n         case PROPERTY:\n+        case EXISTING_PROPERTY: // as per [#528] same class as PROPERTY\n             return new AsPropertyTypeDeserializer(baseType, idRes,\n-                    _typeProperty, _typeIdVisible, _defaultImpl);\n+                    _typeProperty, _typeIdVisible, _defaultImpl, _includeAs);\n         case WRAPPER_OBJECT:\n             return new AsWrapperTypeDeserializer(baseType, idRes,\n                     _typeProperty, _typeIdVisible, _defaultImpl);\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n public class SimpleKeyDeserializers\n     implements KeyDeserializers, java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = -6786398737835438187L;\n+    private static final long serialVersionUID = 1L;\n \n     protected HashMap<ClassKey,KeyDeserializer> _classMappings = null;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n     @Override\n     public void serialize(JsonGenerator jg, SerializerProvider provider) throws IOException, JsonProcessingException\n     {\n-        jg.writeStartArray();\n-        for (JsonNode n : _children) {\n-            /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n-             *   extend BaseJsonNode? Or if not, at least implement\n-             *   JsonSerializable? Let's start with former, change if\n-             *   we must.\n-             */\n-            ((BaseJsonNode)n).serialize(jg, provider);\n+    \tfinal List<JsonNode> c = _children;\n+    \tfinal int size = c.size();\n+        jg.writeStartArray(size);\n+        for (int i = 0; i < size; ++i) { // we'll typically have array list\n+        \t// Can we trust that all nodes will always extend BaseJsonNode? Or if not,\n+        \t// at least implement JsonSerializable? Let's start with former, change if must\n+            ((BaseJsonNode) c.get(i)).serialize(jg, provider);\n         }\n         jg.writeEndArray();\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n                 throw new JsonMappingException(\"Value returned by 'any-getter' (\"\n                         +_accessor.getName()+\"()) not java.util.Map but \"+value.getClass().getName());\n             }\n-            _serializer.serializeFilteredFields((Map<?,?>) value, jgen, provider, filter);\n+            // 19-Oct-2014, tatu: Should we try to support @JsonInclude options here?\n+            _serializer.serializeFilteredFields((Map<?,?>) value, jgen, provider, filter, null);\n         }\n     \n     // Note: NOT part of ResolvableSerializer...\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.cfg.SerializerFactoryConfig;\n import com.fasterxml.jackson.databind.ser.impl.*;\n import com.fasterxml.jackson.databind.ser.std.*;\n import com.fasterxml.jackson.databind.type.*;\n-import com.fasterxml.jackson.databind.util.ClassUtil;\n-import com.fasterxml.jackson.databind.util.Converter;\n-import com.fasterxml.jackson.databind.util.EnumValues;\n-import com.fasterxml.jackson.databind.util.TokenBuffer;\n+import com.fasterxml.jackson.databind.util.*;\n \n /**\n  * Factory class that can provide serializers for standard JDK classes,\n         if (java.util.Date.class.isAssignableFrom(raw)) {\n             return DateSerializer.instance;\n         }\n+        if (Map.Entry.class.isAssignableFrom(raw)) {\n+            JavaType kt, vt;\n+            JavaType[] params = prov.getTypeFactory().findTypeParameters(type, Map.Entry.class);\n+            if (params == null || params.length != 2) { // assume that if we don't get 2, they are wrong...\n+                kt = vt = TypeFactory.unknownType();\n+            } else {\n+                kt = params[0];\n+                vt = params[1];\n+            }\n+            return buildMapEntrySerializer(prov.getConfig(), type, beanDesc, staticTyping, kt, vt);\n+        }\n         if (ByteBuffer.class.isAssignableFrom(raw)) {\n             return new ByteBufferSerializer();\n         }\n     {\n         Class<?> type = javaType.getRawClass();\n \n-        // These need to be in decreasing order of specificity...\n         if (Iterator.class.isAssignableFrom(type)) {\n-            return buildIteratorSerializer(config, javaType, beanDesc, staticTyping);\n+            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterator.class);\n+            JavaType vt = (params == null || params.length != 1) ?\n+                    TypeFactory.unknownType() : params[0];\n+            return buildIteratorSerializer(config, javaType, beanDesc, staticTyping, vt);\n         }\n         if (Iterable.class.isAssignableFrom(type)) {\n-            return buildIterableSerializer(config, javaType, beanDesc,  staticTyping);\n+            JavaType[] params = config.getTypeFactory().findTypeParameters(javaType, Iterable.class);\n+            JavaType vt = (params == null || params.length != 1) ?\n+                    TypeFactory.unknownType() : params[0];\n+            return buildIterableSerializer(config, javaType, beanDesc,  staticTyping, vt);\n         }\n         if (CharSequence.class.isAssignableFrom(type)) {\n             return ToStringSerializer.instance;\n                     elementTypeSerializer, elementValueSerializer);\n             } else {\n                 Object filterId = findFilterId(config, beanDesc);\n-                ser = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()),\n+                MapSerializer mapSer = MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()),\n                     type, staticTyping, elementTypeSerializer,\n                     keySerializer, elementValueSerializer, filterId);\n+                Object suppressableValue = findSuppressableContentValue(config,\n+                        type.getContentType(), beanDesc);\n+                if (suppressableValue != null) {\n+                    mapSer = mapSer.withContentInclusion(suppressableValue);\n+                }\n+                ser = mapSer;\n             }\n         }\n         // [Issue#120]: Allow post-processing\n         return ser;\n     }\n \n+    /**\n+     * @since 2.5\n+     */\n+    protected Object findSuppressableContentValue(SerializationConfig config,\n+            JavaType contentType, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        JsonInclude.Include incl = beanDesc.findSerializationInclusionForContent(null);\n+\n+        if (incl != null) {\n+            switch (incl) {\n+            case NON_DEFAULT:\n+                // 19-Oct-2014, tatu: Not sure what this'd mean; so take it to mean \"NON_EMPTY\"...\n+                incl = JsonInclude.Include.NON_EMPTY;\n+                break;\n+            default:\n+                // all other modes actually good as is, unless we'll find better ways\n+                break;\n+            }\n+            return incl;\n+        }\n+        return null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Factory methods, for Arrays\n     /**********************************************************\n      */\n \n+    /**\n+     * @since 2.5\n+     */\n     protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,\n-            JavaType type, BeanDescription beanDesc,\n-            boolean staticTyping)\n-        throws JsonMappingException\n-    {\n-        // if there's generic type, it'll be the first contained type\n-        JavaType valueType = type.containedType(0);\n-        if (valueType == null) {\n-            valueType = TypeFactory.unknownType();\n-        }\n-        TypeSerializer vts = createTypeSerializer(config, valueType);\n-        return new IteratorSerializer(valueType, staticTyping, vts, null);\n-    }\n-\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n+            JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        return new IteratorSerializer(valueType, staticTyping, createTypeSerializer(config, valueType), null);\n+    }\n+\n+    @Deprecated // since 2.5\n+    protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping) throws JsonMappingException\n+    {\n+        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterator.class);\n+        JavaType vt = (params == null || params.length != 1) ?\n+                TypeFactory.unknownType() : params[0];\n+        return buildIteratorSerializer(config, type, beanDesc, staticTyping, vt); \n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n+            JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        return new IterableSerializer(valueType, staticTyping, createTypeSerializer(config, valueType), null);\n+    }\n+\n+    @Deprecated // since 2.5\n     protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,\n             JavaType type, BeanDescription beanDesc,\n             boolean staticTyping)\n         throws JsonMappingException\n     {\n-        // if there's generic type, it'll be the first contained type\n-        JavaType valueType = type.containedType(0);\n-        if (valueType == null) {\n-            valueType = TypeFactory.unknownType();\n-        }\n-        TypeSerializer vts = createTypeSerializer(config, valueType);\n-        return new IterableSerializer(valueType, staticTyping, vts, null);\n-    }\n-    \n+        JavaType[] params = config.getTypeFactory().findTypeParameters(type, Iterable.class);\n+        JavaType vt = (params == null || params.length != 1) ?\n+                TypeFactory.unknownType() : params[0];\n+        return buildIterableSerializer(config, type, beanDesc, staticTyping, vt); \n+    }\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    protected JsonSerializer<?> buildMapEntrySerializer(SerializationConfig config,\n+            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n+            JavaType keyType, JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        return new MapEntrySerializer(valueType, keyType, valueType,\n+                staticTyping, createTypeSerializer(config, valueType), null);\n+    }\n+\n     protected JsonSerializer<?> buildEnumSerializer(SerializationConfig config,\n             JavaType type, BeanDescription beanDesc)\n         throws JsonMappingException\n     {\n-        /* As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n+        /* As per [databind#24], may want to use alternate shape, serialize as JSON Object.\n          * Challenge here is that EnumSerializer does not know how to produce\n          * POJO style serialization, so we must handle that special case separately;\n          * otherwise pass it to EnumSerializer.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n import java.lang.reflect.Type;\n import java.util.HashMap;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.SerializableString;\n import com.fasterxml.jackson.core.io.SerializedString;\n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n      */\n-    public final static Object MARKER_FOR_EMPTY = new Object();\n-    \n+    public final static Object MARKER_FOR_EMPTY = JsonInclude.Include.NON_EMPTY;\n+\n     /*\n     /**********************************************************\n     /* Settings for accessing property value to serialize\n     @Override public PropertyName getWrapperName() { return _wrapperName; }\n     @Override public boolean isRequired() { return _metadata.isRequired(); }\n     @Override public PropertyMetadata getMetadata() { return _metadata; }\n-    \n+\n+    // Note: also part of 'PropertyWriter'\n     @Override\n     public <A extends Annotation> A getAnnotation(Class<A> acls) {\n         return _member.getAnnotation(acls);\n     }\n \n+    // Note: also part of 'PropertyWriter'\n     @Override\n     public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n         return _contextAnnotations.get(acls);\n \n     public Class<?>[] getViews() { return _includeInViews; }\n \n-    /**\n-     *<p>\n-     * NOTE: due to introspection, this is a <b>slow</b> method to call\n-     * and should never be called during actual serialization or filtering\n-     * of the property. Rather it is needed for traversal needed for things\n-     * like constructing JSON Schema instances.\n-     * \n-     * @since 2.1\n-     * \n-     * @deprecated since 2.2, use {@link #isRequired()} instead.\n-     */\n-    @Deprecated\n-    protected boolean isRequired(AnnotationIntrospector intr) { return _metadata.isRequired(); }\n-    \n     /*\n     /**********************************************************\n     /* PropertyWriter methods (serialization)\n     }\n \n     /**\n-     * @deprecated Since 2.3 Use overloaded variants\n-     */\n-    @Deprecated\n-    protected void _handleSelfReference(Object bean, JsonSerializer<?> ser)\n-        throws JsonMappingException {\n-        _handleSelfReference(bean, null, null, ser);\n-    }\n-    \n-    /**\n      * Method called to handle a direct self-reference through this property.\n      * Method can choose to indicate an error by throwing {@link JsonMappingException};\n      * fully handle serialization (and return true); or indicate that it should be\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n         /* Can not:\n          * \n          * - have Object Id (may be allowed in future)\n-         * - have any getter\n-         * \n+         * - have \"any getter\"\n+         * - have per-property filters\n          */\n         if ((_objectIdWriter == null)\n                 && (_anyGetterWriter == null)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n                     // Finally: maybe we can still deal with it as an implementation of some basic JDK interface?\n                     if (ser == null) {\n                         ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n+                        // 18-Sep-2014, tatu: Actually, as per [jackson-databind#539], need to get\n+                        //   'unknown' serializer assigned earlier, here, so that it gets properly\n+                        //   post-processed\n+                        if (ser == null) {\n+                            ser = prov.getUnknownTypeSerializer(beanDesc.getBeanClass());\n+                        }\n                     }\n                 }\n             }\n         \n         JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n         \n-        /* However, after all modifications: no properties, no serializer\n-         * (note; as per [JACKSON-670], check was moved later on from an earlier location)\n-         */\n         if (ser == null) {\n-            /* 27-Nov-2009, tatu: Except that as per [JACKSON-201], we are\n-             *   ok with that as long as it has a recognized class annotation\n-             *  (which may come from a mix-in too)\n-             */\n+            // If we get this far, there were no properties found, so no regular BeanSerializer\n+            // would be constructed. But, couple of exceptions.\n+            // First: if there are known annotations, just create 'empty bean' serializer\n             if (beanDesc.hasKnownClassAnnotations()) {\n                 return builder.createDummy();\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/ContainerSerializer.java\n \n     protected ContainerSerializer(Class<T> t) {\n         super(t);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected ContainerSerializer(JavaType fullType) {\n+        super(fullType);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n         findValueSerializer(javaType, null).acceptJsonFormatVisitor(visitor, javaType);\n     }\n \n-    @Deprecated // since 2.3; use the overloaded variant\n-    public boolean hasSerializerFor(Class<?> cls) {\n-        return hasSerializerFor(cls, null);\n-    }\n-    \n     /**\n      * Method that can be called to see if this serializer provider\n      * can find a serializer for an instance of given class.\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n     }\n \n     /**\n-     * @deprecated Since 2.3, use variant that takes {@link SerializerProvider} as\n-     *   first argument -- to be removed from 2.4\n-     */\n-    @Deprecated\n-    protected final BeanPropertyWriter buildWriter(BeanPropertyDefinition propDef,\n-            JavaType declaredType, JsonSerializer<?> ser,\n-            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n-            AnnotatedMember am, boolean defaultUseStaticTyping)\n-    {\n-        /* We will only retain this method until 2.4; left for now to explicitly\n-         * cause compilation/linking issue iff anyone has overridden the method\n-         * (hopefully not)\n-         */\n-        throw new IllegalStateException();\n-    }\n-\n-    /**\n      * @param contentTypeSer Optional explicit type information serializer\n      *    to use for contained values (only used for properties that are\n      *    of container type)\n             }\n             JavaType ct = serializationType.getContentType();\n             /* 03-Sep-2010, tatu: This is somehow related to [JACKSON-356], but I don't completely\n-             *   yet understand how pieces fit together. Still, better be explicit than rely on\n+             *   yet understand how pieces fit together. Still, better to be explicit than rely on\n              *   NPE to indicate an issue...\n              */\n             if (ct == null) {\n                 am, _beanDesc.getClassAnnotations(), declaredType,\n                 ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n \n-        // 14-Oct-2013, tatu: And how about custom null serializer?\n+        // How about custom null serializer?\n         Object serDef = _annotationIntrospector.findNullSerializer(am);\n         if (serDef != null) {\n             bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n         }\n-        \n-        // [JACKSON-132]: Unwrapping\n+        // And then, handling of unwrapping\n         NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n         if (unwrapper != null) {\n             bpw = bpw.unwrappingWriter(unwrapper);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyWriter.java\n package com.fasterxml.jackson.databind.ser;\n \n+import java.lang.annotation.Annotation;\n+\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n     public abstract String getName();\n \n     public abstract PropertyName getFullName();\n+\n+    /**\n+     * Convenience method for accessing annotation that may be associated\n+     * either directly on property, or, if not, via enclosing class (context).\n+     * This allows adding baseline contextual annotations, for example, by adding\n+     * an annotation for a given class and making that apply to all properties\n+     * unless overridden by per-property annotations.\n+     *<p>\n+     * This method is functionally equivalent to:\n+     *<pre>\n+     *  MyAnnotation ann = propWriter.getAnnotation(MyAnnotation.class);\n+     *  if (ann == null) {\n+     *    ann = propWriter.getContextAnnotation(MyAnnotation.class);\n+     *  }\n+     *</pre>\n+     * that is, tries to find a property annotation first, but if one is not\n+     * found, tries to find context-annotation (from enclosing class) of\n+     * same type.\n+     * \n+     * @since 2.5\n+     */\n+    public <A extends Annotation> A findAnnotation(Class<A> acls) {\n+        A ann = getAnnotation(acls);\n+        if (ann == null) {\n+            ann = getContextAnnotation(acls);\n+        }\n+        return ann;\n+    }\n     \n+    /**\n+     * Method for accessing annotations directly declared for property that this\n+     * writer is associated with.\n+     * \n+     * @since 2.5\n+     */\n+    public abstract <A extends Annotation> A getAnnotation(Class<A> acls);\n+\n+    /**\n+     * Method for accessing annotations declared in context of the property that this\n+     * writer is associated with; usually this means annotations on enclosing class\n+     * for property.\n+     * \n+     * @since 2.5\n+     */\n+    public abstract <A extends Annotation> A getContextAnnotation(Class<A> acls);\n+\n     /*\n     /**********************************************************\n     /* Serialization methods, regular output\n     /**\n      * The main serialization method called by filter when property is to be written normally.\n      */\n-    public abstract void serializeAsField(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsField(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /**\n      * filtered, but the underlying data format requires a placeholder of some kind.\n      * This is usually the case for tabular (positional) data formats such as CSV.\n      */\n-    public abstract void serializeAsOmittedField(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsOmittedField(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /*\n      * data format; so it is typically NOT called for fully tabular formats such as CSV,\n      * where logical output is still as form of POJOs.\n      */\n-    public abstract void serializeAsElement(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsElement(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /**\n      * but then value is to be omitted. This requires output of a placeholder value\n      * of some sort; often similar to {@link #serializeAsOmittedField}.\n      */\n-    public abstract void serializeAsPlaceholder(Object pojo, JsonGenerator jgen, SerializerProvider prov)\n+    public abstract void serializeAsPlaceholder(Object value, JsonGenerator jgen, SerializerProvider provider)\n         throws Exception;\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedListSerializer.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n import java.io.IOException;\n-import java.util.LinkedList;\n-import java.util.List;\n+import java.util.*;\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n     public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) {\n         return new IndexedListSerializer(_elementType, _staticTyping, vts, _property, _elementSerializer);\n     }\n+\n+    @Override\n+    public final void serialize(List<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+    \tfinal int len = value.size();\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n     public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider)\n                 }\n             }\n         } catch (Exception e) {\n-            // [JACKSON-55] Need to add reference information\n             wrapAndThrow(provider, e, value, i);\n         }\n     }\n     \n     public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider,\n             JsonSerializer<Object> ser)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         final int len = value.size();\n         if (len == 0) {\n     }\n \n     public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         final int len = value.size();\n         if (len == 0) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n             return;\n         }\n         \n-        jgen.writeStartArray();\n+        jgen.writeStartArray(len);\n         if (_serializer == null) {\n             serializeContents(value, jgen, provider, len);\n         } else {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IteratorSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IteratorSerializer.java\n import java.io.IOException;\n import java.util.Iterator;\n \n-import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n     }\n \n     @Override\n+    public final void serialize(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+        if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray();\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n+    \n+    @Override\n     public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         if (value.hasNext()) {\n             final TypeSerializer typeSer = _valueTypeSerializer;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/MapEntrySerializer.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n+\n+/**\n+ * @since 2.5\n+ */\n+@JacksonStdImpl\n+public class MapEntrySerializer\n+    extends ContainerSerializer<Map.Entry<?,?>>\n+    implements ContextualSerializer\n+{\n+    /**\n+     * Map-valued property being serialized with this instance\n+     */\n+    protected final BeanProperty _property;\n+\n+    /**\n+     * Whether static types should be used for serialization of values\n+     * or not (if not, dynamic runtime type is used)\n+     */\n+    protected final boolean _valueTypeIsStatic;\n+\n+    protected final JavaType _entryType, _keyType, _valueType;\n+\n+    /**\n+     * Key serializer to use, if it can be statically determined\n+     */\n+    protected JsonSerializer<Object> _keySerializer;\n+    \n+    /**\n+     * Value serializer to use, if it can be statically determined\n+     */\n+    protected JsonSerializer<Object> _valueSerializer;\n+\n+    /**\n+     * Type identifier serializer used for values, if any.\n+     */\n+    protected final TypeSerializer _valueTypeSerializer;\n+\n+    /**\n+     * If value type can not be statically determined, mapping from\n+     * runtime value types to serializers are stored in this object.\n+     */\n+    protected PropertySerializerMap _dynamicValueSerializers;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+    \n+    public MapEntrySerializer(JavaType type, JavaType keyType, JavaType valueType,\n+            boolean staticTyping, TypeSerializer vts,\n+            BeanProperty property)\n+    {\n+        super(type);\n+        _entryType = type;\n+        _keyType = keyType;\n+        _valueType = valueType;\n+        _valueTypeIsStatic = staticTyping;\n+        _valueTypeSerializer = vts;\n+        _property = property;\n+        _dynamicValueSerializers = PropertySerializerMap.emptyMap();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected MapEntrySerializer(MapEntrySerializer src, BeanProperty property,\n+            TypeSerializer vts,\n+            JsonSerializer<?> keySer, JsonSerializer<?> valueSer)\n+    {\n+        super(Map.class, false);\n+        _entryType = src._entryType;\n+        _keyType = src._keyType;\n+        _valueType = src._valueType;\n+        _valueTypeIsStatic = src._valueTypeIsStatic;\n+        _valueTypeSerializer = src._valueTypeSerializer;\n+        _keySerializer = (JsonSerializer<Object>) keySer;\n+        _valueSerializer = (JsonSerializer<Object>) valueSer;\n+        _dynamicValueSerializers = src._dynamicValueSerializers;\n+        _property = src._property;\n+    }\n+\n+    @Override\n+    public ContainerSerializer<?> _withValueTypeSerializer(TypeSerializer vts) {\n+        return new MapEntrySerializer(this, _property, vts, _keySerializer, _valueSerializer);\n+    }\n+\n+    public MapEntrySerializer withResolved(BeanProperty property,\n+            JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer) {\n+        return new MapEntrySerializer(this, property, _valueTypeSerializer, keySerializer, valueSerializer);\n+    }\n+\n+    @Override\n+    public JsonSerializer<?> createContextual(SerializerProvider provider,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        JsonSerializer<?> ser = null;\n+        JsonSerializer<?> keySer = null;\n+        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+        final AnnotatedMember propertyAcc = (property == null) ? null : property.getMember();\n+\n+        // First: if we have a property, may have property-annotation overrides\n+        if (propertyAcc != null && intr != null) {\n+            Object serDef = intr.findKeySerializer(propertyAcc);\n+            if (serDef != null) {\n+                keySer = provider.serializerInstance(propertyAcc, serDef);\n+            }\n+            serDef = intr.findContentSerializer(propertyAcc);\n+            if (serDef != null) {\n+                ser = provider.serializerInstance(propertyAcc, serDef);\n+            }\n+        }\n+        if (ser == null) {\n+            ser = _valueSerializer;\n+        }\n+        // [Issue#124]: May have a content converter\n+        ser = findConvertingContentSerializer(provider, property, ser);\n+        if (ser == null) {\n+            // 30-Sep-2012, tatu: One more thing -- if explicit content type is annotated,\n+            //   we can consider it a static case as well.\n+            // 20-Aug-2013, tatu: Need to avoid trying to access serializer for java.lang.Object tho\n+            if ((_valueTypeIsStatic && _valueType.getRawClass() != Object.class)\n+                    || hasContentTypeAnnotation(provider, property)) {\n+                ser = provider.findValueSerializer(_valueType, property);\n+            }\n+        } else {\n+            ser = provider.handleSecondaryContextualization(ser, property);\n+        }\n+        if (keySer == null) {\n+            keySer = _keySerializer;\n+        }\n+        if (keySer == null) {\n+            keySer = provider.findKeySerializer(_keyType, property);\n+        } else {\n+            keySer = provider.handleSecondaryContextualization(keySer, property);\n+        }\n+        MapEntrySerializer mser = withResolved(property, keySer, ser);\n+        // but note: no filtering, ignored entries or sorting (unlike Maps)\n+        return mser;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _valueType;\n+    }\n+\n+    @Override\n+    public JsonSerializer<?> getContentSerializer() {\n+        return _valueSerializer;\n+    }\n+\n+    @Override\n+    public boolean hasSingleElement(Map.Entry<?,?> value) {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean isEmpty(Entry<?, ?> value) {\n+        return (value == null);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void serialize(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException\n+    {\n+        jgen.writeStartObject();\n+        if (_valueSerializer != null) {\n+            serializeUsing(value, jgen, provider, _valueSerializer);\n+        } else {\n+            serializeDynamic(value, jgen, provider);\n+        }\n+        jgen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer) throws IOException\n+    {\n+        typeSer.writeTypePrefixForObject(value, jgen);\n+        if (_valueSerializer != null) {\n+            serializeUsing(value, jgen, provider, _valueSerializer);\n+        } else {\n+            serializeDynamic(value, jgen, provider);\n+        }\n+        typeSer.writeTypeSuffixForObject(value, jgen);\n+    }\n+\n+    protected void serializeDynamic(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException\n+    {\n+        final JsonSerializer<Object> keySerializer = _keySerializer;\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n+        final TypeSerializer vts = _valueTypeSerializer;\n+\n+        PropertySerializerMap serializers = _dynamicValueSerializers;\n+\n+        Object valueElem = value.getValue();\n+        Object keyElem = value.getKey();\n+        if (keyElem == null) {\n+            provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n+        } else {\n+            // [JACKSON-314] skip entries with null values?\n+            if (skipNulls && valueElem == null) return;\n+            keySerializer.serialize(keyElem, jgen, provider);\n+        }\n+        // And then value\n+        if (valueElem == null) {\n+            provider.defaultSerializeNull(jgen);\n+        } else {\n+            Class<?> cc = valueElem.getClass();\n+            JsonSerializer<Object> ser = serializers.serializerFor(cc);\n+            if (ser == null) {\n+                if (_valueType.hasGenericTypes()) {\n+                    ser = _findAndAddDynamic(serializers,\n+                            provider.constructSpecializedType(_valueType, cc), provider);\n+                } else {\n+                    ser = _findAndAddDynamic(serializers, cc, provider);\n+                }\n+                serializers = _dynamicValueSerializers;\n+            }\n+            try {\n+                if (vts == null) {\n+                    ser.serialize(valueElem, jgen, provider);\n+                } else {\n+                    ser.serializeWithType(valueElem, jgen, provider, vts);\n+                }\n+            } catch (Exception e) {\n+                // [JACKSON-55] Need to add reference information\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method called to serialize fields, when the value type is statically known,\n+     * so that value serializer is passed and does not need to be fetched from\n+     * provider.\n+     */\n+    protected void serializeUsing(Map.Entry<?, ?> value, JsonGenerator jgen, SerializerProvider provider,\n+            JsonSerializer<Object> ser)\n+        throws IOException, JsonGenerationException\n+    {\n+        final JsonSerializer<Object> keySerializer = _keySerializer;\n+        final TypeSerializer vts = _valueTypeSerializer;\n+        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n+\n+        Object valueElem = value.getValue();\n+        Object keyElem = value.getKey();\n+        if (keyElem == null) {\n+            provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n+        } else {\n+            // [JACKSON-314] also may need to skip entries with null values\n+            if (skipNulls && valueElem == null) return;\n+            keySerializer.serialize(keyElem, jgen, provider);\n+        }\n+        if (valueElem == null) {\n+            provider.defaultSerializeNull(jgen);\n+        } else {\n+            try {\n+                if (vts == null) {\n+                    ser.serialize(valueElem, jgen, provider);\n+                } else {\n+                    ser.serializeWithType(valueElem, jgen, provider, vts);\n+                }\n+            } catch (Exception e) {\n+                // [JACKSON-55] Need to add reference information\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            Class<?> type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSecondarySerializer(type, provider, _property);\n+        if (map != result.map) {\n+            _dynamicValueSerializers = result.map;\n+        }\n+        return result.serializer;\n+    }\n+\n+    protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            JavaType type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSecondarySerializer(type, provider, _property);\n+        if (map != result.map) {\n+            _dynamicValueSerializers = result.map;\n+        }\n+        return result.serializer;\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n \n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n     /* Actual serialization\n     /**********************************************************\n      */\n+    \n+    @Override\n+    public final void serialize(String[] value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+    \tfinal int len = value.length;\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n     public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n         throws IOException, JsonGenerationException\n     {\n         // [JACKSON-805]\n-        if ((value.size() == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+    \tfinal int len = value.size();\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n             _serializeUnwrapped(value, jgen, provider);\n             return;\n         }      \n-        jgen.writeStartArray();\n+        jgen.writeStartArray(len);\n         if (_serializer == null) {\n             serializeContents(value, jgen, provider);\n         } else {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ArraySerializerBase.java\n         super(src._handledType, false);\n         _property = property;\n     }\n-    \n+\n+    // NOTE: as of 2.5, sub-classes SHOULD override (in 2.4 and before, was final),\n+    // at least if they can provide access to actual size of value and use `writeStartArray()`\n+    // variant that passes size of array to output, which is helpful with some data formats\n     @Override\n-    public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n-        // [JACKSON-805]\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(value)) {\n             serializeContents(value, jgen, provider);\n         serializeContents(value, jgen, provider);\n         jgen.writeEndArray();\n     }\n-    \n+\n     @Override\n     public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n             TypeSerializer typeSer)\n         serializeContents(value, jgen, provider);\n         typeSer.writeTypeSuffixForArray(value, jgen);\n     }\n-\n+    \n     protected abstract void serializeContents(T value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.ParameterizedType;\n import java.lang.reflect.Type;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Base class for serializers that will output contents as JSON\n     /* Serialization\n     /**********************************************************\n      */\n-    \n-    @Override\n-    public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n-        // [JACKSON-805]\n+\n+    // NOTE: as of 2.5, sub-classes SHOULD override (in 2.4 and before, was final),\n+    // at least if they can provide access to actual size of value and use `writeStartArray()`\n+    // variant that passes size of array to output, which is helpful with some data formats\n+    @Override\n+    public void serialize(T value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n         if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)\n                 && hasSingleElement(value)) {\n             serializeContents(value, jgen, provider);\n         jgen.writeEndArray();\n     }\n \n-    // Note: was 'final' modifier in 2.2 and before; no real need to be, removed\n     @Override\n     public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+            TypeSerializer typeSer) throws IOException\n     {\n         // note: let's NOT consider [JACKSON-805] here; gets too complicated, and probably just won't work\n         typeSer.writeTypePrefixForArray(value, jgen);\n     }\n \n     protected abstract void serializeContents(T value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException;\n+        throws IOException;\n \n     @SuppressWarnings(\"deprecation\")\n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n         return null;\n     }\n \n+    @SuppressWarnings(\"incomplete-switch\")\n     @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n     {\n+        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+        final AnnotatedMember accessor = (property == null || intr == null)\n+                ? null : property.getMember();\n+        final SerializationConfig config = provider.getConfig();\n+        \n+        // Let's start with one big transmutation: Enums that are annotated\n+        // to serialize as Objects may want to revert\n+        JsonFormat.Shape shape = null;\n+        if (accessor != null) {\n+            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n+\n+            if (format != null) {\n+                shape = format.getShape();\n+                // or, alternatively, asked to revert \"back to\" other representations...\n+                if (shape != _serializationShape) {\n+                    if (_handledType.isEnum()) {\n+                        switch (shape) {\n+                        case STRING:\n+                        case NUMBER:\n+                        case NUMBER_INT:\n+                            // 12-Oct-2014, tatu: May need to introspect full annotations... but\n+                            //   for now, just do class ones\n+                            BeanDescription desc = config.introspectClassAnnotations(_handledType);\n+                            JsonSerializer<?> ser = EnumSerializer.construct(_handledType,\n+                                    provider.getConfig(), desc, format);\n+                            return provider.handlePrimaryContextualization(ser, property);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         ObjectIdWriter oiw = _objectIdWriter;\n         String[] ignorals = null;\n         Object newFilterId = null;\n-        final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n-        final AnnotatedMember accessor = (property == null || intr == null)\n-                ? null : property.getMember();\n         \n-        // First: may have an override for Object Id:\n+        // Then we may have an override for Object Id\n         if (accessor != null) {\n             ignorals = intr.findPropertiesToIgnore(accessor);\n             ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n         if (newFilterId != null) {\n             contextual = contextual.withFilterId(newFilterId);\n         }\n-        \n-        // One more thing: are we asked to serialize POJO as array?\n-        JsonFormat.Shape shape = null;\n-        if (accessor != null) {\n-            JsonFormat.Value format = intr.findFormat((Annotated) accessor);\n-\n-            if (format != null) {\n-                shape = format.getShape();\n-            }\n-        }\n         if (shape == null) {\n             shape = _serializationShape;\n         }\n         if (shape == JsonFormat.Shape.ARRAY) {\n-            contextual = contextual.asArraySerializer();\n+            return contextual.asArraySerializer();\n         }\n         return contextual;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n         it.next();\n         return !it.hasNext();\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Actual serialization\n     /**********************************************************\n      */\n+\n+    @Override\n+    public final void serialize(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+    \tfinal int len = value.size();\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n-    public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n     {\n         if (_elementSerializer != null) {\n             serializeContentsUsing(value, jgen, provider, _elementSerializer);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n         //todo: (ryan) add a format for the date in the schema?\n         return createSchemaNode(_asTimestamp(provider) ? \"number\" : \"string\", true);\n     }\n-    \n+\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n      * \n      * @since 2.1\n      */\n-    public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config,\n+    @SuppressWarnings(\"unchecked\")\n+    public static EnumSerializer construct(Class<?> enumClass, SerializationConfig config,\n             BeanDescription beanDesc, JsonFormat.Value format)\n     {\n         // [JACKSON-212]: If toString() is to be used instead, leave EnumValues null\n-        EnumValues v = EnumValues.construct(config, enumClass);\n+        EnumValues v = EnumValues.construct(config, (Class<Enum<?>>) enumClass);\n         Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);\n         return new EnumSerializer(v, serializeAsIndex);\n     }\n     \n     @Override\n     public final void serialize(Enum<?> en, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         // [JACKSON-684]: serialize as index?\n         if (_serializeAsIndex(provider)) {\n     \n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-            throws JsonMappingException\n+        throws JsonMappingException\n     {\n         // [JACKSON-684]: serialize as index?\n         if (visitor.getProvider().isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n         if (shape == Shape.STRING) {\n             return Boolean.FALSE;\n         }\n-        if (shape.isNumeric()) {\n+        // 01-Oct-2014, tatu: For convenience, consider \"as-array\" to also mean 'yes, use index')\n+        if (shape.isNumeric() || (shape == Shape.ARRAY)) {\n             return Boolean.TRUE;\n         }\n         throw new IllegalArgumentException(\"Unsupported serialization shape (\"+shape+\") for Enum \"+enumClass.getName()\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.util.EnumSet;\n+import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n     public boolean hasSingleElement(EnumSet<? extends Enum<?>> value) {\n         return value.size() == 1;\n     }\n+\n+    @Override\n+    public final void serialize(EnumSet<? extends Enum<?>> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+    \tfinal int len = value.size();\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n     public void serializeContents(EnumSet<? extends Enum<?>> value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.util.Iterator;\n+import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.BeanProperty;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n import com.fasterxml.jackson.databind.ser.ContainerSerializer;\n         }\n         return false;\n     }\n+\n+    @Override\n+    public final void serialize(Iterable<?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+    {\n+        if (provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED) && hasSingleElement(value)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray();\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n     public void serializeContents(Iterable<?> value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n                  *   to serializer factory at this point... \n                  */\n                 // 05-Sep-2013, tatu: I _think_ this can be considered a primary property...\n-                ser = provider.findPrimaryPropertySerializer(t, _property);\n+                ser = provider.findPrimaryPropertySerializer(t, property);\n                 /* 09-Dec-2010, tatu: Turns out we must add special handling for\n                  *   cases where \"native\" (aka \"natural\") type is being serialized,\n                  *   using standard serializer\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapProperty.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n+import java.lang.annotation.Annotation;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.PropertyName;\n  */\n public class MapProperty extends PropertyWriter\n {\n-    protected TypeSerializer _typeSerializer;\n-    \n-    protected Object _key, _value;\n+    protected final TypeSerializer _typeSerializer;\n+\n+    protected final BeanProperty _property;\n+\n+    protected Object _key;\n \n     protected JsonSerializer<Object> _keySerializer, _valueSerializer;\n \n-    public MapProperty(TypeSerializer typeSer)\n+    /**\n+     * @deprecated since 2.4\n+     */\n+    @Deprecated // since 2.4\n+    public MapProperty(TypeSerializer typeSer) {\n+        this(typeSer, null);\n+    }\n+    \n+    public MapProperty(TypeSerializer typeSer, BeanProperty prop)\n     {\n         _typeSerializer = typeSer;\n+        _property = prop;\n+    }\n+\n+    /**\n+     * Deprecated method with wrong signature; value should not be assigned\n+     * to property, should be passed via proper call-through methods.\n+     * \n+     * @deprecated Since 2.5, remove in 2.6\n+     */\n+    @Deprecated // since 2.5\n+    public void reset(Object key, Object value,\n+            JsonSerializer<Object> keySer, JsonSerializer<Object> valueSer) {\n+        reset(key, keySer, valueSer);\n     }\n     \n     /**\n      * Initialization method that needs to be called before passing\n      * property to filter.\n      */\n-    public void reset(Object key, Object value,\n+    public void reset(Object key,\n             JsonSerializer<Object> keySer, JsonSerializer<Object> valueSer)\n     {\n         _key = key;\n-        _value = value;\n         _keySerializer = keySer;\n         _valueSerializer = valueSer;\n     }\n     }\n \n     @Override\n-    public void serializeAsField(Object pojo, JsonGenerator jgen,\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+        return (_property == null) ? null : _property.getAnnotation(acls);\n+    }\n+\n+    @Override\n+    public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n+        return (_property == null) ? null : _property.getContextAnnotation(acls);\n+    }\n+    \n+    @Override\n+    public void serializeAsField(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws IOException\n     {\n         _keySerializer.serialize(_key, jgen, provider);\n         if (_typeSerializer == null) {\n-            _valueSerializer.serialize(_value, jgen, provider);\n+            _valueSerializer.serialize(value, jgen, provider);\n         } else {\n-            _valueSerializer.serializeWithType(_value, jgen, provider, _typeSerializer);\n+            _valueSerializer.serializeWithType(value, jgen, provider, _typeSerializer);\n         }\n     }\n \n     @Override\n-    public void serializeAsOmittedField(Object pojo, JsonGenerator jgen,\n+    public void serializeAsOmittedField(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws Exception\n     {\n         if (!jgen.canOmitFields()) {\n     }\n \n     @Override\n-    public void serializeAsElement(Object pojo, JsonGenerator jgen,\n+    public void serializeAsElement(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws Exception\n     {\n         if (_typeSerializer == null) {\n-            _valueSerializer.serialize(_value, jgen, provider);\n+            _valueSerializer.serialize(value, jgen, provider);\n         } else {\n-            _valueSerializer.serializeWithType(_value, jgen, provider, _typeSerializer);\n+            _valueSerializer.serializeWithType(value, jgen, provider, _typeSerializer);\n         }\n     }\n     \n     @Override\n-    public void serializeAsPlaceholder(Object pojo, JsonGenerator jgen,\n+    public void serializeAsPlaceholder(Object value, JsonGenerator jgen,\n             SerializerProvider provider) throws Exception\n     {\n         jgen.writeNull();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n import java.lang.reflect.Type;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.ser.PropertyFilter;\n import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.ArrayBuilders;\n \n /**\n  * Standard serializer implementation for serializing {link java.util.Map} types.\n     implements ContextualSerializer\n {\n     protected final static JavaType UNSPECIFIED_TYPE = TypeFactory.unknownType();\n-    \n+\n     /**\n      * Map-valued property being serialized with this instance\n      */\n     protected final BeanProperty _property;\n-    \n+\n     /**\n      * Set of entries to omit during serialization, if any\n      */\n      * @since 2.4\n      */\n     protected final boolean _sortKeys;\n+\n+    /**\n+     * Value that indicates suppression mechanism to use; either one of\n+     * values of {@link JsonInclude.Include}, or actual object to compare\n+     * against (\"default value\")\n+     * \n+     * @since 2.5\n+     */\n+    protected final Object _suppressableValue;\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n     \n+    /**\n+     * @since 2.5\n+     */\n     @SuppressWarnings(\"unchecked\")\n     protected MapSerializer(HashSet<String> ignoredEntries,\n             JavaType keyType, JavaType valueType, boolean valueTypeIsStatic,\n         _property = null;\n         _filterId = null;\n         _sortKeys = false;\n-    }\n-\n+        _suppressableValue = null;\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected void _ensureOverride() {\n+        if (getClass() != MapSerializer.class) {\n+            throw new IllegalStateException(\"Missing override in class \"+getClass().getName());\n+        }\n+    }\n+    \n     @SuppressWarnings(\"unchecked\")\n     protected MapSerializer(MapSerializer src, BeanProperty property,\n             JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer,\n         _property = property;\n         _filterId = src._filterId;\n         _sortKeys = src._sortKeys;\n-    }\n-\n-    protected MapSerializer(MapSerializer src, TypeSerializer vts)\n+        _suppressableValue = src._suppressableValue;\n+    }\n+\n+    @Deprecated // since 2.5\n+    protected MapSerializer(MapSerializer src, TypeSerializer vts) {\n+        this(src, vts, src._suppressableValue);\n+    }\n+\n+    /**\n+     * @since 2.5\n+     */\n+    protected MapSerializer(MapSerializer src, TypeSerializer vts,\n+            Object suppressableValue)\n     {\n         super(Map.class, false);\n         _ignoredEntries = src._ignoredEntries;\n         _property = src._property;\n         _filterId = src._filterId;\n         _sortKeys = src._sortKeys;\n+        _suppressableValue = suppressableValue;\n     }\n \n     protected MapSerializer(MapSerializer src, Object filterId, boolean sortKeys)\n         _property = src._property;\n         _filterId = filterId;\n         _sortKeys = sortKeys;\n-    }\n-    \n+        _suppressableValue = src._suppressableValue;\n+    }\n+\n     @Override\n     public MapSerializer _withValueTypeSerializer(TypeSerializer vts) {\n-        return new MapSerializer(this, vts);\n-    }\n-\n-    @Deprecated // since 2.3\n-    public MapSerializer withResolved(BeanProperty property,\n-            JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer, HashSet<String> ignored) {\n-        return withResolved(property, keySerializer, valueSerializer, ignored, _sortKeys);\n+        if (_valueTypeSerializer == vts) {\n+            return this;\n+        }\n+        _ensureOverride();\n+        return new MapSerializer(this, vts, null);\n     }\n \n     /**\n             JsonSerializer<?> keySerializer, JsonSerializer<?> valueSerializer,\n             HashSet<String> ignored, boolean sortKeys)\n     {\n+        _ensureOverride();\n         MapSerializer ser = new MapSerializer(this, property, keySerializer, valueSerializer, ignored);\n         if (sortKeys != ser._sortKeys) {\n             ser = new MapSerializer(ser, _filterId, sortKeys);\n         }\n         return ser;\n     }\n-    \n+\n     /**\n      * @since 2.3\n      */\n     public MapSerializer withFilterId(Object filterId) {\n-        return (_filterId == filterId) ? this : new MapSerializer(this, filterId, _sortKeys);\n-    }\n-\n-    /**\n-     * @deprecated Since 2.3 use the method that takes `filterId`\n-     */\n-    @Deprecated\n-    public static MapSerializer construct(String[] ignoredList, JavaType mapType,\n-            boolean staticValueType, TypeSerializer vts,\n-            JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer)\n-    {\n-        return construct(ignoredList, mapType, staticValueType, vts,\n-                keySerializer, valueSerializer, null);\n-    }\n-\n+        if (_filterId == filterId) {\n+            return this;\n+        }\n+        _ensureOverride();\n+        return new MapSerializer(this, filterId, _sortKeys);\n+    }\n+\n+    /**\n+     * Mutant factory for constructing an instance with different inclusion strategy\n+     * for content (Map values).\n+     * \n+     * @since 2.5\n+     */\n+    public MapSerializer withContentInclusion(Object suppressableValue) {\n+        if (suppressableValue == _suppressableValue) {\n+            return this;\n+        }\n+        _ensureOverride();\n+        return new MapSerializer(this, _valueTypeSerializer, suppressableValue);\n+    }                \n+    \n     /**\n      * @since 2.3\n      */\n             JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer,\n             Object filterId)\n     {\n-        HashSet<String> ignoredEntries = toSet(ignoredList);\n+        HashSet<String> ignoredEntries = (ignoredList == null || ignoredList.length == 0)\n+                ? null : ArrayBuilders.arrayToSet(ignoredList);\n+\n         JavaType keyType, valueType;\n         \n         if (mapType == null) {\n             ser = ser.withFilterId(filterId);\n         }\n         return ser;\n-    }\n-\n-    private static HashSet<String> toSet(String[] ignoredEntries) {\n-        if (ignoredEntries == null || ignoredEntries.length == 0) {\n-            return null;\n-        }\n-        HashSet<String> result = new HashSet<String>(ignoredEntries.length);\n-        for (String prop : ignoredEntries) {\n-            result.add(prop);\n-        }\n-        return result;\n     }\n \n     /*\n         JsonSerializer<?> keySer = null;\n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n         final AnnotatedMember propertyAcc = (property == null) ? null : property.getMember();\n+        Object suppressableValue = _suppressableValue;\n \n         // First: if we have a property, may have property-annotation overrides\n         if (propertyAcc != null && intr != null) {\n             serDef = intr.findContentSerializer(propertyAcc);\n             if (serDef != null) {\n                 ser = provider.serializerInstance(propertyAcc, serDef);\n+            }\n+            JsonInclude.Include incl = intr.findSerializationInclusionForContent(propertyAcc, null);\n+            if (incl != null) {\n+                suppressableValue = incl;\n             }\n         }\n         if (ser == null) {\n             sortKeys = (b != null) && b.booleanValue();\n         }\n         MapSerializer mser = withResolved(property, keySer, ser, ignored, sortKeys);\n+        if (suppressableValue != _suppressableValue) {\n+            mser = mser.withContentInclusion(suppressableValue);\n+        }\n \n         // [Issue#307]: allow filtering\n         if (property != null) {\n     /* JsonSerializer implementation\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public void serialize(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         jgen.writeStartObject();\n         if (!value.isEmpty()) {\n+            Object suppressableValue = _suppressableValue;\n+            if (suppressableValue == null) {\n+                if (!provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)) {\n+                    suppressableValue = JsonInclude.Include.NON_NULL;\n+                }\n+            } else if (suppressableValue == JsonInclude.Include.ALWAYS) {\n+                suppressableValue = null;\n+            }\n+            if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n+                value = _orderEntries(value);\n+            }\n             if (_filterId != null) {\n                 serializeFilteredFields(value, jgen, provider,\n-                        findPropertyFilter(provider, _filterId, value));\n-                jgen.writeEndObject();\n-                return;\n+                        findPropertyFilter(provider, _filterId, value), suppressableValue);\n+            } else if (suppressableValue != null) {\n+                serializeOptionalFields(value, jgen, provider, suppressableValue);\n+            } else if (_valueSerializer != null) {\n+                serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n+            } else {\n+                serializeFields(value, jgen, provider);\n+            }\n+        }\n+        jgen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException\n+    {\n+        typeSer.writeTypePrefixForObject(value, jgen);\n+        if (!value.isEmpty()) {\n+            Object suppressableValue = _suppressableValue;\n+            if (suppressableValue == null) {\n+                if (!provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES)) {\n+                    suppressableValue = JsonInclude.Include.NON_NULL;\n+                }\n+            } else if (suppressableValue == JsonInclude.Include.ALWAYS) {\n+                suppressableValue = null;\n             }\n             if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n                 value = _orderEntries(value);\n             }\n-            if (_valueSerializer != null) {\n+            if (_filterId != null) {\n+                serializeFilteredFields(value, jgen, provider,\n+                        findPropertyFilter(provider, _filterId, value), suppressableValue);\n+            } else if (suppressableValue != null) {\n+                serializeOptionalFields(value, jgen, provider, suppressableValue);\n+            } else if (_valueSerializer != null) {\n                 serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n             } else {\n                 serializeFields(value, jgen, provider);\n             }\n         }\n-        jgen.writeEndObject();\n-    }\n-\n-    @Override\n-    public void serializeWithType(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n-    {\n-        typeSer.writeTypePrefixForObject(value, jgen);\n-        if (!value.isEmpty()) {\n-            if (_sortKeys || provider.isEnabled(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS)) {\n-                value = _orderEntries(value);\n-            }\n-            if (_valueSerializer != null) {\n-                serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n-            } else {\n-                serializeFields(value, jgen, provider);\n-            }\n-        }\n         typeSer.writeTypeSuffixForObject(value, jgen);\n     }\n \n      */\n     \n     /**\n-     * Method called to serialize fields, when the value type is not statically known.\n+     * Method called to serialize fields, when the value type is not statically known;\n+     * but we know that no value suppression is needed (which simplifies processing a bit)\n      */\n     public void serializeFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         // If value type needs polymorphic type handling, some more work needed:\n         if (_valueTypeSerializer != null) {\n-            serializeTypedFields(value, jgen, provider);\n+            serializeTypedFields(value, jgen, provider, null);\n             return;\n         }\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n-        \n         final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         PropertySerializerMap serializers = _dynamicValueSerializers;\n \n             if (keyElem == null) {\n                 provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n             } else {\n-                // [JACKSON-314] skip entries with null values?\n-                if (skipNulls && valueElem == null) continue;\n                 // One twist: is entry ignorable? If so, skip\n                 if (ignored != null && ignored.contains(keyElem)) continue;\n                 keySerializer.serialize(keyElem, jgen, provider);\n                 try {\n                     serializer.serialize(valueElem, jgen, provider);\n                 } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n+                    // Add reference information\n                     String keyDesc = \"\"+keyElem;\n                     wrapAndThrow(provider, e, value, keyDesc);\n                 }\n         }\n     }\n \n+    public void serializeOptionalFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+            Object suppressableValue)\n+        throws IOException\n+    {\n+        // If value type needs polymorphic type handling, some more work needed:\n+        if (_valueTypeSerializer != null) {\n+            serializeTypedFields(value, jgen, provider, suppressableValue);\n+            return;\n+        }\n+        final HashSet<String> ignored = _ignoredEntries;\n+        PropertySerializerMap serializers = _dynamicValueSerializers;\n+\n+        for (Map.Entry<?,?> entry : value.entrySet()) {\n+            // First find key serializer\n+            final Object keyElem = entry.getKey();\n+            JsonSerializer<Object> keySerializer;\n+            if (keyElem == null) {\n+                keySerializer = provider.findNullKeySerializer(_keyType, _property);\n+            } else {\n+                if (ignored != null && ignored.contains(keyElem)) continue;\n+                keySerializer = _keySerializer;\n+            }\n+\n+            // Then value serializer\n+            final Object valueElem = entry.getValue();\n+            JsonSerializer<Object> valueSer;\n+            if (valueElem == null) {\n+                if (suppressableValue != null) { // all suppressions include null-suppression\n+                    continue;\n+                }\n+                valueSer = provider.getDefaultNullValueSerializer();\n+            } else {\n+                valueSer = _valueSerializer;\n+                if (valueSer == null) {\n+                    Class<?> cc = valueElem.getClass();\n+                    valueSer = serializers.serializerFor(cc);\n+                    if (valueSer == null) {\n+                        if (_valueType.hasGenericTypes()) {\n+                            valueSer = _findAndAddDynamic(serializers,\n+                                    provider.constructSpecializedType(_valueType, cc), provider);\n+                        } else {\n+                            valueSer = _findAndAddDynamic(serializers, cc, provider);\n+                        }\n+                        serializers = _dynamicValueSerializers;\n+                    }\n+                }\n+                // also may need to skip non-empty values:\n+                if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n+                        && valueSer.isEmpty(valueElem)) {\n+                    continue;\n+                }\n+            }\n+            // and then serialize, if all went well\n+            try {\n+                keySerializer.serialize(keyElem, jgen, provider);\n+                valueSer.serialize(valueElem, jgen, provider);\n+            } catch (Exception e) {\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+    \n     /**\n      * Method called to serialize fields, when the value type is statically known,\n      * so that value serializer is passed and does not need to be fetched from\n      */\n     protected void serializeFieldsUsing(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n             JsonSerializer<Object> ser)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         final JsonSerializer<Object> keySerializer = _keySerializer;\n         final HashSet<String> ignored = _ignoredEntries;\n         final TypeSerializer typeSer = _valueTypeSerializer;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n-            Object valueElem = entry.getValue();\n             Object keyElem = entry.getKey();\n+            if (ignored != null && ignored.contains(keyElem)) continue;\n+\n             if (keyElem == null) {\n                 provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n             } else {\n-                // [JACKSON-314] also may need to skip entries with null values\n-                if (skipNulls && valueElem == null) continue;\n-                if (ignored != null && ignored.contains(keyElem)) continue;\n                 keySerializer.serialize(keyElem, jgen, provider);\n             }\n+            final Object valueElem = entry.getValue();\n             if (valueElem == null) {\n                 provider.defaultSerializeNull(jgen);\n             } else {\n                         ser.serializeWithType(valueElem, jgen, provider, typeSer);\n                     }\n                 } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n                     String keyDesc = \"\"+keyElem;\n                     wrapAndThrow(provider, e, value, keyDesc);\n                 }\n     /**\n      * Helper method used when we have a JSON Filter to use for potentially\n      * filtering out Map entries.\n-     *<p>\n-     * NOTE: initially only called externally, by <code>AnyGetterWriter</code>\n      * \n-     * @since 2.3\n+     * @since 2.5\n      */\n     public void serializeFilteredFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n-            PropertyFilter filter)\n-        throws IOException, JsonGenerationException\n+            PropertyFilter filter,\n+            Object suppressableValue) // since 2.5\n+        throws IOException\n     {\n         final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n \n         PropertySerializerMap serializers = _dynamicValueSerializers;\n-        final MapProperty prop = new MapProperty(_valueTypeSerializer);\n+        final MapProperty prop = new MapProperty(_valueTypeSerializer, _property);\n \n         for (Map.Entry<?,?> entry : value.entrySet()) {\n-            // First, serialize key\n+            // First, serialize key; unless ignorable by key\n             final Object keyElem = entry.getKey();\n+            if (ignored != null && ignored.contains(keyElem)) continue;\n+\n+            JsonSerializer<Object> keySerializer;\n+            if (keyElem == null) {\n+                keySerializer = provider.findNullKeySerializer(_keyType, _property);\n+            } else {\n+                keySerializer = _keySerializer;\n+            }\n+            // or by value; nulls often suppressed\n             final Object valueElem = entry.getValue();\n-            JsonSerializer<Object> keySer;\n-            if (keyElem == null) {\n-                keySer = provider.findNullKeySerializer(_keyType, _property);\n-            } else {\n-                // [JACKSON-314] skip entries with null values?\n-                if (skipNulls && valueElem == null) continue;\n-                // One twist: is entry ignorable? If so, skip\n-                if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySer = _keySerializer;\n-            }\n+\n             JsonSerializer<Object> valueSer;\n             // And then value\n             if (valueElem == null) {\n+                if (suppressableValue != null) { // all suppressions include null-suppression\n+                    continue;\n+                }\n                 valueSer = provider.getDefaultNullValueSerializer();\n             } else {\n+                valueSer = _valueSerializer;\n+                if (valueSer == null) {\n+                    Class<?> cc = valueElem.getClass();\n+                    valueSer = serializers.serializerFor(cc);\n+                    if (valueSer == null) {\n+                        if (_valueType.hasGenericTypes()) {\n+                            valueSer = _findAndAddDynamic(serializers,\n+                                    provider.constructSpecializedType(_valueType, cc), provider);\n+                        } else {\n+                            valueSer = _findAndAddDynamic(serializers, cc, provider);\n+                        }\n+                        serializers = _dynamicValueSerializers;\n+                    }\n+                }\n+                // also may need to skip non-empty values:\n+                if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n+                        && valueSer.isEmpty(valueElem)) {\n+                    continue;\n+                }\n+            }\n+            // and with that, ask filter to handle it\n+            prop.reset(keyElem, keySerializer, valueSer);\n+            try {\n+                filter.serializeAsField(valueElem, jgen, provider, prop);\n+            } catch (Exception e) {\n+                String keyDesc = \"\"+keyElem;\n+                wrapAndThrow(provider, e, value, keyDesc);\n+            }\n+        }\n+    }\n+\n+    @Deprecated // since 2.5\n+    public void serializeFilteredFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n+            PropertyFilter filter) throws IOException {\n+        serializeFilteredFields(value, gen, provider, filter,\n+                provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES) ? null : JsonInclude.Include.NON_NULL);\n+    }\n+    \n+    /**\n+     * @since 2.5\n+     */\n+    protected void serializeTypedFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider,\n+            Object suppressableValue) // since 2.5\n+        throws IOException\n+    {\n+        final HashSet<String> ignored = _ignoredEntries;\n+        PropertySerializerMap serializers = _dynamicValueSerializers;\n+\n+        for (Map.Entry<?,?> entry : value.entrySet()) {\n+            Object keyElem = entry.getKey();\n+            JsonSerializer<Object> keySerializer;\n+            if (keyElem == null) {\n+                keySerializer = provider.findNullKeySerializer(_keyType, _property);\n+            } else {\n+                // One twist: is entry ignorable? If so, skip\n+                if (ignored != null && ignored.contains(keyElem)) continue;\n+                keySerializer = _keySerializer;\n+            }\n+            final Object valueElem = entry.getValue();\n+    \n+            // And then value\n+            JsonSerializer<Object> valueSer;\n+            if (valueElem == null) {\n+                if (suppressableValue != null) { // all suppression include null suppression\n+                    continue;\n+                }\n+                valueSer = provider.getDefaultNullValueSerializer();\n+                keySerializer.serialize(keyElem, gen, provider);\n+                provider.defaultSerializeNull(gen);\n+            } else {\n+                valueSer = _valueSerializer;\n                 Class<?> cc = valueElem.getClass();\n                 valueSer = serializers.serializerFor(cc);\n                 if (valueSer == null) {\n                     }\n                     serializers = _dynamicValueSerializers;\n                 }\n-            }\n-            prop.reset(keyElem, valueElem, keySer, valueSer);\n+                // also may need to skip non-empty values:\n+                if ((suppressableValue == JsonInclude.Include.NON_EMPTY)\n+                        && valueSer.isEmpty(valueElem)) {\n+                    continue;\n+                }\n+            }\n+            keySerializer.serialize(keyElem, gen, provider);\n             try {\n-                filter.serializeAsField(value, jgen, provider, prop);\n+                valueSer.serializeWithType(valueElem, gen, provider, _valueTypeSerializer);\n             } catch (Exception e) {\n-                // [JACKSON-55] Need to add reference information\n                 String keyDesc = \"\"+keyElem;\n                 wrapAndThrow(provider, e, value, keyDesc);\n             }\n         }\n     }\n-    \n-    protected void serializeTypedFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n-        final JsonSerializer<Object> keySerializer = _keySerializer;\n-        JsonSerializer<Object> prevValueSerializer = null;\n-        Class<?> prevValueClass = null;\n-        final HashSet<String> ignored = _ignoredEntries;\n-        final boolean skipNulls = !provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES);\n-    \n-        for (Map.Entry<?,?> entry : value.entrySet()) {\n-            Object valueElem = entry.getValue();\n-            // First, serialize key\n-            Object keyElem = entry.getKey();\n-            if (keyElem == null) {\n-                provider.findNullKeySerializer(_keyType, _property).serialize(null, jgen, provider);\n-            } else {\n-                // [JACKSON-314] also may need to skip entries with null values\n-                if (skipNulls && valueElem == null) continue;\n-                // One twist: is entry ignorable? If so, skip\n-                if (ignored != null && ignored.contains(keyElem)) continue;\n-                keySerializer.serialize(keyElem, jgen, provider);\n-            }\n-    \n-            // And then value\n-            if (valueElem == null) {\n-                provider.defaultSerializeNull(jgen);\n-            } else {\n-                Class<?> cc = valueElem.getClass();\n-                JsonSerializer<Object> currSerializer;\n-                if (cc == prevValueClass) {\n-                    currSerializer = prevValueSerializer;\n-                } else {\n-                    if (_valueType.hasGenericTypes()) {\n-                        currSerializer = provider.findValueSerializer(provider.constructSpecializedType(_valueType, cc), _property);\n-                    } else {\n-                        currSerializer = provider.findValueSerializer(cc, _property);\n-                    }\n-                    prevValueSerializer = currSerializer;\n-                    prevValueClass = cc;\n-                }\n-                try {\n-                    currSerializer.serializeWithType(valueElem, jgen, provider, _valueTypeSerializer);\n-                } catch (Exception e) {\n-                    // [JACKSON-55] Need to add reference information\n-                    String keyDesc = \"\"+keyElem;\n-                    wrapAndThrow(provider, e, value, keyDesc);\n-                }\n-            }\n-        }\n-    }\n+\n+    @Deprecated // since 2.5\n+    protected void serializeTypedFields(Map<?,?> value, JsonGenerator gen, SerializerProvider provider)\n+        throws IOException {\n+        serializeTypedFields(value, gen, provider,\n+                provider.isEnabled(SerializationFeature.WRITE_NULL_MAP_VALUES) ? null : JsonInclude.Include.NON_NULL);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Schema related functionality\n+    /**********************************************************\n+     */\n     \n     @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         // there's no way to statically determine the keys, so the \"Entries\" can't be determined.\n         return o;\n     }\n-    \n+\n     @Override\n     public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n     /* Actual serialization\n     /**********************************************************\n      */\n+\n+    @Override\n+    public final void serialize(Object[] value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+    \tfinal int len = value.length;\n+        if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+            serializeContents(value, jgen, provider);\n+            return;\n+        }\n+        jgen.writeStartArray(len);\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n     \n     @Override\n     public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n import java.util.HashMap;\n \n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonArrayFormatVisitor;\n         public boolean hasSingleElement(boolean[] value) {\n             return (value.length == 1);\n         }\n+\n+        @Override\n+        public final void serialize(boolean[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n         \n         @Override\n         public void serializeContents(boolean[] value, JsonGenerator jgen, SerializerProvider provider)\n         public boolean hasSingleElement(short[] value) {\n             return (value.length == 1);\n         }\n+\n+        @Override\n+        public final void serialize(short[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n         \n         @SuppressWarnings(\"cast\")\n         @Override\n         {\n             // [JACKSON-289] allows serializing as 'sparse' char array too:\n             if (provider.isEnabled(SerializationFeature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {\n-                jgen.writeStartArray();\n+                jgen.writeStartArray(value.length);\n                 _writeArrayContents(jgen, value);\n                 jgen.writeEndArray();\n             } else {\n         }\n \n         @Override\n+        public final void serialize(int[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n+\n+        @Override\n         public void serializeContents(int[] value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n+            throws IOException\n         {\n             for (int i = 0, len = value.length; i < len; ++i) {\n                 jgen.writeNumber(value[i]);\n         public boolean hasSingleElement(long[] value) {\n             return (value.length == 1);\n         }\n+\n+        @Override\n+        public final void serialize(long[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n         \n         @Override\n         public void serializeContents(long[] value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n+            throws IOException\n         {\n             if (_valueTypeSerializer != null) {\n                 for (int i = 0, len = value.length; i < len; ++i) {\n         public boolean hasSingleElement(float[] value) {\n             return (value.length == 1);\n         }\n+\n+        @Override\n+        public final void serialize(float[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n         \n         @Override\n         public void serializeContents(float[] value, JsonGenerator jgen, SerializerProvider provider)\n         public boolean hasSingleElement(double[] value) {\n             return (value.length == 1);\n         }\n-        \n-        @Override\n-        public void serializeContents(double[] value, JsonGenerator jgen, SerializerProvider provider)\n-            throws IOException, JsonGenerationException\n+\n+        @Override\n+        public final void serialize(double[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+        \tfinal int len = value.length;\n+            if ((len == 1) && provider.isEnabled(SerializationFeature.WRITE_SINGLE_ELEM_ARRAYS_UNWRAPPED)) {\n+                serializeContents(value, jgen, provider);\n+                return;\n+            }\n+            jgen.writeStartArray(len);\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n+        \n+        @Override\n+        public void serializeContents(double[] value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n         {\n             for (int i = 0, len = value.length; i < len; ++i) {\n                 jgen.writeNumber(value[i]);\n         \n         @Override\n         public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-                throws JsonMappingException\n+            throws JsonMappingException\n         {\n             if (visitor != null) {\n                 JsonArrayFormatVisitor v2 = visitor.expectArrayFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n     public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)\n         throws JsonMappingException\n     {\n-        // First: if already got serializer to delegate to, contextualize it:\n-        if (_delegateSerializer != null) {\n-            if (_delegateSerializer instanceof ContextualSerializer) {\n-                JsonSerializer<?> ser = provider.handleSecondaryContextualization(_delegateSerializer, property);\n-                if (ser == _delegateSerializer) {\n-                    return this;\n-                }\n-                return withDelegate(_converter, _delegateType, ser);\n+        JsonSerializer<?> delSer = _delegateSerializer;\n+        JavaType delegateType = _delegateType;\n+\n+        if (delSer == null) {\n+            // Otherwise, need to locate serializer to delegate to. For that we need type information...\n+            if (delegateType == null) {\n+                delegateType = _converter.getOutputType(provider.getTypeFactory());\n             }\n-            return this;\n-        }\n-        // Otherwise, need to locate serializer to delegate to. For that we need type information...\n-        JavaType delegateType = _delegateType;\n-        if (delegateType == null) {\n-            delegateType = _converter.getOutputType(provider.getTypeFactory());\n-        }\n-        // and then find the thing...\n-        return withDelegate(_converter, delegateType,\n-                provider.findValueSerializer(delegateType, property));\n+            delSer = provider.findValueSerializer(delegateType);\n+        }\n+        if (delSer instanceof ContextualSerializer) {\n+            delSer = provider.handleSecondaryContextualization(delSer, property);\n+        }\n+        return (delSer == _delegateSerializer) ? this\n+                : withDelegate(_converter, delegateType, delSer);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n             BeanProperty prop, JsonSerializer<?> existingSerializer)\n         throws JsonMappingException\n     {\n+        /* 19-Oct-2014, tatu: As per [databind#357], need to avoid infinite loop\n+         *   when applying contextual content converter; this is not ideal way,\n+         *   but should work for most cases.\n+         */\n+\n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n         if (intr != null && prop != null) {\n             Object convDef = intr.findSerializationContentConverter(prop.getMember());\n                 Converter<Object,Object> conv = provider.converterInstance(prop.getMember(), convDef);\n                 JavaType delegateType = conv.getOutputType(provider.getTypeFactory());\n                 if (existingSerializer == null) {\n-                    existingSerializer = provider.findValueSerializer(delegateType, prop);\n+                    existingSerializer = provider.findValueSerializer(delegateType);\n                 }\n                 return new StdDelegatingSerializer(conv, delegateType, existingSerializer);\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n      */\n     public ToStringSerializer() { super(Object.class); }\n \n+    /**\n+     * Sometimes it may actually make sense to retain actual handled type, so...\n+     * \n+     * @since 2.5\n+     */\n+    public ToStringSerializer(Class<?> handledType) {\n+        super(handledType, false);\n+    }\n+    \n     @Override\n     public boolean isEmpty(Object value) {\n         if (value == null) {\n             return true;\n         }\n         String str = value.toString();\n-        // would use String.isEmpty(), but that's JDK 1.6\n-        return (str == null) || (str.length() == 0);\n+        return str.isEmpty();\n     }\n     \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         jgen.writeString(value.toString());\n     }\n     @Override\n     public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider,\n             TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         typeSer.writeTypePrefixForScalar(value, jgen);\n         serialize(value, jgen, provider);\n     }\n     \n     @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n-    {\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n         return createSchemaNode(\"string\", true);\n     }\n     \n     @Override\n-    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n-            throws JsonMappingException\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n     {\n         if (visitor != null) {\n             visitor.expectStringFormat(typeHint);\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n         if (index == 0) return \"E\";\n         return null;\n     }\n+\n+    /**\n+     * No parameterization for array types themselves; element type\n+     * may obviously have parameterization.\n+     */\n+    @Override\n+    public Class<?> getParameterSource() {\n+        return null;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n         return null;\n     }\n \n+    // TODO: should allow construction of instances that do refer\n+    //  to parameterization, since it is NOT Collection\n+    @Override\n+    public Class<?> getParameterSource() {\n+        return null;\n+    }\n+    \n     @Override\n     public StringBuilder getErasedSignature(StringBuilder sb) {\n         return _classSignature(_class, sb, true);\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\n         return new CollectionType(_class, _elementType.withStaticTyping(),\n                 _valueHandler, _typeHandler, true);\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden accessors\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public Class<?> getParameterSource() {\n+        return java.util.Collection.class;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n         return null;\n     }\n \n+    // TODO: should allow construction of instances that do refer\n+    //  to parameterization, since it is NOT Map\n+    @Override\n+    public Class<?> getParameterSource() {\n+        return null;\n+    }\n+    \n     @Override\n     public StringBuilder getErasedSignature(StringBuilder sb) {\n         return _classSignature(_class, sb, true);\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n \n     /*\n     /**********************************************************\n+    /* Overridden accessors\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public Class<?> getParameterSource() {\n+        return java.util.Map.class;\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Extended API\n     /**********************************************************\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n     private static final long serialVersionUID = -800374828948534376L;\n \n     /**\n+     * In case there are resolved type parameters, this field stores reference\n+     * to that type. It must be {@link #getRawClass()} or its supertype.\n+     * \n+     * @since 2.5\n+     */\n+    protected final Class<?> _typeParametersFor;\n+    \n+    /**\n      * Generic type arguments for this type.\n      */\n     protected final JavaType[] _typeParameters;\n      */\n \n     protected SimpleType(Class<?> cls) {\n-        this(cls, null, null, null, null, false);\n-    }\n-\n+        this(cls, null, null, null, null, false, null);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5 use variant that takes one more argument\n+     */\n+    @Deprecated\n     protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams,\n             Object valueHandler, Object typeHandler, boolean asStatic)\n+    {\n+        this(cls, typeNames, typeParams, valueHandler, typeHandler, asStatic, null);\n+    }\n+\n+    /**\n+     * \n+     * @param parametersFrom Interface or abstract class implemented by this type,\n+     *   and for which type parameters apply. It may be <code>cls</code> itself,\n+     *   but more commonly it is one of its supertypes.\n+     */\n+    protected SimpleType(Class<?> cls,\n+            String[] typeNames, JavaType[] typeParams,\n+            Object valueHandler, Object typeHandler, boolean asStatic,\n+            Class<?> parametersFrom)\n     {\n         super(cls, 0, valueHandler, typeHandler, asStatic);\n         if (typeNames == null || typeNames.length == 0) {\n             _typeNames = typeNames;\n             _typeParameters = typeParams;\n         }\n+        _typeParametersFor = parametersFrom;\n     }\n \n     /**\n      * not in same package\n      */\n     public static SimpleType constructUnsafe(Class<?> raw) {\n-        return new SimpleType(raw, null, null, null, null, false);\n+        return new SimpleType(raw, null, null, null, null, false, null);\n     }\n \n     @Override\n     {\n         // Should we check that there is a sub-class relationship?\n         return new SimpleType(subclass, _typeNames, _typeParameters, _valueHandler, _typeHandler,\n-                _asStatic);\n+                _asStatic, _typeParametersFor);\n     }\n \n     @Override\n     @Override\n     public SimpleType withTypeHandler(Object h)\n     {\n-        return new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, h, _asStatic);\n+        return new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, h, _asStatic, _typeParametersFor);\n     }\n \n     @Override\n         if (h == _valueHandler) {\n             return this;\n         }\n-        return new SimpleType(_class, _typeNames, _typeParameters, h, _typeHandler, _asStatic);\n+        return new SimpleType(_class, _typeNames, _typeParameters, h, _typeHandler, _asStatic, _typeParametersFor);\n     }\n     \n     @Override\n     @Override\n     public SimpleType withStaticTyping() {\n         return _asStatic ? this : new SimpleType(_class,\n-                _typeNames, _typeParameters, _valueHandler, _typeHandler, _asStatic);\n+                _typeNames, _typeParameters, _valueHandler, _typeHandler, _asStatic, _typeParametersFor);\n     }\n \n     @Override\n         }\n         return _typeNames[index];\n     }\n+\n+    @Override\n+    public Class<?> getParameterSource() {\n+        return _typeParametersFor;\n+    }\n     \n     @Override\n     public StringBuilder getErasedSignature(StringBuilder sb) {\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n          * case actually fully works; and former mostly works. In future may need to\n          * rewrite former part, which requires changes to JavaType as well.\n          */\n-        Class<?> raw = type.getRawClass();\n-        if (raw == expType) {\n+        if (expType == type.getParameterSource()) {\n             // Direct type info; good since we can return it as is\n             int count = type.containedTypeCount();\n             if (count == 0) return null;\n          * if/when there are problems; current handling is an improvement over earlier\n          * code.\n          */\n+        Class<?> raw = type.getRawClass();\n         return findTypeParameters(raw, expType, new TypeBindings(this, type));\n     }\n \n     public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n         return findTypeParameters(clz, expType, new TypeBindings(this, clz));\n     }\n-    \n+\n     public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)\n     {\n         // First: find full inheritance chain\n \n         // simple class?\n         if (type instanceof Class<?>) {\n-            Class<?> cls = (Class<?>) type;\n-            resultType = _fromClass(cls, context);\n+            resultType = _fromClass((Class<?>) type, context);\n         }\n         // But if not, need to start resolving.\n         else if (type instanceof ParameterizedType) {\n     \n     /**\n      * Method for constructing a type instance with specified parameterization.\n-     */\n-    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes)\n+     * \n+     * @deprecated Since 2.5, use variant that takes one more argument\n+     */\n+    @Deprecated\n+    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes) {\n+        return constructSimpleType(rawType, rawType, parameterTypes);\n+    }\n+    \n+    public JavaType constructSimpleType(Class<?> rawType, Class<?> parameterTarget,\n+            JavaType[] parameterTypes)\n     {\n         // Quick sanity check: must match numbers of types with expected...\n-        TypeVariable<?>[] typeVars = rawType.getTypeParameters();\n+        TypeVariable<?>[] typeVars = parameterTarget.getTypeParameters();\n         if (typeVars.length != parameterTypes.length) {\n             throw new IllegalArgumentException(\"Parameter type mismatch for \"+rawType.getName()\n-                    +\": expected \"+typeVars.length+\" parameters, was given \"+parameterTypes.length);\n+                    +\" (and target \"+parameterTarget.getName()+\"): expected \"+typeVars.length\n+                    +\" parameters, was given \"+parameterTypes.length);\n         }\n         String[] names = new String[typeVars.length];\n         for (int i = 0, len = typeVars.length; i < len; ++i) {\n             names[i] = typeVars[i].getName();\n         }\n-        JavaType resultType = new SimpleType(rawType, names, parameterTypes, null, null, false);\n-        return resultType;\n+        return new SimpleType(rawType, names, parameterTypes, null, null, false, parameterTarget);\n     } \n \n     /**\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     */\n-    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses)\n+     * \n+     * @param parametrized Type-erased type of instance being constructed\n+     * @param parametersFor class or interface for which type parameters are applied; either\n+     *   <code>parametrized</code> or one of its supertypes\n+     * @parameterClasses Type parameters to apply\n+     * \n+     * @since 2.5\n+     */\n+    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n+            Class<?>... parameterClasses)\n     {\n         int len = parameterClasses.length;\n         JavaType[] pt = new JavaType[len];\n         for (int i = 0; i < len; ++i) {\n             pt[i] = _fromClass(parameterClasses[i], null);\n         }\n-        return constructParametricType(parametrized, pt);\n+        return constructParametrizedType(parametrized, parametersFor, pt);\n+    }\n+\n+    /**\n+     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n+     */\n+    @Deprecated\n+    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n+        return constructParametrizedType(parametrized, parametrized, parameterClasses);\n     }\n \n     /**\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     */\n-    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes)\n+     * \n+     * \n+     * @param parametrized Actual full type\n+     * @param parametersFor class or interface for which type parameters are applied; either\n+     *   <code>parametrized</code> or one of its supertypes\n+     * @parameterClasses Type parameters to apply\n+     * \n+     * @since 2.5\n+     */\n+    public JavaType constructParametrizedType(Class<?> parametrized, Class<?> parametersFor,\n+            JavaType... parameterTypes)\n     {\n         JavaType resultType;\n         \n             }\n             resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);\n         } else {\n-            resultType = constructSimpleType(parametrized, parameterTypes);\n+            resultType = constructSimpleType(parametrized, parametersFor, parameterTypes);\n         }\n         return resultType;\n     }\n \n+    /**\n+     * @deprecated Since 2.5, use {@link #constructParametrizedType} instead.\n+     */\n+    @Deprecated\n+    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes) {\n+        return constructParametrizedType(parametrized, parametrized, parameterTypes);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Direct factory methods for \"raw\" variants, used when\n         } else if (Collection.class.isAssignableFrom(clz)) {\n             result =  _collectionType(clz);\n         } else {\n-            result = new SimpleType(clz);\n+            // 29-Sep-2014, tatu: We may want to pre-resolve well-known generic types\n+            if (Map.Entry.class.isAssignableFrom(clz)) {\n+                JavaType[] pts = this.findTypeParameters(clz, Map.Entry.class);\n+                JavaType kt, vt;\n+                if (pts == null || pts.length != 2) {\n+                    kt = vt = unknownType();\n+                } else {\n+                    kt = pts[0];\n+                    vt = pts[1];\n+                }\n+                result = constructSimpleType(clz, Map.Entry.class, new JavaType[] { kt, vt });\n+            } else {\n+                result = new SimpleType(clz);\n+            }\n         }\n         _typeCache.put(key, result); // cache object syncs\n         return result;\n         if (paramTypes.size() == 0) {\n             return new SimpleType(clz);\n         }\n+        // Hmmh. Does this actually occur?\n         JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);\n-        return constructSimpleType(clz, pt);\n+        return constructSimpleType(clz, clz, pt);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n import java.text.ParseException;\n \n /**\n- * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than\n- * using SimpleDateFormat so highly suitable if you (un)serialize lots of date objects.\n+ * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than using SimpleDateFormat so\n+ * highly suitable if you (un)serialize lots of date objects.\n+ * \n+ * Supported parse format: [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n+ * \n+ * @see <a href=\"http://www.w3.org/TR/NOTE-datetime\">this specification</a>\n  */\n-public class ISO8601Utils {\n-\n+public class ISO8601Utils\n+{\n     /**\n      * ID to represent the 'GMT' string\n      */\n     /* Static factories\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Accessor for static GMT timezone instance.\n      */\n-    public static TimeZone timeZoneGMT() { return TIMEZONE_GMT; }\n+    public static TimeZone timeZoneGMT() {\n+        return TIMEZONE_GMT;\n+    }\n \n     /*\n     /**********************************************************\n     /* Formatting\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (GMT timezone, no milliseconds precision)\n-     *\n+     * \n      * @param date the date to format\n      * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\n      */\n \n     /**\n      * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)\n-     *\n-     * @param date   the date to format\n+     * \n+     * @param date the date to format\n      * @param millis true to include millis precision otherwise false\n      * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'\n      */\n \n     /**\n      * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n-     *\n-     * @param date   the date to format\n+     * \n+     * @param date the date to format\n      * @param millis true to include millis precision otherwise false\n-     * @param tz     timezone to use for the formatting (GMT will produce 'Z')\n+     * @param tz timezone to use for the formatting (GMT will produce 'Z')\n      * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n      */\n     public static String format(Date date, boolean millis, TimeZone tz) {\n      */\n \n     /**\n-     * Parse a date from ISO-8601 formatted string. It expects a format yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n-     *\n+     * Parse a date from ISO-8601 formatted string. It expects a format\n+     * [yyyy-MM-dd|yyyyMMdd][T(hh:mm[:ss[.sss]]|hhmm[ss[.sss]])]?[Z|[+-]hh:mm]]\n+     * \n      * @param date ISO string to parse in the appropriate format.\n      * @param pos The position to start parsing from, updated to where parsing stopped.\n      * @return the parsed date\n      * @throws ParseException if the date is not in the appropriate format\n      */\n-    public static Date parse(String date, ParsePosition pos) throws ParseException\n-    {\n+    public static Date parse(String date, ParsePosition pos) throws ParseException {\n         Exception fail = null;\n         try {\n             int offset = pos.getIndex();\n \n             // extract year\n             int year = parseInt(date, offset, offset += 4);\n-            checkOffset(date, offset, '-');\n+            if (checkOffset(date, offset, '-')) {\n+                offset += 1;\n+            }\n \n             // extract month\n-            int month = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, '-');\n+            int month = parseInt(date, offset, offset += 2);\n+            if (checkOffset(date, offset, '-')) {\n+                offset += 1;\n+            }\n \n             // extract day\n-            int day = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, 'T');\n-\n-            // extract hours, minutes, seconds and milliseconds\n-            int hour = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, ':');\n-\n-            int minutes = parseInt(date, offset += 1, offset += 2);\n-            checkOffset(date, offset, ':');\n-\n-            int seconds = parseInt(date, offset += 1, offset += 2);\n-            // milliseconds can be optional in the format\n+            int day = parseInt(date, offset, offset += 2);\n+            // default time value\n+            int hour = 0;\n+            int minutes = 0;\n+            int seconds = 0;\n             int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n-            if (date.charAt(offset) == '.') {\n-                checkOffset(date, offset, '.');\n-                milliseconds = parseInt(date, offset += 1, offset += 3);\n+            if (checkOffset(date, offset, 'T')) {\n+\n+                // extract hours, minutes, seconds and milliseconds\n+                hour = parseInt(date, offset += 1, offset += 2);\n+                if (checkOffset(date, offset, ':')) {\n+                    offset += 1;\n+                }\n+\n+                minutes = parseInt(date, offset, offset += 2);\n+                if (checkOffset(date, offset, ':')) {\n+                    offset += 1;\n+                }\n+                // second and milliseconds can be optional\n+                if (date.length() > offset) {\n+                    char c = date.charAt(offset);\n+                    if (c != 'Z' && c != '+' && c != '-') {\n+                        seconds = parseInt(date, offset, offset += 2);\n+                        // milliseconds can be optional in the format\n+                        if (checkOffset(date, offset, '.')) {\n+                            milliseconds = parseInt(date, offset += 1, offset += 3);\n+                        }\n+                    }\n+                }\n             }\n \n             // extract timezone\n             String timezoneId;\n+            if (date.length() <= offset) {\n+                throw new IllegalArgumentException(\"No time zone indicator\");\n+            }\n             char timezoneIndicator = date.charAt(offset);\n             if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n                 String timezoneOffset = date.substring(offset);\n \n             pos.setIndex(offset);\n             return calendar.getTime();\n-            //If we get a ParseException it'll already have the right message/offset.\n-            //Other exception types can convert here.\n+            // If we get a ParseException it'll already have the right message/offset.\n+            // Other exception types can convert here.\n         } catch (IndexOutOfBoundsException e) {\n             fail = e;\n         } catch (NumberFormatException e) {\n         } catch (IllegalArgumentException e) {\n             fail = e;\n         }\n-        String input = (date == null) ? null : ('\"'+date+\"'\");\n-        throw new ParseException(\"Failed to parse date [\"+input\n-            +\"]: \"+fail.getMessage(), pos.getIndex());\n-    }\n-\n-    /**\n-     * Check if the expected character exist at the given offset of the\n-     *\n-     * @param value    the string to check at the specified offset\n-     * @param offset   the offset to look for the expected character\n+        String input = (date == null) ? null : ('\"' + date + \"'\");\n+        throw new ParseException(\"Failed to parse date [\" + input + \"]: \" + fail.getMessage(), pos.getIndex());\n+    }\n+\n+    /**\n+     * Check if the expected character exist at the given offset in the value.\n+     * \n+     * @param value the string to check at the specified offset\n+     * @param offset the offset to look for the expected character\n      * @param expected the expected character\n-     * @throws IndexOutOfBoundsException if the expected character is not found\n-     */\n-    private static void checkOffset(String value, int offset, char expected) throws ParseException {\n-        char found = value.charAt(offset);\n-        if (found != expected) {\n-            throw new ParseException(\"Expected '\" + expected + \"' character but found '\" + found + \"'\", offset);\n-        }\n+     * @return true if the expected character exist at the given offset\n+     */\n+    private static boolean checkOffset(String value, int offset, char expected) {\n+        return (offset < value.length()) && (value.charAt(offset) == expected);\n     }\n \n     /**\n      * Parse an integer located between 2 given offsets in a string\n-     *\n-     * @param value      the string to parse\n+     * \n+     * @param value the string to parse\n      * @param beginIndex the start index for the integer in the string\n-     * @param endIndex   the end index for the integer in the string\n+     * @param endIndex the end index for the integer in the string\n      * @return the int\n      * @throws NumberFormatException if the value is not a number\n      */\n \n     /**\n      * Zero pad a number to a specified length\n-     *\n+     * \n      * @param buffer buffer to use for padding\n-     * @param value  the integer value to pad if necessary.\n+     * @param value the integer value to pad if necessary.\n      * @param length the length of the string we should zero pad\n      */\n     private static void padInt(StringBuilder buffer, int value, int length) {\n         buffer.append(strValue);\n     }\n }\n-\n--- a/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n  * NOTE: since version 2.4.2, this is <b>NOT</b> an LRU-based at all; reason\n  * being that it is not possible to use JDK components that do LRU _AND_ perform\n  * well wrt synchronization on multi-core systems. So we choose efficient synchronization\n- * over potentially more effecient handling of entries.\n+ * over potentially more efficient handling of entries.\n+ *<p>\n+ * And yes, there are efficient LRU implementations such as\n+ * <a href=\"https://code.google.com/p/concurrentlinkedhashmap/\">concurrentlinkedhashmap</a>;\n+ * but at this point we really try to keep external deps to minimum. But perhaps\n+ * a shaded variant may be used one day.\n  */\n public class LRUMap<K,V>\n     implements java.io.Serializable\n         return _map.put(key, value);\n     }\n \n+    /**\n+     * @since 2.5\n+     */\n+    public V putIfAbsent(K key, V value) {\n+        // not 100% optimal semantically, but better from correctness (never exceeds\n+        // defined maximum) and close enough all in all:\n+        if (_map.size() >= _maxEntries) {\n+            synchronized (this) {\n+                if (_map.size() >= _maxEntries) {\n+                    clear();\n+                }\n+            }\n+        }\n+        return _map.putIfAbsent(key, value);\n+    }\n+    \n     // NOTE: key is of type Object only to retain binary backwards-compatibility\n     public V get(Object key) {  return _map.get(key); }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/util/PrimitiveArrayBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/PrimitiveArrayBuilder.java\n     /**********************************************************\n      */\n \n+    public int bufferedSize() { return _bufferedEntryCount; }\n+    \n     public T resetAndStart()\n     {\n         _reset();\n--- a/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n package com.fasterxml.jackson.databind.util;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.PropertyMetadata;\n         return (_member instanceof AnnotatedParameter) ? (AnnotatedParameter) _member : null;\n     }\n \n+    @Override\n+    public Iterator<AnnotatedParameter> getConstructorParameters() {\n+        AnnotatedParameter param = getConstructorParameter();\n+        if (param == null) {\n+            return EmptyIterator.instance();\n+        }\n+        return Collections.singleton(param).iterator();\n+    }\n+    \n     /**\n      * Method used to find accessor (getter, field to access) to use for accessing\n      * value of the property.\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n         /**********************************************************\n          */\n \n-        @Deprecated // since 2.3\n-        protected Parser(Segment firstSeg, ObjectCodec codec) {\n-            this(firstSeg, codec, false, false);\n-        }\n-\n-        /**\n-         * @since 2.3\n-         */\n         public Parser(Segment firstSeg, ObjectCodec codec,\n                 boolean hasNativeTypeIds,\n                 boolean hasNativeObjectIds)\n--- a/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonValue;\n-\n import com.fasterxml.jackson.databind.ObjectMapper;\n-\n-import com.fasterxml.jackson.test.BaseTest;\n \n public abstract class BaseMapTest\n     extends BaseTest\n         }\n     }\n \n-    protected String aposToQuotes(String json) {\n+    protected static String aposToQuotes(String json) {\n         return json.replace(\"'\", \"\\\"\");\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/BaseTest.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+//import static org.junit.Assert.*;\n+\n+public abstract class BaseTest\n+    extends TestCase\n+{\n+    /*\n+    /**********************************************************\n+    /* Some sample documents:\n+    /**********************************************************\n+     */\n+\n+    protected final static int SAMPLE_SPEC_VALUE_WIDTH = 800;\n+    protected final static int SAMPLE_SPEC_VALUE_HEIGHT = 600;\n+    protected final static String SAMPLE_SPEC_VALUE_TITLE = \"View from 15th Floor\";\n+    protected final static String SAMPLE_SPEC_VALUE_TN_URL = \"http://www.example.com/image/481989943\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_HEIGHT = 125;\n+    protected final static String SAMPLE_SPEC_VALUE_TN_WIDTH = \"100\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID1 = 116;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID2 = 943;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID3 = 234;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID4 = 38793;\n+\n+    protected final static String SAMPLE_DOC_JSON_SPEC = \n+        \"{\\n\"\n+        +\"  \\\"Image\\\" : {\\n\"\n+        +\"    \\\"Width\\\" : \"+SAMPLE_SPEC_VALUE_WIDTH+\",\\n\"\n+        +\"    \\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_HEIGHT+\",\"\n+        +\"\\\"Title\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TITLE+\"\\\",\\n\"\n+        +\"    \\\"Thumbnail\\\" : {\\n\"\n+        +\"      \\\"Url\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_URL+\"\\\",\\n\"\n+        +\"\\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_TN_HEIGHT+\",\\n\"\n+        +\"      \\\"Width\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_WIDTH+\"\\\"\\n\"\n+        +\"    },\\n\"\n+        +\"    \\\"IDs\\\" : [\"+SAMPLE_SPEC_VALUE_TN_ID1+\",\"+SAMPLE_SPEC_VALUE_TN_ID2+\",\"+SAMPLE_SPEC_VALUE_TN_ID3+\",\"+SAMPLE_SPEC_VALUE_TN_ID4+\"]\\n\"\n+        +\"  }\"\n+        +\"}\"\n+        ;\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes (beans)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Sample class from Jackson tutorial (\"JacksonInFiveMinutes\")\n+     */\n+    protected static class FiveMinuteUser {\n+        public enum Gender { MALE, FEMALE };\n+\n+        public static class Name\n+        {\n+          private String _first, _last;\n+\n+          public Name() { }\n+          public Name(String f, String l) {\n+              _first = f;\n+              _last = l;\n+          }\n+          \n+          public String getFirst() { return _first; }\n+          public String getLast() { return _last; }\n+\n+          public void setFirst(String s) { _first = s; }\n+          public void setLast(String s) { _last = s; }\n+\n+          @Override\n+          public boolean equals(Object o)\n+          {\n+              if (o == this) return true;\n+              if (o == null || o.getClass() != getClass()) return false;\n+              Name other = (Name) o;\n+              return _first.equals(other._first) && _last.equals(other._last); \n+          }\n+        }\n+\n+        private Gender _gender;\n+        private Name _name;\n+        private boolean _isVerified;\n+        private byte[] _userImage;\n+\n+        public FiveMinuteUser() { }\n+\n+        public FiveMinuteUser(String first, String last, boolean verified, Gender g, byte[] data)\n+        {\n+            _name = new Name(first, last);\n+            _isVerified = verified;\n+            _gender = g;\n+            _userImage = data;\n+        }\n+        \n+        public Name getName() { return _name; }\n+        public boolean isVerified() { return _isVerified; }\n+        public Gender getGender() { return _gender; }\n+        public byte[] getUserImage() { return _userImage; }\n+\n+        public void setName(Name n) { _name = n; }\n+        public void setVerified(boolean b) { _isVerified = b; }\n+        public void setGender(Gender g) { _gender = g; }\n+        public void setUserImage(byte[] b) { _userImage = b; }\n+\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this) return true;\n+            if (o == null || o.getClass() != getClass()) return false;\n+            FiveMinuteUser other = (FiveMinuteUser) o;\n+            if (_isVerified != other._isVerified) return false;\n+            if (_gender != other._gender) return false; \n+            if (!_name.equals(other._name)) return false;\n+            byte[] otherImage = other._userImage;\n+            if (otherImage.length != _userImage.length) return false;\n+            for (int i = 0, len = _userImage.length; i < len; ++i) {\n+                if (_userImage[i] != otherImage[i]) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* High-level helpers\n+    /**********************************************************\n+     */\n+\n+    protected void verifyJsonSpecSampleDoc(JsonParser jp, boolean verifyContents)\n+        throws IOException\n+    {\n+        verifyJsonSpecSampleDoc(jp, verifyContents, true);\n+    }\n+\n+    protected void verifyJsonSpecSampleDoc(JsonParser jp, boolean verifyContents,\n+            boolean requireNumbers)\n+        throws IOException\n+    {\n+        if (!jp.hasCurrentToken()) {\n+            jp.nextToken();\n+        }\n+        assertToken(JsonToken.START_OBJECT, jp.getCurrentToken()); // main object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Image'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Image\");\n+        }\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Width\");\n+        }\n+\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_WIDTH);\n+        }\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Height\");\n+        }\n+\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_HEIGHT);\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Title'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Title\");\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Thumbnail'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Thumbnail\");\n+        }\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Url'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Url\");\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (verifyContents) {\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(jp));\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Height\");\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_HEIGHT);\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Width\");\n+        }\n+        // Width value is actually a String in the example\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (verifyContents) {\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(jp));\n+        }\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'IDs'\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken()); // 'ids' array\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[0]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID1);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[1]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID2);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[2]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID3);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[3]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID4);\n+        }\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // main object\n+    }\n+\n+    private void verifyIntToken(JsonToken t, boolean requireNumbers)\n+    {\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return;\n+        }\n+        if (requireNumbers) { // to get error\n+            assertToken(JsonToken.VALUE_NUMBER_INT, t);\n+        }\n+        // if not number, must be String\n+        if (t != JsonToken.VALUE_STRING) {\n+            fail(\"Expected INT or STRING value, got \"+t);\n+        }\n+    }\n+    \n+    protected void verifyFieldName(JsonParser jp, String expName)\n+        throws IOException\n+    {\n+        assertEquals(expName, jp.getText());\n+        assertEquals(expName, jp.getCurrentName());\n+    }\n+\n+    protected void verifyIntValue(JsonParser jp, long expValue)\n+        throws IOException\n+    {\n+        // First, via textual\n+        assertEquals(String.valueOf(expValue), jp.getText());\n+    }\n+\n+    /**\n+     * Method that checks whether Unit tests appear to run from Ant build\n+     * scripts.\n+     * \n+     * @since 1.6\n+     */\n+    protected static boolean runsFromAnt() {\n+        return \"true\".equals(System.getProperty(\"FROM_ANT\"));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Parser/generator construction\n+    /**********************************************************\n+     */\n+\n+    protected JsonParser createParserUsingReader(String input)\n+        throws IOException, JsonParseException\n+    {\n+        return createParserUsingReader(new JsonFactory(), input);\n+    }\n+\n+    protected JsonParser createParserUsingReader(JsonFactory f, String input)\n+        throws IOException, JsonParseException\n+    {\n+        return f.createParser(new StringReader(input));\n+    }\n+\n+    protected JsonParser createParserUsingStream(String input, String encoding)\n+        throws IOException, JsonParseException\n+    {\n+        return createParserUsingStream(new JsonFactory(), input, encoding);\n+    }\n+\n+    protected JsonParser createParserUsingStream(JsonFactory f,\n+                                                 String input, String encoding)\n+        throws IOException, JsonParseException\n+    {\n+\n+        /* 23-Apr-2008, tatus: UTF-32 is not supported by JDK, have to\n+         *   use our own codec too (which is not optimal since there's\n+         *   a chance both encoder and decoder might have bugs, but ones\n+         *   that cancel each other out or such)\n+         */\n+        byte[] data;\n+        if (encoding.equalsIgnoreCase(\"UTF-32\")) {\n+            data = encodeInUTF32BE(input);\n+        } else {\n+            data = input.getBytes(encoding);\n+        }\n+        InputStream is = new ByteArrayInputStream(data);\n+        return f.createParser(is);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Additional assertion methods\n+    /**********************************************************\n+     */\n+\n+    protected void assertToken(JsonToken expToken, JsonToken actToken)\n+    {\n+        if (actToken != expToken) {\n+            fail(\"Expected token \"+expToken+\", current token \"+actToken);\n+        }\n+    }\n+\n+    protected void assertToken(JsonToken expToken, JsonParser jp)\n+    {\n+        assertToken(expToken, jp.getCurrentToken());\n+    }\n+\n+    protected void assertType(Object ob, Class<?> expType)\n+    {\n+        if (ob == null) {\n+            fail(\"Expected an object of type \"+expType.getName()+\", got null\");\n+        }\n+        Class<?> cls = ob.getClass();\n+        if (!expType.isAssignableFrom(cls)) {\n+            fail(\"Expected type \"+expType.getName()+\", got \"+cls.getName());\n+        }\n+    }\n+\n+    protected void assertValidLocation(JsonLocation location) {\n+        assertNotNull(\"Should have non-null location\", location);\n+        assertTrue(\"Should have positive line number\", location.getLineNr() > 0);\n+    }\n+\n+    protected void verifyException(Throwable e, String... matches)\n+    {\n+        String msg = e.getMessage();\n+        String lmsg = (msg == null) ? \"\" : msg.toLowerCase();\n+        for (String match : matches) {\n+            String lmatch = match.toLowerCase();\n+            if (lmsg.indexOf(lmatch) >= 0) {\n+                return;\n+            }\n+        }\n+        fail(\"Expected an exception with one of substrings (\"+Arrays.asList(matches)+\"): got one with message \\\"\"+msg+\"\\\"\");\n+    }\n+\n+    /**\n+     * Method that gets textual contents of the current token using\n+     * available methods, and ensures results are consistent, before\n+     * returning them\n+     */\n+    protected String getAndVerifyText(JsonParser jp)\n+        throws IOException, JsonParseException\n+    {\n+        // Ok, let's verify other accessors\n+        int actLen = jp.getTextLength();\n+        char[] ch = jp.getTextCharacters();\n+        String str2 = new String(ch, jp.getTextOffset(), actLen);\n+        String str = jp.getText();\n+\n+        if (str.length() !=  actLen) {\n+            fail(\"Internal problem (jp.token == \"+jp.getCurrentToken()+\"): jp.getText().length() ['\"+str+\"'] == \"+str.length()+\"; jp.getTextLength() == \"+actLen);\n+        }\n+        assertEquals(\"String access via getText(), getTextXxx() must be the same\", str, str2);\n+\n+        return str;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* And other helpers\n+    /**********************************************************\n+     */\n+\n+    protected byte[] encodeInUTF32BE(String input)\n+    {\n+        int len = input.length();\n+        byte[] result = new byte[len * 4];\n+        int ptr = 0;\n+        for (int i = 0; i < len; ++i, ptr += 4) {\n+            char c = input.charAt(i);\n+            result[ptr] = result[ptr+1] = (byte) 0;\n+            result[ptr+2] = (byte) (c >> 8);\n+            result[ptr+3] = (byte) c;\n+        }\n+        return result;\n+    }\n+\n+    public String quote(String str) {\n+        return '\"'+str+'\"';\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n         assertEquals(0, m.getDeserializationConfig().mixInCount());\n         assertEquals(0, m2.getDeserializationConfig().mixInCount());\n \n-        m.addMixInAnnotations(String.class, Integer.class);\n+        m.addMixIn(String.class, Integer.class);\n         assertEquals(1, m.getSerializationConfig().mixInCount());\n         assertEquals(0, m2.getSerializationConfig().mixInCount());\n         assertEquals(1, m.getDeserializationConfig().mixInCount());\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanDeserializer.java\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Unit tests for verifying deserialization of Beans.\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanSerializer.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * This unit test suite tries to verify that the \"Native\" java type\n--- a/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n-public class TestParserUsingMapper  extends com.fasterxml.jackson.test.BaseTest\n+public class TestParserUsingMapper  extends BaseMapTest\n {\n     final static int TWO_BYTE_ESCAPED = 0x111;\n     final static int THREE_BYTE_ESCAPED = 0x1111;\n--- a/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n  * Tests to ensure that we get proper Version information via\n  * things defined as Versioned.\n  */\n-public class TestVersions extends com.fasterxml.jackson.test.BaseTest\n+public class TestVersions extends BaseMapTest\n {\n     public void testMapperVersions()\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextAttributeWithDeser.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextAttributeWithDeser.java\n \n         // as above, should not carry on state\n         TestPOJO pojo2 = MAPPER.reader(TestPOJO.class)\n-                .withAttribute(KEY, Integer.valueOf(3))\n+                .withAttribute(KEY, Integer.valueOf(5))\n                 .readValue(INPUT);\n-        assertEquals(\"x/3\", pojo2.value);\n+        assertEquals(\"x/5\", pojo2.value);\n     }\n \n     public void testHierarchic() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/SingleArgCreatorTest.java\n package com.fasterxml.jackson.databind.creators;\n \n import com.fasterxml.jackson.annotation.*;\n-\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n \n public class SingleArgCreatorTest extends BaseMapTest\n {\n         public String getSs() { return _ss; }\n     }\n \n+    // [Databind#557]\n+    \n+    static class StringyBean\n+    {\n+        public final String value;\n+\n+        private StringyBean(String value) { this.value = value; }\n+\n+        public String getValue() {\n+            return value;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MyParamIntrospector extends JacksonAnnotationIntrospector\n+    {\n+        @Override\n+        public String findImplicitPropertyName(AnnotatedMember param) {\n+            if (param instanceof AnnotatedParameter) {\n+                AnnotatedParameter ap = (AnnotatedParameter) param;\n+                switch (ap.getIndex()) {\n+                case 0: return \"value\";\n+                }\n+                return \"param\"+ap.getIndex();\n+            }\n+            return super.findImplicitPropertyName(param);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n                 SingleNamedStringBean.class);\n         assertEquals(\"foobar\", bean._ss);\n     }\n+\n+    public void testSingleStringArgWithImplicitName() throws Exception\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.setAnnotationIntrospector(new MyParamIntrospector());\n+        StringyBean bean = mapper.readValue(quote(\"foobar\"), StringyBean.class);\n+        assertEquals(\"foobar\", bean.getValue());\n+    }    \n }\n+\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestBuilderSimple.java\n         }\n     }\n \n-    @SuppressWarnings(\"hiding\")\n     static class SimpleBuilderXY\n     {\n         public int x, y;\n     \t\n-        public SimpleBuilderXY withX(int x) {\n-    \t\t    this.x = x;\n+        public SimpleBuilderXY withX(int x0) {\n+    \t\t    this.x = x0;\n     \t\t    return this;\n         }\n \n-        public SimpleBuilderXY withY(int y) {\n-    \t\t    this.y = y;\n+        public SimpleBuilderXY withY(int y0) {\n+    \t\t    this.y = y0;\n     \t\t    return this;\n         }\n \n         }\n     }\n \n-    @SuppressWarnings(\"hiding\")\n     static class BuildABC\n     {\n         public int a; // to be used as is\n         private int b, c;\n     \t\n         @JsonProperty(\"b\")\n-        public BuildABC assignB(int b) {\n-            this.b = b;\n+        public BuildABC assignB(int b0) {\n+            this.b = b0;\n             return this;\n         }\n \n         // Also ok NOT to return 'this'\n         @JsonSetter(\"c\")\n-        public void c(int c) {\n-            this.c = c;\n+        public void c(int c0) {\n+            this.c = c0;\n         }\n \n         public ValueClassABC build() {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorWithNamingStrategy556.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+\n+public class TestCreatorWithNamingStrategy556\n+    extends BaseMapTest\n+{\n+    static class RenamingCtorBean\n+    {\n+        protected String myName;\n+        protected int myAge;\n+\n+        @JsonCreator\n+        public RenamingCtorBean(int myAge, String myName)\n+        {\n+            this.myName = myName;\n+            this.myAge = myAge;\n+        }\n+    }\n+\n+    // Try the same with factory, too\n+    static class RenamedFactoryBean\n+    {\n+        protected String myName;\n+        protected int myAge;\n+\n+        private RenamedFactoryBean(int a, String n, boolean foo) {\n+            myAge = a;\n+            myName = n;\n+        }\n+        \n+        @JsonCreator\n+        public static RenamedFactoryBean create(int age, String name) {\n+            return new RenamedFactoryBean(age, name, true);\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    static class MyParamIntrospector extends JacksonAnnotationIntrospector\n+    {\n+        @Override\n+        public String findImplicitPropertyName(AnnotatedMember param) {\n+            if (param instanceof AnnotatedParameter) {\n+                AnnotatedParameter ap = (AnnotatedParameter) param;\n+                switch (ap.getIndex()) {\n+                case 0: return \"myAge\";\n+                case 1: return \"myName\";\n+                default:\n+                    return \"param\"+ap.getIndex();\n+                }\n+            }\n+            return super.findImplicitPropertyName(param);\n+        }\n+    }\n+    \n+    private final ObjectMapper MAPPER = new ObjectMapper()\n+            .setPropertyNamingStrategy(PropertyNamingStrategy.PASCAL_CASE_TO_CAMEL_CASE)\n+            ;\n+    {\n+        MAPPER.setAnnotationIntrospector(new MyParamIntrospector());\n+    }\n+\n+    private final static String CTOR_JSON = aposToQuotes(\"{ 'MyAge' : 42,  'MyName' : 'NotMyRealName' }\");\n+    \n+    public void testRenameViaCtor() throws Exception\n+    {\n+        RenamingCtorBean bean = MAPPER.readValue(CTOR_JSON, RenamingCtorBean.class);\n+        assertEquals(42, bean.myAge);\n+        assertEquals(\"NotMyRealName\", bean.myName);\n+    }\n+\n+    public void testRenameViaFactory() throws Exception\n+    {\n+        RenamedFactoryBean bean = MAPPER.readValue(CTOR_JSON, RenamedFactoryBean.class);\n+        assertEquals(42, bean.myAge);\n+        assertEquals(\"NotMyRealName\", bean.myName);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorWithPolymorphic113.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Test(s) for [Issue#113], problems with polymorphic types, JsonCreator.\n+ */\n+public class TestCreatorWithPolymorphic113 extends BaseMapTest\n+{\n+    @JsonIgnoreProperties(ignoreUnknown = true)\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = \"_class\")\n+    @JsonSubTypes({  @JsonSubTypes.Type(Dog.class) })\n+    public static abstract class Animal {\n+        public final static String ID = \"id\";\n+\n+        private String id;\n+\n+        @JsonCreator\n+        public Animal(@JsonProperty(ID) String id) {\n+            this.id = id;\n+        }\n+\n+        @JsonProperty(ID)\n+        public String getId() {\n+            return id;\n+        }\n+    }\n+\n+    @JsonIgnoreProperties(ignoreUnknown = true)\n+    public static class Dog extends Animal {\n+        @JsonCreator\n+        public Dog(@JsonProperty(ID) String id) {\n+            super(id);\n+        }\n+    }\n+\n+    @JsonIgnoreProperties(ignoreUnknown = true)\n+    public static class AnimalWrapper {\n+        private Animal animal;\n+\n+        @JsonCreator\n+        public AnimalWrapper(@JsonProperty(\"animal\") Animal animal) {\n+            this.animal = animal;\n+        }\n+\n+        public Animal getAnimal() {\n+            return animal;\n+        }\n+    }\n+\n+    public void testSubtypes() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String id = \"nice dogy\";\n+        String json = mapper.writeValueAsString(new AnimalWrapper(new Dog(id)));\n+//System.err.println(\"JSON = \"+json);\n+        AnimalWrapper wrapper = mapper.readValue(json, AnimalWrapper.class);\n+        assertEquals(id, wrapper.getAnimal().getId());\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators.java\n     public void testFactoryCreatorWithMixin() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(CreatorBean.class, MixIn.class);\n+        m.addMixIn(CreatorBean.class, MixIn.class);\n         CreatorBean bean = m.readValue\n             (\"{ \\\"a\\\" : \\\"xyz\\\", \\\"x\\\" : 12 }\", CreatorBean.class);\n         assertEquals(11, bean.x);\n     public void testFactoryCreatorWithRenamingMixin() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(FactoryBean.class, FactoryBeanMixIn.class);\n+        m.addMixIn(FactoryBean.class, FactoryBeanMixIn.class);\n         // override changes property name from \"f\" to \"mixed\"\n         FactoryBean bean = m.readValue(\"{ \\\"mixed\\\" :  20.5 }\", FactoryBean.class);\n         assertEquals(20.5, bean.d);\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators2.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators2.java\n     // For [JACKSON-541]: should not need @JsonCreator if SerializationFeature.AUTO_DETECT_CREATORS is on.\n     static class AutoDetectConstructorBean\n     {\n-    \tprotected final String foo;\n-    \tprotected final String bar;\n-\n-    \tpublic AutoDetectConstructorBean(@JsonProperty(\"bar\") String bar, @JsonProperty(\"foo\") String foo){\n-    \t    this.bar = bar;\n-    \t    this.foo = foo;\n-    \t}\n+        protected final String foo;\n+        protected final String bar;\n+\n+        public AutoDetectConstructorBean(@JsonProperty(\"bar\") String bar,\n+                @JsonProperty(\"foo\") String foo){\n+            this.bar = bar;\n+            this.foo = foo;\n+        }\n     }\n \n     static class BustedCtor {\n     }\n     \n     public void testCreatorMultipleArgumentWithoutAnnotation() throws Exception {\n-        AutoDetectConstructorBean value = MAPPER.readValue(\"{\\\"bar\\\":\\\"bar\\\",\\\"foo\\\":\\\"foo\\\"}\", AutoDetectConstructorBean.class);\n+        AutoDetectConstructorBean value = MAPPER.readValue(\"{\\\"bar\\\":\\\"bar\\\",\\\"foo\\\":\\\"foo\\\"}\",\n+                AutoDetectConstructorBean.class);\n         assertEquals(\"bar\", value.bar);\n         assertEquals(\"foo\", value.foo);\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreators421.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+\n+public class TestCreators421 extends BaseMapTest\n+{\n+    static class MultiCtor\n+    {\n+        protected String _a, _b;\n+        \n+        private MultiCtor() { }\n+        private MultiCtor(String a, String b, Boolean c) {\n+            if (c == null) {\n+                throw new RuntimeException(\"Wrong factory!\");\n+            }\n+            _a = a;\n+            _b = b;\n+        }\n+\n+        @JsonCreator\n+        static MultiCtor factory(@JsonProperty(\"a\") String a, @JsonProperty(\"b\") String b) {\n+            return new MultiCtor(a, b, Boolean.TRUE);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MyParamIntrospector extends JacksonAnnotationIntrospector\n+    {\n+        @Override\n+        public String findImplicitPropertyName(AnnotatedMember param) {\n+            if (param instanceof AnnotatedParameter) {\n+                AnnotatedParameter ap = (AnnotatedParameter) param;\n+                switch (ap.getIndex()) {\n+                case 0: return \"a\";\n+                case 1: return \"b\";\n+                case 2: return \"c\";\n+                default:\n+                    return \"param\"+ap.getIndex();\n+                }\n+            }\n+            return super.findImplicitPropertyName(param);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    // [Issue#421]\n+    public void testMultiCtor421() throws Exception\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.setAnnotationIntrospector(new MyParamIntrospector());\n+\n+        MultiCtor bean = mapper.readValue(aposToQuotes(\"{'a':'123','b':'foo'}\"), MultiCtor.class);\n+        assertNotNull(bean);\n+        assertEquals(\"123\", bean._a);\n+        assertEquals(\"foo\", bean._b);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorsDelegating.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestCreatorsDelegating.java\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JacksonInject;\n-\n import com.fasterxml.jackson.databind.*;\n \n public class TestCreatorsDelegating extends BaseMapTest\n             return new FactoryBean711(a, n1, n2);\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Unit tests\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestPolymorphicDelegating.java\n+package com.fasterxml.jackson.databind.creators;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestPolymorphicDelegating extends BaseMapTest\n+{\n+\n+    // For [databind#580]\n+    \n+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)\n+    static abstract class Issue580Base {\n+    }\n+\n+    static class Issue580Impl extends Issue580Base {\n+        public int id = 3;\n+\n+        public Issue580Impl() { }\n+        public Issue580Impl(int id) { this.id = id; }\n+    }\n+\n+    static class Issue580Bean {\n+        public Issue580Base value;\n+\n+        @JsonCreator\n+        public Issue580Bean(Issue580Base v) {\n+            value = v;\n+        }\n+\n+        @JsonValue\n+        public Issue580Base value() {\n+            return value;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testAbstractDelegateWithCreator() throws Exception\n+    {\n+        Issue580Bean input = new Issue580Bean(new Issue580Impl(13));\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(input);\n+\n+        Issue580Bean result = mapper.readValue(json, Issue580Bean.class);\n+        assertNotNull(result);\n+        assertNotNull(result.value);\n+        assertEquals(13, ((Issue580Impl) result.value).id);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/creators/TestValueUpdate.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/creators/TestValueUpdate.java\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.test.BaseTest;\n \n-public class TestValueUpdate extends BaseTest\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestValueUpdate extends BaseMapTest\n {\n     static class Bean\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n     /********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testPropertyRemoval() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n     public void testPOJOFromEmptyString() throws Exception\n     {\n         // first, verify default settings which do not accept empty String:\n-        ObjectMapper mapper = new ObjectMapper();\n+        assertFalse(MAPPER.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT));\n         try {\n-            mapper.readValue(quote(\"\"), Bean.class);\n+            MAPPER.readValue(quote(\"\"), Bean.class);\n             fail(\"Should not accept Empty String for POJO\");\n         } catch (JsonProcessingException e) {\n             verifyException(e, \"from String value\");\n             assertValidLocation(e.getLocation());\n         }\n+        // should be ok to enable dynamically\n+        ObjectReader r = MAPPER.reader(Bean.class)\n+                .with(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n+        Bean result = r.readValue(quote(\"\"));\n+        assertNull(result);\n+    }\n+\n+    // [Databind#540]\n+    public void testPOJOFromEmptyArray() throws Exception\n+    {\n+        final String JSON = \"  [\\n]\";\n+        assertFalse(MAPPER.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT));\n+        // first, verify default settings which do not accept empty Array\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.readValue(JSON, Bean.class);\n+            fail(\"Should not accept Empty Array for POJO by default\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"START_ARRAY token\");\n+            assertValidLocation(e.getLocation());\n+        }\n \n         // should be ok to enable dynamically:\n-        mapper = new ObjectMapper();\n-        mapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n-        Bean result = mapper.readValue(quote(\"\"), Bean.class);\n+        ObjectReader r = MAPPER.reader(Bean.class)\n+                .with(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT);\n+        Bean result = r.readValue(JSON);\n         assertNull(result);\n     }\n-\n+    \n     // [Issue#120]\n     public void testModifyArrayDeserializer() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n package com.fasterxml.jackson.databind.deser;\n \n import java.io.IOException;\n+import java.math.BigDecimal;\n import java.util.EnumMap;\n import java.util.EnumSet;\n import java.util.Map;\n import java.util.concurrent.TimeUnit;\n \n import com.fasterxml.jackson.annotation.*;\n-\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.*;\n             return TestEnum.valueOf(jp.getText().toUpperCase());\n         }\n     }\n-    \n+\n     protected enum EnumWithCreator {\n         A, B;\n \n         public static EnumWithCreator fromEnum(String str) {\n             if (\"enumA\".equals(str)) return A;\n             if (\"enumB\".equals(str)) return B;\n+            return null;\n+        }\n+    }\n+\n+    protected enum EnumWithBDCreator {\n+        E5, E8;\n+\n+        @JsonCreator\n+        public static EnumWithBDCreator create(BigDecimal bd) {\n+            if (bd.longValue() == 5L) return E5;\n+            if (bd.longValue() == 8L) return E8;\n             return null;\n         }\n     }\n     }\n \n     // [JACKSON-193]\n-    public void testCreatorEnums() throws Exception\n-    {\n+    public void testCreatorEnums() throws Exception {\n         EnumWithCreator value = MAPPER.readValue(\"\\\"enumA\\\"\", EnumWithCreator.class);\n         assertEquals(EnumWithCreator.A, value);\n+    }\n+\n+    public void testCreatorEnumsFromBigDecimal() throws Exception {\n+        EnumWithBDCreator value = MAPPER.readValue(\"\\\"8.0\\\"\", EnumWithBDCreator.class);\n+        assertEquals(EnumWithBDCreator.E8, value);\n     }\n     \n     // [JACKSON-212]\n     // [JACKSON-834]\n     public void testEnumsFromInts() throws Exception\n     {\n-        TestEnumFor834 res = MAPPER.readValue(\"1 \", TestEnumFor834.class);\n-        assertSame(TestEnumFor834.ENUM_A, res);\n+        Object ob = MAPPER.readValue(\"1 \", TestEnumFor834.class);\n+        assertEquals(TestEnumFor834.class, ob.getClass());\n+        assertSame(TestEnumFor834.ENUM_A, ob);\n     }\n \n     // [Issue#141]: allow mapping of empty String into null\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.type.TypeReference;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n public class TestMapDeserialization\n     extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Test classes, enums\n-    /**********************************************************\n-     */\n-\n-    enum Key {\n+    static enum Key {\n         KEY1, KEY2, WHATEVER;\n     }\n \n     public static enum ConcreteType implements ITestType {\n         ONE, TWO;\n     }\n-\n-    \n     \n     /*\n     /**********************************************************\n         assertEquals(Integer.valueOf(1), result.get(\"a\"));\n \n         assertNull(result.get(\"\"));\n+    }\n+\n+    // [Databind#540]\n+    public void testMapFromEmptyArray() throws Exception\n+    {\n+        final String JSON = \"  [\\n]\";\n+        assertFalse(MAPPER.isEnabled(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT));\n+        // first, verify default settings which do not accept empty Array\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.readValue(JSON, Map.class);\n+            fail(\"Should not accept Empty Array for Map by default\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"START_ARRAY token\");\n+        }\n+        // should be ok to enable dynamically:\n+        ObjectReader r = MAPPER.reader(Map.class)\n+                .with(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT);\n+\n+        Map<?,?> result = r.readValue(JSON);\n+        assertNull(result);\n+\n+        EnumMap<?,?> result2 = r.withType(new TypeReference<EnumMap<Key,String>>() { })\n+                .readValue(JSON);\n+        assertNull(result2);\n     }\n \n     /*\n      * Simple test to ensure that @JsonDeserialize.using is\n      * recognized\n      */\n-    public void testMapWithDeserializer() throws IOException\n+    public void testMapWithDeserializer() throws Exception\n     {\n         CustomMap result = MAPPER.readValue(quote(\"xyz\"), CustomMap.class);\n         assertEquals(1, result.size());\n         assertEquals(\"xyz\", result.get(\"x\"));\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Test methods, annotated Map.Entry\n+    /**********************************************************\n+     */\n+\n+    public void testMapEntrySimpleTypes() throws Exception\n+    {\n+        List<Map.Entry<String,Long>> stuff = MAPPER.readValue(aposToQuotes(\"[{'a':15},{'b':42}]\"),\n+                new TypeReference<List<Map.Entry<String,Long>>>() { });\n+        assertNotNull(stuff);\n+        assertEquals(2, stuff.size());\n+        assertNotNull(stuff.get(1));\n+        assertEquals(\"b\", stuff.get(1).getKey());\n+        assertEquals(Long.valueOf(42), stuff.get(1).getValue());\n+    }\n+\n+    public void testMapEntryWithStringBean() throws Exception\n+    {\n+        List<Map.Entry<Integer,StringWrapper>> stuff = MAPPER.readValue(aposToQuotes(\"[{'28':'Foo'},{'13':'Bar'}]\"),\n+                new TypeReference<List<Map.Entry<Integer,StringWrapper>>>() { });\n+        assertNotNull(stuff);\n+        assertEquals(2, stuff.size());\n+        assertNotNull(stuff.get(1));\n+        assertEquals(Integer.valueOf(13), stuff.get(1).getKey());\n+        \n+        StringWrapper sw = stuff.get(1).getValue();\n+        assertEquals(\"Bar\", sw.str);\n+    }\n+\n+    public void testMapEntryFail() throws Exception\n+    {\n+        try {\n+            /*List<Map.Entry<Integer,StringWrapper>> stuff =*/ MAPPER.readValue(aposToQuotes(\"[{'28':'Foo','13':'Bar'}]\"),\n+                    new TypeReference<List<Map.Entry<Integer,StringWrapper>>>() { });\n+            fail(\"Should not have passed\");\n+        } catch (Exception e) {\n+            verifyException(e, \"more than one entry in JSON\");\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Error tests\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestValueAnnotations.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestValueAnnotations.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * This unit test suite tests use of \"value\" Annotations;\n  * deserialization.\n  */\n public class TestValueAnnotations\n-    extends BaseTest\n+    extends BaseMapTest\n {\n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/filter/TestMapFiltering.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/filter/TestMapFiltering.java\n package com.fasterxml.jackson.databind.filter;\n \n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.JsonFilter;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.ser.PropertyFilter;\n+import com.fasterxml.jackson.databind.ser.PropertyWriter;\n import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\n import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;\n \n public class TestMapFiltering extends BaseMapTest\n {\n+    @Target({ElementType.FIELD})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface CustomOffset\n+    {\n+        public int value();\n+    }\n+\n     @SuppressWarnings(\"serial\")\n     @JsonFilter(\"filterForMaps\")\n     static class FilteredBean extends LinkedHashMap<String,Integer> { }\n     \n     static class MapBean {\n         @JsonFilter(\"filterX\")\n+        @CustomOffset(1)\n         public Map<String,Integer> values;\n         \n         public MapBean() {\n             values.put(\"c\", 9);\n         }\n     }\n-    \n+\n+    static class MyMapFilter implements PropertyFilter\n+    {\n+        @Override\n+        public void serializeAsField(Object value, JsonGenerator jgen,\n+                SerializerProvider provider, PropertyWriter writer)\n+            throws Exception\n+        {\n+            String name = writer.getName();\n+            if (!\"a\".equals(name)) {\n+                return;\n+            }\n+            CustomOffset n = writer.findAnnotation(CustomOffset.class);\n+            int offset = (n == null) ? 0 : n.value();\n+            Integer I = offset + ((Integer) value).intValue();\n+\n+            writer.serializeAsField(I, jgen, provider);\n+        }\n+\n+        @Override\n+        public void serializeAsElement(Object elementValue, JsonGenerator jgen,\n+                SerializerProvider prov, PropertyWriter writer)\n+                throws Exception {\n+            // not needed for testing\n+        }\n+\n+        @Override\n+        public void depositSchemaProperty(PropertyWriter writer,\n+                ObjectNode propertiesNode, SerializerProvider provider)\n+                throws JsonMappingException {\n+            \n+        }\n+\n+        @Override\n+        public void depositSchemaProperty(PropertyWriter writer,\n+                JsonObjectFormatVisitor objectVisitor,\n+                SerializerProvider provider) throws JsonMappingException {\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertEquals(aposToQuotes(\"{'b':3}\"), json);\n     }\n     \n+    // [Issue#522]\n+    public void testMapFilteringWithAnnotations() throws Exception\n+    {\n+        FilterProvider prov = new SimpleFilterProvider().addFilter(\"filterX\",\n+                new MyMapFilter());\n+        String json = MAPPER.writer(prov).writeValueAsString(new MapBean());\n+        // a=1 should become a=2\n+        assertEquals(aposToQuotes(\"{'values':{'a':2}}\"), json);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestCglibUsage.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestCglibUsage.java\n package com.fasterxml.jackson.databind.interop;\n \n-\n-import java.io.*;\n import java.lang.reflect.Method;\n import java.util.*;\n \n import net.sf.cglib.proxy.MethodProxy;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Unit test for checking that we can serialize CGLib generated proxies.\n  */\n-public class TestCglibUsage\n-    extends BaseTest\n+public class TestCglibUsage extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n     interface BeanInterface {\n         public int getX();\n     }\n         assertEquals(1, result.size());\n         assertEquals(Integer.valueOf(13), result.get(\"x\"));\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper methods\n-    /**********************************************************\n-     */\n-\n-    @SuppressWarnings(\"unchecked\")\n-\tprivate Map<String,Object> writeAndMap(ObjectMapper m, Object value)\n-        throws IOException\n-    {\n-        StringWriter sw = new StringWriter();\n-        m.writeValue(sw, value);\n-        return (Map<String,Object>) m.readValue(sw.toString(), Object.class);\n-    }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestHibernate.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestHibernate.java\n package com.fasterxml.jackson.databind.interop;\n \n-\n-import java.io.*;\n import java.lang.reflect.Method;\n import java.util.*;\n \n import org.hibernate.repackage.cglib.proxy.MethodProxy;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * Basic tests covering Hibernate-compatibility features.\n  */\n public class TestHibernate\n-    extends BaseTest\n+    extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n     interface BeanInterfaceHib {\n         public int getX();\n     }\n         assertEquals(1, result.size());\n         assertEquals(Integer.valueOf(13), result.get(\"x\"));\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper methods\n-    /**********************************************************\n-     */\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private Map<String,Object> writeAndMap(ObjectMapper m, Object value)\n-        throws IOException\n-    {\n-        StringWriter sw = new StringWriter();\n-        m.writeValue(sw, value);\n-        return (Map<String,Object>) m.readValue(sw.toString(), Object.class);\n-    }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestAnnotionBundles.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestAnnotionBundles.java\n import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n \n-import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JacksonAnnotationsInside;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyName;\n \n /* Tests mostly for [JACKSON-754]: ability to create \"annotation bundles\"\n  */\n     public class Bean92 {\n         @Bundle92\n         protected String id = \"abc\";\n-    }    \n+    }\n+\n+    @HolderB\n+    @JacksonAnnotationsInside\n+    @Retention(RetentionPolicy.RUNTIME)\n+    static @interface HolderA {}\n+\n+    @HolderA\n+    @JacksonAnnotationsInside\n+    @Retention(RetentionPolicy.RUNTIME)\n+    static @interface HolderB {}\n+\n+    static class RecursiveHolder {\n+        @HolderA public int unimportant = 42;\n+    }\n+\n+    @JsonProperty\n+    @JacksonAnnotationsInside\n+    @Retention(RetentionPolicy.RUNTIME)\n+    static @interface InformativeHolder {\n+        // doesn't really contribute to the test, but would be impossible without this feature\n+        boolean important() default true;\n+    }\n+\n+    static class InformingHolder {\n+        @InformativeHolder public int unimportant = 42;\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class BundleAnnotationIntrospector extends JacksonAnnotationIntrospector {\n+        @Override\n+        public PropertyName findNameForSerialization(Annotated a)\n+        {\n+            InformativeHolder informativeHolder = a.getAnnotation(InformativeHolder.class);\n+            if ((informativeHolder != null) && informativeHolder.important()) {\n+                return new PropertyName(\"important\");\n+            }\n+            return super.findNameForSerialization(a);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n      */\n \n     private final ObjectMapper MAPPER = new ObjectMapper();\n-    \n+\n+    public void testKeepAnnotationBundle() throws Exception\n+    {\n+        MAPPER.setAnnotationIntrospector(new BundleAnnotationIntrospector());\n+        assertEquals(\"{\\\"important\\\":42}\", MAPPER.writeValueAsString(new InformingHolder()));\n+    }\n+\n+    public void testRecursiveBundles() throws Exception\n+    {\n+        assertEquals(\"{\\\"unimportant\\\":42}\", MAPPER.writeValueAsString(new RecursiveHolder()));\n+    }\n+\n     public void testBundledIgnore() throws Exception\n     {\n         assertEquals(\"{\\\"foobar\\\":13}\", MAPPER.writeValueAsString(new Bean()));\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestAutoDetect.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+\n+public class TestAutoDetect\n+    extends BaseMapTest\n+{\n+    static class PrivateBean {\n+        String a;\n+\n+        private PrivateBean() { }\n+\n+        private PrivateBean(String a) { this.a = a; }\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Unit tests\n+    /********************************************************\n+     */\n+    \n+    public void testPrivateCtor() throws Exception\n+    {\n+        // first, default settings, with which construction works ok\n+        ObjectMapper m = new ObjectMapper();\n+        PrivateBean bean = m.readValue(\"\\\"abc\\\"\", PrivateBean.class);\n+        assertEquals(\"abc\", bean.a);\n+\n+        // then by increasing visibility requirement:\n+        m = new ObjectMapper();\n+        // note: clumsy code, but needed for Eclipse/JDK1.5 compilation (not for 1.6)\n+        VisibilityChecker<?> vc = m.getVisibilityChecker();\n+        vc = vc.withCreatorVisibility(JsonAutoDetect.Visibility.PUBLIC_ONLY);\n+        m.setVisibilityChecker(vc);\n+        try {\n+            m.readValue(\"\\\"abc\\\"\", PrivateBean.class);\n+            fail(\"Expected exception for missing constructor\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"no single-String constructor/factory\");\n+        }\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestBuilderMethods.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestBuilderMethods.java\n     {\n         public int x;\n \n-        @SuppressWarnings(\"hiding\")\n-        public SimpleBuilder withX(int x) {\n-    \t\t    this.x = x;\n+        public SimpleBuilder withX(int x0) {\n+    \t\t    this.x = x0;\n     \t\t    return this;\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestMixinMerging.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestMixinMerging.java\n     }\n \n     static class ContactImpl implements Contact {\n+        @Override\n         public String getCity() { return \"Seattle\"; }\n     }\n \n     static class ContactMixin implements Contact {\n+        @Override\n         @JsonProperty\n         public String getCity() { return null; }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestNameConflicts.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestNameConflicts.java\n \n public class TestNameConflicts extends BaseMapTest\n {\n+    @JsonAutoDetect\n+    (fieldVisibility= JsonAutoDetect.Visibility.NONE,getterVisibility= JsonAutoDetect.Visibility.NONE, setterVisibility= JsonAutoDetect.Visibility.NONE, isGetterVisibility= JsonAutoDetect.Visibility.NONE)\n+    static class CoreBean158 {\n+        private String bar = \"x\";\n+\n+        @JsonProperty\n+        public String getBar() {\n+            return bar;\n+        }\n+\n+        @JsonProperty\n+        public void setBar(String bar) {\n+            this.bar = bar;\n+        }\n+\n+        public void setBar(java.io.Serializable bar) {\n+            this.bar = bar.toString();\n+        }\n+    }\n+    \n     static class Bean193\n     {\n         @JsonProperty(\"val1\")\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = objectMapper();\n+    \n     // [Issue#193]\n     public void testIssue193() throws Exception\n     {\n     // [Issue#327]\n     public void testNonConflict() throws Exception\n     {\n-        String json = objectMapper().writeValueAsString(new BogusConflictBean());\n+        String json = MAPPER.writeValueAsString(new BogusConflictBean());\n         assertEquals(aposToQuotes(\"{'prop1':2,'prop2':1}\"), json);\n     }    \n \n         String json = objectWriter().writeValueAsString(new MultipleTheoreticalGetters());\n         assertEquals(aposToQuotes(\"{'a':3}\"), json);\n     }\n+\n+    // for [jackson-core#158]\n+    public void testOverrideName() throws Exception\n+    {\n+        final ObjectMapper mapper = objectMapper();\n+        String json = mapper.writeValueAsString(new CoreBean158());\n+        assertEquals(aposToQuotes(\"{'bar':'x'}\"), json);\n+\n+        // and back\n+        CoreBean158 result = null;\n+        try {\n+            result = mapper.readValue(aposToQuotes(\"{'bar':'y'}\"), CoreBean158.class);\n+        } catch (Exception e) {\n+            fail(\"Unexpected failure when reading CoreBean158: \"+e);\n+        }\n+        assertNotNull(result);\n+        assertEquals(\"y\", result.bar);\n+    }    \n }\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestPropertyConflicts.java\n     // [Issue#238]\n     protected static class Getters1A\n     {\n+        @JsonProperty\n         protected int value = 3;\n         \n         public int getValue() { return value+1; }\n     {\n         public boolean isValue() { return false; }\n \n+        @JsonProperty\n         protected int value = 3;\n         \n         public int getValue() { return value+1; }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n      * Another enum type, but this time forcing sub-classing\n      */\n     enum ComplexChoice {\n-    \tMAYBE(true), PROBABLY_NOT(false);\n-\n-    \tprivate boolean state;\n+        MAYBE(true), PROBABLY_NOT(false);\n+\n+        private boolean state;\n     \t\n-    \tprivate ComplexChoice(boolean b) { state = b; }\n+        private ComplexChoice(boolean b) { state = b; }\n     \t\n         @Override\n-    \tpublic String toString() { return String.valueOf(state); }\n+        public String toString() { return String.valueOf(state); }\n     }\n \n     // [JACKSON-311]\n         assertEquals(\"abc\", ((StringBean) result[0]).name);\n     }\n \n+    // with 2.5, another test to check that \"as-property\" is valid option\n+    public void testBeanAsObjectUsingAsProperty() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.NON_FINAL,\n+                \".hype\");\n+        // note: need to wrap, to get declared as Object\n+        String json = m.writeValueAsString(new StringBean(\"abc\"));\n+        \n+        // Ok: serialization seems to work as expected. Now deserialize:\n+        Object result = m.readValue(json, Object.class);\n+        assertNotNull(result);\n+        assertEquals(StringBean.class, result.getClass());\n+        assertEquals(\"abc\", ((StringBean) result).name);\n+    }\n+    \n     /**\n      * Unit test that verifies that an abstract bean is stored with type information\n      * if default type information is enabled for non-concrete types.\n         String json = mapper.writeValueAsString(new BeanHolder(new StringBean(\"punny\")));\n         assertEquals(\"{\\\"bean\\\":{\\\"*CLASS*\\\":\\\"com.fasterxml.jackson.databind.jsontype.TestDefaultForObject$StringBean\\\",\\\"name\\\":\\\"punny\\\"}}\", json);\n     }\n+\n+    public void testNoGoWithExternalProperty() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT,\n+                    JsonTypeInfo.As.EXTERNAL_PROPERTY);\n+            fail(\"Should not have passed\");\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"Can not use includeAs of EXTERNAL_PROPERTY\");\n+        }\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n \n import com.fasterxml.jackson.annotation.*;\n \n-import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.core.type.TypeReference;\n \n import com.fasterxml.jackson.databind.*;\n     public void testSubTypesFor356() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        /* 06-Sep-2010, tatus: This was not fixed for 1.6; and to keep junit test\n-         *   suite green, let's not run it for versions prior to 1.7...\n-         */\n-        Version v = mapper.version();\n-        if (v.getMajorVersion() == 1 && v.getMinorVersion() == 6) {\n-            System.err.println(\"Note: skipping test for Jackson 1.6\");\n-            return;\n-        }\n         \n         JSONResponse<List<Parent>> input = new JSONResponse<List<Parent>>();\n \n \n         JavaType rootType = TypeFactory.defaultInstance().constructType(new TypeReference<JSONResponse<List<Parent>>>() { });\n         byte[] json = mapper.writerWithType(rootType).writeValueAsBytes(input);\n-//        byte[] json = mapper.writeValueAsBytes(input);\n-\n-//        System.out.println(\"After Serialization: \" + new String(json));\n         \n         JSONResponse<List<Parent>> out = mapper.readValue(json, 0, json.length, rootType);\n \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypesExistingProperty.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestSubtypesExistingProperty extends BaseMapTest {\n+\n+    /**\n+     * Polymorphic base class - existing property as simple property on subclasses\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\",\n+\t        visible=true)\n+\t@JsonSubTypes({\n+\t\t@Type(value = Apple.class, name = \"apple\") ,\n+\t\t@Type(value = Orange.class, name = \"orange\") \n+\t\t})\n+\tstatic abstract class Fruit {\n+        public String name;\n+        protected Fruit(String n)  { name = n; }\n+    }\n+\n+    @JsonTypeName(\"apple\")\n+    static class Apple extends Fruit\n+    {\n+        public int seedCount;\n+        public String type;\n+\n+        private Apple() { super(null);; }\n+        public Apple(String name, int b) {\n+            super(name);\n+            seedCount = b;\n+            type = \"apple\";\n+        }\n+    }\n+    \n+    @JsonTypeName(\"orange\")\n+    static class Orange extends Fruit\n+    {\n+        public String color;\n+        public String type;\n+        \n+        private Orange() { super(null); }\n+        public Orange(String name, String c) {\n+            super(name);\n+            color = c;\n+            type = \"orange\";\n+        }\n+    }\n+\n+    static class FruitWrapper {\n+        public Fruit fruit;\n+        public FruitWrapper() {}\n+        public FruitWrapper(Fruit f) { fruit = f; }\n+    }\n+    \n+    /**\n+     * Polymorphic base class - existing property forced by abstract method\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Dog.class, name = \"doggie\") ,\n+\t\t@Type(value = Cat.class, name = \"kitty\") \n+\t\t})\n+\tstatic abstract class Animal {\n+        public String name;\n+        \n+        protected Animal(String n)  { name = n; }\n+        \n+        public abstract String getType();\n+    }\n+\n+    @JsonTypeName(\"doggie\")\n+    static class Dog extends Animal\n+    {\n+        public int boneCount;\n+        \n+        private Dog() { super(null); }\n+        public Dog(String name, int b) {\n+            super(name);\n+            boneCount = b;\n+        }\n+        \n+ \t\t@Override\n+\t\tpublic String getType() {\n+        \treturn \"doggie\";\n+        }        \n+    }\n+    \n+    @JsonTypeName(\"kitty\")\n+    static class Cat extends Animal\n+    {\n+        public String furColor;\n+        \n+        private Cat() { super(null); }\n+        public Cat(String name, String c) {\n+            super(name);\n+            furColor = c;\n+        }\n+        \n+\t\t@Override\n+\t\tpublic String getType() {\n+        \treturn \"kitty\";\n+        }        \n+    }\n+\n+    static class AnimalWrapper {\n+        public Animal animal;\n+        public AnimalWrapper() {}\n+        public AnimalWrapper(Animal a) { animal = a; }\n+    }\n+\n+\n+    /**\n+     * Polymorphic base class - existing property NOT forced by abstract method on base class\n+     */\n+\t@JsonTypeInfo(use = Id.NAME, include = As.EXISTING_PROPERTY, property = \"type\")\n+\t@JsonSubTypes({\n+\t\t@Type(value = Accord.class, name = \"accord\") ,\n+\t\t@Type(value = Camry.class, name = \"camry\") \n+\t\t})\n+\tstatic abstract class Car {\n+        public String name;        \n+        protected Car(String n)  { name = n; }\n+    }\n+\n+    @JsonTypeName(\"accord\")\n+    static class Accord extends Car\n+    {\n+        public int speakerCount;\n+        \n+        private Accord() { super(null); }\n+        public Accord(String name, int b) {\n+            super(name);\n+            speakerCount = b;\n+        }\n+        \n+\t\tpublic String getType() {\n+        \treturn \"accord\";\n+        }        \n+    }\n+    \n+    @JsonTypeName(\"camry\")\n+    static class Camry extends Car\n+    {\n+        public String exteriorColor;\n+        \n+        private Camry() { super(null); }\n+        public Camry(String name, String c) {\n+            super(name);\n+            exteriorColor = c;\n+        }\n+        \n+\t\tpublic String getType() {\n+        \treturn \"camry\";\n+        }        \n+    }\n+\n+    static class CarWrapper {\n+        public Car car;\n+        public CarWrapper() {}\n+        public CarWrapper(Car c) { car = c; }\n+    }\n+    \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    /*\n+    /**********************************************************\n+    /* Mock data\n+    /**********************************************************\n+     */\n+\n+\tprivate static final Orange mandarin = new Orange(\"Mandarin Orange\", \"orange\");\n+\tprivate static final String mandarinJson = \"{\\\"name\\\":\\\"Mandarin Orange\\\",\\\"color\\\":\\\"orange\\\",\\\"type\\\":\\\"orange\\\"}\";\t\n+\tprivate static final Apple pinguo = new Apple(\"Apple-A-Day\", 16);\n+\tprivate static final String pinguoJson = \"{\\\"name\\\":\\\"Apple-A-Day\\\",\\\"seedCount\\\":16,\\\"type\\\":\\\"apple\\\"}\";\n+\tprivate static final FruitWrapper pinguoWrapper = new FruitWrapper(pinguo);\n+\tprivate static final String pinguoWrapperJson = \"{\\\"fruit\\\":\" + pinguoJson + \"}\";\n+\tprivate static final List<Fruit> fruitList = Arrays.asList(pinguo, mandarin);\n+\tprivate static final String fruitListJson = \"[\" + pinguoJson + \",\" + mandarinJson + \"]\";\n+\n+\tprivate static final Cat beelzebub = new Cat(\"Beelzebub\", \"tabby\");\n+\tprivate static final String beelzebubJson = \"{\\\"name\\\":\\\"Beelzebub\\\",\\\"furColor\\\":\\\"tabby\\\",\\\"type\\\":\\\"kitty\\\"}\";\t\n+\tprivate static final Dog rover = new Dog(\"Rover\", 42);\n+\tprivate static final String roverJson = \"{\\\"name\\\":\\\"Rover\\\",\\\"boneCount\\\":42,\\\"type\\\":\\\"doggie\\\"}\";\n+\tprivate static final AnimalWrapper beelzebubWrapper = new AnimalWrapper(beelzebub);\n+\tprivate static final String beelzebubWrapperJson = \"{\\\"animal\\\":\" + beelzebubJson + \"}\";\n+\tprivate static final List<Animal> animalList = Arrays.asList(beelzebub, rover);\n+\tprivate static final String animalListJson = \"[\" + beelzebubJson + \",\" + roverJson + \"]\";\n+\n+\tprivate static final Camry camry = new Camry(\"Sweet Ride\", \"candy-apple-red\");\n+\tprivate static final String camryJson = \"{\\\"name\\\":\\\"Sweet Ride\\\",\\\"exteriorColor\\\":\\\"candy-apple-red\\\",\\\"type\\\":\\\"camry\\\"}\";\t\n+\tprivate static final Accord accord = new Accord(\"Road Rage\", 6);\n+\tprivate static final String accordJson = \"{\\\"name\\\":\\\"Road Rage\\\",\\\"speakerCount\\\":6,\\\"type\\\":\\\"accord\\\"}\";\n+\tprivate static final CarWrapper camryWrapper = new CarWrapper(camry);\n+\tprivate static final String camryWrapperJson = \"{\\\"car\\\":\" + camryJson + \"}\";\n+\tprivate static final List<Car> carList = Arrays.asList(camry, accord);\n+\tprivate static final String carListJson = \"[\" + camryJson + \",\" + accordJson + \"]\";\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fruits - serialization tests for simple property on sub-classes\n+     */\n+    public void testExistingPropertySerializationFruits() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, pinguo);\n+        assertEquals(3, result.size());\n+        assertEquals(pinguo.name, result.get(\"name\"));\n+        assertEquals(pinguo.seedCount, result.get(\"seedCount\"));\n+        assertEquals(pinguo.type, result.get(\"type\"));\n+        \n+        result = writeAndMap(MAPPER, mandarin);\n+        assertEquals(3, result.size());\n+        assertEquals(mandarin.name, result.get(\"name\"));\n+        assertEquals(mandarin.color, result.get(\"color\"));\n+        assertEquals(mandarin.type, result.get(\"type\"));\n+        \n+        String pinguoSerialized = MAPPER.writeValueAsString(pinguo);\n+        assertEquals(pinguoSerialized, pinguoJson);\n+\n+        String mandarinSerialized = MAPPER.writeValueAsString(mandarin);\n+        assertEquals(mandarinSerialized, mandarinJson);\n+\n+        String fruitWrapperSerialized = MAPPER.writeValueAsString(pinguoWrapper);\n+        assertEquals(fruitWrapperSerialized, pinguoWrapperJson);\n+\n+        String fruitListSerialized = MAPPER.writeValueAsString(fruitList);\n+        assertEquals(fruitListSerialized, fruitListJson);\n+    }\n+\n+    /**\n+     * Fruits - deserialization tests for simple property on sub-classes\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationFruits() throws Exception\n+    {\n+        Fruit pinguoDeserialized = MAPPER.readValue(pinguoJson, Fruit.class);\n+        assertTrue(pinguoDeserialized instanceof Apple);\n+        assertSame(pinguoDeserialized.getClass(), Apple.class);\n+        assertEquals(pinguo.name, pinguoDeserialized.name);\n+        assertEquals(pinguo.seedCount, ((Apple) pinguoDeserialized).seedCount);\n+        assertEquals(pinguo.type, ((Apple) pinguoDeserialized).type);\n+\n+        FruitWrapper pinguoWrapperDeserialized = MAPPER.readValue(pinguoWrapperJson, FruitWrapper.class);\n+        Fruit pinguoExtracted = pinguoWrapperDeserialized.fruit;\n+        assertTrue(pinguoExtracted instanceof Apple);\n+        assertSame(pinguoExtracted.getClass(), Apple.class);\n+        assertEquals(pinguo.name, pinguoExtracted.name);\n+        assertEquals(pinguo.seedCount, ((Apple) pinguoExtracted).seedCount);\n+        assertEquals(pinguo.type, ((Apple) pinguoExtracted).type);\n+\n+        Fruit[] fruits = MAPPER.readValue(fruitListJson, Fruit[].class);\n+        assertEquals(2, fruits.length);\n+        assertEquals(Apple.class, fruits[0].getClass());\n+        assertEquals(\"apple\", ((Apple) fruits[0]).type);\n+        assertEquals(Orange.class, fruits[1].getClass());\n+        assertEquals(\"orange\", ((Orange) fruits[1]).type);\n+        \n+        List<Fruit> f2 = MAPPER.readValue(fruitListJson,\n+                new TypeReference<List<Fruit>>() { });\n+        assertNotNull(f2);\n+        assertTrue(f2.size() == 2);\n+        assertEquals(Apple.class, f2.get(0).getClass());\n+        assertEquals(Orange.class, f2.get(1).getClass());\n+    }\n+\n+    /**\n+     * Animals - serialization tests for abstract method in base class\n+     */\n+    public void testExistingPropertySerializationAnimals() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, beelzebub);\n+        assertEquals(3, result.size());\n+        assertEquals(beelzebub.name, result.get(\"name\"));\n+        assertEquals(beelzebub.furColor, result.get(\"furColor\"));\n+        assertEquals(beelzebub.getType(), result.get(\"type\"));\n+\n+        result = writeAndMap(MAPPER, rover);\n+        assertEquals(3, result.size());\n+        assertEquals(rover.name, result.get(\"name\"));\n+        assertEquals(rover.boneCount, result.get(\"boneCount\"));\n+        assertEquals(rover.getType(), result.get(\"type\"));\n+        \n+        String beelzebubSerialized = MAPPER.writeValueAsString(beelzebub);\n+        assertEquals(beelzebubSerialized, beelzebubJson);\n+        \n+        String roverSerialized = MAPPER.writeValueAsString(rover);\n+        assertEquals(roverSerialized, roverJson);\n+        \n+        String animalWrapperSerialized = MAPPER.writeValueAsString(beelzebubWrapper);\n+        assertEquals(animalWrapperSerialized, beelzebubWrapperJson);\n+\n+        String animalListSerialized = MAPPER.writeValueAsString(animalList);\n+        assertEquals(animalListSerialized, animalListJson);\n+    }\n+\n+    /**\n+     * Animals - deserialization tests for abstract method in base class\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationAnimals() throws Exception\n+    {\n+        Animal beelzebubDeserialized = MAPPER.readValue(beelzebubJson, Animal.class);\n+        assertTrue(beelzebubDeserialized instanceof Cat);\n+        assertSame(beelzebubDeserialized.getClass(), Cat.class);\n+        assertEquals(beelzebub.name, beelzebubDeserialized.name);\n+        assertEquals(beelzebub.furColor, ((Cat) beelzebubDeserialized).furColor);\n+        assertEquals(beelzebub.getType(), beelzebubDeserialized.getType());\n+\n+        AnimalWrapper beelzebubWrapperDeserialized = MAPPER.readValue(beelzebubWrapperJson, AnimalWrapper.class);\n+        Animal beelzebubExtracted = beelzebubWrapperDeserialized.animal;\n+        assertTrue(beelzebubExtracted instanceof Cat);\n+        assertSame(beelzebubExtracted.getClass(), Cat.class);\n+        assertEquals(beelzebub.name, beelzebubExtracted.name);\n+        assertEquals(beelzebub.furColor, ((Cat) beelzebubExtracted).furColor);\n+        assertEquals(beelzebub.getType(), beelzebubExtracted.getType());\n+    \t\n+        @SuppressWarnings(\"unchecked\")\n+        List<Animal> animalListDeserialized = MAPPER.readValue(animalListJson, List.class);\n+        assertNotNull(animalListDeserialized);\n+        assertTrue(animalListDeserialized.size() == 2);\n+        Animal cat = MAPPER.convertValue(animalListDeserialized.get(0), Animal.class);\n+        assertTrue(cat instanceof Cat);\n+        assertSame(cat.getClass(), Cat.class);\n+        Animal dog = MAPPER.convertValue(animalListDeserialized.get(1), Animal.class);\n+        assertTrue(dog instanceof Dog);\n+        assertSame(dog.getClass(), Dog.class);\n+    }\n+\n+    /**\n+     * Cars - serialization tests for no abstract method or type variable in base class\n+     */\n+    public void testExistingPropertySerializationCars() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(MAPPER, camry);\n+        assertEquals(3, result.size());\n+        assertEquals(camry.name, result.get(\"name\"));\n+        assertEquals(camry.exteriorColor, result.get(\"exteriorColor\"));\n+        assertEquals(camry.getType(), result.get(\"type\"));\n+\n+        result = writeAndMap(MAPPER, accord);\n+        assertEquals(3, result.size());\n+        assertEquals(accord.name, result.get(\"name\"));\n+        assertEquals(accord.speakerCount, result.get(\"speakerCount\"));\n+        assertEquals(accord.getType(), result.get(\"type\"));\n+        \n+        String camrySerialized = MAPPER.writeValueAsString(camry);\n+        assertEquals(camrySerialized, camryJson);\n+        \n+        String accordSerialized = MAPPER.writeValueAsString(accord);\n+        assertEquals(accordSerialized, accordJson);\n+        \n+        String carWrapperSerialized = MAPPER.writeValueAsString(camryWrapper);\n+        assertEquals(carWrapperSerialized, camryWrapperJson);\n+\n+        String carListSerialized = MAPPER.writeValueAsString(carList);\n+        assertEquals(carListSerialized, carListJson);\n+    }\n+\n+    /**\n+     * Cars - deserialization tests for no abstract method or type variable in base class\n+     */\n+    public void testSimpleClassAsExistingPropertyDeserializationCars() throws Exception\n+    {\n+        Car camryDeserialized = MAPPER.readValue(camryJson, Camry.class);\n+        assertTrue(camryDeserialized instanceof Camry);\n+        assertSame(camryDeserialized.getClass(), Camry.class);\n+        assertEquals(camry.name, camryDeserialized.name);\n+        assertEquals(camry.exteriorColor, ((Camry) camryDeserialized).exteriorColor);\n+        assertEquals(camry.getType(), ((Camry) camryDeserialized).getType());\n+\n+        CarWrapper camryWrapperDeserialized = MAPPER.readValue(camryWrapperJson, CarWrapper.class);\n+        Car camryExtracted = camryWrapperDeserialized.car;\n+        assertTrue(camryExtracted instanceof Camry);\n+        assertSame(camryExtracted.getClass(), Camry.class);\n+        assertEquals(camry.name, camryExtracted.name);\n+        assertEquals(camry.exteriorColor, ((Camry) camryExtracted).exteriorColor);\n+        assertEquals(camry.getType(), ((Camry) camryExtracted).getType());\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<Car> carListDeserialized = MAPPER.readValue(carListJson, List.class);\n+        assertNotNull(carListDeserialized);\n+        assertTrue(carListDeserialized.size() == 2);\n+        Car result = MAPPER.convertValue(carListDeserialized.get(0), Car.class);\n+        assertTrue(result instanceof Camry);\n+        assertSame(result.getClass(), Camry.class);\n+\n+        result = MAPPER.convertValue(carListDeserialized.get(1), Car.class);\n+        assertTrue(result instanceof Accord);\n+        assertSame(result.getClass(), Accord.class);\n+    }\n+}    \n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArrayDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArrayDeserialization.java\n     {\n         ObjectMapper m = new ObjectMapper();\n         // use class name, WRAPPER_OBJECT\n-        m.addMixInAnnotations(long[].class, WrapperMixIn.class);\n+        m.addMixIn(long[].class, WrapperMixIn.class);\n         String JSON = \"{\\\"\"+long[].class.getName()+\"\\\":[5, 6, 7]}\";\n         long[] value = m.readValue(JSON, long[].class);\n         assertNotNull(value);\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n     public void testIntArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(int[].class, WrapperMixIn.class);\n+        m.addMixIn(int[].class, WrapperMixIn.class);\n         int[] input = new int[] { 1, 2, 3 };\n         String clsName = int[].class.getName();\n         assertEquals(\"{\\\"\"+clsName+\"\\\":[1,2,3]}\", serializeAsString(m, input));\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedContainerSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedContainerSerialization.java\n     {\n             ArrayList<Animal> animals = new ArrayList<Animal>();\n             animals.add(new Dog(\"Spot\"));\n-            JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class);\n+            JavaType rootType = TypeFactory.defaultInstance().constructParametrizedType(Iterator.class, Iterator.class, Animal.class);\n             String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator());\n             if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n                 fail(\"No polymorphic type retained, should be; JSON = '\"+json+\"'\");\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserialization.java\n     public void testTypeAsWrapper() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Animal.class, TypeWithWrapper.class);\n+        m.addMixIn(Animal.class, TypeWithWrapper.class);\n         String JSON = \"{\\\".TestTypedDeserialization$Dog\\\" : \"\n             +asJSONObjectValueString(m, \"name\", \"Scooby\", \"boneCount\", \"6\")+\" }\";\n         Animal a = m.readValue(JSON, Animal.class);\n     public void testTypeAsArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Animal.class, TypeWithArray.class);\n+        m.addMixIn(Animal.class, TypeWithArray.class);\n         // hmmh. Not good idea to rely on exact output, order may change. But...\n         String JSON = \"[\\\"\"+Dog.class.getName()+\"\\\", \"\n             +asJSONObjectValueString(m, \"name\", \"Martti\", \"boneCount\", \"11\")+\" ]\";\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n     public void testTypeAsWrapper() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Animal.class, TypeWithWrapper.class);\n+        m.addMixIn(Animal.class, TypeWithWrapper.class);\n         Map<String,Object> result = writeAndMap(m, new Cat(\"Venla\", \"black\"));\n         // should get a wrapper; keyed by minimal class name (\"Cat\" here)\n         assertEquals(1, result.size());\n     public void testTypeAsArray() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Animal.class, TypeWithArray.class);\n+        m.addMixIn(Animal.class, TypeWithArray.class);\n         // hmmh. Not good idea to rely on exact output, order may change. But...\n         Map<String,Object> result = writeAndMap(m, new AnimalWrapper(new Dog(\"Amadeus\", 7)));\n         // First level, wrapper\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestVisibleTypeId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestVisibleTypeId.java\n package com.fasterxml.jackson.databind.jsontype;\n \n-import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n-import com.fasterxml.jackson.annotation.JsonSubTypes;\n-import com.fasterxml.jackson.annotation.JsonTypeId;\n-import com.fasterxml.jackson.annotation.JsonTypeInfo;\n-import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n import com.fasterxml.jackson.databind.*;\n \n /**\n         public void setType(String t) { type = t; }\n     }\n \n-    // as external id, bit trickier\n-    static class ExternalIdWrapper {\n-        @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.EXTERNAL_PROPERTY,\n-                property=\"type\", visible=true)\n-        public ExternalIdBean bean = new ExternalIdBean();\n-    }\n-    \n     @JsonTypeName(\"ExternalType\")\n     static class ExternalIdBean {\n         public int a = 2;\n         public String getName() { return \"bob\"; }\n         \n         public int age = 41;\n+    }\n+\n+    // [databind#408]\n+    static class ExternalBeanWithId\n+    {\n+        protected String _type;\n+        \n+        @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property=\"type\", visible=true)\n+        public ValueBean bean;\n+\n+        public ExternalBeanWithId() { }\n+        public ExternalBeanWithId(int v) {\n+            bean = new ValueBean(v);\n+        }\n+\n+        public void setType(String t) {\n+            _type = t;\n+        }\n+    }\n+\n+    @JsonTypeName(\"vbean\")\n+    static class ValueBean {\n+        public int value;\n+        \n+        public ValueBean() { }\n+        public ValueBean(int v) { value = v; }\n     }\n     \n     /*\n         assertEquals(\"ObjectType\", result.type);\n     }\n \n-    public void testVisibleWithExternalId() throws Exception\n-    {\n-        String json = MAPPER.writeValueAsString(new ExternalIdWrapper());\n-        // but then expect to read it back\n-        ExternalIdWrapper result = MAPPER.readValue(json, ExternalIdWrapper.class);\n-        assertEquals(\"ExternalType\", result.bean.type);\n-        assertEquals(2, result.bean.a);\n-    }\n-\n-    // [JACKSON-762]\n-\n     public void testTypeIdFromProperty() throws Exception\n     {\n         assertEquals(\"{\\\"type\\\":\\\"SomeType\\\",\\\"a\\\":3}\",\n         I263Base result = MAPPER.readValue(\"{\\\"age\\\":19,\\\"name\\\":\\\"bob\\\"}\", I263Base.class);\n         assertTrue(result instanceof I263Impl);\n         assertEquals(19, ((I263Impl) result).age);\n+    }\n+\n+    // [databind#408]\n+    /* NOTE: Handling changed between 2.4 and 2.5; earlier, type id was 'injected'\n+     *  inside POJO; but with 2.5 this was fixed so it would remain outside, similar\n+     *  to how JSON structure is.\n+     */\n+    public void testVisibleTypeId408() throws Exception\n+    {\n+        String json = MAPPER.writeValueAsString(new ExternalBeanWithId(3));\n+        ExternalBeanWithId result = MAPPER.readValue(json, ExternalBeanWithId.class);\n+        assertNotNull(result);\n+        assertNotNull(result.bean);\n+        assertEquals(3, result.bean.value);\n+        assertEquals(\"vbean\", result._type);\n     }\n     \n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n     {\n         Dog dog = new Dog(\"Fluffy\", 3);\n         ContainerWithGetter<Animal> c2 = new ContainerWithGetter<Animal>(dog);\n-        String json = MAPPER.writerWithType(MAPPER.getTypeFactory().constructParametricType(ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);\n+        String json = MAPPER.writerWithType(MAPPER.getTypeFactory().constructParametrizedType(ContainerWithGetter.class, ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);\n         if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n             fail(\"polymorphic type not kept, result == \"+json+\"; should contain 'object-type':'...'\");\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForClass.java\n          * use field\n          */\n         m = new ObjectMapper();\n-        m.addMixInAnnotations(LeafClass.class, MixIn.class);\n+        m.addMixIn(LeafClass.class, MixIn.class);\n         result = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\", LeafClass.class);\n         assertEquals(\"value\", result.a);\n     }\n     public void testClassMixInsMidLevel() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        m.addMixIn(BaseClass.class, MixIn.class);\n         {\n             BaseClass result = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\", BaseClass.class);\n             assertEquals(\"value\", result.a);\n     public void testClassMixInsForObjectClass() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(Object.class, MixIn.class);\n+        m.addMixIn(Object.class, MixIn.class);\n         // will be seen for BaseClass\n         {\n             BaseClass result = m.readValue(\"{\\\"a\\\":\\\"\\\"}\", BaseClass.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForCreators.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForCreators.java\n     public void testForConstructor() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(BaseClassWithPrivateCtor.class, MixInForPrivate.class);\n+        m.addMixIn(BaseClassWithPrivateCtor.class, MixInForPrivate.class);\n         BaseClassWithPrivateCtor result = m.readValue(\"\\\"?\\\"\", BaseClassWithPrivateCtor.class);\n         assertEquals(\"?...\", result._a);\n     }\n \n         // Then with simple mix-in: should change to use the factory method\n         m = new ObjectMapper();\n-        m.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        m.addMixIn(BaseClass.class, MixIn.class);\n         result = m.readValue(\"\\\"string\\\"\", BaseClass.class);\n         assertEquals(\"stringX\", result._a);\n     }\n     public void testFactoryMixIn() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(StringWrapper.class, StringWrapperMixIn.class);\n+        m.addMixIn(StringWrapper.class, StringWrapperMixIn.class);\n         StringWrapper result = m.readValue(\"\\\"a\\\"\", StringWrapper.class);\n         assertEquals(\"a\", result._value);\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForMethods.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForMethods.java\n     public void testWithAnySetter() throws IOException\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        m.addMixIn(BaseClass.class, MixIn.class);\n         BaseClass result = m.readValue(\"{ \\\"a\\\" : 3, \\\"b\\\" : true }\", BaseClass.class);\n         assertNotNull(result);\n         assertEquals(2, result.values.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinInheritance.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinInheritance.java\n     public void testMixinFieldInheritance() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(Beano.class, BeanoMixinSub.class);\n+        mapper.addMixIn(Beano.class, BeanoMixinSub.class);\n         Map<String,Object> result;\n         result = writeAndMap(mapper, new Beano());\n         assertEquals(2, result.size());\n     public void testMixinMethodInheritance() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(Beano2.class, BeanoMixinSub2.class);\n+        mapper.addMixIn(Beano2.class, BeanoMixinSub2.class);\n         Map<String,Object> result;\n         result = writeAndMap(mapper, new Beano2());\n         assertEquals(2, result.size());\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForClass.java\n \n         // then with top-level override\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(LeafClass.class, MixIn.class);\n+        mapper.addMixIn(LeafClass.class, MixIn.class);\n         result = writeAndMap(mapper, new LeafClass(\"abc\"));\n         assertEquals(2, result.size());\n         assertEquals(\"abc\", result.get(\"a\"));\n \n         // mid-level override; should not have any effect\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixIn(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, new LeafClass(\"abc\"));\n         assertEquals(1, result.size());\n         assertEquals(\"abc\", result.get(\"a\"));\n \n         // then with working mid-level override, which effectively suppresses 'a'\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(BaseClass.class, MixInAutoDetect.class);\n+        mapper.addMixIn(BaseClass.class, MixInAutoDetect.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(1, result.size());\n         assertEquals(\"c2\", result.get(\"c\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForFields.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForFields.java\n \n         // and then with simple mix-in\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixIn(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(2, result.size());\n         assertEquals(\"1\", result.get(\"a\"));\n         HashMap<Class<?>,Class<?>> mixins = new HashMap<Class<?>,Class<?>>();\n         mixins.put(SubClass.class, MixIn.class);\n         mixins.put(BaseClass.class, MixIn2.class);\n-        mapper.setMixInAnnotations(mixins);\n+        mapper.setMixIns(mixins);\n \n         Map<String,Object> result;\n         result = writeAndMap(mapper, new SubClass(\"1\", \"2\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForMethods.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForMethods.java\n \n         // then with leaf-level mix-in\n         mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixIn(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(2, result.size());\n         assertEquals(\"b2\", result.get(\"b2\"));\n         Map<String,Object> result;\n         LeafClass bean = new LeafClass(\"XXX\", \"b2\");\n \n-        mapper.addMixInAnnotations(BaseClass.class, MixIn.class);\n+        mapper.addMixIn(BaseClass.class, MixIn.class);\n         result = writeAndMap(mapper, bean);\n         assertEquals(1, result.size());\n         assertEquals(\"XXX\", result.get(\"a\"));\n     public void testIntermediateMixin2() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(EmptyBean.class, MixInForSimple.class);\n+        mapper.addMixIn(EmptyBean.class, MixInForSimple.class);\n         Map<String,Object> result = writeAndMap(mapper, new SimpleBean());\n         assertEquals(1, result.size());\n         assertEquals(Integer.valueOf(42), result.get(\"x\"));\n     public void testObjectMixin() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(Object.class, ObjectMixIn.class);\n+        mapper.addMixIn(Object.class, ObjectMixIn.class);\n \n         // First, with our bean...\n         Map<String,Object> result = writeAndMap(mapper, new BaseClass(\"a\", \"b\"));\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n \n         // Property SerializationConfig.SerializationFeature.DEFAULT_VIEW_INCLUSION set to false\n         mapper.configure(MapperFeature.DEFAULT_VIEW_INCLUSION, Boolean.FALSE);\n-        mapper.addMixInAnnotations(A.class, AMixInAnnotation.class);\n+        mapper.addMixIn(A.class, AMixInAnnotation.class);\n         String json = mapper.writerWithView(AView.class).writeValueAsString(a);\n \n         assertTrue(json.indexOf(\"\\\"name\\\"\") > 0);\n       sourceMixins.put( SimpleTestData.class, TestDataJAXBMixin.class );\n       sourceMixins.put( ComplexTestData.class, TestComplexDataJAXBMixin.class );\n       \n-      objectMapper.setMixInAnnotations(sourceMixins);\n+      objectMapper.setMixIns(sourceMixins);\n       return objectMapper;\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifierNameResolution.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifierNameResolution.java\n package com.fasterxml.jackson.databind.module;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.type.TypeBindings;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.type.TypeModifier;\n-import com.fasterxml.jackson.test.BaseTest;\n \n import java.lang.reflect.Type;\n \n-public class TestTypeModifierNameResolution extends BaseTest {\n-\n+public class TestTypeModifierNameResolution extends BaseMapTest\n+{\n \tinterface MyType {\n \t\tString getData();\n \t\tvoid setData(String data);\n \t{\n \t\tObjectMapper mapper = new ObjectMapper();\n \t\tmapper.setTypeFactory(mapper.getTypeFactory().withModifier(new CustomTypeModifier()));\n-\t\tmapper.addMixInAnnotations(MyType.class, Mixin.class);\n+\t\tmapper.addMixIn(MyType.class, Mixin.class);\n \n \t\tMyType obj = new MyTypeImpl();\n \t\tobj.setData(\"something\");\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n     {\n         String JSON = \"{\\\"leaf\\\":{\\\"value\\\":13}}\";\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.addMixInAnnotations(Leaf.class, LeafMixIn.class);\n+        mapper.addMixIn(Leaf.class, LeafMixIn.class);\n         JsonNode root = mapper.readTree(JSON);\n         // Ok, try converting to bean using two mechanisms\n         Root r1 = mapper.treeToValue(root, Root.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestTreeMapperSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeMapperSerializer.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.test.BaseTest;\n \n /**\n  * This unit test suite tries to verify that the trees ObjectMapper\n  * constructs can be serialized properly.\n  */\n public class TestTreeMapperSerializer\n-    extends BaseTest\n+    extends BaseMapTest\n {\n     final static String FIELD1 = \"first\";\n     final static String FIELD2 = \"Second?\";\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationInheritance.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationInheritance.java\n package com.fasterxml.jackson.databind.ser;\n \n-import java.io.*;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n  * bean serialization.\n  */\n public class TestAnnotationInheritance\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends BaseMapTest\n {\n     /*\n     /**********************************************************\n         assertEquals(Integer.valueOf(1), result.get(\"width\"));\n         assertEquals(Integer.valueOf(2), result.get(\"length\"));\n     }\n-\n-    /*\n-    //////////////////////////////////////////////\n-    // Helper methods\n-    //////////////////////////////////////////////\n-     */\n-\n-    @SuppressWarnings(\"unchecked\")\n-\tprivate Map<String,Object> writeAndMap(ObjectMapper m, Object value)\n-        throws IOException\n-    {\n-        StringWriter sw = new StringWriter();\n-        m.writeValue(sw, value);\n-        return (Map<String,Object>) m.readValue(sw.toString(), Object.class);\n-    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnyGetter.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnyGetter.java\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializationFeature;\n \n-public class TestAnyGetter\n-    extends BaseMapTest\n+public class TestAnyGetter extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper bean classes\n-    /**********************************************************\n-     */\n-\n     static class Bean\n     {\n         final static Map<String,Boolean> extra = new HashMap<String,Boolean>();\n         }\n     }\n \n+    static class MapAsAny\n+    {\n+        protected Map<String,Object> stuff = new LinkedHashMap<String,Object>();\n+        \n+        @JsonAnyGetter\n+        public Map<String,Object> any() {\n+            return stuff;\n+        }\n+\n+        public void add(String key, Object value) {\n+            stuff.put(key, value);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Test cases\n     /**********************************************************\n      */\n \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n     public void testSimpleJsonValue() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        String json = serializeAsString(m, new Bean());\n-        Map<?,?> map = m.readValue(json, Map.class);\n+        String json = MAPPER.writeValueAsString(new Bean());\n+        Map<?,?> map = MAPPER.readValue(json, Map.class);\n         assertEquals(2, map.size());\n         assertEquals(Integer.valueOf(3), map.get(\"x\"));\n         assertEquals(Boolean.TRUE, map.get(\"a\"));\n         json = serializeAsString(m, new AnyOnlyBean());\n         assertEquals(\"{\\\"a\\\":3}\", json);\n     }\n+\n+    // Trying to repro [databind#577]\n+    public void testAnyWithNull() throws Exception\n+    {\n+        MapAsAny input = new MapAsAny();\n+        input.add(\"bar\", null);\n+        assertEquals(aposToQuotes(\"{'bar':null}\"),\n+                MAPPER.writeValueAsString(input));\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n import com.fasterxml.jackson.databind.introspect.POJOPropertyBuilder;\n @SuppressWarnings(\"serial\")\n public class TestBeanSerializer extends BaseMapTest\n {\n-    /*\n-    /********************************************************\n-    /* Helper types\n-    /********************************************************\n-     */\n-\n-    static class ModuleImpl extends SimpleModule\n+    static class SerializerModifierModule extends SimpleModule\n     {\n         protected BeanSerializerModifier modifier;\n         \n-        public ModuleImpl(BeanSerializerModifier modifier)\n+        public SerializerModifierModule(BeanSerializerModifier modifier)\n         {\n             super(\"test\", Version.unknownVersion());\n             this.modifier = modifier;\n         }\n     }\n \n+    // [Issue#539]: use post-modifier\n+    static class EmptyBeanModifier539 extends BeanSerializerModifier\n+    {\n+        @Override\n+        public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\n+                BeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n+        {\n+            return beanProperties;\n+        }\n+        \n+        @Override\n+        public JsonSerializer<?> modifySerializer(SerializationConfig config,\n+                BeanDescription beanDesc, JsonSerializer<?> serializer) {\n+            return new BogusBeanSerializer(42);\n+        }\n+    }\n     // [Issue#120], arrays, collections, maps\n     \n     static class ArraySerializerModifier extends BeanSerializerModifier {\n     public void testPropertyRemoval() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new RemovingModifier(\"a\")));\n+        mapper.registerModule(new SerializerModifierModule(new RemovingModifier(\"a\")));\n         Bean bean = new Bean();\n         assertEquals(\"{\\\"b\\\":\\\"b\\\"}\", mapper.writeValueAsString(bean));\n     }\n     public void testPropertyReorder() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new ReorderingModifier()));\n+        mapper.registerModule(new SerializerModifierModule(new ReorderingModifier()));\n         Bean bean = new Bean();\n         assertEquals(\"{\\\"a\\\":\\\"a\\\",\\\"b\\\":\\\"b\\\"}\", mapper.writeValueAsString(bean));\n     }\n     public void testBuilderReplacement() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new BuilderModifier(new BogusBeanSerializer(17))));\n+        mapper.registerModule(new SerializerModifierModule(new BuilderModifier(new BogusBeanSerializer(17))));\n         Bean bean = new Bean();\n         assertEquals(\"17\", mapper.writeValueAsString(bean));\n     }    \n     public void testSerializerReplacement() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        mapper.registerModule(new ModuleImpl(new ReplacingModifier(new BogusBeanSerializer(123))));\n+        mapper.registerModule(new SerializerModifierModule(new ReplacingModifier(new BogusBeanSerializer(123))));\n         Bean bean = new Bean();\n         assertEquals(\"123\", mapper.writeValueAsString(bean));\n     }\n         assertEquals(\"{\\\"bogus\\\":\\\"foo\\\"}\", json);\n     }\n \n+    // [Issue#539]\n+    public void testEmptyBean539() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new SimpleModule(\"test\", Version.unknownVersion()) {\n+            @Override\n+            public void setupModule(SetupContext context)\n+            {\n+                super.setupModule(context);\n+                context.addBeanSerializerModifier(new EmptyBeanModifier539());\n+            }\n+        });\n+        String json = mapper.writeValueAsString(new EmptyBean());\n+        assertEquals(\"42\", json);\n+    }\n+    \n     // [Issue#121]\n \n     public void testModifyArraySerializer() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n     public void testCustomization() throws Exception\n     {\n         ObjectMapper objectMapper = new ObjectMapper();\n-        objectMapper.addMixInAnnotations(Element.class, ElementMixin.class);\n+        objectMapper.addMixIn(Element.class, ElementMixin.class);\n         Element element = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument().createElement(\"el\");\n         StringWriter sw = new StringWriter();\n         objectMapper.writeValue(sw, element);\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n \n         // Including class annotation through mix-ins\n         ObjectMapper m2 = new ObjectMapper();\n-        m2.addMixInAnnotations(Empty.class, EmptyWithAnno.class);\n+        m2.addMixIn(Empty.class, EmptyWithAnno.class);\n         assertEquals(\"{}\", m2.writeValueAsString(new Empty()));\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.annotation.JsonValue;\n-\n import com.fasterxml.jackson.core.*;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n         public OK text = OK.V1;\n     }\n     \n-    @JsonFormat(shape=JsonFormat.Shape.ARRAY) // not supported as of now\n-    static enum BrokenPoNum\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY) // alias for 'number', as of 2.5\n+    static enum PoAsArray\n     {\n         A, B;\n     }\n                 SerializerProvider provider) throws IOException {\n             jgen.writeString(value.name().toLowerCase());\n         }\n+    }\n+\n+    // for [databind#572]\n+    static class PoOverrideAsString\n+    {\n+        @JsonFormat(shape=Shape.STRING)\n+        public PoNUM value = PoNUM.B;\n+    }\n+\n+    static class PoOverrideAsNumber\n+    {\n+        @JsonFormat(shape=Shape.NUMBER)\n+        public PoNUM value = PoNUM.B;\n     }\n     \n     /*\n     {\n         // can't share, as new mix-ins are added\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(TestEnum.class, ToStringMixin.class);\n+        m.addMixIn(TestEnum.class, ToStringMixin.class);\n         assertEquals(\"\\\"b\\\"\", m.writeValueAsString(TestEnum.B));\n     }\n \n     public void testEnumAsIndexViaAnnotations() throws Exception {\n         assertEquals(\"{\\\"text\\\":0}\", mapper.writeValueAsString(new PoNUMContainer()));\n     }\n-    \n+\n+    // As of 2.5, use of Shape.ARRAY is legal alias for \"write as number\"\n     public void testEnumAsObjectBroken() throws Exception\n     {\n-        try {\n-            String json = mapper.writeValueAsString(BrokenPoNum.A);\n-            fail(\"Should not have succeeded, produced: \"+json);\n-        } catch (JsonMappingException e) {\n-            verifyException(e, \"Unsupported serialization shape\");\n-        }\n+        assertEquals(\"0\", mapper.writeValueAsString(PoAsArray.A));\n     }\n     \n     // [Issue#227]\n         module.addSerializer(Enum.class, new LowerCasingEnumSerializer());\n         m.registerModule(module);\n         assertEquals(quote(\"b\"), m.writeValueAsString(TestEnum.B));\n+    }\n+\n+    // [databind#572]\n+    public void testOverrideEnumAsString() throws Exception {\n+        assertEquals(\"{\\\"value\\\":\\\"B\\\"}\", mapper.writeValueAsString(new PoOverrideAsString()));\n+    }\n+\n+    public void testOverrideEnumAsNumber() throws Exception {\n+        assertEquals(\"{\\\"value\\\":1}\", mapper.writeValueAsString(new PoOverrideAsNumber()));\n     }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestExceptionHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestExceptionHandling.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n-import com.fasterxml.jackson.test.BaseTest;\n import com.fasterxml.jackson.test.BrokenStringWriter;\n \n /**\n  * with Object serialization.\n  */\n public class TestExceptionHandling\n-    extends BaseTest\n+    extends BaseMapTest\n {\n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n import java.util.*;\n import java.util.concurrent.ConcurrentHashMap;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n public class TestMapSerialization\n     extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n     /**\n      * Class needed for testing [JACKSON-220]\n      */\n         }\n     }\n \n+    // [Databind#565]: Support ser/deser of Map.Entry\n+    static class StringIntMapEntry implements Map.Entry<String,Integer> {\n+        public final String k;\n+        public final Integer v;\n+        public StringIntMapEntry(String k, Integer v) {\n+            this.k = k;\n+            this.v = v;\n+        }\n+\n+        @Override\n+        public String getKey() {\n+            return k;\n+        }\n+\n+        @Override\n+        public Integer getValue() {\n+            return v;\n+        }\n+\n+        @Override\n+        public Integer setValue(Integer value) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    // [databind#527]\n+    static class NoNullValuesMapContainer {\n+        @JsonInclude(content=JsonInclude.Include.NON_NULL)\n+        public Map<String,String> stuff = new LinkedHashMap<String,String>();\n+        \n+        public NoNullValuesMapContainer add(String key, String value) {\n+            stuff.put(key, value);\n+            return this;\n+        }\n+    }\n+\n+    // [databind#527]\n+    @JsonInclude(content=JsonInclude.Include.NON_NULL)\n+    static class NoNullsStringMap extends LinkedHashMap<String,String> {\n+        public NoNullsStringMap add(String key, String value) {\n+            put(key, value);\n+            return this;\n+        }\n+    }\n+\n+    @JsonInclude(content=JsonInclude.Include.NON_EMPTY)\n+    static class NoEmptyStringsMap extends LinkedHashMap<String,String> {\n+        public NoEmptyStringsMap add(String key, String value) {\n+            put(key, value);\n+            return this;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n     /**********************************************************\n      */\n \n-    final ObjectMapper MAPPER = objectMapper();\n+    final private ObjectMapper MAPPER = objectMapper();\n \n     public void testUsingObjectWriter() throws IOException\n     {\n         assertEquals(\"{\\\"a\\\":6,\\\"b\\\":3}\", m.writer(SerializationFeature.ORDER_MAP_ENTRIES_BY_KEYS).writeValueAsString(map));\n     }\n \n-    // [#335[\n+    // [Databind#335]\n     public void testOrderByKeyViaProperty() throws IOException\n     {\n         MapOrderingBean input = new MapOrderingBean(\"c\", \"b\", \"a\");\n         String json = MAPPER.writeValueAsString(input);\n         assertEquals(aposToQuotes(\"{'map':{'a':3,'b':2,'c':1}}\"), json);\n     }        \n+\n+    // [Databind#565]\n+    public void testEnumMapEntry() throws IOException\n+    {\n+        StringIntMapEntry input = new StringIntMapEntry(\"answer\", 42);\n+        String json = MAPPER.writeValueAsString(input);\n+        assertEquals(aposToQuotes(\"{'answer':42}\"), json);\n+\n+        StringIntMapEntry[] array = new StringIntMapEntry[] { input };\n+        json = MAPPER.writeValueAsString(array);\n+        assertEquals(aposToQuotes(\"[{'answer':42}]\"), json);\n+    }        \n+\n+    // [databind#527]\n+    public void testNonNullValueMap() throws IOException\n+    {\n+        String json = MAPPER.writeValueAsString(new NoNullsStringMap()\n+            .add(\"a\", \"foo\")\n+            .add(\"b\", null)\n+            .add(\"c\", \"bar\"));\n+        assertEquals(aposToQuotes(\"{'a':'foo','c':'bar'}\"), json);\n+    }\n+\n+    // [databind#527]\n+    public void testNonEmptyValueMap() throws IOException\n+    {\n+        String json = MAPPER.writeValueAsString(new NoEmptyStringsMap()\n+            .add(\"a\", \"foo\")\n+            .add(\"b\", \"bar\")\n+            .add(\"c\", \"\"));\n+        assertEquals(aposToQuotes(\"{'a':'foo','b':'bar'}\"), json);\n+    }\n+    \n+    // [databind#527]\n+    public void testNonNullValueMapViaProp() throws IOException\n+    {\n+        String json = MAPPER.writeValueAsString(new NoNullValuesMapContainer()\n+            .add(\"a\", \"foo\")\n+            .add(\"b\", null)\n+            .add(\"c\", \"bar\"));\n+        assertEquals(aposToQuotes(\"{'stuff':{'a':'foo','c':'bar'}}\"), json);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n     public void testOrderWithMixins() throws Exception\n     {\n         ObjectMapper m = new ObjectMapper();\n-        m.addMixInAnnotations(BeanWithOrder.class, OrderMixIn.class);\n+        m.addMixIn(BeanWithOrder.class, OrderMixIn.class);\n         assertEquals(\"{\\\"b\\\":2,\\\"a\\\":1,\\\"c\\\":3,\\\"d\\\":4}\",\n                 serializeAsString(m, new BeanWithOrder(1, 2, 3, 4)));\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectIdDeserialization.java\n             return new PoolResolver(pool);\n         }\n     }\n+    \n+    /*\n+    /*****************************************************\n+    /* Unit tests, external id deserialization\n+    /*****************************************************\n+     */\n \n     private final ObjectMapper mapper = new ObjectMapper();\n     \n-    /*\n-    /*****************************************************\n-    /* Unit tests, external id deserialization\n-    /*****************************************************\n-     */\n-\n     private final static String EXP_SIMPLE_INT_CLASS = \"{\\\"id\\\":1,\\\"value\\\":13,\\\"next\\\":1}\";\n \n     public void testSimpleDeserializationClass() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArray.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArray.java\n import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n \n-import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n \n         String json = mapper.writeValueAsString(new SingleBean());\n         assertEquals(\"\\\"foo\\\"\", json);\n     }\n+\n+    public void testBeanAsArrayUnwrapped() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n+        SingleBean result = mapper.readValue(\"[\\\"foobar\\\"]\", SingleBean.class);\n+        assertNotNull(result);\n+        assertEquals(\"foobar\", result.name);\n+    }\n     \n     /*\n     /*****************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayWithBuilder.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArrayWithBuilder.java\n     {\n         public int x, y;\n         \n-        @SuppressWarnings(\"hiding\")\n-        public SimpleBuilderXY withX(int x) {\n-            this.x = x;\n+        public SimpleBuilderXY withX(int x0) {\n+            this.x = x0;\n             return this;\n         }\n \n-        @SuppressWarnings(\"hiding\")\n-        public SimpleBuilderXY withY(int y) {\n-            this.y = y;\n+        public SimpleBuilderXY withY(int y0) {\n+            this.y = y0;\n             return this;\n         }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java\n \n import java.util.*;\n \n+import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.JavaType;\n \n /**\n  * some degree\n  */\n public class TestJavaType\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends BaseMapTest\n {\n     static class BaseType { }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/type/TestTypeBindings.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeBindings.java\n \n import java.util.*;\n \n+import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.JavaType;\n \n /**\n  * implemented by {@link TypeBindings} class.\n  */\n public class TestTypeBindings\n-    extends com.fasterxml.jackson.test.BaseTest\n+    extends BaseMapTest\n {    \n     static class AbstractType<A,B> { }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java\n import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.type.CollectionType;\n-import com.fasterxml.jackson.databind.type.HierarchicType;\n-import com.fasterxml.jackson.databind.type.MapType;\n-import com.fasterxml.jackson.databind.type.SimpleType;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n-import com.fasterxml.jackson.test.BaseTest;\n+\n+import com.fasterxml.jackson.databind.*;\n \n /**\n  * Simple tests to verify that the {@link TypeFactory} constructs\n  * type information as expected.\n  */\n public class TestTypeFactory\n-    extends BaseTest\n+    extends BaseMapTest\n {    \n     /*\n     /**********************************************************\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n         // first, simple class based\n-        JavaType t = tf.constructParametricType(ArrayList.class, String.class); // ArrayList<String>\n+        JavaType t = tf.constructParametrizedType(ArrayList.class, Collection.class, String.class); // ArrayList<String>\n         assertEquals(CollectionType.class, t.getClass());\n         JavaType strC = tf.constructType(String.class);\n         assertEquals(1, t.containedTypeCount());\n         assertNull(t.containedType(1));\n \n         // Then using JavaType\n-        JavaType t2 = tf.constructParametricType(Map.class, strC, t); // Map<String,ArrayList<String>>\n+        JavaType t2 = tf.constructParametrizedType(Map.class, Map.class, strC, t); // Map<String,ArrayList<String>>\n         // should actually produce a MapType\n         assertEquals(MapType.class, t2.getClass());\n         assertEquals(2, t2.containedTypeCount());\n         assertNull(t2.containedType(2));\n \n         // and then custom generic type as well\n-        JavaType custom = tf.constructParametricType(SingleArgGeneric.class, String.class);\n+        JavaType custom = tf.constructParametrizedType(SingleArgGeneric.class, SingleArgGeneric.class,\n+                String.class);\n         assertEquals(SimpleType.class, custom.getClass());\n         assertEquals(1, custom.containedTypeCount());\n         assertEquals(strC, custom.containedType(0));\n         // And finally, ensure that we can't create invalid combinations\n         try {\n             // Maps must take 2 type parameters, not just one\n-            tf.constructParametricType(Map.class, strC);\n+            tf.constructParametrizedType(Map.class, Map.class, strC);\n         } catch (IllegalArgumentException e) {\n             verifyException(e, \"Need exactly 2 parameter types for Map types\");\n         }\n \n         try {\n             // Type only accepts one type param\n-            tf.constructParametricType(SingleArgGeneric.class, strC, strC);\n+            tf.constructParametrizedType(SingleArgGeneric.class, SingleArgGeneric.class, strC, strC);\n         } catch (IllegalArgumentException e) {\n             verifyException(e, \"expected 1 parameters, was given 2\");\n         }\n         assertNull(sup2.getSuperType());\n     }\n \n+    private int _countSupers(HierarchicType t)\n+    {\n+        int depth = 0;\n+        for (HierarchicType sup = t.getSuperType(); sup != null; sup = sup.getSuperType()) {\n+            ++depth;\n+        }\n+        return depth;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests: map/collection type parameter resolution\n+    /**********************************************************\n+     */\n+\n+    public void testMapTypesSimple()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(new TypeReference<Map<String,Boolean>>() { });\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Boolean.class), mapType.getContentType());\n+    }\n+\n+    public void testMapTypesRaw()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(HashMap.class);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(Object.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Object.class), mapType.getContentType());        \n+    }\n+\n+    public void testMapTypesAdvanced()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(MyMap.class);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n+\n+        type = tf.constructType(MapInterface.class);\n+        mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n+\n+        type = tf.constructType(MyStringIntMap.class);\n+        mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n+    }\n+\n+    /**\n+     * Specific test to verify that complicate name mangling schemes\n+     * do not fool type resolver\n+     */\n+    public void testMapTypesSneaky()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(IntLongMap.class);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n+    }    \n+    \n+    /**\n+     * Plus sneaky types may be found via introspection as well.\n+     */\n+    public void testSneakyFieldTypes() throws Exception\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        Field field = SneakyBean.class.getDeclaredField(\"intMap\");\n+        JavaType type = tf.constructType(field.getGenericType());\n+        assertTrue(type instanceof MapType);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n+\n+        field = SneakyBean.class.getDeclaredField(\"longList\");\n+        type = tf.constructType(field.getGenericType());\n+        assertTrue(type instanceof CollectionType);\n+        CollectionType collectionType = (CollectionType) type;\n+        assertEquals(tf.constructType(Long.class), collectionType.getContentType());\n+    }    \n+    \n+    /**\n+     * Looks like type handling actually differs for properties, too.\n+     */\n+    public void testSneakyBeanProperties() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringLongMapBean bean = mapper.readValue(\"{\\\"value\\\":{\\\"a\\\":123}}\", StringLongMapBean.class);\n+        assertNotNull(bean);\n+        Map<String,Long> map = bean.value;\n+        assertEquals(1, map.size());\n+        assertEquals(Long.valueOf(123), map.get(\"a\"));\n+\n+        StringListBean bean2 = mapper.readValue(\"{\\\"value\\\":[\\\"...\\\"]}\", StringListBean.class);\n+        assertNotNull(bean2);\n+        List<String> list = bean2.value;\n+        assertSame(GenericList.class, list.getClass());\n+        assertEquals(1, list.size());\n+        assertEquals(\"...\", list.get(0));\n+    }\n+\n+    public void testSneakySelfRefs() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new SneakyBean2());\n+        assertEquals(\"{\\\"foobar\\\":null}\", json);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests: handling of specific JDK types\n+    /**********************************************************\n+     */\n+\n     public void testAtomicArrayRefParameterDetection()\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n         assertNull(sub.getSuperType());\n     }\n \n-    private int _countSupers(HierarchicType t)\n-    {\n-        int depth = 0;\n-        for (HierarchicType sup = t.getSuperType(); sup != null; sup = sup.getSuperType()) {\n-            ++depth;\n-        }\n-        return depth;\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Unit tests: map/collection type parameter resolution\n-    /**********************************************************\n-     */\n-\n-    public void testMapTypesSimple()\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        JavaType type = tf.constructType(new TypeReference<Map<String,Boolean>>() { });\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Boolean.class), mapType.getContentType());\n-    }\n-\n-    public void testMapTypesRaw()\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        JavaType type = tf.constructType(HashMap.class);\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(Object.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Object.class), mapType.getContentType());        \n-    }\n-\n-    public void testMapTypesAdvanced()\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        JavaType type = tf.constructType(MyMap.class);\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n-\n-        type = tf.constructType(MapInterface.class);\n-        mapType = (MapType) type;\n-        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n-\n-        type = tf.constructType(MyStringIntMap.class);\n-        mapType = (MapType) type;\n-        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n-    }\n-\n-    /**\n-     * Specific test to verify that complicate name mangling schemes\n-     * do not fool type resolver\n-     */\n-    public void testMapTypesSneaky()\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        JavaType type = tf.constructType(IntLongMap.class);\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n-    }    \n-    \n-    /**\n-     * Plus sneaky types may be found via introspection as well.\n-     */\n-    public void testSneakyFieldTypes() throws Exception\n-    {\n-        TypeFactory tf = TypeFactory.defaultInstance();\n-        Field field = SneakyBean.class.getDeclaredField(\"intMap\");\n-        JavaType type = tf.constructType(field.getGenericType());\n-        assertTrue(type instanceof MapType);\n-        MapType mapType = (MapType) type;\n-        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n-        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n-\n-        field = SneakyBean.class.getDeclaredField(\"longList\");\n-        type = tf.constructType(field.getGenericType());\n-        assertTrue(type instanceof CollectionType);\n-        CollectionType collectionType = (CollectionType) type;\n-        assertEquals(tf.constructType(Long.class), collectionType.getContentType());\n-    }    \n-    \n-    /**\n-     * Looks like type handling actually differs for properties, too.\n-     */\n-    public void testSneakyBeanProperties() throws Exception\n-    {\n-        ObjectMapper mapper = new ObjectMapper();\n-        StringLongMapBean bean = mapper.readValue(\"{\\\"value\\\":{\\\"a\\\":123}}\", StringLongMapBean.class);\n-        assertNotNull(bean);\n-        Map<String,Long> map = bean.value;\n-        assertEquals(1, map.size());\n-        assertEquals(Long.valueOf(123), map.get(\"a\"));\n-\n-        StringListBean bean2 = mapper.readValue(\"{\\\"value\\\":[\\\"...\\\"]}\", StringListBean.class);\n-        assertNotNull(bean2);\n-        List<String> list = bean2.value;\n-        assertSame(GenericList.class, list.getClass());\n-        assertEquals(1, list.size());\n-        assertEquals(\"...\", list.get(0));\n-    }\n-    \n     public void testAtomicArrayRefParameters()\n     {\n         TypeFactory tf = TypeFactory.defaultInstance();\n         assertEquals(tf.constructType(long[].class), params[0]);\n     }\n \n-    public void testSneakySelfRefs() throws Exception\n-    {\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(new SneakyBean2());\n-        assertEquals(\"{\\\"foobar\\\":null}\", json);\n-    }\n-\n+    static abstract class StringIntMapEntry implements Map.Entry<String,Integer> { }\n+    \n+    public void testMapEntryResolution()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType t = tf.constructType(StringIntMapEntry.class);\n+        assertTrue(t.hasGenericTypes());\n+        assertEquals(2, t.containedTypeCount());\n+        assertEquals(String.class, t.containedType(0).getRawClass());\n+        assertEquals(Integer.class, t.containedType(1).getRawClass());\n+        // NOTE: no key/content types, at least not as of 2.5\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Unit tests: construction of \"raw\" types\n--- a/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.type.TypeReference;\n-\n+import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.type.CollectionType;\n import com.fasterxml.jackson.databind.type.MapType;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n @SuppressWarnings(\"serial\")\n-public class TestTypeResolution extends com.fasterxml.jackson.test.BaseTest\n+public class TestTypeResolution extends BaseMapTest\n {\n     public static class LongValuedMap<K> extends HashMap<K, Long> { }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java\n package com.fasterxml.jackson.databind.util;\n \n-import java.util.*;\n+import java.text.ParseException;\n import java.text.ParsePosition;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.TimeZone;\n \n import com.fasterxml.jackson.databind.BaseMapTest;\n-import com.fasterxml.jackson.databind.util.ISO8601Utils;\n \n /**\n  * @see ISO8601Utils\n  */\n-public class ISO8601UtilsTest extends BaseMapTest\n-{\n+public class ISO8601UtilsTest extends BaseMapTest {\n     private Date date;\n+    private Date dateWithoutTime;\n     private Date dateZeroMillis;\n+    private Date dateZeroSecondAndMillis;\n \n     @Override\n-    public void setUp()\n-    {\n+    public void setUp() {\n         Calendar cal = new GregorianCalendar(2007, 8 - 1, 13, 19, 51, 23);\n         cal.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n         cal.set(Calendar.MILLISECOND, 789);\n         date = cal.getTime();\n         cal.set(Calendar.MILLISECOND, 0);\n         dateZeroMillis = cal.getTime();\n+        cal.set(Calendar.SECOND, 0);\n+        dateZeroSecondAndMillis = cal.getTime();\n+        \n+        cal = new GregorianCalendar(2007, 8 - 1, 13, 0, 0, 0);\n+        cal.set(Calendar.MILLISECOND, 0);\n+        cal.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+        dateWithoutTime = cal.getTime();\n+\n     }\n \n     public void testFormat() {\n         assertEquals(date, d);\n     }\n \n+    public void testParseShortDate() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"20070813T19:51:23.789Z\", new ParsePosition(0));\n+        assertEquals(date, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T19:51:23Z\", new ParsePosition(0));\n+        assertEquals(dateZeroMillis, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T21:51:23.789+02:00\", new ParsePosition(0));\n+        assertEquals(date, d);\n+    }\n+\n+    public void testParseShortTime() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"2007-08-13T195123.789Z\", new ParsePosition(0));\n+        assertEquals(date, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T195123Z\", new ParsePosition(0));\n+        assertEquals(dateZeroMillis, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T215123.789+02:00\", new ParsePosition(0));\n+        assertEquals(date, d);\n+    }\n+\n+    public void testParseShortDateTime() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"20070813T195123.789Z\", new ParsePosition(0));\n+        assertEquals(date, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T195123Z\", new ParsePosition(0));\n+        assertEquals(dateZeroMillis, d);\n+\n+        d = ISO8601Utils.parse(\"20070813T215123.789+02:00\", new ParsePosition(0));\n+        assertEquals(date, d);\n+    }\n+\n+    public void testParseWithoutTime() throws ParseException {\n+        Date d = ISO8601Utils.parse(\"2007-08-13Z\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+\n+        d = ISO8601Utils.parse(\"20070813Z\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13+00:00\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+\n+        d = ISO8601Utils.parse(\"20070813+00:00\", new ParsePosition(0));\n+        assertEquals(dateWithoutTime, d);\n+    }\n+\n+    public void testParseWithoutTimeAndTimeZoneMustFail() {\n+        try {\n+            ISO8601Utils.parse(\"2007-08-13\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+        try {\n+            ISO8601Utils.parse(\"20070813\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+        try {\n+            ISO8601Utils.parse(\"2007-08-13\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+        try {\n+            ISO8601Utils.parse(\"20070813\", new ParsePosition(0));\n+            fail();\n+        } catch (ParseException p) {\n+        }\n+    }\n+    \n+    \n+    public void testParseOptional() throws java.text.ParseException {\n+        Date d = ISO8601Utils.parse(\"2007-08-13T19:51Z\", new ParsePosition(0));\n+        assertEquals(dateZeroSecondAndMillis, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T1951Z\", new ParsePosition(0));\n+        assertEquals(dateZeroSecondAndMillis, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T21:51+02:00\", new ParsePosition(0));\n+        assertEquals(dateZeroSecondAndMillis, d);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/util/TestObjectBuffer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/TestObjectBuffer.java\n \n import java.util.*;\n \n-import com.fasterxml.jackson.test.BaseTest;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n \n public class TestObjectBuffer\n-    extends BaseTest\n+    extends BaseMapTest\n {\n     /**\n      * First a test that treats results as plain old Object[]\n--- a/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.util.JsonParserSequence;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n-public class TestTokenBuffer extends com.fasterxml.jackson.test.BaseTest\n+public class TestTokenBuffer extends BaseMapTest\n {\n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/failing/TestConvertingSerializer357.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestConvertingSerializer357.java\n     extends com.fasterxml.jackson.databind.BaseMapTest\n {\n     // [Issue#357]\n-    static class A { }\n+    static class Value { }\n \n-    static class B {\n-        @JsonSerialize(contentConverter = AToStringConverter.class)\n-        public List<A> list = Arrays.asList(new A());\n+    static class ListWrapper {\n+        @JsonSerialize(contentConverter = ValueToStringListConverter.class)\n+        public List<Value> list = Arrays.asList(new Value());\n     }\n \n-    static class AToStringConverter extends StdConverter<A, List<String>> {\n+    static class ValueToStringListConverter extends StdConverter<Value, List<String>> {\n         @Override\n-        public List<String> convert(A value) {\n+        public List<String> convert(Value value) {\n             return Arrays.asList(\"Hello world!\");\n         }\n     }\n \n     // [Issue#357]\n     public void testConverterForList357() throws Exception {\n-        String json = objectWriter().writeValueAsString(new B());\n+        String json = objectWriter().writeValueAsString(new ListWrapper());\n         assertEquals(\"{\\\"list\\\":[[\\\"Hello world!\\\"]]}\", json);\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId222.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestExternalTypeId222 extends BaseMapTest\n+{\n+\t@SuppressWarnings(\"unused\")\n+\tpublic void testTypes() throws IOException {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+        final Point _date = new Point(new Date());\n+        final Point _integer = new Point(12231321);\n+        final Point _boolean = new Point(Boolean.TRUE);\n+        final Point _long = new Point(1234L);\n+\n+        final Point _pojo = new Point(new Pojo(1));\n+        final String s_date = mapper.writeValueAsString(_date);\n+        final String s_integer = mapper.writeValueAsString(_integer);\n+\n+//System.err.println(\"Int -> \"+s_integer);   \n+    \n+        final String s_boolean = mapper.writeValueAsString(_boolean);\n+        final String s_long = mapper.writeValueAsString(_long);\n+        final String s_pojo = mapper.writeValueAsString(_pojo);\n+\n+        final Point d_date = mapper.readValue(s_date, Point.class);\n+        final Point d_long = mapper.readValue(s_long, Point.class);\n+        final Point d_pojo = mapper.readValue(s_pojo, Point.class);\n+        final Point d_integer = mapper.readValue(s_integer, Point.class);\n+        final Point d_boolean = mapper.readValue(s_boolean, Point.class);\n+    }\n+\n+    @JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY,\n+        getterVisibility = JsonAutoDetect.Visibility.NONE,\n+        setterVisibility = JsonAutoDetect.Visibility.NONE)\n+    static class Point {\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+        property = \"t\",\n+        visible = true,\n+        include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+        defaultImpl = String.class)\n+        @JsonSubTypes({\n+        @JsonSubTypes.Type(value = Date.class, name = \"date\"),\n+        @JsonSubTypes.Type(value = Integer.class, name = \"int\"),\n+        @JsonSubTypes.Type(value = Long.class, name = \"long\"),\n+        @JsonSubTypes.Type(value = Boolean.class, name = \"bool\"),\n+        @JsonSubTypes.Type(value = Pojo.class, name = \"pojo\"),\n+        @JsonSubTypes.Type(value = String.class, name = \"\")\n+        })\n+        private final Object v;\n+    \n+        @JsonCreator\n+        public Point(@JsonProperty(\"v\") Object v) {\n+            this.v = v;\n+        }\n+    \n+        public Object getValue() {\n+            return v;\n+        }\n+    }\n+     \n+\n+    static class Pojo {\n+        public final int p;\n+\n+        @JsonCreator\n+        private Pojo(@JsonProperty(\"p\") int p) {\n+            this.p = p;\n+        }\n+    }\n+\n+    // [Issue#222]\n+    static class Issue222Bean\n+    {\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+                property = \"type\",\n+                include = JsonTypeInfo.As.EXTERNAL_PROPERTY)\n+        public Issue222BeanB value;\n+\n+        public String type = \"foo\";\n+        \n+        public Issue222Bean() { }\n+        public Issue222Bean(int v) {\n+            value = new Issue222BeanB(v);\n+        }\n+    }\n+\n+    static class Issue222BeanB\n+    {\n+        public int x;\n+        \n+        public Issue222BeanB() { }\n+        public Issue222BeanB(int value) { x = value; }\n+    }\n+\n+    public void testIssue222() throws Exception\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        Issue222Bean input = new Issue222Bean(13);\n+        String json = mapper.writeValueAsString(input);\n+        assertEquals(\"{\\\"value\\\":{\\\"x\\\":13},\\\"type\\\":\\\"foo\\\"}\", json);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/failing/TestJavaType76.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestJavaType76.java\n \n import java.util.*;\n \n+import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Failing test related to [Issue#76]\n  */\n-public class TestJavaType76\n-    extends com.fasterxml.jackson.test.BaseTest\n+public class TestJavaType76 extends BaseMapTest\n {\n     @SuppressWarnings(\"serial\")\n     static class HashTree<K, V> extends HashMap<K, HashTree<K, V>> { }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestMapSerialization588.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.io.IOException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestMapSerialization588 extends BaseMapTest\n+{\n+    static class NoEmptiesMapContainer {\n+        @JsonInclude(value=JsonInclude.Include.NON_EMPTY,\n+                content=JsonInclude.Include.NON_EMPTY)\n+        public Map<String,String> stuff = new LinkedHashMap<String,String>();\n+        \n+        public NoEmptiesMapContainer add(String key, String value) {\n+            stuff.put(key, value);\n+            return this;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    final private ObjectMapper MAPPER = objectMapper();\n+\n+    // [databind#588]\n+    public void testNonNullValueMapViaProp() throws IOException\n+    {\n+        String json = MAPPER.writeValueAsString(new NoEmptiesMapContainer()\n+            .add(\"a\", null)\n+            .add(\"b\", \"\"));\n+        assertEquals(aposToQuotes(\"{}\"), json);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestMultipleExternalIds291.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestMultipleExternalIds291 extends BaseMapTest\n+{\n+    // For [Issue#291]\n+    interface F1 {}\n+\n+    static class A implements F1 {\n+        public String a;\n+    }\n+\n+    static class B implements F1 {\n+        public String b;\n+    }\n+\n+    static interface F2 {}\n+\n+    static class C implements F2 {\n+        public String c;\n+    }\n+\n+    static class D implements F2{\n+        public String d;\n+    }\n+\n+    static class Container {\n+        public String type;\n+\n+        @JsonTypeInfo(use = Id.NAME, property = \"type\", include = As.EXTERNAL_PROPERTY)\n+        @JsonSubTypes({\n+                @JsonSubTypes.Type(value = A.class, name = \"1\"),\n+                @JsonSubTypes.Type(value = B.class, name = \"2\")})\n+        public F1 field1;\n+\n+        @JsonTypeInfo(use = Id.NAME, property = \"type\", include = As.EXTERNAL_PROPERTY)\n+        @JsonSubTypes({\n+                @JsonSubTypes.Type(value = C.class, name = \"1\"),\n+                @JsonSubTypes.Type(value = D.class, name = \"2\")})\n+        public F2 field2;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    // [Issue#291]\n+    public void testMultiple() throws Exception\n+    {\n+        final ObjectMapper mapper = objectMapper();\n+        final String JSON =\n+\"{\\\"type\\\" : \\\"1\\\",\\n\"\n++\"\\\"field1\\\" : {\\n\"\n++\"  \\\"a\\\" : \\\"AAA\\\"\\n\"\n++\"}, \\\"field2\\\" : {\\n\"\n++\"  \\\"c\\\" : \\\"CCC\\\"\\n\"\n++\"}\\n\"\n++\"}\";\n+\n+        Container c = mapper.readValue(JSON, Container.class);\n+        assertNotNull(c);\n+        assertTrue(c.field1 instanceof A);\n+        assertTrue(c.field2 instanceof C);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestObjectIdWithInjectables538.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestObjectIdWithInjectables538 extends BaseMapTest\n+{\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)\n+    public static class A {\n+        public B b;\n+\n+        public A(@JacksonInject(\"i1\") String injected) {\n+        }\n+    }\n+\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.IntSequenceGenerator.class)\n+    public static class B {\n+        public A a;\n+\n+        public B(@JacksonInject(\"i2\") String injected) {\n+        }\n+    } \n+\n+    /*\n+    /*****************************************************\n+    /* Test methods\n+    /*****************************************************\n+     */\n+    \n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testWithInjectables538() throws Exception\n+    {\n+        A a = new A(\"a\");\n+        B b = new B(\"b\");\n+        a.b = b;\n+        b.a = a;\n+\n+        String json = MAPPER.writeValueAsString(a);\n+\n+        InjectableValues.Std inject = new InjectableValues.Std();\n+        inject.addValue(\"i1\", \"e1\");\n+        inject.addValue(\"i2\", \"e2\");\n+        A output = null;\n+\n+        try {\n+            output = MAPPER.reader(inject).withType(A.class).readValue(json);\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Failed to deserialize from JSON '\"+json+\"'\", e);\n+        }\n+        assertNotNull(output);\n+\n+        assertNotNull(output.b);\n+    }\n+}\n+\n--- a/src/test/java/com/fasterxml/jackson/failing/TestPolymorphicDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestPolymorphicDeserialization.java\n  * deserializer comes to different conclusion (using default implementation class),\n  * resulting in a <code>ClassCastException</code>.\n  * Whether this is wrong, and if so, can we fix it, is unknown at this point\n- * (2.3.0-SNAPSHOT): quite possibly this can not be changed.\n+ * (2.3): quite possibly this can not be changed.\n  */\n public class TestPolymorphicDeserialization extends BaseMapTest\n {\n--- a/src/test/java/com/fasterxml/jackson/failing/TestScalaLikeImplicitProperties.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestScalaLikeImplicitProperties.java\n             String name = null;\n             if (member instanceof AnnotatedField) {\n                 name = member.getName();\n-            }\n-            if (name != null) {\n-                if (name.endsWith(\"\u203f\")) {                    \n+                if (name.endsWith(\"\u203f\")) {\n                     return name.substring(0, name.length()-1);\n                 }\n+            } else if (member instanceof AnnotatedMethod) {\n+                name = member.getName();\n+                if (name.endsWith(\"_\u2040\")) {\n+                    return name.substring(0, name.length()-2);\n+                }\n+                if (!name.startsWith(\"get\") && !name.startsWith(\"set\")) {\n+                    return name;\n+                }\n+            } else if (member instanceof AnnotatedParameter) {\n+                // A placeholder for legitimate property name detection\n+                // such as what the JDK8 module provides\n+                return \"prop\";\n             }\n             return null;\n+        }\n+\n+        @Override\n+        public boolean hasCreatorAnnotation(Annotated a) {\n+            // A placeholder for legitmate creator detection.\n+            // In Scala, all primary constructors should be creators,\n+            // but I can't obtain a reference to the AnnotatedClass from the\n+            // AnnotatedConstructor, so it's simulated here.\n+            return (a instanceof AnnotatedConstructor);\n         }\n     }\n     \n     static class ValProperty\n     {\n-        public final String prop\u203f;\n+        private final String prop\u203f;\n         public String prop() { return prop\u203f; }\n \n         public ValProperty(String prop) {\n \n     static class ValWithBeanProperty\n     {\n-        public final String prop\u203f;\n+        private final String prop\u203f;\n         public String prop() { return prop\u203f; }\n         public String getProp() { return prop\u203f; }\n \n \n     static class VarProperty\n     {\n-        public String prop\u203f;\n+        private String prop\u203f;\n         public String prop() { return prop\u203f; }\n         public void prop_\u2040(String p) { prop\u203f = p; }\n \n \n     static class VarWithBeanProperty\n     {\n-        public String prop\u203f;\n+        private String prop\u203f;\n         public String prop() { return prop\u203f; }\n         public void prop_\u2040(String p) { prop\u203f = p; }\n         public String getProp() { return prop\u203f; }\n     {\n         ObjectMapper m = manglingMapper();\n \n-        // TODO: Activate whatever handler implements the property detection style\n-\n         assertEquals(\"{\\\"prop\\\":\\\"val\\\"}\", m.writeValueAsString(new ValProperty(\"val\")));\n     }\n \n     {\n         ObjectMapper m = manglingMapper();\n \n-        // TODO: Activate whatever handler implements the property detection style\n-\n         assertEquals(\"{\\\"prop\\\":\\\"val\\\"}\", m.writeValueAsString(new ValWithBeanProperty(\"val\")));\n     }\n \n     public void testVarProperty() throws Exception\n     {\n         ObjectMapper m = manglingMapper();\n-\n-        // TODO: Activate whatever handler implements the property detection style\n \n         assertEquals(\"{\\\"prop\\\":\\\"var\\\"}\", m.writeValueAsString(new VarProperty(\"var\")));\n         VarProperty result = m.readValue(\"{\\\"prop\\\":\\\"read\\\"}\", VarProperty.class);\n     {\n         ObjectMapper m = manglingMapper();\n \n-        // TODO: Activate whatever handler implements the property detection style\n-\n         assertEquals(\"{\\\"prop\\\":\\\"var\\\"}\", m.writeValueAsString(new VarWithBeanProperty(\"var\")));\n         VarWithBeanProperty result = m.readValue(\"{\\\"prop\\\":\\\"read\\\"}\", VarWithBeanProperty.class);\n         assertEquals(\"read\", result.prop());\n     public void testGetterSetterProperty() throws Exception\n     {\n         ObjectMapper m = manglingMapper();\n-\n-        // TODO: Activate whatever handler implements the property detection style\n \n         assertEquals(\"{\\\"prop\\\":\\\"get/set\\\"}\", m.writeValueAsString(new GetterSetterProperty()));\n         GetterSetterProperty result = m.readValue(\"{\\\"prop\\\":\\\"read\\\"}\", GetterSetterProperty.class);\n--- a/src/test/java/com/fasterxml/jackson/failing/TestSetterlessProperties501.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestSetterlessProperties501.java\n \n import com.fasterxml.jackson.databind.*;\n \n-/**\n- * Unit tests for verifying that feature requested\n- * via [JACKSON-88] (\"setterless collections\") work as\n- * expected, similar to how Collections and Maps work\n- * with JAXB.\n- */\n public class TestSetterlessProperties501\n     extends BaseMapTest\n {\n--- a/src/test/java/com/fasterxml/jackson/failing/TestTypeWithJsonValue466.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestTypeWithJsonValue466.java\n package com.fasterxml.jackson.failing;\n \n import java.io.*;\n+import java.math.BigDecimal;\n import java.util.*;\n \n import com.fasterxml.jackson.annotation.*;\n     // The following is required for the testDecimalMetadata test case. That case fails.\n     @JsonTypeName(value = \"decimalValue\")\n     public static class DecimalValue {\n-        private java.math.BigDecimal value;\n-        public DecimalValue(){ this.value = java.math.BigDecimal.valueOf( 1234.4321 ); }\n+        private BigDecimal value;\n+        public DecimalValue() { value = new BigDecimal(\"111.1\"); }\n      \n         @JsonValue\n-        public java.math.BigDecimal getValue(){ return value; }\n+        public BigDecimal getValue(){ return value; }\n     }\n \n     @JsonPropertyOrder({\"key\",\"value\"})\n     public static class DecimalEntry {\n-    public DecimalEntry(){}\n-        public String getKey(){ return \"num\"; }\n+    public DecimalEntry() {}\n+        public String getKey() { return \"num\"; }\n          \n         @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.EXTERNAL_PROPERTY)\n         public DecimalValue getValue(){\n     @JsonTypeName(value = \"doubleValue\")\n     public static class DoubleValue {\n         private Double value;\n-        public DoubleValue(){ this.value = 1234.4321; }\n+        public DoubleValue() { value = 1234.25; }\n          \n         @JsonValue\n-        public Double getValue(){ return value; }\n+        public Double getValue() { return value; }\n     }\n \n     @JsonPropertyOrder({\"key\",\"value\"})\n     \n     public void testDoubleMetadata() throws IOException {\n         DoubleMetadata doub = new DoubleMetadata();\n-        String expected = \"{\\\"metadata\\\":[{\\\"key\\\":\\\"num\\\",\\\"value\\\":1234.4321,\\\"@type\\\":\\\"doubleValue\\\"}]}\";\n+        String expected = \"{\\\"metadata\\\":[{\\\"key\\\":\\\"num\\\",\\\"value\\\":1234.25,\\\"@type\\\":\\\"doubleValue\\\"}]}\";\n         String json = MAPPER.writeValueAsString(doub);\n         assertEquals(\"Serialized json not equivalent\", expected, json);\n     }\n \n     public void testDecimalMetadata() throws IOException{\n         DecimalMetadata dec = new DecimalMetadata();\n-        String expected = \"{\\\"metadata\\\":[{\\\"key\\\":\\\"num\\\",\\\"value\\\":1234.4321,\\\"@type\\\":\\\"decimalValue\\\"}]}\";\n+        String expected = \"{\\\"metadata\\\":[{\\\"key\\\":\\\"num\\\",\\\"value\\\":111.1,\\\"@type\\\":\\\"decimalValue\\\"}]}\";\n         String json = MAPPER.writeValueAsString(dec);\n         assertEquals(\"Serialized json not equivalent\", expected, json);\n     }\n--- a/src/test/java/com/fasterxml/jackson/failing/TestUnknownProperty426.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestUnknownProperty426.java\n public class TestUnknownProperty426 extends BaseMapTest\n {\n     // For [Issue#426]\n-    @JsonIgnoreProperties({ \"userId\"})\n-    public class User {\n+    @JsonIgnoreProperties({ \"userId\" })\n+    static class User {\n         Integer userId; \n \n         void setUserId(String id) {\n \n     public void testIssue426() throws Exception\n     {\n-        String jsonString = \"{id: 9, firstName: \\\"Mike\\\" }\";\n-        User result = MAPPER.reader( User.class ).readValue(jsonString);\n+        final String JSON = aposToQuotes(\"{'id': 9, 'firstName': 'Mike' }\");\n+        User result = MAPPER.reader(User.class).readValue(JSON);\n         assertNotNull(result);\n     }\n }", "timestamp": 1413913097, "metainfo": ""}