{"sha": "8d0d6e4aa8753f44d340b12b6293b5bc0c33d6f5", "log": "Robustify handling of iso-8601 date parsing", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n             return _dateFormat;\n         }\n         /* 24-Feb-2012, tatu: At this point, all timezone configuration\n-         *    should have occured, with respect to default dateformat\n+         *    should have occurred, with respect to default dateformat\n          *    and timezone configuration. But we still better clone\n          *    an instance as formatters may be stateful.\n          */\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n             }\n \n             TimeZone timezone = TimeZone.getTimeZone(timezoneId);\n-            if (!timezone.getID().equals(timezoneId)) {\n-                throw new IndexOutOfBoundsException();\n+            String act = timezone.getID();\n+            if (!act.equals(timezoneId)) {\n+                /* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n+                 *    one without. If so, don't sweat.\n+                 *   Yes, very inefficient. Hopefully not hit often.\n+                 *   If it becomes a perf problem, add 'loose' comparison instead.\n+                 */\n+                String cleaned = act.replace(\":\", \"\");\n+                if (!cleaned.equals(timezoneId)) {\n+                    throw new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n+                            +timezone.getID());\n+                }\n             }\n \n             Calendar calendar = new GregorianCalendar(timezone);\n             fail = e;\n         }\n         String input = (date == null) ? null : ('\"' + date + \"'\");\n-        throw new ParseException(\"Failed to parse date [\" + input + \"]: \" + fail.getMessage(), pos.getIndex());\n+        String msg = fail.getMessage();\n+        if (msg == null || msg.isEmpty()) {\n+            msg = \"(\"+fail.getClass().getName()+\")\";\n+        }\n+        ParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\n+        ex.initCause(fail);\n+        throw ex;\n     }\n \n     /**\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.exc.InvalidFormatException;\n+import com.fasterxml.jackson.databind.util.ISO8601DateFormat;\n \n public class TestDateDeserialization\n     extends BaseMapTest\n         assertEquals(9, c.get(Calendar.HOUR_OF_DAY));\n     }\n \n+    // Based on an external report; was throwing an exception for second case here\n+    public void testISO8601Directly() throws Exception\n+    {\n+        final String TIME_STR = \"2015-01-21T08:56:13.533+0000\";\n+        Date d = MAPPER.readValue(quote(TIME_STR), Date.class);\n+        assertNotNull(d);\n+\n+        ISO8601DateFormat f = new ISO8601DateFormat();\n+        Date d2 = f.parse(TIME_STR);\n+        assertNotNull(d2);\n+        assertEquals(d.getTime(), d2.getTime());\n+    }\n+\n     /*\n     /**********************************************************\n     /* Tests to verify failing cases", "timestamp": 1421969773, "metainfo": ""}