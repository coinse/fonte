{"sha": "6d3fc10bcaed6834823eed08d1b8990b71590e5a", "log": "Add back support for deserializing JsonLocation (using ValueInstiator, for added style points)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     // 16-May-2009, tatu: Ditto ^^^\n     protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector();\n \n-    /**\n-     * @since 1.5\n-     */\n     protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance();\n     \n     /*\n     /**\n      * Registered concrete subtypes that can be used instead of (or\n      * in addition to) ones declared using annotations.\n-     * \n-     * @since 1.6\n      */\n     protected SubtypeResolver _subtypeResolver;\n \n \n     /**\n      * Provider for values to inject in deserialized POJOs.\n-     * \n-     * @since 1.9\n      */\n     protected InjectableValues _injectableValues;\n     \n     /**\n      * Method that will return version information stored in and read from jar\n      * that contains this class.\n-     * \n-     * @since 1.6\n      */\n     @Override\n     public Version version() {\n         return this;\n     }\n \n-    /**\n-     * @since 1.4\n-     */   \n     public SerializerProvider getSerializerProvider() {\n         return _serializerProvider;\n     }\n         return this;\n     }\n \n-    /**\n-     * @since 1.4\n-     */   \n     public DeserializerProvider getDeserializerProvider() {\n         return _deserializerProvider;\n     }\n      * Method for accessing currently configured visibility checker;\n      * object used for determining whether given property element\n      * (method, field, constructor) can be auto-detected or not.\n-     * \n-     * @since 1.5\n      */\n     public VisibilityChecker<?> getVisibilityChecker() {\n         return _serializationConfig.getDefaultVisibilityChecker();\n      * (method, field, constructor) can be auto-detected or not.\n      * This default checker is used if no per-class overrides\n      * are defined.\n-     * \n-     * @since 1.5\n      */    \n     public void setVisibilityChecker(VisibilityChecker<?> vc) {\n         _deserializationConfig = _deserializationConfig.withVisibilityChecker(vc);\n      * \n      * @return Modified mapper instance (that is, \"this\"), to allow chaining\n      *    of configuration calls\n-     * \n-     * @since 1.9\n      */\n     public ObjectMapper setVisibility(PropertyAccessor forMethod, JsonAutoDetect.Visibility visibility)\n     {\n     \n     /**\n      * Method for accessing subtype resolver in use.\n-     * \n-     * @since 1.6\n      */\n     public SubtypeResolver getSubtypeResolver() {\n         if (_subtypeResolver == null) {\n \n     /**\n      * Method for setting custom subtype resolver to use.\n-     * \n-     * @since 1.6\n      */\n     public void setSubtypeResolver(SubtypeResolver r) {\n         _subtypeResolver = r;\n     /**\n      * Method for changing {@link AnnotationIntrospector} used by this\n      * mapper instance for both serialization and deserialization\n-     * \n-     * @since 1.8\n      */\n     public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n         _serializationConfig = _serializationConfig.withAnnotationIntrospector(ai);\n     \n     /**\n      * Method for setting custom property naming strategy to use.\n-     * \n-     * @since 1.8\n      */\n     public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n         _serializationConfig = _serializationConfig.withPropertyNamingStrategy(s);\n      *<pre>\n      *  mapper.setSerializationConfig(mapper.getSerializationConfig().withSerializationInclusion(incl));\n      *</pre>\n-     * \n-     * @since 1.9\n      */\n     public ObjectMapper setSerializationInclusion(JsonSerialize.Inclusion incl) {\n         _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n      * {@link JsonFactory#setParserFeature} on the shared\n      * {@link JsonFactory} this mapper uses (which is accessible\n      * using {@link #getJsonFactory}).\n-     *\n-     * @since 1.2\n      */\n     public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n         _jsonFactory.configure(f, state);\n      * {@link JsonFactory#setGeneratorFeature} on the shared\n      * {@link JsonFactory} this mapper uses (which is accessible\n      * using {@link #getJsonFactory}).\n-     *\n-     * @since 1.2\n      */\n     public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n         _jsonFactory.configure(f, state);\n     /**\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n-     * \n-     * @since 1.9\n      */\n     public ObjectMapper enable(DeserializationConfig.Feature... f) {\n         _deserializationConfig = _deserializationConfig.with(f);\n     /**\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n-     * \n-     * @since 1.9\n      */\n     public ObjectMapper disable(DeserializationConfig.Feature... f) {\n         _deserializationConfig = _deserializationConfig.without(f);\n     /**\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n-     * \n-     * @since 1.9\n      */\n     public ObjectMapper enable(SerializationConfig.Feature... f) {\n         _serializationConfig = _serializationConfig.with(f);\n     /**\n      * Method for enabling specified {@link DeserializationConfig} features.\n      * Modifies and returns this instance; no new object is created.\n-     * \n-     * @since 1.9\n      */\n     public ObjectMapper disable(SerializationConfig.Feature... f) {\n         _serializationConfig = _serializationConfig.without(f);\n      *<pre>\n      *  getSerializationConfig().isEnabled(f);\n      *</pre>\n-     * \n-     * @since 1.9\n      */\n     public boolean isEnabled(SerializationConfig.Feature f) {\n         return _serializationConfig.isEnabled(f);\n      *<pre>\n      *  getDeserializationConfig().isEnabled(f);\n      *</pre>\n-     * \n-     * @since 1.9\n      */\n     public boolean isEnabled(DeserializationConfig.Feature f) {\n         return _deserializationConfig.isEnabled(f);\n      *<pre>\n      *  getJsonFactory().isEnabled(f);\n      *</pre>\n-     * \n-     * @since 1.9\n      */\n     public boolean isEnabled(JsonParser.Feature f) {\n         return _jsonFactory.isEnabled(f);\n      *<pre>\n      *  getJsonFactory().isEnabled(f);\n      *</pre>\n-     * \n-     * @since 1.9\n      */\n     public boolean isEnabled(JsonGenerator.Feature f) {\n         return _jsonFactory.isEnabled(f);\n      *<pre>\n      *   getDeserializationConfig().getNodeFactory()\n      *</pre>\n-     *\n-     * @since 1.2\n      */\n     public JsonNodeFactory getNodeFactory() {\n         return _deserializationConfig.getNodeFactory();\n     public <T> T readValue(JsonParser jp, Class<T> valueType)\n         throws IOException, JsonParseException, JsonMappingException\n     {\n-// !!! TODO\n-//    \t_setupClassLoaderForDeserialization(valueType);\n         return (T) _readValue(copyDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n     } \n \n \n     /**\n      * Method for reading sequence of Objects from parser stream.\n-     * \n-     * @since 1.8\n      */\n     @Override\n     public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n      * container ({@link java.util.Collection} or {@link java.util.Map}.\n      * The reason is that due to type erasure, key and value types\n      * can not be introspected when using this method.\n-     * @since 1.1\n      *\n      * @param cfg Specific deserialization configuration to use for\n      *   this operation. Note that not all config settings can\n      *   be changed on per-operation basis: some changeds only take effect\n      *   before calling the operation for the first time (for the mapper\n      *   instance)\n-     *\n-     * @since 1.1\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef,\n      *   be changed on per-operation basis: some changeds only take effect\n      *   before calling the operation for the first time (for the mapper\n      *   instance)\n-     *\n-     * @since 1.1\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <T> T readValue(JsonParser jp, JavaType valueType,\n      *   be changed on per-operation basis: some changeds only take effect\n      *   before calling the operation for the first time (for the mapper\n      *   instance)\n-     *\n-     * @since 1.1\n      */\n     public JsonNode readTree(JsonParser jp, DeserializationConfig cfg)\n         throws IOException, JsonProcessingException\n      *\n      * @param in Input stream used to read JSON content\n      *   for building the JSON tree.\n-     *\n-     * @since 1.3\n      */\n     public JsonNode readTree(InputStream in)\n         throws IOException, JsonProcessingException\n      *\n      * @param r Reader used to read JSON content\n      *   for building the JSON tree.\n-     *\n-     * @since 1.3\n      */\n     public JsonNode readTree(Reader r)\n         throws IOException, JsonProcessingException\n      * event is a value event, not container).\n      *\n      * @param content JSON content to parse to build the JSON tree.\n-     *\n-     * @since 1.3\n      */\n     public JsonNode readTree(String content)\n         throws IOException, JsonProcessingException\n      * event is a value event, not container).\n      *\n      * @param content JSON content to parse to build the JSON tree.\n-     *\n-     * @since 1.9\n      */\n     public JsonNode readTree(byte[] content)\n         throws IOException, JsonProcessingException\n      * event is a value event, not container).\n      *\n      * @param file File of which contents to parse as JSON for building a tree instance\n-     *\n-     * @since 1.9\n      */\n     public JsonNode readTree(File file)\n         throws IOException, JsonProcessingException\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n import com.fasterxml.jackson.databind.deser.impl.CreatorProperty;\n+import com.fasterxml.jackson.databind.deser.std.JacksonDeserializers;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n                 instantiator = config.valueInstantiatorInstance(ac, (Class<? extends ValueInstantiator>)instClass);\n             }\n         } else {\n-            instantiator = constructDefaultValueInstantiator(config, beanDesc);\n+            /* Second: see if some of standard Jackson/JDK types might provide value\n+             * instantiators.\n+             */\n+            instantiator = findStdValueInstantiator(config, beanDesc);\n+            if (instantiator == null) {\n+                instantiator = constructDefaultValueInstantiator(config, beanDesc);\n+            }\n         }\n         \n         // finally: anyone want to modify ValueInstantiator?\n      * Overridable method that constructs a {@link BeanDeserializerBuilder}\n      * which is used to accumulate information needed to create deserializer\n      * instance.\n-     * \n-     * @since 1.7\n      */\n     protected BeanDeserializerBuilder constructBeanDeserializerBuilder(BasicBeanDescription beanDesc) {\n         return new BeanDeserializerBuilder(beanDesc);\n     }\n \n+    protected ValueInstantiator findStdValueInstantiator(DeserializationConfig config,\n+            BasicBeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        return JacksonDeserializers.findValueInstantiator(config, beanDesc);\n+    }\n+    \n     /**\n      * Method that will construct standard default {@link ValueInstantiator}\n      * using annotations (like @JsonCreator) and visibility rules\n-     * \n-     * @since 1.9\n      */\n     protected ValueInstantiator constructDefaultValueInstantiator(DeserializationConfig config,\n             BasicBeanDescription beanDesc)\n     /**\n      * Method called locate all members used for value injection (if any),\n      * constructor {@link com.fasterxml.jackson.databind.deser.impl.ValueInjector} instances, and add them to builder.\n-     * \n-     * @since 1.9\n      */\n     protected void addInjectables(DeserializationConfig config,\n             BasicBeanDescription beanDesc, BeanDeserializerBuilder builder)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n      * constructor or factory method)\n      * is available for this instantiator\n      */\n-    public abstract boolean canCreateUsingDelegate();\n-//        return getDelegateType(null) != null;\n+    public boolean canCreateUsingDelegate() {\n+        return false;\n+    }\n \n     /**\n      * Method that can be called to check whether a property-based creator\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JacksonDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JacksonDeserializers.java\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.deser.impl.CreatorProperty;\n+import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n {\n     public static StdDeserializer<?>[] all()\n     {\n+        // note: JsonLocation supported via ValueInstantiator\n         return  new StdDeserializer[] {\n             new JavaTypeDeserializer(),\n-//            new JsonLocationDeserializer(),\n             new TokenBufferDeserializer(),\n         };\n     }\n \n+    public static ValueInstantiator findValueInstantiator(DeserializationConfig config,\n+            BasicBeanDescription beanDesc)\n+    {\n+        if (beanDesc.getBeanClass() == JsonLocation.class) {\n+            return new JsonLocationInstantiator();\n+        }\n+        return null;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Deserializer implementations\n         }\n     }\n \n-    @JacksonStdImpl\n-    public static class JsonLocationDeserializer\n-        extends StdScalarDeserializer<JsonLocation>\n+    /**\n+     * For {@link JsonLocation}, we should be able to just implement\n+     * {@link ValueInstantiator} (not that explicit one would be very\n+     * hard but...)\n+     */\n+    public static class JsonLocationInstantiator extends ValueInstantiator\n     {\n-        public JsonLocationDeserializer() { super(JsonLocation.class); }\n+        @Override\n+        public String getValueTypeDesc() {\n+            return JsonLocation.class.getName();\n+        }\n+        \n+        @Override\n+        public boolean canCreateFromObjectWith() { return true; }\n+        \n+        @Override\n+        public CreatorProperty[] getFromObjectArguments(DeserializationConfig config) {\n+            JavaType intType = config.constructType(Integer.TYPE);\n+            JavaType longType = config.constructType(Long.TYPE);\n+            return  new CreatorProperty[] {\n+                    new CreatorProperty(\"sourceRef\", config.constructType(Object.class), null, null, null, 0, null),\n+                    new CreatorProperty(\"byteOffset\", longType, null, null, null, 1, null),\n+                    new CreatorProperty(\"charOffset\", longType, null, null, null, 2, null),\n+                    new CreatorProperty(\"lineNr\", intType, null, null, null, 3, null),\n+                    new CreatorProperty(\"columnNr\", intType, null, null, null, 4, null)\n+            };\n+        }\n \n         @Override\n-        public JsonLocation deserialize(JsonParser jp, DeserializationContext ctxt)\n-            throws IOException, JsonProcessingException\n-        {\n-            // !!! TBI\n-            return null;\n+        public Object createFromObjectWith(Object[] args) {\n+            return new JsonLocation(args[0], _long(args[1]), _long(args[2]),\n+                    _int(args[3]), _int(args[4]));\n+        }\n+\n+        private final static long _long(Object o) {\n+            return (o == null) ? 0L : ((Number) o).longValue();\n+        }\n+        private final static int _int(Object o) {\n+            return (o == null) ? 0 : ((Number) o).intValue();\n         }\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n             new StackTraceElementDeserializer()\n         };\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Deserializer implementations: from-String deserializers\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java\n /**\n  * Base class for deserializers that handle types that are serialized\n  * as JSON scalars (non-structured, i.e. non-Object, non-Array, values).\n- * \n- * @since 1.9 (moved from higher-level package)\n  */\n public abstract class StdScalarDeserializer<T> extends StdDeserializer<T>\n {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestJacksonTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestJacksonTypes.java\n         // Let's use serializer here; goal is round-tripping\n         String ser = serializeAsString(m, loc);\n         JsonLocation result = m.readValue(ser, JsonLocation.class);\n-        assertEquals(\"Did not correctly deserialize standard serialization '\"+ser+\"'\",\n-                     loc, result);\n+        assertNotNull(result);\n+        assertEquals(loc.getSourceRef(), result.getSourceRef());\n+        assertEquals(loc.getByteOffset(), result.getByteOffset());\n+        assertEquals(loc.getCharOffset(), result.getCharOffset());\n+        assertEquals(loc.getColumnNr(), result.getColumnNr());\n+        assertEquals(loc.getLineNr(), result.getLineNr());\n     }\n \n     // doesn't really belong here but...", "timestamp": 1325062348, "metainfo": ""}