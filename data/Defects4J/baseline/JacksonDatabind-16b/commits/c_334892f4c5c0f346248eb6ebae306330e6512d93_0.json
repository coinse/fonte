{"sha": "334892f4c5c0f346248eb6ebae306330e6512d93", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n \n     /*\n     /**********************************************************\n-    /* State\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Configuration settings container class for bean serializer factory.\n-     */\n-    /*\n-    /**********************************************************\n-    /* Config class implementation\n-    /**********************************************************\n-     */\n-    \n+    /* Configuration\n+    /**********************************************************\n+     */\n     \n     /**\n      * Configuration settings for this factory; immutable instance (just like this\n      * see if we know serializer to use for given type.\n      */\n     protected final JsonSerializer<?> findSerializerByLookup(JavaType type,\n-            SerializationConfig config, BeanDescription beanDesc, BeanProperty property,\n+            SerializationConfig config, BeanDescription beanDesc,\n             boolean staticTyping)\n     {\n         Class<?> raw = type.getRawClass();\n      * mostly concrete or abstract base classes.\n      */\n     protected final JsonSerializer<?> findSerializerByPrimaryType(SerializerProvider prov, \n-            JavaType type, BeanDescription beanDesc, BeanProperty property,\n+            JavaType type, BeanDescription beanDesc,\n             boolean staticTyping)\n         throws JsonMappingException\n     {\n             if (prov.canOverrideAccessModifiers()) {\n                 ClassUtil.checkAndFixAccess(m);\n             }\n-            JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod, property);\n+            JsonSerializer<Object> ser = findSerializerFromAnnotation(prov, valueMethod);\n             return new JsonValueSerializer(m, ser);\n         }\n         \n      * bean classes may implement {@link Iterable}, but their main\n      * function is usually something else. The reason for\n      */\n-    protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType,\n-            BeanDescription beanDesc, BeanProperty property,\n+    protected final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config,\n+            JavaType javaType, BeanDescription beanDesc,\n             boolean staticTyping)\n         throws JsonMappingException\n     {\n \n         // These need to be in decreasing order of specificity...\n         if (Iterator.class.isAssignableFrom(type)) {\n-            return buildIteratorSerializer(config, javaType, beanDesc, property, staticTyping);\n+            return buildIteratorSerializer(config, javaType, beanDesc, staticTyping);\n         }\n         if (Iterable.class.isAssignableFrom(type)) {\n-            return buildIterableSerializer(config, javaType, beanDesc, property, staticTyping);\n+            return buildIterableSerializer(config, javaType, beanDesc,  staticTyping);\n         }\n         if (CharSequence.class.isAssignableFrom(type)) {\n             return ToStringSerializer.instance;\n      * Returns null if no such annotation found.\n      */\n     protected JsonSerializer<Object> findSerializerFromAnnotation(SerializerProvider prov,\n-            Annotated a, BeanProperty property)\n+            Annotated a)\n         throws JsonMappingException\n     {\n         Object serDef = prov.getAnnotationIntrospector().findSerializer(a);\n         if (serDef == null) {\n             return null;\n         }\n-        return prov.serializerInstance(a, property, serDef);\n+        return prov.serializerInstance(a, serDef);\n     }\n \n     /*\n         JavaType elementType = type.getContentType();\n         TypeSerializer elementTypeSerializer = createTypeSerializer(config,\n                 elementType);\n-        \n+\n         // if elements have type serializer, can not force static typing:\n         if (elementTypeSerializer != null) {\n             staticTyping = false;\n-        } else if (!staticTyping) {\n-            staticTyping = usesStaticTyping(config, beanDesc, elementTypeSerializer, property);\n         }\n         JsonSerializer<Object> elementValueSerializer = _findContentSerializer(prov,\n                 beanDesc.getClassInfo(), property);\n                 return buildMapSerializer(config, (MapType) mlt, beanDesc, staticTyping,\n                         keySerializer, elementTypeSerializer, elementValueSerializer);\n             }\n-            return buildMapLikeSerializer(config, mlt, beanDesc, staticTyping,\n-                    keySerializer, elementTypeSerializer, elementValueSerializer);\n+            // Only custom serializers may be available:\n+            for (Serializers serializers : customSerializers()) {\n+                JsonSerializer<?> ser = serializers.findMapLikeSerializer(config,\n+                        (MapLikeType) type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n+                if (ser != null) {\n+                    return ser;\n+                }\n+            }\n+            return null;\n         }\n         if (type.isCollectionLikeType()) {\n             CollectionLikeType clt = (CollectionLikeType) type;\n-            if (clt.isTrueCollectionType()) {\n+            if (clt.isTrueCollectionType()) { // only have custom ones, if any:\n                 return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, property, staticTyping,\n                         elementTypeSerializer, elementValueSerializer);\n             }\n-            return buildCollectionLikeSerializer(config, clt, beanDesc, property, staticTyping,\n+            // Only custom variants for this:\n+            for (Serializers serializers : customSerializers()) {\n+                JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config,\n+                        (CollectionLikeType) type, beanDesc, elementTypeSerializer, elementValueSerializer);\n+                if (ser != null) {\n+                    return ser;\n+                }\n+            }\n+            return null;\n+        }\n+        if (type.isArrayType()) {\n+            return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,\n                     elementTypeSerializer, elementValueSerializer);\n-        }\n-        if (type.isArrayType()) {\n-            return buildArraySerializer(config, (ArrayType) type, beanDesc, property, staticTyping,\n-                    elementTypeSerializer, elementValueSerializer);\n-        }\n-        return null;\n-    }\n-    \n-    /**\n-     * Helper method that handles configuration details when constructing serializers for\n-     * Collection and Collection-like types.\n-     */\n-    protected JsonSerializer<?> buildCollectionLikeSerializer(SerializationConfig config,\n-            CollectionLikeType type,\n-            BeanDescription beanDesc, BeanProperty property,\n-            boolean staticTyping,\n-            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n-        throws JsonMappingException\n-    {\n-        for (Serializers serializers : customSerializers()) {\n-            JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config,\n-                    type, beanDesc, elementTypeSerializer, elementValueSerializer);\n-            if (ser != null) {\n-                return ser;\n-            }\n         }\n         return null;\n     }\n         }\n         Class<?> raw = type.getRawClass();\n         if (EnumSet.class.isAssignableFrom(raw)) {\n-            return buildEnumSetSerializer(config, type, beanDesc, property, staticTyping,\n-                    elementTypeSerializer, elementValueSerializer);\n+            // this may or may not be available (Class doesn't; type of field/method does)\n+            JavaType enumType = type.getContentType();\n+            // and even if nominally there is something, only use if it really is enum\n+            if (!enumType.isEnumType()) {\n+                enumType = null;\n+            }\n+            return StdContainerSerializers.enumSetSerializer(enumType);\n         }\n         Class<?> elementRaw = type.getContentType().getRawClass();\n         if (isIndexedList(raw)) {\n         return StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping,\n                 elementTypeSerializer, property, elementValueSerializer);\n     }\n-\n-    protected JsonSerializer<?> buildEnumSetSerializer(SerializationConfig config, JavaType type,\n-            BeanDescription beanDesc, BeanProperty property,\n-            boolean staticTyping,\n-            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n-    {\n-        // this may or may not be available (Class doesn't; type of field/method does)\n-        JavaType enumType = type.getContentType();\n-        // and even if nominally there is something, only use if it really is enum\n-        if (!enumType.isEnumType()) {\n-            enumType = null;\n-        }\n-        return StdContainerSerializers.enumSetSerializer(enumType, property);\n-    }\n     \n     protected boolean isIndexedList(Class<?> cls)\n     {\n     /* Factory methods, for Maps\n     /**********************************************************\n      */\n-    \n-    /**\n-     * Helper method that handles configuration details when constructing serializers for\n-     * all \"Map-like\" types; both ones that implement {@link java.util.Map} and\n-     * ones that do not (but that have been indicated to behave like Maps).\n-     */\n-    protected JsonSerializer<?> buildMapLikeSerializer(SerializationConfig config, MapLikeType type,\n-            BeanDescription beanDesc, boolean staticTyping,\n-            JsonSerializer<Object> keySerializer,\n-            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n-        throws JsonMappingException\n-    {\n-        for (Serializers serializers : customSerializers()) {\n-            JsonSerializer<?> ser = serializers.findMapLikeSerializer(config,\n-                    type, beanDesc, keySerializer, elementTypeSerializer, elementValueSerializer);\n-            if (ser != null) {\n-                return ser;\n-            }\n-        }\n-        return null;\n-    }\n     \n     /**\n      * Helper method that handles configuration details when constructing serializers for\n             }\n         }\n         if (EnumMap.class.isAssignableFrom(type.getRawClass())) {\n-            return buildEnumMapSerializer(config, type, beanDesc, staticTyping,\n-                    elementTypeSerializer, elementValueSerializer);\n+            JavaType keyType = type.getKeyType();\n+            // Need to find key enum values...\n+            EnumValues enums = null;\n+            if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance)\n+                @SuppressWarnings(\"unchecked\")\n+                Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();\n+                enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector());\n+            }\n+            return new EnumMapSerializer(type.getContentType(), staticTyping, enums,\n+                elementTypeSerializer, elementValueSerializer);\n         }\n         return MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()),\n                 type, staticTyping, elementTypeSerializer,\n                 keySerializer, elementValueSerializer);\n     }\n-    \n-    /**\n-     * Helper method that handles configuration details when constructing serializers for\n-     * {@link java.util.EnumMap} types.\n-     */\n-    protected JsonSerializer<?> buildEnumMapSerializer(SerializationConfig config,\n-            JavaType type, BeanDescription beanDesc, boolean staticTyping,\n-            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n-        throws JsonMappingException\n-    {\n-        JavaType keyType = type.getKeyType();\n-        // Need to find key enum values...\n-        EnumValues enums = null;\n-        if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance)\n-            @SuppressWarnings(\"unchecked\")\n-            Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();\n-            enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector());\n-        }\n-        return new EnumMapSerializer(type.getContentType(), staticTyping, enums,\n-            elementTypeSerializer, elementValueSerializer);\n-    }\n \n     /*\n     /**********************************************************\n      * <code>Object[]</code> (and subtypes, except for String).\n      */\n     protected JsonSerializer<?> buildArraySerializer(SerializationConfig config,\n-            ArrayType type, BeanDescription beanDesc, BeanProperty property,\n+            ArrayType type, BeanDescription beanDesc,\n             boolean staticTyping,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n         throws JsonMappingException\n      */\n \n     protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config,\n-            JavaType type, BeanDescription beanDesc, BeanProperty property,\n+            JavaType type, BeanDescription beanDesc,\n             boolean staticTyping)\n         throws JsonMappingException\n     {\n         }\n         TypeSerializer vts = createTypeSerializer(config, valueType);\n         return StdContainerSerializers.iteratorSerializer(valueType,\n-                usesStaticTyping(config, beanDesc, vts, property), vts, property);\n+                usesStaticTyping(config, beanDesc, vts, null), vts);\n     }\n     \n     protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config,\n-            JavaType type, BeanDescription beanDesc, BeanProperty property,\n+            JavaType type, BeanDescription beanDesc,\n             boolean staticTyping)\n         throws JsonMappingException\n     {\n         }\n         TypeSerializer vts = createTypeSerializer(config, valueType);\n         return StdContainerSerializers.iterableSerializer(valueType,\n-                usesStaticTyping(config, beanDesc, vts, property),\n-                vts, property);\n+                usesStaticTyping(config, beanDesc, vts, null),\n+                vts);\n     }\n     \n     /*\n      * Helper method used to encapsulate details of annotation-based type coercion\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type)\n+    protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config,\n+            Annotated a, T type)\n     {\n         // first: let's check class for the instance itself:\n         Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a);\n             if (m != null) {\n                 Object serDef = intr.findKeySerializer(m);\n                 if (serDef != null) {\n-                    return prov.serializerInstance(m, property, serDef);\n+                    return prov.serializerInstance(m, serDef);\n                 }\n             }\n         }\n         Object serDef = intr.findKeySerializer(a);\n         if (serDef != null) {\n-            return prov.serializerInstance(a, property, serDef);\n+            return prov.serializerInstance(a, serDef);\n         }\n         return null;\n     }\n             if (m != null) {\n                 Object serDef = intr.findContentSerializer(m);\n                 if (serDef != null) {\n-                    return prov.serializerInstance(m, property, serDef);\n+                    return prov.serializerInstance(m, serDef);\n                 }\n             }\n         }\n         Object serDef = intr.findContentSerializer(a);\n         if (serDef != null) {\n-            return prov.serializerInstance(a, property, serDef);\n+            return prov.serializerInstance(a, serDef);\n         }\n         return null;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     public JsonSerializer<Object> createSerializer(SerializerProvider prov,\n-            JavaType origType,\n-            BeanProperty property)\n+            JavaType origType, BeanProperty property)\n         throws JsonMappingException\n     {\n         // Very first thing, let's check if there is explicit serializer annotation:\n         final SerializationConfig config = prov.getConfig();\n         BeanDescription beanDesc = config.introspect(origType);\n-        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo(), property);\n+        JsonSerializer<?> ser = findSerializerFromAnnotation(prov, beanDesc.getClassInfo());\n         if (ser != null) {\n             return (JsonSerializer<Object>) ser;\n         }\n-\n         // Next: we may have annotations that further define types to use...\n         JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n         // and if so, we consider it implicit \"force static typing\" instruction\n         boolean staticTyping = (type != origType);\n-        \n-        // Container types differ from non-container types:\n-        if (origType.isContainerType()) {\n-            return (JsonSerializer<Object>) buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n-        }\n \n         // Modules may provide serializers of all types:\n         for (Serializers serializers : _factoryConfig.serializers()) {\n             }\n         }\n \n+        // Container types differ from non-container types:\n+        if (origType.isContainerType()) {\n+            if (!staticTyping) {\n+                staticTyping = usesStaticTyping(config, beanDesc, null, property);\n+            }\n+            return (JsonSerializer<Object>) buildContainerSerializer(prov,\n+                    type, beanDesc, property, staticTyping);\n+        }\n+        \n         /* Otherwise, we will check \"primary types\"; both marker types that\n          * indicate specific handling (JsonSerializable), or main types that have\n          * precedence over container types\n          */\n-        ser = findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n+        ser = findSerializerByLookup(type, config, beanDesc, staticTyping);\n         if (ser == null) {\n-            ser = findSerializerByPrimaryType(prov, type, beanDesc, property, staticTyping);\n+            ser = findSerializerByPrimaryType(prov, type, beanDesc, staticTyping);\n             if (ser == null) {\n                 /* And this is where this class comes in: if type is not a\n                  * known \"primary JDK type\", perhaps it's a bean? We can still\n                  * implementation of some basic JDK interface?\n                  */\n                 if (ser == null) {\n-                    ser = findSerializerByAddonType(config, type, beanDesc, property, staticTyping);\n+                    ser = findSerializerByAddonType(config, type, beanDesc, staticTyping);\n                 }\n             }\n         }\n         BeanProperty.Std property = new BeanProperty.Std(name, type, pb.getClassAnnotations(), accessor);\n \n         // Does member specify a serializer? If so, let's use it.\n-        JsonSerializer<Object> annotatedSerializer = findSerializerFromAnnotation(prov, accessor, property);\n+        JsonSerializer<Object> annotatedSerializer = findSerializerFromAnnotation(prov, accessor);\n         // And how about polymorphic typing? First special to cover JAXB per-field settings:\n         TypeSerializer contentTypeSer = null;\n         if (ClassUtil.isCollectionMapOrArray(type.getRawClass())) {", "timestamp": 1328155302, "metainfo": ""}