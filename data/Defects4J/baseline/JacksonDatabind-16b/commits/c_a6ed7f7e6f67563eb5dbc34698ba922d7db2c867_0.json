{"sha": "a6ed7f7e6f67563eb5dbc34698ba922d7db2c867", "log": "Clean up test for #47; have a look at how implement, realizing that it's... a pain to implement.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n         if (cls == String.class) {\n             return DEFAULT_STRING_SERIALIZER;\n         }\n-        if (cls == Object.class) {\n+        if (cls == Object.class || cls.isPrimitive() || Number.class.isAssignableFrom(cls)) {\n             return DEFAULT_KEY_SERIALIZER;\n         }\n-        // [JACKSON-606] special handling for dates...\n         if (Date.class.isAssignableFrom(cls)) {\n             return (JsonSerializer<Object>) DateKeySerializer.instance;\n         }\n         if (Calendar.class.isAssignableFrom(cls)) {\n             return (JsonSerializer<Object>) CalendarKeySerializer.instance;\n         }\n+        /* 14-Mar-2014, tatu: Should support @JsonValue, as per #47; but that\n+         *   requires extensive introspection, and passing in more information\n+         *   to this method.\n+         */\n         // If no match, just use default one:\n         return DEFAULT_KEY_SERIALIZER;\n     }\n--- a/src/test/java/com/fasterxml/jackson/failing/TestMapJsonValueKey.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestMapJsonValueKey.java\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonValue;\n-import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.test.BaseTest;\n \n-public class TestMapJsonValueKey extends BaseTest\n+// [Issue#47]\n+public class TestMapJsonValueKey extends BaseMapTest\n {\n     public static class Wat\n     {\n         private final String wat;\n \n         @JsonCreator\n-        Wat(String wat)\n-        {\n+        Wat(String wat) {\n             this.wat = wat;\n         }\n \n         @JsonValue\n-        public String getWat()\n-        {\n+        public String getWat() {\n             return wat;\n         }\n \n         @Override\n-        public String toString()\n-        {\n-            return \"[Wat: \" + wat + \"]\";\n+        public String toString() {\n+            return \"(String)[Wat: \" + wat + \"]\";\n         }\n     }\n \n     public void testMapJsonValueKey()\n     throws Exception\n     {\n-        Map<Wat, Boolean> map = new HashMap<Wat, Boolean>();\n-        map.put(new Wat(\"3\"), true);\n-        map.put(new Wat(\"x\"), false);\n-\n-        TypeReference<Map<Wat, Boolean>> type = new TypeReference<Map<Wat, Boolean>>(){};\n+        Map<Wat, Boolean> input = new HashMap<Wat, Boolean>();\n+        input.put(new Wat(\"3\"), true);\n \n         ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(map, mapper.readValue(mapper.writeValueAsBytes(map), type));\n+        String json = mapper.writeValueAsString(input);\n+        assertEquals(aposToQuotes(\"{'3':'true'}\"), json);\n     }\n }", "timestamp": 1394828057, "metainfo": ""}