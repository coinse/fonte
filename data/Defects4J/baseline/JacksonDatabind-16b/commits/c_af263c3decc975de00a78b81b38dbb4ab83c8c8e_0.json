{"sha": "af263c3decc975de00a78b81b38dbb4ab83c8c8e", "log": "Implement #268", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n import java.text.DateFormat;\n import java.text.ParseException;\n import java.util.*;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.core.*;\n     /**********************************************************\n      */\n \n+    @Deprecated // since 2.3, use overloaded variant\n+    public boolean hasValueDeserializerFor(JavaType type) {\n+        return hasValueDeserializerFor(type, null);\n+    }\n+\n     /**\n      * Method for checking whether we could find a deserializer\n      * for given type.\n-     */\n-    public boolean hasValueDeserializerFor(JavaType type) {\n-        return _cache.hasValueDeserializerFor(this, _factory, type);\n-    }\n-    \n+     * \n+     * @param type\n+     * @since 2.3\n+     */\n+    public boolean hasValueDeserializerFor(JavaType type, AtomicReference<Throwable> cause) {\n+        try {\n+            return _cache.hasValueDeserializerFor(this, _factory, type);\n+        } catch (JsonMappingException e) {\n+            if (cause != null) {\n+                cause.set(e);\n+            }\n+        } catch (RuntimeException e) {\n+            if (cause == null) { // earlier behavior\n+                throw e;\n+            }\n+            cause.set(e);\n+        }\n+        return false;\n+    }\n     \n     /**\n      * Method for finding a value deserializer, and creating a contextual\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import java.text.DateFormat;\n import java.util.*;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.core.*;\n      *  serializable)\n      */\n     public boolean canSerialize(Class<?> type) {\n-        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type);\n-    }\n-\n+        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, null);\n+    }\n+\n+    /**\n+     * Method similar to {@link #canSerialize(Class)} but that can return\n+     * actual {@link Throwable} that was thrown when trying to construct\n+     * serializer: this may be useful in figuring out what the actual problem is.\n+     * \n+     * @since 2.3\n+     */\n+    public boolean canSerialize(Class<?> type, AtomicReference<Throwable> cause) {\n+        return _serializerProvider(getSerializationConfig()).hasSerializerFor(type, cause);\n+    }\n+    \n     /**\n      * Method that can be called to check whether mapper thinks\n      * it could deserialize an Object of given type.\n     public boolean canDeserialize(JavaType type)\n     {\n         return createDeserializationContext(null,\n-                getDeserializationConfig()).hasValueDeserializerFor(type);\n-    }\n-\n+                getDeserializationConfig()).hasValueDeserializerFor(type, null);\n+    }\n+\n+    /**\n+     * Method similar to {@link #canDeserialize(JavaType)} but that can return\n+     * actual {@link Throwable} that was thrown when trying to construct\n+     * serializer: this may be useful in figuring out what the actual problem is.\n+     * \n+     * @since 2.3\n+     */\n+    public boolean canDeserialize(JavaType type, AtomicReference<Throwable> cause)\n+    {\n+        return createDeserializationContext(null,\n+                getDeserializationConfig()).hasValueDeserializerFor(type, cause);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Extended Public API, deserialization,\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n         throws JsonMappingException\n     {\n         JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n-        if (deser != null) {\n-            return deser;\n-        }\n-        // If not, need to request factory to construct (or recycle)\n-        deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n         if (deser == null) {\n-            /* Should we let caller handle it? Let's have a helper method\n-             * decide it; can throw an exception, or return a valid\n-             * deserializer\n-             */\n-            deser = _handleUnknownValueDeserializer(propertyType);\n+            // If not, need to request factory to construct (or recycle)\n+            deser = _createAndCacheValueDeserializer(ctxt, factory, propertyType);\n+            if (deser == null) {\n+                /* Should we let caller handle it? Let's have a helper method\n+                 * decide it; can throw an exception, or return a valid\n+                 * deserializer\n+                 */\n+                deser = _handleUnknownValueDeserializer(propertyType);\n+            }\n         }\n         return deser;\n     }\n      */\n     public boolean hasValueDeserializerFor(DeserializationContext ctxt,\n             DeserializerFactory factory, JavaType type)\n+        throws JsonMappingException\n     {\n         /* Note: mostly copied from findValueDeserializer, except for\n          * handling of unknown types\n          */\n         JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n         if (deser == null) {\n-            try {\n-                deser = _createAndCacheValueDeserializer(ctxt, factory, type);\n-            } catch (Exception e) {\n-                return false;\n-            }\n+            deser = _createAndCacheValueDeserializer(ctxt, factory, type);\n         }\n         return (deser != null);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n \n import java.io.IOException;\n import java.util.*;\n+import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n-\n import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n         visitor.setProvider(this);\n         findValueSerializer(javaType, null).acceptJsonFormatVisitor(visitor, javaType);\n     }\n+\n+    @Deprecated // since 2.3; use the overloaded variant\n+    public boolean hasSerializerFor(Class<?> cls) {\n+        return hasSerializerFor(cls, null);\n+    }\n     \n     /**\n      * Method that can be called to see if this serializer provider\n      * Note that no Exceptions are thrown, including unchecked ones:\n      * implementations are to swallow exceptions if necessary.\n      */\n-    public boolean hasSerializerFor(Class<?> cls)\n+    public boolean hasSerializerFor(Class<?> cls, AtomicReference<Throwable> cause)\n     {\n         try {\n-            return _findExplicitUntypedSerializer(cls) != null;\n+            JsonSerializer<?> ser = _findExplicitUntypedSerializer(cls);\n+            return (ser != null);\n         } catch (JsonMappingException e) {\n-            // usually bad practice, but here caller only asked if a serializer\n-            // could be found; for which exception is useless\n-            return false;\n-        }\n+            if (cause != null) {\n+                cause.set(e);\n+            }\n+        } catch (RuntimeException e) {\n+            if (cause == null) { // earlier behavior\n+                throw e;\n+            }\n+            cause.set(e);\n+        }\n+        return false;\n     }\n \n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializerProvider.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializerProvider.java\n package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.ser.BeanSerializerFactory;\n         public int getX() { return 3; }\n     }\n \n+    static class NoPropsBean {\n+    }\n+    \n     public void testFindExplicit() throws JsonMappingException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         assertNotNull(prov.getDefaultNullValueSerializer());\n         // as well as 'unknown type' one (throws exception)\n         assertNotNull(prov.getUnknownTypeSerializer(getClass()));\n-        \n-        assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class));\n+\n+        assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class, null));\n         // call twice to verify it'll be cached (second code path)\n-        assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class));\n+        assertTrue(prov.createInstance(config, f).hasSerializerFor(String.class, null));\n \n-        assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class));\n-        assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class));\n+        assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class, null));\n+        assertTrue(prov.createInstance(config, f).hasSerializerFor(MyBean.class, null));\n+\n+        // And then some negative testing\n+        AtomicReference<Throwable> cause = new AtomicReference<Throwable>();\n+        assertFalse(prov.createInstance(config, f).hasSerializerFor(NoPropsBean.class, cause));\n+        Throwable t = cause.get();\n+        // no actual exception: just fails since there are no properties\n+        assertNull(t);\n     }\n }", "timestamp": 1382656730, "metainfo": ""}