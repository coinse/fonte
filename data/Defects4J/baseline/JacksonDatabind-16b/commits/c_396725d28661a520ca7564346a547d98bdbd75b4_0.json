{"sha": "396725d28661a520ca7564346a547d98bdbd75b4", "log": "Add customizable date format handling for Calendars as well (what about Joda?)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n+import java.text.DateFormat;\n import java.util.Calendar;\n \n import com.fasterxml.jackson.core.*;\n \n-import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n \n  */\n @JacksonStdImpl\n public class CalendarSerializer\n-    extends StdScalarSerializer<Calendar>\n+    extends DateTimeSerializerBase<Calendar>\n {\n     public static CalendarSerializer instance = new CalendarSerializer();\n \n-    public CalendarSerializer() { super(Calendar.class); }\n-    \n+    public CalendarSerializer() { this(false, null); }\n+\n+    public CalendarSerializer(boolean useTimestamp, DateFormat customFormat) {\n+        super(Calendar.class, useTimestamp, customFormat);\n+    }\n+\n     @Override\n-    public boolean isEmpty(Calendar value) {\n-        // let's assume \"null date\" (timestamp 0) qualifies for empty\n-        return (value == null) || (value.getTimeInMillis() == 0L);\n+    public CalendarSerializer withFormat(boolean timestamp, DateFormat customFormat)\n+    {\n+        if (timestamp) {\n+            return new CalendarSerializer(true, null);\n+        }\n+        return new CalendarSerializer(false, customFormat);\n+    }\n+\n+    protected long _timestamp(Calendar value) {\n+        return (value == null) ? 0L : value.getTimeInMillis();\n     }\n \n     @Override\n     public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n-        provider.defaultSerializeDateValue(value.getTimeInMillis(), jgen);\n+        if (_useTimestamp) {\n+            jgen.writeNumber(_timestamp(value));\n+        } else if (_customFormat != null) {\n+            // 21-Feb-2011, tatu: not optimal, but better than alternatives:\n+            synchronized (_customFormat) {\n+                jgen.writeString(_customFormat.format(value));\n+            }\n+        } else {\n+            provider.defaultSerializeDateValue(value.getTime(), jgen);\n+        }\n     }\n \n-    @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-    {\n-        //TODO: (ryan) add a format for the date in the schema?\n-        return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n-                ? \"number\" : \"string\", true);\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n package com.fasterxml.jackson.databind.ser.std;\n \n import java.io.IOException;\n-import java.lang.reflect.Type;\n import java.text.DateFormat;\n-import java.text.SimpleDateFormat;\n import java.util.*;\n \n-import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n-import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n \n /**\n  * For efficiency, we will serialize Dates as longs, instead of\n  */\n @JacksonStdImpl\n public class DateSerializer\n-    extends StdScalarSerializer<Date>\n-    implements ContextualSerializer\n+    extends DateTimeSerializerBase<Date>\n {\n     /**\n      * Default instance that is used when no contextual configuration\n      */\n     public static DateSerializer instance = new DateSerializer();\n     \n-    /**\n-     * Flag that indicates that serialization must be done as the\n-     * Java timetamp, regardless of other settings.\n-     */\n-    protected final boolean _useTimestamp;\n-    \n-    /**\n-     * Specific format to use, if not default format: non null value\n-     * also indicates that serialization is to be done as JSON String,\n-     * not numeric timestamp, unless {@link #_useTimestamp} is true.\n-     */\n-    protected final DateFormat _customFormat;\n-    \n-    /*\n-    /**********************************************************\n-    /* Life-cycle\n-    /**********************************************************\n-     */\n-    \n     public DateSerializer() {\n         this(false, null);\n     }\n         \n-    public DateSerializer(boolean useTimestamp, DateFormat customFormat)\n-    {\n-        super(Date.class);\n-        _useTimestamp = useTimestamp;\n-        _customFormat = customFormat;\n+    public DateSerializer(boolean useTimestamp, DateFormat customFormat) {\n+        super(Date.class, useTimestamp, customFormat);\n     }\n \n+    @Override\n     public DateSerializer withFormat(boolean timestamp, DateFormat customFormat)\n     {\n         if (timestamp) {\n         return new DateSerializer(false, customFormat);\n     }\n \n-    @Override\n-    public JsonSerializer<?> createContextual(SerializerProvider prov,\n-            BeanProperty property) throws JsonMappingException\n-    {\n-        if (property != null) {\n-            JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(property.getMember());\n-            if (format != null) {\n-                if (format.shape.isNumeric()) {\n-                    return withFormat(true, null);\n-                }\n-                String pattern = format.pattern;\n-                if (pattern.length() > 0){\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, prov.getLocale());\n-                    df.setTimeZone(prov.getTimeZone());\n-                    return withFormat(false, df);\n-                }\n-            }\n-        }\n-        return this;\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Accessors\n-    /**********************************************************\n-     */\n-    \n-    @Override\n-    public boolean isEmpty(Date value) {\n-        // let's assume \"null date\" (timestamp 0) qualifies for empty\n-        return (value == null) || (value.getTime() == 0L);\n+    protected long _timestamp(Date value) {\n+        return (value == null) ? 0L : value.getTime();\n     }\n \n-    @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-    {\n-        //todo: (ryan) add a format for the date in the schema?\n-        boolean asNumber = _useTimestamp;\n-        if (!asNumber) {\n-            if (_customFormat == null) {\n-                asNumber = provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n-            }\n-        }\n-        return createSchemaNode(asNumber ? \"number\" : \"string\", true);\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Actual serialization\n-    /**********************************************************\n-     */\n-    \n     @Override\n     public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n         if (_useTimestamp) {\n-            jgen.writeNumber(value.getTime());\n+            jgen.writeNumber(_timestamp(value));\n         } else if (_customFormat != null) {\n             // 21-Feb-2011, tatu: not optimal, but better than alternatives:\n             synchronized (_customFormat) {\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+\n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n+\n+public abstract class DateTimeSerializerBase<T>\n+    extends StdScalarSerializer<T>\n+    implements ContextualSerializer\n+{\n+    /**\n+     * Flag that indicates that serialization must be done as the\n+     * Java timetamp, regardless of other settings.\n+     */\n+    protected final boolean _useTimestamp;\n+    \n+    /**\n+     * Specific format to use, if not default format: non null value\n+     * also indicates that serialization is to be done as JSON String,\n+     * not numeric timestamp, unless {@link #_useTimestamp} is true.\n+     */\n+    protected final DateFormat _customFormat;\n+\n+    protected DateTimeSerializerBase(Class<T> type,\n+            boolean useTimestamp, DateFormat customFormat)\n+    {\n+        super(type);\n+        _useTimestamp = useTimestamp;\n+        _customFormat = customFormat;\n+    }\n+\n+    public abstract DateTimeSerializerBase<T> withFormat(boolean timestamp, DateFormat customFormat);\n+\n+    @Override\n+    public JsonSerializer<?> createContextual(SerializerProvider prov,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        if (property != null) {\n+            JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(property.getMember());\n+            if (format != null) {\n+                if (format.shape.isNumeric()) {\n+                    return withFormat(true, null);\n+                }\n+                String pattern = format.pattern;\n+                if (pattern.length() > 0){\n+                    SimpleDateFormat df = new SimpleDateFormat(pattern, prov.getLocale());\n+                    df.setTimeZone(prov.getTimeZone());\n+                    return withFormat(false, df);\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isEmpty(T value) {\n+        // let's assume \"null date\" (timestamp 0) qualifies for empty\n+        return (value == null) || (_timestamp(value) == 0L);\n+    }\n+\n+    protected abstract long _timestamp(T value);\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        //todo: (ryan) add a format for the date in the schema?\n+        boolean asNumber = _useTimestamp;\n+        if (!asNumber) {\n+            if (_customFormat == null) {\n+                asNumber = provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+            }\n+        }\n+        return createSchemaNode(asNumber ? \"number\" : \"string\", true);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Actual serialization\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public abstract void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException;\n+}", "timestamp": 1329892485, "metainfo": ""}