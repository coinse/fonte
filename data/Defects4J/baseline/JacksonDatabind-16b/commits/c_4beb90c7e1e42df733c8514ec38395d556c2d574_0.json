{"sha": "4beb90c7e1e42df733c8514ec38395d556c2d574", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/node/BigIntegerNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BigIntegerNode.java\n public final class BigIntegerNode\n     extends NumericNode\n {\n+    private final static BigInteger MIN_INTEGER = BigInteger.valueOf(Integer.MIN_VALUE);\n+    private final static BigInteger MAX_INTEGER = BigInteger.valueOf(Integer.MAX_VALUE);\n+    private final static BigInteger MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);\n+    private final static BigInteger MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);\n+    \n     final protected BigInteger _value;\n-\n+    \n     /*\n     /**********************************************************\n     /* Construction\n     @Override\n     public boolean isBigInteger() { return true; }\n \n+    @Override public boolean canConvertToInt() {\n+        return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0);\n+    }\n+    @Override public boolean canConvertToLong() {\n+        return (_value.compareTo(MIN_LONG) >= 0) && (_value.compareTo(MAX_LONG) <= 0);\n+    }\n+    \n     @Override\n     public Number getNumberValue() {\n         return _value;\n--- a/src/main/java/com/fasterxml/jackson/databind/node/DecimalNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/DecimalNode.java\n public final class DecimalNode\n     extends NumericNode\n {\n+    private final static BigDecimal MIN_INTEGER = BigDecimal.valueOf(Integer.MIN_VALUE);\n+    private final static BigDecimal MAX_INTEGER = BigDecimal.valueOf(Integer.MAX_VALUE);\n+    private final static BigDecimal MIN_LONG = BigDecimal.valueOf(Long.MIN_VALUE);\n+    private final static BigDecimal MAX_LONG = BigDecimal.valueOf(Long.MAX_VALUE);\n+\n     final protected BigDecimal _value;\n \n     /* \n     \n     @Override\n     public boolean isBigDecimal() { return true; }\n+\n+    @Override public boolean canConvertToInt() {\n+        return (_value.compareTo(MIN_INTEGER) >= 0) && (_value.compareTo(MAX_INTEGER) <= 0);\n+    }\n+    @Override public boolean canConvertToLong() {\n+        return (_value.compareTo(MIN_LONG) >= 0) && (_value.compareTo(MAX_LONG) <= 0);\n+    }\n     \n     @Override\n     public Number getNumberValue() { return _value; }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/DoubleNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/DoubleNode.java\n     @Override\n     public boolean isDouble() { return true; }\n \n+    @Override public boolean canConvertToInt() {\n+        return (_value >= Integer.MIN_VALUE && _value <= Integer.MAX_VALUE);\n+    }\n+    @Override public boolean canConvertToLong() {\n+        return (_value >= Long.MIN_VALUE && _value <= Long.MAX_VALUE);\n+    }\n+    \n     @Override\n     public Number getNumberValue() {\n         return Double.valueOf(_value);\n--- a/src/main/java/com/fasterxml/jackson/databind/node/IntNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/IntNode.java\n     @Override\n     public boolean isInt() { return true; }\n \n+    @Override public boolean canConvertToInt() { return true; }\n+    @Override public boolean canConvertToLong() { return true; }\n+    \n     @Override\n     public Number getNumberValue() {\n         return Integer.valueOf(_value);\n--- a/src/main/java/com/fasterxml/jackson/databind/node/LongNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/LongNode.java\n     @Override\n     public boolean isLong() { return true; }\n \n+    @Override public boolean canConvertToInt() {\n+        return (_value >= Integer.MIN_VALUE && _value <= Integer.MAX_VALUE);\n+    }\n+    @Override public boolean canConvertToLong() { return true; }\n+    \n     @Override\n     public Number getNumberValue() {\n         return Long.valueOf(_value);\n--- a/src/main/java/com/fasterxml/jackson/databind/node/NumericNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NumericNode.java\n     @Override\n     public abstract BigInteger getBigIntegerValue();\n \n+    @Override public abstract boolean canConvertToInt();\n+    @Override public abstract boolean canConvertToLong();\n+    \n     /* \n     /**********************************************************\n     /* General type coercions\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.node.BigIntegerNode;\n-import com.fasterxml.jackson.databind.node.BinaryNode;\n-import com.fasterxml.jackson.databind.node.BooleanNode;\n-import com.fasterxml.jackson.databind.node.DecimalNode;\n-import com.fasterxml.jackson.databind.node.DoubleNode;\n-import com.fasterxml.jackson.databind.node.IntNode;\n-import com.fasterxml.jackson.databind.node.LongNode;\n-import com.fasterxml.jackson.databind.node.MissingNode;\n-import com.fasterxml.jackson.databind.node.NullNode;\n-import com.fasterxml.jackson.databind.node.POJONode;\n-import com.fasterxml.jackson.databind.node.TextNode;\n \n /**\n  * Basic tests for {@link JsonNode} base class and some features\n         assertNodeNumbers(t, 1, 1.0);\n     }\n \n-    public void testInt()\n-    {\n-        IntNode n = IntNode.valueOf(1);\n-        assertStandardEquals(n);\n-        assertTrue(0 != n.hashCode());\n-        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());\n-        assertEquals(JsonParser.NumberType.INT, n.getNumberType());\n-        assertEquals(1, n.getIntValue());\n-        assertEquals(1L, n.getLongValue());\n-        assertEquals(BigDecimal.ONE, n.getDecimalValue());\n-        assertEquals(BigInteger.ONE, n.getBigIntegerValue());\n-        assertEquals(\"1\", n.asText());\n-\n-        // 1.6:\n-        assertNodeNumbers(n, 1, 1.0);\n-    }\n-\n-    public void testLong()\n-    {\n-        LongNode n = LongNode.valueOf(1L);\n-        assertStandardEquals(n);\n-        assertTrue(0 != n.hashCode());\n-        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());\n-        assertEquals(JsonParser.NumberType.LONG, n.getNumberType());\n-        assertEquals(1, n.getIntValue());\n-        assertEquals(1L, n.getLongValue());\n-        assertEquals(BigDecimal.ONE, n.getDecimalValue());\n-        assertEquals(BigInteger.ONE, n.getBigIntegerValue());\n-        assertEquals(\"1\", n.asText());\n-\n-        // 1.6:\n-        assertNodeNumbers(n, 1, 1.0);\n-    }\n-\n-    public void testDouble()\n-    {\n-        DoubleNode n = DoubleNode.valueOf(0.25);\n-        assertStandardEquals(n);\n-        assertTrue(0 != n.hashCode());\n-        assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());\n-        assertEquals(JsonParser.NumberType.DOUBLE, n.getNumberType());\n-        assertEquals(0, n.getIntValue());\n-        assertEquals(0.25, n.getDoubleValue());\n-        assertNotNull(n.getDecimalValue());\n-        assertEquals(BigInteger.ZERO, n.getBigIntegerValue());\n-        assertEquals(\"0.25\", n.asText());\n-\n-        // 1.6:\n-        assertNodeNumbers(DoubleNode.valueOf(4.5), 4, 4.5);\n-    }\n-\n-    public void testDecimalNode() throws Exception\n-    {\n-        DecimalNode n = DecimalNode.valueOf(BigDecimal.ONE);\n-        assertStandardEquals(n);\n-        assertTrue(n.equals(new DecimalNode(BigDecimal.ONE)));\n-        assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());\n-        assertEquals(JsonParser.NumberType.BIG_DECIMAL, n.getNumberType());\n-        assertTrue(n.isNumber());\n-        assertFalse(n.isIntegralNumber());\n-        assertTrue(n.isBigDecimal());\n-        assertEquals(BigDecimal.ONE, n.getNumberValue());\n-        assertEquals(1, n.getIntValue());\n-        assertEquals(1L, n.getLongValue());\n-        assertEquals(BigDecimal.ONE, n.getDecimalValue());\n-        assertEquals(\"1\", n.asText());\n-\n-        // 1.6:\n-        assertNodeNumbers(n, 1, 1.0);\n-    }\n-\n-    public void testBigIntegerNode() throws Exception\n-    {\n-        BigIntegerNode n = BigIntegerNode.valueOf(BigInteger.ONE);\n-        assertStandardEquals(n);\n-        assertTrue(n.equals(new BigIntegerNode(BigInteger.ONE)));\n-        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());\n-        assertEquals(JsonParser.NumberType.BIG_INTEGER, n.getNumberType());\n-        assertTrue(n.isNumber());\n-        assertTrue(n.isIntegralNumber());\n-        assertTrue(n.isBigInteger());\n-        assertEquals(BigInteger.ONE, n.getNumberValue());\n-        assertEquals(1, n.getIntValue());\n-        assertEquals(1L, n.getLongValue());\n-        assertEquals(BigInteger.ONE, n.getBigIntegerValue());\n-        assertEquals(\"1\", n.asText());\n-        \n-        // 1.6:\n-        assertNodeNumbers(n, 1, 1.0);\n-\n-        BigInteger maxLong = BigInteger.valueOf(Long.MAX_VALUE);\n-        \n-        n = BigIntegerNode.valueOf(maxLong);\n-        assertEquals(Long.MAX_VALUE, n.getLongValue());\n-\n-        ObjectMapper mapper = new ObjectMapper();\n-        JsonNode n2 = mapper.readTree(maxLong.toString());\n-        assertEquals(Long.MAX_VALUE, n2.getLongValue());\n-\n-        // then over long limit:\n-        BigInteger beyondLong = maxLong.shiftLeft(2); // 4x max long\n-        n2 = mapper.readTree(beyondLong.toString());\n-        assertEquals(beyondLong, n2.getBigIntegerValue());\n-    }\n \n     public void testBinary() throws Exception\n     {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Basic tests for {@link JsonNode} implementations that\n+ * contain numeric values.\n+ */\n+public class TestNumberNodes extends BaseMapTest\n+{\n+    public void testInt()\n+    {\n+        IntNode n = IntNode.valueOf(1);\n+        assertStandardEquals(n);\n+        assertTrue(0 != n.hashCode());\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());\n+        assertEquals(JsonParser.NumberType.INT, n.getNumberType());\n+        assertEquals(1, n.getIntValue());\n+        assertEquals(1L, n.getLongValue());\n+        assertEquals(BigDecimal.ONE, n.getDecimalValue());\n+        assertEquals(BigInteger.ONE, n.getBigIntegerValue());\n+        assertEquals(\"1\", n.asText());\n+\n+        assertNodeNumbers(n, 1, 1.0);\n+\n+        assertTrue(IntNode.valueOf(0).canConvertToInt());\n+        assertTrue(IntNode.valueOf(Integer.MAX_VALUE).canConvertToInt());\n+        assertTrue(IntNode.valueOf(Integer.MIN_VALUE).canConvertToInt());\n+\n+        assertTrue(IntNode.valueOf(0).canConvertToLong());\n+        assertTrue(IntNode.valueOf(Integer.MAX_VALUE).canConvertToLong());\n+        assertTrue(IntNode.valueOf(Integer.MIN_VALUE).canConvertToLong());\n+    }\n+\n+    public void testLong()\n+    {\n+        LongNode n = LongNode.valueOf(1L);\n+        assertStandardEquals(n);\n+        assertTrue(0 != n.hashCode());\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());\n+        assertEquals(JsonParser.NumberType.LONG, n.getNumberType());\n+        assertEquals(1, n.getIntValue());\n+        assertEquals(1L, n.getLongValue());\n+        assertEquals(BigDecimal.ONE, n.getDecimalValue());\n+        assertEquals(BigInteger.ONE, n.getBigIntegerValue());\n+        assertEquals(\"1\", n.asText());\n+\n+        assertNodeNumbers(n, 1, 1.0);\n+\n+        // ok if contains small enough value\n+        assertTrue(LongNode.valueOf(0).canConvertToInt());\n+        assertTrue(LongNode.valueOf(Integer.MAX_VALUE).canConvertToInt());\n+        assertTrue(LongNode.valueOf(Integer.MIN_VALUE).canConvertToInt());\n+        // but not in other cases\n+        assertFalse(LongNode.valueOf(1L + Integer.MAX_VALUE).canConvertToInt());\n+        assertFalse(LongNode.valueOf(-1L + Integer.MIN_VALUE).canConvertToInt());\n+\n+        assertTrue(LongNode.valueOf(0L).canConvertToLong());\n+        assertTrue(LongNode.valueOf(Long.MAX_VALUE).canConvertToLong());\n+        assertTrue(LongNode.valueOf(Long.MIN_VALUE).canConvertToLong());\n+    }\n+\n+    public void testDouble()\n+    {\n+        DoubleNode n = DoubleNode.valueOf(0.25);\n+        assertStandardEquals(n);\n+        assertTrue(0 != n.hashCode());\n+        assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());\n+        assertEquals(JsonParser.NumberType.DOUBLE, n.getNumberType());\n+        assertEquals(0, n.getIntValue());\n+        assertEquals(0.25, n.getDoubleValue());\n+        assertNotNull(n.getDecimalValue());\n+        assertEquals(BigInteger.ZERO, n.getBigIntegerValue());\n+        assertEquals(\"0.25\", n.asText());\n+\n+        // 1.6:\n+        assertNodeNumbers(DoubleNode.valueOf(4.5), 4, 4.5);\n+\n+        assertTrue(DoubleNode.valueOf(0).canConvertToInt());\n+        assertTrue(DoubleNode.valueOf(Integer.MAX_VALUE).canConvertToInt());\n+        assertTrue(DoubleNode.valueOf(Integer.MIN_VALUE).canConvertToInt());\n+        assertFalse(DoubleNode.valueOf(1L + Integer.MAX_VALUE).canConvertToInt());\n+        assertFalse(DoubleNode.valueOf(-1L + Integer.MIN_VALUE).canConvertToInt());\n+\n+        assertTrue(DoubleNode.valueOf(0L).canConvertToLong());\n+        assertTrue(DoubleNode.valueOf(Long.MAX_VALUE).canConvertToLong());\n+        assertTrue(DoubleNode.valueOf(Long.MIN_VALUE).canConvertToLong());\n+    }\n+\n+    public void testDecimalNode() throws Exception\n+    {\n+        DecimalNode n = DecimalNode.valueOf(BigDecimal.ONE);\n+        assertStandardEquals(n);\n+        assertTrue(n.equals(new DecimalNode(BigDecimal.ONE)));\n+        assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());\n+        assertEquals(JsonParser.NumberType.BIG_DECIMAL, n.getNumberType());\n+        assertTrue(n.isNumber());\n+        assertFalse(n.isIntegralNumber());\n+        assertTrue(n.isBigDecimal());\n+        assertEquals(BigDecimal.ONE, n.getNumberValue());\n+        assertEquals(1, n.getIntValue());\n+        assertEquals(1L, n.getLongValue());\n+        assertEquals(BigDecimal.ONE, n.getDecimalValue());\n+        assertEquals(\"1\", n.asText());\n+\n+        // 1.6:\n+        assertNodeNumbers(n, 1, 1.0);\n+\n+        assertTrue(DecimalNode.valueOf(BigDecimal.ZERO).canConvertToInt());\n+        assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Integer.MAX_VALUE)).canConvertToInt());\n+        assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Integer.MIN_VALUE)).canConvertToInt());\n+        assertFalse(DecimalNode.valueOf(BigDecimal.valueOf(1L + Integer.MAX_VALUE)).canConvertToInt());\n+        assertFalse(DecimalNode.valueOf(BigDecimal.valueOf(-1L + Integer.MIN_VALUE)).canConvertToInt());\n+\n+        assertTrue(DecimalNode.valueOf(BigDecimal.ZERO).canConvertToLong());\n+        assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Long.MAX_VALUE)).canConvertToLong());\n+        assertTrue(DecimalNode.valueOf(BigDecimal.valueOf(Long.MIN_VALUE)).canConvertToLong());\n+    }\n+\n+    public void testBigIntegerNode() throws Exception\n+    {\n+        BigIntegerNode n = BigIntegerNode.valueOf(BigInteger.ONE);\n+        assertStandardEquals(n);\n+        assertTrue(n.equals(new BigIntegerNode(BigInteger.ONE)));\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());\n+        assertEquals(JsonParser.NumberType.BIG_INTEGER, n.getNumberType());\n+        assertTrue(n.isNumber());\n+        assertTrue(n.isIntegralNumber());\n+        assertTrue(n.isBigInteger());\n+        assertEquals(BigInteger.ONE, n.getNumberValue());\n+        assertEquals(1, n.getIntValue());\n+        assertEquals(1L, n.getLongValue());\n+        assertEquals(BigInteger.ONE, n.getBigIntegerValue());\n+        assertEquals(\"1\", n.asText());\n+        \n+        // 1.6:\n+        assertNodeNumbers(n, 1, 1.0);\n+\n+        BigInteger maxLong = BigInteger.valueOf(Long.MAX_VALUE);\n+        \n+        n = BigIntegerNode.valueOf(maxLong);\n+        assertEquals(Long.MAX_VALUE, n.getLongValue());\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode n2 = mapper.readTree(maxLong.toString());\n+        assertEquals(Long.MAX_VALUE, n2.getLongValue());\n+\n+        // then over long limit:\n+        BigInteger beyondLong = maxLong.shiftLeft(2); // 4x max long\n+        n2 = mapper.readTree(beyondLong.toString());\n+        assertEquals(beyondLong, n2.getBigIntegerValue());\n+\n+        assertTrue(BigIntegerNode.valueOf(BigInteger.ZERO).canConvertToInt());\n+        assertTrue(BigIntegerNode.valueOf(BigInteger.valueOf(Integer.MAX_VALUE)).canConvertToInt());\n+        assertTrue(BigIntegerNode.valueOf(BigInteger.valueOf(Integer.MIN_VALUE)).canConvertToInt());\n+        assertFalse(BigIntegerNode.valueOf(BigInteger.valueOf(1L + Integer.MAX_VALUE)).canConvertToInt());\n+        assertFalse(BigIntegerNode.valueOf(BigInteger.valueOf(-1L + Integer.MIN_VALUE)).canConvertToInt());\n+\n+        assertTrue(BigIntegerNode.valueOf(BigInteger.ZERO).canConvertToLong());\n+        assertTrue(BigIntegerNode.valueOf(BigInteger.valueOf(Long.MAX_VALUE)).canConvertToLong());\n+        assertTrue(BigIntegerNode.valueOf(BigInteger.valueOf(Long.MIN_VALUE)).canConvertToLong());\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n     /**\n      * Enumeration that defines togglable features that guide\n      * the serialization feature.\n+     * \n+     * Note that some features can only be set for\n+     * {@link ObjectMapper} (as default for all deserializations),\n+     * while others can be changed on per-call basis using {@link ObjectReader}.\n+     * Ones that can be used on per-call basis will return <code>true</code>\n+     * from {@link #canUseForInstance}.\n+     * Trying enable/disable ObjectMapper-only feature will result in\n+     * an {@link IllegalArgumentException}.\n      */\n     public enum Feature implements MapperConfig.ConfigFeature\n     {\n          *<P>\n          * Feature is enabled by default.\n          */\n-        USE_ANNOTATIONS(true),\n+        USE_ANNOTATIONS(true, false),\n \n         /**\n          * Feature that determines whether \"setter\" methods are\n          *<P>\n          * Feature is enabled by default.\n          */\n-        AUTO_DETECT_SETTERS(true),\n+        AUTO_DETECT_SETTERS(true, false),\n \n         /**\n          * Feature that determines whether \"creator\" methods are\n          *<P>\n          * Feature is enabled by default.\n          */\n-        AUTO_DETECT_CREATORS(true),\n+        AUTO_DETECT_CREATORS(true, false),\n \n         /**\n          * Feature that determines whether non-static fields are recognized as\n          *<P>\n          * Feature is enabled by default.\n          */\n-        AUTO_DETECT_FIELDS(true),\n+        AUTO_DETECT_FIELDS(true, false),\n \n         /**\n          * Feature that determines whether otherwise regular \"getter\"\n          *<p>\n          * Feature is enabled by default.\n          */\n-        USE_GETTERS_AS_SETTERS(true),\n+        USE_GETTERS_AS_SETTERS(true, false),\n \n         /**\n          * Feature that determines whether method and field access\n          * may be called to enable access to otherwise unaccessible\n          * objects.\n          */\n-        CAN_OVERRIDE_ACCESS_MODIFIERS(true),\n+        CAN_OVERRIDE_ACCESS_MODIFIERS(true, false),\n \n         /*\n         /******************************************************\n          * Feature is disabled by default, meaning that \"untyped\" floating\n          * point numbers will by default be deserialized as {@link Double}s\n          * (choice is for performance reason -- BigDecimals are slower than\n-         * Doubles)\n-         */\n-        USE_BIG_DECIMAL_FOR_FLOATS(false),\n+         * Doubles).\n+         * Feature <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        USE_BIG_DECIMAL_FOR_FLOATS(false, true),\n \n         /**\n          * Feature that determines whether Json integral (non-floating-point)\n          * Feature is disabled by default, meaning that \"untyped\" floating\n          * point numbers will by default be deserialized using whatever\n          * is the most compact integral type, to optimize efficiency.\n-         */\n-        USE_BIG_INTEGER_FOR_INTS(false),\n+         * Feature <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        USE_BIG_INTEGER_FOR_INTS(false, true),\n \n         // [JACKSON-652]\n         /**\n          * If true, binds as <code>Object[]</code>; if false, as <code>List&lt;Object></code>.\n          *<p>\n          * Feature is disabled by default, meaning that JSON arrays are bound as\n-         * {@link java.util.List}s.\n-         */\n-        USE_JAVA_ARRAY_FOR_JSON_ARRAY(false),\n+         * {@link java.util.List}s. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        USE_JAVA_ARRAY_FOR_JSON_ARRAY(false, true),\n         \n         /**\n          * Feature that determines standard deserialization mechanism used for\n          * Note: this feature should usually have same value\n          * as {@link SerializationConfig.Feature#WRITE_ENUMS_USING_TO_STRING}.\n          *<p>\n-         * For further details, check out [JACKSON-212]\n-         */\n-        READ_ENUMS_USING_TO_STRING(false),\n+         * Feature is disabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        READ_ENUMS_USING_TO_STRING(false, true),\n         \n         /*\n         /******************************************************\n          * methods for unknown properties have been tried, and\n          * property remains unhandled.\n          *<p>\n-         * Feature is enabled by default, meaning that \n-         * {@link JsonMappingException} is thrown if an unknown property\n-         * is encountered. This is the implicit default prior to\n-         * introduction of the feature.\n-         */\n-        FAIL_ON_UNKNOWN_PROPERTIES(true),\n+         * Feature is enabled by default (meaning that a\n+         * {@link JsonMappingException} will be thrown if an unknown property\n+         * is encountered). It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        FAIL_ON_UNKNOWN_PROPERTIES(true, true),\n \n         /**\n          * Feature that determines whether encountering of JSON null\n          * is thrown to indicate this; if not, default value is used\n          * (0 for 'int', 0.0 for double, same defaulting as what JVM uses).\n          *<p>\n-         * Feature is disabled by default,\n-         * i.e. to allow use of nulls for primitive properties.\n-         */\n-        FAIL_ON_NULL_FOR_PRIMITIVES(false),\n+         * Feature is disabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        FAIL_ON_NULL_FOR_PRIMITIVES(false, true),\n \n         /**\n          * Feature that determines whether JSON integer numbers are valid\n          * mapping from integer values to enums might happen (and when enums\n          * are always serialized as JSON Strings)\n          *<p>\n-         * Feature is disabled by default\n-         * i.e. to allow use of JSON integers for Java enums.\n-         */\n-        FAIL_ON_NUMBERS_FOR_ENUMS(false),\n+         * Feature is disabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        FAIL_ON_NUMBERS_FOR_ENUMS(false, true),\n \n         /**\n          * Feature that determines whether Jackson code should catch\n          * However, sometimes calling application may just want \"raw\"\n          * unchecked exceptions passed as is.\n          *<p>\n-         * Feature is enabled by default, and is similar in behavior\n-         * to default prior to 1.7.\n-         */\n-        WRAP_EXCEPTIONS(true),\n+         * Feature is enabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        WRAP_EXCEPTIONS(true, true),\n         \n         /*\n         /******************************************************\n          * This feature is meant to be used for compatibility/interoperability reasons,\n          * to work with packages (such as XML-to-JSON converters) that leave out JSON\n          * array in cases where there is just a single element in array.\n-         */\n-        ACCEPT_SINGLE_VALUE_AS_ARRAY(false),\n+         *<p>\n+         * Feature is disabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        ACCEPT_SINGLE_VALUE_AS_ARRAY(false, true),\n         \n         /**\n          * Feature to allow \"unwrapping\" root-level JSON value, to match setting of\n          * a single property with expected root name. If not, a\n          * {@link JsonMappingException} is thrown; otherwise value of the wrapped property\n          * will be deserialized as if it was the root value.\n-         */\n-        UNWRAP_ROOT_VALUE(false),\n+         *<p>\n+         * Feature is disabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        UNWRAP_ROOT_VALUE(false, true),\n \n         /*\n         /******************************************************\n          * constructors are defined; both of which can add support for other\n          * kinds of JSON values); if enable, empty JSON String can be taken\n          * to be equivalent of JSON null.\n-         */\n-        ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false)\n+         *<p>\n+         * Feature is enabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false, true)\n         \n         ;\n \n-        final boolean _defaultState;\n-\t        \n-        private Feature(boolean defaultState) {\n+        private final boolean _defaultState;\n+\n+        /**\n+         * Whether feature can be used and changed on per-call basis (true),\n+         * or just for <code>ObjectMapper</code> (false).\n+         */\n+        private final boolean _canUseForInstance;\n+        \n+        private Feature(boolean defaultState, boolean canUseForInstance) {\n             _defaultState = defaultState;\n+            _canUseForInstance = canUseForInstance;\n         }\n \n         @Override\n         public boolean enabledByDefault() { return _defaultState; }\n+\n+        @Override\n+        public boolean canUseForInstance() { return _canUseForInstance; }\n     \n         @Override\n         public int getMask() { return (1 << ordinal()); }\n--- a/src/main/java/com/fasterxml/jackson/databind/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperConfig.java\n         public boolean enabledByDefault();\n \n         /**\n+         * Accessor for checking whether feature can be used on per-call basis\n+         * (true), or not (false): in latter case it can only be configured once\n+         * before any serialization or deserialization.\n+         */\n+        public boolean canUseForInstance();\n+        \n+        /**\n          * Returns bit mask for this feature instance\n          */\n         public int getMask();\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n     /**\n      * Enumeration that defines togglable features that guide\n      * the serialization feature.\n+     * \n+     * Note that some features can only be set for\n+     * {@link ObjectMapper} (as default for all serializations),\n+     * while others can be changed on per-call basis using {@link ObjectWriter}.\n+     * Ones that can be used on per-call basis will return <code>true</code>\n+     * from {@link #canUseForInstance}.\n+     * Trying enable/disable ObjectMapper-only feature will result in\n+     * an {@link IllegalArgumentException}.\n      */\n     public enum Feature implements MapperConfig.ConfigFeature\n     {\n          * is used for configuration; if enabled, configured\n          * {@link AnnotationIntrospector} will be used: if disabled,\n          * no annotations are considered.\n-         *<P>\n-         * Feature is enabled by default.\n-         */\n-        USE_ANNOTATIONS(true),\n+         *<p>\n+         * Feature is enabled by default. It can <b>not</b> changed\n+         * after first call to serialization; that is, it is not changeable\n+         * via {@link ObjectWriter}\n+         */\n+        USE_ANNOTATIONS(true, false),\n \n         /**\n          * Feature that determines whether regualr \"getter\" methods are\n          * Note that this feature has lower precedence than per-class\n          * annotations, and is only used if there isn't more granular\n          * configuration available.\n-         *<P>\n-         * Feature is enabled by default.\n-         */\n-        AUTO_DETECT_GETTERS(true),\n+         *<p>\n+         * Feature is enabled by default. It can <b>not</b> changed\n+         * after first call to serialization; that is, it is not changeable\n+         * via {@link ObjectWriter}\n+         */\n+        AUTO_DETECT_GETTERS(true, false),\n \n         /**\n          * Feature that determines whether \"is getter\" methods are\n          * Note that this feature has lower precedence than per-class\n          * annotations, and is only used if there isn't more granular\n          * configuration available.\n-         *<P>\n-         * Feature is enabled by default.\n-         */\n-        AUTO_DETECT_IS_GETTERS(true),\n+         *<p>\n+         * Feature is enabled by default. It can <b>not</b> changed\n+         * after first call to serialization; that is, it is not changeable\n+         * via {@link ObjectWriter}\n+         */\n+        AUTO_DETECT_IS_GETTERS(true, false),\n \n         /**\n          * Feature that determines whether non-static fields are recognized as\n          * annotations, and is only used if there isn't more granular\n          * configuration available.\n          *<p>\n-         * Feature is enabled by default.\n-         */\n-         AUTO_DETECT_FIELDS(true),\n+         * Feature is enabled by default. It can <b>not</b> changed\n+         * after first call to serialization; that is, it is not changeable\n+         * via {@link ObjectWriter}\n+         */\n+         AUTO_DETECT_FIELDS(true, false),\n \n         /**\n          * Feature that determines whether method and field access\n          * may be called to enable access to otherwise unaccessible\n          * objects.\n          *<p>\n-         * Feature is enabled by default.\n-         */\n-        CAN_OVERRIDE_ACCESS_MODIFIERS(true),\n+         * Feature is enabled by default. It can <b>not</b> changed\n+         * after first call to serialization; that is, it is not changeable\n+         * via {@link ObjectWriter}\n+         */\n+        CAN_OVERRIDE_ACCESS_MODIFIERS(true, false),\n \n         /**\n          * Feature that determines whether getters (getter methods)\n          * only getters that match a mutator are auto-discovered; if\n          * false, all auto-detectable getters can be discovered.\n          *<p>\n-         * Feature is disabled by default for backwards compatibility\n-         * reasons.\n-         */\n-        REQUIRE_SETTERS_FOR_GETTERS(false),\n+         * Feature is disabled by default. It can <b>not</b> changed\n+         * after first call to serialization; that is, it is not changeable\n+         * via {@link ObjectWriter}\n+         */\n+        REQUIRE_SETTERS_FOR_GETTERS(false, false),\n         \n         /*\n         /******************************************************\n          * This global default value can be overridden at class, method\n          * or field level by using {@link JsonSerialize#typing} annotation\n          * property\n-         */\n-        USE_STATIC_TYPING(false),\n+         *<p>\n+         * Feature is disabled by default. It can <b>not</b> changed\n+         * after first call to serialization; that is, it is not changeable\n+         * via {@link ObjectWriter}\n+         */\n+        USE_STATIC_TYPING(false, false),\n \n         /**\n          * Feature that determines whether properties that have no view\n          * Default value is enabled, meaning that non-annotated\n          * properties are included in all views if there is no\n          * {@link com.fasterxml.jackson.annotation.JsonView} annotation.\n-         */\n-        DEFAULT_VIEW_INCLUSION(true),\n+         *<p>\n+         * Feature is enabled by default. It <b>can not</b> changed\n+         * after first call to serialization; that is, it is not changeable\n+         * via {@link ObjectWriter}\n+         */\n+        DEFAULT_VIEW_INCLUSION(true, false),\n         \n         /**\n          * Feature that can be enabled to make root value (usually JSON\n          * class name).\n          * Feature is mostly intended for JAXB compatibility.\n          *<p>\n-         * Default setting is false, meaning root value is not wrapped.\n-         */\n-        WRAP_ROOT_VALUE(false),\n+         * Feature is enabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        WRAP_ROOT_VALUE(false, true),\n \n         /**\n          * Feature that allows enabling (or disabling) indentation\n          * you need to directly configure the generator: there is a\n          * method to use any <code>PrettyPrinter</code> instance.\n          * This feature will only allow using the default implementation.\n-         */\n-        INDENT_OUTPUT(false),\n+         *<p>\n+         * Feature is enabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        INDENT_OUTPUT(false, true),\n \n         /**\n          * Feature that defines default property serialization order used\n          *<p>\n          * Note that this is just the default behavior, and can be overridden by\n          * explicit overrides in classes.\n-         */\n-        SORT_PROPERTIES_ALPHABETICALLY(false),\n+         *<p>\n+         * Feature is disabled by default. It <b>can not</b> be changed\n+         * after first call to serialization; that is, it is not changeable\n+         * via {@link ObjectWriter}\n+         */\n+        SORT_PROPERTIES_ALPHABETICALLY(false, false),\n         \n         /*\n         /******************************************************\n          * those \"empty\" beans that do not have any recognized annotations\n          * (like <code>@JsonSerialize</code>): ones that do have annotations\n          * do not result in an exception being thrown.\n-         */\n-        FAIL_ON_EMPTY_BEANS(true),\n+         *<p>\n+         * Feature is enabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        FAIL_ON_EMPTY_BEANS(true, true),\n \n         /**\n          * Feature that determines whether Jackson code should catch\n          * However, sometimes calling application may just want \"raw\"\n          * unchecked exceptions passed as is.\n          *<p>\n-         * Feature is enabled by default.\n-         */\n-        WRAP_EXCEPTIONS(true),\n+         *<p>\n+         * Feature is enabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        WRAP_EXCEPTIONS(true, true),\n \n         /*\n         /******************************************************\n           * NOTE: only affects behavior with <b>root</b> objects, and not other\n           * objects reachable from the root object. Put another way, only one\n           * call will be made for each 'writeValue' call.\n+         *<p>\n+         * Feature is disabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n           */\n-        CLOSE_CLOSEABLE(false),\n+        CLOSE_CLOSEABLE(false, true),\n \n         /**\n          * Feature that determines whether <code>JsonGenerator.flush()</code> is\n          * should not be forced: for example when underlying stream is\n          * compressing and flush() causes compression state to be flushed\n          * (which occurs with some compression codecs).\n-         */\n-        FLUSH_AFTER_WRITE_VALUE(true),\n+         *<p>\n+         * Feature is enabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        FLUSH_AFTER_WRITE_VALUE(true, true),\n          \n         /*\n         /******************************************************\n          *<p>\n          * Note: whether {@link java.util.Map} keys are serialized as Strings\n          * or not is controlled using {@link #WRITE_DATE_KEYS_AS_TIMESTAMPS}.\n-         */\n-        WRITE_DATES_AS_TIMESTAMPS(true),\n+         *<p>\n+         * Feature is enabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        WRITE_DATES_AS_TIMESTAMPS(true, true),\n \n         /**\n          * Feature that determines whether {@link java.util.Date}s\n          *<p>\n          * Default value is 'false', meaning that Date-valued Map keys are serialized\n          * as textual (ISO-8601) values.\n-         */\n-        WRITE_DATE_KEYS_AS_TIMESTAMPS(false),\n+         *<p>\n+         * Feature is disabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        WRITE_DATE_KEYS_AS_TIMESTAMPS(false, true),\n \n         /**\n          * Feature that determines how type <code>char[]</code> is serialized:\n          * when enabled, will be serialized as an explict JSON array (with\n          * single-character Strings as values); when disabled, defaults to\n          * serializing them as Strings (which is more compact).\n-         */\n-        WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS(false),\n+         *<p>\n+         * Feature is disabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS(false, true),\n \n         /**\n          * Feature that determines standard serialization mechanism used for\n          * Enum values: if enabled, return value of <code>Enum.toString()</code>\n          * is used; if disabled, return value of <code>Enum.name()</code> is used.\n-         * Since pre-1.6 method was to use Enum name, this is the default.\n          *<p>\n          * Note: this feature should usually have same value\n          * as {@link DeserializationConfig.Feature#READ_ENUMS_USING_TO_STRING}.\n-         * \n-         * @since 1.6\n-         */\n-        WRITE_ENUMS_USING_TO_STRING(false),\n+         *<p>\n+         * Feature is disabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        WRITE_ENUMS_USING_TO_STRING(false, true),\n \n         /**\n          * Feature that determines whethere Java Enum values are serialized\n          *<p>\n          * Note that this feature has precedence over {@link #WRITE_ENUMS_USING_TO_STRING},\n          * which is only considered if this feature is set to false.\n-         */\n-        WRITE_ENUMS_USING_INDEX(false),\n+         *<p>\n+         * Feature is disabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        WRITE_ENUMS_USING_INDEX(false, true),\n         \n         /**\n          * Feature that determines whether Map entries with null values are\n          * to be serialized (true) or not (false).\n          *<p>\n          * For further details, check out [JACKSON-314]\n-         */\n-        WRITE_NULL_MAP_VALUES(true),\n+         *<p>\n+         * Feature is enabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        WRITE_NULL_MAP_VALUES(true, true),\n \n         /**\n          * Feature that determines whether Container properties (POJO properties\n          *<p>\n          * Note that this does not change behavior of {@link java.util.Map}s, or\n          * \"Collection-like\" types.\n-         */\n-        WRITE_EMPTY_JSON_ARRAYS(true)\n+         *<p>\n+         * Feature is enabled by default. It <b>can</b> be changed\n+         * after first call to serialization; that is, it is changeable\n+         * via {@link ObjectWriter}\n+         */\n+        WRITE_EMPTY_JSON_ARRAYS(true, true)\n         \n             ;\n \n-        final boolean _defaultState;\n-        \n-        private Feature(boolean defaultState) {\n+        private final boolean _defaultState;\n+\n+        /**\n+         * Whether feature can be used and changed on per-call basis (true),\n+         * or just for <code>ObjectMapper</code> (false).\n+         */\n+        private final boolean _canUseForInstance;\n+        \n+        private Feature(boolean defaultState, boolean canUseForInstance) {\n             _defaultState = defaultState;\n-        }\n-\n+            _canUseForInstance = canUseForInstance;\n+        }\n+        \n         @Override\n         public boolean enabledByDefault() { return _defaultState; }\n-    \n+\n+        @Override\n+        public boolean canUseForInstance() { return _canUseForInstance; }\n+\n         @Override\n         public int getMask() { return (1 << ordinal()); }\n     }", "timestamp": 1326947061, "metainfo": ""}