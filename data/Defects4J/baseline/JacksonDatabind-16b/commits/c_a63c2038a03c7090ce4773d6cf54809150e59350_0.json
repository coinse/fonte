{"sha": "a63c2038a03c7090ce4773d6cf54809150e59350", "log": "Add unit tests, almost compilable", "commit": "\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/BaseMapTest.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import static org.junit.Assert.*;\n+\n+import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+public abstract class BaseMapTest\n+    extends BaseTest\n+{\n+    private final static Object SINGLETON_OBJECT = new Object();\n+\n+    /*\n+    /**********************************************************\n+    /* Shared helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Simple wrapper around boolean types, usually to test value\n+     * conversions or wrapping\n+     */\n+    protected static class BooleanWrapper {\n+        public Boolean b;\n+\n+        @JsonCreator\n+        public BooleanWrapper(Boolean value) { b = value; }\n+\n+        @JsonValue public Boolean value() { return b; }\n+    }\n+\n+    protected static class IntWrapper {\n+        public int i;\n+\n+        public IntWrapper() { }\n+        public IntWrapper(int value) { i = value; }\n+    }\n+    \n+    /**\n+     * Simple wrapper around String type, usually to test value\n+     * conversions or wrapping\n+     */\n+    protected static class StringWrapper {\n+        public String str;\n+\n+        public StringWrapper() { }\n+        public StringWrapper(String value) {\n+            str = value;\n+        }\n+    }\n+\n+    protected static class ObjectWrapper {\n+        private final Object object;\n+        protected ObjectWrapper(final Object object) {\n+            this.object = object;\n+        }\n+        public Object getObject() { return object; }\n+        @JsonCreator\n+        static ObjectWrapper jsonValue(final Object object) {\n+            return new ObjectWrapper(object);\n+        }\n+    }\n+\n+    protected static class ListWrapper<T>\n+    {\n+        public List<T> list;\n+\n+        public ListWrapper(T... values) {\n+            list = new ArrayList<T>();\n+            for (T value : values) {\n+                list.add(value);\n+            }\n+        }\n+    }\n+\n+    protected static class MapWrapper<K,V>\n+    {\n+        public Map<K,V> map;\n+\n+        public MapWrapper(Map<K,V> m) {\n+            map = m;\n+        }\n+    }\n+    \n+    protected static class ArrayWrapper<T>\n+    {\n+        public T[] array;\n+\n+        public ArrayWrapper(T[] v) {\n+            array = v;\n+        }\n+    }\n+    \n+    /**\n+     * Enumeration type with sub-classes per value.\n+     */\n+    protected enum EnumWithSubClass {\n+        A { @Override public void foobar() { } }\n+        ,B { @Override public void foobar() { } }\n+        ;\n+\n+        public abstract void foobar();\n+    }\n+\n+    protected BaseMapTest() { super(); }\n+\n+    /*\n+    /**********************************************************\n+    /* Additional assert methods\n+    /**********************************************************\n+     */\n+\n+    protected void assertEquals(int[] exp, int[] act)\n+    {\n+        assertArrayEquals(exp, act);\n+    }\n+\n+    /**\n+     * Helper method for verifying 3 basic cookie cutter cases;\n+     * identity comparison (true), and against null (false),\n+     * or object of different type (false)\n+     */\n+    protected void assertStandardEquals(Object o)\n+    {\n+        assertTrue(o.equals(o));\n+        assertFalse(o.equals(null));\n+        assertFalse(o.equals(SINGLETON_OBJECT));\n+        // just for fun, let's also call hash code...\n+        o.hashCode();\n+    }\n+\n+    protected void assertNodeNumbersForNonNumeric(JsonNode n)\n+    { \n+        assertEquals(0, n.asInt());\n+        assertEquals(-42, n.asInt(-42));\n+        assertEquals(0, n.asLong());\n+        assertEquals(12345678901L, n.asLong(12345678901L));\n+        assertEquals(0.0, n.asDouble());\n+        assertEquals(-19.25, n.asDouble(-19.25));\n+    }\n+    \n+    protected void assertNodeNumbers(JsonNode n, int expInt, double expDouble)\n+    {\n+        assertEquals(expInt, n.asInt());\n+        assertEquals(expInt, n.asInt(-42));\n+        assertEquals((long) expInt, n.asLong());\n+        assertEquals((long) expInt, n.asLong(19L));\n+        assertEquals(expDouble, n.asDouble());\n+        assertEquals(expDouble, n.asDouble(-19.25));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected Map<String,Object> writeAndMap(ObjectMapper m, Object value)\n+        throws IOException\n+    {\n+        String str = m.writeValueAsString(value);\n+        return (Map<String,Object>) m.readValue(str, Map.class);\n+    }\n+\n+    protected Map<String,Object> writeAndMap(Object value)\n+        throws IOException\n+    {\n+        return writeAndMap(new ObjectMapper(), value);\n+    }\n+\n+    protected <T> T readAndMapFromString(ObjectMapper m, String input, Class<T> cls)\n+        throws IOException\n+    {\n+        return (T) m.readValue(\"\\\"\"+input+\"\\\"\", cls);\n+    }\n+\n+    protected String serializeAsString(ObjectMapper m, Object value)\n+        throws IOException\n+    {\n+        return m.writeValueAsString(value);\n+    }\n+\n+    protected String serializeAsString(Object value)\n+        throws IOException\n+    {\n+        return serializeAsString(new ObjectMapper(), value);\n+    }\n+\n+    protected String asJSONObjectValueString(Object... args)\n+        throws IOException\n+    {\n+        return asJSONObjectValueString(new ObjectMapper(), args);\n+    }\n+\n+    protected String asJSONObjectValueString(ObjectMapper m, Object... args)\n+        throws IOException\n+    {\n+        LinkedHashMap<Object,Object> map = new LinkedHashMap<Object,Object>();\n+        for (int i = 0, len = args.length; i < len; i += 2) {\n+            map.put(args[i], args[i+1]);\n+        }\n+        return m.writeValueAsString(map);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/BrokenStringReader.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+\n+public class BrokenStringReader\n+    extends FilterReader\n+{\n+    final String _message;\n+\n+    public BrokenStringReader(String content, String msg)\n+    {\n+        super(new StringReader(content));\n+        _message = msg;\n+    }\n+\n+    @Override\n+    public int read(char[] cbuf, int off, int len)\n+        throws IOException\n+    {\n+        int i = super.read(cbuf, off, len);\n+        if (i < 0) {\n+            throw new IOException(_message);\n+        }\n+        return i;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/BrokenStringWriter.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+\n+public class BrokenStringWriter\n+    extends FilterWriter\n+{\n+    final String _message;\n+\n+    public BrokenStringWriter(String msg) {\n+        super(new StringWriter());\n+        _message = msg;\n+    }\n+\n+    @Override\n+    public void write(char[] cbuf, int off, int len) throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+    \n+    @Override\n+    public void write(int c) throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+    \n+    @Override\n+    public void write(String str, int off, int len)  throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.IOContext;\n+import com.fasterxml.jackson.core.base.ParserBase;\n+import com.fasterxml.jackson.core.base.GeneratorBase;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Basic tests to ensure that {@link FormatSchema} instances are properly\n+ * passed to {@link JsonGenerator} and {@link JsonParser} instances if\n+ * mapper, reader or writer is configured with one.\n+ */\n+public class TestFormatSchema extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************************\n+    /* Helper classes\n+    /**********************************************************************\n+     */\n+\n+    static class MySchema implements FormatSchema {\n+        @Override\n+        public String getSchemaType() { return \"test\"; }\n+    }\n+    \n+    static class FactoryWithSchema extends JsonFactory\n+    {\n+        @Override\n+        protected JsonParser _createJsonParser(Reader r, IOContext ctxt)\n+            throws IOException, JsonParseException\n+        {\n+            return new ParserWithSchema(ctxt, _parserFeatures);\n+        }\n+\n+        @Override\n+        protected JsonGenerator _createJsonGenerator(Writer out, IOContext ctxt) throws IOException\n+        {\n+            return new GeneratorWithSchema(_generatorFeatures, _objectCodec);\n+        }\n+    }\n+\n+    // Ugly, but easiest way to get schema back is to throw exception...\n+    @SuppressWarnings(\"serial\")\n+    static class SchemaException extends RuntimeException\n+    {\n+        public final FormatSchema _schema;\n+        \n+        public SchemaException(FormatSchema s) {\n+            _schema = s;\n+        }\n+    }\n+    \n+    static class ParserWithSchema extends ParserBase\n+    {\n+        public ParserWithSchema(IOContext ioCtxt, int features)\n+        {\n+            super(ioCtxt, features);\n+        }\n+\n+        @Override\n+        public void setSchema(FormatSchema schema) {\n+            throw new SchemaException(schema);\n+        }\n+\n+        @Override\n+        protected void _finishString() throws IOException, JsonParseException { }\n+\n+        @Override\n+        public byte[] getBinaryValue(Base64Variant b64variant) {\n+            return null;\n+        }\n+\n+        @Override\n+        public String getText() throws IOException, JsonParseException {\n+            return null;\n+        }\n+\n+        @Override\n+        public char[] getTextCharacters() throws IOException {\n+            return null;\n+        }\n+\n+        @Override\n+        public int getTextLength() throws IOException, JsonParseException {\n+            return 0;\n+        }\n+\n+        @Override\n+        public int getTextOffset() throws IOException, JsonParseException {\n+            return 0;\n+        }\n+\n+        @Override\n+        public JsonToken nextToken() throws IOException, JsonParseException {\n+            return null;\n+        }\n+\n+        @Override\n+        public ObjectCodec getCodec() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void setCodec(ObjectCodec c) { }\n+\n+        @Override\n+        protected boolean loadMore() throws IOException {\n+            return false;\n+        }\n+\n+        @Override\n+        protected void _closeInput() throws IOException {\n+        }\n+    }\n+\n+    static class GeneratorWithSchema extends GeneratorBase\n+    {\n+        public GeneratorWithSchema(int features, ObjectCodec codec)\n+        {\n+            super(features, codec);\n+        }\n+\n+        @Override\n+        public void setSchema(FormatSchema schema) {\n+            throw new SchemaException(schema);\n+        }\n+\n+        @Override\n+        protected void _releaseBuffers() { }\n+\n+        @Override\n+        protected void _verifyValueWrite(String typeMsg) throws IOException { }\n+\n+        @Override\n+        public void flush() throws IOException { }\n+\n+        @Override\n+        public void writeBinary(Base64Variant b64variant, byte[] data,\n+                int offset, int len) throws IOException { }\n+\n+        @Override\n+        public void writeBoolean(boolean state) throws IOException { }\n+\n+        @Override\n+        public void writeFieldName(String name) throws IOException { }\n+\n+        @Override\n+        public void writeNull() throws IOException, JsonGenerationException { }\n+\n+        @Override\n+        public void writeNumber(int v) throws IOException { }\n+\n+        @Override\n+        public void writeNumber(long v) throws IOException { }\n+\n+        @Override\n+        public void writeNumber(BigInteger v) throws IOException { }\n+\n+        @Override\n+        public void writeNumber(double d) throws IOException { }\n+\n+        @Override\n+        public void writeNumber(float f) throws IOException { }\n+\n+        @Override\n+        public void writeNumber(BigDecimal dec) throws IOException { }\n+\n+        @Override\n+        public void writeNumber(String encodedValue) throws IOException { }\n+\n+        @Override\n+        public void writeRaw(String text) throws IOException { }\n+\n+        @Override\n+        public void writeRaw(String text, int offset, int len) { }\n+\n+        @Override\n+        public void writeRaw(char[] text, int offset, int len) { }\n+\n+        @Override\n+        public void writeRaw(char c) throws IOException { }\n+\n+        @Override\n+        public void writeRawUTF8String(byte[] text, int offset, int length) { }\n+\n+        @Override\n+        public void writeString(String text) throws IOException { }\n+\n+        @Override\n+        public void writeString(char[] text, int offset, int len) { }\n+\n+        @Override\n+        public void writeUTF8String(byte[] text, int offset, int length) { }\n+\n+        @Override\n+        public void writeStartArray() throws IOException,\n+                JsonGenerationException {\n+            // TODO Auto-generated method stub\n+            \n+        }\n+\n+        @Override\n+        public void writeEndArray() throws IOException, JsonGenerationException {\n+            // TODO Auto-generated method stub\n+            \n+        }\n+\n+        @Override\n+        public void writeStartObject() throws IOException,\n+                JsonGenerationException {\n+            // TODO Auto-generated method stub\n+            \n+        }\n+\n+        @Override\n+        public void writeEndObject() throws IOException,\n+                JsonGenerationException {\n+            // TODO Auto-generated method stub\n+            \n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Unit tests\n+    /**********************************************************************\n+     */\n+    \n+    public void testFormatForParsers() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper(new FactoryWithSchema());\n+        MySchema s = new MySchema();\n+        StringReader r = new StringReader(\"{}\");\n+        //  bit ugly, but can't think of cleaner simple way to check this...\n+        try {\n+            mapper.reader(s).withType(Object.class).readValue(r);\n+            fail(\"Excpected exception\");\n+        } catch (SchemaException e) {\n+            assertSame(s, e._schema);\n+        }\n+    }\n+\n+    public void testFormatForGenerators() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper(new FactoryWithSchema());\n+        MySchema s = new MySchema();\n+        StringWriter sw = new StringWriter();\n+        //  bit ugly, but can't think of cleaner simple way to check this...\n+        try {\n+            mapper.writer(s).writeValue(sw, \"Foobar\");\n+            fail(\"Excpected exception\");\n+        } catch (SchemaException e) {\n+            assertSame(s, e._schema);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestFromJavaType.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.math.BigDecimal;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * This unit test suite tries verify simplest aspects of\n+ * \"Native\" java type mapper; basically that is can properly serialize\n+ * core JDK objects to JSON.\n+ *\n+ * @author Tatu Saloranta\n+ */\n+public class TestFromJavaType\n+    extends BaseMapTest\n+{\n+    public void testFromArray()\n+        throws Exception\n+    {\n+        ArrayList<Object> doc = new ArrayList<Object>();\n+        doc.add(\"Elem1\");\n+        doc.add(Integer.valueOf(3));\n+        Map<String,Object> struct = new LinkedHashMap<String, Object>();\n+        struct.put(\"first\", Boolean.TRUE);\n+        struct.put(\"Second\", new ArrayList<Object>());\n+        doc.add(struct);\n+        doc.add(Boolean.FALSE);\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonFactory f =  new JsonFactory();\n+\n+        // loop more than once, just to ensure caching works ok (during second round)\n+        for (int i = 0; i < 3; ++i) {\n+            String str = mapper.writeValueAsString(doc);\n+            \n+            JsonParser jp = f.createJsonParser(str);\n+            assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+            \n+            assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(\"Elem1\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(3, jp.getIntValue());\n+            \n+            assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"first\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"Second\", getAndVerifyText(jp));\n+            \n+            if (jp.nextToken() != JsonToken.START_ARRAY) {\n+                fail(\"Expected START_ARRAY: JSON == '\"+str+\"'\");\n+            }\n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+            \n+            assertEquals(JsonToken.VALUE_FALSE, jp.nextToken());\n+            \n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            assertNull(jp.nextToken());\n+        }\n+    }\n+\n+    public void testFromMap()\n+        throws Exception\n+    {\n+        LinkedHashMap<String,Object> doc = new LinkedHashMap<String,Object>();\n+        JsonFactory f =  new JsonFactory();\n+\n+        doc.put(\"a1\", \"\\\"text\\\"\");\n+        doc.put(\"int\", Integer.valueOf(137));\n+        doc.put(\"foo bar\", Long.valueOf(1234567890L));\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        for (int i = 0; i < 3; ++i) {\n+            String str = mapper.writeValueAsString(doc);\n+            JsonParser jp = f.createJsonParser(str);\n+            \n+            assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"a1\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(\"\\\"text\\\"\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"int\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(137, jp.getIntValue());\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"foo bar\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(1234567890L, jp.getLongValue());\n+            \n+            assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+\n+            assertNull(jp.nextToken());\n+        }\n+    }\n+\n+    /**\n+     * Unit test to catch bug [JACKSON-8].\n+     */\n+    public void testBigDecimal()\n+        throws Exception\n+    {\n+        Map<String, Object> map = new HashMap<String, Object>();\n+        String PI_STR = \"3.14159265\";\n+        map.put(\"pi\", new BigDecimal(PI_STR));\n+        String str = new ObjectMapper().writeValueAsString(map);\n+        assertEquals(\"{\\\"pi\\\":3.14159265}\", str);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestGeneratorUsingMapper.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+\n+public class TestGeneratorUsingMapper extends BaseMapTest\n+{\n+    final static class Pojo\n+    {\n+        public int getX() { return 4; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests for data binding integration\n+    /**********************************************************\n+     */\n+\n+    public void testPojoWriting()\n+        throws IOException\n+    {\n+        JsonFactory jf = new MappingJsonFactory();\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator gen = jf.createJsonGenerator(sw);\n+        gen.writeObject(new Pojo());\n+        gen.close();\n+        // trimming needed if main-level object has leading space\n+        String act = sw.toString().trim();\n+        assertEquals(\"{\\\"x\\\":4}\", act);\n+    }\n+\n+    public void testPojoWritingFailing()\n+        throws IOException\n+    {\n+        // regular factory can't do it, without a call to setCodec()\n+        JsonFactory jf = new JsonFactory();\n+        try {\n+            StringWriter sw = new StringWriter();\n+            JsonGenerator gen = jf.createJsonGenerator(sw);\n+            gen.writeObject(new Pojo());\n+            gen.close();\n+            fail(\"Expected an exception: got sw '\"+sw.toString()+\"'\");\n+        } catch (IllegalStateException e) {\n+            verifyException(e, \"No ObjectCodec defined\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.HandlerInstantiator;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.KeyDeserializer;\n+import com.fasterxml.jackson.databind.MapperConfig;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+public class TestHandlerInstantiation extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************************\n+    /* Helper classes, beans\n+    /**********************************************************************\n+     */\n+\n+    @JsonDeserialize(using=MyBeanDeserializer.class)\n+    @JsonSerialize(using=MyBeanSerializer.class)\n+    static class MyBean\n+    {\n+        public String value;\n+\n+        public MyBean() { this(null); }\n+        public MyBean(String s) { value = s; }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    @JsonDeserialize(keyUsing=MyKeyDeserializer.class)\n+    static class MyMap extends HashMap<String,String> { }\n+\n+    @JsonTypeInfo(use=Id.CUSTOM, include=As.WRAPPER_ARRAY)\n+    @JsonTypeIdResolver(CustomIdResolver.class)\n+    static class TypeIdBean {\n+        public int x;\n+        \n+        public TypeIdBean() { }\n+        public TypeIdBean(int x) { this.x = x; }\n+    }\n+\n+    static class TypeIdBeanWrapper {\n+        public TypeIdBean bean;\n+        \n+        public TypeIdBeanWrapper() { this(null); }\n+        public TypeIdBeanWrapper(TypeIdBean b) { bean = b; }\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Helper classes, serializers/deserializers/resolvers\n+    /**********************************************************************\n+     */\n+    \n+    static class MyBeanDeserializer extends JsonDeserializer<MyBean>\n+    {\n+        public String _prefix = \"\";\n+\n+        public MyBeanDeserializer(String p) {\n+            _prefix  = p;\n+        }\n+        \n+        @Override\n+        public MyBean deserialize(JsonParser jp, DeserializationContext ctxt)\n+                throws IOException, JsonProcessingException\n+        {\n+            return new MyBean(_prefix+jp.getText());\n+        }\n+    }\n+\n+    static class MyKeyDeserializer extends KeyDeserializer\n+    {\n+        public MyKeyDeserializer() { }\n+        \n+        @Override\n+        public Object deserializeKey(String key, DeserializationContext ctxt)\n+                throws IOException, JsonProcessingException\n+        {\n+            return \"KEY\";\n+        }\n+    }\n+    \n+    static class MyBeanSerializer extends JsonSerializer<MyBean>\n+    {\n+        public String _prefix = \"\";\n+\n+        public MyBeanSerializer(String p) {\n+            _prefix  = p;\n+        }\n+        \n+        @Override\n+        public void serialize(MyBean value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonProcessingException\n+        {\n+            jgen.writeString(_prefix + value.value);\n+        }\n+    }\n+    \n+    // copied from \"TestCustomTypeIdResolver\"\n+    static class CustomIdResolver implements TypeIdResolver\n+    {\n+        static List<JavaType> initTypes;\n+\n+        final String _id;\n+        \n+        public CustomIdResolver(String idForBean) {\n+            _id = idForBean;\n+        }\n+        \n+        @Override\n+        public Id getMechanism() {\n+            return Id.CUSTOM;\n+        }\n+\n+        @Override\n+        public String idFromValue(Object value)\n+        {\n+            if (value.getClass() == TypeIdBean.class) {\n+                return _id;\n+            }\n+            return \"unknown\";\n+        }\n+\n+        @Override\n+        public String idFromValueAndType(Object value, Class<?> type) {\n+            return idFromValue(value);\n+        }\n+        \n+        @Override\n+        public void init(JavaType baseType) {\n+            if (initTypes != null) {\n+                initTypes.add(baseType);\n+            }\n+        }\n+\n+        @Override\n+        public JavaType typeFromId(String id)\n+        {\n+            if (id.equals(_id)) {\n+                return TypeFactory.defaultInstance().constructType(TypeIdBean.class);\n+            }\n+            return null;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Helper classes, handler instantiator\n+    /**********************************************************************\n+     */\n+    \n+    static class MyInstantiator extends HandlerInstantiator\n+    {\n+        private final String _prefix;\n+        \n+        public MyInstantiator(String p) {\n+            _prefix = p;\n+        }\n+        \n+        @Override\n+        public JsonDeserializer<?> deserializerInstance(DeserializationConfig config, Annotated annotated,\n+                Class<? extends JsonDeserializer<?>> deserClass)\n+        {\n+            if (deserClass == MyBeanDeserializer.class) {\n+                return new MyBeanDeserializer(_prefix);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public KeyDeserializer keyDeserializerInstance(DeserializationConfig config,\n+                Annotated annotated, Class<? extends KeyDeserializer> keyDeserClass)\n+        {\n+            if (keyDeserClass == MyKeyDeserializer.class) {\n+                return new MyKeyDeserializer();\n+            }\n+            return null;\n+            \n+        }\n+        \n+        @Override\n+        public JsonSerializer<?> serializerInstance(SerializationConfig config,\n+                Annotated annotated, Class<? extends JsonSerializer<?>> serClass)\n+        {\n+            if (serClass == MyBeanSerializer.class) {\n+                return new MyBeanSerializer(_prefix);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public TypeIdResolver typeIdResolverInstance(MapperConfig<?> config,\n+                Annotated annotated, Class<? extends TypeIdResolver> resolverClass)\n+        {\n+            if (resolverClass == CustomIdResolver.class) {\n+                return new CustomIdResolver(\"!!!\");\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public TypeResolverBuilder<?> typeResolverBuilderInstance(MapperConfig<?> config, Annotated annotated,\n+                Class<? extends TypeResolverBuilder<?>> builderClass)\n+        {\n+            return null;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Unit tests\n+    /**********************************************************************\n+     */\n+\n+    public void testDeserializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setHandlerInstantiator(new MyInstantiator(\"abc:\"));\n+        MyBean result = mapper.readValue(quote(\"123\"), MyBean.class);\n+        assertEquals(\"abc:123\", result.value);\n+    }\n+\n+    public void testKeyDeserializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setHandlerInstantiator(new MyInstantiator(\"abc:\"));\n+        MyMap map = mapper.readValue(\"{\\\"a\\\":\\\"b\\\"}\", MyMap.class);\n+        // easiest to test by just serializing...\n+        assertEquals(\"{\\\"KEY\\\":\\\"b\\\"}\", mapper.writeValueAsString(map));\n+    }\n+    \n+    public void testSerializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setHandlerInstantiator(new MyInstantiator(\"xyz:\"));\n+        assertEquals(quote(\"xyz:456\"), mapper.writeValueAsString(new MyBean(\"456\")));\n+    }\n+\n+    public void testTypeIdResolver() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setHandlerInstantiator(new MyInstantiator(\"foobar\"));\n+        String json = mapper.writeValueAsString(new TypeIdBeanWrapper(new TypeIdBean(123)));\n+        // should now use our custom id scheme:\n+        assertEquals(\"{\\\"bean\\\":[\\\"!!!\\\",{\\\"x\\\":123}]}\", json);\n+        // and bring it back too:\n+        TypeIdBeanWrapper result = mapper.readValue(json, TypeIdBeanWrapper.class);\n+        TypeIdBean bean = result.bean;\n+        assertEquals(123, bean.x);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestJsonParserSequence.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonParserSequence;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n+\n+/**\n+ * Unit tests to verify that {@link JsonParserSequence} works\n+ * as expected.\n+ */\n+public class TestJsonParserSequence\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public void testSimple() throws IOException\n+    {\n+        // Let's join a TokenBuffer with JsonParser first\n+        TokenBuffer buf = new TokenBuffer(null);\n+        buf.writeStartArray();\n+        buf.writeString(\"test\");\n+        JsonParser jp = createParserUsingReader(\"[ true, null ]\");\n+        \n+        JsonParserSequence seq = JsonParserSequence.createFlattened(buf.asParser(), jp);\n+        assertEquals(2, seq.containedParsersCount());\n+\n+        assertFalse(jp.isClosed());\n+        \n+        assertFalse(seq.hasCurrentToken());\n+        assertNull(seq.getCurrentToken());\n+        assertNull(seq.getCurrentName());\n+\n+        assertToken(JsonToken.START_ARRAY, seq.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, seq.nextToken());\n+        assertEquals(\"test\", seq.getText());\n+        // end of first parser input, should switch over:\n+        \n+        assertToken(JsonToken.START_ARRAY, seq.nextToken());\n+        assertToken(JsonToken.VALUE_TRUE, seq.nextToken());\n+        assertToken(JsonToken.VALUE_NULL, seq.nextToken());\n+        assertToken(JsonToken.END_ARRAY, seq.nextToken());\n+\n+        /* 17-Jan-2009, tatus: At this point, we may or may not get an\n+         *   exception, depending on how underlying parsers work.\n+         *   Ideally this should be fixed, probably by asking underlying\n+         *   parsers to disable checking for balanced start/end markers.\n+         */\n+\n+        // for this particular case, we won't get an exception tho...\n+        assertNull(seq.nextToken());\n+        // not an error to call again...\n+        assertNull(seq.nextToken());\n+\n+        // also: original parsers should be closed\n+        assertTrue(jp.isClosed());\n+    }\n+\n+    /**\n+     * Test to verify that sequences get flattened, to minimize depth\n+     * of nesting (to reduce call chaining)\n+     */\n+    public void testFlattening() throws IOException\n+    {\n+        TokenBuffer buf1 = new TokenBuffer(null);\n+        buf1.writeStartArray();\n+        TokenBuffer buf2 = new TokenBuffer(null);\n+        buf2.writeString(\"a\");\n+        TokenBuffer buf3 = new TokenBuffer(null);\n+        buf3.writeNumber(13);\n+        TokenBuffer buf4 = new TokenBuffer(null);\n+        buf4.writeEndArray();\n+\n+        JsonParserSequence seq1 = JsonParserSequence.createFlattened(buf1.asParser(), buf2.asParser());\n+        assertEquals(2, seq1.containedParsersCount());\n+        JsonParserSequence seq2 = JsonParserSequence.createFlattened(buf3.asParser(), buf4.asParser());\n+        assertEquals(2, seq2.containedParsersCount());\n+        JsonParserSequence combo = JsonParserSequence.createFlattened(seq1, seq2);\n+        // should flatten it to have 4 underlying parsers\n+        assertEquals(4, combo.containedParsersCount());\n+\n+        assertToken(JsonToken.START_ARRAY, combo.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, combo.nextToken());\n+        assertEquals(\"a\", combo.getText());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, combo.nextToken());\n+        assertEquals(13, combo.getIntValue());\n+        assertToken(JsonToken.END_ARRAY, combo.nextToken());\n+        assertNull(combo.nextToken());        \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestNamingStrategy.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.MapperConfig;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+\n+/**\n+ * Unit tests to verify functioning of {@link PropertyNamingStrategy} which\n+ * was added in Jackson 1.8, as per [JACKSON-178].\n+ */\n+public class TestNamingStrategy extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************************\n+    /* Helper classes\n+    /**********************************************************************\n+     */\n+\n+    static class PrefixStrategy extends PropertyNamingStrategy\n+    {\n+        @Override\n+        public String nameForField(MapperConfig<?> config,\n+                AnnotatedField field, String defaultName)\n+        {\n+            return \"Field-\"+defaultName;\n+        }\n+\n+        @Override\n+        public String nameForGetterMethod(MapperConfig<?> config,\n+                AnnotatedMethod method, String defaultName)\n+        {\n+            return \"Get-\"+defaultName;\n+        }\n+\n+        @Override\n+        public String nameForSetterMethod(MapperConfig<?> config,\n+                AnnotatedMethod method, String defaultName)\n+        {\n+            return \"Set-\"+defaultName;\n+        }\n+    }\n+    \n+    static class CStyleStrategy extends PropertyNamingStrategy\n+    {\n+        @Override\n+        public String nameForField(MapperConfig<?> config, AnnotatedField field, String defaultName)\n+        {\n+            return convert(defaultName);\n+        }\n+\n+        @Override\n+        public String nameForGetterMethod(MapperConfig<?> config, AnnotatedMethod method, String defaultName)\n+        {\n+            return convert(defaultName);\n+        }\n+\n+        @Override\n+        public String nameForSetterMethod(MapperConfig<?> config, AnnotatedMethod method, String defaultName)\n+        {\n+            return convert(defaultName);\n+        }\n+\n+        private String convert(String input)\n+        {\n+            // easy: replace capital letters with underscore, lower-cases equivalent\n+            StringBuilder result = new StringBuilder();\n+            for (int i = 0, len = input.length(); i < len; ++i) {\n+                char c = input.charAt(i);\n+                if (Character.isUpperCase(c)) {\n+                    result.append('_');\n+                    c = Character.toLowerCase(c);\n+                }\n+                result.append(c);\n+            }\n+            return result.toString();\n+        }\n+    }\n+    \n+    static class GetterBean {\n+        public int getKey() { return 123; }\n+    }\n+\n+    static class SetterBean {\n+        protected int value;\n+        \n+        public void setKey(int v) {\n+            value = v;\n+        }\n+    }\n+\n+    static class FieldBean {\n+        public int key;\n+\n+        public FieldBean() { this(0); }\n+        public FieldBean(int v) { key = v; }\n+    }\n+\n+    @JsonPropertyOrder({\"first_name\", \"last_name\"})\n+    static class PersonBean {\n+        public String firstName;\n+        public String lastName;\n+        public int age;\n+\n+        public PersonBean() { this(null, null, 0); }\n+        public PersonBean(String f, String l, int a)\n+        {\n+            firstName = f;\n+            lastName = l;\n+            age = a;\n+        }\n+    }\n+\n+    static class Value {\n+        public int intValue;\n+        \n+        public Value() { this(0); }\n+        public Value(int v) { intValue = v; }\n+    }\n+\n+    static class SetterlessWithValue\n+    {\n+        protected ArrayList<Value> values = new ArrayList<Value>();\n+\n+        public List<Value> getValueList() { return values; }\n+\n+        public SetterlessWithValue add(int v) {\n+            values.add(new Value(v));\n+            return this;\n+        }\n+    }\n+\n+    // [JACKSON-687]\n+    static class LcStrategy extends PropertyNamingStrategy.PropertyNamingStrategyBase\n+    {\n+        @Override\n+        public String translate(String propertyName) {\n+            return propertyName.toLowerCase();\n+        }\n+    }\n+    \n+    static class RenamedCollectionBean\n+    {\n+        @JsonDeserialize\n+        private List<String> THEvalues = Collections.emptyList();\n+        \n+        // intentionally odd name, to be renamed by naming strategy\n+        public List<String> getTheVALUEs() { return THEvalues; }\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Test methods\n+    /**********************************************************************\n+     */\n+    \n+    public void testSimpleGetters() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setPropertyNamingStrategy(new PrefixStrategy());\n+        assertEquals(\"{\\\"Get-key\\\":123}\", mapper.writeValueAsString(new GetterBean()));\n+    }\n+\n+    public void testSimpleSetters() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setPropertyNamingStrategy(new PrefixStrategy());\n+        SetterBean bean = mapper.readValue(\"{\\\"Set-key\\\":13}\", SetterBean.class);\n+        assertEquals(13, bean.value);\n+    }\n+\n+    public void testSimpleFields() throws Exception\n+    {\n+        // First serialize\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setPropertyNamingStrategy(new PrefixStrategy());\n+        String json = mapper.writeValueAsString(new FieldBean(999));\n+        assertEquals(\"{\\\"Field-key\\\":999}\", json);\n+\n+        // then deserialize\n+        FieldBean result = mapper.readValue(json, FieldBean.class);\n+        assertEquals(999, result.key);\n+    }\n+\n+    public void testCStyleNaming() throws Exception\n+    {\n+        // First serialize\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setPropertyNamingStrategy(new CStyleStrategy());\n+        String json = mapper.writeValueAsString(new PersonBean(\"Joe\", \"Sixpack\", 42));\n+        assertEquals(\"{\\\"first_name\\\":\\\"Joe\\\",\\\"last_name\\\":\\\"Sixpack\\\",\\\"age\\\":42}\", json);\n+        \n+        // then deserialize\n+        PersonBean result = mapper.readValue(json, PersonBean.class);\n+        assertEquals(\"Joe\", result.firstName);\n+        assertEquals(\"Sixpack\", result.lastName);\n+        assertEquals(42, result.age);\n+    }\n+\n+    public void testWithGetterAsSetter() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setPropertyNamingStrategy(new CStyleStrategy());\n+        SetterlessWithValue input = new SetterlessWithValue().add(3);\n+        String json = mapper.writeValueAsString(input);\n+        assertEquals(\"{\\\"value_list\\\":[{\\\"int_value\\\":3}]}\", json);\n+\n+        SetterlessWithValue result = mapper.readValue(json, SetterlessWithValue.class);\n+        assertNotNull(result.values);\n+        assertEquals(1, result.values.size());\n+        assertEquals(3, result.values.get(0).intValue);\n+    }\n+\n+    // For [JACKSON-687]\n+    public void testJson() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setPropertyNamingStrategy(new LcStrategy());\n+//        mapper.disable(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS);\n+        RenamedCollectionBean foo = mapper.readValue(\"{\\\"thevalues\\\":[\\\"a\\\"]}\", RenamedCollectionBean.class);\n+        assertNotNull(foo.getTheVALUEs());\n+        assertEquals(1, foo.getTheVALUEs().size());\n+        assertEquals(\"a\", foo.getTheVALUEs().get(0));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+\n+\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.node.*;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+public class TestObjectMapper extends BaseMapTest\n+{\n+    public void testProps()\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // should have default factory\n+        assertNotNull(m.getNodeFactory());\n+        JsonNodeFactory nf = JsonNodeFactory.instance;\n+        m.setNodeFactory(nf);\n+        assertSame(nf, m.getNodeFactory());\n+    }\n+\n+    public void testSupport()\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertTrue(m.canSerialize(String.class));\n+\n+        assertTrue(m.canDeserialize(TypeFactory.defaultInstance().constructType(String.class)));\n+    }\n+\n+    public void testTreeRead() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        String JSON = \"{ }\";\n+        JsonNode n = m.readTree(JSON);\n+        assertTrue(n instanceof ObjectNode);\n+\n+        n = m.readTree(new StringReader(JSON));\n+        assertTrue(n instanceof ObjectNode);\n+\n+        n = m.readTree(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\")));\n+        assertTrue(n instanceof ObjectNode);\n+    }\n+\n+    // Test to ensure that we can check property ordering defaults...\n+    public void testConfigForPropertySorting() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        \n+        // sort-alphabetically is disabled by default:\n+        assertFalse(m.isEnabled(SerializationConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        SerializationConfig sc = m.copySerializationConfig();\n+        assertFalse(sc.isEnabled(SerializationConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        assertFalse(sc.shouldSortPropertiesAlphabetically());\n+        DeserializationConfig dc = m.copyDeserializationConfig();\n+        assertFalse(dc.shouldSortPropertiesAlphabetically());\n+\n+        // but when enabled, should be visible:\n+        m.enable(SerializationConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY);\n+        sc = m.copySerializationConfig();\n+        assertTrue(sc.isEnabled(SerializationConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY));\n+        assertTrue(sc.shouldSortPropertiesAlphabetically());\n+        dc = m.copyDeserializationConfig();\n+        // and not just via SerializationConfig, but also via DeserializationConfig\n+        assertTrue(dc.shouldSortPropertiesAlphabetically());\n+    }\n+\n+\n+    public void testJsonFactoryLinkage()\n+    {\n+        // first, implicit factory, giving implicit linkage\n+        ObjectMapper m = new ObjectMapper();\n+        assertSame(m, m.getJsonFactory().getCodec());\n+\n+        // and then explicit factory, which should also be implicitly linked\n+        JsonFactory f = new JsonFactory();\n+        m = new ObjectMapper(f);\n+        assertSame(f, m.getJsonFactory());\n+        assertSame(m, f.getCodec());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanDeserializer.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+import java.net.URL;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializable;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * Unit tests for verifying deserialization of Beans.\n+ */\n+public class TestObjectMapperBeanDeserializer\n+    extends BaseTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    final static class CtorValueBean\n+        implements JsonSerializable // so we can output as simple String\n+    {\n+        final String _desc;\n+\n+        public CtorValueBean(String d) { _desc = d; }\n+        public CtorValueBean(int value) { _desc = String.valueOf(value); }\n+        public CtorValueBean(long value) { _desc = String.valueOf(value); }\n+\n+        @Override\n+        public void serialize(JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeString(_desc);\n+        }\n+\n+        @Override public String toString() { return _desc; }\n+\n+        @Override public boolean equals(Object o) {\n+            if (!(o instanceof CtorValueBean)) return false;\n+            CtorValueBean other = (CtorValueBean) o;\n+            return _desc.equals(other._desc);\n+        }\n+        @Override\n+        public void serializeWithType(JsonGenerator jgen,\n+                SerializerProvider provider, TypeSerializer typeSer)\n+                throws IOException, JsonProcessingException {\n+            // TODO Auto-generated method stub\n+            \n+        }\n+    }\n+\n+    final static class FactoryValueBean\n+    {\n+        final String _desc;\n+\n+        protected FactoryValueBean(String desc, int dummy) { _desc = desc; }\n+\n+        public static FactoryValueBean valueOf(String v) { return new FactoryValueBean(v, 0); }\n+        public static FactoryValueBean valueOf(int v) { return new FactoryValueBean(String.valueOf(v), 0); }\n+        public static FactoryValueBean valueOf(long v) { return new FactoryValueBean(String.valueOf(v), 0); }\n+\n+        @Override public String toString() { return _desc; }\n+    }\n+\n+    /**\n+     * Simple test bean\n+     */\n+    public final static class TestBean\n+    {\n+        int _x;\n+        long _y;\n+        String _desc;\n+        URL _url;\n+        Collection<?> _misc;\n+\n+        // Explicit constructor\n+        public TestBean(int x, long y, String desc, URL url, Collection<?> misc)\n+        {\n+            _x = x;\n+            _y = y;\n+            _desc = desc;\n+            _url = url;\n+            _misc = misc;\n+        }\n+\n+        // plus default one that is needed for deserialization\n+        public TestBean() { }\n+\n+        public String getDesc() { return _desc; }\n+        public int getX() { return _x; }\n+        public long getY() { return _y; }\n+        public URL getURL() { return _url; }\n+        public Collection<?> getMisc() { return _misc; }\n+\n+        public void setDesc(String value) { _desc = value; }\n+        public void setX(int value) { _x = value; }\n+        public void setY(long value) { _y = value; }\n+        public void setURL(URL value) { _url = value; }\n+        public void setMisc(Collection<?> value) { _misc = value; }\n+\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == null || o.getClass() != getClass()) return false;\n+            TestBean other = (TestBean) o;\n+            return (other._x == _x)\n+                && (other._y == _y)\n+                && (other._desc.equals(_desc))\n+                && (other._url.equals(_url))\n+                && (other._misc.equals(_misc))\n+                ;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"[TestBean \");\n+            sb.append(\"x=\").append(_x);\n+            sb.append(\" y=\").append(_y);\n+            sb.append(\" desc=\").append(_desc);\n+            sb.append(\" url=\").append(_url);\n+            sb.append(\" misc=\").append(_misc);\n+            sb.append(\"]\");\n+            return sb.toString();\n+        }\n+    }\n+\n+    /**\n+     * Another test bean, this one containing a typed list. Needed to ensure\n+     * that generics type information is properly accessed via mutator methods.\n+     * Note: List elements must be something other than what 'untyped' mapper\n+     * would produce from serialization.\n+     */\n+    public final static class BeanWithList\n+    {\n+        List<CtorValueBean> _beans;\n+\n+        public BeanWithList() { }\n+        public BeanWithList(List<CtorValueBean> beans) { _beans = beans; }\n+\n+        public List<CtorValueBean> getBeans() { return _beans; }\n+\n+        public void setBeans(List<CtorValueBean> beans) {\n+            _beans = beans;\n+        }\n+\n+        @Override\n+        public int hashCode() { return (_beans == null) ? -1 : _beans.size(); }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof BeanWithList)) return false;\n+            BeanWithList other = BeanWithList.class.cast(o);\n+            return _beans.equals(other._beans);\n+        }\n+\n+        @Override\n+            public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"[Bean, list \");\n+            if (_beans == null) {\n+                sb.append(\"NULL\");\n+            } else {\n+                sb.append('(').append(_beans.size()).append('/');\n+                sb.append(_beans.getClass().getName()).append(\") \");\n+                boolean type = false;\n+                for (CtorValueBean bean : _beans) {\n+                    if (!type) {\n+                        sb.append(\"(\").append(bean.getClass().getSimpleName()).append(\")\");\n+                        type = true;\n+                    }\n+                    sb.append(bean);\n+                    sb.append(' ');\n+                }\n+            }\n+            sb.append(']');\n+            return sb.toString();\n+        }\n+    }\n+\n+    /*\n+    /////////////////////////////////////////////////\n+    // Deserialization from simple types (String, int)\n+    /////////////////////////////////////////////////\n+     */\n+\n+    public void testFromStringCtor() throws Exception\n+    {\n+        CtorValueBean result = new ObjectMapper().readValue(\"\\\"abc\\\"\", CtorValueBean.class);\n+        assertEquals(\"abc\", result.toString());\n+    }\n+\n+    public void testFromIntCtor() throws Exception\n+    {\n+        CtorValueBean result = new ObjectMapper().readValue(\"13\", CtorValueBean.class);\n+        assertEquals(\"13\", result.toString());\n+    }\n+\n+    public void testFromLongCtor() throws Exception\n+    {\n+        // Must use something that is forced as Long...\n+        long value = 12345678901244L;\n+        CtorValueBean result = new ObjectMapper().readValue(\"\"+value, CtorValueBean.class);\n+        assertEquals(\"\"+value, result.toString());\n+    }\n+\n+    public void testFromStringFactory() throws Exception\n+    {\n+        FactoryValueBean result = new ObjectMapper().readValue(\"\\\"abc\\\"\", FactoryValueBean.class);\n+        assertEquals(\"abc\", result.toString());\n+    }\n+\n+    public void testFromIntFactory() throws Exception\n+    {\n+        FactoryValueBean result = new ObjectMapper().readValue(\"13\", FactoryValueBean.class);\n+        assertEquals(\"13\", result.toString());\n+    }\n+\n+    public void testFromLongFactory() throws Exception\n+    {\n+        // Must use something that is forced as Long...\n+        long value = 12345678901244L;\n+        FactoryValueBean result = new ObjectMapper().readValue(\"\"+value, FactoryValueBean.class);\n+        assertEquals(\"\"+value, result.toString());\n+    }\n+\n+    /*\n+    /////////////////////////////////////////////////\n+    // Deserialization from Json Object\n+    /////////////////////////////////////////////////\n+     */\n+\n+    public void testSimpleBean() throws Exception\n+    {\n+        ArrayList<Object> misc = new ArrayList<Object>();\n+        misc.add(\"xyz\");\n+        misc.add(42);\n+        misc.add(null);\n+        misc.add(Boolean.TRUE);\n+        TestBean bean = new TestBean(13, -900L, \"\\\"test\\\"\", new URL(\"http://foobar.com\"), misc);\n+\n+        // Hmmh. We probably should use serializer too... easier\n+        StringWriter sw = new StringWriter();\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.writeValue(sw, bean);\n+\n+        TestBean result = new ObjectMapper().readValue(sw.toString(), TestBean.class);\n+        assertEquals(bean, result);\n+    }\n+\n+    public void testListBean() throws Exception\n+    {\n+        final int COUNT = 13;\n+        ArrayList<CtorValueBean> beans = new ArrayList<CtorValueBean>();\n+        for (int i = 0; i < COUNT; ++i) {\n+            beans.add(new CtorValueBean(i));\n+        }\n+        BeanWithList bean = new BeanWithList(beans);\n+\n+        StringWriter sw = new StringWriter();\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.writeValue(sw, bean);\n+\n+        BeanWithList result = new ObjectMapper().readValue(sw.toString(), BeanWithList.class);\n+        assertEquals(bean, result);\n+    }\n+\n+    /**\n+     * Also, let's verify that unknown fields cause an exception with default\n+     * settings.\n+     */\n+    public void testUnknownFields() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            TestBean bean = mapper.readValue(\"{ \\\"foobar\\\" : 3 }\", TestBean.class);\n+            fail(\"Expected an exception, got bean: \"+bean);\n+        } catch (JsonMappingException jse) {\n+            ;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanSerializer.java\n+package com.fasterxml.jackson.databind;\n+\n+\n+import java.io.*;\n+import java.net.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * This unit test suite tries to verify that the \"Native\" java type\n+ * mapper can properly serialize Java core objects to JSON.\n+ *\n+ * @author Scott Dixon\n+ */\n+public class TestObjectMapperBeanSerializer\n+    extends BaseTest\n+{\n+    /**\n+     * Sanity test to ensure the pieces all work when put together.\n+     */\n+    public void testComplexObject()\n+        throws Exception\n+    {\n+        FixtureObject  aTestObj = new FixtureObject();\n+        ObjectMapper aMapper  = new ObjectMapper();\n+        StringWriter aWriter = new StringWriter();\n+        JsonGenerator aGen = new JsonFactory().createJsonGenerator(aWriter);\n+        aMapper.writeValue(aGen, aTestObj);\n+        aGen.close();\n+\n+        JsonParser jp = new JsonFactory().createJsonParser(new StringReader(aWriter.toString()));\n+\n+        assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+\n+        while (jp.nextToken() != JsonToken.END_OBJECT) {\n+            assertEquals(JsonToken.FIELD_NAME, jp.getCurrentToken());\n+            String name = jp.getCurrentName();\n+            JsonToken t = jp.nextToken();\n+\n+            if (name.equals(\"uri\")) {\n+                assertToken(JsonToken.VALUE_STRING, t);\n+                assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp));\n+            } else if (name.equals(\"url\")) {\n+                assertToken(JsonToken.VALUE_STRING, t);\n+                assertEquals(FixtureObject.VALUE_URSTR, getAndVerifyText(jp));\n+            } else if (name.equals(\"testNull\")) {\n+                assertToken(JsonToken.VALUE_NULL, t);\n+            } else if (name.equals(\"testString\")) {\n+                assertToken(JsonToken.VALUE_STRING, t);\n+                assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp));\n+            } else if (name.equals(\"testBoolean\")) {\n+                assertToken(JsonToken.VALUE_TRUE, t);\n+            } else if (name.equals(\"testEnum\")) {\n+                assertToken(JsonToken.VALUE_STRING, t);\n+                assertEquals(FixtureObject.VALUE_ENUM.toString(),getAndVerifyText(jp));\n+            } else if (name.equals(\"testInteger\")) {\n+                assertToken(JsonToken.VALUE_NUMBER_INT, t);\n+                assertEquals(jp.getIntValue(),FixtureObject.VALUE_INT);\n+            } else if (name.equals(\"testLong\")) {\n+                assertToken(JsonToken.VALUE_NUMBER_INT, t);\n+                assertEquals(jp.getLongValue(),FixtureObject.VALUE_LONG);\n+            } else if (name.equals(\"testBigInteger\")) {\n+                assertToken(JsonToken.VALUE_NUMBER_INT, t);\n+                assertEquals(jp.getLongValue(),FixtureObject.VALUE_BIGINT.longValue());\n+            } else if (name.equals(\"testBigDecimal\")) {\n+                assertToken(JsonToken.VALUE_NUMBER_FLOAT, t);\n+                assertEquals(jp.getText(), FixtureObject.VALUE_BIGDEC.toString());\n+            } else if (name.equals(\"testCharacter\")) {\n+                assertToken(JsonToken.VALUE_STRING, t);\n+                assertEquals(String.valueOf(FixtureObject.VALUE_CHAR), getAndVerifyText(jp));\n+            } else if (name.equals(\"testShort\")) {\n+                assertToken(JsonToken.VALUE_NUMBER_INT, t);\n+                assertEquals(jp.getIntValue(),FixtureObject.VALUE_SHORT);\n+            } else if (name.equals(\"testByte\")) {\n+                assertToken(JsonToken.VALUE_NUMBER_INT, t);\n+                assertEquals(jp.getIntValue(),FixtureObject.VALUE_BYTE);\n+            } else if (name.equals(\"testFloat\")) {\n+                assertToken(JsonToken.VALUE_NUMBER_FLOAT, t);\n+                assertEquals(jp.getDecimalValue().floatValue(),FixtureObject.VALUE_FLOAT);\n+            } else if (name.equals(\"testDouble\")) {\n+                assertToken(JsonToken.VALUE_NUMBER_FLOAT, t);\n+                assertEquals(jp.getDoubleValue(),FixtureObject.VALUE_DBL);\n+            } else if (name.equals(\"testStringBuffer\")) {\n+                assertToken(JsonToken.VALUE_STRING, t);\n+                assertEquals(FixtureObject.VALUE_STRING, getAndVerifyText(jp));\n+            } else if (name.equals(\"testError\")) {\n+                // More complicated...\n+                assertToken(JsonToken.START_OBJECT, t);\n+\n+                //getTestError->Exception::getCause\n+                \n+                while (jp.nextToken() == JsonToken.FIELD_NAME) {\n+                    name = jp.getCurrentName();\n+                    if (name.equals(\"cause\")) {\n+                        assertEquals(JsonToken.VALUE_NULL, jp.nextToken());\n+                    } else if (name.equals(\"message\")) {\n+                        assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+                        assertEquals(FixtureObject.VALUE_ERRTXT, getAndVerifyText(jp));\n+                    } else if (name.equals(\"localizedMessage\")) {\n+                        assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+                    } else if (name.equals(\"stackTrace\")) {\n+                        assertEquals(JsonToken.START_ARRAY,jp.nextToken());\n+                        int i = 0;\n+                        while(jp.nextToken() != JsonToken.END_ARRAY) {\n+                            if(i >= 100000) {\n+                                assertTrue(\"Probably run away loop in test. StackTrack Array was not properly closed.\",false);\n+                            }\n+                        }\n+                    } else {\n+                        fail(\"Unexpected field name '\"+name+\"'\");\n+                    }\n+                }\n+                //CLOSE OF THE EXCEPTION\n+                assertEquals(JsonToken.END_OBJECT, jp.getCurrentToken());\n+            } else {\n+                fail(\"Unexpected field, name '\"+name+\"'\");\n+            }\n+        }\n+\n+        //END OF TOKEN PARSING\n+        assertNull(jp.nextToken());\n+    }\n+\n+    private static enum EFixtureEnum\n+    {\n+        THIS_IS_AN_ENUM_VALUE_0,\n+        THIS_IS_AN_ENUM_VALUE_1,\n+        THIS_IS_AN_ENUM_VALUE_2,\n+        THIS_IS_AN_ENUM_VALUE_3,\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private static class FixtureObjectBase\n+    {\n+        public static final String       VALUE_STRING = \"foobar\";\n+        public static final EFixtureEnum VALUE_ENUM   = EFixtureEnum.THIS_IS_AN_ENUM_VALUE_2;\n+        public static final int          VALUE_INT    = Integer.MIN_VALUE;\n+        public static final long         VALUE_LONG   = Long.MIN_VALUE;\n+        public static final BigInteger   VALUE_BIGINT = new BigInteger((new Long(Long.MAX_VALUE)).toString());\n+        public static final BigDecimal   VALUE_BIGDEC = new BigDecimal((new Double(Double.MAX_VALUE)).toString());\n+        // this is not necessarily a good char to check\n+        public static final char         VALUE_CHAR   = Character.MAX_VALUE;\n+        public static final short        VALUE_SHORT  = Short.MAX_VALUE;\n+        public static final byte         VALUE_BYTE   = Byte.MAX_VALUE;\n+        public static final float        VALUE_FLOAT  = Float.MAX_VALUE;\n+        public static final double       VALUE_DBL    = Double.MAX_VALUE;\n+        public static final String       VALUE_ERRTXT = \"This is the message text for the test error.\";\n+\n+        public static final String       VALUE_URSTR  = \"http://jackson.codehaus.org/hi?var1=foo%20bar\";\n+\n+        public URL getURL() throws IOException\n+        {\n+            return new URL(VALUE_URSTR);\n+        }\n+\n+        public URI getURI() throws IOException\n+        {\n+            try {\n+                return new URI(VALUE_URSTR);\n+            } catch (Exception e) {\n+                throw new IllegalArgumentException(e);\n+            }\n+        }\n+        public String getTestNull()\n+        {\n+            return null;\n+        }\n+        public String getTestString()\n+        {\n+            return VALUE_STRING;\n+        }\n+        public boolean getTestBoolean()\n+        {\n+            return true;\n+        }\n+        public EFixtureEnum getTestEnum()\n+        {\n+            return VALUE_ENUM;\n+        }\n+        public int getTestInteger()\n+        {\n+            return VALUE_INT;\n+        }\n+        public long getTestLong()\n+        {\n+            return VALUE_LONG;\n+        }\n+        public BigInteger getTestBigInteger()\n+        {\n+            return VALUE_BIGINT;\n+        }\n+        public BigDecimal getTestBigDecimal()\n+        {\n+            return VALUE_BIGDEC;\n+        }\n+        public char getTestCharacter()\n+        {\n+            return VALUE_CHAR;\n+        }\n+        public short getTestShort()\n+        {\n+            return VALUE_SHORT;\n+        }\n+        public byte getTestByte()\n+        {\n+            return VALUE_BYTE;\n+        }\n+        public float getTestFloat()\n+        {\n+            return VALUE_FLOAT;\n+        }\n+        public double getTestDouble()\n+        {\n+            return VALUE_DBL;\n+        }\n+        public StringBuffer getTestStringBuffer()\n+        {\n+            return new StringBuffer(VALUE_STRING);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private static class FixtureObject extends FixtureObjectBase\n+    {\n+        public Exception getTestError()\n+        {\n+            return new Exception(VALUE_ERRTXT);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestParserUsingMapper.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.CharacterEscapes;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestParserUsingMapper  extends com.fasterxml.jackson.test.BaseTest\n+{\n+    final static int TWO_BYTE_ESCAPED = 0x111;\n+    final static int THREE_BYTE_ESCAPED = 0x1111;\n+\n+    final static SerializedString TWO_BYTE_ESCAPED_STRING = new SerializedString(\"&111;\");\n+    final static SerializedString THREE_BYTE_ESCAPED_STRING = new SerializedString(\"&1111;\");\n+    \n+    final static class Pojo\n+    {\n+        int _x;\n+\n+        public void setX(int x) { _x = x; }\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Helper types\n+    /********************************************************\n+     */\n+\n+    /**\n+     * Trivial simple custom escape definition set.\n+     */\n+    static class MyEscapes extends CharacterEscapes\n+    {\n+        \n+        private final int[] _asciiEscapes;\n+\n+        public MyEscapes() {\n+            _asciiEscapes = standardAsciiEscapesForJSON();\n+            _asciiEscapes['a'] = 'A'; // to basically give us \"\\A\"\n+            _asciiEscapes['b'] = CharacterEscapes.ESCAPE_STANDARD; // too force \"\\u0062\"\n+            _asciiEscapes['d'] = CharacterEscapes.ESCAPE_CUSTOM;\n+        }\n+        \n+        @Override\n+        public int[] getEscapeCodesForAscii() {\n+            return _asciiEscapes;\n+        }\n+\n+        @Override\n+        public SerializableString getEscapeSequence(int ch)\n+        {\n+            if (ch == 'd') {\n+                return new SerializedString(\"[D]\");\n+            }\n+            if (ch == TWO_BYTE_ESCAPED) {\n+                return TWO_BYTE_ESCAPED_STRING;\n+            }\n+            if (ch == THREE_BYTE_ESCAPED) {\n+                return THREE_BYTE_ESCAPED_STRING;\n+            }\n+            return null;\n+        }\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Unit tests\n+    /********************************************************\n+     */\n+\n+    public void testReadingArrayAsTree() throws IOException\n+    {\n+        JsonFactory jf = new MappingJsonFactory();\n+        final String JSON = \"[ 1, 2, false ]\";\n+\n+        for (int i = 0; i < 2; ++i) {\n+            JsonParser jp = jf.createJsonParser(new StringReader(JSON));\n+            // whether to try advancing first or not? Try both\n+            if (i == 0) {\n+                assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            }\n+            JsonNode root = jp.readValueAsTree();\n+            jp.close();\n+            assertTrue(root.isArray());\n+            assertEquals(3, root.size());\n+            assertEquals(1, root.get(0).getIntValue());\n+            assertEquals(2, root.get(1).getIntValue());\n+            assertFalse(root.get(2).getBooleanValue());\n+        }\n+    }\n+    \n+    public void testPojoReading() throws IOException\n+    {\n+        JsonFactory jf = new MappingJsonFactory();\n+        final String JSON = \"{ \\\"x\\\" : 9 }\";\n+        JsonParser jp = jf.createJsonParser(new StringReader(JSON));\n+\n+        // let's try first by advancing:\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        Pojo p = jp.readValueAs(Pojo.class);\n+        assertEquals(9, p._x);\n+        jp.close();\n+\n+        // and without\n+        jp = jf.createJsonParser(new StringReader(JSON));\n+        p = jp.readValueAs(Pojo.class);\n+        assertEquals(9, p._x);\n+        jp.close();\n+    }\n+\n+    /**\n+     * Test similar to above, but instead reads a sequence of values\n+     */\n+    public void testIncrementalPojoReading()\n+        throws IOException\n+    {\n+        JsonFactory jf = new MappingJsonFactory();\n+        final String JSON = \"[ 1, true, null, \\\"abc\\\" ]\";\n+        JsonParser jp = jf.createJsonParser(new StringReader(JSON));\n+\n+        // let's advance past array start to prevent full binding\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(Integer.valueOf(1), jp.readValueAs(Integer.class));\n+        assertEquals(Boolean.TRUE, jp.readValueAs(Boolean.class));\n+        /* note: null can be returned both when there is no more\n+         * data in current scope, AND when Json null literal is\n+         * bound!\n+         */\n+        assertNull(jp.readValueAs(Object.class));\n+        // but we can verify that it was Json null by:\n+        assertEquals(JsonToken.VALUE_NULL, jp.getLastClearedToken());\n+\n+        assertEquals(\"abc\", jp.readValueAs(String.class));\n+\n+        // this null is for actually hitting the END_ARRAY\n+        assertNull(jp.readValueAs(Object.class));\n+        assertEquals(JsonToken.END_ARRAY, jp.getLastClearedToken());\n+\n+        // afrer which there should be nothing to advance to:\n+        assertNull(jp.nextToken());\n+\n+        jp.close();\n+    }\n+\n+    public void testPojoReadingFailing()\n+        throws IOException\n+    {\n+        // regular factory can't do it, without a call to setCodec()\n+        JsonFactory jf = new JsonFactory();\n+        try {\n+            final String JSON = \"{ \\\"x\\\" : 9 }\";\n+            JsonParser jp = jf.createJsonParser(new StringReader(JSON));\n+            Pojo p = jp.readValueAs(Pojo.class);\n+            fail(\"Expected an exception: got \"+p);\n+        } catch (IllegalStateException e) {\n+            verifyException(e, \"No ObjectCodec defined\");\n+        }\n+    }\n+    \n+    // for [JACKSON-672]\n+    public void testEscapingUsingMapper() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);\n+        assertEquals(quote(\"\\\\u0101\"), mapper.writeValueAsString(String.valueOf((char) 257)));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestReadValues.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestReadValues extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static class Bean {\n+        public int a;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests; root-level value sequences via Mapper\n+    /**********************************************************\n+     */\n+\n+    public void testRootBeans() throws Exception\n+    {\n+        final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n+        ObjectMapper mapper = new ObjectMapper();\n+        Iterator<Bean> it = mapper.reader(Bean.class).readValues(JSON);\n+\n+        assertTrue(it.hasNext());\n+        Bean b = it.next();\n+        assertEquals(3, b.a);\n+        assertTrue(it.hasNext());\n+        b = it.next();\n+        assertEquals(27, b.a);\n+        assertFalse(it.hasNext());\n+    }\n+\n+    public void testRootMaps() throws Exception\n+    {\n+        final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n+        ObjectMapper mapper = new ObjectMapper();\n+        Iterator<Map<?,?>> it = mapper.reader(Map.class).readValues(JSON);\n+\n+        assertTrue(it.hasNext());\n+        Map<?,?> map = it.next();\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(3), map.get(\"a\"));\n+        assertTrue(it.hasNext());\n+        map = it.next();\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(27), map.get(\"a\"));\n+        assertFalse(it.hasNext());\n+    }\n+\n+    public void testRootArrays() throws Exception\n+    {\n+        final String JSON = \"[1][3]\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        Iterator<int[]> it = mapper.reader(int[].class).readValues(JSON);\n+\n+        assertTrue(it.hasNext());\n+        int[] array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(1, array[0]);\n+        assertTrue(it.hasNext());\n+        array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(3, array[0]);\n+        assertFalse(it.hasNext());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests; root-level value sequences via JsonParser\n+    /**********************************************************\n+     */\n+\n+    public void testRootBeansWithParser() throws Exception\n+    {\n+        final String JSON = \"{\\\"a\\\":3}{\\\"a\\\":27}  \";\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonParser jp = mapper.getJsonFactory().createJsonParser(JSON);\n+        \n+        Iterator<Bean> it = jp.readValuesAs(Bean.class);\n+\n+        assertTrue(it.hasNext());\n+        Bean b = it.next();\n+        assertEquals(3, b.a);\n+        assertTrue(it.hasNext());\n+        b = it.next();\n+        assertEquals(27, b.a);\n+        assertFalse(it.hasNext());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests; non-root arrays\n+    /**********************************************************\n+     */\n+\n+    public void testNonRootBeans() throws Exception\n+    {\n+        final String JSON = \"{\\\"leaf\\\":[{\\\"a\\\":3},{\\\"a\\\":27}]}\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonParser jp = mapper.getJsonFactory().createJsonParser(JSON);\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        \n+        Iterator<Bean> it = mapper.reader(Bean.class).readValues(jp);\n+\n+        assertTrue(it.hasNext());\n+        Bean b = it.next();\n+        assertEquals(3, b.a);\n+        assertTrue(it.hasNext());\n+        b = it.next();\n+        assertEquals(27, b.a);\n+        assertFalse(it.hasNext());\n+        jp.close();\n+    }\n+\n+    public void testNonRootMaps() throws Exception\n+    {\n+        final String JSON = \"[{\\\"a\\\":3},{\\\"a\\\":27}]\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonParser jp = mapper.getJsonFactory().createJsonParser(JSON);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        Iterator<Map<?,?>> it = mapper.reader(Map.class).readValues(jp);\n+\n+        assertTrue(it.hasNext());\n+        Map<?,?> map = it.next();\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(3), map.get(\"a\"));\n+        assertTrue(it.hasNext());\n+        map = it.next();\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(27), map.get(\"a\"));\n+        assertFalse(it.hasNext());\n+        jp.close();\n+    }\n+\n+    public void testNonRootArrays() throws Exception\n+    {\n+        final String JSON = \"[[1],[3]]\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonParser jp = mapper.getJsonFactory().createJsonParser(JSON);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        Iterator<int[]> it = mapper.readValues(jp, int[].class);\n+\n+        assertTrue(it.hasNext());\n+        int[] array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(1, array[0]);\n+        assertTrue(it.hasNext());\n+        array = it.next();\n+        assertEquals(1, array.length);\n+        assertEquals(3, array[0]);\n+        assertFalse(it.hasNext());\n+        jp.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestRootName.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+\n+public class TestRootName extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    @JsonRootName(\"rudy\")\n+    static class Bean {\n+        public int a = 3;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testRootViaMapper() throws Exception\n+    {\n+        ObjectMapper mapper = rootMapper();\n+        String json = mapper.writeValueAsString(new Bean());\n+        assertEquals(\"{\\\"rudy\\\":{\\\"a\\\":3}}\", json);\n+        Bean bean = mapper.readValue(json, Bean.class);\n+        assertNotNull(bean);\n+    }\n+\n+    public void testRootViaWriterAndReader() throws Exception\n+    {\n+        ObjectMapper mapper = rootMapper();\n+        String json = mapper.writer().writeValueAsString(new Bean());\n+        assertEquals(\"{\\\"rudy\\\":{\\\"a\\\":3}}\", json);\n+        Bean bean = mapper.reader(Bean.class).readValue(json);\n+        assertNotNull(bean);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    private ObjectMapper rootMapper()\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(SerializationConfig.Feature.WRAP_ROOT_VALUE, true);\n+        mapper.configure(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE, true);\n+        return mapper;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestStdDateFormat.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.util.StdDateFormat;\n+\n+public class TestStdDateFormat\n+    extends BaseMapTest\n+{\n+    public void testFactories() {\n+        assertNotNull(StdDateFormat.getBlueprintISO8601Format());\n+        assertNotNull(StdDateFormat.getBlueprintRFC1123Format());\n+        TimeZone tz = TimeZone.getTimeZone(\"GMT\");\n+        assertNotNull(StdDateFormat.getISO8601Format(tz));\n+        assertNotNull(StdDateFormat.getRFC1123Format(tz));\n+    }\n+\n+    public void testInvalid() {\n+        StdDateFormat std = new StdDateFormat();\n+        try {\n+            std.parse(\"foobar\");\n+        } catch (java.text.ParseException e) {\n+            verifyException(e, \"Can not parse\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestStdNamingStrategies.java\n+package com.fasterxml.jackson.databind;\n+\n+import static com.fasterxml.jackson.databind.PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.PropertyNamingStrategy;\n+import com.fasterxml.jackson.databind.TestNamingStrategy.PersonBean;\n+\n+/**\n+ * Unit tests to verify functioning of \n+ * {@link PropertyNamingStrategy#CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES} \n+ * inside the context of an ObjectMapper.\n+ * CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES was added in Jackson 1.9, \n+ * as per [JACKSON-598].\n+ * \n+ * @since 1.9\n+ */\n+public class TestStdNamingStrategies extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    @JsonPropertyOrder({\"www\", \"some_url\", \"some_uris\"})\n+    static class Acronyms\n+    {\n+        public String WWW;\n+        public String someURL;\n+        public String someURIs;\n+        \n+        public Acronyms() {this(null, null, null);}\n+        public Acronyms(String WWW, String someURL, String someURIs)\n+        {\n+            this.WWW = WWW;\n+            this.someURL = someURL;\n+            this.someURIs = someURIs;\n+        }\n+    }\n+    \n+    @JsonPropertyOrder({\"from_user\", \"user\", \"from$user\", \"from7user\", \"_\"})\n+    static class UnchangedNames\n+    {\n+        public String from_user;\n+        public String _user;\n+        public String from$user;\n+        public String from7user;\n+        public String _;\n+        \n+        public UnchangedNames() {this(null, null, null, null, null);}\n+        public UnchangedNames(String from_user, String _user, String from$user, String from7user, String _)\n+        {\n+            this.from_user = from_user;\n+            this._user = _user;\n+            this.from$user = from$user;\n+            this.from7user = from7user;\n+            this._ = _;\n+        }\n+    }\n+    \n+    @JsonPropertyOrder({\"results\", \"user\", \"__\", \"$_user\"})\n+    static class OtherNonStandardNames\n+    {\n+        public String Results;\n+        public String _User;\n+        public String ___;\n+        public String $User;\n+        \n+        public OtherNonStandardNames() {this(null, null, null, null);}\n+        public OtherNonStandardNames(String Results, String _User, String ___, String $User)\n+        {\n+            this.Results = Results;\n+            this._User = _User;\n+            this.___ = ___;\n+            this.$User = $User;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Set up\n+    /**********************************************************\n+     */\n+\n+    public static List<Object[]> NAME_TRANSLATIONS = Arrays.asList(new Object[][] {\n+                {null, null},\n+                {\"\", \"\"},\n+                {\"a\", \"a\"},\n+                {\"abc\", \"abc\"},\n+                {\"1\", \"1\"},\n+                {\"123\", \"123\"},\n+                {\"1a\", \"1a\"},\n+                {\"a1\", \"a1\"},\n+                {\"$\", \"$\"},\n+                {\"$a\", \"$a\"},\n+                {\"a$\", \"a$\"},\n+                {\"$_a\", \"$_a\"},\n+                {\"a_$\", \"a_$\"},\n+                {\"a$a\", \"a$a\"},\n+                {\"$A\", \"$_a\"},\n+                {\"$_A\", \"$_a\"},\n+                {\"_\", \"_\"},\n+                {\"__\", \"_\"},\n+                {\"___\", \"__\"},\n+                {\"A\", \"a\"},\n+                {\"A1\", \"a1\"},\n+                {\"1A\", \"1_a\"},\n+                {\"_a\", \"a\"},\n+                {\"_A\", \"a\"},\n+                {\"a_a\", \"a_a\"},\n+                {\"a_A\", \"a_a\"},\n+                {\"A_A\", \"a_a\"},\n+                {\"A_a\", \"a_a\"},\n+                {\"WWW\", \"www\"},\n+                {\"someURI\", \"some_uri\"},\n+                {\"someURIs\", \"some_uris\"},\n+                {\"Results\", \"results\"},\n+                {\"_Results\", \"results\"},\n+                {\"_results\", \"results\"},\n+                {\"__results\", \"_results\"},\n+                {\"__Results\", \"_results\"},\n+                {\"___results\", \"__results\"},\n+                {\"___Results\", \"__results\"},\n+                {\"userName\", \"user_name\"},\n+                {\"user_name\", \"user_name\"},\n+                {\"user__name\", \"user__name\"},\n+                {\"UserName\", \"user_name\"},\n+                {\"User_Name\", \"user_name\"},\n+                {\"User__Name\", \"user__name\"},\n+                {\"_user_name\", \"user_name\"},\n+                {\"_UserName\", \"user_name\"},\n+                {\"_User_Name\", \"user_name\"},\n+                {\"UGLY_NAME\", \"ugly_name\"},\n+                {\"_Bars\", \"bars\" }\n+    });\n+    \n+    private ObjectMapper mapper;\n+    \n+    @Override\n+    public void setUp() throws Exception\n+    {\n+        super.setUp();\n+        mapper = new ObjectMapper();\n+        mapper.setPropertyNamingStrategy(CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods for CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Unit test to verify translations of \n+     * {@link PropertyNamingStrategy#CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES} \n+     * outside the context of an ObjectMapper.\n+     * CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES was added in Jackson 1.9, \n+     * as per [JACKSON-598].\n+     */\n+    @Test\n+    public void testLowerCaseStrategyStandAlone()\n+    {\n+        for (Object[] pair : NAME_TRANSLATIONS) {\n+            String translatedJavaName = PropertyNamingStrategy.CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES.nameForField(null, null,\n+                    (String) pair[0]);\n+            assertEquals((String) pair[1], translatedJavaName);\n+        }\n+    }\n+    \n+    public void testLowerCaseTranslations() throws Exception\n+    {\n+        // First serialize\n+        String json = mapper.writeValueAsString(new PersonBean(\"Joe\", \"Sixpack\", 42));\n+        assertEquals(\"{\\\"first_name\\\":\\\"Joe\\\",\\\"last_name\\\":\\\"Sixpack\\\",\\\"age\\\":42}\", json);\n+        \n+        // then deserialize\n+        PersonBean result = mapper.readValue(json, PersonBean.class);\n+        assertEquals(\"Joe\", result.firstName);\n+        assertEquals(\"Sixpack\", result.lastName);\n+        assertEquals(42, result.age);\n+    }\n+    \n+    public void testLowerCaseAcronymsTranslations() throws Exception\n+    {\n+        // First serialize\n+        String json = mapper.writeValueAsString(new Acronyms(\"world wide web\", \"http://jackson.codehaus.org\", \"/path1/,/path2/\"));\n+        assertEquals(\"{\\\"www\\\":\\\"world wide web\\\",\\\"some_url\\\":\\\"http://jackson.codehaus.org\\\",\\\"some_uris\\\":\\\"/path1/,/path2/\\\"}\", json);\n+        \n+        // then deserialize\n+        Acronyms result = mapper.readValue(json, Acronyms.class);\n+        assertEquals(\"world wide web\", result.WWW);\n+        assertEquals(\"http://jackson.codehaus.org\", result.someURL);\n+        assertEquals(\"/path1/,/path2/\", result.someURIs);\n+    }\n+\n+    public void testLowerCaseOtherNonStandardNamesTranslations() throws Exception\n+    {\n+        // First serialize\n+        String json = mapper.writeValueAsString(new OtherNonStandardNames(\"Results\", \"_User\", \"___\", \"$User\"));\n+        assertEquals(\"{\\\"results\\\":\\\"Results\\\",\\\"user\\\":\\\"_User\\\",\\\"__\\\":\\\"___\\\",\\\"$_user\\\":\\\"$User\\\"}\", json);\n+        \n+        // then deserialize\n+        OtherNonStandardNames result = mapper.readValue(json, OtherNonStandardNames.class);\n+        assertEquals(\"Results\", result.Results);\n+        assertEquals(\"_User\", result._User);\n+        assertEquals(\"___\", result.___);\n+        assertEquals(\"$User\", result.$User);\n+    }\n+\n+    public void testLowerCaseUnchangedNames() throws Exception\n+    {\n+        // First serialize\n+        String json = mapper.writeValueAsString(new UnchangedNames(\"from_user\", \"_user\", \"from$user\", \"from7user\", \"_\"));\n+        assertEquals(\"{\\\"from_user\\\":\\\"from_user\\\",\\\"user\\\":\\\"_user\\\",\\\"from$user\\\":\\\"from$user\\\",\\\"from7user\\\":\\\"from7user\\\",\\\"_\\\":\\\"_\\\"}\", json);\n+        \n+        // then deserialize\n+        UnchangedNames result = mapper.readValue(json, UnchangedNames.class);\n+        assertEquals(\"from_user\", result.from_user);\n+        assertEquals(\"_user\", result._user);\n+        assertEquals(\"from$user\", result.from$user);\n+        assertEquals(\"from7user\", result.from7user);\n+        assertEquals(\"_\", result._);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestToJavaType.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Unit tests for verifying \"old\" data binding from Json to JDK objects;\n+ * one that only uses core JDK types; wrappers, Maps and Lists.\n+ */\n+public class TestToJavaType\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic void testSampleDoc()\n+        throws Exception\n+    {\n+        final String JSON = SAMPLE_DOC_JSON_SPEC;\n+\n+        JsonFactory jf = new JsonFactory();\n+\n+        /* To get \"untyped\" Mapping (to Maps, Lists, instead of beans etc),\n+         * we'll specify plain old Object.class as the target.\n+         */\n+        Object root = new ObjectMapper().readValue(jf.createJsonParser(new StringReader(JSON)), Object.class);\n+\n+        assertType(root, Map.class);\n+        Map<?,?> rootMap = (Map<?,?>) root;\n+        assertEquals(1, rootMap.size());\n+        Map.Entry<?,?> rootEntry =  rootMap.entrySet().iterator().next();\n+        assertEquals(\"Image\", rootEntry.getKey());\n+        Object image = rootEntry.getValue();\n+        assertType(image, Map.class);\n+        Map<?,?> imageMap = (Map<?,?>) image;\n+        assertEquals(5, imageMap.size());\n+\n+        Object value = imageMap.get(\"Width\");\n+        assertType(value, Integer.class);\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_WIDTH), value);\n+\n+        value = imageMap.get(\"Height\");\n+        assertType(value, Integer.class);\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), value);\n+\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, imageMap.get(\"Title\"));\n+\n+        // Another Object, \"thumbnail\"\n+        value = imageMap.get(\"Thumbnail\");\n+        assertType(value, Map.class);\n+        Map<?,?> tnMap = (Map<?,?>) value;\n+        assertEquals(3, tnMap.size());\n+\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), tnMap.get(\"Height\"));\n+        // for some reason, width is textual, not numeric...\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, tnMap.get(\"Width\"));\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, tnMap.get(\"Url\"));\n+\n+        // And then number list, \"IDs\"\n+        value = imageMap.get(\"IDs\");\n+        assertType(value, List.class);\n+        List<Object> ids = (List<Object>) value;\n+        assertEquals(4, ids.size());\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), ids.get(0));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), ids.get(1));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), ids.get(2));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), ids.get(3));\n+\n+        // and that's all folks!\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestUpdateValue.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+\n+public class TestUpdateValue extends BaseMapTest\n+{\n+    /*\n+    /********************************************************\n+    /* Helper types\n+    /********************************************************\n+     */\n+\n+    static class Bean {\n+        public String a = \"a\";\n+        public String b = \"b\";\n+\n+        public int[] c = new int[] { 1, 2, 3 };\n+\n+        public Bean child = null;\n+    }\n+\n+    static class XYBean {\n+        public int x, y;\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Unit tests\n+    /********************************************************\n+     */\n+    \n+    public void testBeanUpdate() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Bean bean = new Bean();\n+        assertEquals(\"b\", bean.b);\n+        assertEquals(3, bean.c.length);\n+        assertNull(bean.child);\n+\n+        Object ob = m.readerForUpdating(bean).readValue(\"{ \\\"b\\\":\\\"x\\\", \\\"c\\\":[4,5], \\\"child\\\":{ \\\"a\\\":\\\"y\\\"} }\");\n+        assertSame(ob, bean);\n+\n+        assertEquals(\"a\", bean.a);\n+        assertEquals(\"x\", bean.b);\n+        assertArrayEquals(new int[] { 4, 5 }, bean.c);\n+\n+        Bean child = bean.child;\n+        assertNotNull(child);\n+        assertEquals(\"y\", child.a);\n+        assertEquals(\"b\", child.b);\n+        assertArrayEquals(new int[] { 1, 2, 3 }, child.c);\n+        assertNull(child.child);\n+    }\n+\n+    public void testListUpdate() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        List<String> strs = new ArrayList<String>();\n+        strs.add(\"a\");\n+        // for lists, we will be appending entries\n+        Object ob = m.readerForUpdating(strs).readValue(\"[ \\\"b\\\", \\\"c\\\", \\\"d\\\" ]\");\n+        assertSame(strs, ob);\n+        assertEquals(4, strs.size());\n+        assertEquals(\"a\", strs.get(0));\n+        assertEquals(\"b\", strs.get(1));\n+        assertEquals(\"c\", strs.get(2));\n+        assertEquals(\"d\", strs.get(3));\n+    }\n+\n+    public void testMapUpdate() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,String> strs = new HashMap<String,String>();\n+        strs.put(\"a\", \"a\");\n+        strs.put(\"b\", \"b\");\n+        // for maps, we will be adding and/or overwriting entries\n+        Object ob = m.readerForUpdating(strs).readValue(\"{ \\\"c\\\" : \\\"c\\\", \\\"a\\\" : \\\"z\\\" }\");\n+        assertSame(strs, ob);\n+        assertEquals(3, strs.size());\n+        assertEquals(\"z\", strs.get(\"a\"));\n+        assertEquals(\"b\", strs.get(\"b\"));\n+        assertEquals(\"c\", strs.get(\"c\"));\n+    }\n+\n+    // Test for [JACKSON-717] -- ensure 'readValues' also does update\n+    public void testUpdateSequence() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        XYBean toUpdate = new XYBean();\n+        Iterator<XYBean> it = m.readerForUpdating(toUpdate).readValues(\n+                \"{\\\"x\\\":1,\\\"y\\\":2}\\n{\\\"x\\\":16}{\\\"y\\\":37}\");\n+\n+        assertTrue(it.hasNext());\n+        XYBean value = it.next();\n+        assertSame(toUpdate, value);\n+        assertEquals(1, value.x);\n+        assertEquals(2, value.y);\n+\n+        assertTrue(it.hasNext());\n+        value = it.next();\n+        assertSame(toUpdate, value);\n+        assertEquals(16, value.x);\n+        assertEquals(2, value.y); // unchanged\n+\n+        assertTrue(it.hasNext());\n+        value = it.next();\n+        assertSame(toUpdate, value);\n+        assertEquals(16, value.x); // unchanged\n+        assertEquals(37, value.y);\n+        \n+        assertFalse(it.hasNext());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.core.Version;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests to verify [JACKSON-278]\n+ */\n+public class TestVersions extends com.fasterxml.jackson.test.BaseTest\n+{\n+    /**\n+     * 18-Nov-2010, tatu: Not a good to do this, but has to do, for now...\n+     */\n+    private final static int MAJOR_VERSION = 2;\n+    private final static int MINOR_VERSION = 0;\n+\n+    public void testMapperVersions()\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertVersion(mapper.version(), MAJOR_VERSION, MINOR_VERSION);\n+        assertVersion(mapper.writer().version(), MAJOR_VERSION, MINOR_VERSION);\n+        assertVersion(mapper.reader().version(), MAJOR_VERSION, MINOR_VERSION);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    private void assertVersion(Version v, int major, int minor)\n+    {\n+        assertFalse(\"Should find version information (got \"+v+\")\", v.isUknownVersion());\n+        assertEquals(major, v.getMajorVersion());\n+        assertEquals(minor, v.getMinorVersion());\n+        // 07-Jan-2011, tatus: Check patch level initially, comment out for maint versions\n+\n+        //assertEquals(0, v.getPatchLevel());\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/access/TestSerAnyGetter.java\n+package com.fasterxml.jackson.databind.access;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Separate tests located in different package than code being\n+ * exercised; needed to trigger some access-related failures.\n+ */\n+public class TestSerAnyGetter\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper bean classes\n+    /**********************************************************\n+     */\n+\n+    static class DynaBean {\n+        public int id;\n+\n+        protected HashMap<String,String> other = new HashMap<String,String>();\n+        \n+        @JsonAnyGetter\n+        public Map<String,String> any() {\n+            return other;\n+        }\n+\n+        @JsonAnySetter\n+        public void set(String name, String value) {\n+            other.put(name, value);\n+        }\n+    }\n+\n+    private static class PrivateThing\n+    {\n+        @SuppressWarnings(\"unused\")\n+        @JsonAnyGetter\n+        public Map<?,?> getProperties()\n+        {\n+            HashMap<String,String> map = new HashMap<String,String>();\n+            map.put(\"a\", \"A\");\n+            return map;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test cases\n+    /**********************************************************\n+     */\n+    \n+    public void testDynaBean() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        DynaBean b = new DynaBean();\n+        b.id = 123;\n+        b.set(\"name\", \"Billy\");\n+        assertEquals(\"{\\\"id\\\":123,\\\"name\\\":\\\"Billy\\\"}\", m.writeValueAsString(b));\n+\n+        DynaBean result = m.readValue(\"{\\\"id\\\":2,\\\"name\\\":\\\"Joe\\\"}\", DynaBean.class);\n+        assertEquals(2, result.id);\n+        assertEquals(\"Joe\", result.other.get(\"name\"));\n+    }\n+\n+    public void testPrivate() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new PrivateThing());\n+        assertEquals(\"{\\\"a\\\":\\\"A\\\"}\", json);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualDeserialization.java\n+package com.fasterxml.jackson.databind.contextual;\n+\n+import java.io.IOException;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.deser.ContextualDeserializer;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Test cases to verify that it is possible to define deserializers\n+ * that can use contextual information (like field/method\n+ * annotations) for configuration.\n+ */\n+public class TestContextualDeserialization extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /* NOTE: important; MUST be considered a 'Jackson' annotation to be seen\n+     * (or recognized otherwise via AnnotationIntrospect.isHandled())\n+     */\n+    @Target({ElementType.FIELD, ElementType.PARAMETER, ElementType.TYPE})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @JacksonAnnotation\n+    public @interface Name {\n+        public String value();\n+    }\n+    \n+    static class ContextualType {\n+        protected String value;\n+        \n+        public ContextualType(String v) { value = v; }\n+    }\n+    \n+    static class ContextualBean\n+    {\n+        @Name(\"NameA\")\n+        public ContextualType a;\n+        @Name(\"NameB\")\n+        public ContextualType b;\n+    }\n+    \n+    static class ContextualCtorBean\n+    {\n+        protected String a, b;\n+\n+        @JsonCreator\n+        public ContextualCtorBean(\n+                @Name(\"CtorA\") @JsonProperty(\"a\") ContextualType a,\n+                @Name(\"CtorB\") @JsonProperty(\"b\") ContextualType b)\n+        {\n+            this.a = a.value;\n+            this.b = b.value;\n+        }\n+    }\n+\n+    @Name(\"Class\")\n+    static class ContextualClassBean\n+    {\n+        public ContextualType a;\n+\n+        @Name(\"NameB\")\n+        public ContextualType b;\n+    }\n+\n+    static class AnnotatedContextualClassBean\n+    {\n+        @Name(\"xyz\")\n+        @JsonDeserialize(using=AnnotatedContextualDeserializer.class)\n+        public ContextualType value;\n+    }\n+    \n+    static class ContextualArrayBean\n+    {\n+        @Name(\"array\")\n+        public ContextualType[] beans;\n+    }\n+    \n+    static class ContextualListBean\n+    {\n+        @Name(\"list\")\n+        public List<ContextualType> beans;\n+    }\n+    \n+    static class ContextualMapBean\n+    {\n+        @Name(\"map\")\n+        public Map<String, ContextualType> beans;\n+    }\n+    \n+    static class MyContextualDeserializer\n+        extends JsonDeserializer<ContextualType>\n+        implements ContextualDeserializer<ContextualType>\n+    {\n+        protected final String _fieldName;\n+        \n+        public MyContextualDeserializer() { this(\"\"); }\n+        public MyContextualDeserializer(String fieldName) {\n+            _fieldName = fieldName;\n+        }\n+\n+        @Override\n+        public ContextualType deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        {\n+            return new ContextualType(\"\"+_fieldName+\"=\"+jp.getText());\n+        }\n+\n+        @Override\n+        public JsonDeserializer<ContextualType> createContextual(DeserializationConfig config,\n+                BeanProperty property)\n+            throws JsonMappingException\n+        {\n+            return new MyContextualDeserializer(property.getName());\n+        }\n+    }\n+\n+    /**\n+     * Alternative that uses annotation for choosing name to use\n+     */\n+    static class AnnotatedContextualDeserializer\n+        extends JsonDeserializer<ContextualType>\n+        implements ContextualDeserializer<ContextualType>\n+    {\n+        protected final String _fieldName;\n+        \n+        public AnnotatedContextualDeserializer() { this(\"\"); }\n+        public AnnotatedContextualDeserializer(String fieldName) {\n+            _fieldName = fieldName;\n+        }\n+    \n+        @Override\n+        public ContextualType deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        {\n+            return new ContextualType(\"\"+_fieldName+\"=\"+jp.getText());\n+        }\n+    \n+        @Override\n+        public JsonDeserializer<ContextualType> createContextual(DeserializationConfig config,\n+                BeanProperty property)\n+            throws JsonMappingException\n+        {\n+            Name ann = property.getAnnotation(Name.class);\n+            if (ann == null) {\n+                ann = property.getContextAnnotation(Name.class);\n+            }\n+            String propertyName = (ann == null) ?  \"UNKNOWN\" : ann.value();\n+            return new MyContextualDeserializer(propertyName);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimple() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addDeserializer(ContextualType.class, new MyContextualDeserializer());\n+        mapper.registerModule(module);\n+        ContextualBean bean = mapper.readValue(\"{\\\"a\\\":\\\"1\\\",\\\"b\\\":\\\"2\\\"}\", ContextualBean.class);\n+        assertEquals(\"a=1\", bean.a.value);\n+        assertEquals(\"b=2\", bean.b.value);\n+\n+        // try again, to ensure caching etc works\n+        bean = mapper.readValue(\"{\\\"a\\\":\\\"3\\\",\\\"b\\\":\\\"4\\\"}\", ContextualBean.class);\n+        assertEquals(\"a=3\", bean.a.value);\n+        assertEquals(\"b=4\", bean.b.value);\n+    }\n+\n+    public void testSimpleWithAnnotations() throws Exception\n+    {\n+        ObjectMapper mapper = _mapperWithAnnotatedContextual();\n+        ContextualBean bean = mapper.readValue(\"{\\\"a\\\":\\\"1\\\",\\\"b\\\":\\\"2\\\"}\", ContextualBean.class);\n+        assertEquals(\"NameA=1\", bean.a.value);\n+        assertEquals(\"NameB=2\", bean.b.value);\n+\n+        // try again, to ensure caching etc works\n+        bean = mapper.readValue(\"{\\\"a\\\":\\\"x\\\",\\\"b\\\":\\\"y\\\"}\", ContextualBean.class);\n+        assertEquals(\"NameA=x\", bean.a.value);\n+        assertEquals(\"NameB=y\", bean.b.value);\n+    }\n+\n+    public void testSimpleWithClassAnnotations() throws Exception\n+    {\n+        ObjectMapper mapper = _mapperWithAnnotatedContextual();\n+        ContextualClassBean bean = mapper.readValue(\"{\\\"a\\\":\\\"1\\\",\\\"b\\\":\\\"2\\\"}\", ContextualClassBean.class);\n+        assertEquals(\"Class=1\", bean.a.value);\n+        assertEquals(\"NameB=2\", bean.b.value);\n+        // and again\n+        bean = mapper.readValue(\"{\\\"a\\\":\\\"123\\\",\\\"b\\\":\\\"345\\\"}\", ContextualClassBean.class);\n+        assertEquals(\"Class=123\", bean.a.value);\n+        assertEquals(\"NameB=345\", bean.b.value);\n+    }\n+    \n+    public void testAnnotatedCtor() throws Exception\n+    {\n+        ObjectMapper mapper = _mapperWithAnnotatedContextual();\n+        ContextualCtorBean bean = mapper.readValue(\"{\\\"a\\\":\\\"foo\\\",\\\"b\\\":\\\"bar\\\"}\", ContextualCtorBean.class);\n+        assertEquals(\"CtorA=foo\", bean.a);\n+        assertEquals(\"CtorB=bar\", bean.b);\n+\n+        bean = mapper.readValue(\"{\\\"a\\\":\\\"1\\\",\\\"b\\\":\\\"0\\\"}\", ContextualCtorBean.class);\n+        assertEquals(\"CtorA=1\", bean.a);\n+        assertEquals(\"CtorB=0\", bean.b);\n+    }\n+\n+    public void testAnnotatedArray() throws Exception\n+    {\n+        ObjectMapper mapper = _mapperWithAnnotatedContextual();\n+        ContextualArrayBean bean = mapper.readValue(\"{\\\"beans\\\":[\\\"x\\\"]}\", ContextualArrayBean.class);\n+        assertEquals(1, bean.beans.length);\n+        assertEquals(\"array=x\", bean.beans[0].value);\n+\n+        bean = mapper.readValue(\"{\\\"beans\\\":[\\\"a\\\",\\\"b\\\"]}\", ContextualArrayBean.class);\n+        assertEquals(2, bean.beans.length);\n+        assertEquals(\"array=a\", bean.beans[0].value);\n+        assertEquals(\"array=b\", bean.beans[1].value);\n+    }\n+\n+    public void testAnnotatedList() throws Exception\n+    {\n+        ObjectMapper mapper = _mapperWithAnnotatedContextual();\n+        ContextualListBean bean = mapper.readValue(\"{\\\"beans\\\":[\\\"x\\\"]}\", ContextualListBean.class);\n+        assertEquals(1, bean.beans.size());\n+        assertEquals(\"list=x\", bean.beans.get(0).value);\n+\n+        bean = mapper.readValue(\"{\\\"beans\\\":[\\\"x\\\",\\\"y\\\",\\\"z\\\"]}\", ContextualListBean.class);\n+        assertEquals(3, bean.beans.size());\n+        assertEquals(\"list=x\", bean.beans.get(0).value);\n+        assertEquals(\"list=y\", bean.beans.get(1).value);\n+        assertEquals(\"list=z\", bean.beans.get(2).value);\n+    }\n+\n+    public void testAnnotatedMap() throws Exception\n+    {\n+        ObjectMapper mapper = _mapperWithAnnotatedContextual();\n+        ContextualMapBean bean = mapper.readValue(\"{\\\"beans\\\":{\\\"a\\\":\\\"b\\\"}}\", ContextualMapBean.class);\n+        assertEquals(1, bean.beans.size());\n+        Map.Entry<String,ContextualType> entry = bean.beans.entrySet().iterator().next();\n+        assertEquals(\"a\", entry.getKey());\n+        assertEquals(\"map=b\", entry.getValue().value);\n+\n+        bean = mapper.readValue(\"{\\\"beans\\\":{\\\"x\\\":\\\"y\\\",\\\"1\\\":\\\"2\\\"}}\", ContextualMapBean.class);\n+        assertEquals(2, bean.beans.size());\n+        Iterator<Map.Entry<String,ContextualType>> it = bean.beans.entrySet().iterator();\n+        entry = it.next();\n+        assertEquals(\"x\", entry.getKey());\n+        assertEquals(\"map=y\", entry.getValue().value);\n+        entry = it.next();\n+        assertEquals(\"1\", entry.getKey());\n+        assertEquals(\"map=2\", entry.getValue().value);\n+    }\n+\n+    // ensure that direct associations also work\n+    public void testAnnotatedContextual() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AnnotatedContextualClassBean bean = mapper.readValue(\n+                \"{\\\"value\\\":\\\"a\\\"}\",\n+              AnnotatedContextualClassBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"xyz=a\", bean.value.value);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private ObjectMapper _mapperWithAnnotatedContextual()\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addDeserializer(ContextualType.class, new AnnotatedContextualDeserializer());\n+        mapper.registerModule(module);\n+        return mapper;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualKeyTypes.java\n+package com.fasterxml.jackson.databind.contextual;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.ContextualKeyDeserializer;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Tests to ensure that we can do contextual key serializers and\n+ * deserializers as well as value ser/deser.\n+ * \n+ * @since 1.8\n+ */\n+public class TestContextualKeyTypes extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    static class ContextualKeySerializer\n+        extends JsonSerializer<String>\n+        implements ContextualSerializer<String>\n+    {\n+        protected final String _prefix;\n+    \n+        public ContextualKeySerializer() { this(\"\"); }\n+        public ContextualKeySerializer(String p) {\n+            _prefix = p;\n+        }\n+\n+        @Override\n+        public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+            if (_prefix != null) {\n+                value = _prefix + value;\n+            }\n+            jgen.writeFieldName(value);\n+        }\n+    \n+        @Override\n+        public JsonSerializer<String> createContextual(SerializationConfig config, BeanProperty property)\n+            throws JsonMappingException\n+        {\n+            return new ContextualKeySerializer(_prefix+\":\");\n+        }\n+    }\n+\n+    static class ContextualDeser\n+        extends KeyDeserializer\n+        implements ContextualKeyDeserializer\n+    {\n+        protected final String _prefix;\n+        \n+        protected ContextualDeser(String p) {\n+            _prefix = p;\n+        }        \n+\n+        @Override\n+        public Object deserializeKey(String key, DeserializationContext ctxt)\n+                throws IOException, JsonProcessingException\n+        {\n+            return _prefix + \":\" + key;\n+        }\n+\n+        @Override\n+        public KeyDeserializer createContextual(DeserializationConfig config,\n+                BeanProperty property) throws JsonMappingException\n+        {\n+            return new ContextualDeser((property == null) ? \"ROOT\" : property.getName());\n+        }\n+    }\n+\n+    static class MapBean {\n+        public Map<String, Integer> map;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests, serialization\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleKeySer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addKeySerializer(String.class, new ContextualKeySerializer(\"prefix\"));\n+        mapper.registerModule(module);\n+        Map<String,Object> input = new HashMap<String,Object>();\n+        input.put(\"a\", Integer.valueOf(3));\n+        String json = mapper.writerWithType(TypeFactory.defaultInstance().constructMapType(HashMap.class, String.class, Object.class))\n+            .writeValueAsString(input);\n+        assertEquals(\"{\\\"prefix:a\\\":3}\", json);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests, deserialization\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleKeyDeser() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addKeyDeserializer(String.class, new ContextualDeser(\"???\"));\n+        mapper.registerModule(module);\n+        MapBean result = mapper.readValue(\"{\\\"map\\\":{\\\"a\\\":3}}\", MapBean.class);\n+        Map<String,Integer> map = result.map;\n+        assertNotNull(map);\n+        assertEquals(1, map.size());\n+        Map.Entry<String,Integer> entry = map.entrySet().iterator().next();\n+        assertEquals(Integer.valueOf(3), entry.getValue());\n+        assertEquals(\"map:a\", entry.getKey());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualSerialization.java\n+package com.fasterxml.jackson.databind.contextual;\n+\n+import java.io.IOException;\n+import java.lang.annotation.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n+import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n+\n+/**\n+ * Test cases to verify that it is possible to define serializers\n+ * that can use contextual information (like field/method\n+ * annotations) for configuration.\n+ * \n+ * @since 1.7\n+ */\n+public class TestContextualSerialization extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /* NOTE: important; MUST be considered a 'Jackson' annotation to be seen\n+     * (or recognized otherwise via AnnotationIntrospect.isHandled())\n+     */\n+    @Target({ElementType.FIELD, ElementType.TYPE, ElementType.METHOD})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @JacksonAnnotation\n+    public @interface Prefix {\n+        public String value();\n+    }\n+\n+    static class ContextualBean\n+    {\n+        protected final String _value;\n+\n+        public ContextualBean(String s) { _value = s; }\n+\n+        @Prefix(\"see:\")\n+        public String getValue() { return _value; }\n+    }\n+\n+    // For [JACKSON-569]\n+    static class AnnotatedContextualBean\n+    {\n+        @Prefix(\"prefix->\")\n+        @JsonSerialize(using=AnnotatedContextualSerializer.class)\n+        protected final String value;\n+\n+        public AnnotatedContextualBean(String s) { value = s; }\n+    }\n+\n+    \n+    @Prefix(\"wrappedBean:\")\n+    static class ContextualBeanWrapper\n+    {\n+        @Prefix(\"wrapped:\")\n+        public ContextualBean wrapped;\n+        \n+        public ContextualBeanWrapper(String s) {\n+            wrapped = new ContextualBean(s);\n+        }\n+    }\n+    \n+    static class ContextualArrayBean\n+    {\n+        @Prefix(\"array->\")\n+        public final String[] beans;\n+        \n+        public ContextualArrayBean(String... strings) {\n+            beans = strings;\n+        }\n+    }\n+    \n+    static class ContextualListBean\n+    {\n+        @Prefix(\"list->\")\n+        public final List<String> beans = new ArrayList<String>();\n+\n+        public ContextualListBean(String... strings) {\n+            for (String string : strings) {\n+                beans.add(string);\n+            }\n+        }\n+    }\n+    \n+    static class ContextualMapBean\n+    {\n+        @Prefix(\"map->\")\n+        public final Map<String, String> beans = new HashMap<String, String>();\n+    }\n+    \n+    /**\n+     * Another bean that has class annotations that should be visible for\n+     * contextualizer, too\n+     */\n+    @Prefix(\"Voila->\")\n+    static class BeanWithClassConfig\n+    {\n+        public String value;\n+\n+        public BeanWithClassConfig(String v) { value = v; }\n+    }\n+    \n+    /**\n+     * Annotation-based contextual serializer that simply prepends piece of text.\n+     */\n+    static class AnnotatedContextualSerializer\n+        extends JsonSerializer<String>\n+        implements ContextualSerializer<String>\n+    {\n+        protected final String _prefix;\n+        \n+        public AnnotatedContextualSerializer() { this(\"\"); }\n+        public AnnotatedContextualSerializer(String p) {\n+            _prefix = p;\n+        }\n+\n+        @Override\n+        public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+            jgen.writeString(_prefix + value);\n+        }\n+\n+        @Override\n+        public JsonSerializer<String> createContextual(SerializationConfig config, BeanProperty property)\n+                throws JsonMappingException\n+        {\n+            String prefix = \"UNKNOWN\";\n+            Prefix ann = property.getAnnotation(Prefix.class);\n+            if (ann == null) {\n+                ann = property.getContextAnnotation(Prefix.class);\n+            }\n+            if (ann != null) {\n+                prefix = ann.value();\n+            }\n+            return new AnnotatedContextualSerializer(prefix);\n+        }\n+    }\n+\n+    static class ContextualAndResolvable\n+        extends JsonSerializer<String>\n+        implements ContextualSerializer<String>, ResolvableSerializer\n+    {\n+        protected boolean isContextual;\n+        protected boolean isResolved;\n+\n+        public ContextualAndResolvable() { this(false); }\n+        \n+        public ContextualAndResolvable(boolean contextual)\n+        {\n+            isContextual = contextual;\n+            isResolved = false;\n+        }\n+        \n+        @Override\n+        public void serialize(String value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+            jgen.writeString(\"contextual=\"+isContextual+\",resolved=\"+isResolved);\n+        }\n+\n+        @Override\n+        public JsonSerializer<String> createContextual(SerializationConfig config, BeanProperty property)\n+                throws JsonMappingException\n+        {\n+            return new ContextualAndResolvable(true);\n+        }\n+\n+        @Override\n+        public void resolve(SerializerProvider provider) {\n+            isResolved = true;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Test to verify that contextual serializer can make use of property\n+     * (method, field) annotations.\n+     */\n+    public void testMethodAnnotations() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addSerializer(String.class, new AnnotatedContextualSerializer());\n+        mapper.registerModule(module);\n+        assertEquals(\"{\\\"value\\\":\\\"see:foobar\\\"}\", mapper.writeValueAsString(new ContextualBean(\"foobar\")));\n+    }\n+\n+    /**\n+     * Test to verify that contextual serializer can also use annotations\n+     * for enclosing class.\n+     */\n+    public void testClassAnnotations() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addSerializer(String.class, new AnnotatedContextualSerializer());\n+        mapper.registerModule(module);\n+        assertEquals(\"{\\\"value\\\":\\\"Voila->xyz\\\"}\", mapper.writeValueAsString(new BeanWithClassConfig(\"xyz\")));\n+    }\n+\n+    public void testWrappedBean() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addSerializer(String.class, new AnnotatedContextualSerializer());\n+        mapper.registerModule(module);\n+        assertEquals(\"{\\\"wrapped\\\":{\\\"value\\\":\\\"see:xyz\\\"}}\", mapper.writeValueAsString(new ContextualBeanWrapper(\"xyz\")));\n+    }\n+    \n+    /**\n+     * Serializer should get passed property context even if contained in an array.\n+     */\n+    public void testMethodAnnotationInArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addSerializer(String.class, new AnnotatedContextualSerializer());\n+        mapper.registerModule(module);\n+        ContextualArrayBean beans = new ContextualArrayBean(\"123\");\n+        assertEquals(\"{\\\"beans\\\":[\\\"array->123\\\"]}\", mapper.writeValueAsString(beans));\n+    }\n+\n+    /**\n+     * Serializer should get passed property context even if contained in a Collection.\n+     */\n+    public void testMethodAnnotationInList() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addSerializer(String.class, new AnnotatedContextualSerializer());\n+        mapper.registerModule(module);\n+        ContextualListBean beans = new ContextualListBean(\"abc\");\n+        assertEquals(\"{\\\"beans\\\":[\\\"list->abc\\\"]}\", mapper.writeValueAsString(beans));\n+    }\n+\n+    /**\n+     * Serializer should get passed property context even if contained in a Collection.\n+     */\n+    public void testMethodAnnotationInMap() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addSerializer(String.class, new AnnotatedContextualSerializer());\n+        mapper.registerModule(module);\n+        ContextualMapBean map = new ContextualMapBean();\n+        map.beans.put(\"first\", \"In Map\");\n+        assertEquals(\"{\\\"beans\\\":{\\\"first\\\":\\\"map->In Map\\\"}}\", mapper.writeValueAsString(map));\n+    }\n+\n+    public void testContextualViaAnnotation() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AnnotatedContextualBean bean = new AnnotatedContextualBean(\"abc\");\n+        assertEquals(\"{\\\"value\\\":\\\"prefix->abc\\\"}\", mapper.writeValueAsString(bean));\n+    }\n+\n+    // [JACKSON-647]: is resolve() called for contextual instances?\n+    public void testResolveOnContextual() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addSerializer(String.class, new ContextualAndResolvable());\n+        mapper.registerModule(module);\n+        assertEquals(quote(\"contextual=true,resolved=true\"), mapper.writeValueAsString(\"abc\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestArrayConversions.java\n+package com.fasterxml.jackson.databind.convert;\n+\n+import java.math.*;\n+import java.util.*;\n+import java.lang.reflect.Array;\n+\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestArrayConversions\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    final static String OVERFLOW_MSG_BYTE = \"out of range of Java byte\";\n+    final static String OVERFLOW_MSG = \"overflow\";\n+\n+    final ObjectMapper mapper = new ObjectMapper();\n+\n+    public void testNullXform() throws Exception\n+    {\n+        /* when given null, null should be returned without conversion\n+         * (Java null has no type)\n+         */\n+        assertNull(mapper.convertValue(null, Integer.class));\n+        assertNull(mapper.convertValue(null, String.class));\n+        assertNull(mapper.convertValue(null, byte[].class));\n+    }\n+\n+    /**\n+     * Tests to verify that primitive number arrays round-trip\n+     * correctly, i.e. type -> type gives equal (although\n+     * not necessarily same) output\n+     */\n+    public void testArrayIdentityTransforms() throws Exception\n+    {\n+        // first integral types\n+        // (note: byte[] is ok, even if it goes to base64 and back)\n+        verifyByteArrayConversion(bytes(), byte[].class);\n+        verifyShortArrayConversion(shorts(), short[].class);\n+        verifyIntArrayConversion(ints(), int[].class);\n+        verifyLongArrayConversion(longs(), long[].class);\n+        // then primitive decimal types\n+        verifyFloatArrayConversion(floats(), float[].class);\n+        verifyDoubleArrayConversion(doubles(), float[].class);\n+    }\n+\n+    public void testByteArrayFrom() throws Exception\n+    {\n+        /* Note: byte arrays are tricky, since they are considered\n+         * binary data primarily, not as array of numbers. Hence\n+         * output will be base64 encoded...\n+         */\n+        byte[] data = _convert(\"c3VyZS4=\", byte[].class);\n+        byte[] exp = \"sure.\".getBytes(\"Ascii\");\n+        verifyIntegralArrays(exp, data, exp.length);\n+    }\n+    \n+    public void testShortArrayToX() throws Exception\n+    {\n+        short[] data = shorts();\n+        verifyShortArrayConversion(data, byte[].class);\n+        verifyShortArrayConversion(data, int[].class);\n+        verifyShortArrayConversion(data, long[].class);\n+    }\n+\n+    public void testIntArrayToX() throws Exception\n+    {\n+        int[] data = ints();\n+        verifyIntArrayConversion(data, byte[].class);\n+        verifyIntArrayConversion(data, short[].class);\n+        verifyIntArrayConversion(data, long[].class);\n+\n+        List<Number> expNums = _numberList(data, data.length);\n+        // Alas, due to type erasure, need to use TypeRef, not just class\n+        List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() {});\n+        assertEquals(expNums, actNums);\n+    }\n+\n+    public void testLongArrayToX() throws Exception\n+    {\n+        long[] data = longs();\n+        verifyLongArrayConversion(data, byte[].class);\n+        verifyLongArrayConversion(data, short[].class);\n+        verifyLongArrayConversion(data, int[].class);\n+ \n+        List<Number> expNums = _numberList(data, data.length);\n+        List<Long> actNums = mapper.convertValue(data, new TypeReference<List<Long>>() {});\n+        assertEquals(expNums, actNums);        \n+    }\n+\n+    public void testOverflows()\n+    {\n+        // Byte overflow\n+        try {\n+            mapper.convertValue(new int[] { 1000 }, byte[].class);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, OVERFLOW_MSG_BYTE);\n+        }\n+        // Short overflow\n+        try {\n+            mapper.convertValue(new int[] { -99999 }, short[].class);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, OVERFLOW_MSG);\n+        }\n+        // Int overflow\n+        try {\n+            mapper.convertValue(new long[] { Long.MAX_VALUE }, int[].class);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, OVERFLOW_MSG);\n+        }\n+        // Longs need help of BigInteger...\n+        BigInteger biggie = BigInteger.valueOf(Long.MAX_VALUE);\n+        biggie.add(BigInteger.ONE);\n+        List<BigInteger> l = new ArrayList<BigInteger>();\n+        l.add(biggie);\n+        try {\n+            mapper.convertValue(l, int[].class);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, OVERFLOW_MSG);\n+        }\n+        \n+    }\n+    \n+    /*\n+     ********************************************************\n+     * Helper methods\n+     ********************************************************\n+     */\n+\n+    // note: all value need to be within byte range\n+    \n+    private byte[] bytes() { return new byte[] { 1, -1, 0, 98, 127 }; }\n+    private short[] shorts() { return new short[] { 1, -1, 0, 98, 127 }; }\n+    private int[] ints() { return new int[] { 1, -1, 0, 98, 127 }; }\n+    private long[] longs() { return new long[] { 1, -1, 0, 98, 127 }; }\n+\n+    // note: use values that are exact in binary\n+\n+    private double[] doubles() { return new double[] { 0.0, 0.25, -0.125, 10.5, 9875.0 }; }\n+    private float[] floats() { return new float[] {\n+            0.0f, 0.25f, -0.125f, 10.5f, 9875.0f };\n+    }\n+\n+    private <T> void verifyByteArrayConversion(byte[] data, Class<T> arrayType) {\n+        T result = _convert(data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyShortArrayConversion(short[] data, Class<T> arrayType) {\n+        T result = _convert(data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyIntArrayConversion(int[] data, Class<T> arrayType) {\n+        T result = _convert(data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyLongArrayConversion(long[] data, Class<T> arrayType) {\n+        T result = _convert(data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyFloatArrayConversion(float[] data, Class<T> arrayType) {\n+        T result = _convert(data, arrayType);\n+        verifyDoubleArrays(data, result, data.length);\n+    }\n+    private <T> void verifyDoubleArrayConversion(double[] data, Class<T> arrayType) {\n+        T result = _convert(data, arrayType);\n+        verifyDoubleArrays(data, result, data.length);\n+    }\n+    \n+    private <T> T _convert(Object input, Class<T> outputType)\n+    {\n+        // must be a primitive array, like \"int[].class\"\n+        if (!outputType.isArray()) throw new IllegalArgumentException();\n+        if (!outputType.getComponentType().isPrimitive()) throw new IllegalArgumentException();\n+        T result = mapper.convertValue(input, outputType);\n+        // sanity check first:\n+        assertNotNull(result);\n+        assertEquals(outputType, result.getClass());\n+        return result;\n+    }\n+\n+    private List<Number> _numberList(Object numberArray, int size)\n+    {\n+        ArrayList<Number> result = new ArrayList<Number>(size);\n+        for (int i = 0; i < size; ++i) {\n+            result.add((Number) Array.get(numberArray, i));\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Helper method for checking that given collections contain integral Numbers\n+     * that essentially contain same values in same order\n+     */\n+    private void verifyIntegralArrays(Object inputArray, Object outputArray, int size)\n+    {\n+        for (int i = 0; i < size; ++i) {\n+            Number n1 = (Number) Array.get(inputArray, i);\n+            Number n2 = (Number) Array.get(outputArray, i);\n+            double value1 = ((Number) n1).longValue();\n+            double value2 = ((Number) n2).longValue();\n+            assertEquals(\"Entry #\"+i+\"/\"+size+\" not equal\", value1, value2);\n+        }        \n+    }\n+\n+    private void verifyDoubleArrays(Object inputArray, Object outputArray, int size)\n+    {\n+        for (int i = 0; i < size; ++i) {\n+            Number n1 = (Number) Array.get(inputArray, i);\n+            Number n2 = (Number) Array.get(outputArray, i);\n+            double value1 = ((Number) n1).doubleValue();\n+            double value2 = ((Number) n2).doubleValue();\n+            assertEquals(\"Entry #\"+i+\"/\"+size+\" not equal\", value1, value2);\n+        }        \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java\n+package com.fasterxml.jackson.databind.convert;\n+\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestBeanConversions\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    final ObjectMapper mapper = new ObjectMapper();\n+\n+    static class Point {\n+        public int x, y;\n+\n+        public int z = -13;\n+\n+        public Point() { }\n+        public Point(int a, int b, int c)\n+        {\n+            x = a;\n+            y = b;\n+            z = c;\n+        }\n+    }\n+\n+    static class PointStrings {\n+        public final String x, y;\n+\n+        public PointStrings(String x, String y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    public static class BooleanBean {\n+        public boolean boolProp;\n+    }\n+\n+    static class WrapperBean {\n+        public BooleanBean x;\n+    }\n+\n+    static class ObjectWrapper\n+    {\n+        private Object data;\n+\n+        public ObjectWrapper() { }\n+        public ObjectWrapper(Object o) { data = o; }\n+\n+        public Object getData() { return data; }\n+        public void setData(Object data) { this.data = data; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    public void testBeanConvert()\n+    {\n+        // should have no problems convert between compatible beans...\n+        PointStrings input = new PointStrings(\"37\", \"-9\");\n+        Point point = mapper.convertValue(input, Point.class);\n+        assertEquals(37, point.x);\n+        assertEquals(-9, point.y);\n+        // z not included in input, will be whatever default constructor provides\n+        assertEquals(-13, point.z);\n+    }\n+    \n+    // For [JACKSON-371]; verify that we know property that caused issue...\n+    // (note: not optimal place for test, but will have to do for now)\n+    public void testErrorReporting() throws Exception\n+    {\n+        //String json = \"{\\\"boolProp\\\":\\\"oops\\\"}\";\n+        // First: unknown property\n+        try {\n+            mapper.readValue(\"{\\\"unknownProp\\\":true}\", BooleanBean.class);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"unknownProp\");\n+        }\n+\n+        // then bad conversion\n+        try {\n+            mapper.readValue(\"{\\\"boolProp\\\":\\\"foobar\\\"}\", BooleanBean.class);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"boolProp\");\n+        }\n+    }\n+\n+    public void testIssue458() throws Exception\n+    {\n+        ObjectWrapper a = new ObjectWrapper(\"foo\");\n+        ObjectWrapper b = new ObjectWrapper(a);\n+        ObjectWrapper b2 = mapper.convertValue(b, ObjectWrapper.class);\n+        ObjectWrapper a2 = mapper.convertValue(b2.getData(), ObjectWrapper.class);\n+        assertEquals(\"foo\", a2.getData());\n+    }\n+\n+    // [JACKSON-710]: should work regardless of wrapping...\n+    public void testWrapping() throws Exception\n+    {\n+        ObjectMapper wrappingMapper = new ObjectMapper();\n+        wrappingMapper.enable(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n+        wrappingMapper.enable(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+        Point input = new Point(1, 2, 3);\n+        // conversion is ok, even if it's bogus one\n+        Point output = wrappingMapper.convertValue(input, Point.class);\n+        assertEquals(1, output.x);\n+        assertEquals(2, output.y);\n+        assertEquals(3, output.z);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestMapConversions.java\n+package com.fasterxml.jackson.databind.convert;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestMapConversions\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    final ObjectMapper mapper = new ObjectMapper();\n+\n+    enum AB { A, B; }\n+\n+    static class Bean {\n+        public Integer A;\n+        public String B;\n+    }\n+    \n+    /**\n+     * Test that verifies that we can go between couple of types of Maps...\n+     */\n+    public void testMapToMap()\n+    {\n+        Map<String,Integer> input = new LinkedHashMap<String,Integer>();\n+        input.put(\"A\", Integer.valueOf(3));\n+        input.put(\"B\", Integer.valueOf(-4));\n+        Map<AB,String> output = mapper.convertValue(input,\n+                new TypeReference<Map<AB,String>>() { });\n+        assertEquals(2, output.size());\n+        assertEquals(\"3\", output.get(AB.A));\n+        assertEquals(\"-4\", output.get(AB.B));\n+\n+        // Let's try the other way too... and mix up types a bit\n+        Map<String,Integer> roundtrip = mapper.convertValue(input,\n+                new TypeReference<TreeMap<String,Integer>>() { });\n+        assertEquals(2, roundtrip.size());\n+        assertEquals(Integer.valueOf(3), roundtrip.get(\"A\"));\n+        assertEquals(Integer.valueOf(-4), roundtrip.get(\"B\"));\n+    }\n+\n+    public void testMapToBean()\n+    {\n+        EnumMap<AB,String> map = new EnumMap<AB,String>(AB.class);\n+        map.put(AB.A, \"   17\");\n+        map.put(AB.B, \" -1\");\n+        Bean bean = mapper.convertValue(map, Bean.class);\n+        assertEquals(Integer.valueOf(17), bean.A);\n+        assertEquals(\" -1\", bean.B);\n+    }\n+\n+    public void testBeanToMap()\n+    {\n+        Bean bean = new Bean();\n+        bean.A = 129;\n+        bean.B = \"13\";\n+        EnumMap<AB,String> result = mapper.convertValue(bean,\n+                new TypeReference<EnumMap<AB,String>>() { });\n+        assertEquals(\"129\", result.get(AB.A));\n+        assertEquals(\"13\", result.get(AB.B));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestStringConversions.java\n+package com.fasterxml.jackson.databind.convert;\n+\n+import java.util.*;\n+\n+import static org.junit.Assert.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestStringConversions\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    final ObjectMapper mapper = new ObjectMapper();\n+\n+    public void testSimple()\n+    {\n+        assertEquals(Boolean.TRUE, mapper.convertValue(\"true\", Boolean.class));\n+        assertEquals(Integer.valueOf(-3), mapper.convertValue(\"  -3 \", Integer.class));\n+        assertEquals(Long.valueOf(77), mapper.convertValue(\"77\", Long.class));\n+\n+        int[] ints = { 1, 2, 3 };\n+        List<Integer> Ints = new ArrayList<Integer>();\n+        Ints.add(1);\n+        Ints.add(2);\n+        Ints.add(3);\n+        \n+        assertArrayEquals(ints, mapper.convertValue(Ints, int[].class));\n+    }\n+\n+    public void testStringsToInts()\n+    {\n+        // let's verify our \"neat trick\" actually works...\n+        assertArrayEquals(new int[] { 1, 2, 3, 4, -1, 0 },\n+                          mapper.convertValue(\"1  2 3    4  -1 0\".split(\"\\\\s+\"), int[].class));\n+    }\n+\n+    /**\n+     * @since 1.6\n+     */\n+    public void testBytesToBase64AndBack() throws Exception\n+    {\n+        byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 };\n+        String encoded = mapper.convertValue(input, String.class);\n+        assertNotNull(encoded);\n+        byte[] result = mapper.convertValue(encoded, byte[].class);\n+        assertArrayEquals(input, result);\n+    }\n+    \n+    /**\n+     * @since 1.7.3\n+     */\n+    public void testBytestoCharArray() throws Exception\n+    {\n+        byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 };\n+        // first, do baseline encoding\n+        char[] expEncoded = mapper.convertValue(input, String.class).toCharArray();\n+        // then compare\n+        char[] actEncoded = mapper.convertValue(input, char[].class);\n+        assertArrayEquals(expEncoded, actEncoded);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestAbstract.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Tests for checking handling of abstract types.\n+ */\n+public class TestAbstract\n+    extends BaseMapTest\n+{\n+    static abstract class Abstract {\n+        public int x;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Test to verify details of how trying to deserialize into\n+     * abstract type should fail (if there is no way to determine\n+     * actual type information for the concrete type to use)\n+     */\n+    public void testAbstractFailure() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        try {\n+            m.readValue(\"{ \\\"x\\\" : 3 }\", Abstract.class);\n+            fail(\"Should fail on trying to deserialize abstract type\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"can not construct\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestAnnotationIgnore.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * This unit test suite that tests use of {@link JsonIgnore}\n+ * annotation with deserialization.\n+ */\n+public class TestAnnotationIgnore\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /// Class for testing {@link JsonIgnore} annotations with setters\n+    final static class SizeClassIgnore\n+    {\n+        int _x = 0;\n+        int _y = 0;\n+\n+        public void setX(int value) { _x = value; }\n+        @JsonIgnore public void setY(int value) { _y = value; }\n+\n+        /* Just igoring won't help a lot here; let's define a replacement\n+         * so that we won't get an exception for \"unknown field\"\n+         */\n+        @JsonProperty(\"y\") void foobar(int value) {\n+            ; // nop\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleIgnore() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        SizeClassIgnore result = m.readValue\n+            (\"{ \\\"x\\\":1, \\\"y\\\" : 2 }\",\n+             SizeClassIgnore.class);\n+        // x should be set, y not\n+        assertEquals(1, result._x);\n+        assertEquals(0, result._y);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestAnnotationUsing.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+\n+/**\n+ * Unit test suite that tests \"usingXxx\" properties of\n+ * {@link JsonDeserialize} annotation.\n+ */\n+public class TestAnnotationUsing\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************************\n+    /* Annotated Bean classes\n+    /**********************************************************************\n+     */\n+\n+    /**\n+     * Class for testing {@link JsonDeserializer} annotation\n+     * for class itself.\n+     */\n+    @JsonDeserialize(using=ValueDeserializer.class)\n+    final static class ValueClass {\n+        int _a;\n+        \n+        /* we'll test it by not having default no-arg ctor, and leaving\n+         * out single-int-arg ctor (because deserializer would use that too)\n+         */\n+        public ValueClass(int a, int b) {\n+            _a = a;\n+        }\n+    }\n+\n+    /**\n+     * Class for testing {@link JsonDeserializer} annotation\n+     * for a method\n+     */\n+    final static class MethodBean {\n+        int[] _ints;\n+\n+        /* Note: could be made to work otherwise, except that\n+         * to trigger failure (in absence of annotation) Json\n+         * is of type VALUE_NUMBER_INT, not an Array: array would\n+         * work by default, but scalar not\n+         */\n+        @JsonDeserialize(using=IntsDeserializer.class)\n+        public void setInts(int[] i) {\n+            _ints = i;\n+        }\n+    }\n+\n+    static class ArrayBean {\n+        @JsonDeserialize(contentUsing=ValueDeserializer.class)\n+        public Object[] values;\n+    }\n+\n+\n+    static class ListBean {\n+        @JsonDeserialize(contentUsing=ValueDeserializer.class)\n+        public List<Object> values;\n+    }\n+\n+    static class MapBean {\n+        @JsonDeserialize(contentUsing=ValueDeserializer.class)\n+        public Map<String,Object> values;\n+    }\n+\n+    static class MapKeyBean {\n+        @JsonDeserialize(keyUsing=MapKeyDeserializer.class)\n+        public Map<Object,Object> values;\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    @JsonDeserialize(keyUsing=MapKeyDeserializer.class, contentUsing=ValueDeserializer.class)\n+    static class MapKeyMap extends HashMap<Object,Object> { }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Deserializers\n+    /**********************************************************************\n+     */\n+\n+    static class ValueDeserializer extends StdDeserializer<ValueClass>\n+    {\n+        public ValueDeserializer() { super(ValueClass.class); }\n+        @Override\n+        public ValueClass deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            int i = jp.getIntValue();\n+            return new ValueClass(i, i);\n+        }\n+    }\n+\n+    private final static class IntsDeserializer extends StdDeserializer<int[]>\n+    {\n+        public IntsDeserializer() { super(int[].class); }\n+        @Override\n+        public int[] deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return new int[] { jp.getIntValue() };\n+        }\n+    }\n+\n+    private final static class MapKeyDeserializer extends KeyDeserializer\n+    {\n+        @Override\n+        public Object deserializeKey(String key, DeserializationContext ctxt)\n+        {\n+            return new String[] { key };\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Tests: specifying deserializer of value itself\n+    /**********************************************************************\n+     */\n+\n+    // Unit test to verify that {@link JsonDeserialize#using} annotation works\n+    // when applied to a class\n+    public void testClassDeserializer() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        ValueClass result = m.readValue(\"  123  \", ValueClass.class);\n+        assertEquals(123, result._a);\n+    }\n+\n+    // Unit test to verify that {@link JsonDeserialize#using} annotation works\n+    // when applied to a Method\n+    public void testMethodDeserializer() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // note: since it's part of method, must parse from Object struct\n+        MethodBean result = m.readValue(\" { \\\"ints\\\" : 3 } \", MethodBean.class);\n+        assertNotNull(result);\n+        int[] ints = result._ints;\n+        assertNotNull(ints);\n+        assertEquals(1, ints.length);\n+        assertEquals(3, ints[0]);\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Tests: specifying deserializer for keys and/or contents\n+    /**********************************************************************\n+     */\n+\n+    public void testArrayContentUsing() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        ArrayBean result = m.readValue(\" { \\\"values\\\" : [ 1, 2, 3 ] } \", ArrayBean.class);\n+        assertNotNull(result);\n+        Object[] obs = result.values;\n+        assertNotNull(obs);\n+        assertEquals(3, obs.length);\n+        assertEquals(ValueClass.class, obs[0].getClass());\n+        assertEquals(1, ((ValueClass) obs[0])._a);\n+        assertEquals(ValueClass.class, obs[1].getClass());\n+        assertEquals(2, ((ValueClass) obs[1])._a);\n+        assertEquals(ValueClass.class, obs[2].getClass());\n+        assertEquals(3, ((ValueClass) obs[2])._a);\n+    }\n+\n+    public void testListContentUsing() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        ListBean result = m.readValue(\" { \\\"values\\\" : [ 1, 2, 3 ] } \", ListBean.class);\n+        assertNotNull(result);\n+        List<Object> obs = result.values;\n+        assertNotNull(obs);\n+        assertEquals(3, obs.size());\n+        assertEquals(ValueClass.class, obs.get(0).getClass());\n+        assertEquals(1, ((ValueClass) obs.get(0))._a);\n+        assertEquals(ValueClass.class, obs.get(1).getClass());\n+        assertEquals(2, ((ValueClass) obs.get(1))._a);\n+        assertEquals(ValueClass.class, obs.get(2).getClass());\n+        assertEquals(3, ((ValueClass) obs.get(2))._a);\n+    }\n+\n+    public void testMapContentUsing() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        MapBean result = m.readValue(\" { \\\"values\\\" : { \\\"a\\\": 1, \\\"b\\\":2 } } \", MapBean.class);\n+        assertNotNull(result);\n+        Map<String,Object> map = result.values;\n+        assertNotNull(map);\n+        assertEquals(2, map.size());\n+        assertEquals(ValueClass.class, map.get(\"a\").getClass());\n+        assertEquals(1, ((ValueClass) map.get(\"a\"))._a);\n+        assertEquals(ValueClass.class, map.get(\"b\").getClass());\n+        assertEquals(2, ((ValueClass) map.get(\"b\"))._a);\n+    }\n+\n+    public void testMapKeyUsing() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        MapKeyBean result = m.readValue(\" { \\\"values\\\" : { \\\"a\\\": true } } \", MapKeyBean.class);\n+        assertNotNull(result);\n+        Map<Object,Object> map = result.values;\n+        assertNotNull(map);\n+        assertEquals(1, map.size());\n+        Map.Entry<Object,Object> en = map.entrySet().iterator().next();\n+        assertEquals(String[].class, en.getKey().getClass());\n+        assertEquals(Boolean.TRUE, en.getValue());\n+    }\n+    \n+    // @since 1.8\n+    public void testRootValueWithCustomKey() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        MapKeyMap result = m.readValue(\" { \\\"a\\\": 13 } \", MapKeyMap.class);\n+        assertNotNull(result);\n+        assertNotNull(result);\n+        assertEquals(1, result.size());\n+        Map.Entry<Object,Object> en = result.entrySet().iterator().next();\n+        assertEquals(ValueClass.class, en.getValue().getClass());\n+        assertEquals(13, ((ValueClass) en.getValue())._a);\n+        assertEquals(String[].class, en.getKey().getClass());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestAnyProperties.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for verifying that {@link JsonAnySetter} annotation\n+ * works as expected.\n+ */\n+public class TestAnyProperties\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes\n+    /**********************************************************\n+     */\n+\n+    static class MapImitator\n+    {\n+        HashMap<String,Object> _map;\n+\n+        public MapImitator() {\n+            _map = new HashMap<String,Object>();\n+        }\n+\n+        @JsonAnySetter\n+        void addEntry(String key, Object value)\n+        {\n+            _map.put(key, value);\n+        }\n+    }\n+\n+    /**\n+     * Let's also verify that it is possible to define different\n+     * value: not often useful, but possible.\n+     */\n+    static class MapImitatorWithValue\n+    {\n+        HashMap<String,int[]> _map;\n+\n+        public MapImitatorWithValue() {\n+            _map = new HashMap<String,int[]>();\n+        }\n+\n+        @JsonAnySetter\n+        void addEntry(String key, int[] value)\n+        {\n+            _map.put(key, value);\n+        }\n+    }\n+\n+    // Bad; 2 \"any setters\"\n+    static class Broken\n+    {\n+        @JsonAnySetter\n+        void addEntry1(String key, Object value) { }\n+        @JsonAnySetter\n+        void addEntry2(String key, Object value) { }\n+    }\n+\n+    @JsonIgnoreProperties(\"dummy\")\n+    static class Ignored\n+    {\n+        HashMap<String,Object> map = new HashMap<String,Object>();\n+ \n+        @JsonIgnore\n+        public String bogus;\n+        \n+        @JsonAnySetter\n+        void addEntry(String key, Object value)\n+        {\n+            map.put(key, value);\n+        }        \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleMapImitation() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        MapImitator mapHolder = m.readValue\n+            (\"{ \\\"a\\\" : 3, \\\"b\\\" : true }\", MapImitator.class);\n+        Map<String,Object> result = mapHolder._map;\n+        assertEquals(2, result.size());\n+        assertEquals(Integer.valueOf(3), result.get(\"a\"));\n+        assertEquals(Boolean.TRUE, result.get(\"b\"));\n+    }\n+\n+    public void testSimpleTyped() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        MapImitatorWithValue mapHolder = m.readValue\n+            (\"{ \\\"a\\\" : [ 3, -1 ], \\\"b\\\" : [ ] }\", MapImitatorWithValue.class);\n+        Map<String,int[]> result = mapHolder._map;\n+        assertEquals(2, result.size());\n+        assertEquals(new int[] { 3, -1 }, result.get(\"a\"));\n+        assertEquals(new int[0], result.get(\"b\"));\n+    }\n+\n+    public void testBrokenWithDoubleAnnotations() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        try {\n+            @SuppressWarnings(\"unused\")\n+            Broken b = m.readValue(\"{ \\\"a\\\" : 3 }\", Broken.class);\n+            fail(\"Should have gotten an exception\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Multiple 'any-setters'\");\n+        }\n+    }\n+\n+    // [JACKSON-313]\n+    public void testIgnored() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(com.fasterxml.jackson.databind.DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, true);\n+        Ignored bean = mapper.readValue(\"{\\\"name\\\":\\\"Bob\\\", \\\"bogus\\\": [ 1, 2, 3], \\\"dummy\\\" : 13 }\", Ignored.class);\n+        assertNull(bean.map.get(\"dummy\"));\n+        assertNull(bean.map.get(\"bogus\"));\n+        assertEquals(\"Bob\", bean.map.get(\"name\"));\n+        assertEquals(1, bean.map.size());\n+    }\n+\n+    public void testIgnored383() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(com.fasterxml.jackson.databind.DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        Ignored bean = mapper.readValue(\"{\\\"name\\\":\\\"Bob\\\", \\\"bogus\\\": [ 1, 2, 3], \\\"dummy\\\" : 13 }\", Ignored.class);\n+        assertNull(bean.map.get(\"dummy\"));\n+        assertNull(bean.map.get(\"bogus\"));\n+        assertEquals(\"Bob\", bean.map.get(\"name\"));\n+        assertEquals(1, bean.map.size());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestArrayDeserialization.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import static org.junit.Assert.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * This unit test suite tries to verify that the \"Native\" java type\n+ * mapper can properly re-construct Java array objects from Json arrays.\n+ */\n+public class TestArrayDeserialization\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    public final static class Bean1\n+    {\n+        int _x, _y;\n+        List<Bean2> _beans;\n+\n+        // Just for deserialization:\n+        @SuppressWarnings(\"unused\")\n+        private Bean1() { }\n+\n+        public Bean1(int x, int y, List<Bean2> beans)\n+        {\n+            _x = x;\n+            _y = y;\n+            _beans = beans;\n+        }\n+\n+        public int getX() { return _x; }\n+        public int getY() { return _y; }\n+        public List<Bean2> getBeans() { return _beans; }\n+\n+        public void setX(int x) { _x = x; }\n+        public void setY(int y) { _y = y; }\n+        public void setBeans(List<Bean2> b) { _beans = b; }\n+\n+        @Override public boolean equals(Object o) {\n+            if (!(o instanceof Bean1)) return false;\n+            Bean1 other = (Bean1) o;\n+            return (_x == other._x)\n+                && (_y == other._y)\n+                && _beans.equals(other._beans)\n+                ;\n+        }\n+    }\n+\n+    /**\n+     * Simple bean that just gets serialized as a String value.\n+     * Deserialization from String value will be done via single-arg\n+     * constructor.\n+     */\n+    public final static class Bean2\n+        implements JsonSerializable // so we can output as simple String\n+    {\n+        final String _desc;\n+\n+        public Bean2(String d)\n+        {\n+            _desc = d;\n+        }\n+\n+        @Override\n+        public void serialize(JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeString(_desc);\n+        }\n+\n+        @Override public String toString() { return _desc; }\n+\n+        @Override public boolean equals(Object o) {\n+            if (!(o instanceof Bean2)) return false;\n+            Bean2 other = (Bean2) o;\n+            return _desc.equals(other._desc);\n+        }\n+\n+        @Override\n+        public void serializeWithType(JsonGenerator jgen,\n+                SerializerProvider provider, TypeSerializer typeSer)\n+                throws IOException, JsonProcessingException {\n+            // TODO Auto-generated method stub\n+            \n+        }\n+    }\t\n+\n+    static class ObjectWrapper {\n+        public Object wrapped;\n+    }\n+\n+    static class ObjectArrayWrapper {\n+    \tpublic Object[] wrapped;\n+    }\n+\n+    static class CustomNonDeserArrayDeserializer extends JsonDeserializer<NonDeserializable[]>\n+    {\n+        @Override\n+        public NonDeserializable[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        {\n+            List<NonDeserializable> list = new ArrayList<NonDeserializable>();\n+            while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                list.add(new NonDeserializable(jp.getText(), false));\n+            }\n+            return list.toArray(new NonDeserializable[list.size()]);\n+        }\n+    }\n+\n+    static class NonDeserializable {\n+        protected String value;\n+        \n+        public NonDeserializable(String v, boolean bogus) {\n+            value = v;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Tests for \"untyped\" arrays, Object[]\n+    /**********************************************************\n+     */\n+\n+    public void testUntypedArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        // to get \"untyped\" default map-to-map, pass Object[].class\n+        String JSON = \"[ 1, null, \\\"x\\\", true, 2.0 ]\";\n+\n+        Object[] result = mapper.readValue(JSON, Object[].class);\n+        assertNotNull(result);\n+\n+        assertEquals(5, result.length);\n+\n+        assertEquals(Integer.valueOf(1), result[0]);\n+        assertNull(result[1]);\n+        assertEquals(\"x\", result[2]);\n+        assertEquals(Boolean.TRUE, result[3]);\n+        assertEquals(Double.valueOf(2.0), result[4]);\n+    }\n+\n+    public void testIntegerArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final int LEN = 90000;\n+\n+        // Let's construct array to get it big enough\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (int i = 0; i < LEN; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n+            }\n+            sb.append(i);\n+        }\n+        sb.append(']');\n+\n+        Integer[] result = mapper.readValue(sb.toString(), Integer[].class);\n+        assertNotNull(result);\n+\n+        assertEquals(LEN, result.length);\n+        for (int i = 0; i < LEN; ++i) {\n+            assertEquals(i, result[i].intValue());\n+        }\n+    }\n+\n+    // [JACKSON-620]: allow \"\" to mean 'null' for Maps\n+    public void testFromEmptyString() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+        assertNull(m.readValue(quote(\"\"), Object[].class));\n+        assertNull( m.readValue(quote(\"\"), String[].class));\n+        assertNull( m.readValue(quote(\"\"), int[].class));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Arrays of arrays...\n+    /**********************************************************\n+     */\n+\n+    public void testUntypedArrayOfArrays() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        // to get \"untyped\" default map-to-map, pass Object[].class\n+        final String JSON = \"[[[-0.027512,51.503221],[-0.008497,51.503221],[-0.008497,51.509744],[-0.027512,51.509744]]]\";\n+\n+        Object result = mapper.readValue(JSON, Object.class);\n+        assertEquals(ArrayList.class, result.getClass());\n+        assertNotNull(result);\n+\n+        // Should be able to get it as an Object array as well\n+\n+        Object[] array = mapper.readValue(JSON, Object[].class);\n+        assertNotNull(array);\n+        assertEquals(Object[].class, array.getClass());\n+\n+        // and as wrapped variants too\n+        ObjectWrapper w = mapper.readValue(\"{\\\"wrapped\\\":\"+JSON+\"}\", ObjectWrapper.class);\n+        assertNotNull(w);\n+        assertNotNull(w.wrapped);\n+        assertEquals(ArrayList.class, w.wrapped.getClass());\n+\n+        ObjectArrayWrapper aw = mapper.readValue(\"{\\\"wrapped\\\":\"+JSON+\"}\", ObjectArrayWrapper.class);\n+        assertNotNull(aw);\n+        assertNotNull(aw.wrapped);\n+    }    \n+    \n+    /*\n+    /**********************************************************\n+    /* Tests for String arrays, char[]\n+    /**********************************************************\n+     */\n+\n+    public void testStringArray() throws Exception\n+    {\n+        final String[] STRS = new String[] {\n+            \"a\", \"b\", \"abcd\", \"\", \"???\", \"\\\"quoted\\\"\", \"lf: \\n\",\n+        };\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = new JsonFactory().createJsonGenerator(sw);\n+        jg.writeStartArray();\n+        for (String str : STRS) {\n+            jg.writeString(str);\n+        }\n+        jg.writeEndArray();\n+        jg.close();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String[] result = mapper.readValue(sw.toString(), String[].class);\n+        assertNotNull(result);\n+\n+        assertEquals(STRS.length, result.length);\n+        for (int i = 0; i < STRS.length; ++i) {\n+            assertEquals(STRS[i], result[i]);\n+        }\n+    }\n+\n+    public void testCharArray() throws Exception\n+    {\n+        final String TEST_STR = \"Let's just test it? Ok!\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        char[] result = mapper.readValue(\"\\\"\"+TEST_STR+\"\\\"\", char[].class);\n+        assertEquals(TEST_STR, new String(result));\n+\n+        // And just for [JACKSON-289], let's verify that fluffy arrays work too\n+        result = mapper.readValue(\"[\\\"a\\\",\\\"b\\\",\\\"c\\\"]\", char[].class);\n+        assertEquals(\"abc\", new String(result));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests for primitive arrays\n+    /**********************************************************\n+     */\n+\n+    public void testBooleanArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        boolean[] result = mapper.readValue(\"[ true, false, false ]\", boolean[].class);\n+        assertNotNull(result);\n+        assertEquals(3, result.length);\n+        assertTrue(result[0]);\n+        assertFalse(result[1]);\n+        assertFalse(result[2]);\n+    }\n+\n+    public void testByteArrayAsNumbers() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final int LEN = 37000;\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (int i = 0; i < LEN; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n+            }\n+            sb.append(i & 0x7F);\n+        }\n+        sb.append(']');\n+        byte[] result = mapper.readValue(sb.toString(), byte[].class);\n+        assertNotNull(result);\n+        assertEquals(LEN, result.length);\n+        for (int i = 0; i < LEN; ++i) {\n+            byte exp = (byte) (i & 0x7F);\n+            assertEquals(exp, result[i]);\n+        }\n+    }\n+\n+    public void testByteArrayAsBase64() throws Exception\n+    {\n+        /* Hmmh... let's use JsonGenerator here, to hopefully ensure we\n+         * get proper base64 encoding. Plus, not always using that\n+         * silly sample from Wikipedia.\n+         */\n+        JsonFactory jf = new JsonFactory();\n+        StringWriter sw = new StringWriter();\n+\n+        int LEN = 9000;\n+        byte[] TEST = new byte[LEN];\n+        for (int i = 0; i < LEN; ++i) {\n+            TEST[i] = (byte) i;\n+        }\n+\n+        JsonGenerator jg = jf.createJsonGenerator(sw);\n+        jg.writeBinary(TEST);\n+        jg.close();\n+        String inputData = sw.toString();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        byte[] result = mapper.readValue(inputData, byte[].class);\n+        assertNotNull(result);\n+        assertArrayEquals(TEST, result);\n+    }\n+\n+    /**\n+     * And then bit more challenging case; let's try decoding\n+     * multiple byte arrays from an array...\n+     */\n+    public void testByteArraysAsBase64() throws Exception\n+    {\n+        JsonFactory jf = new JsonFactory();\n+        StringWriter sw = new StringWriter(1000);\n+\n+        final int entryCount = 15;\n+\n+        JsonGenerator jg = jf.createJsonGenerator(sw);\n+        jg.writeStartArray();\n+\n+        byte[][] entries = new byte[entryCount][];\n+        for (int i = 0; i < entryCount; ++i) {\n+            byte[] b = new byte[1000 - i * 20];\n+            for (int x = 0; x < b.length; ++x) {\n+                b[x] = (byte) (i + x);\n+            }\n+            entries[i] = b;\n+            jg.writeBinary(b);\n+        }\n+        jg.writeEndArray();\n+        jg.close();\n+\n+        String inputData = sw.toString();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        byte[][] result = mapper.readValue(inputData, byte[][].class);\n+        assertNotNull(result);\n+\n+        assertEquals(entryCount, result.length);\n+        for (int i = 0; i < entryCount; ++i) {\n+            byte[] b = result[i];\n+            assertArrayEquals(\"Comparing entry #\"+i+\"/\"+entryCount,entries[i], b);\n+        }\n+    }\n+\n+    public void testShortArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final int LEN = 31001; // fits in signed 16-bit\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (int i = 0; i < LEN; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n+            }\n+            sb.append(i);\n+        }\n+        sb.append(']');\n+\n+        short[] result = mapper.readValue(sb.toString(), short[].class);\n+        assertNotNull(result);\n+\n+        assertEquals(LEN, result.length);\n+        for (int i = 0; i < LEN; ++i) {\n+            short exp = (short) i;\n+            assertEquals(exp, result[i]);\n+        }\n+    }\n+\n+    public void testIntArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final int LEN = 70000;\n+\n+        // Let's construct array to get it big enough\n+\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (int i = 0; i < LEN; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n+            }\n+            sb.append(-i);\n+        }\n+        sb.append(']');\n+\n+        int[] result = mapper.readValue(sb.toString(), int[].class);\n+        assertNotNull(result);\n+\n+        assertEquals(LEN, result.length);\n+        for (int i = 0; i < LEN; ++i) {\n+            assertEquals(-i, result[i]);\n+        }\n+    }\n+\n+    public void testLongArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final int LEN = 12300;\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (int i = 0; i < LEN; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n+            }\n+            sb.append(i);\n+        }\n+        sb.append(']');\n+\n+        long[] result = mapper.readValue(sb.toString(), long[].class);\n+        assertNotNull(result);\n+\n+        assertEquals(LEN, result.length);\n+        for (int i = 0; i < LEN; ++i) {\n+            long exp = (long) i;\n+            assertEquals(exp, result[i]);\n+        }\n+    }\n+\n+    public void testDoubleArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final int LEN = 7000;\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (int i = 0; i < LEN; ++i) {\n+            // not ideal, but has to do...\n+            if (i > 0) {\n+                sb.append(',');\n+            }\n+            sb.append(i).append('.').append(i % 10);\n+        }\n+        sb.append(']');\n+\n+        double[] result = mapper.readValue(sb.toString(), double[].class);\n+        assertNotNull(result);\n+\n+        assertEquals(LEN, result.length);\n+        for (int i = 0; i < LEN; ++i) {\n+            String expStr = String.valueOf(i) + \".\" + String.valueOf(i % 10);\n+            String actStr = String.valueOf(result[i]);\n+            if (!expStr.equals(actStr)) {\n+                fail(\"Entry #\"+i+\"/\"+LEN+\"; exp '\"+expStr+\"', got '\"+actStr+\"'\");\n+            }\n+        }\n+    }\n+\n+    public void testFloatArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final int LEN = 7000;\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[');\n+        for (int i = 0; i < LEN; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n+            }\n+            // not ideal, but has to do...\n+            sb.append(i).append('.').append(i % 10);\n+        }\n+        sb.append(']');\n+\n+        float[] result = mapper.readValue(sb.toString(), float[].class);\n+        assertNotNull(result);\n+\n+        assertEquals(LEN, result.length);\n+        for (int i = 0; i < LEN; ++i) {\n+            String expStr = String.valueOf(i) + \".\" + String.valueOf(i % 10);\n+            assertEquals(expStr, String.valueOf(result[i]));\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests for Bean arrays\n+    /**********************************************************\n+     */\n+\n+    public void testBeanArray()\n+        throws Exception\n+    {\n+        List<Bean1> src = new ArrayList<Bean1>();\n+\n+        List<Bean2> b2 = new ArrayList<Bean2>();\n+        b2.add(new Bean2(\"a\"));\n+        b2.add(new Bean2(\"foobar\"));\n+        src.add(new Bean1(1, 2, b2));\n+\n+        b2 = new ArrayList<Bean2>();\n+        b2.add(null);\n+        src.add(new Bean1(4, 5, b2));\n+\n+        // Ok: let's assume bean serializer works ok....\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+\n+        mapper.writeValue(sw, src);\n+\n+        // And then test de-serializer\n+        List<Bean1> result = mapper.readValue(sw.toString(), new TypeReference<List<Bean1>>() { });\n+        assertNotNull(result);\n+        assertEquals(src, result);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* And custom deserializers too\n+    /**********************************************************\n+     */\n+\n+    public void testCustomDeserializers() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule testModule = new SimpleModule(\"test\", Version.unknownVersion());\n+        testModule.addDeserializer(NonDeserializable[].class, new CustomNonDeserArrayDeserializer());\n+        mapper.registerModule(testModule);\n+        \n+        NonDeserializable[] result = mapper.readValue(\"[\\\"a\\\"]\", NonDeserializable[].class);\n+        assertNotNull(result);\n+        assertEquals(1, result.length);\n+        assertEquals(\"a\", result[0].value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestAutoDetect.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestAutoDetect\n+    extends BaseMapTest\n+{\n+    /*\n+    /********************************************************\n+    /* Helper beans\n+    /********************************************************\n+     */\n+\n+    static class PrivateBean {\n+        String a;\n+\n+        private PrivateBean() { }\n+\n+        private PrivateBean(String a) { this.a = a; }\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Unit tests\n+    /********************************************************\n+     */\n+    \n+    public void testPrivateCtor() throws Exception\n+    {\n+        // first, default settings, with which construction works ok\n+        ObjectMapper m = new ObjectMapper();\n+        PrivateBean bean = m.readValue(\"\\\"abc\\\"\", PrivateBean.class);\n+        assertEquals(\"abc\", bean.a);\n+\n+        // then by increasing visibility requirement:\n+        m = new ObjectMapper();\n+        m.setVisibilityChecker(m.getVisibilityChecker().withCreatorVisibility\n+                (JsonAutoDetect.Visibility.PUBLIC_ONLY));\n+        try {\n+            m.readValue(\"\\\"abc\\\"\", PrivateBean.class);\n+            fail(\"Expected exception for missing constructor\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"no single-String constructor/factory\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBasicAnnotations.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+\n+/**\n+ * This unit test suite tests use of basic Annotations for\n+ * bean deserialization; ones that indicate (non-constructor)\n+ * method types, explicit deserializer annotations.\n+ */\n+public class TestBasicAnnotations\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes\n+    /**********************************************************\n+     */\n+\n+    /// Class for testing {@link JsonProperty} annotations\n+    final static class SizeClassSetter\n+    {\n+        int _size;\n+        int _length;\n+        int _other;\n+\n+        @JsonProperty public void size(int value) { _size = value; }\n+        @JsonProperty(\"length\") public void foobar(int value) { _length = value; }\n+\n+        // note: need not be public if annotated\n+        @JsonProperty protected void other(int value) { _other = value; }\n+\n+        // finally: let's add a red herring that should be avoided...\n+        public void errorOut(int value) { throw new Error(); }\n+    }\n+\n+    final static class SizeClassSetter2\n+    {\n+        int _x;\n+\n+        @JsonProperty public void setX(int value) { _x = value; }\n+\n+        // another red herring, which shouldn't be included\n+        public void setXandY(int x, int y) { throw new Error(); }\n+    }\n+\n+    /**\n+     * One more, but this time checking for implied setter\n+     * using @JsonDeserialize\n+     */\n+    final static class SizeClassSetter3\n+    {\n+        int _x;\n+\n+        @JsonDeserialize public void x(int value) { _x = value; }\n+    }\n+\n+\n+    /// Classes for testing Setter discovery with inheritance\n+    static class BaseBean\n+    {\n+        int _x = 0, _y = 0;\n+\n+        public void setX(int value) { _x = value; }\n+        @JsonProperty(\"y\") void foobar(int value) { _y = value; }\n+    }\n+\n+    static class BeanSubClass extends BaseBean\n+    {\n+        int _z;\n+\n+        public void setZ(int value) { _z = value; }\n+    }\n+\n+    static class BeanWithDeserialize {\n+        @JsonDeserialize private int a;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other helper classes\n+    /**********************************************************\n+     */\n+\n+    final static class IntsDeserializer extends StdDeserializer<int[]>\n+    {\n+        public IntsDeserializer() { super(int[].class); }\n+        @Override\n+        public int[] deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return new int[] { jp.getIntValue() };\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleSetter() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        SizeClassSetter result = m.readValue\n+            (\"{ \\\"other\\\":3, \\\"size\\\" : 2, \\\"length\\\" : -999 }\",\n+             SizeClassSetter.class);\n+                                             \n+        assertEquals(3, result._other);\n+        assertEquals(2, result._size);\n+        assertEquals(-999, result._length);\n+    }\n+\n+    // Test for checking [JACKSON-64]\n+    public void testSimpleSetter2() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        SizeClassSetter2 result = m.readValue\n+            (\"{ \\\"x\\\": -3 }\",\n+             SizeClassSetter2.class);\n+        assertEquals(-3, result._x);\n+    }\n+\n+    // Checking parts of [JACKSON-120]\n+    public void testSimpleSetter3() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        SizeClassSetter3 result = m.readValue\n+            (\"{ \\\"x\\\": 128 }\",\n+             SizeClassSetter3.class);\n+        assertEquals(128, result._x);\n+    }\n+\n+    /**\n+     * Test for verifying that super-class setters are used as\n+     * expected.\n+     */\n+    public void testSetterInheritance() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        BeanSubClass result = m.readValue\n+            (\"{ \\\"x\\\":1, \\\"z\\\" : 3, \\\"y\\\" : 2 }\",\n+             BeanSubClass.class);\n+        assertEquals(1, result._x);\n+        assertEquals(2, result._y);\n+        assertEquals(3, result._z);\n+    }\n+\n+    public void testImpliedProperty() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        BeanWithDeserialize bean = m.readValue(\"{\\\"a\\\":3}\", BeanWithDeserialize.class);\n+        assertNotNull(bean);\n+        assertEquals(3, bean.a);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBeanDeserializer.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.BeanDeserializer;\n+import com.fasterxml.jackson.databind.deser.BeanDeserializerBuilder;\n+import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n+import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+public class TestBeanDeserializer extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static class Bean {\n+        public String b = \"b\";\n+        public String a = \"a\";\n+\n+        public Bean() { }\n+        public Bean(String a, String b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+    }\n+\n+    static class ModuleImpl extends SimpleModule\n+    {\n+        protected BeanDeserializerModifier modifier;\n+        \n+        public ModuleImpl(BeanDeserializerModifier modifier)\n+        {\n+            super(\"test\", Version.unknownVersion());\n+            this.modifier = modifier;\n+        }\n+        \n+        @Override\n+        public void setupModule(SetupContext context)\n+        {\n+            super.setupModule(context);\n+            if (modifier != null) {\n+                context.addBeanDeserializerModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    static class RemovingModifier extends BeanDeserializerModifier\n+    {\n+        private final String _removedProperty;\n+        \n+        public RemovingModifier(String remove) { _removedProperty = remove; }\n+        \n+        @Override\n+        public BeanDeserializerBuilder updateBuilder(DeserializationConfig config,\n+                BasicBeanDescription beanDesc, BeanDeserializerBuilder builder) {\n+            builder.addIgnorable(_removedProperty);\n+            return builder;\n+        }\n+    }\n+    \n+    static class ReplacingModifier extends BeanDeserializerModifier\n+    {\n+        private final JsonDeserializer<?> _deserializer;\n+        \n+        public ReplacingModifier(JsonDeserializer<?> s) { _deserializer = s; }\n+        \n+        @Override\n+        public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config, BasicBeanDescription beanDesc,\n+                JsonDeserializer<?> deserializer) {\n+            return _deserializer;\n+        }\n+    }\n+\n+    static class BogusBeanDeserializer extends JsonDeserializer<Object>\n+    {\n+        private final String a, b;\n+        \n+        public BogusBeanDeserializer(String a, String b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+        \n+        @Override\n+        public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+                throws IOException, JsonProcessingException\n+        {\n+            return new Bean(a, b);\n+        }\n+    }\n+\n+    static class Issue476Bean {\n+        public Issue476Type value1, value2;\n+    }\n+    static class Issue476Type {\n+        public String name, value;\n+    }\n+    static class Issue476Deserializer extends BeanDeserializer\n+        implements ContextualDeserializer<Object>\n+    {\n+        protected static int propCount;\n+\n+        public Issue476Deserializer(BeanDeserializer src) {\n+            super(src);\n+        }\n+\n+        @Override\n+        public JsonDeserializer<Object> createContextual(DeserializationConfig config, BeanProperty property) throws JsonMappingException {\n+            propCount++;\n+            return this;\n+        }        \n+    }\n+    public class Issue476DeserializerModifier extends BeanDeserializerModifier {\n+        @Override\n+        public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config, BasicBeanDescription beanDesc, JsonDeserializer<?> deserializer) {\n+            if (Issue476Type.class == beanDesc.getBeanClass()) {\n+                return new Issue476Deserializer((BeanDeserializer)deserializer);\n+            }\n+            return super.modifyDeserializer(config, beanDesc, deserializer);\n+        }        \n+    }\n+    public class Issue476Module extends SimpleModule\n+    {\n+        public Issue476Module() {\n+            super(\"Issue476Module\", Version.unknownVersion());\n+        }\n+        \n+        @Override\n+        public void setupModule(SetupContext context) {\n+            context.addBeanDeserializerModifier(new Issue476DeserializerModifier());\n+        }        \n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Unit tests\n+    /********************************************************\n+     */\n+\n+    public void testPropertyRemoval() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new ModuleImpl(new RemovingModifier(\"a\")));\n+        Bean bean = mapper.readValue(\"{\\\"b\\\":\\\"2\\\"}\", Bean.class);\n+        assertEquals(\"2\", bean.b);\n+        // and 'a' has its default value:\n+        assertEquals(\"a\", bean.a);\n+    } \n+\n+    public void testDeserializerReplacement() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new ModuleImpl(new ReplacingModifier(new BogusBeanDeserializer(\"foo\", \"bar\"))));\n+        Bean bean = mapper.readValue(\"{\\\"a\\\":\\\"xyz\\\"}\", Bean.class);\n+        // custom deserializer always produces instance like this:\n+        assertEquals(\"foo\", bean.a);\n+        assertEquals(\"bar\", bean.b);\n+    }\n+\n+    public void testIssue476() throws Exception\n+    {\n+        final String JSON = \"{\\\"value1\\\" : {\\\"name\\\" : \\\"fruit\\\", \\\"value\\\" : \\\"apple\\\"}, \\\"value2\\\" : {\\\"name\\\" : \\\"color\\\", \\\"value\\\" : \\\"red\\\"}}\";\n+        \n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new Issue476Module());\n+        mapper.readValue(JSON, Issue476Bean.class);\n+\n+        // there are 2 properties\n+        assertEquals(2, Issue476Deserializer.propCount);\n+    }\n+\n+    public void testPOJOFromEmptyString() throws Exception\n+    {\n+        // first, verify default settings which do not accept empty String:\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.readValue(quote(\"\"), Bean.class);\n+            fail(\"Should not accept Empty String for POJO\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"from JSON String\");\n+        }\n+\n+        // should be ok to enable dynamically:\n+        mapper = new ObjectMapper();\n+        mapper.configure(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+        Bean result = mapper.readValue(quote(\"\"), Bean.class);\n+        assertNull(result);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestBlocking.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit test mostly written to cover issue [JACKSON-81]; unintended blocking\n+ * after data binding.\n+ */\n+public class TestBlocking\n+    extends BaseMapTest\n+{\n+    /**\n+     * This is an indirect test that should trigger problems if (and only if)\n+     * underlying parser is advanced beyond the only element array.\n+     * Basically, although content is invalid, this should be encountered\n+     * quite yet.\n+     */\n+    public void testEagerAdvance() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonParser jp = createParserUsingReader(\"[ 1  \");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+\n+        // And then try to map just a single entry: shouldn't fail:\n+        Integer I = mapper.readValue(jp, Integer.class);\n+        assertEquals(Integer.valueOf(1), I);\n+\n+        // and should fail only now:\n+        try {\n+            jp.nextToken();\n+        } catch (IOException ioe) {\n+            verifyException(ioe, \"Unexpected end-of-input: expected close marker for ARRAY\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+\n+public class TestCollectionDeserialization\n+    extends BaseMapTest\n+{\n+    enum Key {\n+        KEY1, KEY2, WHATEVER;\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    @JsonDeserialize(using=ListDeserializer.class)\n+    static class CustomList extends LinkedList<String> { }\n+\n+    static class ListDeserializer extends StdDeserializer<CustomList>\n+    {\n+        public ListDeserializer() { super(CustomList.class); }\n+\n+        @Override\n+        public CustomList deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException\n+        {\n+            CustomList result = new CustomList();\n+            result.add(jp.getText());\n+            return result;\n+        }\n+    }\n+\n+    static class XBean {\n+        public int x;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    public void testUntypedList() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // to get \"untyped\" default List, pass Object.class\n+        String JSON = \"[ \\\"text!\\\", true, null, 23 ]\";\n+\n+        /* Not a guaranteed cast theoretically, but will work:\n+         * (since we know that Jackson will construct an ArrayList here...)\n+         */\n+        Object value = mapper.readValue(JSON, Object.class);\n+        assertNotNull(value);\n+        assertTrue(value instanceof ArrayList<?>);\n+        List<?> result = (List<?>) value;\n+\n+        assertEquals(4, result.size());\n+\n+        assertEquals(\"text!\", result.get(0));\n+        assertEquals(Boolean.TRUE, result.get(1));\n+        assertNull(result.get(2));\n+        assertEquals(Integer.valueOf(23), result.get(3));\n+    }\n+\n+    public void testExactStringCollection() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // to get typing, must use type reference\n+        String JSON = \"[ \\\"a\\\", \\\"b\\\" ]\";\n+        List<String> result = mapper.readValue(JSON, new TypeReference<ArrayList<String>>() { });\n+\n+        assertNotNull(result);\n+        assertEquals(ArrayList.class, result.getClass());\n+        assertEquals(2, result.size());\n+\n+        assertEquals(\"a\", result.get(0));\n+        assertEquals(\"b\", result.get(1));\n+    }\n+\n+    public void testHashSet() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String JSON = \"[ \\\"KEY1\\\", \\\"KEY2\\\" ]\";\n+\n+        EnumSet<Key> result = mapper.readValue(JSON, new TypeReference<EnumSet<Key>>() { });\n+        assertNotNull(result);\n+        assertTrue(EnumSet.class.isAssignableFrom(result.getClass()));\n+        assertEquals(2, result.size());\n+\n+        assertTrue(result.contains(Key.KEY1));\n+        assertTrue(result.contains(Key.KEY2));\n+        assertFalse(result.contains(Key.WHATEVER));\n+    }\n+\n+    /**\n+     * Test to verify that @JsonDeserialize.using works as expected\n+     */\n+    public void testCustomDeserializer() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        CustomList result = mapper.readValue(quote(\"abc\"), CustomList.class);\n+        assertEquals(1, result.size());\n+        assertEquals(\"abc\", result.get(0));\n+    }\n+\n+    /* Testing [JACKSON-526], \"implicit JSON array\" for single-element arrays,\n+     * mostly produced by Jettison, Badgerfish conversions (from XML)\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testImplicitArrays() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);\n+\n+        // first with simple scalar types (numbers), with collections\n+        List<Integer> ints = mapper.readValue(\"4\", List.class);\n+        assertEquals(1, ints.size());\n+        assertEquals(Integer.valueOf(4), ints.get(0));\n+        List<String> strings = mapper.readValue(quote(\"abc\"), new TypeReference<ArrayList<String>>() { });\n+        assertEquals(1, strings.size());\n+        assertEquals(\"abc\", strings.get(0));\n+        // and arrays:\n+        int[] intArray = mapper.readValue(\"-7\", int[].class);\n+        assertEquals(1, intArray.length);\n+        assertEquals(-7, intArray[0]);\n+        String[] stringArray = mapper.readValue(quote(\"xyz\"), String[].class);\n+        assertEquals(1, stringArray.length);\n+        assertEquals(\"xyz\", stringArray[0]);\n+\n+        // and then with Beans:\n+        List<XBean> xbeanList = mapper.readValue(\"{\\\"x\\\":4}\", new TypeReference<List<XBean>>() { });\n+        assertEquals(1, xbeanList.size());\n+        assertEquals(XBean.class, xbeanList.get(0).getClass());\n+\n+        Object ob = mapper.readValue(\"{\\\"x\\\":29}\", XBean[].class);\n+        XBean[] xbeanArray = (XBean[]) ob;\n+        assertEquals(1, xbeanArray.length);\n+        assertEquals(XBean.class, xbeanArray[0].getClass());\n+    }\n+\n+    // [JACKSON-620]: allow \"\" to mean 'null' for Maps\n+    public void testFromEmptyString() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+        List<?> result = m.readValue(quote(\"\"), List.class);\n+        assertNull(result);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestConcurrency.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+\n+/**\n+ * Testing for [JACKSON-237] (NPE due to race condition)\n+ */\n+public class TestConcurrency extends BaseMapTest\n+{\n+    /*\n+    /**********************************************\n+    /* Helper beans\n+    /**********************************************\n+     */\n+\n+    @JsonDeserialize(using=BeanDeserializer.class)\n+    static class Bean\n+    {\n+        public int value = 42;\n+    }\n+\n+    /*\n+    /**********************************************\n+    /* Helper classes\n+    /**********************************************\n+     */\n+    \n+    /**\n+     * Dummy deserializer used for verifying that partially handled (i.e. not yet\n+     * resolved) deserializers are not allowed to be used.\n+     */\n+    static class BeanDeserializer\n+        extends JsonDeserializer<Bean>\n+        implements ResolvableDeserializer\n+    {\n+        protected volatile boolean resolved = false;\n+        \n+        @Override\n+        public Bean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException, JsonProcessingException\n+        {\n+            if (!resolved) {\n+                throw new IOException(\"Deserializer not yet completely resolved\");\n+            }\n+            Bean b = new Bean();\n+            b.value = 13;\n+            return b;\n+        }\n+\n+        @Override\n+        public void resolve(DeserializationConfig config, DeserializerProvider provider)\n+            throws JsonMappingException\n+        {\n+            try {\n+                Thread.sleep(100L);\n+            } catch (Exception e) { }\n+            resolved = true;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************\n+    /* Unit tests\n+    /**********************************************\n+     */\n+\n+    public void testDeserializerResolution() throws Exception\n+    {\n+        /* Let's repeat couple of times, just to be sure; thread timing is not\n+         * exact science; plus caching plays a role too\n+         */\n+        final String JSON = \"{\\\"value\\\":42}\";\n+        \n+        for (int i = 0; i < 5; ++i) {\n+            final ObjectMapper mapper = new ObjectMapper();\n+            Runnable r = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        /*Bean b =*/ mapper.readValue(JSON, Bean.class);\n+                    } catch (Exception e) { }\n+                }\n+            };\n+            Thread t = new Thread(r);\n+            t.start();\n+            // then let it proceed\n+            Thread.sleep(10L);\n+            // and try the same...\n+            Bean b = mapper.readValue(JSON, Bean.class);\n+            // note: funny deserializer, mangles data.. :)\n+            assertEquals(13, b.value);\n+            t.join();\n+        }   \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestConfig.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for checking handling of DeserializationConfig.\n+ */\n+public class TestConfig\n+    extends BaseMapTest\n+{\n+    @JsonAutoDetect(setterVisibility=Visibility.NONE)\n+    final static class Dummy { }\n+\n+    final static class EmptyDummy { }\n+\n+    static class AnnoBean {\n+        int value = 3;\n+        \n+        @JsonProperty(\"y\")\n+            public void setX(int v) { value = v; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Main tests\n+    /**********************************************************\n+     */\n+\n+    public void testDefaults()\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        DeserializationConfig cfg = m.getDeserializationConfig();\n+\n+        // Expected defaults:\n+        assertTrue(cfg.isEnabled(DeserializationConfig.Feature.USE_ANNOTATIONS));\n+        assertTrue(cfg.isEnabled(DeserializationConfig.Feature.AUTO_DETECT_SETTERS));\n+        assertTrue(cfg.isEnabled(DeserializationConfig.Feature.AUTO_DETECT_CREATORS));\n+        assertTrue(cfg.isEnabled(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS));\n+        assertTrue(cfg.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n+\n+\n+        assertFalse(cfg.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS));\n+        assertFalse(cfg.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS));\n+\n+        assertTrue(cfg.isEnabled(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES));\n+    }\n+\n+    public void testOverrideIntrospectors()\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        DeserializationConfig cfg = m.getDeserializationConfig();\n+        // and finally, ensure we could override introspectors\n+        cfg = cfg.withClassIntrospector(null); // no way to verify tho\n+        cfg = cfg.withAnnotationIntrospector(null);\n+        assertNull(cfg.getAnnotationIntrospector());\n+    }\n+        \n+    public void testAnnotationsDisabled() throws Exception\n+    {\n+        // first: verify that annotation introspection is enabled by default\n+        ObjectMapper m = new ObjectMapper();\n+        assertTrue(m.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.USE_ANNOTATIONS));\n+        // with annotations, property is renamed\n+        AnnoBean bean = m.readValue(\"{ \\\"y\\\" : 0 }\", AnnoBean.class);\n+        assertEquals(0, bean.value);\n+\n+        m = new ObjectMapper();\n+        m.configure(DeserializationConfig.Feature.USE_ANNOTATIONS, false);\n+        // without annotations, should default to default bean-based name...\n+        bean = m.readValue(\"{ \\\"x\\\" : 0 }\", AnnoBean.class);\n+        assertEquals(0, bean.value);\n+    }\n+\n+    /**\n+     * Test for verifying working of [JACKSON-191]\n+     */\n+    public void testProviderConfig() throws Exception   \n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(0, mapper.getDeserializerProvider().cachedDeserializersCount());\n+        // and then should get one constructed for:\n+        AnnoBean bean = mapper.readValue(\"{ \\\"y\\\" : 3 }\", AnnoBean.class);\n+        assertNotNull(bean);\n+        assertEquals(1, mapper.getDeserializerProvider().cachedDeserializersCount());\n+        mapper.getDeserializerProvider().flushCachedDeserializers();\n+        assertEquals(0, mapper.getDeserializerProvider().cachedDeserializersCount());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestConstructFromMap.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.awt.Point; // just for convenience\n+import java.math.BigDecimal;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * This unit test suite that tests use of {@link JsonCreator}\n+ * with \"delegate\" constructors and factory methods: ones that\n+ * take a deserializable type that is bound from JSON content.\n+ * This is usually done to get two-phase data binding, often using\n+ * {@link java.util.Map} as the intermediate form.\n+ */\n+public class TestConstructFromMap\n+    extends BaseMapTest\n+{\n+    static class ConstructorFromMap\n+    {\n+        int _x;\n+        String _y;\n+\n+        @JsonCreator\n+        ConstructorFromMap(Map<?,?> arg)\n+        {\n+            _x = ((Number) arg.get(\"x\")).intValue();\n+            _y = (String) arg.get(\"y\");\n+        }\n+    }\n+\n+    static class FactoryFromPoint\n+    {\n+        int _x, _y;\n+\n+        private FactoryFromPoint(Point p) {\n+            _x = p.x;\n+            _y = p.y;\n+        }\n+\n+        @JsonCreator\n+        static FactoryFromPoint createIt(Point p)\n+        {\n+            return new FactoryFromPoint(p);\n+        }\n+    }\n+\n+    // Also: let's test BigDecimal-from-JSON-String factory\n+    static class FactoryFromDecimalString\n+    {\n+\tint _value;\n+\n+        private FactoryFromDecimalString(BigDecimal d) {\n+\t    _value = d.intValue();\n+        }\n+\n+        @JsonCreator\n+        static FactoryFromDecimalString whateverNameWontMatter(BigDecimal d)\n+        {\n+            return new FactoryFromDecimalString(d);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testViaConstructor() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        ConstructorFromMap result = m.readValue\n+            (\"{ \\\"x\\\":1, \\\"y\\\" : \\\"abc\\\" }\", ConstructorFromMap.class);\n+        assertEquals(1, result._x);\n+        assertEquals(\"abc\", result._y);\n+    }\n+\n+    public void testViaFactory() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        FactoryFromPoint result = m.readValue(\"{ \\\"x\\\" : 3, \\\"y\\\" : 4 }\", FactoryFromPoint.class);\n+        assertEquals(3, result._x);\n+        assertEquals(4, result._y);\n+    }\n+\n+    public void testViaFactoryUsingString() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        FactoryFromDecimalString result = m.readValue(\"\\\"12.57\\\"\", FactoryFromDecimalString.class);\n+        assertNotNull(result);\n+        assertEquals(12, result._value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCreators.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for verifying that it is possible to annotate\n+ * various kinds of things with {@link JsonCreator} annotation.\n+ */\n+public class TestCreators\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes, simple\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Simple(st) possible demonstration of using annotated\n+     * constructors\n+     */\n+    static class ConstructorBean {\n+        int x;\n+\n+        @JsonCreator protected ConstructorBean(@JsonProperty(\"x\") int x) {\n+            this.x = x;\n+        }\n+    }\n+\n+    /**\n+     * Another simple constructor, but with bit more unusual argument\n+     * type\n+     */\n+    static class BooleanConstructorBean {\n+        Boolean b;\n+        @JsonCreator protected BooleanConstructorBean(Boolean b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unused\")\n+    private static class BooleanConstructorBean2 {\n+        boolean b;\n+        @JsonCreator protected BooleanConstructorBean2(boolean b) {\n+            this.b = b;\n+        }\n+    }\n+    \n+    static class DoubleConstructorBean {\n+        Double d; // cup?\n+        @JsonCreator protected DoubleConstructorBean(Double d) {\n+            this.d = d;\n+        }\n+    }\n+\n+    static class FactoryBean {\n+        double d; // teehee\n+\n+        private FactoryBean(double value, boolean dummy) { d = value; }\n+\n+        @JsonCreator protected static FactoryBean createIt(@JsonProperty(\"f\") double value) {\n+            return new FactoryBean(value, true);\n+        }\n+    }\n+\n+    static class LongFactoryBean {\n+        long value;\n+\n+        private LongFactoryBean(long v) { value = v; }\n+\n+        @JsonCreator static protected LongFactoryBean valueOf(long v) {\n+            return new LongFactoryBean(v);\n+        }\n+    }\n+\n+    static class StringFactoryBean {\n+        String value;\n+\n+        private StringFactoryBean(String v, boolean dummy) { value = v; }\n+\n+        @JsonCreator static protected StringFactoryBean valueOf(String v) {\n+            return new StringFactoryBean(v, true);\n+        }\n+    }\n+\n+    static class FactoryBeanMixIn { // static just to be able to use static methods\n+        /**\n+         * Note: signature (name and parameter types) must match; but\n+         * only annotations will be used, not code or such. And use\n+         * is by augmentation, so we only need to add things to add\n+         * or override.\n+         */\n+        static FactoryBean createIt(@JsonProperty(\"mixed\") double xyz) {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Simple demonstration of INVALID construtor annotation (only\n+     * defining name for first arg)\n+     */\n+    static class BrokenBean {\n+        @JsonCreator protected BrokenBean(@JsonProperty(\"a\") int a,\n+                                          int b) {\n+        }\n+    }\n+\n+    /**\n+     * Bean that defines both creator and factory methor as\n+     * creators. Constructors have priority; but it is possible\n+     * to hide it using mix-in annotations.\n+     */\n+    static class CreatorBean\n+    {\n+        String a;\n+        int x;\n+\n+        @JsonCreator\n+        protected CreatorBean(@JsonProperty(\"a\") String paramA,\n+                              @JsonProperty(\"x\") int paramX)\n+        {\n+            a = \"ctor:\"+paramA;\n+            x = 1+paramX;\n+        }\n+\n+        private CreatorBean(String a, int x, boolean dummy) {\n+            this.a = a;\n+            this.x = x;\n+        }\n+\n+        @JsonCreator\n+        public static CreatorBean buildMeUpButterCup(@JsonProperty(\"a\") String paramA,\n+                                                     @JsonProperty(\"x\") int paramX)\n+        {\n+            return new CreatorBean(\"factory:\"+paramA, paramX-1, false);\n+        }\n+    }\n+\n+    /**\n+     * Class for sole purpose of hosting mix-in annotations.\n+     * Couple of things to note: (a) MUST be static class (non-static\n+     * get implicit pseudo-arg, 'this';\n+     * (b) for factory methods, must have static to match (part of signature)\n+     */\n+    abstract static class MixIn {\n+        @JsonIgnore private MixIn(String a, int x) { }\n+    }\n+\n+    static class MultiBean {\n+        Object value;\n+\n+        @JsonCreator public MultiBean(int v) { value = v; }\n+        @JsonCreator public MultiBean(double v) { value = v; }\n+        @JsonCreator public MultiBean(String v) { value = v; }\n+        @JsonCreator public MultiBean(boolean v) { value = v; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes, mixed (creator and props)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Test bean for ensuring that constructors can be mixed with setters\n+     */\n+    static class ConstructorAndPropsBean\n+    {\n+        final int a, b;\n+        boolean c;\n+\n+        @JsonCreator protected ConstructorAndPropsBean(@JsonProperty(\"a\") int a,\n+                                                       @JsonProperty(\"b\") int b)\n+        {\n+            this.a = a;\n+            this.b = b;\n+        }\n+\n+        public void setC(boolean value) { c = value; }\n+    }\n+\n+    /**\n+     * Test bean for ensuring that factory methods can be mixed with setters\n+     */\n+    static class FactoryAndPropsBean\n+    {\n+        boolean[] arg1;\n+        int arg2, arg3;\n+\n+        @JsonCreator protected FactoryAndPropsBean(@JsonProperty(\"a\") boolean[] arg)\n+        {\n+            arg1 = arg;\n+        }\n+\n+        public void setB(int value) { arg2 = value; }\n+        public void setC(int value) { arg3 = value; }\n+    }\n+\n+    static class DeferredConstructorAndPropsBean\n+    {\n+        final int[] createA;\n+        String propA = \"xyz\";\n+        String propB;\n+\n+        @JsonCreator\n+        public DeferredConstructorAndPropsBean(@JsonProperty(\"createA\") int[] a)\n+        {\n+            createA = a;\n+        }\n+        public void setPropA(String a) { propA = a; }\n+        public void setPropB(String b) { propB = b; }\n+    }\n+\n+    static class DeferredFactoryAndPropsBean\n+    {\n+        String prop, ctor;\n+\n+        @JsonCreator DeferredFactoryAndPropsBean(@JsonProperty(\"ctor\") String str)\n+        {\n+            ctor = str;\n+        }\n+\n+        public void setProp(String str) { prop = str; }\n+    }\n+\n+    /*\n+    //////////////////////////////////////////////\n+    // Annotated helper classes for Maps\n+    //////////////////////////////////////////////\n+     */\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MapWithCtor extends HashMap<Object,Object>\n+    {\n+        final int _number;\n+        String _text = \"initial\";\n+\n+        MapWithCtor() { this(-1, \"default\"); }\n+\n+        @JsonCreator\n+            public MapWithCtor(@JsonProperty(\"number\") int nr,\n+                               @JsonProperty(\"text\") String t)\n+        {\n+            _number = nr;\n+            _text = t;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MapWithFactory extends TreeMap<Object,Object>\n+    {\n+        Boolean _b;\n+\n+        private MapWithFactory(Boolean b) {\n+            _b = b;\n+        }\n+\n+        @JsonCreator\n+            static MapWithFactory createIt(@JsonProperty(\"b\") Boolean b)\n+        {\n+            return new MapWithFactory(b);\n+        }\n+    }\n+\n+    /*\n+    /////////////////////////////////////////////////////\n+    // Test methods, valid cases, non-deferred, no-mixins\n+    /////////////////////////////////////////////////////\n+     */\n+\n+    public void testSimpleConstructor() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        ConstructorBean bean = m.readValue(\"{ \\\"x\\\" : 42 }\", ConstructorBean.class);\n+        assertEquals(42, bean.x);\n+    }\n+\n+    public void testSimpleDoubleConstructor() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Double exp = new Double(\"0.25\");\n+        DoubleConstructorBean bean = m.readValue(exp.toString(), DoubleConstructorBean.class);\n+        assertEquals(exp, bean.d);\n+    }\n+\n+    public void testSimpleBooleanConstructor() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        BooleanConstructorBean bean = m.readValue(\" true \", BooleanConstructorBean.class);\n+        assertEquals(Boolean.TRUE, bean.b);\n+\n+        BooleanConstructorBean2 bean2 = m.readValue(\" true \", BooleanConstructorBean2.class);\n+        assertTrue(bean2.b);\n+    }\n+\n+    public void testSimpleFactory() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        FactoryBean bean = m.readValue(\"{ \\\"f\\\" : 0.25 }\", FactoryBean.class);\n+        assertEquals(0.25, bean.d);\n+    }\n+\n+    public void testLongFactory() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        long VALUE = 123456789000L;\n+        LongFactoryBean bean = m.readValue(String.valueOf(VALUE), LongFactoryBean.class);\n+        assertEquals(VALUE, bean.value);\n+    }\n+\n+    public void testStringFactory() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        String str = \"abc\";\n+        StringFactoryBean bean = m.readValue(quote(str), StringFactoryBean.class);\n+        assertEquals(str, bean.value);\n+    }\n+\n+    public void testConstructorCreator() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        CreatorBean bean = m.readValue\n+            (\"{ \\\"a\\\" : \\\"xyz\\\", \\\"x\\\" : 12 }\", CreatorBean.class);\n+        assertEquals(13, bean.x);\n+        assertEquals(\"ctor:xyz\", bean.a);\n+    }\n+\n+    public void testConstructorAndProps() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        ConstructorAndPropsBean bean = m.readValue\n+            (\"{ \\\"a\\\" : \\\"1\\\", \\\"b\\\": 2, \\\"c\\\" : true }\", ConstructorAndPropsBean.class);\n+        assertEquals(1, bean.a);\n+        assertEquals(2, bean.b);\n+        assertEquals(true, bean.c);\n+    }\n+\n+    public void testFactoryAndProps() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        FactoryAndPropsBean bean = m.readValue\n+            (\"{ \\\"a\\\" : [ false, true, false ], \\\"b\\\": 2, \\\"c\\\" : -1 }\", FactoryAndPropsBean.class);\n+        assertEquals(2, bean.arg2);\n+        assertEquals(-1, bean.arg3);\n+        boolean[] arg1 = bean.arg1;\n+        assertNotNull(arg1);\n+        assertEquals(3, arg1.length);\n+        assertFalse(arg1[0]);\n+        assertTrue(arg1[1]);\n+        assertFalse(arg1[2]);\n+    }\n+\n+    /**\n+     * Test to verify that multiple creators may co-exist, iff\n+     * they use different JSON type as input\n+     */\n+    public void testMultipleCreators() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        MultiBean bean = m.readValue(\"123\", MultiBean.class);\n+        assertEquals(Integer.valueOf(123), bean.value);\n+        bean = m.readValue(quote(\"abc\"), MultiBean.class);\n+        assertEquals(\"abc\", bean.value);\n+        bean = m.readValue(\"0.25\", MultiBean.class);\n+        assertEquals(Double.valueOf(0.25), bean.value);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods, valid cases, deferred, no mixins\n+    /**********************************************************\n+     */\n+\n+    public void testDeferredConstructorAndProps() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        DeferredConstructorAndPropsBean bean = m.readValue\n+            (\"{ \\\"propB\\\" : \\\"...\\\", \\\"createA\\\" : [ 1 ], \\\"propA\\\" : null }\",\n+             DeferredConstructorAndPropsBean.class);\n+\n+        assertEquals(\"...\", bean.propB);\n+        assertNull(bean.propA);\n+        assertNotNull(bean.createA);\n+        assertEquals(1, bean.createA.length);\n+        assertEquals(1, bean.createA[0]);\n+    }\n+\n+    public void testDeferredFactoryAndProps() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        DeferredFactoryAndPropsBean bean = m.readValue\n+            (\"{ \\\"prop\\\" : \\\"1\\\", \\\"ctor\\\" : \\\"2\\\" }\", DeferredFactoryAndPropsBean.class);\n+        assertEquals(\"1\", bean.prop);\n+        assertEquals(\"2\", bean.ctor);\n+    }\n+\n+    /*\n+    /////////////////////////////////////////////////////\n+    // Test methods, valid cases, mixins\n+    /////////////////////////////////////////////////////\n+     */\n+\n+    public void testFactoryCreatorWithMixin() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getDeserializationConfig().addMixInAnnotations(CreatorBean.class, MixIn.class);\n+        CreatorBean bean = m.readValue\n+            (\"{ \\\"a\\\" : \\\"xyz\\\", \\\"x\\\" : 12 }\", CreatorBean.class);\n+        assertEquals(11, bean.x);\n+        assertEquals(\"factory:xyz\", bean.a);\n+    }\n+\n+    public void testFactoryCreatorWithRenamingMixin() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getDeserializationConfig().addMixInAnnotations(FactoryBean.class, FactoryBeanMixIn.class);\n+        // override changes property name from \"f\" to \"mixed\"\n+        FactoryBean bean = m.readValue(\"{ \\\"mixed\\\" :  20.5 }\", FactoryBean.class);\n+        assertEquals(20.5, bean.d);\n+    }\n+\n+    /*\n+    /////////////////////////////////////////////////////\n+    // Test methods, valid cases, Map with creator\n+    // (to test [JACKSON-153])\n+    /////////////////////////////////////////////////////\n+     */\n+\n+    public void testMapWithConstructor() throws Exception\n+    {\n+        MapWithCtor result = new ObjectMapper().readValue\n+            (\"{\\\"text\\\":\\\"abc\\\", \\\"entry\\\":true, \\\"number\\\":123, \\\"xy\\\":\\\"yx\\\"}\",\n+             MapWithCtor.class);\n+        // regular Map entries:\n+        assertEquals(Boolean.TRUE, result.get(\"entry\"));\n+        assertEquals(\"yx\", result.get(\"xy\"));\n+        assertEquals(2, result.size());\n+        // then ones passed via constructor\n+        assertEquals(\"abc\", result._text);\n+        assertEquals(123, result._number);\n+    }\n+\n+    public void testMapWithFactory() throws Exception\n+    {\n+        MapWithFactory result = new ObjectMapper().readValue\n+            (\"{\\\"x\\\":\\\"...\\\",\\\"b\\\":true  }\",\n+             MapWithFactory.class);\n+        assertEquals(\"...\", result.get(\"x\"));\n+        assertEquals(1, result.size());\n+        assertEquals(Boolean.TRUE, result._b);\n+    }\n+\n+    /*\n+    //////////////////////////////////////////////\n+    // Test methods, invalid/broken cases\n+    //////////////////////////////////////////////\n+     */\n+\n+    public void testBrokenConstructor() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        try {\n+            /*BrokenBean bean =*/ m.readValue(\"{ \\\"x\\\" : 42 }\", BrokenBean.class);\n+        } catch (JsonMappingException je) {\n+            verifyException(je, \"has no property name\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCreators2.java\n+\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+\n+public class TestCreators2\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    static class HashTest\n+    {\n+        final byte[] bytes;\n+        final String type;\n+\n+        @JsonCreator\n+        public HashTest(@JsonProperty(\"bytes\") @JsonDeserialize(using = BytesDeserializer.class) final byte[] bytes,\n+                @JsonProperty(\"type\") final String type)\n+        {\n+            this.bytes = bytes;\n+            this.type = type;\n+        }\n+    }\n+\n+    static class BytesDeserializer extends JsonDeserializer<byte[]>\n+    {\n+        @Override\n+        public byte[] deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n+            String str = jp.getText();\n+            return str.getBytes(\"UTF-8\");\n+        }\n+    }\n+\n+    static class Primitives\n+    {\n+        protected int x = 3;\n+        protected double d = -0.5;\n+        protected boolean b = true;\n+        \n+        @JsonCreator\n+        public Primitives(@JsonProperty(\"x\") int x,\n+                @JsonProperty(\"d\") double d,\n+                @JsonProperty(\"b\") boolean b)\n+        {\n+            this.x = x;\n+            this.d = d;\n+            this.b = b;\n+        }\n+    }\n+    \n+    protected static class Test431Container {\n+        protected final List<Item431> items;\n+\n+        @JsonCreator\n+        public Test431Container(@JsonProperty(\"items\") final List<Item431> i) {\n+            items = i;\n+        }\n+}    \n+\n+    @JsonIgnoreProperties(ignoreUnknown = true)\n+    protected static class Item431 {\n+        protected final String id;\n+\n+        @JsonCreator\n+        public Item431(@JsonProperty(\"id\") String id) {\n+            this.id = id;\n+        }\n+    }\n+\n+    // Test class for verifying that creator-call failures are reported as checked exceptions\n+    static class BeanFor438 {\n+        @JsonCreator\n+        public BeanFor438(@JsonProperty(\"name\") String s) {\n+            throw new IllegalArgumentException(\"I don't like that name!\");\n+        }\n+    }\n+\n+    // For [JACKSON-465]\n+    static class MapBean\n+    {\n+        protected Map<String,Long> map;\n+        \n+        @JsonCreator\n+        public MapBean(Map<String, Long> map) {\n+            this.map = map;\n+        }\n+    }\n+\n+    // For [JACKSON-470]: should be appropriately detected, reported error about\n+    static class BrokenCreatorBean\n+    {\n+        protected String bar;\n+        \n+        @JsonCreator\n+        public BrokenCreatorBean(@JsonProperty(\"bar\") String bar1, @JsonProperty(\"bar\") String bar2) {\n+            bar = \"\"+bar1+\"/\"+bar2;\n+        }\n+    }\n+    \n+    // For [JACKSON-541]: should not need @JsonCreator if Feature.AUTO_DETECT_CREATORS is on.\n+    static class AutoDetectConstructorBean\n+    {\n+    \tprotected final String foo;\n+    \tprotected final String bar;\n+\n+    \tpublic AutoDetectConstructorBean(@JsonProperty(\"bar\") String bar, @JsonProperty(\"foo\") String foo){\n+    \t    this.bar = bar;\n+    \t    this.foo = foo;\n+    \t}\n+    }\n+\n+    static class BustedCtor {\n+        @JsonCreator\n+        BustedCtor(@JsonProperty(\"a\") String value) {\n+            throw new IllegalArgumentException(\"foobar\");\n+        }\n+    }\n+\n+    // As per [JACKSON-575]\n+    static class IgnoredCtor\n+    {\n+        @JsonIgnore\n+        public IgnoredCtor(String arg) {\n+            throw new RuntimeException(\"Should never use this constructor\");\n+        }\n+\n+        public IgnoredCtor() { }\n+    }\n+\n+    abstract static class AbstractBase {\n+        @JsonCreator\n+        public static AbstractBase create(Map<String,Object> props)\n+        {\n+            return new AbstractBaseImpl(props);\n+        }\n+    }\n+\n+    static class AbstractBaseImpl extends AbstractBase\n+    {\n+        protected Map<String,Object> props;\n+        \n+        public AbstractBaseImpl(Map<String,Object> props) {\n+            this.props = props;\n+        }\n+    }\n+\n+    static class BooleanBean\n+    {\n+        protected Boolean value;\n+\n+        public BooleanBean(Boolean v) { value = v; }\n+        \n+        @JsonCreator\n+        protected static BooleanBean create(Boolean value) {\n+            return new BooleanBean(value);\n+        }\n+    }\n+    \n+    static interface Issue700Set extends java.util.Set<Object> { }\n+\n+    static class Issue700Bean\n+    {\n+        protected Issue700Set item;\n+\n+        @JsonCreator\n+        public Issue700Bean(@JsonProperty(\"item\") String item) { }\n+\n+        public String getItem() { return null; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    // for [JACKSON-547]\n+    public void testExceptionFromConstructor() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        try {\n+            m.readValue(\"{}\", BustedCtor.class);\n+            fail(\"Expected exception\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \": foobar\");\n+            // also: should have nested exception\n+            Throwable t = e.getCause();\n+            assertNotNull(t);\n+            assertEquals(IllegalArgumentException.class, t.getClass());\n+            assertEquals(\"foobar\", t.getMessage());\n+        }\n+    }\n+    \n+    public void testSimpleConstructor() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        HashTest test = m.readValue(\"{\\\"type\\\":\\\"custom\\\",\\\"bytes\\\":\\\"abc\\\" }\", HashTest.class);\n+        assertEquals(\"custom\", test.type);\n+        assertEquals(\"abc\", new String(test.bytes, \"UTF-8\"));\n+    }    \n+\n+    // Test for [JACKSON-372]\n+    public void testMissingPrimitives() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Primitives p = m.readValue(\"{}\", Primitives.class);\n+        assertFalse(p.b);\n+        assertEquals(0, p.x);\n+        assertEquals(0.0, p.d);\n+    }\n+\n+    public void testJackson431() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        final Test431Container foo = m.readValue(\n+                \"{\\\"items\\\":\\n\"\n+                +\"[{\\\"bar\\\": 0,\\n\"\n+                +\"\\\"id\\\": \\\"id123\\\",\\n\"\n+                +\"\\\"foo\\\": 1\\n\" \n+                +\"}]}\",\n+                Test431Container.class);\n+        assertNotNull(foo);\n+    }\n+\n+    // [JACKSON-438]: Catch and rethrow exceptions that Creator methods throw\n+    public void testJackson438() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        try {\n+            m.readValue(\"{ \\\"name\\\":\\\"foobar\\\" }\", BeanFor438.class);\n+            fail(\"Should have failed\");\n+        } catch (Exception e) {\n+            if (!(e instanceof JsonMappingException)) {\n+                fail(\"Should have received JsonMappingException, caught \"+e.getClass().getName());\n+            }\n+            verifyException(e, \"don't like that name\");\n+            // Ok: also, let's ensure root cause is directly linked, without other extra wrapping:\n+            Throwable t = e.getCause();\n+            assertNotNull(t);\n+            assertEquals(IllegalArgumentException.class, t.getClass());\n+            verifyException(e, \"don't like that name\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIssue465() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final String JSON = \"{\\\"A\\\":12}\";\n+\n+        // first, test with regular Map, non empty\n+        Map<String,Long> map = mapper.readValue(JSON, Map.class);\n+        assertEquals(1, map.size());\n+        assertEquals(Integer.valueOf(12), map.get(\"A\"));\n+        \n+        MapBean bean = mapper.readValue(JSON, MapBean.class);\n+        assertEquals(1, bean.map.size());\n+        assertEquals(Long.valueOf(12L), bean.map.get(\"A\"));\n+\n+        // and then empty ones\n+        final String EMPTY_JSON = \"{}\";\n+\n+        map = mapper.readValue(EMPTY_JSON, Map.class);\n+        assertEquals(0, map.size());\n+        \n+        bean = mapper.readValue(EMPTY_JSON, MapBean.class);\n+        assertEquals(0, bean.map.size());\n+    }\n+\n+    public void testCreatorWithDupNames() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.readValue(\"{\\\"bar\\\":\\\"x\\\"}\", BrokenCreatorBean.class);\n+            fail(\"Should have caught duplicate creator parameters\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"duplicate creator property \\\"bar\\\"\");\n+        }\n+    }\n+    \n+    public void testCreatorMultipleArgumentWithoutAnnotation() throws Exception {\n+    \tObjectMapper mapper = new ObjectMapper();\n+    \tAutoDetectConstructorBean value = mapper.readValue(\"{\\\"bar\\\":\\\"bar\\\",\\\"foo\\\":\\\"foo\\\"}\", AutoDetectConstructorBean.class);\n+    \tassertEquals(\"bar\", value.bar);\n+    \tassertEquals(\"foo\", value.foo);\n+    }\n+\n+    // for [JACKSON-575]\n+    public void testIgnoredSingleArgCtor() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.readValue(quote(\"abc\"), IgnoredCtor.class);\n+            fail(\"Should have caught missing constructor problem\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"no single-String constructor/factory method\");\n+        }\n+    }\n+\n+    public void testAbstractFactory() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AbstractBase bean = mapper.readValue(\"{\\\"a\\\":3}\",\n+                AbstractBase.class);\n+        assertNotNull(bean);\n+        AbstractBaseImpl impl = (AbstractBaseImpl) bean;\n+        assertEquals(1, impl.props.size());\n+        assertEquals(Integer.valueOf(3), impl.props.get(\"a\"));\n+    }\n+\n+    public void testBooleanDelegate() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // should obviously work with booleans...\n+        BooleanBean bb = m.readValue(\"true\", BooleanBean.class);\n+        assertEquals(Boolean.TRUE, bb.value);\n+\n+        // but also with value conversion from String\n+        bb = m.readValue(quote(\"true\"), BooleanBean.class);\n+        assertEquals(Boolean.TRUE, bb.value);\n+    }\n+\n+    // [JACKSON-700]\n+    public void testCreatorProperties() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Issue700Bean value = mapper.readValue(\"{ \\\"item\\\" : \\\"foo\\\" }\", Issue700Bean.class);\n+        assertNotNull(value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCustomFactory.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+\n+/**\n+ * Test to check that customization using {@link CustomDeserializerFactory}\n+ * works as expected.\n+ */\n+public class TestCustomFactory\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    static class DummyDeserializer<T>\n+        extends StdDeserializer<T>\n+    {\n+        final T value;\n+\n+        public DummyDeserializer(T v, Class<T> cls) {\n+            super(cls);\n+            value = v;\n+        }\n+\n+        @Override\n+        public T deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            // need to skip, if structured...\n+            jp.skipChildren();\n+            return value;\n+        }\n+    }\n+\n+    static class TestBeans {\n+        public List<TestBean> beans;\n+    }\n+    static class TestBean {\n+        public CustomBean c;\n+        public String d;\n+    }\n+    @JsonDeserialize(using=CustomBeanDeserializer.class)\n+    static class CustomBean {\n+        protected final int a, b;\n+        public CustomBean(int a, int b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+    }\n+\n+    static class CustomBeanDeserializer extends JsonDeserializer<CustomBean>\n+    {\n+        @Override\n+        public CustomBean deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+        {\n+            int a = 0, b = 0;\n+            JsonToken t = jp.getCurrentToken();\n+            if (t == JsonToken.START_OBJECT) {\n+                t = jp.nextToken();\n+            } else if (t != JsonToken.FIELD_NAME) {\n+                throw new Error();\n+            }\n+            while(t == JsonToken.FIELD_NAME) {\n+                final String fieldName = jp.getCurrentName();\n+                t = jp.nextToken();\n+                if (t != JsonToken.VALUE_NUMBER_INT) {\n+                    throw new JsonParseException(\"expecting number got \"+ t, jp.getCurrentLocation());\n+                }\n+                if (fieldName.equals(\"a\")) {\n+                    a = jp.getIntValue();\n+                } else if (fieldName.equals(\"b\")) {\n+                    b = jp.getIntValue();\n+                } else {\n+                    throw new Error();\n+                }\n+                t = jp.nextToken();\n+            }\n+            return new CustomBean(a, b);\n+        }\n+    }\n+\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testCustomBeanDeserializer() throws Exception\n+    {\n+\n+        final ObjectMapper map = new ObjectMapper();\n+        String json = \"{\\\"beans\\\":[{\\\"c\\\":{\\\"a\\\":10,\\\"b\\\":20},\\\"d\\\":\\\"hello, tatu\\\"}]}\";\n+        TestBeans beans = map.readValue(json, TestBeans.class);\n+\n+        assertNotNull(beans);\n+        List<TestBean> results = beans.beans;\n+        assertNotNull(results);\n+        assertEquals(1, results.size());\n+        TestBean bean = results.get(0);\n+        assertEquals(\"hello, tatu\", bean.d);\n+        CustomBean c = bean.c;\n+        assertNotNull(c);\n+        assertEquals(10, c.a);\n+        assertEquals(20, c.b);\n+\n+        json = \"{\\\"beans\\\":[{\\\"c\\\":{\\\"b\\\":3,\\\"a\\\":-4},\\\"d\\\":\\\"\\\"},\"\n+            +\"{\\\"d\\\":\\\"abc\\\", \\\"c\\\":{\\\"b\\\":15}}]}\";\n+        beans = map.readValue(json, TestBeans.class);\n+\n+        assertNotNull(beans);\n+        results = beans.beans;\n+        assertNotNull(results);\n+        assertEquals(2, results.size());\n+\n+        bean = results.get(0);\n+        assertEquals(\"\", bean.d);\n+        c = bean.c;\n+        assertNotNull(c);\n+        assertEquals(-4, c.a);\n+        assertEquals(3, c.b);\n+\n+        bean = results.get(1);\n+        assertEquals(\"abc\", bean.d);\n+        c = bean.c;\n+        assertNotNull(c);\n+        assertEquals(0, c.a);\n+        assertEquals(15, c.b);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCyclicTypes.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import javax.xml.bind.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Simple unit tests to verify that it is possible to handle\n+ * potentially cyclic structures, as long as object graph itself\n+ * is not cyclic. This is the case for directed hierarchies like\n+ * trees and DAGs.\n+ */\n+public class TestCyclicTypes\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper bean classes\n+    /**********************************************************\n+     */\n+\n+    static class Bean\n+    {\n+        Bean _next;\n+        String _name;\n+\n+        public Bean() { }\n+\n+        public void setNext(Bean b) { _next = b; }\n+        public void setName(String n) { _name = n; }\n+\n+    }\n+\n+    // Also another one to ensure JAXB annotation introspector has no problems\n+    @XmlAccessorType(XmlAccessType.FIELD)\n+    static class JaxbBean\n+    {\n+        @XmlElement(required = true)\n+        protected int id;\n+\n+        @XmlElement(required = false)\n+        protected JaxbBean circular;\n+    }\n+\n+    static class LinkA {\n+        public LinkB next;\n+    }\n+\n+    static class LinkB {\n+        private LinkA a;\n+\n+        public void setA(LinkA a) { this.a = a; }\n+        public LinkA getA() { return a; }\n+    }\n+\n+    static class GenericLink<T> {\n+        public GenericLink<T> next;\n+    }\n+\n+    static class StringLink extends GenericLink<String> {\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testLinked() throws Exception\n+    {\n+        Bean first = new ObjectMapper().readValue\n+            (\"{\\\"name\\\":\\\"first\\\", \\\"next\\\": { \"\n+             +\" \\\"name\\\":\\\"last\\\", \\\"next\\\" : null }}\",\n+             Bean.class);\n+\n+        assertNotNull(first);\n+        assertEquals(\"first\", first._name);\n+        Bean last = first._next;\n+        assertNotNull(last);\n+        assertEquals(\"last\", last._name);\n+        assertNull(last._next);\n+    }\n+\n+    public void testLinkedGeneric() throws Exception\n+    {\n+        StringLink link = new ObjectMapper().readValue\n+            (\"{\\\"next\\\":null}\", StringLink.class);\n+        assertNotNull(link);\n+        assertNull(link.next);\n+    }\n+\n+    public void testCycleWith2Classes() throws Exception\n+    {\n+        LinkA a = new ObjectMapper().readValue(\"{\\\"next\\\":{\\\"a\\\":null}}\", LinkA.class);\n+        assertNotNull(a.next);\n+        LinkB b = a.next;\n+        assertNull(b.a);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestDateDeserialization.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestDateDeserialization\n+    extends BaseMapTest\n+{\n+    public void testDateUtil() throws Exception\n+    {\n+        long now = 123456789L;\n+        java.util.Date value = new java.util.Date(now);\n+\n+        // First from long\n+        assertEquals(value, new ObjectMapper().readValue(\"\"+now, java.util.Date.class));\n+\n+        String dateStr = serializeDateAsString(value);\n+        java.util.Date result = new ObjectMapper().readValue(\"\\\"\"+dateStr+\"\\\"\", java.util.Date.class);\n+\n+        assertEquals(\"Date: expect \"+value+\" (\"+value.getTime()+\"), got \"+result+\" (\"+result.getTime()+\")\", value.getTime(), result.getTime());\n+    }\n+\n+    /**\n+     * @since 1.5.0\n+     */\n+    public void testDateUtilWithStringTimestamp() throws Exception\n+    {\n+        long now = 1321992375446L;\n+        /* As of 1.5.0, should be ok to pass as JSON String, as long\n+         * as it is plain timestamp (all numbers, 64-bit)\n+         */\n+        String json = quote(String.valueOf(now));\n+        java.util.Date value = new ObjectMapper().readValue(json, java.util.Date.class);\n+        assertEquals(now, value.getTime());\n+    }\n+\n+    /**\n+     * As of version 0.9.8, we'll try to cover RFC-1123 Strings too,\n+     * automatically.\n+     */\n+    public void testDateUtilRFC1123() throws Exception\n+    {\n+        DateFormat fmt = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\");\n+        // let's use an arbitrary value...\n+        String inputStr = \"Sat, 17 Jan 2009 06:13:58 +0000\";\n+        java.util.Date inputDate = fmt.parse(inputStr);\n+        assertEquals(inputDate, new ObjectMapper().readValue(\"\\\"\"+inputStr+\"\\\"\", java.util.Date.class));\n+    }\n+\n+    /**\n+     * ISO8601 is supported as well\n+     */\n+    public void testDateUtilISO8601() throws Exception\n+    {\n+        /* let's use simple baseline value, arbitrary date in GMT,\n+         * using the standard notation\n+         */\n+        ObjectMapper mapper = new ObjectMapper();\n+        String inputStr = \"1972-12-28T00:00:00.000+0000\";\n+        Date inputDate = mapper.readValue(\"\\\"\"+inputStr+\"\\\"\", java.util.Date.class);\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+        c.setTime(inputDate);\n+        assertEquals(1972, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));\n+        assertEquals(28, c.get(Calendar.DAY_OF_MONTH));\n+\n+        // And then the same, but using 'Z' as alias for +0000 (very common)\n+        inputStr = \"1972-12-28T00:00:00.000Z\";\n+        inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n+        c.setTime(inputDate);\n+        assertEquals(1972, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));\n+        assertEquals(28, c.get(Calendar.DAY_OF_MONTH));\n+\n+        // Same but using colon in timezone\n+        inputStr = \"1972-12-28T00:00:00.000+00:00\";\n+        inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n+        c.setTime(inputDate);\n+        assertEquals(1972, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));\n+        assertEquals(28, c.get(Calendar.DAY_OF_MONTH));\n+\n+        // Same but only passing hour difference as timezone\n+        inputStr = \"1972-12-28T00:00:00.000+00\";\n+        inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n+        c.setTime(inputDate);\n+        assertEquals(1972, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));\n+        assertEquals(28, c.get(Calendar.DAY_OF_MONTH));\n+\n+        inputStr = \"1984-11-30T00:00:00.000Z\";\n+        inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n+        c.setTime(inputDate);\n+        assertEquals(1984, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.NOVEMBER, c.get(Calendar.MONTH));\n+        assertEquals(30, c.get(Calendar.DAY_OF_MONTH));\n+    }\n+\n+    public void testDateUtilISO8601NoTimezone() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // Timezone itself is optional as well... \n+        String inputStr = \"1984-11-13T00:00:09\";\n+        Date inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+        c.setTime(inputDate);\n+        assertEquals(1984, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.NOVEMBER, c.get(Calendar.MONTH));\n+        assertEquals(13, c.get(Calendar.DAY_OF_MONTH));\n+        assertEquals(0, c.get(Calendar.HOUR_OF_DAY));\n+        assertEquals(0, c.get(Calendar.MINUTE));\n+        assertEquals(9, c.get(Calendar.SECOND));\n+        assertEquals(0, c.get(Calendar.MILLISECOND));\n+    }\n+\n+    public void testDateUtilISO8601JustDate() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // Plain date (no time)\n+        String inputStr = \"1972-12-28\";\n+        Date inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+        c.setTime(inputDate);\n+        assertEquals(1972, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.DECEMBER, c.get(Calendar.MONTH));\n+        assertEquals(28, c.get(Calendar.DAY_OF_MONTH));\n+\n+    }\n+\n+\n+    @SuppressWarnings(\"deprecation\")\n+    public void testDateSql() throws Exception\n+    {\n+        java.sql.Date value = new java.sql.Date(0L);\n+        value.setYear(99); // 1999\n+        value.setDate(19);\n+        value.setMonth(Calendar.APRIL);\n+        long now = value.getTime();\n+\n+        // First from long\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(value, mapper.readValue(String.valueOf(now), java.sql.Date.class));\n+\n+        // then from default java.sql.Date String serialization:\n+        \n+        java.sql.Date result = mapper.readValue(quote(value.toString()), java.sql.Date.class);\n+        Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+        c.setTimeInMillis(result.getTime());\n+        assertEquals(1999, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.APRIL, c.get(Calendar.MONTH));\n+        assertEquals(19, c.get(Calendar.DAY_OF_MONTH));\n+\n+        /* [JACKSON-200]: looks like we better add support for regular date\n+         *   formats as well\n+         */\n+        String expStr = \"1981-07-13\";\n+        result = mapper.readValue(quote(expStr), java.sql.Date.class);\n+        c.setTimeInMillis(result.getTime());\n+        assertEquals(1981, c.get(Calendar.YEAR));\n+        assertEquals(Calendar.JULY, c.get(Calendar.MONTH));\n+        assertEquals(13, c.get(Calendar.DAY_OF_MONTH));\n+\n+        /* 20-Nov-2009, tatus: I'll be damned if I understand why string serialization\n+         *   is off-by-one, but day-of-month does seem to be one less. My guess is\n+         *   that something is funky with timezones (i.e. somewhere local TZ is\n+         *   being used), but just can't resolve it. Hence, need to comment this:\n+         */\n+        //assertEquals(expStr, result.toString());\n+    }\n+\n+    public void testCalendar() throws Exception\n+    {\n+        // not ideal, to use (ever-changing) current date, but...\n+        java.util.Date now = new Date();\n+        java.util.Calendar value = Calendar.getInstance();\n+        value.setTime(now);\n+\n+        // First from long\n+        assertEquals(value, new ObjectMapper().readValue(\"\"+now.getTime(), Calendar.class));\n+\n+        String dateStr = serializeDateAsString(now);\n+        Calendar result = new ObjectMapper().readValue(\"\\\"\"+dateStr+\"\\\"\", Calendar.class);\n+\n+        assertEquals(value, result);\n+    }\n+\n+    public void testCustom() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'X'HH:mm:ss\");\n+        df.setTimeZone(TimeZone.getTimeZone(\"PST\"));\n+        mapper.setDateFormat(df);\n+\n+        String dateStr = \"1972-12-28X15:45:00\";\n+        java.util.Date exp = df.parse(dateStr);\n+        java.util.Date result = mapper.readValue(\"\\\"\"+dateStr+\"\\\"\", java.util.Date.class);\n+        assertEquals(exp, result);\n+    }\n+\n+    /**\n+     * Test for [JACKSON-203]: make empty Strings deserialize as nulls by default,\n+     * without need to turn on feature (which may be added in future)\n+     */\n+    public void testDatesWithEmptyStrings() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        assertNull(mapper.readValue(quote(\"\"), java.util.Date.class));\n+        assertNull(mapper.readValue(quote(\"\"), java.util.Calendar.class));\n+        assertNull(mapper.readValue(quote(\"\"), java.sql.Date.class));\n+    }\n+\n+    // for [JACKSON-334]\n+    public void test8601DateTimeNoMilliSecs() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // ok, Zebra, no milliseconds\n+        for (String inputStr : new String[] {\n+               \"2010-06-28T23:34:22Z\",\n+               \"2010-06-28T23:34:22+0000\",\n+               \"2010-06-28T23:34:22+00\",\n+        }) {\n+            Date inputDate = mapper.readValue(quote(inputStr), java.util.Date.class);\n+            Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+            c.setTime(inputDate);\n+            assertEquals(2010, c.get(Calendar.YEAR));\n+            assertEquals(Calendar.JUNE, c.get(Calendar.MONTH));\n+            assertEquals(28, c.get(Calendar.DAY_OF_MONTH));\n+            assertEquals(23, c.get(Calendar.HOUR_OF_DAY));\n+            assertEquals(34, c.get(Calendar.MINUTE));\n+            assertEquals(22, c.get(Calendar.SECOND));\n+            assertEquals(0, c.get(Calendar.MILLISECOND));\n+        }\n+    }\n+\n+    public void testTimeZone() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        TimeZone result = mapper.readValue(quote(\"PST\"), TimeZone.class);\n+        assertEquals(\"PST\", result.getID());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    String serializeDateAsString(java.util.Date value)\n+    {\n+        /* Then from String. This is bit tricky, since JDK does not really\n+         * suggest a 'standard' format. So let's try using something...\n+         */\n+        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\n+        return df.format(value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.EnumMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+\n+public class TestEnumDeserialization\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes, enums\n+    /**********************************************************\n+     */\n+\n+    enum TestEnum { JACKSON, RULES, OK; }\n+\n+    /**\n+     * Alternative version that annotates which deserializer to use\n+     */\n+    @JsonDeserialize(using=DummySerializer.class)\n+    enum AnnotatedTestEnum {\n+        JACKSON, RULES, OK;\n+    }\n+\n+    public static class DummySerializer extends StdDeserializer<Object>\n+    {\n+        public DummySerializer() { super(Object.class); }\n+        @Override\n+        public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+        {\n+            return AnnotatedTestEnum.OK;\n+        }\n+    }\n+\n+    protected enum EnumWithCreator {\n+        A, B;\n+\n+        @JsonCreator\n+        public static EnumWithCreator fromEnum(String str) {\n+            if (\"enumA\".equals(str)) return A;\n+            if (\"enumB\".equals(str)) return B;\n+            return null;\n+        }\n+    }\n+\n+    protected enum LowerCaseEnum {\n+        A, B, C;\n+        private LowerCaseEnum() { }\n+        @Override\n+        public String toString() { return name().toLowerCase(); }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimple() throws Exception\n+    {\n+        // First \"good\" case with Strings\n+        ObjectMapper mapper = new ObjectMapper();\n+        String JSON = \"\\\"OK\\\" \\\"RULES\\\"  null\";\n+        // multiple main-level mappings, need explicit parser:\n+        JsonParser jp = mapper.getJsonFactory().createJsonParser(JSON);\n+\n+        assertEquals(TestEnum.OK, mapper.readValue(jp, TestEnum.class));\n+        assertEquals(TestEnum.RULES, mapper.readValue(jp, TestEnum.class));\n+\n+        /* should be ok; nulls are typeless; handled by mapper, not by\n+         * deserializer\n+         */\n+        assertNull(mapper.readValue(jp, TestEnum.class));\n+\n+        // and no more content beyond that...\n+        assertFalse(jp.hasCurrentToken());\n+\n+        /* Then alternative with index (0 means first entry)\n+         */\n+        assertEquals(TestEnum.JACKSON, mapper.readValue(\" 0 \", TestEnum.class));\n+\n+        /* Then error case: unrecognized value\n+         */\n+        try {\n+            /*Object result =*/ mapper.readValue(\"\\\"NO-SUCH-VALUE\\\"\", TestEnum.class);\n+            fail(\"Expected an exception for bogus enum value...\");\n+        } catch (JsonMappingException jex) {\n+            verifyException(jex, \"value not one of declared\");\n+        }\n+    }\n+\n+    /**\n+     * Enums are considered complex if they have code (and hence sub-classes)... an\n+     * example is TimeUnit\n+     */\n+    public void testComplexEnum() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(TimeUnit.HOURS);\n+        assertEquals(quote(\"HOURS\"), json);\n+        TimeUnit result = mapper.readValue(json, TimeUnit.class);\n+        assertSame(TimeUnit.HOURS, result);\n+    }\n+    \n+    /**\n+     * Testing to see that annotation override works\n+     */\n+    public void testAnnotated() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AnnotatedTestEnum e = mapper.readValue(\"\\\"JACKSON\\\"\", AnnotatedTestEnum.class);\n+        /* dummy deser always returns value OK, independent of input;\n+         * only works if annotation is used\n+         */\n+        assertEquals(AnnotatedTestEnum.OK, e);\n+    }\n+\n+    public void testEnumMaps() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        EnumMap<TestEnum,String> value = mapper.readValue(\"{\\\"OK\\\":\\\"value\\\"}\",\n+                new TypeReference<EnumMap<TestEnum,String>>() { });\n+        assertEquals(\"value\", value.get(TestEnum.OK));\n+    }\n+    \n+    // Test [JACKSON-214]\n+    public void testSubclassedEnums() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        EnumWithSubClass value = mapper.readValue(\"\\\"A\\\"\", EnumWithSubClass.class);\n+        assertEquals(EnumWithSubClass.A, value);\n+    }\n+\n+    // [JACKSON-193]\n+    public void testCreatorEnums() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        EnumWithCreator value = mapper.readValue(\"\\\"enumA\\\"\", EnumWithCreator.class);\n+        assertEquals(EnumWithCreator.A, value);\n+    }\n+    \n+    // [JACKSON-212]\n+    public void testToStringEnums() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING, true);\n+        LowerCaseEnum value = mapper.readValue(\"\\\"c\\\"\", LowerCaseEnum.class);\n+        assertEquals(LowerCaseEnum.C, value);\n+    }\n+\n+    // [JACKSON-212]\n+    public void testToStringEnumMaps() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING, true);\n+        EnumMap<LowerCaseEnum,String> value = mapper.readValue(\"{\\\"a\\\":\\\"value\\\"}\",\n+                new TypeReference<EnumMap<LowerCaseEnum,String>>() { });\n+        assertEquals(\"value\", value.get(LowerCaseEnum.A));\n+    }\n+\n+    // [JACKSON-412], disallow use of numbers\n+    public void testNumbersToEnums() throws Exception\n+    {\n+        // by default numbers are fine:\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertFalse(mapper.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS));\n+        TestEnum value = mapper.readValue(\"1\", TestEnum.class);\n+        assertSame(TestEnum.RULES, value);\n+\n+        // but can also be changed to errors:\n+        mapper = new ObjectMapper();\n+        mapper.configure(DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS, true);\n+        try {\n+            value = mapper.readValue(\"1\", TestEnum.class);\n+            fail(\"Expected an error\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Not allowed to deserialize Enum value out of JSON number\");\n+        }\n+    }\n+\n+    // [JACKSON-684], enums using index\n+    public void testEnumsWithIndex() throws Exception\n+    {\n+        // by default numbers are fine:\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enable(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX);\n+        String json = mapper.writeValueAsString(TestEnum.RULES);\n+        assertEquals(String.valueOf(TestEnum.RULES.ordinal()), json);\n+        TestEnum result = mapper.readValue(json, TestEnum.class);\n+        assertSame(TestEnum.RULES, result);\n+    }        \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionDeserialization.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+/**\n+ * Unit tests for verifying that simple exceptions can be deserialized.\n+ */\n+public class TestExceptionDeserialization\n+    extends BaseMapTest\n+{\n+    @SuppressWarnings(\"serial\")\n+    static class MyException extends Exception\n+    {\n+        protected int value;\n+\n+        protected String myMessage;\n+        protected HashMap<String,Object> stuff = new HashMap<String, Object>();\n+        \n+        @JsonCreator\n+        MyException(@JsonProperty(\"message\") String msg, @JsonProperty(\"value\") int v)\n+        {\n+            super(msg);\n+            myMessage = msg;\n+            value = v;\n+        }\n+\n+        public int getValue() { return value; }\n+        \n+        public String getFoo() { return \"bar\"; }\n+\n+        @JsonAnySetter public void setter(String key, Object value)\n+        {\n+            stuff.put(key, value);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MyNoArgException extends Exception\n+    {\n+        @JsonCreator MyNoArgException() { }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Tests\n+    /**********************************************************\n+     */\n+\n+    public void testIOException() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        IOException ioe = new IOException(\"TEST\");\n+        String json = mapper.writeValueAsString(ioe);\n+        IOException result = mapper.readValue(json, IOException.class);\n+        assertEquals(ioe.getMessage(), result.getMessage());\n+    }\n+\n+    // As per [JACKSON-377]\n+    public void testWithCreator() throws IOException\n+    {\n+        final String MSG = \"the message\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new MyException(MSG, 3));\n+\n+        MyException result = mapper.readValue(json, MyException.class);\n+        assertEquals(MSG, result.getMessage());\n+        assertEquals(3, result.value);\n+        assertEquals(1, result.stuff.size());\n+        assertEquals(result.getFoo(), result.stuff.get(\"foo\"));\n+    }\n+\n+    // [JACKSON-388]\n+    public void testWithNullMessage() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setSerializationInclusion(JsonSerialize.Inclusion.NON_NULL);\n+        String json = mapper.writeValueAsString(new IOException((String) null));\n+        IOException result = mapper.readValue(json, IOException.class);\n+        assertNotNull(result);\n+        assertNull(result.getMessage());\n+    }\n+\n+    public void testNoArgsException() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        MyNoArgException exc = mapper.readValue(\"{}\", MyNoArgException.class);\n+        assertNotNull(exc);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n+\n+/**\n+ * Unit test for verifying that exceptions are properly handled (caught,\n+ * re-thrown or wrapped, depending)\n+ * with Object deserialization.\n+ */\n+public class TestExceptionHandling\n+    extends BaseMapTest\n+{\n+    static class Bean {\n+        String x;\n+    }\n+\n+    /**\n+     * Verification of [JACKSON-301]\n+     */\n+    public void testHandlingOfUnrecognized() throws Exception\n+    {\n+        try {\n+            new ObjectMapper().readValue(\"{\\\"bar\\\":3}\", Bean.class);\n+            fail(\"Should have failed binding\");\n+        } catch (UnrecognizedPropertyException e) {\n+            assertEquals(\"bar\", e.getUnrecognizedPropertyName());\n+            assertEquals(Bean.class, e.getReferringClass());\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Simple test to check behavior when end-of-stream is encountered\n+     * without content. Should throw EOFException.\n+     */\n+    public void testExceptionWithEmpty() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            Object result = mapper.readValue(\"    \", Object.class);\n+            fail(\"Expected an exception, but got result value: \"+result);\n+        } catch (Exception e) {\n+            verifyException(e, EOFException.class, \"No content\");\n+        }\n+    }\n+\n+    public void testExceptionWithIncomplete()\n+        throws Exception\n+    {\n+        BrokenStringReader r = new BrokenStringReader(\"[ 1, \", \"TEST\");\n+        JsonFactory f = new JsonFactory();\n+        JsonParser jp = f.createJsonParser(r);\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            @SuppressWarnings(\"unused\")\n+            Object ob = mapper.readValue(jp, Object.class);\n+            fail(\"Should have gotten an exception\");\n+        } catch (IOException e) {\n+            /* For \"bona fide\" IO problems (due to low-level problem,\n+             * thrown by reader/stream), IOException must be thrown\n+             */\n+            verifyException(e, IOException.class, \"TEST\");\n+        }\n+    }\n+\n+    public void testExceptionWithEOF()\n+        throws Exception\n+    {\n+        StringReader r = new StringReader(\"  3\");\n+        JsonFactory f = new JsonFactory();\n+        JsonParser jp = f.createJsonParser(r);\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        Integer I = mapper.readValue(jp, Integer.class);\n+        assertEquals(3, I.intValue());\n+\n+        // and then end-of-input...\n+        try {\n+            I = mapper.readValue(jp, Integer.class);\n+            fail(\"Should have gotten an exception\");\n+        } catch (IOException e) {\n+            verifyException(e, EOFException.class, \"No content\");\n+        }\n+        // also: should have no current token after end-of-input\n+        JsonToken t = jp.getCurrentToken();\n+        if (t != null) {\n+            fail(\"Expected current token to be null after end-of-stream, was: \"+t);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    void verifyException(Exception e, Class<?> expType, String expMsg)\n+        throws Exception\n+    {\n+        if (e.getClass() != expType) {\n+            fail(\"Expected exception of type \"+expType.getName()+\", got \"+e.getClass().getName());\n+        }\n+        if (expMsg != null) {\n+            verifyException(e, expMsg);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestFieldDeserialization.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.*;\n+\n+/**\n+ * Unit tests for verifying that field-backed properties can also be\n+ * deserialized (since version 1.1) as well as\n+ * setter-accessible properties.\n+ */\n+public class TestFieldDeserialization\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes\n+    /**********************************************************\n+     */\n+\n+    static class SimpleFieldBean\n+    {\n+        public int x, y;\n+\n+        // not auto-detectable, not public\n+        int z;\n+\n+        // ignored, not detectable either\n+        @JsonIgnore public int a;\n+    }\n+\n+    static class SimpleFieldBean2\n+    {\n+        @JsonDeserialize String[] values;\n+    }\n+\n+    @JsonAutoDetect(fieldVisibility=Visibility.NONE)\n+    static class NoAutoDetectBean\n+    {\n+        // not auto-detectable any more\n+        public int z;\n+\n+        @JsonProperty(\"z\")\n+        public int _z;\n+    }\n+\n+    // Let's test invalid bean too\n+    static class DupFieldBean\n+    {\n+        public int z;\n+\n+        @JsonProperty(\"z\")\n+        public int _z;\n+    }\n+\n+    public static class DupFieldBean2\n+    {\n+        @JsonProperty(\"foo\")\n+        public int _z;\n+\n+        @SuppressWarnings(\"unused\")\n+        @JsonDeserialize\n+        private int foo;\n+    }\n+\n+    public static class OkDupFieldBean\n+        extends SimpleFieldBean\n+    {\n+        @JsonProperty(\"x\")\n+        protected int myX = 10;\n+\n+        public int y = 11;\n+    }\n+    \n+    abstract static class Abstract { }\n+    static class Concrete extends Abstract\n+    {\n+        String value;\n+\n+        public Concrete(String v) { value = v; }\n+    }\n+\n+    static class AbstractWrapper {\n+        @JsonDeserialize(as=Concrete.class)\n+        public Abstract value;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Main tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleAutoDetect() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        SimpleFieldBean result = m.readValue(\"{ \\\"x\\\" : -13 }\",\n+                                           SimpleFieldBean.class);\n+        assertEquals(-13, result.x);\n+        assertEquals(0, result.y);\n+    }\n+\n+    public void testSimpleAnnotation() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        SimpleFieldBean2 bean = m.readValue(\"{ \\\"values\\\" : [ \\\"x\\\", \\\"y\\\" ] }\",\n+                SimpleFieldBean2.class);\n+        String[] values = bean.values;\n+        assertNotNull(values);\n+        assertEquals(2, values.length);\n+        assertEquals(\"x\", values[0]);\n+        assertEquals(\"y\", values[1]);\n+    }\n+\n+    public void testNoAutoDetect() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        NoAutoDetectBean bean = m.readValue(\"{ \\\"z\\\" : 7 }\",\n+                                            NoAutoDetectBean.class);\n+        assertEquals(7, bean._z);\n+    }\n+\n+    public void testTypeAnnotation() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        AbstractWrapper w = m.readValue(\"{ \\\"value\\\" : \\\"abc\\\" }\",\n+                                        AbstractWrapper.class);\n+        Abstract bean = w.value;\n+        assertNotNull(bean);\n+        assertEquals(Concrete.class, bean.getClass());\n+        assertEquals(\"abc\", ((Concrete)bean).value);\n+    }\n+\n+    public void testFailureDueToDups() throws Exception\n+    {\n+        try {\n+            writeAndMap(new ObjectMapper(), new DupFieldBean());\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Multiple fields representing property\");\n+        }\n+    }\n+\n+    public void testFailureDueToDups2() throws Exception\n+    {\n+        try {\n+            writeAndMap(new ObjectMapper(), new DupFieldBean2());\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Multiple fields representing property\");\n+        }\n+    }\n+\n+    // For [JACKSON-226], acceptable field overrides\n+    public void testOkFieldOverride() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        OkDupFieldBean result = m.readValue(\"{ \\\"x\\\" : 1, \\\"y\\\" : 2 }\",\n+                OkDupFieldBean.class);\n+        assertEquals(1, result.myX);\n+        assertEquals(2, result.y);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericCollectionDeser.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+\n+@SuppressWarnings(\"serial\")\n+public class TestGenericCollectionDeser\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Test classes, enums\n+    /**********************************************************\n+     */\n+\n+    static class ListSubClass extends ArrayList<StringWrapper> { }\n+\n+    /**\n+     * Map class that should behave like {@link MapSubClass}, but by\n+     * using annotations.\n+     */\n+    @JsonDeserialize(contentAs=StringWrapper.class)\n+    static class AnnotatedStringList extends ArrayList<Object> { }\n+\n+    @JsonDeserialize(contentAs=BooleanWrapper.class)\n+    static class AnnotatedBooleanList extends ArrayList<Object> { }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    /*\n+    /**********************************************************\n+    /* Tests for sub-classing\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Verifying that sub-classing works ok wrt generics information\n+     */\n+    public void testListSubClass() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ListSubClass result = mapper.readValue(\"[ \\\"123\\\" ]\", ListSubClass.class);\n+        assertEquals(1, result.size());\n+        Object value = result.get(0);\n+        assertEquals(StringWrapper.class, value.getClass());\n+        StringWrapper bw = (StringWrapper) value;\n+        assertEquals(\"123\", bw.str);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests for annotations\n+    /**********************************************************\n+     */\n+\n+    // Verifying that sub-classing works ok wrt generics information\n+    public void testAnnotatedLStringist() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AnnotatedStringList result = mapper.readValue(\"[ \\\"...\\\" ]\", AnnotatedStringList.class);\n+        assertEquals(1, result.size());\n+        Object ob = result.get(0);\n+        assertEquals(StringWrapper.class, ob.getClass());\n+        assertEquals(\"...\", ((StringWrapper) ob).str);\n+    }\n+\n+    public void testAnnotatedBooleanList() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AnnotatedBooleanList result = mapper.readValue(\"[ false ]\", AnnotatedBooleanList.class);\n+        assertEquals(1, result.size());\n+        Object ob = result.get(0);\n+        assertEquals(BooleanWrapper.class, ob.getClass());\n+        assertFalse(((BooleanWrapper) ob).b);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericMapDeser.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+@SuppressWarnings(\"serial\")\n+public class TestGenericMapDeser\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Test classes, enums\n+    /**********************************************************\n+     */\n+\n+    static class BooleanWrapper {\n+        final Boolean b;\n+        @JsonCreator BooleanWrapper(Boolean value) { b = value; }\n+    }\n+\n+    static class StringWrapper {\n+        final String str;\n+        @JsonCreator StringWrapper(String value) {\n+            str = value;\n+        }\n+    }\n+\n+    static class MapSubClass extends HashMap<String,BooleanWrapper> { }\n+\n+    /**\n+     * Map class that should behave like {@link MapSubClass}, but by\n+     * using annotations.\n+     */\n+    @JsonDeserialize(keyAs=StringWrapper.class, contentAs=BooleanWrapper.class)\n+        static class AnnotatedMap extends HashMap<Object,Object> { }\n+\n+    interface MapWrapper<K,V> extends java.io.Serializable {\n+        public abstract Map<K,V> getEntries();\n+    }\n+\n+    static class StringMap implements MapWrapper<String,Long>\n+    {\n+        private Map<String,Long> entries = new LinkedHashMap<String,Long>();\n+\n+        public StringMap() { }\n+\n+        @Override\n+        public Map<String,Long> getEntries() { return entries; }\n+    }\n+\n+    static class StringWrapperValueMap<KEY> extends HashMap<KEY,StringWrapper> { }\n+\n+    static class StringStringWrapperMap extends StringWrapperValueMap<String> { }\n+\n+    static class KeyTypeCtor  {\n+        protected String value;\n+        public KeyTypeCtor(String v) { value = v; }\n+    }\n+\n+    static class KeyTypeFactory  {\n+        protected String value;\n+        private KeyTypeFactory(String v, boolean foo) { value = v; }\n+\n+        @JsonCreator\n+        public static KeyTypeFactory create(String str) {\n+            return new KeyTypeFactory(str, true);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods for sub-classing\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Verifying that sub-classing works ok wrt generics information\n+     */\n+    public void testMapSubClass() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        MapSubClass result = mapper.readValue\n+            (\"{\\\"a\\\":true }\", MapSubClass.class);\n+        assertEquals(1, result.size());\n+        Object value = result.get(\"a\");\n+        assertEquals(BooleanWrapper.class, value.getClass());\n+        BooleanWrapper bw = (BooleanWrapper) value;\n+        assertEquals(Boolean.TRUE, bw.b);\n+    }\n+\n+    public void testMapWrapper() throws Exception\n+    {\n+        StringMap value = new ObjectMapper().readValue\n+            (\"{\\\"entries\\\":{\\\"a\\\":9} }\", StringMap.class);\n+        assertNotNull(value.getEntries());\n+        assertEquals(1, value.getEntries().size());\n+        assertEquals(Long.valueOf(9), value.getEntries().get(\"a\"));\n+    }\n+\n+    public void testIntermediateTypes() throws Exception\n+    {\n+        StringStringWrapperMap result = new ObjectMapper().readValue\n+            (\"{\\\"a\\\":\\\"b\\\"}\", StringStringWrapperMap.class);\n+        assertEquals(1, result.size());\n+        Object value = result.get(\"a\");\n+        assertNotNull(value);\n+        assertEquals(value.getClass(), StringWrapper.class);\n+        assertEquals(\"b\", ((StringWrapper) value).str);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods for sub-classing for annotation handling\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Verifying that sub-classing works ok wrt generics information\n+     */\n+    public void testAnnotatedMap() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AnnotatedMap result = mapper.readValue\n+            (\"{\\\"a\\\":true }\", AnnotatedMap.class);\n+        assertEquals(1, result.size());\n+        Map.Entry<Object,Object> en = result.entrySet().iterator().next();\n+        assertEquals(StringWrapper.class, en.getKey().getClass());\n+        assertEquals(BooleanWrapper.class, en.getValue().getClass());\n+        assertEquals(\"a\", ((StringWrapper) en.getKey()).str);\n+        assertEquals(Boolean.TRUE, ((BooleanWrapper) en.getValue()).b);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods for ensuring @JsonCreator works for keys\n+    /**********************************************************\n+     */\n+\n+    public void testKeyViaCtor() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Map<KeyTypeCtor,Integer> map = mapper.readValue(\"{\\\"a\\\":123}\",\n+                TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeCtor.class, Integer.class));\n+        assertEquals(1, map.size());\n+        Map.Entry<?,?> entry = map.entrySet().iterator().next();\n+        assertEquals(Integer.valueOf(123), entry.getValue());\n+        Object key = entry.getKey();\n+        assertEquals(KeyTypeCtor.class, key.getClass());\n+        assertEquals(\"a\", ((KeyTypeCtor) key).value);\n+    }\n+\n+    public void testKeyViaFactory() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Map<KeyTypeCtor,Integer> map = mapper.readValue(\"{\\\"a\\\":123}\",\n+                TypeFactory.defaultInstance().constructMapType(HashMap.class, KeyTypeFactory.class, Integer.class));\n+        assertEquals(1, map.size());\n+        Map.Entry<?,?> entry = map.entrySet().iterator().next();\n+        assertEquals(Integer.valueOf(123), entry.getValue());\n+        Object key = entry.getKey();\n+        assertEquals(KeyTypeFactory.class, key.getClass());\n+        assertEquals(\"a\", ((KeyTypeFactory) key).value);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericNumber.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for verifying handling of non-specific numeric types.\n+ */\n+public class TestGenericNumber\n+    extends BaseMapTest\n+{\n+    public void testIntAsNumber() throws Exception\n+    {\n+        /* Even if declared as 'generic' type, should return using most\n+         * efficient type... here, Integer\n+         */\n+        Number result = new ObjectMapper().readValue(new StringReader(\" 123 \"), Number.class);\n+        assertEquals(Integer.valueOf(123), result);\n+    }\n+\n+    public void testLongAsNumber() throws Exception\n+    {\n+        // And beyond int range, should get long\n+        long exp = 1234567890123L;\n+        Number result = new ObjectMapper().readValue(String.valueOf(exp), Number.class);\n+        assertEquals(Long.valueOf(exp), result);\n+    }\n+\n+    public void testBigIntAsNumber() throws Exception\n+    {\n+        // and after long, BigInteger\n+        BigInteger biggie = new BigInteger(\"1234567890123456789012345678901234567890\");\n+        Number result = new ObjectMapper().readValue(biggie.toString(), Number.class);\n+        assertEquals(BigInteger.class, biggie.getClass());\n+        assertEquals(biggie, result);\n+    }\n+\n+    public void testIntTypeOverride() throws Exception\n+    {\n+        /* Slight twist; as per [JACKSON-100], can also request binding\n+         * to BigInteger even if value would fit in Integer\n+         */\n+        ObjectMapper m = new ObjectMapper();\n+        m.enable(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS);\n+        BigInteger exp = BigInteger.valueOf(123L);\n+\n+        // first test as any Number\n+        Number result = m.readValue(new StringReader(\" 123 \"), Number.class);\n+        assertEquals(BigInteger.class, result.getClass());\n+        assertEquals(exp, result);\n+\n+        // then as any Object\n+        /*Object value =*/ m.readValue(new StringReader(\"123\"), Object.class);\n+        assertEquals(BigInteger.class, result.getClass());\n+        assertEquals(exp, result);\n+    }\n+\n+    /**\n+     * Related to [JACKSON-72]: by default should wrap floating-point\n+     * Number as Double\n+     */\n+    public void testDoubleAsNumber() throws Exception\n+    {\n+        Number result = new ObjectMapper().readValue(new StringReader(\" 1.0 \"), Number.class);\n+        assertEquals(Double.valueOf(1.0), result);\n+    }\n+\n+    /**\n+     * Test for verifying [JACKSON-72].\n+     */\n+    public void testFpTypeOverrideSimple() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enable(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS);\n+        BigDecimal dec = new BigDecimal(\"0.1\");\n+\n+        // First test generic stand-alone Number\n+        Number result = m.readValue(dec.toString(), Number.class);\n+        assertEquals(BigDecimal.class, result.getClass());\n+        assertEquals(dec, result);\n+\n+        // Then plain old Object\n+        Object value = m.readValue(dec.toString(), Object.class);\n+        assertEquals(BigDecimal.class, result.getClass());\n+        assertEquals(dec, value);\n+    }\n+\n+\tpublic void testFpTypeOverrideStructured() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        BigDecimal dec = new BigDecimal(\"-19.37\");\n+\n+        m.enable(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS);\n+\n+        // List element types\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> list = (List<Object>)m.readValue(\"[ \"+dec.toString()+\" ]\", List.class);\n+        assertEquals(1, list.size());\n+        Object val = list.get(0);\n+        assertEquals(BigDecimal.class, val.getClass());\n+        assertEquals(dec, val);\n+\n+        // and a map\n+        Map<?,?> map = m.readValue(\"{ \\\"a\\\" : \"+dec.toString()+\" }\", Map.class);\n+        assertEquals(1, map.size());\n+        val = map.get(\"a\");\n+        assertEquals(BigDecimal.class, val.getClass());\n+        assertEquals(dec, val);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestGenerics.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestGenerics\n+    extends BaseMapTest\n+{\n+    static abstract class BaseNumberBean<T extends Number>\n+    {\n+        public abstract void setNumber(T value);\n+    }\n+\n+    static class NumberBean\n+        extends BaseNumberBean<Long>\n+    {\n+        long _number;\n+\n+        @Override\n+        public void setNumber(Long value)\n+        {\n+            _number = value.intValue();\n+        }\n+    }\n+\n+    /**\n+     * Very simple bean class\n+     */\n+    static class SimpleBean\n+    {\n+        public int x;\n+    }\n+\n+    static class Wrapper<T>\n+    {\n+        public T value;\n+\n+        public Wrapper() { }\n+\n+        public Wrapper(T v) { value = v; }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return (o instanceof Wrapper<?>) && (((Wrapper<?>) o).value.equals(value));\n+        }\n+    }\n+\n+    /*\n+    /***************************************************\n+    /* Test cases\n+    /***************************************************\n+     */\n+\n+    public void testSimpleNumberBean() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        NumberBean result = mapper.readValue(\"{\\\"number\\\":17}\", NumberBean.class);\n+        assertEquals(17, result._number);\n+    }\n+\n+    /**\n+     * Unit test for verifying fix to [JACKSON-109].\n+     */\n+    public void testGenericWrapper() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Wrapper<SimpleBean> result = mapper.readValue\n+            (\"{\\\"value\\\": { \\\"x\\\" : 13 } }\",\n+             new TypeReference<Wrapper<SimpleBean>>() { });\n+        assertNotNull(result);\n+        assertEquals(Wrapper.class, result.getClass());\n+        Object contents = result.value;\n+        assertNotNull(contents);\n+        assertEquals(SimpleBean.class, contents.getClass());\n+        SimpleBean bean = (SimpleBean) contents;\n+        assertEquals(13, bean.x);\n+    }\n+\n+    /**\n+     * Unit test for verifying that we can use different\n+     * type bindings for individual generic types;\n+     * problem with [JACKSON-190]\n+     */\n+    public void testMultipleWrappers() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        // First, numeric wrapper\n+        Wrapper<Boolean> result = mapper.readValue\n+            (\"{\\\"value\\\": true}\", new TypeReference<Wrapper<Boolean>>() { });\n+        assertEquals(new Wrapper<Boolean>(Boolean.TRUE), result);\n+\n+        // Then string one\n+        Wrapper<String> result2 = mapper.readValue\n+            (\"{\\\"value\\\": \\\"abc\\\"}\", new TypeReference<Wrapper<String>>() { });\n+        assertEquals(new Wrapper<String>(\"abc\"), result2);\n+\n+        // And then number\n+        Wrapper<Long> result3 = mapper.readValue\n+            (\"{\\\"value\\\": 7}\", new TypeReference<Wrapper<Long>>() { });\n+        assertEquals(new Wrapper<Long>(7L), result3);\n+    }\n+\n+    /**\n+     * Unit test for verifying fix to [JACKSON-109].\n+     */\n+    public void testArrayOfGenericWrappers() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Wrapper<SimpleBean>[] result = mapper.readValue\n+            (\"[ {\\\"value\\\": { \\\"x\\\" : 9 } } ]\",\n+             new TypeReference<Wrapper<SimpleBean>[]>() { });\n+        assertNotNull(result);\n+        assertEquals(Wrapper[].class, result.getClass());\n+        assertEquals(1, result.length);\n+        Wrapper<SimpleBean> elem = result[0];\n+        Object contents = elem.value;\n+        assertNotNull(contents);\n+        assertEquals(SimpleBean.class, contents.getClass());\n+        SimpleBean bean = (SimpleBean) contents;\n+        assertEquals(9, bean.x);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericsBounded.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.*;\n+\n+import java.io.Serializable;\n+\n+public class TestGenericsBounded\n+    extends BaseMapTest\n+{\n+    /*\n+    /*******************************************************\n+    /* Helper types\n+    /*******************************************************\n+     */\n+\n+    @SuppressWarnings(\"serial\")\n+    static class Range<E extends Comparable<E>> implements Serializable\n+    {\n+         protected E start, end;\n+\n+         public Range(){ }\n+         public Range(E start, E end) {\n+             this.start = start;\n+             this.end = end;\n+         }\n+\n+         public E getEnd() { return end; }\n+         public void setEnd(E e) { end = e; }\n+\n+         public E getStart() { return start; }\n+         public void setStart(E s) {\n+             start = s;\n+         }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class DoubleRange extends Range<Double> {\n+        public DoubleRange() { }\n+        public DoubleRange(Double s, Double e) { super(s, e); }\n+    }\n+     \n+    static class BoundedWrapper<A extends Serializable>\n+    {\n+        public List<A> values;\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class IntBean implements Serializable\n+    {\n+        public int x;\n+    }\n+\n+    static class IntBeanWrapper<T extends IntBean> {\n+        public T wrapped;\n+    }\n+    \n+    /*\n+    /*******************************************************\n+    /* Unit tests\n+    /*******************************************************\n+     */\n+\n+    public void testLowerBound() throws Exception\n+    {\n+        IntBeanWrapper<?> result = new ObjectMapper().readValue(\"{\\\"wrapped\\\":{\\\"x\\\":3}}\",\n+                IntBeanWrapper.class);\n+        assertNotNull(result);\n+        assertEquals(IntBean.class, result.wrapped.getClass());\n+        assertEquals(3, result.wrapped.x);\n+    }\n+    \n+    /**\n+     * Test related to type bound handling problem within\n+     * [JACKSON-190]\n+     */\n+    public void testBounded() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        BoundedWrapper<IntBean> result = mapper.readValue\n+            (\"{\\\"values\\\":[ {\\\"x\\\":3} ] } \", new TypeReference<BoundedWrapper<IntBean>>() {});\n+        List<?> list = result.values;\n+        assertEquals(1, list.size());\n+        Object ob = list.get(0);\n+        assertEquals(IntBean.class, ob.getClass());\n+        assertEquals(3, result.values.get(0).x);\n+    }\n+\n+    public void testGenericsComplex() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        DoubleRange in = new DoubleRange(-0.5, 0.5);\n+        String json = m.writeValueAsString(in);\n+        DoubleRange out = m.readValue(json, DoubleRange.class);\n+        assertNotNull(out);\n+        assertEquals(-0.5, out.start);\n+        assertEquals(0.5, out.end);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestIgnoredTypes.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Test for [JACKSON-429]\n+ */\n+public class TestIgnoredTypes extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes\n+    /**********************************************************\n+     */\n+    \n+    @JsonIgnoreType\n+    class IgnoredType { // note: non-static, can't be deserializer\n+        public IgnoredType(IgnoredType src) { }\n+    }\n+\n+    @JsonIgnoreType(false)\n+    static class NonIgnoredType\n+    {\n+        public int value = 13;\n+        public IgnoredType ignored;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testIgnoredType() throws Exception\n+    {\n+        // First: should be ok in general, even though couldn't build deserializer (due to non-static inner class):\n+        ObjectMapper mapper = new ObjectMapper();\n+        NonIgnoredType bean = mapper.readValue(\"{\\\"value\\\":13}\", NonIgnoredType.class);\n+        assertNotNull(bean);\n+        assertEquals(13, bean.value);\n+\n+        // And also ok to see something with that value; will just get ignored\n+        bean = mapper.readValue(\"{ \\\"ignored\\\":[1,2,{}], \\\"value\\\":9 }\", NonIgnoredType.class);\n+        assertNotNull(bean);\n+        assertEquals(9, bean.value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestInjectables.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestInjectables extends BaseMapTest\n+{\n+    static class InjectedBean\n+    {\n+        @JacksonInject\n+        protected String stuff;\n+\n+        @JacksonInject(\"myId\")\n+        protected String otherStuff;\n+\n+        protected long third;\n+        \n+        public int value;\n+\n+        @JacksonInject\n+        public void injectThird(long v) {\n+            third = v;\n+        }\n+    }    \n+\n+    static class BadBean1 {\n+        @JacksonInject protected String prop1;\n+        @JacksonInject protected String prop2;\n+    }\n+\n+    static class BadBean2 {\n+        @JacksonInject(\"x\") protected String prop1;\n+        @JacksonInject(\"x\") protected String prop2;\n+    }\n+\n+    static class CtorBean {\n+        protected String name;\n+        protected int age;\n+        \n+        public CtorBean(@JacksonInject String n, @JsonProperty(\"age\") int a)\n+        {\n+            name = n;\n+            age = a;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimple() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setInjectableValues(new InjectableValues.Std()\n+            .addValue(String.class, \"stuffValue\")\n+            .addValue(\"myId\", \"xyz\")\n+            .addValue(Long.TYPE, Long.valueOf(37))\n+            );\n+        InjectedBean bean = mapper.readValue(\"{\\\"value\\\":3}\", InjectedBean.class);\n+        assertEquals(3, bean.value);\n+        assertEquals(\"stuffValue\", bean.stuff);\n+        assertEquals(\"xyz\", bean.otherStuff);\n+        assertEquals(37L, bean.third);\n+    }\n+\n+    public void testWithCtors() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setInjectableValues(new InjectableValues.Std()\n+            .addValue(String.class, \"Bubba\")\n+            );\n+        CtorBean bean = mapper.readValue(\"{\\\"age\\\":55}\", CtorBean.class);\n+        assertEquals(55, bean.age);\n+        assertEquals(\"Bubba\", bean.name);\n+    }\n+    \n+    public void testInvalidDup() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.readValue(\"{}\", BadBean1.class);\n+        } catch (Exception e) {\n+            verifyException(e, \"Duplicate injectable value\");\n+        }\n+        try {\n+            mapper.readValue(\"{}\", BadBean2.class);\n+        } catch (Exception e) {\n+            verifyException(e, \"Duplicate injectable value\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestInnerClass.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestInnerClass extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Value classes\n+    /**********************************************************\n+     */\n+\n+    // [JACKSON-594]\n+    static class Dog\n+    {\n+      public String name;\n+      public Brain brain;\n+\n+      public Dog() { }\n+      public Dog(String n, boolean thinking) {\n+          name = n;\n+          brain = new Brain();\n+          brain.isThinking = thinking;\n+      }\n+      \n+      // note: non-static\n+      public class Brain {\n+          public boolean isThinking;\n+\n+          public String parentName() { return name; }\n+      }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleNonStaticInner() throws Exception\n+    {\n+        // Let's actually verify by first serializing, then deserializing back\n+        ObjectMapper mapper = new ObjectMapper();\n+        Dog input = new Dog(\"Smurf\", true);\n+        String json = mapper.writeValueAsString(input);\n+//System.out.println(\"JSON = \"+json);\n+        Dog output = mapper.readValue(json, Dog.class);\n+        assertEquals(\"Smurf\", output.name);\n+        assertNotNull(output.brain);\n+        assertTrue(output.brain.isThinking);\n+        // and verify correct binding...\n+        assertEquals(\"Smurf\", output.brain.parentName());\n+        output.name = \"Foo\";\n+        assertEquals(\"Foo\", output.brain.parentName());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestJacksonTypes.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n+\n+/**\n+ * Unit tests for those Jackson types we want to ensure can be deserialized.\n+ */\n+public class TestJacksonTypes\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    public void testJsonLocation() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // note: source reference is untyped, only String guaranteed to work\n+        JsonLocation loc = new JsonLocation(\"whatever\",  -1, -1, 100, 13);\n+        // Let's use serializer here; goal is round-tripping\n+        String ser = serializeAsString(m, loc);\n+        JsonLocation result = m.readValue(ser, JsonLocation.class);\n+        assertEquals(\"Did not correctly deserialize standard serialization '\"+ser+\"'\",\n+                     loc, result);\n+    }\n+\n+    // doesn't really belong here but...\n+    public void testJsonLocationProps()\n+    {\n+        JsonLocation loc = new JsonLocation(null,  -1, -1, 100, 13);\n+        assertTrue(loc.equals(loc));\n+        assertFalse(loc.equals(null));\n+        assertFalse(loc.equals(\"abx\"));\n+\n+        // should we check it's not 0?\n+        loc.hashCode();\n+    }\n+\n+    /**\n+     * Verify that {@link TokenBuffer} can be properly deserialized\n+     * automatically, using the \"standard\" JSON sample document\n+     */\n+    public void testTokenBufferWithSample() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // First, try standard sample doc:\n+        TokenBuffer result = m.readValue(SAMPLE_DOC_JSON_SPEC, TokenBuffer.class);\n+        verifyJsonSpecSampleDoc(result.asParser(), true);\n+    }\n+\n+    public void testTokenBufferWithSequence() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // and then sequence of other things\n+        JsonParser jp = createParserUsingReader(\"[ 32, [ 1 ], \\\"abc\\\", { \\\"a\\\" : true } ]\");\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        TokenBuffer buf = m.readValue(jp, TokenBuffer.class);\n+\n+        // check manually...\n+        JsonParser bufParser = buf.asParser();\n+        assertToken(JsonToken.VALUE_NUMBER_INT, bufParser.nextToken());\n+        assertEquals(32, bufParser.getIntValue());\n+        assertNull(bufParser.nextToken());\n+\n+        // then bind to another\n+        buf = m.readValue(jp, TokenBuffer.class);\n+        bufParser = buf.asParser();\n+        assertToken(JsonToken.START_ARRAY, bufParser.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, bufParser.nextToken());\n+        assertEquals(1, bufParser.getIntValue());\n+        assertToken(JsonToken.END_ARRAY, bufParser.nextToken());\n+        assertNull(bufParser.nextToken());\n+\n+        // third one, with automatic binding\n+        buf = m.readValue(jp, TokenBuffer.class);\n+        String str = m.readValue(buf.asParser(), String.class);\n+        assertEquals(\"abc\", str);\n+\n+        // and ditto for last one\n+        buf = m.readValue(jp, TokenBuffer.class);\n+        Map<?,?> map = m.readValue(buf.asParser(), Map.class);\n+        assertEquals(1, map.size());\n+        assertEquals(Boolean.TRUE, map.get(\"a\"));\n+        \n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+    }\n+\n+    public void testJavaType() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        // first simple type:\n+        String json = mapper.writeValueAsString(tf.constructType(String.class));\n+        assertEquals(quote(java.lang.String.class.getName()), json);\n+        // and back\n+        JavaType t = mapper.readValue(json, JavaType.class);\n+        assertNotNull(t);\n+        assertEquals(String.class, t.getRawClass());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestJdkTypes.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.util.Currency;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.regex.Pattern;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestJdkTypes\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    static class PrimitivesBean\n+    {\n+        public boolean booleanValue = true;\n+        public byte byteValue = 3;\n+        public char charValue = 'a';\n+        public short shortValue = 37;\n+        public int intValue = 1;\n+        public long longValue = 100L;\n+        public float floatValue = 0.25f;\n+        public double doubleValue = -1.0;\n+    }\n+\n+    // for [JACKSON-616]\n+    static class WrappersBean\n+    {\n+        public Boolean booleanValue;\n+        public Byte byteValue;\n+        public Character charValue;\n+        public Short shortValue;\n+        public Integer intValue;\n+        public Long longValue;\n+        public Float floatValue;\n+        public Double doubleValue;\n+    }\n+\n+    \n+    static class ParamClassBean\n+    {\n+         public String name = \"bar\";\n+         public Class<String> clazz ;\n+\n+         public ParamClassBean() { }\n+         public ParamClassBean(String name) {\n+             this.name = name;\n+             clazz = String.class;\n+         }\n+    }    \n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Related to issue [JACKSON-155].\n+     */\n+    public void testFile() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // Not portable etc... has to do:\n+        File src = new File(\"/test\").getAbsoluteFile();\n+        File result = m.readValue(\"\\\"\"+src.getAbsolutePath()+\"\\\"\", File.class);\n+        assertEquals(src.getAbsolutePath(), result.getAbsolutePath());\n+    }\n+\n+    public void testRegexps() throws IOException\n+    {\n+        final String PATTERN_STR = \"abc:\\\\s?(\\\\d+)\";\n+        Pattern exp = Pattern.compile(PATTERN_STR);\n+        /* Ok: easiest way is to just serialize first; problem\n+         * is the backslash\n+         */\n+        ObjectMapper m = new ObjectMapper();\n+        String json = m.writeValueAsString(exp);\n+        Pattern result = m.readValue(json, Pattern.class);\n+        assertEquals(exp.pattern(), result.pattern());\n+    }\n+\n+    public void testCurrency() throws IOException\n+    {\n+        Currency usd = Currency.getInstance(\"USD\");\n+        assertEquals(usd, new ObjectMapper().readValue(quote(\"USD\"), Currency.class));\n+    }\n+\n+    /**\n+     * Test for [JACKSON-419]\n+     * \n+     * @since 1.7\n+     */\n+    public void testLocale() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(new Locale(\"en\"), mapper.readValue(quote(\"en\"), Locale.class));\n+        assertEquals(new Locale(\"es\", \"ES\"), mapper.readValue(quote(\"es_ES\"), Locale.class));\n+        assertEquals(new Locale(\"FI\", \"fi\", \"savo\"), mapper.readValue(quote(\"fi_FI_savo\"), Locale.class));\n+    }\n+\n+    /**\n+     * Test for [JACKSON-420] (add DeserializationConfig.FAIL_ON_NULL_FOR_PRIMITIVES)\n+     * \n+     * @since 1.7\n+     */\n+    public void testNullForPrimitives() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        // by default, ok to rely on defaults\n+        PrimitivesBean bean = mapper.readValue(\"{\\\"intValue\\\":null, \\\"booleanValue\\\":null, \\\"doubleValue\\\":null}\",\n+                PrimitivesBean.class);\n+        assertNotNull(bean);\n+        assertEquals(0, bean.intValue);\n+        assertEquals(false, bean.booleanValue);\n+        assertEquals(0.0, bean.doubleValue);\n+\n+        bean = mapper.readValue(\"{\\\"byteValue\\\":null, \\\"longValue\\\":null, \\\"floatValue\\\":null}\",\n+                PrimitivesBean.class);\n+        assertNotNull(bean);\n+        assertEquals((byte) 0, bean.byteValue);\n+        assertEquals(0L, bean.longValue);\n+        assertEquals(0.0f, bean.floatValue);\n+        \n+        // but not when enabled\n+        mapper = new ObjectMapper();\n+        mapper.configure(DeserializationConfig.Feature.FAIL_ON_NULL_FOR_PRIMITIVES, true);\n+\n+        // boolean\n+        try {\n+            mapper.readValue(\"{\\\"booleanValue\\\":null}\", PrimitivesBean.class);\n+            fail(\"Expected failure for boolean + null\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Can not map JSON null into type boolean\");\n+        }\n+        // byte/char/short/int/long\n+        try {\n+            mapper.readValue(\"{\\\"byteValue\\\":null}\", PrimitivesBean.class);\n+            fail(\"Expected failure for byte + null\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Can not map JSON null into type byte\");\n+        }\n+        try {\n+            mapper.readValue(\"{\\\"charValue\\\":null}\", PrimitivesBean.class);\n+            fail(\"Expected failure for char + null\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Can not map JSON null into type char\");\n+        }\n+        try {\n+            mapper.readValue(\"{\\\"shortValue\\\":null}\", PrimitivesBean.class);\n+            fail(\"Expected failure for short + null\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Can not map JSON null into type short\");\n+        }\n+        try {\n+            mapper.readValue(\"{\\\"intValue\\\":null}\", PrimitivesBean.class);\n+            fail(\"Expected failure for int + null\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Can not map JSON null into type int\");\n+        }\n+        try {\n+            mapper.readValue(\"{\\\"longValue\\\":null}\", PrimitivesBean.class);\n+            fail(\"Expected failure for long + null\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Can not map JSON null into type long\");\n+        }\n+\n+        // float/double\n+        try {\n+            mapper.readValue(\"{\\\"floatValue\\\":null}\", PrimitivesBean.class);\n+            fail(\"Expected failure for float + null\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Can not map JSON null into type float\");\n+        }\n+        try {\n+            mapper.readValue(\"{\\\"doubleValue\\\":null}\", PrimitivesBean.class);\n+            fail(\"Expected failure for double + null\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Can not map JSON null into type double\");\n+        }\n+    }\n+    \n+    /**\n+     * Test for [JACKSON-483], allow handling of CharSequence\n+     */\n+    public void testCharSequence() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        CharSequence cs = mapper.readValue(\"\\\"abc\\\"\", CharSequence.class);\n+        assertEquals(String.class, cs.getClass());\n+        assertEquals(\"abc\", cs.toString());\n+    }\n+    \n+    // [JACKSON-484]\n+    public void testInetAddress() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        InetAddress address = mapper.readValue(quote(\"127.0.0.1\"), InetAddress.class);\n+        assertEquals(\"127.0.0.1\", address.getHostAddress());\n+\n+        // should we try resolving host names? That requires connectivity... \n+        final String HOST = \"www.ning.com\";\n+        address = mapper.readValue(quote(HOST), InetAddress.class);\n+        assertEquals(HOST, address.getHostName());\n+    }\n+\n+    // [JACKSON-597]\n+    public void testClass() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertSame(String.class, mapper.readValue(quote(\"java.lang.String\"), Class.class));\n+\n+        // then primitive types\n+        assertSame(Boolean.TYPE, mapper.readValue(quote(\"boolean\"), Class.class));\n+        assertSame(Byte.TYPE, mapper.readValue(quote(\"byte\"), Class.class));\n+        assertSame(Short.TYPE, mapper.readValue(quote(\"short\"), Class.class));\n+        assertSame(Character.TYPE, mapper.readValue(quote(\"char\"), Class.class));\n+        assertSame(Integer.TYPE, mapper.readValue(quote(\"int\"), Class.class));\n+        assertSame(Long.TYPE, mapper.readValue(quote(\"long\"), Class.class));\n+        assertSame(Float.TYPE, mapper.readValue(quote(\"float\"), Class.class));\n+        assertSame(Double.TYPE, mapper.readValue(quote(\"double\"), Class.class));\n+        assertSame(Void.TYPE, mapper.readValue(quote(\"void\"), Class.class));\n+    }\n+\n+    // [JACKSON-605]\n+    public void testClassWithParams() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new ParamClassBean(\"Foobar\"));\n+\n+        ParamClassBean result = mapper.readValue(json, ParamClassBean.class);\n+        assertEquals(\"Foobar\", result.name);\n+        assertSame(String.class, result.clazz);\n+    }\n+\n+    // by default, should return nulls, n'est pas?\n+    public void testEmptyStringForWrappers() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        WrappersBean bean;\n+\n+        // by default, ok to rely on defaults\n+        bean = mapper.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        assertNull(bean.booleanValue);\n+        bean = mapper.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        assertNull(bean.byteValue);\n+\n+        // char/Character is different... not sure if this should work or not:\n+        bean = mapper.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        assertNull(bean.charValue);\n+\n+        bean = mapper.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        assertNull(bean.shortValue);\n+        bean = mapper.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        assertNull(bean.intValue);\n+        bean = mapper.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        assertNull(bean.longValue);\n+        bean = mapper.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        assertNull(bean.floatValue);\n+        bean = mapper.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", WrappersBean.class);\n+        assertNull(bean.doubleValue);\n+    }\n+\n+    // for [JACKSON-616]\n+    // @since 1.9\n+    public void testEmptyStringForPrimitives() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        PrimitivesBean bean;\n+        bean = mapper.readValue(\"{\\\"booleanValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        assertFalse(bean.booleanValue);\n+        bean = mapper.readValue(\"{\\\"byteValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        assertEquals((byte) 0, bean.byteValue);\n+        bean = mapper.readValue(\"{\\\"charValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        assertEquals((char) 0, bean.charValue);\n+        bean = mapper.readValue(\"{\\\"shortValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        assertEquals((short) 0, bean.shortValue);\n+        bean = mapper.readValue(\"{\\\"intValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        assertEquals(0, bean.intValue);\n+        bean = mapper.readValue(\"{\\\"longValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        assertEquals(0L, bean.longValue);\n+        bean = mapper.readValue(\"{\\\"floatValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        assertEquals(0.0f, bean.floatValue);\n+        bean = mapper.readValue(\"{\\\"doubleValue\\\":\\\"\\\"}\", PrimitivesBean.class);\n+        assertEquals(0.0, bean.doubleValue);\n+    }\n+\n+    // for [JACKSON-652]\n+    // @since 1.9\n+    public void testUntypedWithJsonArrays() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // by default we get:\n+        Object ob = mapper.readValue(\"[1]\", Object.class);\n+        assertTrue(ob instanceof List<?>);\n+\n+        // but can change to produce Object[]:\n+        mapper.configure(DeserializationConfig.Feature.USE_JAVA_ARRAY_FOR_JSON_ARRAY, true);\n+        ob = mapper.readValue(\"[1]\", Object.class);\n+        assertEquals(Object[].class, ob.getClass());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+\n+public class TestMapDeserialization\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Test classes, enums\n+    /**********************************************************\n+     */\n+\n+    enum Key {\n+        KEY1, KEY2, WHATEVER;\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class BrokenMap\n+        extends HashMap<Object,Object>\n+    {\n+        // No default ctor, nor @JsonCreators\n+        public BrokenMap(boolean dummy) { super(); }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    @JsonDeserialize(using=MapDeserializer.class)\n+    static class CustomMap extends LinkedHashMap<String,String> { }\n+\n+    static class MapDeserializer extends StdDeserializer<CustomMap>\n+    {\n+        public MapDeserializer() { super(CustomMap.class); }\n+        @Override\n+        public CustomMap deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException\n+        {\n+            CustomMap result = new CustomMap();\n+            result.put(\"x\", jp.getText());\n+            return result;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods, untyped (Object valued) maps\n+    /**********************************************************\n+     */\n+\n+    public void testUntypedMap() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // to get \"untyped\" default map-to-map, pass Object.class\n+        String JSON = \"{ \\\"foo\\\" : \\\"bar\\\", \\\"crazy\\\" : true, \\\"null\\\" : null }\";\n+\n+        // Not a guaranteed cast theoretically, but will work:\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String,Object> result = (Map<String,Object>)mapper.readValue(JSON, Object.class);\n+        assertNotNull(result);\n+        assertTrue(result instanceof Map<?,?>);\n+\n+        assertEquals(3, result.size());\n+\n+        assertEquals(\"bar\", result.get(\"foo\"));\n+        assertEquals(Boolean.TRUE, result.get(\"crazy\"));\n+        assertNull(result.get(\"null\"));\n+\n+        // Plus, non existing:\n+        assertNull(result.get(\"bar\"));\n+        assertNull(result.get(3));\n+    }\n+\n+    /**\n+     * Let's also try another way to express \"gimme a Map\" deserialization;\n+     * this time by specifying a Map class, to reduce need to cast\n+     */\n+    public void testUntypedMap2() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // to get \"untyped\" default map-to-map, pass Object.class\n+        String JSON = \"{ \\\"a\\\" : \\\"x\\\" }\";\n+\n+        @SuppressWarnings(\"unchecked\")\n+        HashMap<String,Object> result = /*(HashMap<String,Object>)*/ mapper.readValue(JSON, HashMap.class);\n+        assertNotNull(result);\n+        assertTrue(result instanceof Map<?,?>);\n+\n+        assertEquals(1, result.size());\n+\n+        assertEquals(\"x\", result.get(\"a\"));\n+    }\n+\n+    /**\n+     * Unit test for [JACKSON-185]\n+     */\n+    public void testUntypedMap3() throws Exception\n+    {\n+        String JSON = \"{\\\"a\\\":[{\\\"a\\\":\\\"b\\\"},\\\"value\\\"]}\";\n+        ObjectMapper m = new ObjectMapper();\n+        Map<?,?> result = m.readValue(JSON, Map.class);\n+        assertTrue(result instanceof Map<?,?>);\n+        assertEquals(1, result.size());\n+        Object ob = result.get(\"a\");\n+        assertNotNull(ob);\n+        Collection<?> list = (Collection<?>)ob;\n+        assertEquals(2, list.size());\n+\n+        JSON = \"{ \\\"var1\\\":\\\"val1\\\", \\\"var2\\\":\\\"val2\\\", \"\n+            +\"\\\"subvars\\\": [\"\n+            +\" {  \\\"subvar1\\\" : \\\"subvar2\\\", \\\"x\\\" : \\\"y\\\" }, \"\n+            +\" { \\\"a\\\":1 } ]\"\n+            +\" }\"\n+            ;\n+        result = m.readValue(JSON, Map.class);\n+        assertTrue(result instanceof Map<?,?>);\n+        assertEquals(3, result.size());\n+    }\n+\n+    private static final String UNTYPED_MAP_JSON =\n+            \"{ \\\"double\\\":42.0, \\\"string\\\":\\\"string\\\",\"\n+            +\"\\\"boolean\\\":true, \\\"list\\\":[\\\"list0\\\"],\"\n+            +\"\\\"null\\\":null }\";\n+    \n+    @SuppressWarnings(\"serial\")\n+    static class ObjectWrapperMap extends HashMap<String, ObjectWrapper> { }\n+    \n+    public void testSpecialMap() throws IOException\n+    {\n+       final ObjectMapper mapper = new ObjectMapper();\n+       final ObjectWrapperMap map = mapper.readValue(UNTYPED_MAP_JSON, ObjectWrapperMap.class);\n+       _doTestUntyped(map);\n+    }\n+\n+    public void testGenericMap() throws IOException\n+    {\n+        final ObjectMapper mapper = new ObjectMapper();\n+        final Map<String, ObjectWrapper> map = mapper.readValue\n+            (UNTYPED_MAP_JSON,\n+             new TypeReference<Map<String, ObjectWrapper>>() { });\n+       _doTestUntyped(map);\n+    }\n+    \n+    private void _doTestUntyped(final Map<String, ObjectWrapper> map)\n+    {\n+       assertEquals(Double.valueOf(42), map.get(\"double\").getObject());\n+       assertEquals(\"string\", map.get(\"string\").getObject());\n+       assertEquals(Boolean.TRUE, map.get(\"boolean\").getObject());\n+       assertEquals(Collections.singletonList(\"list0\"), map.get(\"list\").getObject());\n+       assertTrue(map.containsKey(\"null\"));\n+       assertNull(map.get(\"null\"));\n+       assertEquals(5, map.size());\n+    }\n+    \n+    // [JACKSON-620]: allow \"\" to mean 'null' for Maps\n+    public void testFromEmptyString() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true);\n+        Map<?,?> result = m.readValue(quote(\"\"), Map.class);\n+        assertNull(result);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods, typed maps\n+    /**********************************************************\n+     */\n+\n+    public void testExactStringIntMap() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // to get typing, must use type reference\n+        String JSON = \"{ \\\"foo\\\" : 13, \\\"bar\\\" : -39, \\n \\\"\\\" : 0 }\";\n+        Map<String,Integer> result = mapper.readValue\n+            (JSON, new TypeReference<HashMap<String,Integer>>() { });\n+\n+        assertNotNull(result);\n+        assertEquals(HashMap.class, result.getClass());\n+        assertEquals(3, result.size());\n+\n+        assertEquals(Integer.valueOf(13), result.get(\"foo\"));\n+        assertEquals(Integer.valueOf(-39), result.get(\"bar\"));\n+        assertEquals(Integer.valueOf(0), result.get(\"\"));\n+        assertNull(result.get(\"foobar\"));\n+        assertNull(result.get(\" \"));\n+    }\n+\n+    /**\n+     * Let's also check that it is possible to do type conversions\n+     * to allow use of non-String Map keys.\n+     */\n+    public void testIntBooleanMap() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // to get typing, must use type reference\n+        String JSON = \"{ \\\"1\\\" : true, \\\"-1\\\" : false }\";\n+        Map<String,Integer> result = mapper.readValue\n+            (JSON, new TypeReference<HashMap<Integer,Boolean>>() { });\n+\n+        assertNotNull(result);\n+        assertEquals(HashMap.class, result.getClass());\n+        assertEquals(2, result.size());\n+\n+        assertEquals(Boolean.TRUE, result.get(Integer.valueOf(1)));\n+        assertEquals(Boolean.FALSE, result.get(Integer.valueOf(-1)));\n+        assertNull(result.get(\"foobar\"));\n+        assertNull(result.get(0));\n+    }\n+\n+    public void testExactStringStringMap() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // to get typing, must use type reference\n+        String JSON = \"{ \\\"a\\\" : \\\"b\\\" }\";\n+        Map<String,Integer> result = mapper.readValue\n+            (JSON, new TypeReference<TreeMap<String,String>>() { });\n+\n+        assertNotNull(result);\n+        assertEquals(TreeMap.class, result.getClass());\n+        assertEquals(1, result.size());\n+\n+        assertEquals(\"b\", result.get(\"a\"));\n+        assertNull(result.get(\"b\"));\n+    }\n+\n+    /**\n+     * Unit test that verifies that it's ok to have incomplete\n+     * information about Map class itself, as long as it's something\n+     * we good guess about: for example, <code>Map.Class</code> will\n+     * be replaced by something like <code>HashMap.class</code>,\n+     * if given.\n+     */\n+    public void testGenericStringIntMap() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // to get typing, must use type reference; but with abstract type\n+        String JSON = \"{ \\\"a\\\" : 1, \\\"b\\\" : 2, \\\"c\\\" : -99 }\";\n+        Map<String,Integer> result = mapper.readValue\n+            (JSON, new TypeReference<Map<String,Integer>>() { });\n+        assertNotNull(result);\n+        assertTrue(result instanceof Map<?,?>);\n+        assertEquals(3, result.size());\n+\n+        assertEquals(Integer.valueOf(-99), result.get(\"c\"));\n+        assertEquals(Integer.valueOf(2), result.get(\"b\"));\n+        assertEquals(Integer.valueOf(1), result.get(\"a\"));\n+\n+        assertNull(result.get(\"\"));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods, maps with enums\n+    /**********************************************************\n+     */\n+\n+    public void testEnumMap() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String JSON = \"{ \\\"KEY1\\\" : \\\"\\\", \\\"WHATEVER\\\" : null }\";\n+\n+        // to get typing, must use type reference\n+        EnumMap<Key,String> result = mapper.readValue\n+            (JSON, new TypeReference<EnumMap<Key,String>>() { });\n+\n+        assertNotNull(result);\n+        assertEquals(EnumMap.class, result.getClass());\n+        assertEquals(2, result.size());\n+\n+        assertEquals(\"\", result.get(Key.KEY1));\n+        // null should be ok too...\n+        assertTrue(result.containsKey(Key.WHATEVER));\n+        assertNull(result.get(Key.WHATEVER));\n+\n+        // plus we have nothing for this key\n+        assertFalse(result.containsKey(Key.KEY2));\n+        assertNull(result.get(Key.KEY2));\n+    }\n+\n+    public void testMapWithEnums() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String JSON = \"{ \\\"KEY2\\\" : \\\"WHATEVER\\\" }\";\n+\n+        // to get typing, must use type reference\n+        Map<Enum<?>,Enum<?>> result = mapper.readValue\n+            (JSON, new TypeReference<Map<Key,Key>>() { });\n+\n+        assertNotNull(result);\n+        assertTrue(result instanceof Map<?,?>);\n+        assertEquals(1, result.size());\n+\n+        assertEquals(Key.WHATEVER, result.get(Key.KEY2));\n+        assertNull(result.get(Key.WHATEVER));\n+        assertNull(result.get(Key.KEY1));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods, maps with Date\n+    /**********************************************************\n+     */\n+    public void testDateMap() throws Exception\n+    {\n+    \t ObjectMapper mapper = new ObjectMapper();\n+    \t Date date1=new Date(123456000L);\n+    \t DateFormat fmt = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\");\n+         \n+    \t String JSON = \"{ \\\"\"+  fmt.format(date1)+\"\\\" : \\\"\\\", \\\"\"+new Date(0).getTime()+\"\\\" : null }\";\n+    \t HashMap<Date,String> result=  mapper.readValue\n+    \t            (JSON, new TypeReference<HashMap<Date,String>>() { });\n+    \t \n+    \t assertNotNull(result);\n+    \t assertEquals(HashMap.class, result.getClass());\n+    \t assertEquals(2, result.size());\n+    \t \n+    \t assertTrue(result.containsKey(date1));\n+    \t assertEquals(\"\", result.get(new Date(123456000L)));\n+    \t \n+    \t assertTrue(result.containsKey(new Date(0)));\n+    \t assertNull(result.get(new Date(0)));\n+    \t \n+    \t \n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods, maps with various alternative key types\n+    /**********************************************************\n+     */\n+\n+    public void testCalendarMap() throws Exception\n+    {\n+    \t ObjectMapper mapper = new ObjectMapper();\n+    \t Calendar c = Calendar.getInstance();\n+         c.setTimeInMillis(123456000L);\n+         DateFormat fmt = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\");\n+    \t String JSON = \"{ \\\"\"+fmt.format(c.getTime())+\"\\\" : \\\"\\\", \\\"\"+new Date(0).getTime()+\"\\\" : null }\";\n+    \t HashMap<Calendar,String> result=  mapper.readValue\n+    \t            (JSON, new TypeReference<HashMap<Calendar,String>>() { });\n+    \t \n+    \t assertNotNull(result);\n+    \t assertEquals(HashMap.class, result.getClass());\n+    \t assertEquals(2, result.size());\n+    \t\n+    \t assertTrue(result.containsKey(c));\n+    \t assertEquals(\"\", result.get(c));\n+    \t c.setTimeInMillis(0);\n+    \t assertTrue(result.containsKey(c));\n+    \t assertNull(result.get(c));\n+    }\n+\n+    // [JACKSON-726]\n+    public void testUUIDKeyMap() throws Exception\n+    {\n+         ObjectMapper mapper = new ObjectMapper();\n+         UUID key = UUID.nameUUIDFromBytes(\"foobar\".getBytes(\"UTF-8\"));\n+         String JSON = \"{ \\\"\"+key+\"\\\":4}\";\n+         Map<UUID,Object> result = mapper.readValue(JSON, new TypeReference<Map<UUID,Object>>() { });\n+         assertNotNull(result);\n+         assertEquals(1, result.size());\n+         Object ob = result.keySet().iterator().next();\n+         assertNotNull(ob);\n+         assertEquals(UUID.class, ob.getClass());\n+         assertEquals(key, ob);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods, annotated Maps\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Simple test to ensure that @JsonDeserialize.using is\n+     * recognized\n+     */\n+    public void testMapWithDeserializer() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        CustomMap result = mapper.readValue(quote(\"xyz\"), CustomMap.class);\n+        assertEquals(1, result.size());\n+        assertEquals(\"xyz\", result.get(\"x\"));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Error tests\n+    /**********************************************************\n+     */\n+\n+    public void testMapError() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            Object result = mapper.readValue(\"[ 1, 2 ]\", \n+                                             new TypeReference<Map<String,String>>() { });\n+            fail(\"Expected an exception, but got result value: \"+result);\n+        } catch (JsonMappingException jex) {\n+            verifyException(jex, \"START_ARRAY\");\n+        }\n+    }\n+\n+    public void testNoCtorMap() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            BrokenMap result = mapper.readValue(\"{ \\\"a\\\" : 3 }\", BrokenMap.class);\n+            // should never get here; assert added to remove compiler warning\n+            assertNull(result);\n+        } catch (JsonMappingException e) {\n+            // instead, should get this exception:\n+            verifyException(e, \"no default constructor found\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestNullHandling.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+public class TestNullHandling extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    static class FunnyNullDeserializer extends JsonDeserializer<String>\n+    {\n+        @Override\n+        public String deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n+            return \"text\";\n+        }\n+\n+        @Override\n+        public String getNullValue() { return \"funny\"; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    // Test for [JACKSON-643]\n+    public void testCustomRootNulls() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addDeserializer(String.class, new FunnyNullDeserializer());\n+        mapper.registerModule(module);\n+\n+        // should get non-default null directly:\n+        String str = mapper.readValue(\"null\", String.class);\n+        assertNotNull(str);\n+        assertEquals(\"funny\", str);\n+        \n+        // as well as via ObjectReader\n+        ObjectReader reader = mapper.reader(String.class);\n+        str = reader.readValue(\"null\");\n+        assertNotNull(str);\n+        assertEquals(\"funny\", str);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestNumbers.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+\n+/**\n+ * Tests related to [JACKSON-139]\n+ */\n+public class TestNumbers\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************************\n+    /* Helper classes, beans\n+    /**********************************************************************\n+     */\n+\n+    static class MyBeanHolder {\n+        public Long id;\n+        public MyBeanDefaultValue defaultValue;\n+    }\n+\n+    static class MyBeanDefaultValue\n+    {\n+        public MyBeanValue value;\n+    }\n+\n+    @JsonDeserialize(using=MyBeanDeserializer.class)\n+    static class MyBeanValue {\n+        public BigDecimal decimal;\n+        public MyBeanValue() { this(null); }\n+        public MyBeanValue(BigDecimal d) { this.decimal = d; }\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Helper classes, serializers/deserializers/resolvers\n+    /**********************************************************************\n+     */\n+    \n+    static class MyBeanDeserializer extends JsonDeserializer<MyBeanValue>\n+    {\n+        @Override\n+        public MyBeanValue deserialize(JsonParser jp, DeserializationContext ctxt)\n+                throws IOException\n+        {\n+            return new MyBeanValue(jp.getDecimalValue());\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Unit tests\n+    /**********************************************************************\n+     */\n+    \n+    public void testFloatNaN() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Float result = m.readValue(\" \\\"NaN\\\"\", Float.class);\n+        assertEquals(Float.valueOf(Float.NaN), result);\n+    }\n+\n+    public void testDoubleInf() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Double result = m.readValue(\" \\\"\"+Double.POSITIVE_INFINITY+\"\\\"\", Double.class);\n+        assertEquals(Double.valueOf(Double.POSITIVE_INFINITY), result);\n+\n+        result = m.readValue(\" \\\"\"+Double.NEGATIVE_INFINITY+\"\\\"\", Double.class);\n+        assertEquals(Double.valueOf(Double.NEGATIVE_INFINITY), result);\n+    }\n+\n+    // [JACKSON-349]\n+    public void testEmptyAsNumber() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertNull(m.readValue(quote(\"\"), Integer.class));\n+        assertNull(m.readValue(quote(\"\"), Long.class));\n+        assertNull(m.readValue(quote(\"\"), Float.class));\n+        assertNull(m.readValue(quote(\"\"), Double.class));\n+        assertNull(m.readValue(quote(\"\"), BigInteger.class));\n+        assertNull(m.readValue(quote(\"\"), BigDecimal.class));\n+    }\n+\n+    // // Tests for [JACKSON-668]\n+    \n+    public void testDeserializeDecimalHappyPath() throws Exception {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = \"{\\\"defaultValue\\\": { \\\"value\\\": 123 } }\";\n+        MyBeanHolder result = mapper.readValue(json, MyBeanHolder.class);\n+        assertEquals(BigDecimal.valueOf(123), result.defaultValue.value.decimal);\n+    }\n+\n+    public void testDeserializeDecimalProperException() throws Exception {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = \"{\\\"defaultValue\\\": { \\\"value\\\": \\\"123\\\" } }\";\n+        try {\n+            mapper.readValue(json, MyBeanHolder.class);\n+            fail(\"should have raised exception\");\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"not numeric\");\n+        }\n+    }\n+\n+    public void testDeserializeDecimalProperExceptionWhenIdSet() throws Exception {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = \"{\\\"id\\\": 5, \\\"defaultValue\\\": { \\\"value\\\": \\\"123\\\" } }\";\n+        try {\n+            MyBeanHolder result = mapper.readValue(json, MyBeanHolder.class);\n+            fail(\"should have raised exception instead value was set to \" + result.defaultValue.value.decimal.toString());\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"not numeric\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestOverloaded.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests related to handling of overloaded methods;\n+ * and specifically addressing problem [JACKSON-189].\n+ *\n+ * @since 1.5\n+ */\n+public class TestOverloaded\n+    extends BaseMapTest\n+{\n+    static class BaseListBean\n+    {\n+        List<String> list;\n+\n+        BaseListBean() { }\n+\n+        public void setList(List<String> l) { list = l; }\n+    }\n+\n+    static class ArrayListBean extends BaseListBean\n+    {\n+        ArrayListBean() { }\n+\n+        public void setList(ArrayList<String> l) { super.setList(l); }\n+    }\n+\n+    // 27-Feb-2010, tatus: Won't fix immediately, need to comment out\n+    /*\n+    static class OverloadBean\n+    {\n+        String a;\n+\n+        public OverloadBean() { }\n+\n+        public void setA(int value) { a = String.valueOf(value); }\n+        public void setA(String value) { a = value; }\n+    }\n+    */\n+\n+    static class NumberBean {\n+    \tprotected Object value;\n+    \t\n+    \tpublic void setValue(Number n) { value = n; }\n+    }\n+\n+    static class WasNumberBean extends NumberBean {\n+    \tpublic void setValue(String str) { value = str; }\n+    }\n+\n+    /**\n+     * And then a Bean that is conflicting and should not work\n+     */\n+    static class ConflictBean {\n+    \tpublic void setA(ArrayList<Object> a) { }\n+    \tpublic void setA(LinkedList<Object> a) { }\n+    }\n+    \n+    /*\n+    /************************************************************\n+    /* Unit tests\n+    /************************************************************\n+    */\n+\n+    /**\n+     * Unit test related to [JACKSON-189]\n+     */\n+    // 27-Feb-2010, tatus: Won't fix immediately, need to comment out\n+    /*\n+    public void testSimpleOverload() throws Exception\n+    {\n+        OverloadBean bean;\n+        try {\n+            bean = new ObjectMapper().readValue(\"{ \\\"a\\\" : 13 }\", OverloadBean.class);\n+        } catch (JsonMappingException e) {\n+            fail(\"Did not expect an exception, got: \"+e.getMessage());\n+            return;\n+        }\n+        assertEquals(\"13\", bean.a);\n+    }\n+    */\n+\n+    /**\n+     * It should be ok to overload with specialized \n+     * version; more specific method should be used.\n+     */\n+    public void testSpecialization() throws Exception\n+    {\n+        ArrayListBean bean = new ObjectMapper().readValue\n+            (\"{\\\"list\\\":[\\\"a\\\",\\\"b\\\",\\\"c\\\"]}\", ArrayListBean.class);\n+        assertNotNull(bean.list);\n+        assertEquals(3, bean.list.size());\n+        assertEquals(ArrayList.class, bean.list.getClass());\n+        assertEquals(\"a\", bean.list.get(0));\n+        assertEquals(\"b\", bean.list.get(1));\n+        assertEquals(\"c\", bean.list.get(2));\n+    }\n+\n+    /**\n+     * As per [JACKSON-255], should also allow more general overriding,\n+     * as long as there are no in-class conflicts.\n+     */\n+    public void testOverride() throws Exception\n+    {\n+        WasNumberBean bean = new ObjectMapper().readValue\n+            (\"{\\\"value\\\" : \\\"abc\\\"}\", WasNumberBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"abc\", bean.value);\n+    }\n+\n+    /**\n+     * For genuine setter conflict, an exception is to be thrown.\n+     */\n+    public void testSetterConflict() throws Exception\n+    {\n+    \ttry {    \t\t\n+    \t\tnew ObjectMapper().readValue(\"{ }\", ConflictBean.class);\n+    \t} catch (Exception e) {\n+    \t\tverifyException(e, \"Conflicting setter definitions\");\n+    \t}\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestParentChildReferences.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestParentChildReferences\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Test classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * First, a simple 'tree': just parent/child linkage\n+     */\n+    static class SimpleTreeNode\n+    {\n+        public String name;\n+        \n+        // Reference back to parent; reference, ignored during ser,\n+        // re-constructed during deser\n+        @JsonBackReference\n+        public SimpleTreeNode parent;\n+\n+        // Reference that is serialized normally during ser, back\n+        // reference within pointed-to instance assigned to point to\n+        // referring bean (\"this\")\n+        @JsonManagedReference\n+        public SimpleTreeNode child;\n+\n+        public SimpleTreeNode() { this(null); }\n+        public SimpleTreeNode(String n) { name = n; }\n+    }\n+\n+    static class SimpleTreeNode2\n+    {\n+        public String name;\n+        private SimpleTreeNode2 parent;\n+        private SimpleTreeNode2 child;\n+\n+        public SimpleTreeNode2() { this(null); }\n+        public SimpleTreeNode2(String n) { name = n; }\n+\n+        @JsonBackReference\n+        public SimpleTreeNode2 getParent() { return parent; }\n+        public void setParent(SimpleTreeNode2 p) { parent = p; }\n+\n+        @JsonManagedReference\n+        public SimpleTreeNode2 getChild() { return child; }\n+        public void setChild(SimpleTreeNode2 c) { child = c; }\n+    }\n+    \n+    /**\n+     * Then nodes with two separate linkages; parent/child\n+     * and prev/next-sibling\n+     */\n+    static class FullTreeNode\n+    {\n+        public String name;\n+\n+        // parent-child links\n+        @JsonBackReference(\"parent\")\n+        public FullTreeNode parent;\n+        @JsonManagedReference(\"parent\")\n+        public FullTreeNode firstChild;\n+\n+        // sibling-links\n+        @JsonManagedReference(\"sibling\")\n+        public FullTreeNode next;\n+        @JsonBackReference(\"sibling\")\n+        protected FullTreeNode prev;\n+        \n+        public FullTreeNode() { this(null); }\n+        public FullTreeNode(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    /**\n+     * Class for testing managed references via arrays\n+     */\n+    static class NodeArray\n+    {\n+        @JsonManagedReference(\"arr\")\n+        public ArrayNode[] nodes;\n+    }\n+\n+    static class ArrayNode\n+    {\n+        public String name;\n+        \n+        @JsonBackReference(\"arr\")\n+        public NodeArray parent;\n+\n+        public ArrayNode() { this(null); }\n+        public ArrayNode(String n) { name = n; }\n+    }\n+    \n+    /**\n+     * Class for testing managed references via Collections\n+     */\n+    static class NodeList\n+    {\n+        @JsonManagedReference\n+        public List<NodeForList> nodes;\n+    }\n+\n+    static class NodeForList\n+    {\n+        public String name;\n+        \n+        @JsonBackReference\n+        public NodeList parent;\n+\n+        public NodeForList() { this(null); }\n+        public NodeForList(String n) { name = n; }\n+    }\n+    \n+    static class NodeMap\n+    {\n+        @JsonManagedReference\n+        public Map<String,NodeForMap> nodes;\n+    }\n+\n+    static class NodeForMap\n+    {\n+        public String name;\n+        \n+        @JsonBackReference\n+        public NodeMap parent;\n+\n+        public NodeForMap() { this(null); }\n+        public NodeForMap(String n) { name = n; }\n+    }\n+\n+    public static class Parent {\n+        @JsonManagedReference\n+        private final List<Child> children = new ArrayList<Child>();\n+\n+        public List<Child> getChildren() { return children; }\n+\n+        public void addChild(Child child) { children.add(child); child.setParent(this); }\n+    }\n+\n+    public static class Child {\n+        private Parent parent;\n+        private final String value; // So that the bean is not empty of properties\n+\n+        public Child(@JsonProperty(\"value\") String value) { this.value = value; }\n+\n+        public String getValue() { return value; }\n+\n+        @JsonBackReference\n+        public Parent getParent() { return parent; }\n+\n+        public void setParent(Parent parent) { this.parent = parent; }\n+    }    \n+\n+    // [JACKSON-708]\n+    static class Model708 { }\n+    \n+    static class Advertisement708 extends Model708 {\n+        public String title;\n+        @JsonManagedReference public List<Photo708> photos;\n+    }\n+\n+    static class Photo708 extends Model708 {\n+        public int id;\n+        @JsonBackReference public Advertisement708 advertisement;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testSimpleRefs() throws Exception\n+    {\n+        SimpleTreeNode root = new SimpleTreeNode(\"root\");\n+        SimpleTreeNode child = new SimpleTreeNode(\"kid\");\n+        ObjectMapper mapper = new ObjectMapper();\n+        root.child = child;\n+        child.parent = root;\n+        \n+        String json = mapper.writeValueAsString(root);\n+        \n+        SimpleTreeNode resultNode = mapper.readValue(json, SimpleTreeNode.class);\n+        assertEquals(\"root\", resultNode.name);\n+        SimpleTreeNode resultChild = resultNode.child;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+    }\n+\n+    // [JACKSON-693]\n+    public void testSimpleRefsWithGetter() throws Exception\n+    {\n+        SimpleTreeNode2 root = new SimpleTreeNode2(\"root\");\n+        SimpleTreeNode2 child = new SimpleTreeNode2(\"kid\");\n+        ObjectMapper mapper = new ObjectMapper();\n+        root.child = child;\n+        child.parent = root;\n+        \n+        String json = mapper.writeValueAsString(root);\n+        \n+        SimpleTreeNode2 resultNode = mapper.readValue(json, SimpleTreeNode2.class);\n+        assertEquals(\"root\", resultNode.name);\n+        SimpleTreeNode2 resultChild = resultNode.child;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+    }\n+    \n+    public void testFullRefs() throws Exception\n+    {\n+        FullTreeNode root = new FullTreeNode(\"root\");\n+        FullTreeNode child1 = new FullTreeNode(\"kid1\");\n+        FullTreeNode child2 = new FullTreeNode(\"kid2\");\n+        ObjectMapper mapper = new ObjectMapper();\n+        root.firstChild = child1;\n+        child1.parent = root;\n+        child1.next = child2;\n+        child2.prev = child1;\n+        \n+        String json = mapper.writeValueAsString(root);\n+        \n+        FullTreeNode resultNode = mapper.readValue(json, FullTreeNode.class);\n+        assertEquals(\"root\", resultNode.name);\n+        FullTreeNode resultChild = resultNode.firstChild;\n+        assertNotNull(resultChild);\n+        assertEquals(\"kid1\", resultChild.name);\n+        assertSame(resultChild.parent, resultNode);\n+\n+        // and then sibling linkage\n+        assertNull(resultChild.prev);\n+        FullTreeNode resultChild2 = resultChild.next;\n+        assertNotNull(resultChild2);\n+        assertEquals(\"kid2\", resultChild2.name);\n+        assertSame(resultChild, resultChild2.prev);\n+        assertNull(resultChild2.next);\n+    }\n+\n+    public void testArrayOfRefs() throws Exception\n+    {\n+        NodeArray root = new NodeArray();\n+        ArrayNode node1 = new ArrayNode(\"a\");\n+        ArrayNode node2 = new ArrayNode(\"b\");\n+        root.nodes = new ArrayNode[] { node1, node2 };\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(root);\n+        \n+        NodeArray result = mapper.readValue(json, NodeArray.class);\n+        ArrayNode[] kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.length);\n+        assertEquals(\"a\", kids[0].name);\n+        assertEquals(\"b\", kids[1].name);\n+        assertSame(result, kids[0].parent);\n+        assertSame(result, kids[1].parent);\n+    }\n+\n+    public void testListOfRefs() throws Exception\n+    {\n+        NodeList root = new NodeList();\n+        NodeForList node1 = new NodeForList(\"a\");\n+        NodeForList node2 = new NodeForList(\"b\");\n+        root.nodes = Arrays.asList(node1, node2);\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(root);\n+        \n+        NodeList result = mapper.readValue(json, NodeList.class);\n+        List<NodeForList> kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.size());\n+        assertEquals(\"a\", kids.get(0).name);\n+        assertEquals(\"b\", kids.get(1).name);\n+        assertSame(result, kids.get(0).parent);\n+        assertSame(result, kids.get(1).parent);\n+    }\n+\n+    public void testMapOfRefs() throws Exception\n+    {\n+        NodeMap root = new NodeMap();\n+        NodeForMap node1 = new NodeForMap(\"a\");\n+        NodeForMap node2 = new NodeForMap(\"b\");\n+        Map<String,NodeForMap> nodes = new HashMap<String, NodeForMap>();\n+        nodes.put(\"a1\", node1);\n+        nodes.put(\"b2\", node2);\n+        root.nodes = nodes;\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(root);\n+        \n+        NodeMap result = mapper.readValue(json, NodeMap.class);\n+        Map<String,NodeForMap> kids = result.nodes;\n+        assertNotNull(kids);\n+        assertEquals(2, kids.size());\n+        assertNotNull(kids.get(\"a1\"));\n+        assertNotNull(kids.get(\"b2\"));\n+        assertEquals(\"a\", kids.get(\"a1\").name);\n+        assertEquals(\"b\", kids.get(\"b2\").name);\n+        assertSame(result, kids.get(\"a1\").parent);\n+        assertSame(result, kids.get(\"b2\").parent);\n+    }\n+\n+    public void testIssue693() throws Exception\n+    {\n+        Parent parent = new Parent();\n+        parent.addChild(new Child(\"foo\"));\n+        parent.addChild(new Child(\"bar\"));\n+        ObjectMapper mapper = new ObjectMapper();\n+        byte[] bytes = mapper.writeValueAsBytes(parent);\n+        Parent value = mapper.readValue(bytes, Parent.class); \n+        for (Child child : value.children) {\n+            assertEquals(value, child.getParent());\n+        }\n+    }\n+\n+    public void testIssue708() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Advertisement708 ad = mapper.readValue(\"{\\\"title\\\":\\\"Hroch\\\",\\\"photos\\\":[{\\\"id\\\":3}]}\", Advertisement708.class);      \n+        assertNotNull(ad);\n+    }   \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestPolymorphicCreators.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for verifying that it is possible to annotate\n+ * various kinds of things with {@link JsonCreator} annotation.\n+ */\n+public class TestPolymorphicCreators\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper beans\n+    /**********************************************************\n+     */\n+\n+    static class Animal\n+    {\n+\t// All animals have names, for our demo purposes...\n+\tpublic String name;\n+\n+\tprotected Animal() { }\n+\n+\t/**\n+\t * Creator method that can instantiate instances of\n+\t * appropriate polymoprphic type\n+\t */\n+        @JsonCreator\n+\tpublic static Animal create(@JsonProperty(\"type\") String type)\n+\t{\n+\t    if (\"dog\".equals(type)) {\n+\t\treturn new Dog();\n+\t    }\n+\t    if (\"cat\".equals(type)) {\n+\t\treturn new Cat();\n+\t    }\n+\t    throw new IllegalArgumentException(\"No such animal type ('\"+type+\"')\");\n+\t}\n+    }\n+\n+    static class Dog extends Animal\n+    {\n+\tdouble barkVolume; // in decibels\n+\tpublic Dog() { }\n+\tpublic void setBarkVolume(double v) { barkVolume = v; }\n+    }\n+\n+    static class Cat extends Animal\n+    {\n+\tboolean likesCream;\n+\tpublic int lives;\n+\tpublic Cat() { }\n+\tpublic void setLikesCream(boolean likesCreamSurely) { likesCream = likesCreamSurely; }\n+    }\n+\n+    abstract static class AbstractRoot\n+    {\n+        private final String opt;\n+\n+        private AbstractRoot(String opt) {\n+            this.opt = opt;\n+        }\n+\n+        @JsonCreator\n+        public static final AbstractRoot make(@JsonProperty(\"which\") int which,\n+            @JsonProperty(\"opt\") String opt) {\n+            if(1 == which) {\n+                return new One(opt);\n+            }\n+            throw new RuntimeException(\"cannot instantiate \" + which);\n+        }\n+\n+        abstract public int getWhich();\n+\n+        public final String getOpt() {\n+                return opt;\n+        }\n+    }\n+\n+    static final class One extends AbstractRoot {\n+            private One(String opt) {\n+                    super(opt);\n+            }\n+\n+            @Override public int getWhich() {\n+                    return 1;\n+            }\n+    }\n+    \n+    /*\n+    **********************************************\n+    * Actual tests\n+    **********************************************\n+     */\n+\n+    /**\n+     * Simple test to verify that it is possible to implement polymorphic\n+     * deserialization manually.\n+     */\n+    public void testManualPolymorphicDog() throws Exception\n+    {\n+\tObjectMapper mapper = new ObjectMapper();\n+\t// first, a dog, start with type\n+\tAnimal animal = mapper.readValue(\"{ \\\"type\\\":\\\"dog\\\", \\\"name\\\":\\\"Fido\\\", \\\"barkVolume\\\" : 95.0 }\", Animal.class);\n+\tassertEquals(Dog.class, animal.getClass());\n+\tassertEquals(\"Fido\", animal.name);\n+\tassertEquals(95.0, ((Dog) animal).barkVolume);\n+    }\n+\n+    public void testManualPolymorphicCatBasic() throws Exception\n+    {\n+\tObjectMapper mapper = new ObjectMapper();\n+\t// and finally, lactose-intolerant, but otherwise robust super-cat:\n+\tAnimal animal = mapper.readValue(\"{ \\\"name\\\" : \\\"Macavity\\\", \\\"type\\\":\\\"cat\\\", \\\"lives\\\":18, \\\"likesCream\\\":false }\", Animal.class);\n+\tassertEquals(Cat.class, animal.getClass());\n+\tassertEquals(\"Macavity\", animal.name); // ... there's no one like Macavity!\n+\tCat cat = (Cat) animal;\n+\tassertEquals(18, cat.lives);\n+\t// ok, he can't drink dairy products. Let's verify:\n+\tassertEquals(false, cat.likesCream);\n+    }\n+\n+    public void testManualPolymorphicCatWithReorder() throws Exception\n+    {\n+\tObjectMapper mapper = new ObjectMapper();\n+\t// Then cat; shuffle order to mandate buffering\n+\tAnimal animal = mapper.readValue(\"{ \\\"likesCream\\\":true, \\\"name\\\" : \\\"Venla\\\", \\\"type\\\":\\\"cat\\\" }\", Animal.class);\n+\tassertEquals(Cat.class, animal.getClass());\n+\tassertEquals(\"Venla\", animal.name);\n+\t// bah, of course cats like cream. But let's ensure Jackson won't mess with laws of nature!\n+\tassertTrue(((Cat) animal).likesCream);\n+    }\n+\n+    public void testManualPolymorphicWithNumbered() throws Exception\n+    {\n+         final ObjectMapper m = new ObjectMapper();\n+         final ObjectWriter w = m.writerWithType(AbstractRoot.class);\n+         final ObjectReader r = m.reader(AbstractRoot.class);\n+\n+        AbstractRoot input = AbstractRoot.make(1, \"oh hai!\");\n+        String json = w.writeValueAsString(input);\n+        AbstractRoot result = r.readValue(json);\n+        assertNotNull(result);\n+        assertEquals(\"oh hai!\", result.getOpt());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSetterlessProperties.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for verifying that feature requested\n+ * via [JACKSON-88] (\"setterless collections\") work as\n+ * expected, similar to how Collections and Maps work\n+ * with JAXB.\n+ */\n+public class TestSetterlessProperties\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper beans\n+    /**********************************************************\n+     */\n+\n+    static class CollectionBean\n+    {\n+        List<String> _values = new ArrayList<String>();\n+\n+        public List<String> getValues() { return _values; }\n+    }\n+\n+    static class MapBean\n+    {\n+        Map<String,Integer> _values = new HashMap<String,Integer>();\n+\n+        public Map<String,Integer> getValues() { return _values; }\n+    }\n+\n+    // testing to verify that field has precedence over getter, for lists\n+    static class Dual\n+    {\n+        @JsonProperty(\"list\") protected List<Integer> values = new ArrayList<Integer>();\n+\n+        public Dual() { }\n+        \n+        public List<Integer> getList() {\n+            throw new IllegalStateException(\"Should not get called\");\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleSetterlessCollectionOk()\n+        throws Exception\n+    {\n+        CollectionBean result = new ObjectMapper().readValue\n+            (\"{\\\"values\\\":[ \\\"abc\\\", \\\"def\\\" ]}\", CollectionBean.class);\n+        List<String> l = result._values;\n+        assertEquals(2, l.size());\n+        assertEquals(\"abc\", l.get(0));\n+        assertEquals(\"def\", l.get(1));\n+    }\n+\n+    /**\n+     * Let's also verify that disabling the feature makes\n+     * deserialization fail for setterless bean\n+     */\n+    public void testSimpleSetterlessCollectionFailure()\n+        throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // by default, it should be enabled\n+        assertTrue(m.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS));\n+        m.configure(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS, false);\n+        assertFalse(m.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS));\n+\n+        // and now this should fail\n+        try {\n+            m.readValue\n+                (\"{\\\"values\\\":[ \\\"abc\\\", \\\"def\\\" ]}\", CollectionBean.class);\n+            fail(\"Expected an exception\");\n+        } catch (JsonMappingException e) {\n+            /* Not a good exception, ideally could suggest a need for\n+             * a setter...?\n+             */\n+            verifyException(e, \"Unrecognized field\");\n+        }\n+    }\n+\n+    public void testSimpleSetterlessMapOk()\n+        throws Exception\n+    {\n+        MapBean result = new ObjectMapper().readValue\n+            (\"{\\\"values\\\":{ \\\"a\\\": 15, \\\"b\\\" : -3 }}\", MapBean.class);\n+        Map<String,Integer> m = result._values;\n+        assertEquals(2, m.size());\n+        assertEquals(Integer.valueOf(15), m.get(\"a\"));\n+        assertEquals(Integer.valueOf(-3), m.get(\"b\"));\n+    }\n+\n+    public void testSimpleSetterlessMapFailure()\n+        throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS, false);\n+        // so this should fail now without a setter\n+        try {\n+            m.readValue\n+                (\"{\\\"values\\\":{ \\\"a\\\":3 }}\", MapBean.class);\n+            fail(\"Expected an exception\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Unrecognized field\");\n+        }\n+    }\n+\n+    /* Test for [JACKSON-328], precedence of \"getter-as-setter\" (for Lists) versus\n+     * field for same property.\n+     */\n+    public void testSetterlessPrecedence() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS, true);\n+        Dual value = m.readValue(\"{\\\"list\\\":[1,2,3]}, valueType)\", Dual.class);\n+        assertNotNull(value);\n+        assertEquals(3, value.values.size());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleAtomicTypes.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.concurrent.atomic.*;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestSimpleAtomicTypes\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    public void testAtomicBoolean() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AtomicBoolean b = mapper.readValue(\"true\", AtomicBoolean.class);\n+        assertTrue(b.get());\n+    }\n+\n+    public void testAtomicInt() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AtomicInteger value = mapper.readValue(\"13\", AtomicInteger.class);\n+        assertEquals(13, value.get());\n+    }\n+\n+    public void testAtomicLong() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AtomicLong value = mapper.readValue(\"12345678901\", AtomicLong.class);\n+        assertEquals(12345678901L, value.get());\n+    }\n+\n+    public void testAtomicReference() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AtomicReference<long[]> value = mapper.readValue(\"[1,2]\",\n+                new com.fasterxml.jackson.core.type.TypeReference<AtomicReference<long[]>>() { });\n+        Object ob = value.get();\n+        assertNotNull(ob);\n+        assertEquals(long[].class, ob.getClass());\n+        long[] longs = (long[]) ob;\n+        assertNotNull(longs);\n+        assertEquals(2, longs.length);\n+        assertEquals(1, longs[0]);\n+        assertEquals(2, longs[1]);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestSimpleTypes.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.net.URL;\n+import java.net.URI;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n+\n+/**\n+ * Unit tests for verifying handling of simple basic non-structured\n+ * types; primitives (and/or their wrappers), Strings.\n+ */\n+public class TestSimpleTypes\n+    extends BaseMapTest\n+{\n+    final static String NAN_STRING = \"NaN\";\n+\n+    final static class BooleanBean {\n+        boolean _v;\n+        void setV(boolean v) { _v = v; }\n+    }\n+\n+    static class IntBean {\n+        int _v;\n+        void setV(int v) { _v = v; }\n+    }\n+\n+    final static class DoubleBean {\n+        double _v;\n+        void setV(double v) { _v = v; }\n+    }\n+\n+    final static class FloatBean {\n+        float _v;\n+        void setV(float v) { _v = v; }\n+    }\n+\n+    /**\n+     * Also, let's ensure that it's ok to override methods.\n+     */\n+    static class IntBean2\n+        extends IntBean\n+    {\n+        @Override\n+        void setV(int v2) { super.setV(v2+1); }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Then tests for primitives\n+    /**********************************************************\n+     */\n+\n+    public void testBooleanPrimitive() throws Exception\n+    {\n+        // first, simple case:\n+        ObjectMapper mapper = new ObjectMapper();\n+        BooleanBean result = mapper.readValue(new StringReader(\"{\\\"v\\\":true}\"), BooleanBean.class);\n+        assertTrue(result._v);\n+        // then [JACKSON-79]:\n+        result = mapper.readValue(new StringReader(\"{\\\"v\\\":null}\"), BooleanBean.class);\n+        assertNotNull(result);\n+        assertFalse(result._v);\n+\n+        // should work with arrays too..\n+        boolean[] array = mapper.readValue(new StringReader(\"[ null ]\"), boolean[].class);\n+        assertNotNull(array);\n+        assertEquals(1, array.length);\n+        assertFalse(array[0]);\n+    }\n+\n+    public void testIntPrimitive() throws Exception\n+    {\n+        // first, simple case:\n+        ObjectMapper mapper = new ObjectMapper();\n+        IntBean result = mapper.readValue(new StringReader(\"{\\\"v\\\":3}\"), IntBean.class);\n+        assertEquals(3, result._v);\n+        // then [JACKSON-79]:\n+        result = mapper.readValue(new StringReader(\"{\\\"v\\\":null}\"), IntBean.class);\n+        assertNotNull(result);\n+        assertEquals(0, result._v);\n+\n+        // should work with arrays too..\n+        int[] array = mapper.readValue(new StringReader(\"[ null ]\"), int[].class);\n+        assertNotNull(array);\n+        assertEquals(1, array.length);\n+        assertEquals(0, array[0]);\n+    }\n+\n+    public void testDoublePrimitive() throws Exception\n+    {\n+        // first, simple case:\n+        ObjectMapper mapper = new ObjectMapper();\n+        // bit tricky with binary fps but...\n+        double value = 0.016;\n+        DoubleBean result = mapper.readValue(new StringReader(\"{\\\"v\\\":\"+value+\"}\"), DoubleBean.class);\n+        assertEquals(value, result._v);\n+        // then [JACKSON-79]:\n+        result = mapper.readValue(new StringReader(\"{\\\"v\\\":null}\"), DoubleBean.class);\n+        assertNotNull(result);\n+        assertEquals(0.0, result._v);\n+\n+        // should work with arrays too..\n+        double[] array = mapper.readValue(new StringReader(\"[ null ]\"), double[].class);\n+        assertNotNull(array);\n+        assertEquals(1, array.length);\n+        assertEquals(0.0, array[0]);\n+    }\n+\n+    public void testDoublePrimitiveNonNumeric() throws Exception\n+    {\n+        // first, simple case:\n+        ObjectMapper mapper = new ObjectMapper();\n+        // bit tricky with binary fps but...\n+        double value = Double.POSITIVE_INFINITY;\n+        DoubleBean result = mapper.readValue(new StringReader(\"{\\\"v\\\":\\\"\"+value+\"\\\"}\"), DoubleBean.class);\n+        assertEquals(value, result._v);\n+        \n+        // should work with arrays too..\n+        double[] array = mapper.readValue(new StringReader(\"[ \\\"Infinity\\\" ]\"), double[].class);\n+        assertNotNull(array);\n+        assertEquals(1, array.length);\n+        assertEquals(Double.POSITIVE_INFINITY, array[0]);\n+    }\n+    \n+    public void testFloatPrimitiveNonNumeric() throws Exception\n+    {\n+        // first, simple case:\n+        ObjectMapper mapper = new ObjectMapper();\n+        // bit tricky with binary fps but...\n+        float value = Float.POSITIVE_INFINITY;\n+        FloatBean result = mapper.readValue(new StringReader(\"{\\\"v\\\":\\\"\"+value+\"\\\"}\"), FloatBean.class);\n+        assertEquals(value, result._v);\n+        \n+        // should work with arrays too..\n+        float[] array = mapper.readValue(new StringReader(\"[ \\\"Infinity\\\" ]\"), float[].class);\n+        assertNotNull(array);\n+        assertEquals(1, array.length);\n+        assertEquals(Float.POSITIVE_INFINITY, array[0]);\n+    }\n+    \n+    /**\n+     * Beyond simple case, let's also ensure that method overriding works as\n+     * expected.\n+     */\n+    public void testIntWithOverride() throws Exception\n+    {\n+        // first, simple case:\n+        ObjectMapper mapper = new ObjectMapper();\n+        IntBean2 result = mapper.readValue(new StringReader(\"{\\\"v\\\":8}\"), IntBean2.class);\n+        assertEquals(9, result._v);\n+\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Then tests for wrappers\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Simple unit test to verify that we can map boolean values to\n+     * java.lang.Boolean.\n+     */\n+    public void testBooleanWrapper() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Boolean result = mapper.readValue(new StringReader(\"true\"), Boolean.class);\n+        assertEquals(Boolean.TRUE, result);\n+        result = mapper.readValue(new StringReader(\"false\"), Boolean.class);\n+        assertEquals(Boolean.FALSE, result);\n+\n+        /* [JACKSON-78]: should accept ints too, (0 == false, otherwise true)\n+         */\n+        result = mapper.readValue(new StringReader(\"0\"), Boolean.class);\n+        assertEquals(Boolean.FALSE, result);\n+        result = mapper.readValue(new StringReader(\"1\"), Boolean.class);\n+        assertEquals(Boolean.TRUE, result);\n+    }\n+\n+    public void testByteWrapper() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Byte result = mapper.readValue(new StringReader(\"   -42\\t\"), Byte.class);\n+        assertEquals(Byte.valueOf((byte)-42), result);\n+\n+        // Also: should be able to coerce floats, strings:\n+        result = mapper.readValue(new StringReader(\" \\\"-12\\\"\"), Byte.class);\n+        assertEquals(Byte.valueOf((byte)-12), result);\n+\n+        result = mapper.readValue(new StringReader(\" 39.07\"), Byte.class);\n+        assertEquals(Byte.valueOf((byte)39), result);\n+    }\n+\n+    public void testShortWrapper() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Short result = mapper.readValue(new StringReader(\"37\"), Short.class);\n+        assertEquals(Short.valueOf((short)37), result);\n+\n+        // Also: should be able to coerce floats, strings:\n+        result = mapper.readValue(new StringReader(\" \\\"-1009\\\"\"), Short.class);\n+        assertEquals(Short.valueOf((short)-1009), result);\n+\n+        result = mapper.readValue(new StringReader(\"-12.9\"), Short.class);\n+        assertEquals(Short.valueOf((short)-12), result);\n+    }\n+\n+    public void testCharacterWrapper() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // First: canonical value is 1-char string\n+        Character result = mapper.readValue(new StringReader(\"\\\"a\\\"\"), Character.class);\n+        assertEquals(Character.valueOf('a'), result);\n+\n+        // But can also pass in ascii code\n+        result = mapper.readValue(new StringReader(\" \"+((int) 'X')), Character.class);\n+        assertEquals(Character.valueOf('X'), result);\n+    }\n+\n+    public void testIntWrapper() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Integer result = mapper.readValue(new StringReader(\"   -42\\t\"), Integer.class);\n+        assertEquals(Integer.valueOf(-42), result);\n+\n+        // Also: should be able to coerce floats, strings:\n+        result = mapper.readValue(new StringReader(\" \\\"-1200\\\"\"), Integer.class);\n+        assertEquals(Integer.valueOf(-1200), result);\n+\n+        result = mapper.readValue(new StringReader(\" 39.07\"), Integer.class);\n+        assertEquals(Integer.valueOf(39), result);\n+    }\n+\n+    public void testLongWrapper() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Long result = mapper.readValue(new StringReader(\"12345678901\"), Long.class);\n+        assertEquals(Long.valueOf(12345678901L), result);\n+\n+        // Also: should be able to coerce floats, strings:\n+        result = mapper.readValue(new StringReader(\" \\\"-9876\\\"\"), Long.class);\n+        assertEquals(Long.valueOf(-9876), result);\n+\n+        result = mapper.readValue(new StringReader(\"1918.3\"), Long.class);\n+        assertEquals(Long.valueOf(1918), result);\n+    }\n+\n+    /* Note: dealing with floating-point values is tricky; not sure if\n+     * we can really use equality tests here... JDK does have decent\n+     * conversions though, to retain accuracy and round-trippability.\n+     * But still...\n+     */\n+    public void testFloatWrapper() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        // Also: should be able to coerce floats, strings:\n+        String[] STRS = new String[] {\n+            \"1.0\", \"0.0\", \"-0.3\", \"0.7\", \"42.012\", \"-999.0\", NAN_STRING\n+        };\n+\n+        for (String str : STRS) {\n+            Float exp = Float.valueOf(str);\n+            Float result;\n+\n+            if (NAN_STRING != str) {\n+                // First, as regular floating point value\n+                result = mapper.readValue(new StringReader(str), Float.class);\n+                assertEquals(exp, result);\n+            }\n+\n+            // and then as coerced String:\n+            result = mapper.readValue(new StringReader(\" \\\"\"+str+\"\\\"\"), Float.class);\n+            assertEquals(exp, result);\n+        }\n+    }\n+\n+    public void testDoubleWrapper() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        // Also: should be able to coerce doubles, strings:\n+        String[] STRS = new String[] {\n+            \"1.0\", \"0.0\", \"-0.3\", \"0.7\", \"42.012\", \"-999.0\", NAN_STRING\n+        };\n+\n+        for (String str : STRS) {\n+            Double exp = Double.valueOf(str);\n+            Double result;\n+\n+            // First, as regular double value\n+            if (NAN_STRING != str) {\n+            \tresult = mapper.readValue(new StringReader(str), Double.class);\n+            \tassertEquals(exp, result);\n+            }\n+            // and then as coerced String:\n+            result = mapper.readValue(new StringReader(\" \\\"\"+str+\"\\\"\"), Double.class);\n+            assertEquals(exp, result);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Simple non-primitive types\n+    /**********************************************************\n+     */\n+\n+    public void testSingleString() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String value = \"FOO!\";\n+        String result = mapper.readValue(new StringReader(\"\\\"\"+value+\"\\\"\"), String.class);\n+        assertEquals(value, result);\n+    }\n+\n+    public void testNull() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // null doesn't really have a type, fake by assuming Object\n+        Object result = mapper.readValue(\"   null\", Object.class);\n+        assertNull(result);\n+    }\n+\n+    public void testClass() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Class<?> result = mapper.readValue(\"\\\"java.lang.String\\\"\", Class.class);\n+        assertEquals(String.class, result);\n+    }\n+\n+    public void testBigDecimal() throws Exception\n+    {\n+        BigDecimal value = new BigDecimal(\"0.001\");\n+        BigDecimal result = new ObjectMapper().readValue(new StringReader(value.toString()), BigDecimal.class);\n+        assertEquals(value, result);\n+    }\n+\n+    public void testBigInteger() throws Exception\n+    {\n+        BigInteger value = new BigInteger(\"-1234567890123456789012345567809\");\n+        BigInteger result = new ObjectMapper().readValue(new StringReader(value.toString()), BigInteger.class);\n+        assertEquals(value, result);\n+    }\n+\n+    public void testUUID() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        UUID value = UUID.fromString(\"76e6d183-5f68-4afa-b94a-922c1fdb83f8\");\n+        assertEquals(value, mapper.readValue(\"\\\"\"+value.toString()+\"\\\"\", UUID.class));\n+\n+        // [JACKSON-393] fix:\n+\n+        // first, null should come as null\n+        TokenBuffer buf = new TokenBuffer(null);\n+        buf.writeObject(null);\n+        assertNull(mapper.readValue(buf.asParser(), UUID.class));\n+\n+        // then, UUID itself come as is:\n+        buf = new TokenBuffer(null);\n+        buf.writeObject(value);\n+        assertSame(value, mapper.readValue(buf.asParser(), UUID.class));\n+\n+        // and finally from byte[]\n+        // oh crap; JDK UUID just... sucks. Not even byte[] accessors or constructors? Huh?\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+        DataOutputStream out = new DataOutputStream(bytes);\n+        out.writeLong(value.getMostSignificantBits());\n+        out.writeLong(value.getLeastSignificantBits());\n+        byte[] data = bytes.toByteArray();\n+        assertEquals(16, data.length);\n+        \n+        buf.writeObject(data);\n+\n+        UUID value2 = mapper.readValue(buf.asParser(), UUID.class);\n+        \n+        assertEquals(value, value2);\n+    }\n+\n+    public void testURL() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        URL value = new URL(\"http://foo.com\");\n+        assertEquals(value, mapper.readValue(\"\\\"\"+value.toString()+\"\\\"\", URL.class));\n+\n+        // trivial case; null to null, embedded URL to URL\n+        TokenBuffer buf = new TokenBuffer(null);\n+        buf.writeObject(null);\n+        assertNull(mapper.readValue(buf.asParser(), URL.class));\n+\n+        // then, UUID itself come as is:\n+        buf = new TokenBuffer(null);\n+        buf.writeObject(value);\n+        assertSame(value, mapper.readValue(buf.asParser(), URL.class));\n+    }\n+\n+    public void testURI() throws Exception\n+    {\n+        URI value = new URI(\"http://foo.com\");\n+        assertEquals(value, new ObjectMapper().readValue(\"\\\"\"+value.toString()+\"\\\"\", URI.class));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Sequence tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Then a unit test to verify that we can conveniently bind sequence of\n+     * space-separate simple values\n+     */\n+    public void testSequenceOfInts() throws Exception\n+    {\n+        final int NR_OF_INTS = 100;\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < NR_OF_INTS; ++i) {\n+            sb.append(\" \");\n+            sb.append(i);\n+        }\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonParser jp = mapper.getJsonFactory().createJsonParser(sb.toString());\n+        for (int i = 0; i < NR_OF_INTS; ++i) {\n+            Integer result = mapper.readValue(jp, Integer.class);\n+            assertEquals(Integer.valueOf(i), result);\n+        }\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestStatics.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Tests for checking that static methods are not recognized as accessors\n+ * for properties\n+ */\n+public class TestStatics\n+    extends BaseMapTest\n+{\n+    static class Bean\n+    {\n+        int _x;\n+\n+        public static void setX(int value) { throw new Error(\"Should NOT call static method\"); }\n+        \n+        @JsonProperty(\"x\") public void assignX(int x) { _x = x; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleIgnore() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // should not care about static setter...\n+        Bean result = m.readValue(\"{ \\\"x\\\":3}\", Bean.class);\n+        assertEquals(3, result._x);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestTimestampDeserialization.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestTimestampDeserialization\n+    extends BaseMapTest\n+{\n+    // As for TestDateDeserialization except we don't need to test date conversion routines, so\n+    // just check we pick up timestamp class\n+\n+    public void testTimestampUtil() throws Exception\n+    {\n+        long now = 123456789L;\n+        java.sql.Timestamp value = new java.sql.Timestamp(now);\n+\n+        // First from long\n+        assertEquals(value, new ObjectMapper().readValue(\"\"+now, java.sql.Timestamp.class));\n+\n+        String dateStr = serializeTimestampAsString(value);\n+        java.sql.Timestamp result = new ObjectMapper().readValue(\"\\\"\"+dateStr+\"\\\"\", java.sql.Timestamp.class);\n+\n+        assertEquals(\"Date: expect \"+value+\" (\"+value.getTime()+\"), got \"+result+\" (\"+result.getTime()+\")\", value.getTime(), result.getTime());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private String serializeTimestampAsString(java.sql.Timestamp value)\n+    {\n+        /* Then from String. This is bit tricky, since JDK does not really\n+         * suggest a 'standard' format. So let's try using something...\n+         */\n+        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");\n+        return df.format(value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestUnknownProperties.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for checking handling of unknown properties\n+ */\n+public class TestUnknownProperties\n+    extends BaseMapTest\n+{\n+    final static String JSON_UNKNOWN_FIELD = \"{ \\\"a\\\" : 1, \\\"foo\\\" : [ 1, 2, 3], \\\"b\\\" : -1 }\";\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    final static class TestBean\n+    {\n+        String _unknown;\n+\n+        int _a, _b;\n+\n+        public TestBean() { }\n+\n+        public void setA(int a) { _a = a; }\n+        public void setB(int b) { _b = b; }\n+\n+        public void markUnknown(String unk) { _unknown = unk; }\n+    }\n+\n+    /**\n+     * Simple {@link DeserializationProblemHandler} sub-class that\n+     * just marks unknown property/ies when encountered, along with\n+     * Json value of the property.\n+     */\n+    final static class MyHandler\n+        extends DeserializationProblemHandler\n+    {\n+        @Override\n+        public boolean handleUnknownProperty(DeserializationContext ctxt, JsonDeserializer<?> deserializer,\n+                                             Object bean, String propertyName)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonParser jp = ctxt.getParser();\n+            // very simple, just to verify that we do see correct token type\n+            ((TestBean) bean).markUnknown(propertyName+\":\"+jp.getCurrentToken().toString());\n+            // Yup, we are good to go; must skip whatever value we'd have:\n+            jp.skipChildren();\n+            return true;\n+        }\n+    }\n+\n+    @JsonIgnoreProperties({\"b\", \"c\"})\n+    static class IgnoreSome\n+    {\n+        public int a, b;\n+        private String c, d;\n+\n+        public IgnoreSome() { }\n+\n+        public String c() { return c; }\n+        public void setC(String value) { c = value; }\n+        public String d() { return d; }\n+        public void setD(String value) { d = value; }\n+    }\n+\n+    @JsonIgnoreProperties(ignoreUnknown=true)\n+    static class IgnoreUnknown {\n+        public int a;\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    @JsonIgnoreProperties({\"a\", \"d\"})\n+    static class IgnoreMap extends HashMap<String,Object> { }\n+\n+    static class ImplicitIgnores {\n+        @JsonIgnore public int a;\n+        @JsonIgnore public void setB(int b) { }\n+        public int c;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * By default we should just get an exception if an unknown property\n+     * is encountered\n+     */\n+    public void testUnknownHandlingDefault()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class);\n+        } catch (JsonMappingException jex) {\n+            verifyException(jex, \"Unrecognized field \\\"foo\\\"\");\n+        }\n+    }\n+\n+    /**\n+     * Test that verifies that it is possible to ignore unknown properties using\n+     * {@link DeserializationProblemHandler}.\n+     */\n+    public void testUnknownHandlingIgnoreWithHandler()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.getDeserializationConfig().clearHandlers();\n+        mapper.getDeserializationConfig().addHandler(new MyHandler());\n+        TestBean result = mapper.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class);\n+        assertNotNull(result);\n+        assertEquals(1, result._a);\n+        assertEquals(-1, result._b);\n+        assertEquals(\"foo:START_ARRAY\", result._unknown);\n+    }\n+\n+    /**\n+     * Test for checking that it is also possible to simply suppress\n+     * error reporting for unknown properties.\n+     *\n+     * @since 1.2\n+     */\n+    public void testUnknownHandlingIgnoreWithFeature()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+        TestBean result = null;\n+        try {\n+            result = mapper.readValue(new StringReader(JSON_UNKNOWN_FIELD), TestBean.class);\n+        } catch (JsonMappingException jex) {\n+            fail(\"Did not expect a problem, got: \"+jex.getMessage());\n+        }\n+        assertNotNull(result);\n+        assertEquals(1, result._a);\n+        assertNull(result._unknown);\n+        assertEquals(-1, result._b);\n+    }\n+\n+    /// @since 1.4\n+    public void testWithClassIgnore()\n+        throws Exception\n+    {\n+        IgnoreSome result = new ObjectMapper().readValue(\"{ \\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":\\\"x\\\",\\\"d\\\":\\\"y\\\"}\",\n+                IgnoreSome.class);\n+        // first: should deserialize 2 of properties normally\n+        assertEquals(1, result.a);\n+        assertEquals(\"y\", result.d());\n+        // and not take other 2\n+        assertEquals(0, result.b);\n+        assertNull(result.c());\n+    }\n+\n+    /// @since 1.4\n+    public void testClassIgnoreWithMap() throws Exception\n+    {\n+        // Let's actually use incompatible types for \"a\" and \"d\"; should not matter when ignored\n+        IgnoreMap result = new ObjectMapper().readValue\n+            (\"{ \\\"a\\\":[ 1],\\n\"\n+                +\"\\\"b\\\":2,\\n\"\n+                +\"\\\"c\\\": \\\"x\\\",\\n\"\n+                +\"\\\"d\\\":false }\", IgnoreMap.class);\n+        assertEquals(2, result.size());\n+        Object ob = result.get(\"b\");\n+        assertEquals(Integer.class, ob.getClass());\n+        assertEquals(Integer.valueOf(2), ob);\n+        assertEquals(\"x\", result.get(\"c\"));\n+        assertFalse(result.containsKey(\"a\"));\n+        assertFalse(result.containsKey(\"d\"));\n+    }\n+\n+    /// @since 1.4\n+    public void testClassWithIgnoreUnknown() throws Exception\n+    {\n+        IgnoreUnknown result = new ObjectMapper().readValue\n+            (\"{\\\"b\\\":3,\\\"c\\\":[1,2],\\\"x\\\":{ },\\\"a\\\":-3}\", IgnoreUnknown.class);\n+        assertEquals(-3, result.a);\n+    }\n+\n+    /**\n+     * Test that verifies that use of {@link JsonIgnore} will add implicit\n+     * skipping of matching properties.\n+     */\n+    public void testClassWithUnknownAndIgnore() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // should be ok: \"a\" and \"b\" ignored, \"c\" mapped:\n+        ImplicitIgnores result = m.readValue\n+            (\"{\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":3 }\", ImplicitIgnores.class);\n+        assertEquals(3, result.c);\n+\n+        // but \"d\" is not defined, so should still error\n+        try {\n+            m.readValue(\"{\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":3,\\\"d\\\":4 }\", ImplicitIgnores.class);            \n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Unrecognized field \\\"d\\\"\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestValueAnnotations.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * This unit test suite tests use of \"value\" Annotations;\n+ * annotations that define actual type (Class) to use for\n+ * deserialization.\n+ */\n+public class TestValueAnnotations\n+    extends BaseTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated root classes for @JsonDeserialize#as\n+    /**********************************************************\n+     */\n+\n+    @JsonDeserialize(using=RootStringDeserializer.class)\n+    interface RootString {\n+        public String contents();\n+    }\n+\n+    static class RootStringImpl implements RootString\n+    {\n+        final String _contents;\n+\n+        public RootStringImpl(String x) { _contents = x; }\n+\n+        @Override\n+        public String contents() { return _contents; }\n+        public String contents2() { return _contents; }\n+    }\n+\n+    @JsonDeserialize(as=RootInterfaceImpl.class)\n+    interface RootInterface {\n+        public String getA();\n+    }\n+\n+    static class RootInterfaceImpl implements RootInterface {\n+        public String a;\n+\n+        public RootInterfaceImpl() { }\n+\n+        @Override\n+        public String getA() { return a; }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    @JsonDeserialize(contentAs=RootStringImpl.class)\n+    static class RootMap extends HashMap<String,RootStringImpl> { }\n+\n+    @SuppressWarnings(\"serial\")\n+    @JsonDeserialize(contentAs=RootStringImpl.class)\n+    static class RootList extends LinkedList<RootStringImpl> { }\n+\n+    static class RootStringDeserializer\n+        extends StdDeserializer<RootString>\n+    {\n+        public RootStringDeserializer() { super(RootString.class); }\n+\n+        @Override\n+        public RootString deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            if (jp.getCurrentToken() == JsonToken.VALUE_STRING) {\n+                return new RootStringImpl(jp.getText());\n+            }\n+            throw ctxt.mappingException(_valueClass);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes for @JsonDeserialize#as\n+    /**********************************************************\n+     */\n+\n+    /* Class for testing valid {@link JsonDeserialize} annotation\n+     * with 'as' parameter to define concrete class to deserialize to\n+     */\n+    final static class CollectionHolder\n+    {\n+        Collection<String> _strings;\n+\n+        /* Default for 'Collection' would probably be ArrayList or so;\n+         * let's try to make it a TreeSet instead.\n+         */\n+        @JsonDeserialize(as=TreeSet.class)\n+        public void setStrings(Collection<String> s)\n+        {\n+            _strings = s;\n+        }\n+    }\n+\n+    /* Another class for testing valid {@link JsonDeserialize} annotation\n+     * with 'as' parameter to define concrete class to deserialize to\n+     */\n+    final static class MapHolder\n+    {\n+        // Let's also coerce numbers into Strings here\n+        Map<String,String> _data;\n+\n+        /* Default for 'Collection' would be HashMap,\n+         * let's try to make it a TreeMap instead.\n+         */\n+        @JsonDeserialize(as=TreeMap.class)\n+        public void setStrings(Map<String,String> s)\n+        {\n+            _data = s;\n+        }\n+    }\n+\n+    /* Another class for testing valid {@link JsonDeserialize} annotation\n+     * with 'as' parameter, but with array\n+     */\n+    final static class ArrayHolder\n+    {\n+        String[] _strings;\n+\n+        @JsonDeserialize(as=String[].class)\n+        public void setStrings(Object[] o)\n+        {\n+            // should be passed instances of proper type, as per annotation\n+            _strings = (String[]) o;\n+        }\n+    }\n+\n+    /* Another class for testing broken {@link JsonDeserialize} annotation\n+     * with 'as' parameter; one with incompatible type\n+     */\n+    final static class BrokenCollectionHolder\n+    {\n+        @JsonDeserialize(as=String.class) // not assignable to Collection\n+        public void setStrings(Collection<String> s) { }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes for @JsonDeserialize.keyAs\n+    /**********************************************************\n+     */\n+\n+    final static class StringWrapper\n+    {\n+        final String _string;\n+\n+        public StringWrapper(String s) { _string = s; }\n+    }\n+\n+    final static class MapKeyHolder\n+    {\n+        Map<Object, String> _map;\n+\n+        @JsonDeserialize(keyAs=StringWrapper.class)\n+        public void setMap(Map<Object,String> m)\n+        {\n+            // type should be ok, but no need to cast here (won't matter)\n+            _map = m;\n+        }\n+    }\n+\n+    final static class BrokenMapKeyHolder\n+    {\n+        // Invalid: Integer not a sub-class of String\n+        @JsonDeserialize(keyAs=Integer.class)\n+            public void setStrings(Map<String,String> m) { }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes for @JsonDeserialize#contentAs\n+    /**********************************************************\n+     */\n+\n+    final static class ListContentHolder\n+    {\n+        List<?> _list;\n+\n+        @JsonDeserialize(contentAs=StringWrapper.class)\n+        public void setList(List<?> l) {\n+            _list = l;\n+        }\n+    }\n+\n+    final static class InvalidContentClass\n+    {\n+        /* Such annotation not allowed, since it makes no sense;\n+         * non-container classes have no contents to annotate (but\n+         * note that it is possible to first use @JsonDesiarialize.as\n+         * to mark Object as, say, a List, and THEN use\n+         * @JsonDeserialize.contentAs!)\n+         */\n+        @JsonDeserialize(contentAs=String.class)\n+            public void setValue(Object x) { }\n+    }\n+\n+    final static class ArrayContentHolder\n+    {\n+        Object[] _data;\n+\n+        @JsonDeserialize(contentAs=Long.class)\n+        public void setData(Object[] o)\n+        { // should have proper type, but no need to coerce here\n+            _data = o;\n+        }\n+    }\n+\n+    final static class MapContentHolder\n+    {\n+        Map<Object,Object> _map;\n+\n+        @JsonDeserialize(contentAs=Integer.class)\n+        public void setMap(Map<Object,Object> m)\n+        {\n+            _map = m;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods for @JsonDeserialize#as\n+    /**********************************************************\n+     */\n+\n+    public void testOverrideClassValid() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        CollectionHolder result = m.readValue\n+            (\"{ \\\"strings\\\" : [ \\\"test\\\" ] }\", CollectionHolder.class);\n+\n+        Collection<String> strs = result._strings;\n+        assertEquals(1, strs.size());\n+        assertEquals(TreeSet.class, strs.getClass());\n+        assertEquals(\"test\", strs.iterator().next());\n+    }\n+\n+    public void testOverrideMapValid() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // note: expecting conversion from number to String, as well\n+        MapHolder result = m.readValue\n+            (\"{ \\\"strings\\\" :  { \\\"a\\\" : 3 } }\", MapHolder.class);\n+\n+        Map<String,String> strs = result._data;\n+        assertEquals(1, strs.size());\n+        assertEquals(TreeMap.class, strs.getClass());\n+        String value = strs.get(\"a\");\n+        assertEquals(\"3\", value);\n+    }\n+\n+    public void testOverrideArrayClass() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        ArrayHolder result = m.readValue\n+            (\"{ \\\"strings\\\" : [ \\\"test\\\" ] }\", ArrayHolder.class);\n+\n+        String[] strs = result._strings;\n+        assertEquals(1, strs.length);\n+        assertEquals(String[].class, strs.getClass());\n+        assertEquals(\"test\", strs[0]);\n+    }\n+\n+    public void testOverrideClassInvalid() throws Exception\n+    {\n+        // should fail due to incompatible Annotation\n+        try {\n+            BrokenCollectionHolder result = new ObjectMapper().readValue\n+                (\"{ \\\"strings\\\" : [ ] }\", BrokenCollectionHolder.class);\n+            fail(\"Expected a failure, but got results: \"+result);\n+        } catch (JsonMappingException jme) {\n+            verifyException(jme, \"is not assignable to\");\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods for @JsonDeserialize#as used for root values\n+    /**********************************************************\n+     */\n+\n+    public void testRootInterfaceAs() throws Exception\n+    {\n+        RootInterface value = new ObjectMapper().readValue(\"{\\\"a\\\":\\\"abc\\\" }\", RootInterface.class);\n+        assertTrue(value instanceof RootInterfaceImpl);\n+        assertEquals(\"abc\", value.getA());\n+    }\n+\n+    public void testRootInterfaceUsing() throws Exception\n+    {\n+        RootString value = new ObjectMapper().readValue(\"\\\"xxx\\\"\", RootString.class);\n+        assertTrue(value instanceof RootString);\n+        assertEquals(\"xxx\", value.contents());\n+    }\n+\n+    public void testRootListAs() throws Exception\n+    {\n+        RootMap value = new ObjectMapper().readValue(\"{\\\"a\\\":\\\"b\\\"}\", RootMap.class);\n+        assertEquals(1, value.size());\n+        Object v2 = value.get(\"a\");\n+        assertEquals(RootStringImpl.class, v2.getClass());\n+        assertEquals(\"b\", ((RootString) v2).contents());\n+    }\n+\n+    public void testRootMapAs() throws Exception\n+    {\n+        RootList value = new ObjectMapper().readValue(\"[ \\\"c\\\" ]\", RootList.class);\n+        assertEquals(1, value.size());\n+        Object v2 = value.get(0);\n+        assertEquals(RootStringImpl.class, v2.getClass());\n+        assertEquals(\"c\", ((RootString) v2).contents());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods for @JsonDeserialize#keyAs\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic void testOverrideKeyClassValid() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        MapKeyHolder result = m.readValue(\"{ \\\"map\\\" : { \\\"xxx\\\" : \\\"yyy\\\" } }\", MapKeyHolder.class);\n+        Map<StringWrapper, String> map = (Map<StringWrapper,String>)(Map<?,?>)result._map;\n+        assertEquals(1, map.size());\n+        Map.Entry<StringWrapper, String> en = map.entrySet().iterator().next();\n+\n+        StringWrapper key = en.getKey();\n+        assertEquals(StringWrapper.class, key.getClass());\n+        assertEquals(\"xxx\", key._string);\n+        assertEquals(\"yyy\", en.getValue());\n+    }\n+\n+    public void testOverrideKeyClassInvalid() throws Exception\n+    {\n+        // should fail due to incompatible Annotation\n+        try {\n+            BrokenMapKeyHolder result = new ObjectMapper().readValue\n+                (\"{ \\\"123\\\" : \\\"xxx\\\" }\", BrokenMapKeyHolder.class);\n+            fail(\"Expected a failure, but got results: \"+result);\n+        } catch (JsonMappingException jme) {\n+            verifyException(jme, \"is not assignable to\");\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods for @JsonDeserialize#contentAs\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic void testOverrideContentClassValid() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        ListContentHolder result = m.readValue(\"{ \\\"list\\\" : [ \\\"abc\\\" ] }\", ListContentHolder.class);\n+        List<StringWrapper> list = (List<StringWrapper>)result._list;\n+        assertEquals(1, list.size());\n+        Object value = list.get(0);\n+        assertEquals(StringWrapper.class, value.getClass());\n+        assertEquals(\"abc\", ((StringWrapper) value)._string);\n+    }\n+\n+    public void testOverrideArrayContents() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        ArrayContentHolder result = m.readValue(\"{ \\\"data\\\" : [ 1, 2, 3 ] }\",\n+                                                ArrayContentHolder.class);\n+        Object[] data = result._data;\n+        assertEquals(3, data.length);\n+        assertEquals(Long[].class, data.getClass());\n+        assertEquals(1L, data[0]);\n+        assertEquals(2L, data[1]);\n+        assertEquals(3L, data[2]);\n+    }\n+\n+    public void testOverrideMapContents() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        MapContentHolder result = m.readValue(\"{ \\\"map\\\" : { \\\"a\\\" : 9 } }\",\n+                                                MapContentHolder.class);\n+        Map<Object,Object> map = result._map;\n+        assertEquals(1, map.size());\n+        Object ob = map.values().iterator().next();\n+        assertEquals(Integer.class, ob.getClass());\n+        assertEquals(Integer.valueOf(9), ob);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ext/TestCoreXMLTypes.java\n+package com.fasterxml.jackson.databind.ext;\n+\n+import javax.xml.datatype.*;\n+import javax.xml.namespace.QName;\n+\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ext.CoreXMLDeserializers;\n+\n+/**\n+ * Core XML types (javax.xml) are considered \"external\" (or more precisely \"optional\")\n+ * since some Java(-like) platforms do not include them: specifically, Google AppEngine\n+ * and Android seem to skimp on their inclusion. As such, they are dynamically loaded\n+ * only as needed, and need bit special handling.\n+ * \n+ * @author tatu\n+ */\n+public class TestCoreXMLTypes\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Serializer tests\n+    /**********************************************************\n+     */\n+\n+    public void testQNameSer() throws Exception\n+    {\n+        QName qn = new QName(\"http://abc\", \"tag\", \"prefix\");\n+        assertEquals(quote(qn.toString()), serializeAsString(qn));\n+    }\n+\n+    public void testDurationSer() throws Exception\n+    {\n+        DatatypeFactory dtf = DatatypeFactory.newInstance();\n+        // arbitrary value\n+        Duration dur = dtf.newDurationDayTime(false, 15, 19, 58, 1);\n+        assertEquals(quote(dur.toString()), serializeAsString(dur));\n+    }\n+\n+    public void testXMLGregorianCalendarSerAndDeser() throws Exception\n+    {\n+        DatatypeFactory dtf = DatatypeFactory.newInstance();\n+        XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar\n+            (1974, 10, 10, 18, 15, 17, 123, 0);\n+        /* Due to [JACKSON-308], 1.6 will use configurable Date serialization;\n+         * and it defaults to using timestamp. So let's try couple of combinations.\n+         */\n+        ObjectMapper mapper = new ObjectMapper();\n+        long timestamp = cal.toGregorianCalendar().getTimeInMillis();\n+        String numStr = String.valueOf(timestamp);\n+        assertEquals(numStr, mapper.writeValueAsString(cal));\n+\n+        // [JACKSON-403] Needs to come back ok as well:\n+        XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class);\n+        assertNotNull(calOut);\n+        assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis());\n+        \n+        // and then textual variant\n+        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);\n+        // this is ALMOST same as default for XMLGregorianCalendar... just need to unify Z/+0000\n+        String exp = cal.toXMLFormat();\n+        String act = mapper.writeValueAsString(cal);\n+        act = act.substring(1, act.length() - 1); // remove quotes\n+        exp = removeZ(exp);\n+        act = removeZ(act);\n+        assertEquals(exp, act);\n+    }\n+\n+    private String removeZ(String dateStr) {\n+        if (dateStr.endsWith(\"Z\")) {\n+            return dateStr.substring(0, dateStr.length()-1);\n+        }\n+        if (dateStr.endsWith(\"+0000\")) {\n+            return dateStr.substring(0, dateStr.length()-5);\n+        }\n+        return dateStr;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Deserializer tests\n+    /**********************************************************\n+     */\n+    \n+    // First things first: must be able to load the deserializers...\n+    public void testDeserializerLoading()\n+    {\n+        new CoreXMLDeserializers.DurationDeserializer();\n+        new CoreXMLDeserializers.GregorianCalendarDeserializer();\n+        new CoreXMLDeserializers.QNameDeserializer();\n+    }\n+\n+    public void testQNameDeser() throws Exception\n+    {\n+        QName qn = new QName(\"http://abc\", \"tag\", \"prefix\");\n+        String qstr = qn.toString();\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"Should deserialize to equal QName (exp serialization: '\"+qstr+\"')\",\n+                     qn, mapper.readValue(quote(qstr), QName.class));\n+    }\n+\n+    public void testCalendarDeser() throws Exception\n+    {\n+        DatatypeFactory dtf = DatatypeFactory.newInstance();\n+        XMLGregorianCalendar cal = dtf.newXMLGregorianCalendar\n+            (1974, 10, 10, 18, 15, 17, 123, 0);\n+        String exp = cal.toXMLFormat();\n+        assertEquals(\"Should deserialize to equal XMLGregorianCalendar ('\"+exp+\"')\", cal,\n+                new ObjectMapper().readValue(quote(exp), XMLGregorianCalendar.class));\n+    }\n+\n+    public void testDurationDeser() throws Exception\n+    {\n+        DatatypeFactory dtf = DatatypeFactory.newInstance();\n+        // arbitrary value, like... say, 27d5h15m59s\n+        Duration dur = dtf.newDurationDayTime(true, 27, 5, 15, 59);\n+        String exp = dur.toString();\n+        assertEquals(\"Should deserialize to equal Duration ('\"+exp+\"')\", dur,\n+                new ObjectMapper().readValue(quote(exp), Duration.class));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ext/TestDOM.java\n+package com.fasterxml.jackson.databind.ext;\n+\n+import java.io.StringReader;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+\n+import org.xml.sax.InputSource;\n+import org.w3c.dom.*;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestDOM extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    final static String SIMPLE_XML =\n+        \"<root attr='3'><leaf>Rock &amp; Roll!</leaf><?proc instr?></root>\";\n+    final static String SIMPLE_XML_NS =\n+        \"<root ns:attr='abc' xmlns:ns='http://foo' />\";\n+    \n+    public void testSerializeSimpleNonNS() throws Exception\n+    {\n+        // Let's just parse first, easiest\n+        Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse\n+            (new InputSource(new StringReader(SIMPLE_XML)));\n+        assertNotNull(doc);\n+        ObjectMapper mapper = new ObjectMapper();\n+        // need to strip xml declaration, if any\n+        String outputRaw = mapper.writeValueAsString(doc);\n+        // And re-parse as String, since JSON has quotes...\n+        String output = mapper.readValue(outputRaw, String.class);\n+        /* ... and finally, normalize to (close to) canonical XML\n+         * output (single vs double quotes, xml declaration etc)\n+         */\n+        assertEquals(SIMPLE_XML, normalizeOutput(output));\n+    }\n+\n+    public void testDeserializeNonNS() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        for (int i = 0; i < 2; ++i) {\n+            Document doc;\n+\n+            if (i == 0) {\n+                // First, as Document:\n+                doc = mapper.readValue(quote(SIMPLE_XML), Document.class);\n+            } else {\n+                // and then as plain Node (no difference)\n+                Node node = mapper.readValue(quote(SIMPLE_XML), Node.class);\n+                doc = (Document) node;\n+            }\n+            Element root = doc.getDocumentElement();\n+            assertNotNull(root);\n+            // non-ns, simple...\n+            assertEquals(\"root\", root.getTagName());\n+            assertEquals(\"3\", root.getAttribute(\"attr\"));\n+            assertEquals(1, root.getAttributes().getLength());\n+            NodeList nodes = root.getChildNodes();\n+            assertEquals(2, nodes.getLength());\n+            Element leaf = (Element) nodes.item(0);\n+            assertEquals(\"leaf\", leaf.getTagName());\n+            assertEquals(0, leaf.getAttributes().getLength());\n+            //\"<root attr='3'><leaf>Rock &amp; Roll!</leaf><?proc instr?></root>\";\n+            ProcessingInstruction pi = (ProcessingInstruction) nodes.item(1);\n+            assertEquals(\"proc\", pi.getTarget());\n+            assertEquals(\"instr\", pi.getData());\n+        }\n+    }\n+    \n+    public void testDeserializeNS() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Document doc = mapper.readValue(quote(SIMPLE_XML_NS), Document.class);\n+        Element root = doc.getDocumentElement();\n+        assertNotNull(root);\n+        assertEquals(\"root\", root.getTagName());\n+        // Not sure if it ought to be \"\" or null...\n+        String uri = root.getNamespaceURI();\n+        assertTrue((uri == null) || \"\".equals(uri));\n+        // no child nodes:\n+        assertEquals(0, root.getChildNodes().getLength());\n+        // DOM is weird, includes ns decls as attributes...\n+        assertEquals(2, root.getAttributes().getLength());\n+        assertEquals(\"abc\", root.getAttributeNS(\"http://foo\", \"attr\"));\n+    }\n+\n+    /*\n+     **********************************************************\n+     * Helper methods\n+     **********************************************************\n+     */\n+\n+    protected static String normalizeOutput(String output)\n+    {\n+        // XML declaration to get rid of?\n+        output = output.trim();\n+        if (output.startsWith(\"<?xml\")) {\n+            // can find closing '>' of xml decl...\n+            output = output.substring(output.indexOf('>')+1).trim();\n+        }\n+        // And replace double quotes with single-quotes...\n+        return output.replace('\"', '\\'');\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ext/TestJodaTime.java\n+package com.fasterxml.jackson.databind.ext;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+\n+import org.joda.time.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for verifying limited interoperability for Joda time.\n+ * Basic support is added for handling {@link DateTime}; more can be\n+ * added over time if and when requested.\n+ */\n+public class TestJodaTime\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Tests for DateTime (and closely related)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * First: let's ensure that serialization does not fail\n+     * with an error (see [JACKSON-157]).\n+     */\n+    public void testSerialization() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // let's use epoch time (Jan 1, 1970, UTC)\n+        DateTime dt = new DateTime(0L, DateTimeZone.UTC);\n+        // by default, dates use timestamp, so:\n+        assertEquals(\"0\", serializeAsString(m, dt));\n+\n+        // but if re-configured, as regular ISO-8601 string\n+        m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);\n+        assertEquals(quote(\"1970-01-01T00:00:00.000Z\"), serializeAsString(m, dt));\n+    }\n+\n+    /**\n+     * Ok, then: should be able to convert from JSON String or Number,\n+     * with standard deserializer we provide.\n+     */\n+    public void testDeserFromNumber() throws IOException\n+    {\n+        Calendar cal = new GregorianCalendar(TimeZone.getTimeZone(\"GMT\"));\n+        // use some arbitrary but non-default time point (after 1.1.1970)\n+        cal.set(Calendar.YEAR, 1972);\n+        long timepoint = cal.getTime().getTime();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        // Ok, first: using JSON number (milliseconds since epoch)\n+        DateTime dt = mapper.readValue(String.valueOf(timepoint), DateTime.class);\n+        assertEquals(timepoint, dt.getMillis());\n+\n+        // And then ISO-8601 String\n+        dt = mapper.readValue(quote(\"1972-12-28T12:00:01.000+0000\"), DateTime.class);\n+        assertEquals(\"1972-12-28T12:00:01.000Z\", dt.toString());\n+    }\n+\n+    // @since 1.6    \n+    public void testDeserReadableDateTime() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ReadableDateTime date = mapper.readValue(quote(\"1972-12-28T12:00:01.000+0000\"), ReadableDateTime.class);\n+        assertNotNull(date);\n+        assertEquals(\"1972-12-28T12:00:01.000Z\", date.toString());\n+\n+        // since 1.6.1, for [JACKSON-360]\n+        assertNull(mapper.readValue(quote(\"\"), ReadableDateTime.class));\n+    }\n+\n+    // @since 1.6    \n+    public void testDeserReadableInstant() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ReadableInstant date = mapper.readValue(quote(\"1972-12-28T12:00:01.000+0000\"), ReadableInstant.class);\n+        assertNotNull(date);\n+        assertEquals(\"1972-12-28T12:00:01.000Z\", date.toString());\n+\n+        // since 1.6.1, for [JACKSON-360]\n+        assertNull(mapper.readValue(quote(\"\"), ReadableInstant.class));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Tests for DateMidnight type\n+    /**********************************************************\n+     */\n+    \n+    // @since 1.5\n+    public void testDateMidnightSer() throws IOException\n+    {\n+        DateMidnight date = new DateMidnight(2001, 5, 25);\n+        ObjectMapper mapper = new ObjectMapper();\n+        // default format is that of JSON array...\n+        assertEquals(\"[2001,5,25]\", mapper.writeValueAsString(date));\n+        // but we can force it to be a String as well (note: here we assume this is\n+        // dynamically changeable)\n+        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);        \n+        assertEquals(quote(\"2001-05-25\"), mapper.writeValueAsString(date));\n+    }\n+\n+    // @since 1.5\n+    public void testDateMidnightDeser() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // couple of acceptable formats, so:\n+        DateMidnight date = mapper.readValue(\"[2001,5,25]\", DateMidnight.class);\n+        assertEquals(2001, date.getYear());\n+        assertEquals(5, date.getMonthOfYear());\n+        assertEquals(25, date.getDayOfMonth());\n+\n+        DateMidnight date2 = mapper.readValue(quote(\"2005-07-13\"), DateMidnight.class);\n+        assertEquals(2005, date2.getYear());\n+        assertEquals(7, date2.getMonthOfYear());\n+        assertEquals(13, date2.getDayOfMonth());\n+\n+        // since 1.6.1, for [JACKSON-360]\n+        assertNull(mapper.readValue(quote(\"\"), DateMidnight.class));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Tests for LocalDate type\n+    /**********************************************************\n+     */\n+    \n+    // @since 1.5\n+    public void testLocalDateSer() throws IOException\n+    {\n+        LocalDate date = new LocalDate(2001, 5, 25);\n+        ObjectMapper mapper = new ObjectMapper();\n+        // default format is that of JSON array...\n+        assertEquals(\"[2001,5,25]\", mapper.writeValueAsString(date));\n+        // but we can force it to be a String as well (note: here we assume this is\n+        // dynamically changeable)\n+        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);        \n+        assertEquals(quote(\"2001-05-25\"), mapper.writeValueAsString(date));\n+    }\n+\n+    // @since 1.5\n+    public void testLocalDateDeser() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // couple of acceptable formats, so:\n+        LocalDate date = mapper.readValue(\"[2001,5,25]\", LocalDate.class);\n+        assertEquals(2001, date.getYear());\n+        assertEquals(5, date.getMonthOfYear());\n+        assertEquals(25, date.getDayOfMonth());\n+\n+        LocalDate date2 = mapper.readValue(quote(\"2005-07-13\"), LocalDate.class);\n+        assertEquals(2005, date2.getYear());\n+        assertEquals(7, date2.getMonthOfYear());\n+        assertEquals(13, date2.getDayOfMonth());\n+\n+        // since 1.6.1, for [JACKSON-360]\n+        assertNull(mapper.readValue(quote(\"\"), LocalDate.class));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests for LocalDateTime type\n+    /**********************************************************\n+     */\n+    \n+    // @since 1.5\n+    public void testLocalDateTimeSer() throws IOException\n+    {\n+        LocalDateTime date = new LocalDateTime(2001, 5, 25,\n+                10, 15, 30, 37);\n+        ObjectMapper mapper = new ObjectMapper();\n+        // default format is that of JSON array...\n+        assertEquals(\"[2001,5,25,10,15,30,37]\", mapper.writeValueAsString(date));\n+        // but we can force it to be a String as well (note: here we assume this is\n+        // dynamically changeable)\n+        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);        \n+        assertEquals(quote(\"2001-05-25T10:15:30.037\"), mapper.writeValueAsString(date));\n+    }\n+\n+    // @since 1.5\n+    public void testLocalDateTimeDeser() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // couple of acceptable formats again:\n+        LocalDateTime date = mapper.readValue(\"[2001,5,25,10,15,30,37]\", LocalDateTime.class);\n+        assertEquals(2001, date.getYear());\n+        assertEquals(5, date.getMonthOfYear());\n+        assertEquals(25, date.getDayOfMonth());\n+\n+        assertEquals(10, date.getHourOfDay());\n+        assertEquals(15, date.getMinuteOfHour());\n+        assertEquals(30, date.getSecondOfMinute());\n+        assertEquals(37, date.getMillisOfSecond());\n+\n+        LocalDateTime date2 = mapper.readValue(quote(\"2007-06-30T08:34:09.001\"), LocalDateTime.class);\n+        assertEquals(2007, date2.getYear());\n+        assertEquals(6, date2.getMonthOfYear());\n+        assertEquals(30, date2.getDayOfMonth());\n+\n+        assertEquals(8, date2.getHourOfDay());\n+        assertEquals(34, date2.getMinuteOfHour());\n+        assertEquals(9, date2.getSecondOfMinute());\n+        assertEquals(1, date2.getMillisOfSecond());\n+\n+        // since 1.6.1, for [JACKSON-360]\n+        assertNull(mapper.readValue(quote(\"\"), LocalDateTime.class));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests for Period type\n+    /**********************************************************\n+     */\n+\n+    // @since 1.9.2\n+    public void testPeriodSer() throws IOException\n+    {\n+        Period in = new Period(1, 2, 3, 4);\n+        String json = new ObjectMapper().writeValueAsString(in);\n+        assertEquals(quote(\"PT1H2M3.004S\"), json);\n+    }\n+\n+    // @since 1.9.2\n+    public void testPeriodDeser() throws IOException\n+    {\n+        Period out = new ObjectMapper().readValue(quote(\"PT1H2M3.004S\"), Period.class);\n+        assertEquals(1, out.getHours());\n+        assertEquals(2, out.getMinutes());\n+        assertEquals(3, out.getSeconds());\n+        assertEquals(4, out.getMillis());\n+\n+        // also, should work as number:\n+        String json = String.valueOf(1000 * out.toStandardSeconds().getSeconds());\n+        out = new ObjectMapper().readValue(json, Period.class);\n+        assertEquals(1, out.getHours());\n+        assertEquals(2, out.getMinutes());\n+        assertEquals(3, out.getSeconds());\n+        // but millis are actually truncated...\n+        assertEquals(0, out.getMillis());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestCglibUsage.java\n+package com.fasterxml.jackson.databind.interop;\n+\n+\n+import java.io.*;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import net.sf.cglib.proxy.Enhancer;\n+import net.sf.cglib.proxy.MethodInterceptor;\n+import net.sf.cglib.proxy.MethodProxy;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * Unit test for checking that we can serialize CGLib generated proxies.\n+ */\n+public class TestCglibUsage\n+    extends BaseTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    interface BeanInterface {\n+        public int getX();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleProxied() throws Exception\n+    {\n+        Enhancer enh = new Enhancer();\n+        enh.setInterfaces(new Class[] { BeanInterface.class });\n+        enh.setCallback(new MethodInterceptor() {\n+            @Override\n+                public Object intercept(Object obj, Method method,\n+                                        Object[] args, MethodProxy proxy)\n+                    throws Throwable\n+                {\n+                    if (\"getX\".equals(method.getName ())) {\n+                        return Integer.valueOf(13);\n+                    }\n+                    return proxy.invokeSuper(obj, args);\n+                }\n+            });\n+        BeanInterface bean = (BeanInterface) enh.create();\n+        ObjectMapper mapper = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(mapper, bean);\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(13), result.get(\"x\"));\n+    }\n+\n+    /*\n+    //////////////////////////////////////////////\n+    // Helper methods\n+    //////////////////////////////////////////////\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+\tprivate Map<String,Object> writeAndMap(ObjectMapper m, Object value)\n+        throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        m.writeValue(sw, value);\n+        return (Map<String,Object>) m.readValue(sw.toString(), Object.class);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestGoogleCollections.java\n+package com.fasterxml.jackson.databind.interop;\n+\n+import com.fasterxml.jackson.annotation.JsonValue;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+import com.google.common.collect.*;\n+\n+/**\n+ * NOTE: this is bogus test currently (as of Jackson 1.6) -- not support\n+ * has been added!\n+ * \n+ * @author tatu\n+ */\n+public class TestGoogleCollections\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    static class MapBean\n+    {\n+        // both class and method left non-public to verify that access is overridden\n+        @JsonValue\n+        protected ImmutableMap<String,Integer> toMap()\n+        {\n+            return new ImmutableMap.Builder<String,Integer>().put(\"a\", 1).build();\n+        }\n+    }\n+\n+    // !!! NOTE: does not test that it produces anything useful...\n+    public void testTrivialMultiMapSerialize() throws Exception\n+    {\n+        Multimap<String,String> map = HashMultimap.create();\n+        map.put(\"a\", \"1\");\n+        String json = new ObjectMapper().writeValueAsString(map);\n+        assertNotNull(json);\n+\n+        /*\n+        assertEquals(\"{\\\"a\\\":[\\\"1\\\"]}\", json);\n+        */\n+    }\n+\n+    public void testMapWithJsonValue() throws Exception\n+    {\n+        assertEquals(\"{\\\"a\\\":1}\", new ObjectMapper().writeValueAsString(new MapBean()));\n+    }\n+\n+    /*// fails similarly, for same reason\n+    static class StdMapBean\n+    {\n+        @JsonValue\n+        public Map<String,String> toMap()\n+        {\n+            HashMap<String,String> map = new HashMap<String,String>();\n+            map.put(\"a\", \"1\");\n+            return map;\n+        }\n+    }\n+    \n+    public void testMapWithJsonValue2() throws Exception\n+    {\n+        assertEquals(\"{\\\"a\\\":1}\", new ObjectMapper().writeValueAsString(new StdMapBean()));\n+    }\n+    */\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestGroovyBeans.java\n+package com.fasterxml.jackson.databind.interop;\n+\n+import java.util.*;\n+\n+import groovy.lang.GroovyClassLoader;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Basic tests to see that simple Groovy beans can be serialized\n+ * and deserialized\n+ */\n+public class TestGroovyBeans\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    final static String SIMPLE_POGO = \n+        \"public class GBean {\\n\"\n+        +\"long id = 3;\\n\"\n+        +\"String name = \\\"whome\\\";\\n\"\n+        +\"}\";\n+\n+\n+    public void testSimpleSerialization() throws Exception\n+    {\n+        Object ob = newGroovyObject(SIMPLE_POGO);\n+        Map<String,Object> result = writeAndMap(ob);\n+        assertEquals(2, result.size());\n+        assertEquals(\"whome\", result.get(\"name\"));\n+        /* 26-Nov-2009, tatu: Strange... Groovy seems to decide\n+         *    'long' means 'int'... Oh well.\n+         */\n+        Object num = result.get(\"id\");\n+        assertNotNull(num);\n+        assertTrue(num instanceof Number);\n+        assertEquals(3, ((Number) num).intValue());\n+    }\n+\n+    public void testSimpleDeserialization() throws Exception\n+    {\n+        Class<?> cls = defineGroovyClass(SIMPLE_POGO);\n+        // First: deserialize from data\n+        Object pogo = new ObjectMapper().readValue(\"{\\\"id\\\":9,\\\"name\\\":\\\"Bob\\\"}\", cls);\n+        assertNotNull(pogo);\n+        /* Hmmh. Could try to access using Reflection, or by defining\n+         * a Java interface it implements. Or, maybe simplest, just\n+         * re-serialize and see what we got.\n+         */\n+        Map<String,Object> result = writeAndMap(pogo);\n+        assertEquals(2, result.size());\n+        assertEquals(\"Bob\", result.get(\"name\"));\n+        // as per earlier, we just get a number...\n+        Object num = result.get(\"id\");\n+        assertNotNull(num);\n+        assertTrue(num instanceof Number);\n+        assertEquals(9, ((Number) num).intValue());\n+    }\n+\n+    /*\n+    *************************************************\n+    * Helper methods\n+    *************************************************\n+    */\n+\n+    protected Class<?> defineGroovyClass(String src) throws Exception\n+    {\n+        return new GroovyClassLoader(getClass().getClassLoader()).parseClass(src);\n+\n+    }\n+\n+    protected Object newGroovyObject(String src) throws Exception\n+    {\n+        Class<?> cls = defineGroovyClass(src);\n+        return cls.newInstance();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestHibernate.java\n+package com.fasterxml.jackson.databind.interop;\n+\n+\n+import java.io.*;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import org.hibernate.repackage.cglib.proxy.Enhancer;\n+import org.hibernate.repackage.cglib.proxy.MethodInterceptor;\n+import org.hibernate.repackage.cglib.proxy.MethodProxy;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * Basic tests covering Hibernate-compatibility features.\n+ */\n+public class TestHibernate\n+    extends BaseTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    interface BeanInterfaceHib {\n+        public int getX();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests\n+    /**********************************************************\n+     */\n+\n+    /*\n+     * Unit test to test [JACKSON-177]\n+     */\n+    public void testHibernateCglib() throws Exception\n+    {\n+        /* 03-Sep-2010, tatu: This often fails form Eclipse (on some platforms like Mac OS X),\n+         *   so let's only run it from Ant/CLI\n+         */\n+        if (!runsFromAnt()) {\n+            return;\n+        }\n+\n+        Enhancer enh = new Enhancer();\n+        enh.setInterfaces(new Class[] { BeanInterfaceHib.class });\n+        enh.setCallback(new MethodInterceptor() {\n+            @Override\n+            public Object intercept(Object obj, Method method,\n+                    Object[] args, MethodProxy proxy)\n+                            throws Throwable\n+            {\n+                if (\"getX\".equals(method.getName ())) {\n+                    return Integer.valueOf(13);\n+                }\n+                return proxy.invokeSuper(obj, args);\n+            }\n+        });\n+        BeanInterfaceHib bean = (BeanInterfaceHib) enh.create();\n+        ObjectMapper mapper = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(mapper, bean);\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(13), result.get(\"x\"));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Map<String,Object> writeAndMap(ObjectMapper m, Object value)\n+        throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        m.writeValue(sw, value);\n+        return (Map<String,Object>) m.readValue(sw.toString(), Object.class);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestAnnotationMerging.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Tests to verify that annotations are shared and merged between members\n+ * of a property (getter and setter and so on)\n+ */\n+public class TestAnnotationMerging extends BaseMapTest\n+{\n+    static class Wrapper\n+    {\n+        protected Object value;\n+\n+        public Wrapper() { }\n+        public Wrapper(Object o) { value = o; }\n+        \n+        @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)\n+        public Object getValue() { return value; }\n+\n+        public void setValue(Object o) { value = o; }\n+    }\n+\n+    static class SharedName {\n+        @JsonProperty(\"x\")\n+        protected int value;\n+\n+        public SharedName(int v) { value = v; }\n+        \n+        public int getValue() { return value; }\n+    }\n+\n+    static class SharedName2\n+    {\n+        @JsonProperty(\"x\")\n+        public int getValue() { return 1; }\n+        public void setValue(int x) { }\n+    }\n+\n+    // Testing to ensure that ctor param and getter can \"share\" @JsonTypeInfo stuff\n+    static class TypeWrapper\n+    {\n+        protected Object value;\n+\n+        @JsonCreator\n+        public TypeWrapper(\n+                @JsonProperty(\"value\")\n+                @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS) Object o) {\n+            value = o;\n+        }\n+        public Object getValue() { return value; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testSharedNames() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"{\\\"x\\\":6}\", mapper.writeValueAsString(new SharedName(6)));\n+    }\n+\n+    public void testSharedNamesFromGetterToSetter() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new SharedName2());\n+        assertEquals(\"{\\\"x\\\":1}\", json);\n+        SharedName2 result = mapper.readValue(json, SharedName2.class);\n+        assertNotNull(result);\n+    }\n+    \n+    public void testSharedTypeInfo() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new Wrapper(13L));\n+        Wrapper result = mapper.readValue(json, Wrapper.class);\n+        assertEquals(Long.class, result.value.getClass());\n+    }\n+\n+    public void testSharedTypeInfoWithCtor() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new TypeWrapper(13L));\n+        TypeWrapper result = mapper.readValue(json, TypeWrapper.class);\n+        assertEquals(Long.class, result.value.getClass());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestJacksonAnnotationIntrospector.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.util.*;\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.*;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * @author Ryan Heaton\n+ */\n+public class TestJacksonAnnotationIntrospector\n+    extends BaseMapTest\n+{\n+    public static enum EnumExample {\n+        VALUE1;\n+    }\n+\n+    public static class JacksonExample\n+    {\n+        private String attributeProperty;\n+        private String elementProperty;\n+        private List<String> wrappedElementProperty;\n+        private EnumExample enumProperty;\n+        private QName qname;\n+\n+        @JsonSerialize(using=QNameSerializer.class)\n+        public QName getQname()\n+        {\n+            return qname;\n+        }\n+\n+        @JsonDeserialize(using=QNameDeserializer.class)\n+        public void setQname(QName qname)\n+        {\n+            this.qname = qname;\n+        }\n+\n+        @JsonProperty(\"myattribute\")\n+        public String getAttributeProperty()\n+        {\n+            return attributeProperty;\n+        }\n+\n+        @JsonProperty(\"myattribute\")\n+        public void setAttributeProperty(String attributeProperty)\n+        {\n+            this.attributeProperty = attributeProperty;\n+        }\n+\n+        @JsonProperty(\"myelement\")\n+        public String getElementProperty()\n+        {\n+            return elementProperty;\n+        }\n+\n+        @JsonProperty(\"myelement\")\n+        public void setElementProperty(String elementProperty)\n+        {\n+            this.elementProperty = elementProperty;\n+        }\n+\n+        @JsonProperty(\"mywrapped\")\n+        public List<String> getWrappedElementProperty()\n+        {\n+            return wrappedElementProperty;\n+        }\n+\n+        @JsonProperty(\"mywrapped\")\n+        public void setWrappedElementProperty(List<String> wrappedElementProperty)\n+        {\n+            this.wrappedElementProperty = wrappedElementProperty;\n+        }\n+\n+        public EnumExample getEnumProperty()\n+        {\n+            return enumProperty;\n+        }\n+\n+        public void setEnumProperty(EnumExample enumProperty)\n+        {\n+            this.enumProperty = enumProperty;\n+        }\n+    }\n+\n+    public static class QNameSerializer extends JsonSerializer<QName> {\n+\n+        @Override\n+        public void serialize(QName value, JsonGenerator jgen, SerializerProvider provider)\n+                throws IOException, JsonProcessingException\n+        {\n+            jgen.writeString(value.toString());\n+        }\n+    }\n+\n+\n+    public static class QNameDeserializer extends StdDeserializer<QName>\n+    {\n+        public QNameDeserializer() { super(QName.class); }\n+        @Override\n+        public QName deserialize(JsonParser jp, DeserializationContext ctxt)\n+                throws IOException, JsonProcessingException\n+        {\n+            return QName.valueOf(jp.readValueAs(String.class));\n+        }\n+    }\n+\n+    public static class DummyBuilder extends StdTypeResolverBuilder\n+    //<DummyBuilder>\n+    {\n+    }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS)\n+    @JsonTypeResolver(DummyBuilder.class)\n+    static class TypeResolverBean { }\n+\n+    // @since 1.7\n+    @JsonIgnoreType\n+    static class IgnoredType { }\n+\n+    static class IgnoredSubType extends IgnoredType { }\n+\n+    // Test to ensure we can override enum settings\n+    static class LcEnumIntrospector extends JacksonAnnotationIntrospector\n+    {\n+        @Override\n+        public String findEnumValue(Enum<?> value)\n+        {\n+            return value.name().toLowerCase();\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * tests getting serializer/deserializer instances.\n+     */\n+    public void testSerializeDeserializeWithJaxbAnnotations() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enable(SerializationConfig.Feature.INDENT_OUTPUT);\n+        JacksonExample ex = new JacksonExample();\n+        QName qname = new QName(\"urn:hi\", \"hello\");\n+        ex.setQname(qname);\n+        ex.setAttributeProperty(\"attributeValue\");\n+        ex.setElementProperty(\"elementValue\");\n+        ex.setWrappedElementProperty(Arrays.asList(\"wrappedElementValue\"));\n+        ex.setEnumProperty(EnumExample.VALUE1);\n+        StringWriter writer = new StringWriter();\n+        mapper.writeValue(writer, ex);\n+        writer.flush();\n+        writer.close();\n+\n+        String json = writer.toString();\n+        JacksonExample readEx = mapper.readValue(json, JacksonExample.class);\n+\n+        assertEquals(ex.qname, readEx.qname);\n+        assertEquals(ex.attributeProperty, readEx.attributeProperty);\n+        assertEquals(ex.elementProperty, readEx.elementProperty);\n+        assertEquals(ex.wrappedElementProperty, readEx.wrappedElementProperty);\n+        assertEquals(ex.enumProperty, readEx.enumProperty);\n+    }\n+\n+    public void testJsonTypeResolver() throws Exception\n+    {\n+        JacksonAnnotationIntrospector ai = new JacksonAnnotationIntrospector();\n+        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(TypeResolverBean.class, ai, null);\n+        JavaType baseType = TypeFactory.defaultInstance().constructType(TypeResolverBean.class);\n+        ObjectMapper mapper = new ObjectMapper();\n+        TypeResolverBuilder<?> rb = ai.findTypeResolver(mapper.getDeserializationConfig(), ac, baseType);\n+        assertNotNull(rb);\n+        assertSame(DummyBuilder.class, rb.getClass());\n+    }    \n+\n+    /**\n+     * Tests to ensure that {@link JsonIgnoreType} is detected as expected\n+     * by the standard introspector.\n+     * \n+     * @since 1.7\n+     */\n+    public void testIgnoredType() throws Exception\n+    {\n+        JacksonAnnotationIntrospector ai = new JacksonAnnotationIntrospector();\n+        AnnotatedClass ac = AnnotatedClass.construct(IgnoredType.class, ai, null);\n+        assertEquals(Boolean.TRUE, ai.isIgnorableType(ac));\n+\n+        // also, should inherit as expected\n+        ac = AnnotatedClass.construct(IgnoredSubType.class, ai, null);\n+        assertEquals(Boolean.TRUE, ai.isIgnorableType(ac));\n+    }\n+\n+    public void testEnumHandling() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setAnnotationIntrospector(new LcEnumIntrospector());\n+        assertEquals(\"\\\"value1\\\"\", mapper.writeValueAsString(EnumExample.VALUE1));\n+        EnumExample result = mapper.readValue(quote(\"value1\"), EnumExample.class);\n+        assertEquals(EnumExample.VALUE1, result);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestPOJOPropertiesCollector.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+\n+/**\n+ * @since 1.9\n+ */\n+public class TestPOJOPropertiesCollector\n+    extends BaseMapTest\n+{\n+    static class Simple {\n+        public int value;\n+        \n+        @JsonProperty(\"value\")\n+        public void valueSetter(int v) { value = v; }\n+\n+        @JsonProperty(\"value\")\n+        public int getFoobar() { return value; }\n+    }\n+\n+    static class SimpleFieldDeser\n+    {\n+        @JsonDeserialize String[] values;\n+    }\n+    \n+    static class SimpleGetterVisibility {\n+        public int getA() { return 0; }\n+        protected int getB() { return 1; }\n+        @SuppressWarnings(\"unused\")\n+        private int getC() { return 2; }\n+    }\n+    \n+    // Class for testing 'shared ignore'\n+    static class Empty {\n+        public int value;\n+        \n+        public void setValue(int v) { value = v; }\n+\n+        @JsonIgnore\n+        public int getValue() { return value; }\n+    }\n+\n+    static class IgnoredSetter {\n+        @JsonProperty\n+        public int value;\n+        \n+        @JsonIgnore\n+        public void setValue(int v) { value = v; }\n+\n+        public int getValue() { return value; }\n+    }\n+\n+    static class ImplicitIgnores {\n+        @JsonIgnore public int a;\n+        @JsonIgnore public void setB(int b) { }\n+        public int c;\n+    }\n+    \n+    // Should find just one setter for \"y\", due to partial ignore\n+    static class IgnoredRenamedSetter {\n+        @JsonIgnore public void setY(int value) { }\n+        @JsonProperty(\"y\") void foobar(int value) { }\n+    }\n+    \n+    // should produce a single property, \"x\"\n+    static class RenamedProperties {\n+        @JsonProperty(\"x\")\n+        public int value;\n+        \n+        public void setValue(int v) { value = v; }\n+\n+        public int getX() { return value; }\n+    }\n+\n+    static class RenamedProperties2\n+    {\n+        @JsonProperty(\"renamed\")\n+        public int getValue() { return 1; }\n+        public void setValue(int x) { }\n+    }\n+    \n+    // Testing that we can \"merge\" properties with renaming\n+    static class MergedProperties {\n+        public int x;\n+        \n+        @JsonProperty(\"x\")\n+        public void setFoobar(int v) { x = v; }\n+    }\n+\n+    // Testing that property order is obeyed, even for deserialization purposes\n+    @JsonPropertyOrder({\"a\", \"b\", \"c\", \"d\"})\n+    static class SortedProperties\n+    {\n+        public int b;\n+        public int c;\n+        \n+        public void setD(int value) { }\n+        public void setA(int value) { }\n+    }\n+\n+    // [JACKSON-700]: test property type detection, selection\n+    static class TypeTestBean\n+    {\n+        protected Long value;\n+\n+        @JsonCreator\n+        public TypeTestBean(@JsonProperty(\"value\") String value) { }\n+\n+        // If you remove this method, the test will pass\n+        public Integer getValue() { return 0; }\n+    }\n+\n+    static class Jackson703\n+    {\n+        private List<FoodOrgLocation> location = new ArrayList<FoodOrgLocation>();\n+\n+        {\n+            location.add(new FoodOrgLocation());\n+        }\n+\n+        public List<FoodOrgLocation> getLocation() { return location; } \n+    }\n+    \n+    static class FoodOrgLocation\n+    {\n+        protected Long id;\n+        public String name;\n+        protected Location location;\n+\n+        public FoodOrgLocation() {\n+            location = new Location();\n+        }\n+\n+        public FoodOrgLocation(final Location foodOrg) { }\n+                \n+        public FoodOrgLocation(final Long id, final String name, final Location location) { }\n+\n+        public Location getLocation() { return location; }\n+    }\n+\n+    static class Location {\n+        public BigDecimal lattitude;\n+        public BigDecimal longitude;\n+\n+        public Location() { }\n+\n+        public Location(final BigDecimal lattitude, final BigDecimal longitude) { }\n+    }\n+\n+    class Issue701Bean { // important: non-static!\n+        private int i;\n+\n+        // annotation does not matter -- just need one on the last argument\n+        public Issue701Bean(@JsonProperty int i) { this.i = i; }\n+\n+        public int getX() { return i; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimple()\n+    {\n+        POJOPropertiesCollector coll = collector(Simple.class, true);\n+        Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n+        assertEquals(1, props.size());\n+        POJOPropertyBuilder prop = props.get(\"value\");\n+        assertNotNull(prop);\n+        assertTrue(prop.hasSetter());\n+        assertTrue(prop.hasGetter());\n+        assertTrue(prop.hasField());\n+    }\n+\n+    public void testSimpleFieldVisibility()\n+    {\n+        // false -> deserialization\n+        POJOPropertiesCollector coll = collector(SimpleFieldDeser.class, false);\n+        Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n+        assertEquals(1, props.size());\n+        POJOPropertyBuilder prop = props.get(\"values\");\n+        assertNotNull(prop);\n+        assertFalse(prop.hasSetter());\n+        assertFalse(prop.hasGetter());\n+        assertTrue(prop.hasField());\n+    }\n+\n+    public void testSimpleGetterVisibility()\n+    {\n+        POJOPropertiesCollector coll = collector(SimpleGetterVisibility.class, true);\n+        Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n+        assertEquals(1, props.size());\n+        POJOPropertyBuilder prop = props.get(\"a\");\n+        assertNotNull(prop);\n+        assertFalse(prop.hasSetter());\n+        assertTrue(prop.hasGetter());\n+        assertFalse(prop.hasField());\n+    }\n+    \n+    // Unit test for verifying that a single @JsonIgnore can remove the\n+    // whole property, unless explicit property marker exists\n+    public void testEmpty()\n+    {\n+        POJOPropertiesCollector coll = collector(Empty.class, true);\n+        Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n+        assertEquals(0, props.size());\n+    }\n+\n+    // Unit test for verifying handling of 'partial' @JsonIgnore; that is,\n+    // if there is at least one explicit annotation to indicate property,\n+    // only parts that are ignored are, well, ignored\n+    public void testPartialIgnore()\n+    {\n+        POJOPropertiesCollector coll = collector(IgnoredSetter.class, true);\n+        Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n+        assertEquals(1, props.size());\n+        POJOPropertyBuilder prop = props.get(\"value\");\n+        assertNotNull(prop);\n+        assertFalse(prop.hasSetter());\n+        assertTrue(prop.hasGetter());\n+        assertTrue(prop.hasField());\n+    }\n+\n+    public void testSimpleRenamed()\n+    {\n+        POJOPropertiesCollector coll = collector(RenamedProperties.class, true);\n+        Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n+        assertEquals(1, props.size());\n+        POJOPropertyBuilder prop = props.get(\"x\");\n+        assertNotNull(prop);\n+        assertTrue(prop.hasSetter());\n+        assertTrue(prop.hasGetter());\n+        assertTrue(prop.hasField());\n+    }\n+\n+    public void testSimpleRenamed2()\n+    {\n+        POJOPropertiesCollector coll = collector(RenamedProperties2.class, true);\n+        Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n+        assertEquals(1, props.size());\n+        POJOPropertyBuilder prop = props.get(\"renamed\");\n+        assertNotNull(prop);\n+        assertTrue(prop.hasSetter());\n+        assertTrue(prop.hasGetter());\n+        assertFalse(prop.hasField());\n+    }\n+\n+    public void testMergeWithRename()\n+    {\n+        POJOPropertiesCollector coll = collector(MergedProperties.class, true);\n+        Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n+        assertEquals(1, props.size());\n+        POJOPropertyBuilder prop = props.get(\"x\");\n+        assertNotNull(prop);\n+        assertTrue(prop.hasSetter());\n+        assertFalse(prop.hasGetter());\n+        assertTrue(prop.hasField());\n+    }\n+    \n+    public void testSimpleIgnoreAndRename()\n+    {\n+        POJOPropertiesCollector coll = collector(IgnoredRenamedSetter.class, true);\n+        Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n+        assertEquals(1, props.size());\n+        POJOPropertyBuilder prop = props.get(\"y\");\n+        assertNotNull(prop);\n+        assertTrue(prop.hasSetter());\n+        assertFalse(prop.hasGetter());\n+        assertFalse(prop.hasField());\n+    }\n+\n+    public void testGlobalVisibilityForGetters()\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        POJOPropertiesCollector coll = collector(m, SimpleGetterVisibility.class, true);\n+        // should be 1, expect that we disabled getter auto-detection, so\n+        Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n+        assertEquals(0, props.size());\n+    }\n+\n+    public void testCollectionOfIgnored()\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        POJOPropertiesCollector coll = collector(m, ImplicitIgnores.class, false);\n+        // should be 1, due to ignorals\n+        Map<String, POJOPropertyBuilder> props = coll.getPropertyMap();\n+        assertEquals(1, props.size());\n+        // but also have 2 ignored properties\n+        Collection<String> ign = coll.getIgnoredPropertyNames();\n+        assertEquals(2, ign.size());\n+        assertTrue(ign.contains(\"a\"));\n+        assertTrue(ign.contains(\"b\"));\n+    }\n+\n+    public void testSimpleOrderingForDeserialization()\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        POJOPropertiesCollector coll = collector(m, SortedProperties.class, false);\n+        List<BeanPropertyDefinition> props = coll.getProperties();\n+        assertEquals(4, props.size());\n+        assertEquals(\"a\", props.get(0).getName());\n+        assertEquals(\"b\", props.get(1).getName());\n+        assertEquals(\"c\", props.get(2).getName());\n+        assertEquals(\"d\", props.get(3).getName());\n+    }\n+\n+    public void testSimpleWithType()\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // first for serialization; should base choice on getter\n+        POJOPropertiesCollector coll = collector(mapper, TypeTestBean.class, true);\n+        List<BeanPropertyDefinition> props = coll.getProperties();\n+        assertEquals(1, props.size());\n+        assertEquals(\"value\", props.get(0).getName());\n+        AnnotatedMember m = props.get(0).getAccessor();\n+        assertTrue(m instanceof AnnotatedMethod);\n+        assertEquals(Integer.class, m.getRawType());\n+\n+        // then for deserialization; prefer ctor param\n+        coll = collector(mapper, TypeTestBean.class, false);\n+        props = coll.getProperties();\n+        assertEquals(1, props.size());\n+        assertEquals(\"value\", props.get(0).getName());\n+        m = props.get(0).getMutator();\n+        assertEquals(AnnotatedParameter.class, m.getClass());\n+        assertEquals(String.class, m.getRawType());\n+    }\n+\n+    // for [JACKSON-701]\n+    public void testInnerClassWithAnnotationsInCreator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        BasicBeanDescription beanDesc;\n+        // first with serialization\n+        beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(Issue701Bean.class));\n+        assertNotNull(beanDesc);\n+        // then with deserialization\n+        beanDesc = mapper.getDeserializationConfig().introspect(mapper.constructType(Issue701Bean.class));\n+        assertNotNull(beanDesc);\n+    }\n+\n+    public void testJackson703() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(SerializationConfig.Feature.USE_ANNOTATIONS, false);\n+        BasicBeanDescription beanDesc = mapper.getSerializationConfig().introspect(mapper.constructType(Jackson703.class));\n+        assertNotNull(beanDesc);\n+\n+        Jackson703 bean = new Jackson703();\n+        String json = mapper.writeValueAsString(bean);\n+        assertNotNull(json);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected POJOPropertiesCollector collector(Class<?> cls, boolean forSerialization)\n+    {\n+        return collector(new ObjectMapper(), cls, forSerialization);\n+    }\n+\n+    protected POJOPropertiesCollector collector(ObjectMapper mapper,\n+            Class<?> cls, boolean forSerialization)\n+    {\n+        BasicClassIntrospector bci = new BasicClassIntrospector();\n+        // no real difference between serialization, deserialization, at least here\n+        if (forSerialization) {\n+            return bci.collectProperties(mapper.getSerializationConfig(),\n+                    mapper.constructType(cls), null, true);\n+        }\n+        return bci.collectProperties(mapper.getDeserializationConfig(),\n+                mapper.constructType(cls), null, false);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n+package com.fasterxml.jackson.databind.jsonschema;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+/**\n+ * @author Ryan Heaton\n+ */\n+public class TestGenerateJsonSchema\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    public static class SimpleBean\n+    {\n+        private int property1;\n+        private String property2;\n+        private String[] property3;\n+        private Collection<Float> property4;\n+\n+        public int getProperty1()\n+        {\n+            return property1;\n+        }\n+\n+        public void setProperty1(int property1)\n+        {\n+            this.property1 = property1;\n+        }\n+\n+        public String getProperty2()\n+        {\n+            return property2;\n+        }\n+\n+        public void setProperty2(String property2)\n+        {\n+            this.property2 = property2;\n+        }\n+\n+        public String[] getProperty3()\n+        {\n+            return property3;\n+        }\n+\n+        public void setProperty3(String[] property3)\n+        {\n+            this.property3 = property3;\n+        }\n+\n+        public Collection<Float> getProperty4()\n+        {\n+            return property4;\n+        }\n+\n+        public void setProperty4(Collection<Float> property4)\n+        {\n+            this.property4 = property4;\n+        }\n+    }\n+\n+    public class TrivialBean {\n+        public String name;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * tests generating json-schema stuff.\n+     */\n+    public void testGeneratingJsonSchema()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonSchema jsonSchema = mapper.generateJsonSchema(SimpleBean.class);\n+        assertNotNull(jsonSchema);\n+\n+        // test basic equality, and that equals() handles null, other obs\n+        assertTrue(jsonSchema.equals(jsonSchema));\n+        assertFalse(jsonSchema.equals(null));\n+        assertFalse(jsonSchema.equals(\"foo\"));\n+\n+        // other basic things\n+        assertNotNull(jsonSchema.toString());\n+        assertNotNull(JsonSchema.getDefaultSchemaNode());\n+\n+\tObjectNode root = jsonSchema.getSchemaNode();\n+        assertEquals(\"object\", root.get(\"type\").asText());\n+        assertEquals(false, root.path(\"required\").getBooleanValue());\n+        JsonNode propertiesSchema = root.get(\"properties\");\n+        assertNotNull(propertiesSchema);\n+        JsonNode property1Schema = propertiesSchema.get(\"property1\");\n+        assertNotNull(property1Schema);\n+        assertEquals(\"integer\", property1Schema.get(\"type\").asText());\n+        assertEquals(false, property1Schema.path(\"required\").getBooleanValue());\n+        JsonNode property2Schema = propertiesSchema.get(\"property2\");\n+        assertNotNull(property2Schema);\n+        assertEquals(\"string\", property2Schema.get(\"type\").asText());\n+        assertEquals(false, property2Schema.path(\"required\").getBooleanValue());\n+        JsonNode property3Schema = propertiesSchema.get(\"property3\");\n+        assertNotNull(property3Schema);\n+        assertEquals(\"array\", property3Schema.get(\"type\").asText());\n+        assertEquals(false, property3Schema.path(\"required\").getBooleanValue());\n+        assertEquals(\"string\", property3Schema.get(\"items\").get(\"type\").asText());\n+        JsonNode property4Schema = propertiesSchema.get(\"property4\");\n+        assertNotNull(property4Schema);\n+        assertEquals(\"array\", property4Schema.get(\"type\").asText());\n+        assertEquals(false, property4Schema.path(\"required\").getBooleanValue());\n+        assertEquals(\"number\", property4Schema.get(\"items\").get(\"type\").asText());\n+    }\n+\n+    /**\n+     * Additional unit test for verifying that schema object itself\n+     * can be properly serialized\n+     *\n+     * @since 1.2\n+     */\n+    public void testSchemaSerialization()\n+            throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonSchema jsonSchema = mapper.generateJsonSchema(SimpleBean.class);\n+\tMap<String,Object> result = writeAndMap(mapper, jsonSchema);\n+\tassertNotNull(result);\n+\t// no need to check out full structure, just basics...\n+\tassertEquals(\"object\", result.get(\"type\"));\n+\t// only add 'required' if it is true...\n+\tassertNull(result.get(\"required\"));\n+\tassertNotNull(result.get(\"properties\"));\n+    }\n+\n+    public void testInvalidCall()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // not ok to pass null\n+        try {\n+            mapper.generateJsonSchema(null);\n+        } catch (IllegalArgumentException iae) { }\n+    }\n+\n+    /**\n+     * Test for [JACKSON-454]\n+     */\n+    public void testThatObjectsHaveNoItems() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonSchema jsonSchema = mapper.generateJsonSchema(TrivialBean.class);\n+        String json = jsonSchema.toString().replaceAll(\"\\\"\", \"'\");\n+        // can we count on ordering being stable? I think this is true with current ObjectNode impl\n+        // as perh [JACKSON-563]; 'required' is only included if true\n+        assertEquals(\"{'type':'object','properties':{'name':{'type':'string'}}}\",\n+                json);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestReadJsonSchema.java\n+package com.fasterxml.jackson.databind.jsonschema;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+\n+/**\n+ * Trivial test to ensure {@link JsonSchema} can be also deserialized\n+ */\n+public class TestReadJsonSchema\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    enum SchemaEnum { YES, NO; }\n+\n+    static class Schemable {\n+        public String name;\n+        public char[] nameBuffer;\n+\n+        // We'll include tons of stuff, just to force generation of schema\n+        public boolean[] states;\n+        public byte[] binaryData;\n+        public short[] shorts;\n+        public int[] ints;\n+        public long[] longs;\n+\n+        public float[] floats;\n+        public double[] doubles;\n+\n+        public Object[] objects;\n+        public JsonSerializable someSerializable;\n+\n+        public Iterable<Object> iterableOhYeahBaby;\n+\n+        public List<String> extra;\n+        public ArrayList<String> extra2;\n+        public Iterator<String[]> extra3;\n+\n+        public Map<String,Double> sizes;\n+        public EnumMap<SchemaEnum,List<String>> whatever;\n+\n+        SchemaEnum testEnum;\n+        public EnumSet<SchemaEnum> testEnums;\n+    }\n+\n+    /**\n+     * Verifies that a simple schema that is serialized can be\n+     * deserialized back to equal schema instance\n+     */\n+    public void testDeserializeSimple() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonSchema schema = mapper.generateJsonSchema(Schemable.class);\n+        assertNotNull(schema);\n+\n+        String schemaStr = mapper.writeValueAsString(schema);\n+        assertNotNull(schemaStr);\n+        JsonSchema result = mapper.readValue(schemaStr, JsonSchema.class);\n+        assertEquals(\"Trying to read from '\"+schemaStr+\"'\", schema, result);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractTypeNames.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;\n+\n+/**\n+ * Unit tests for checking how combination of interfaces, implementation\n+ * classes are handled, with respect to type names.\n+ * \n+ * @since 1.8\n+ */\n+public class TestAbstractTypeNames  extends BaseMapTest\n+{\n+    @JsonTypeName(\"Employee\")\n+    public interface Employee extends User {\n+        public abstract String getEmployer();\n+    }\n+\n+    @JsonTypeInfo(use=Id.NAME, include=As.PROPERTY, property=\"userType\")\n+    @JsonTypeName(\"User\")\n+    @JsonSubTypes({ @JsonSubTypes.Type(value=Employee.class,name=\"Employee\") })\n+    public interface User {\n+            public abstract String getName();\n+            public abstract List<User> getFriends();\n+    }\n+\n+    @JsonTypeName(\"Employee\")\n+    static class DefaultEmployee extends DefaultUser implements Employee\n+    {\n+        private String _employer;\n+\n+        @JsonCreator\n+        public DefaultEmployee(@JsonProperty(\"name\") String name,\n+                @JsonProperty(\"friends\") List<User> friends,\n+                @JsonProperty(\"employer\") String employer) {\n+            super(name, friends);\n+            _employer = employer;\n+        }\n+\n+        @Override\n+        public String getEmployer() {\n+            return _employer;\n+        }\n+    }\n+\n+    @JsonTypeInfo(use=Id.NAME, include=As.PROPERTY, property=\"userType\")\n+    @JsonTypeName(\"User\")\n+    @JsonSubTypes({ @JsonSubTypes.Type(value=DefaultEmployee.class,name=\"Employee\") })\n+    static class DefaultUser implements User\n+    {\n+        private String _name;\n+        private List<User> _friends;\n+\n+        @JsonCreator\n+        public DefaultUser(@JsonProperty(\"name\") String name,\n+                @JsonProperty(\"friends\") List<User> friends)\n+        {\n+            super();\n+            _name = name;\n+            _friends = friends;\n+        }\n+\n+        @Override public String getName() {\n+            return _name;\n+        }\n+\n+        @Override public List<User> getFriends() {\n+            return _friends;\n+        }\n+    }\n+\n+    static class BaseValue {\n+        public int value = 42;\n+\n+        public int getValue() { return value; }\n+    }\n+\n+    final static class BeanWithAnon {\n+        public BaseValue bean = new BaseValue() {\n+            @Override\n+            public String toString() { return \"sub!\"; }\n+        };\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    // Testing [JACKSON-498], partial fix\n+    public void testEmptyCollection() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(SerializationConfig.Feature.INDENT_OUTPUT, true);\n+        List<User>friends = new ArrayList<User>();\n+        friends.add(new DefaultUser(\"Joe Hildebrandt\", null));\n+        friends.add(new DefaultEmployee(\"Richard Nasr\",null,\"MDA\"));\n+\n+        User user = new DefaultEmployee(\"John Vanspronssen\", friends, \"MDA\");\n+        String json = mapper.writeValueAsString(user);\n+\n+        /* 24-Feb-2011, tatu: For now let's simply require registration of\n+         *   concrete subtypes; can't think of a way to avoid that for now\n+         */\n+        mapper = new ObjectMapper();\n+        mapper.registerSubtypes(DefaultEmployee.class);\n+        mapper.registerSubtypes(DefaultUser.class);\n+        \n+        User result = mapper.readValue(json, User.class);\n+        assertNotNull(result);\n+        assertEquals(DefaultEmployee.class, result.getClass());\n+\n+        friends = result.getFriends();\n+        assertEquals(2, friends.size());\n+        assertEquals(DefaultUser.class, friends.get(0).getClass());\n+        assertEquals(DefaultEmployee.class, friends.get(1).getClass());\n+    }\n+    \n+    // [JACKSON-584]: change anonymous non-static inner type into static type:\n+    public void testInnerClassWithType() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(DefaultTyping.NON_FINAL);\n+        String json = mapper.writeValueAsString(new BeanWithAnon());\n+        BeanWithAnon result = mapper.readValue(json, BeanWithAnon.class);\n+        assertEquals(BeanWithAnon.class, result.getClass());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.annotation.JsonTypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+public class TestCustomTypeIdResolver extends BaseMapTest\n+{\n+    @JsonTypeInfo(use=Id.CUSTOM, include=As.WRAPPER_OBJECT)\n+    @JsonTypeIdResolver(CustomResolver.class)\n+    static class CustomBean {\n+        public int x;\n+        \n+        public CustomBean() { }\n+        public CustomBean(int x) { this.x = x; }\n+    }\n+    \n+    static class CustomResolver implements TypeIdResolver\n+    {\n+        static List<JavaType> initTypes;\n+\n+        public CustomResolver() { }\n+        \n+        @Override\n+        public Id getMechanism() {\n+            return Id.CUSTOM;\n+        }\n+\n+        @Override\n+        public String idFromValue(Object value)\n+        {\n+            if (value.getClass() == CustomBean.class) {\n+                return \"*\";\n+            }\n+            return \"unknown\";\n+        }\n+\n+        @Override\n+        public String idFromValueAndType(Object value, Class<?> type) {\n+            return idFromValue(value);\n+        }\n+        \n+        @Override\n+        public void init(JavaType baseType) {\n+            if (initTypes != null) {\n+                initTypes.add(baseType);\n+            }\n+        }\n+\n+        @Override\n+        public JavaType typeFromId(String id)\n+        {\n+            if (\"*\".equals(id)) {\n+                return TypeFactory.defaultInstance().constructType(CustomBean.class);\n+            }\n+            return null;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    // for [JACKSON-359]\n+    public void testCustomTypeIdResolver() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        List<JavaType> types = new ArrayList<JavaType>();\n+        CustomResolver.initTypes = types;\n+        String json = m.writeValueAsString(new CustomBean[] { new CustomBean(28) });\n+        assertEquals(\"[{\\\"*\\\":{\\\"x\\\":28}}]\", json);\n+        assertEquals(1, types.size());\n+        assertEquals(CustomBean.class, types.get(0).getRawClass());\n+\n+        types = new ArrayList<JavaType>();\n+        CustomResolver.initTypes = types;\n+        CustomBean[] result = m.readValue(json, CustomBean[].class);\n+        assertNotNull(result);\n+        assertEquals(1, result.length);\n+        assertEquals(28, result[0].x);\n+        assertEquals(1, types.size());\n+        assertEquals(CustomBean.class, types.get(0).getRawClass());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForArrays.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+\n+import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;\n+\n+public class TestDefaultForArrays extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static class ArrayBean {\n+        public Object[] values;\n+\n+        public ArrayBean() { this(null); }\n+        public ArrayBean(Object[] v) { values = v; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Simple unit test for verifying that we get String array\n+     * back, even though declared type is Object array\n+     */\n+    public void testArrayTypingSimple() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS);\n+        ArrayBean bean = new ArrayBean(new String[0]);\n+        String json = m.writeValueAsString(bean);\n+        ArrayBean result = m.readValue(json, ArrayBean.class);\n+        assertNotNull(result.values);\n+        assertEquals(String[].class, result.values.getClass());\n+    }\n+\n+    // And let's try it with deeper array as well\n+    public void testArrayTypingNested() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping(DefaultTyping.NON_CONCRETE_AND_ARRAYS);\n+        ArrayBean bean = new ArrayBean(new String[0][0]);\n+        String json = m.writeValueAsString(bean);\n+        ArrayBean result = m.readValue(json, ArrayBean.class);\n+        assertNotNull(result.values);\n+        assertEquals(String[][].class, result.values.getClass());\n+    }\n+\n+    // @since 1.8\n+    public void testNodeInArray() throws Exception\n+    {\n+        JsonNode node = new ObjectMapper().readTree(\"{\\\"a\\\":3}\");\n+\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping(DefaultTyping.JAVA_LANG_OBJECT);\n+        Object[] obs = new Object[] { node };\n+        String json = m.writeValueAsString(obs);\n+        Object[] result = m.readValue(json, Object[].class);\n+        assertEquals(1, result.length);\n+        Object ob = result[0];\n+        assertTrue(ob instanceof JsonNode);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForEnums.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestDefaultForEnums\n+    extends BaseMapTest\n+{\n+    public enum TestEnum {\n+        A, B;\n+    }\n+\n+    static final class EnumHolder\n+    {\n+        public Object value; // \"untyped\"\n+        \n+        public EnumHolder() { }\n+        public EnumHolder(TestEnum e) { value = e; }\n+    }\n+\n+    protected static class TimeUnitBean {\n+        public TimeUnit timeUnit;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleEnumBean() throws Exception\n+    {\n+        TimeUnitBean bean = new TimeUnitBean();\n+        bean.timeUnit = TimeUnit.HOURS;\n+        \n+        // First, without type info\n+        ObjectMapper m = new ObjectMapper();\n+        String json = m.writeValueAsString(bean);\n+        TimeUnitBean result = m.readValue(json, TimeUnitBean.class);\n+        assertEquals(TimeUnit.HOURS, result.timeUnit);\n+        \n+        // then with type info\n+        m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+        json = m.writeValueAsString(bean);\n+        result = m.readValue(json, TimeUnitBean.class);\n+\n+        assertEquals(TimeUnit.HOURS, result.timeUnit);\n+    }\n+    \n+    public void testSimpleEnumsInObjectArray() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+        \n+        // Typing is needed for enums\n+        String json = m.writeValueAsString(new Object[] { TestEnum.A });\n+        assertEquals(\"[[\\\"org.codehaus.jackson.map.jsontype.TestDefaultForEnums$TestEnum\\\",\\\"A\\\"]]\", json);\n+\n+        // and let's verify we get it back ok as well:\n+        Object[] value = m.readValue(json, Object[].class);\n+        assertEquals(1, value.length);\n+        assertSame(TestEnum.A, value[0]);\n+    }\n+\n+    public void testSimpleEnumsAsField() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+        String json = m.writeValueAsString(new EnumHolder(TestEnum.B));\n+        assertEquals(\"{\\\"value\\\":[\\\"org.codehaus.jackson.map.jsontype.TestDefaultForEnums$TestEnum\\\",\\\"B\\\"]}\", json);\n+        EnumHolder holder = m.readValue(json, EnumHolder.class);\n+        assertSame(TestEnum.B, holder.value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForLists.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ObjectMapper.DefaultTyping;\n+\n+public class TestDefaultForLists\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Wrapper bean needed before there is a way to force\n+     * type of the root value. Long is used because it is a final\n+     * type, but not one of \"untypeable\" ones.\n+     */\n+    static class ListOfLongs {\n+        public List<Long> longs;\n+\n+        public ListOfLongs() { }\n+        public ListOfLongs(Long ... ls) {\n+            longs = new ArrayList<Long>();\n+            for (Long l: ls) {\n+                longs.add(l);\n+            }\n+        }\n+    }\n+\n+    static class ListOfNumbers {\n+        public List<Number> nums;\n+\n+        public ListOfNumbers() { }\n+        public ListOfNumbers(Number ... numbers) {\n+            nums = new ArrayList<Number>();\n+            for (Number n : numbers) {\n+                nums.add(n);\n+            }\n+        }\n+    }\n+\n+    static class ObjectListBean {\n+        public List<Object> values;\n+    }\n+\n+    interface Foo { }\n+\n+    static class SetBean {\n+        public Set<String> names;\n+        \n+        public SetBean() { }\n+        public SetBean(String str) {\n+            names = new HashSet<String>();\n+            names.add(str);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testListOfLongs() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+        ListOfLongs input = new ListOfLongs(1L, 2L, 3L);\n+        String json = m.writeValueAsString(input);\n+        assertEquals(\"{\\\"longs\\\":[\\\"java.util.ArrayList\\\",[1,2,3]]}\", json);\n+        ListOfLongs output = m.readValue(json, ListOfLongs.class);\n+\n+        assertNotNull(output.longs);\n+        assertEquals(3, output.longs.size());\n+        assertEquals(Long.valueOf(1L), output.longs.get(0));\n+        assertEquals(Long.valueOf(2L), output.longs.get(1));\n+        assertEquals(Long.valueOf(3L), output.longs.get(2));\n+    }\n+\n+    /**\n+     * Then bit more heterogenous list; also tests mixing of\n+     * regular scalar types, and non-typed ones (int and double\n+     * will never have type info added; other numbers will if\n+     * necessary)\n+     */\n+    public void testListOfNumbers() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+        ListOfNumbers input = new ListOfNumbers(Long.valueOf(1L), Integer.valueOf(2), Double.valueOf(3.0));\n+        String json = m.writeValueAsString(input);\n+        assertEquals(\"{\\\"nums\\\":[\\\"java.util.ArrayList\\\",[[\\\"java.lang.Long\\\",1],2,3.0]]}\", json);\n+        ListOfNumbers output = m.readValue(json, ListOfNumbers.class);\n+\n+        assertNotNull(output.nums);\n+        assertEquals(3, output.nums.size());\n+        assertEquals(Long.valueOf(1L), output.nums.get(0));\n+        assertEquals(Integer.valueOf(2), output.nums.get(1));\n+        assertEquals(Double.valueOf(3.0), output.nums.get(2));\n+    }\n+\n+    public void testDateTypes() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+        ObjectListBean input = new ObjectListBean();\n+        List<Object> inputList = new ArrayList<Object>();\n+        inputList.add(TimeZone.getTimeZone(\"EST\"));\n+        inputList.add(Locale.CHINESE);\n+        input.values = inputList;\n+        String json = m.writeValueAsString(input);\n+        \n+        ObjectListBean output = m.readValue(json, ObjectListBean.class);\n+        List<Object> outputList = output.values;\n+        assertEquals(2, outputList.size());\n+        assertTrue(outputList.get(0) instanceof TimeZone);\n+        assertTrue(outputList.get(1) instanceof Locale);\n+    }\n+    \n+    public void testJackson628() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(DefaultTyping.NON_FINAL);\n+        ArrayList<Foo> data = new ArrayList<Foo>();\n+        String json = mapper.writeValueAsString(data);\n+        List<?> output = mapper.readValue(json, List.class);\n+        assertTrue(output.isEmpty());\n+    }\n+\n+    public void testJackson667() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL,\n+                JsonTypeInfo.As.PROPERTY);\n+        String json = mapper.writeValueAsString(new SetBean(\"abc\"));\n+        SetBean bean = mapper.readValue(json, SetBean.class);\n+        assertNotNull(bean);\n+        assertTrue(bean.names instanceof HashSet);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForMaps.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.jsontype.impl.TypeNameIdResolver;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+public class TestDefaultForMaps \n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static class MapKey {\n+        public String key;\n+\n+        public MapKey(String k) { key = k; }\n+\n+        @Override public String toString() { return key; }\n+    }\n+\n+    static class MapKeyDeserializer extends KeyDeserializer\n+    {\n+        @Override\n+        public Object deserializeKey(String key, DeserializationContext ctxt) {\n+            return new MapKey(key);\n+        }\n+    }\n+    \n+    static class MapHolder\n+    {\n+        @JsonDeserialize(keyAs=MapKey.class, keyUsing=MapKeyDeserializer.class)\n+        public Map<MapKey,List<Object>> map;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testJackson428() throws Exception\n+    {\n+        ObjectMapper serMapper = new ObjectMapper();\n+\n+        TypeResolverBuilder<?> serializerTyper = new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL);\n+        serializerTyper = serializerTyper.init(JsonTypeInfo.Id.NAME, createTypeNameIdResolver(true));\n+        serializerTyper = serializerTyper.inclusion(JsonTypeInfo.As.PROPERTY);\n+        serMapper.setDefaultTyping(serializerTyper);\n+\n+        // Let's start by constructing something to serialize first\n+        MapHolder holder = new MapHolder();\n+        holder.map = new HashMap<MapKey,List<Object>>();\n+        List<Object> ints = new ArrayList<Object>();\n+        ints.add(Integer.valueOf(3));\n+        holder.map.put(new MapKey(\"key\"), ints);\n+        String json = serMapper.writeValueAsString(holder);\n+\n+        // Then deserialize: need separate mapper to initialize type id resolver appropriately\n+        ObjectMapper deserMapper = new ObjectMapper();\n+        TypeResolverBuilder<?> deserializerTyper = new ObjectMapper.DefaultTypeResolverBuilder(ObjectMapper.DefaultTyping.NON_FINAL);\n+        deserializerTyper = deserializerTyper.init(JsonTypeInfo.Id.NAME, createTypeNameIdResolver(false));\n+        deserializerTyper = deserializerTyper.inclusion(JsonTypeInfo.As.PROPERTY);\n+        deserMapper.setDefaultTyping(deserializerTyper);\n+\n+        MapHolder result = deserMapper.readValue(json, MapHolder.class);\n+        assertNotNull(result);\n+        Map<?,?> map = result.map;\n+        assertEquals(1, map.size());\n+        Map.Entry<?,?> entry = map.entrySet().iterator().next();\n+        Object key = entry.getKey();\n+        assertEquals(MapKey.class, key.getClass());\n+        Object value = entry.getValue();\n+        assertTrue(value instanceof List<?>);\n+        List<?> list = (List<?>) value;\n+        assertEquals(1, list.size());\n+        assertEquals(Integer.class, list.get(0).getClass());\n+        assertEquals(Integer.valueOf(3), list.get(0));\n+    }\n+\n+    protected TypeNameIdResolver createTypeNameIdResolver(boolean forSerialization)\n+    {\n+        Collection<NamedType> subtypes = new ArrayList<NamedType>();\n+        subtypes.add(new NamedType(MapHolder.class, \"mapHolder\"));\n+        subtypes.add(new NamedType(ArrayList.class, \"AList\"));\n+        subtypes.add(new NamedType(HashMap.class, \"HMap\"));\n+        ObjectMapper mapper = new ObjectMapper();\n+        return TypeNameIdResolver.construct(mapper.getDeserializationConfig(),\n+                TypeFactory.defaultInstance().constructType(Object.class), subtypes, forSerialization, !forSerialization);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForObject.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n+\n+public class TestDefaultForObject\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static abstract class AbstractBean { }\n+    \n+    static class StringBean extends AbstractBean { // ha, punny!\n+        public String name;\n+\n+        public StringBean() { this(null); }\n+        protected StringBean(String n)  { name = n; }\n+    }\n+\n+    enum Choice { YES, NO; }\n+\n+    /**\n+     * Another enum type, but this time forcing sub-classing\n+     */\n+    enum ComplexChoice {\n+    \tMAYBE(true), PROBABLY_NOT(false);\n+\n+    \tprivate boolean state;\n+    \t\n+    \tprivate ComplexChoice(boolean b) { state = b; }\n+    \t\n+        @Override\n+    \tpublic String toString() { return String.valueOf(state); }\n+    }\n+\n+    // [JACKSON-311]\n+    static class PolymorphicType {\n+        public String foo;\n+        public Object bar;\n+        \n+        public PolymorphicType() { }\n+        public PolymorphicType(String foo, int bar) {\n+            this.foo = foo;\n+            this.bar = bar;\n+        }\n+    }\n+\n+    final static class BeanHolder\n+    {\n+        public AbstractBean bean;\n+        \n+        public BeanHolder() { }\n+        public BeanHolder(AbstractBean b) { bean = b; }\n+    }\n+\n+    final static class ObjectHolder\n+    {\n+        public Object value;\n+\n+        public ObjectHolder() { }\n+        public ObjectHolder(Object v) { value = v; }\n+    }\n+\n+    // [JACKSON-352]\n+    static class DomainBean {\n+        public int weight;\n+    }\n+\n+    static class DiscussBean extends DomainBean {\n+        public String subject;\n+    }\n+\n+    static public class DomainBeanWrapper {\n+        public String name;\n+        public Object myBean;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Unit test that verifies that a bean is stored with type information,\n+     * when declared type is <code>Object.class</code> (since it is within\n+     * Object[]), and default type information is enabled.\n+     */\n+    public void testBeanAsObject() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+        // note: need to wrap, to get declared as Object\n+        String str = m.writeValueAsString(new Object[] { new StringBean(\"abc\") });\n+\n+        _verifySerializationAsMap(str);\n+        \n+        // Ok: serialization seems to work as expected. Now deserialize:\n+        Object ob = m.readValue(str, Object[].class);\n+        assertNotNull(ob);\n+        Object[] result = (Object[]) ob;\n+        assertNotNull(result[0]);\n+        assertEquals(StringBean.class, result[0].getClass());\n+        assertEquals(\"abc\", ((StringBean) result[0]).name);\n+    }\n+\n+    /**\n+     * Unit test that verifies that an abstract bean is stored with type information\n+     * if default type information is enabled for non-concrete types.\n+     */\n+    public void testAbstractBean() throws Exception\n+    {\n+        // First, let's verify that we'd fail without enabling default type info\n+        ObjectMapper m = new ObjectMapper();\n+        AbstractBean[] input = new AbstractBean[] { new StringBean(\"xyz\") };\n+        String serial = m.writeValueAsString(input);\n+        try {\n+            m.readValue(serial, AbstractBean[].class);\n+            fail(\"Should have failed\");\n+        } catch (JsonMappingException e) {\n+            // let's use whatever is currently thrown exception... may change tho\n+            verifyException(e, \"can not construct\");\n+        }\n+        \n+        // and then that we will succeed with default type info\n+        m = new ObjectMapper();\n+        m.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);\n+        serial = m.writeValueAsString(input);\n+        AbstractBean[] beans = m.readValue(serial, AbstractBean[].class);\n+        assertEquals(1, beans.length);\n+        assertEquals(StringBean.class, beans[0].getClass());\n+        assertEquals(\"xyz\", ((StringBean) beans[0]).name);\n+    }\n+\n+    /**\n+     * Unit test to verify that type information is included for\n+     * all non-final types, if default typing suitably configured\n+     */\n+    public void testNonFinalBean() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // first: use \"object or abstract\" typing: should produce no type info:        \n+        m.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE);\n+        StringBean bean = new StringBean(\"x\");\n+        assertEquals(\"{\\\"name\\\":\\\"x\\\"}\", m.writeValueAsString(bean));\n+        // then non-final, and voila:\n+        m = new ObjectMapper();\n+        m.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n+        assertEquals(\"[\\\"\"+StringBean.class.getName()+\"\\\",{\\\"name\\\":\\\"x\\\"}]\",\n+            m.writeValueAsString(bean));\n+    }\n+\n+    public void testNullValue() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n+        BeanHolder h = new BeanHolder();\n+        String json = m.writeValueAsString(h);\n+        assertNotNull(json);\n+        BeanHolder result = m.readValue(json, BeanHolder.class);\n+        assertNotNull(result);\n+        assertNull(result.bean);\n+    }\n+    \n+    public void testEnumAsObject() throws Exception\n+    {\n+        // wrapping to be declared as object\n+        Object[] input = new Object[] { Choice.YES };\n+        Object[] input2 = new Object[] { ComplexChoice.MAYBE};\n+        // first, without type info:\n+        assertEquals(\"[\\\"YES\\\"]\", serializeAsString(input));\n+        assertEquals(\"[\\\"MAYBE\\\"]\", serializeAsString(input2));\n+\n+        // and then with it\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+\n+        String json = m.writeValueAsString(input);\n+        assertEquals(\"[[\\\"\"+Choice.class.getName()+\"\\\",\\\"YES\\\"]]\", json);\n+\n+        // which we should get back same way\n+        Object[] output = m.readValue(json, Object[].class);\n+        assertEquals(1, output.length);\n+        assertEquals(Choice.YES, output[0]);\n+\n+        // ditto for more complicated enum\n+        json = m.writeValueAsString(input2);\n+        assertEquals(\"[[\\\"\"+ComplexChoice.class.getName()+\"\\\",\\\"MAYBE\\\"]]\", json);\n+        output = m.readValue(json, Object[].class);\n+        assertEquals(1, output.length);\n+        assertEquals(ComplexChoice.MAYBE, output[0]);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEnumSet() throws Exception\n+    {\n+        EnumSet<Choice> set = EnumSet.of(Choice.NO);\n+        Object[] input = new Object[] { set };\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+        String json = m.writeValueAsString(input);\n+        Object[] output = m.readValue(json, Object[].class);\n+        assertEquals(1, output.length);\n+        Object ob = output[0];\n+        assertTrue(ob instanceof EnumSet<?>);\n+        EnumSet<Choice> set2 = (EnumSet<Choice>) ob;\n+        assertEquals(1, set2.size());\n+        assertTrue(set2.contains(Choice.NO));\n+        assertFalse(set2.contains(Choice.YES));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEnumMap() throws Exception\n+    {\n+        EnumMap<Choice,String> map = new EnumMap<Choice,String>(Choice.class);\n+        map.put(Choice.NO, \"maybe\");\n+        Object[] input = new Object[] { map };\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+        String json = m.writeValueAsString(input);\n+        Object[] output = m.readValue(json, Object[].class);\n+        assertEquals(1, output.length);\n+        Object ob = output[0];\n+        assertTrue(ob instanceof EnumMap<?,?>);\n+        EnumMap<Choice,String> map2 = (EnumMap<Choice,String>) ob;\n+        assertEquals(1, map2.size());\n+        assertEquals(\"maybe\", map2.get(Choice.NO));\n+        assertNull(map2.get(Choice.YES));\n+    }\n+\n+    public void testJackson311() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n+        String json = mapper.writeValueAsString(new PolymorphicType(\"hello\", 2));\n+        PolymorphicType value = mapper.readValue(json, PolymorphicType.class);\n+        assertEquals(\"hello\", value.foo);\n+        assertEquals(Integer.valueOf(2), value.bar);\n+    }\n+\n+    // Also, let's ensure TokenBuffer gets properly handled\n+    public void testTokenBuffer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n+\n+        // Ok, first test JSON Object containing buffer:\n+        TokenBuffer buf = new TokenBuffer(mapper);\n+        buf.writeStartObject();\n+        buf.writeNumberField(\"num\", 42);\n+        buf.writeEndObject();\n+        String json = mapper.writeValueAsString(new ObjectHolder(buf));\n+        ObjectHolder holder = mapper.readValue(json, ObjectHolder.class);\n+        assertNotNull(holder.value);\n+        assertSame(TokenBuffer.class, holder.value.getClass());\n+        JsonParser jp = ((TokenBuffer) holder.value).asParser();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // then as an array:\n+        buf = new TokenBuffer(mapper);\n+        buf.writeStartArray();\n+        buf.writeBoolean(true);\n+        buf.writeEndArray();\n+        json = mapper.writeValueAsString(new ObjectHolder(buf));\n+        holder = mapper.readValue(json, ObjectHolder.class);\n+        assertNotNull(holder.value);\n+        assertSame(TokenBuffer.class, holder.value.getClass());\n+        jp = ((TokenBuffer) holder.value).asParser();\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // and finally as scalar\n+        buf = new TokenBuffer(mapper);\n+        buf.writeNumber(321);\n+        json = mapper.writeValueAsString(new ObjectHolder(buf));\n+        holder = mapper.readValue(json, ObjectHolder.class);\n+        assertNotNull(holder.value);\n+        assertSame(TokenBuffer.class, holder.value.getClass());\n+        jp = ((TokenBuffer) holder.value).asParser();\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(321, jp.getIntValue());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+\n+    /**\n+     * Test for [JACKSON-352]\n+     */\n+    public void testIssue352() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping (ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, JsonTypeInfo.As.PROPERTY);\n+        DiscussBean d1 = new DiscussBean();\n+        d1.subject = \"mouse\";\n+        d1.weight=88;\n+        DomainBeanWrapper wrapper = new DomainBeanWrapper();\n+        wrapper.name = \"mickey\";\n+        wrapper.myBean = d1;\n+        String json = mapper.writeValueAsString(wrapper);\n+        DomainBeanWrapper result = mapper.readValue(json, DomainBeanWrapper.class);\n+        assertNotNull(result);\n+        assertNotNull(wrapper.myBean);\n+        assertSame(DiscussBean.class, wrapper.myBean.getClass());\n+    }    \n+\n+    // Test to ensure we can also use \"As.PROPERTY\" inclusion and custom property name\n+    public void testFeature432() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTypingAsProperty(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, \"*CLASS*\");\n+        String json = mapper.writeValueAsString(new BeanHolder(new StringBean(\"punny\")));\n+        assertEquals(\"{\\\"bean\\\":{\\\"*CLASS*\\\":\\\"org.codehaus.jackson.map.jsontype.TestDefaultForObject$StringBean\\\",\\\"name\\\":\\\"punny\\\"}}\", json);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    private void _verifySerializationAsMap(String str) throws Exception\n+    {\n+        // First: validate that structure looks correct (as Map etc)\n+        // note: should look something like:\n+        // \"[[\"org.codehaus.jackson.map.jsontype.TestDefaultForObject$StringBean\",{\"name\":\"abc\"}]]\")\n+\n+        // note: must have default mapper, default typer NOT enabled (to get 'plain' map)\n+        ObjectMapper m = new ObjectMapper();\n+        List<Object> list = m.readValue(str, List.class);\n+        assertEquals(1, list.size()); // no type for main List, just single entry\n+        Object entryOb = list.get(0);\n+        assertTrue(entryOb instanceof List<?>);\n+        // but then type wrapper for bean\n+        List<?> entryList = (List<?>)entryOb;\n+        assertEquals(2, entryList.size());\n+        assertEquals(StringBean.class.getName(), entryList.get(0));\n+        assertTrue(entryList.get(1) instanceof Map);\n+        Map<?,?> map = (Map<?,?>) entryList.get(1);\n+        assertEquals(1, map.size());\n+        assertEquals(\"abc\", map.get(\"name\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForScalars.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import static org.junit.Assert.*;\n+\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests to verify that Java/JSON scalar values (non-structured values)\n+ * are handled properly with respect to additional type information.\n+ * \n+ * @since 1.5\n+ * @author tatu\n+ */\n+public class TestDefaultForScalars\n+    extends BaseMapTest\n+{\n+    static class Jackson417Bean {\n+        public String foo = \"bar\";\n+        public java.io.Serializable bar = new Integer(13);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Unit test to verify that limited number of core types do NOT include\n+     * type information, even if declared as Object. This is only done for types\n+     * that JSON scalar values natively map to: String, Integer and Boolean (and\n+     * nulls never have type information)\n+     */\n+    public void testNumericScalars() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+\n+        // no typing for Integer, Double, yes for others\n+        assertEquals(\"[123]\", m.writeValueAsString(new Object[] { Integer.valueOf(123) }));\n+        assertEquals(\"[[\\\"java.lang.Long\\\",37]]\", m.writeValueAsString(new Object[] { Long.valueOf(37) }));\n+        assertEquals(\"[0.25]\", m.writeValueAsString(new Object[] { Double.valueOf(0.25) }));\n+        assertEquals(\"[[\\\"java.lang.Float\\\",0.5]]\", m.writeValueAsString(new Object[] { Float.valueOf(0.5f) }));\n+    }\n+\n+    public void testDateScalars() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+\n+        long ts = 12345678L;\n+        assertEquals(\"[[\\\"java.util.Date\\\",\"+ts+\"]]\",\n+                m.writeValueAsString(new Object[] { new Date(ts) }));\n+\n+        // Calendar is trickier... hmmh. Need to ensure round-tripping\n+        Calendar c = Calendar.getInstance();\n+        c.setTimeInMillis(ts);\n+        String json = m.writeValueAsString(new Object[] { c });\n+        assertEquals(\"[[\\\"\"+c.getClass().getName()+\"\\\",\"+ts+\"]]\", json);\n+        // and let's make sure it also comes back same way:\n+        Object[] result = m.readValue(json, Object[].class);\n+        assertEquals(1, result.length);\n+        assertTrue(result[0] instanceof Calendar);\n+        assertEquals(ts, ((Calendar) result[0]).getTimeInMillis());\n+    }\n+\n+    public void testMiscScalars() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+\n+        // no typing for Strings, booleans\n+        assertEquals(\"[\\\"abc\\\"]\", m.writeValueAsString(new Object[] { \"abc\" }));\n+        assertEquals(\"[true,null,false]\", m.writeValueAsString(new Boolean[] { true, null, false }));\n+    }\n+\n+    /**\n+     * Test for verifying that contents of \"untyped\" homogenous arrays are properly\n+     * handled,\n+     */\n+    public void testScalarArrays() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping(ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT);\n+        Object[] input = new Object[] {\n+                \"abc\", new Date(1234567), null, Integer.valueOf(456)\n+        };\n+        String json = m.writeValueAsString(input);\n+        assertEquals(\"[\\\"abc\\\",[\\\"java.util.Date\\\",1234567],null,456]\", json);\n+\n+        // and should deserialize back as well:\n+        Object[] output = m.readValue(json, Object[].class);\n+        assertArrayEquals(input, output);\n+    }\n+\n+    /**\n+     * Loosely scalar; for [JACKSON-417]\n+     */\n+    public void test417() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.enableDefaultTyping();\n+        Jackson417Bean input = new Jackson417Bean();\n+        String json = m.writeValueAsString(input);\n+        Jackson417Bean result = m.readValue(json, Jackson417Bean.class);\n+        assertEquals(input.foo, result.foo);\n+        assertEquals(input.bar, result.bar);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultWithCreators.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestDefaultWithCreators\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static abstract class Job\n+    {\n+        public long id;\n+    }\n+\n+    static class UrlJob extends Job\n+    {\n+        private final String url;\n+        private final int count;\n+        \n+        @JsonCreator\n+        public UrlJob(@JsonProperty(\"id\") long id, @JsonProperty(\"url\") String url,\n+                @JsonProperty(\"count\") int count)\n+        {\n+            this.id = id;\n+            this.url = url;\n+            this.count = count;\n+        }\n+\n+        public String getUrl() { return url; }\n+        public int getCount() { return count; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testWithCreators() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n+        UrlJob input = new UrlJob(123L, \"http://foo\", 3);\n+        String json = mapper.writeValueAsString(input);\n+        assertNotNull(json);\n+        Job output = mapper.readValue(json, Job.class);\n+        assertNotNull(output);\n+        assertSame(UrlJob.class, output.getClass());\n+        UrlJob o2 = (UrlJob) output;\n+        assertEquals(123L, o2.id);\n+        assertEquals(\"http://foo\", o2.getUrl());\n+        assertEquals(3, o2.getCount());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestEnumTyping.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+@SuppressWarnings(\"serial\")\n+public class TestEnumTyping extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    // note: As.WRAPPER_ARRAY worked initially; but as per [JACKSON-485], As.PROPERTY had issues\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.MINIMAL_CLASS, include=JsonTypeInfo.As.PROPERTY)\n+    public interface EnumInterface { }\n+\n+    public enum Tag implements EnumInterface\n+    { A, B };\n+    \n+    static class EnumInterfaceWrapper {\n+        public EnumInterface value;\n+    }\n+    \n+    static class EnumInterfaceList extends ArrayList<EnumInterface> { }\n+\n+    static class TagList extends ArrayList<Tag> { }\n+\n+    static enum TestEnum { A, B, C; }\n+    \n+    static class UntypedEnumBean\n+    {\n+       @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property=\"__type\")\n+        public Object value;\n+\n+        public UntypedEnumBean() { }\n+        public UntypedEnumBean(TestEnum v) { value = v; }\n+\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property=\"__type\")\n+        public void setValue(Object o) {\n+            value = o;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testTagList() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        TagList list = new TagList();\n+        list.add(Tag.A);\n+        list.add(Tag.B);\n+        String json = m.writeValueAsString(list);\n+\n+        TagList result = m.readValue(json, TagList.class);\n+        assertEquals(2, result.size());\n+        assertSame(Tag.A, result.get(0));\n+        assertSame(Tag.B, result.get(1));\n+    }\n+\n+    public void testEnumInterface() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        String json = m.writeValueAsString(Tag.B);\n+        \n+        EnumInterface result = m.readValue(json, EnumInterface.class);\n+        assertSame(Tag.B, result);\n+    }\n+\n+    public void testEnumInterfaceList() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        EnumInterfaceList list = new EnumInterfaceList();\n+        list.add(Tag.A);\n+        list.add(Tag.B);\n+        String json = m.writeValueAsString(list);\n+        \n+        EnumInterfaceList result = m.readValue(json, EnumInterfaceList.class);\n+        assertEquals(2, result.size());\n+        assertSame(Tag.A, result.get(0));\n+        assertSame(Tag.B, result.get(1));\n+    }\n+\n+    public void testUntypedEnum() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String str = mapper.writeValueAsString(new UntypedEnumBean(TestEnum.B));\n+        UntypedEnumBean result = mapper.readValue(str, UntypedEnumBean.class);\n+        assertNotNull(result);\n+        assertNotNull(result.value);\n+        Object ob = result.value;\n+        assertSame(TestEnum.class, ob.getClass());\n+        assertEquals(TestEnum.B, result.value);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+// Tests for [JACKSON-453]\n+public class TestExternalId extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+    \n+    static class ExternalBean\n+    {\n+        @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property=\"extType\")\n+        public Object bean;\n+\n+        public ExternalBean() { }\n+        public ExternalBean(int v) {\n+            bean = new ValueBean(v);\n+        }\n+    }\n+\n+    static class ExternalBean3\n+    {\n+        @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property=\"extType1\")\n+        public Object value1;\n+        \n+        @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property=\"extType2\")\n+        public Object value2;\n+\n+        public int foo;\n+        \n+        @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property=\"extType3\")\n+        public Object value3;\n+        \n+        public ExternalBean3() { }\n+        public ExternalBean3(int v) {\n+            value1 = new ValueBean(v);\n+            value2 = new ValueBean(v+1);\n+            value3 = new ValueBean(v+2);\n+            foo = v;\n+        }\n+    }\n+\n+    static class ExternalBeanWithCreator\n+    {\n+        @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property=\"extType\")\n+        public Object value;\n+\n+        public int foo;\n+        \n+        @JsonCreator\n+        public ExternalBeanWithCreator(@JsonProperty(\"foo\") int f)\n+        {\n+            foo = f;\n+            value = new ValueBean(f);\n+        }\n+    }\n+    \n+    @JsonTypeName(\"vbean\")\n+    static class ValueBean {\n+        public int value;\n+        \n+        public ValueBean() { }\n+        public ValueBean(int v) { value = v; }\n+    }\n+\n+    @JsonTypeName(\"funk\")\n+    @JsonTypeInfo(use=Id.NAME, include=As.EXTERNAL_PROPERTY, property=\"extType\")\n+    static class FunkyExternalBean {\n+        public int i = 3;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests, serialization\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleSerialization() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerSubtypes(ValueBean.class);\n+        // This may look odd, but one implementation nastiness is the fact\n+        // that we can not properly serialize type id before the object,\n+        // because call is made after property name (for object) has already\n+        // been written out. So we'll write it after...\n+        // Deserializer will work either way as it can not rely on ordering\n+        // anyway.\n+        assertEquals(\"{\\\"bean\\\":{\\\"value\\\":11},\\\"extType\\\":\\\"vbean\\\"}\",\n+                mapper.writeValueAsString(new ExternalBean(11)));\n+    }\n+\n+    // If trying to use with Class, should just become \"PROPERTY\" instead:\n+    public void testImproperExternalIdSerialization() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"{\\\"extType\\\":\\\"funk\\\",\\\"i\\\":3}\",\n+                mapper.writeValueAsString(new FunkyExternalBean()));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests, deserialization\n+    /**********************************************************\n+     */\n+    \n+    public void testSimpleDeserialization() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerSubtypes(ValueBean.class);\n+        ExternalBean result = mapper.readValue(\"{\\\"bean\\\":{\\\"value\\\":11},\\\"extType\\\":\\\"vbean\\\"}\", ExternalBean.class);\n+        assertNotNull(result);\n+        assertNotNull(result.bean);\n+        ValueBean vb = (ValueBean) result.bean;\n+        assertEquals(11, vb.value);\n+    }\n+\n+    /**\n+     * Test for verifying that it's ok to have multiple (say, 3)\n+     * externally typed things, mixed with other stuff...\n+     */\n+    public void testMultipleTypeIdsDeserialization() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerSubtypes(ValueBean.class);\n+        String json = mapper.writeValueAsString(new ExternalBean3(3));\n+        ExternalBean3 result = mapper.readValue(json, ExternalBean3.class);\n+        assertNotNull(result);\n+        assertNotNull(result.value1);\n+        assertNotNull(result.value2);\n+        assertNotNull(result.value3);\n+        assertEquals(3, ((ValueBean)result.value1).value);\n+        assertEquals(4, ((ValueBean)result.value2).value);\n+        assertEquals(5, ((ValueBean)result.value3).value);\n+        assertEquals(3, result.foo);\n+    }\n+\n+    /**\n+     * Also, it should be ok to use @JsonCreator as well...\n+     */\n+    public void testExternalTypeWithCreator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerSubtypes(ValueBean.class);\n+        String json = mapper.writeValueAsString(new ExternalBeanWithCreator(7));\n+        ExternalBeanWithCreator result = mapper.readValue(json, ExternalBeanWithCreator.class);\n+        assertNotNull(result);\n+        assertNotNull(result.value);\n+        assertEquals(7, ((ValueBean)result.value).value);\n+        assertEquals(7, result.foo);\n+    }\n+    \n+    // If trying to use with Class, should just become \"PROPERTY\" instead:\n+    public void testImproperExternalIdDeserialization() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        FunkyExternalBean result = mapper.readValue(\"{\\\"extType\\\":\\\"funk\\\",\\\"i\\\":3}\", FunkyExternalBean.class);\n+        assertNotNull(result);\n+        assertEquals(3, result.i);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestGenericListSerialization.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+public class TestGenericListSerialization\n+    extends BaseMapTest\n+{\n+    // [JACKSON-356]\n+    public static class JSONResponse<T> {\n+\n+        private T result;\n+\n+        public T getResult() {\n+            return result;\n+        }\n+\n+        public void setResult(T result) {\n+            this.result = result;\n+        }\n+    } \n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property=\"@class\")\n+    public static class Parent {\n+        public String parentContent = \"PARENT\";\n+    }\n+\n+    public static class Child1 extends Parent {\n+        public String childContent1 = \"CHILD1\";\n+    }\n+\n+    public static class Child2 extends Parent {\n+        public String childContent2 = \"CHILD2\";\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testSubTypesFor356() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        /* 06-Sep-2010, tatus: This was not fixed for 1.6; and to keep junit test\n+         *   suite green, let's not run it for versions prior to 1.7...\n+         */\n+        Version v = mapper.version();\n+        if (v.getMajorVersion() == 1 && v.getMinorVersion() == 6) {\n+            System.err.println(\"Note: skipping test for Jackson 1.6\");\n+            return;\n+        }\n+        \n+        JSONResponse<List<Parent>> input = new JSONResponse<List<Parent>>();\n+\n+        List<Parent> embedded = new ArrayList<Parent>();\n+        embedded.add(new Child1());\n+        embedded.add(new Child2());\n+        input.setResult(embedded);\n+        mapper.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+\n+        JavaType rootType = TypeFactory.defaultInstance().constructType(new TypeReference<JSONResponse<List<Parent>>>() { });\n+        byte[] json = mapper.writerWithType(rootType).writeValueAsBytes(input);\n+//        byte[] json = mapper.writeValueAsBytes(input);\n+\n+//        System.out.println(\"After Serialization: \" + new String(json));\n+        \n+        JSONResponse<List<Parent>> out = mapper.readValue(json, 0, json.length, rootType);\n+\n+        List<Parent> deserializedContent = (List<Parent>) out.getResult();\n+\n+        assertEquals(2, deserializedContent.size());\n+        assertTrue(deserializedContent.get(0) instanceof Parent);\n+        assertTrue(deserializedContent.get(0) instanceof Child1);\n+        assertFalse(deserializedContent.get(0) instanceof Child2);\n+        assertTrue(deserializedContent.get(1) instanceof Child2);\n+        assertFalse(deserializedContent.get(1) instanceof Child1);\n+\n+        assertEquals(\"PARENT\", ((Child1) deserializedContent.get(0)).parentContent);\n+        assertEquals(\"PARENT\", ((Child2) deserializedContent.get(1)).parentContent);\n+        assertEquals(\"CHILD1\", ((Child1) deserializedContent.get(0)).childContent1);\n+        assertEquals(\"CHILD2\", ((Child2) deserializedContent.get(1)).childContent2);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestPropertyTypeInfo.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Testing to verify that {@link JsonTypeInfo} works\n+ * for properties as well as types (see [JACKSON-280] for details)\n+ */\n+@SuppressWarnings(\"serial\")\n+public class TestPropertyTypeInfo extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static class FieldWrapperBean\n+    {\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)\n+        public Object value;\n+\n+        public FieldWrapperBean() { }\n+        public FieldWrapperBean(Object o) { value = o; }\n+    }\n+\n+    static class FieldWrapperBeanList extends ArrayList<FieldWrapperBean> { }\n+    static class FieldWrapperBeanMap extends HashMap<String,FieldWrapperBean> { }\n+    static class FieldWrapperBeanArray {\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)\n+        public FieldWrapperBean[] beans;\n+\n+        public FieldWrapperBeanArray() { }\n+        public FieldWrapperBeanArray(FieldWrapperBean[] beans) { this.beans = beans; }\n+    }\n+    \n+    static class MethodWrapperBean\n+    {\n+        private Object value;\n+        \n+        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)\n+        public Object getValue() { return value; }\n+\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)\n+        public void setValue(Object v) { value = v; }\n+        \n+        public MethodWrapperBean() { }\n+        public MethodWrapperBean(Object o) { value = o; }\n+    }\n+    \n+    static class MethodWrapperBeanList extends ArrayList<MethodWrapperBean> { }\n+    static class MethodWrapperBeanMap extends HashMap<String,MethodWrapperBean> { }\n+    static class MethodWrapperBeanArray {\n+        protected MethodWrapperBean[] beans;\n+\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)\n+        public MethodWrapperBean[] getValue() { return beans; }\n+\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)\n+        public void setValue(MethodWrapperBean[] v) { beans = v; }\n+        \n+        public MethodWrapperBeanArray() { }\n+        public MethodWrapperBeanArray(MethodWrapperBean[] beans) { this.beans = beans; }\n+    }\n+\n+    static class OtherBean {\n+        public int x = 1, y = 1;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleField() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new FieldWrapperBean(new StringWrapper(\"foo\")));\n+//System.out.println(\"JSON/field+object == \"+json);\n+        FieldWrapperBean bean = mapper.readValue(json, FieldWrapperBean.class);\n+        assertNotNull(bean.value);\n+        assertEquals(StringWrapper.class, bean.value.getClass());\n+        assertEquals(((StringWrapper) bean.value).str, \"foo\");\n+    }\n+\n+    public void testSimpleMethod() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new FieldWrapperBean(new IntWrapper(37)));\n+//System.out.println(\"JSON/method+object == \"+json);\n+        FieldWrapperBean bean = mapper.readValue(json, FieldWrapperBean.class);\n+        assertNotNull(bean.value);\n+        assertEquals(IntWrapper.class, bean.value.getClass());\n+        assertEquals(((IntWrapper) bean.value).i, 37);\n+    }\n+\n+    public void testSimpleListField() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        FieldWrapperBeanList list = new FieldWrapperBeanList();\n+        list.add(new FieldWrapperBean(new OtherBean()));\n+        String json = mapper.writeValueAsString(list);\n+//System.out.println(\"JSON/field+list == \"+json);\n+        FieldWrapperBeanList result = mapper.readValue(json, FieldWrapperBeanList.class);\n+        assertNotNull(result);\n+        assertEquals(1, result.size());\n+        FieldWrapperBean bean = list.get(0);\n+        assertEquals(OtherBean.class, bean.value.getClass());\n+        assertEquals(((OtherBean) bean.value).x, 1);\n+        assertEquals(((OtherBean) bean.value).y, 1);\n+    }\n+\n+    public void testSimpleListMethod() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        MethodWrapperBeanList list = new MethodWrapperBeanList();\n+        list.add(new MethodWrapperBean(new BooleanWrapper(true)));\n+        list.add(new MethodWrapperBean(new StringWrapper(\"x\")));\n+        list.add(new MethodWrapperBean(new OtherBean()));\n+        String json = mapper.writeValueAsString(list);\n+        MethodWrapperBeanList result = mapper.readValue(json, MethodWrapperBeanList.class);\n+        assertNotNull(result);\n+        assertEquals(3, result.size());\n+        MethodWrapperBean bean = result.get(0);\n+        assertEquals(BooleanWrapper.class, bean.value.getClass());\n+        assertEquals(((BooleanWrapper) bean.value).b, Boolean.TRUE);\n+        bean = result.get(1);\n+        assertEquals(StringWrapper.class, bean.value.getClass());\n+        assertEquals(((StringWrapper) bean.value).str, \"x\");\n+        bean = result.get(2);\n+        assertEquals(OtherBean.class, bean.value.getClass());\n+    }\n+\n+    public void testSimpleArrayField() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        FieldWrapperBeanArray array = new FieldWrapperBeanArray(new\n+                FieldWrapperBean[] { new FieldWrapperBean(new BooleanWrapper(true)) });\n+        String json = mapper.writeValueAsString(array);\n+        FieldWrapperBeanArray result = mapper.readValue(json, FieldWrapperBeanArray.class);\n+        assertNotNull(result);\n+        FieldWrapperBean[] beans = result.beans;\n+        assertEquals(1, beans.length);\n+        FieldWrapperBean bean = beans[0];\n+        assertEquals(BooleanWrapper.class, bean.value.getClass());\n+        assertEquals(((BooleanWrapper) bean.value).b, Boolean.TRUE);\n+    }\n+\n+    public void testSimpleArrayMethod() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        MethodWrapperBeanArray array = new MethodWrapperBeanArray(new\n+                MethodWrapperBean[] { new MethodWrapperBean(new StringWrapper(\"A\")) });\n+        String json = mapper.writeValueAsString(array);\n+        MethodWrapperBeanArray result = mapper.readValue(json, MethodWrapperBeanArray.class);\n+        assertNotNull(result);\n+        MethodWrapperBean[] beans = result.beans;\n+        assertEquals(1, beans.length);\n+        MethodWrapperBean bean = beans[0];\n+        assertEquals(StringWrapper.class, bean.value.getClass());\n+        assertEquals(((StringWrapper) bean.value).str, \"A\");\n+    }\n+    \n+    public void testSimpleMapField() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        FieldWrapperBeanMap map = new FieldWrapperBeanMap();\n+        map.put(\"foop\", new FieldWrapperBean(new IntWrapper(13)));\n+        String json = mapper.writeValueAsString(map);\n+        FieldWrapperBeanMap result = mapper.readValue(json, FieldWrapperBeanMap.class);\n+        assertNotNull(result);\n+        assertEquals(1, result.size());\n+        FieldWrapperBean bean = result.get(\"foop\");\n+        assertNotNull(bean);\n+        Object ob = bean.value;\n+        assertEquals(IntWrapper.class, ob.getClass());\n+        assertEquals(((IntWrapper) ob).i, 13);\n+    }\n+\n+    public void testSimpleMapMethod() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        MethodWrapperBeanMap map = new MethodWrapperBeanMap();\n+        map.put(\"xyz\", new MethodWrapperBean(new BooleanWrapper(true)));\n+        String json = mapper.writeValueAsString(map);\n+        MethodWrapperBeanMap result = mapper.readValue(json, MethodWrapperBeanMap.class);\n+        assertNotNull(result);\n+        assertEquals(1, result.size());\n+        MethodWrapperBean bean = result.get(\"xyz\");\n+        assertNotNull(bean);\n+        Object ob = bean.value;\n+        assertEquals(BooleanWrapper.class, ob.getClass());\n+        assertEquals(((BooleanWrapper) ob).b, Boolean.TRUE);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestScalars.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.io.Serializable;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestScalars extends BaseMapTest\n+{\n+    private static class DynamicWrapper {\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)\n+        public Object value;\n+        \n+        @SuppressWarnings(\"unused\")\n+        public DynamicWrapper() { }\n+        public DynamicWrapper(Object v) { value = v; }\n+    }\n+\n+    static enum TestEnum { A, B; }\n+\n+    private static class AbstractWrapper {\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)\n+        public Serializable value;\n+        \n+        @SuppressWarnings(\"unused\")\n+        public AbstractWrapper() { }\n+        public AbstractWrapper(Serializable v) { value = v; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Ensure that per-property dynamic types work, both for \"native\" types\n+     * and others\n+     */\n+    public void testScalarsWithTyping() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        String json;\n+        DynamicWrapper result;\n+\n+        // first, check \"native\" types\n+        json = m.writeValueAsString(new DynamicWrapper(Integer.valueOf(3)));\n+        result = m.readValue(json, DynamicWrapper.class);\n+        assertEquals(Integer.valueOf(3), result.value);\n+\n+        json = m.writeValueAsString(new DynamicWrapper(\"abc\"));\n+        result = m.readValue(json, DynamicWrapper.class);\n+        assertEquals(\"abc\", result.value);\n+\n+        json = m.writeValueAsString(new DynamicWrapper(\"abc\"));\n+        result = m.readValue(json, DynamicWrapper.class);\n+        assertEquals(\"abc\", result.value);\n+\n+        json = m.writeValueAsString(new DynamicWrapper(Boolean.TRUE));\n+        result = m.readValue(json, DynamicWrapper.class);\n+        assertEquals(Boolean.TRUE, result.value);\n+        \n+        // then verify other scalars\n+        json = m.writeValueAsString(new DynamicWrapper(Long.valueOf(7L)));\n+        result = m.readValue(json, DynamicWrapper.class);\n+        assertEquals(Long.valueOf(7), result.value);\n+\n+        json = m.writeValueAsString(new DynamicWrapper(TestEnum.B));\n+        result = m.readValue(json, DynamicWrapper.class);\n+        assertEquals(TestEnum.B, result.value);\n+    }\n+\n+    public void testScalarsViaAbstractType() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        String json;\n+        AbstractWrapper result;\n+\n+        // first, check \"native\" types\n+        json = m.writeValueAsString(new AbstractWrapper(Integer.valueOf(3)));\n+        result = m.readValue(json, AbstractWrapper.class);\n+        assertEquals(Integer.valueOf(3), result.value);\n+\n+        json = m.writeValueAsString(new AbstractWrapper(\"abc\"));\n+        result = m.readValue(json, AbstractWrapper.class);\n+        assertEquals(\"abc\", result.value);\n+\n+        json = m.writeValueAsString(new AbstractWrapper(\"abc\"));\n+        result = m.readValue(json, AbstractWrapper.class);\n+        assertEquals(\"abc\", result.value);\n+\n+        json = m.writeValueAsString(new AbstractWrapper(Boolean.TRUE));\n+        result = m.readValue(json, AbstractWrapper.class);\n+        assertEquals(Boolean.TRUE, result.value);\n+        \n+        // then verify other scalars\n+        json = m.writeValueAsString(new AbstractWrapper(Long.valueOf(7L)));\n+        result = m.readValue(json, AbstractWrapper.class);\n+        assertEquals(Long.valueOf(7), result.value);\n+\n+        json = m.writeValueAsString(new AbstractWrapper(TestEnum.B));\n+        result = m.readValue(json, AbstractWrapper.class);\n+        assertEquals(TestEnum.B, result.value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypes.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+public class TestSubtypes extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME)\n+    static abstract class SuperType {\n+    }\n+\n+    @JsonTypeName(\"TypeB\")\n+    static class SubB extends SuperType {\n+        public int b = 1;\n+    }\n+\n+    static class SubC extends SuperType {\n+        public int c = 2;\n+    }\n+\n+    static class SubD extends SuperType {\n+        public int d;\n+    }\n+\n+    // \"Empty\" bean, to test [JACKSON-366]\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME)\n+    static abstract class BaseBean { }\n+    \n+    static class EmptyBean extends BaseBean { }\n+\n+    static class EmptyNonFinal { }\n+\n+    // Verify combinations with [JACKSON-510]\n+\n+    static class PropertyBean\n+    {\n+        @JsonTypeInfo(use=JsonTypeInfo.Id.NAME)\n+        public SuperType value;\n+        \n+        public PropertyBean() { this(null); }\n+        public PropertyBean(SuperType v) { value = v; }\n+    }\n+\n+    // And then [JACKSON-614]\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=As.PROPERTY,\n+            property=\"#type\",\n+            defaultImpl=DefaultImpl.class)\n+    static abstract class SuperTypeWithDefault { }\n+\n+    static class DefaultImpl extends SuperTypeWithDefault {\n+        public int a;\n+    }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=As.PROPERTY, property=\"#type\")\n+    static abstract class SuperTypeWithoutDefault { }\n+\n+    static class DefaultImpl505 extends SuperTypeWithoutDefault {\n+        public int a;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    // JACKSON-510\n+    public void testPropertyWithSubtypes() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // must register subtypes\n+        mapper.registerSubtypes(SubB.class, SubC.class, SubD.class);\n+        String json = mapper.writeValueAsString(new PropertyBean(new SubC()));\n+        PropertyBean result = mapper.readValue(json, PropertyBean.class);\n+        assertSame(SubC.class, result.value.getClass());\n+    }\n+\n+    public void testSerialization() throws Exception\n+    {\n+        // serialization can detect type name ok without anything extra:\n+        SubB bean = new SubB();\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"{\\\"@type\\\":\\\"TypeB\\\",\\\"b\\\":1}\", mapper.writeValueAsString(bean));\n+\n+        // but we can override type name here too\n+        mapper = new ObjectMapper();\n+        mapper.registerSubtypes(new NamedType(SubB.class, \"typeB\"));\n+        assertEquals(\"{\\\"@type\\\":\\\"typeB\\\",\\\"b\\\":1}\", mapper.writeValueAsString(bean));\n+\n+        // and default name ought to be simple class name; with context\n+        assertEquals(\"{\\\"@type\\\":\\\"TestSubtypes$SubD\\\",\\\"d\\\":0}\", mapper.writeValueAsString(new SubD()));  \n+    }\n+\n+    public void testDeserializationNonNamed() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerSubtypes(SubC.class);\n+\n+        // default name should be unqualified class name\n+        SuperType bean = mapper.readValue(\"{\\\"@type\\\":\\\"TestSubtypes$SubC\\\", \\\"c\\\":1}\", SuperType.class);\n+        assertSame(SubC.class, bean.getClass());\n+        assertEquals(1, ((SubC) bean).c);\n+    }\n+\n+    public void testDeserializatioNamed() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerSubtypes(SubB.class);\n+        mapper.registerSubtypes(new NamedType(SubD.class, \"TypeD\"));\n+\n+        SuperType bean = mapper.readValue(\"{\\\"@type\\\":\\\"TypeB\\\", \\\"b\\\":13}\", SuperType.class);\n+        assertSame(SubB.class, bean.getClass());\n+        assertEquals(13, ((SubB) bean).b);\n+\n+        // but we can also explicitly register name too\n+        bean = mapper.readValue(\"{\\\"@type\\\":\\\"TypeD\\\", \\\"d\\\":-4}\", SuperType.class);\n+        assertSame(SubD.class, bean.getClass());\n+        assertEquals(-4, ((SubD) bean).d);\n+    }\n+\n+    // Trying to reproduce [JACKSON-366]\n+    public void testEmptyBean() throws Exception\n+    {\n+        // First, with annotations\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, true);\n+        String json = mapper.writeValueAsString(new EmptyBean());\n+        assertEquals(\"{\\\"@type\\\":\\\"TestSubtypes$EmptyBean\\\"}\", json);\n+\n+        mapper = new ObjectMapper();\n+        mapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        json = mapper.writeValueAsString(new EmptyBean());\n+        assertEquals(\"{\\\"@type\\\":\\\"TestSubtypes$EmptyBean\\\"}\", json);\n+\n+        // and then with defaults\n+        mapper = new ObjectMapper();\n+        mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n+        mapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        json = mapper.writeValueAsString(new EmptyNonFinal());\n+        assertEquals(\"[\\\"org.codehaus.jackson.map.jsontype.TestSubtypes$EmptyNonFinal\\\",{}]\", json);\n+    }\n+\n+    public void testDefaultImpl() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // first, test with no type information\n+        SuperTypeWithDefault bean = mapper.readValue(\"{\\\"a\\\":13}\", SuperTypeWithDefault.class);\n+        assertEquals(DefaultImpl.class, bean.getClass());\n+        assertEquals(13, ((DefaultImpl) bean).a);\n+\n+        // and then with unmapped info\n+        bean = mapper.readValue(\"{\\\"a\\\":14,\\\"#type\\\":\\\"foobar\\\"}\", SuperTypeWithDefault.class);\n+        assertEquals(DefaultImpl.class, bean.getClass());\n+        assertEquals(14, ((DefaultImpl) bean).a);\n+\n+        bean = mapper.readValue(\"{\\\"#type\\\":\\\"foobar\\\",\\\"a\\\":15}\", SuperTypeWithDefault.class);\n+        assertEquals(DefaultImpl.class, bean.getClass());\n+        assertEquals(15, ((DefaultImpl) bean).a);\n+\n+        bean = mapper.readValue(\"{\\\"#type\\\":\\\"foobar\\\"}\", SuperTypeWithDefault.class);\n+        assertEquals(DefaultImpl.class, bean.getClass());\n+        assertEquals(0, ((DefaultImpl) bean).a);\n+    }\n+\n+    // [JACKSON-505]: ok to also default to mapping there might be for base type\n+    public void testDefaultImplViaModule() throws Exception\n+    {\n+        final String JSON = \"{\\\"a\\\":123}\";\n+        \n+        // first: without registration etc, epic fail:\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.readValue(JSON, SuperTypeWithoutDefault.class);\n+            fail(\"Expected an exception\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"missing property\");\n+        }\n+\n+        // but then succeed when we register default impl\n+        mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addAbstractTypeMapping(SuperTypeWithoutDefault.class, DefaultImpl505.class);\n+        mapper.registerModule(module);\n+        SuperTypeWithoutDefault bean = mapper.readValue(JSON, SuperTypeWithoutDefault.class);\n+        assertNotNull(bean);\n+        assertEquals(DefaultImpl505.class, bean.getClass());\n+        assertEquals(123, ((DefaultImpl505) bean).a);\n+\n+        bean = mapper.readValue(\"{\\\"#type\\\":\\\"foobar\\\"}\", SuperTypeWithoutDefault.class);\n+        assertEquals(DefaultImpl505.class, bean.getClass());\n+        assertEquals(0, ((DefaultImpl505) bean).a);\n+    \n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypeNames.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Separate tests for verifying that \"type name\" type id mechanism\n+ * works.\n+ * \n+ * @author tatu\n+ */\n+public class TestTypeNames extends BaseMapTest\n+{\n+    @SuppressWarnings(\"serial\")\n+    static class AnimalMap extends LinkedHashMap<String,Animal> { }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testSerialization() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+\n+        // Note: need to use wrapper array just so that we can define\n+        // static type on serialization. If we had root static types,\n+        // could use those; but at the moment root type is dynamic\n+        \n+        assertEquals(\"[{\\\"doggy\\\":{\\\"name\\\":\\\"Spot\\\",\\\"ageInYears\\\":3}}]\",\n+                m.writeValueAsString(new Animal[] { new Dog(\"Spot\", 3) }));\n+        assertEquals(\"[{\\\"MaineCoon\\\":{\\\"name\\\":\\\"Belzebub\\\",\\\"purrs\\\":true}}]\",\n+                m.writeValueAsString(new Animal[] { new MaineCoon(\"Belzebub\", true)}));\n+    }\n+\n+    public void testRoundTrip() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Animal[] input = new Animal[] {\n+                new Dog(\"Odie\", 7),\n+                null,\n+                new MaineCoon(\"Piru\", false),\n+                new Persian(\"Khomeini\", true)\n+        };\n+        String json = m.writeValueAsString(input);\n+        List<Animal> output = m.readValue(json,\n+                TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, Animal.class));\n+        assertEquals(input.length, output.size());\n+        for (int i = 0, len = input.length; i < len; ++i) {\n+            assertEquals(\"Entry #\"+i+\" differs, input = '\"+json+\"'\",\n+                input[i], output.get(i));\n+        }\n+    }\n+\n+    public void testRoundTripMap() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        AnimalMap input = new AnimalMap();\n+        input.put(\"venla\", new MaineCoon(\"Venla\", true));\n+        input.put(\"ama\", new Dog(\"Amadeus\", 13));\n+        String json = m.writeValueAsString(input);\n+        AnimalMap output = m.readValue(json, AnimalMap.class);\n+        assertEquals(input, output);\n+    }\n+}\n+\n+/*\n+/**********************************************************\n+/* Helper types\n+/**********************************************************\n+ */\n+\n+@JsonTypeInfo(use=Id.NAME, include=As.WRAPPER_OBJECT)\n+@JsonSubTypes({\n+    @Type(value=Dog.class, name=\"doggy\"),\n+    @Type(Cat.class) /* defaults to \"TestTypedNames$Cat\" then */\n+})\n+class Animal\n+{\n+    public String name;\n+\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) return false;\n+        return name.equals(((Animal) o).name);\n+    }\n+\n+}\n+\n+class Dog extends Animal\n+{\n+    public int ageInYears;\n+\n+    public Dog() { }\n+    public Dog(String n, int y) {\n+        name = n;\n+        ageInYears = y;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return super.equals(o)\n+            && ((Dog) o).ageInYears == ageInYears;\n+    }\n+}\n+\n+@JsonSubTypes({\n+    @Type(MaineCoon.class),\n+    @Type(Persian.class)\n+})\n+abstract class Cat extends Animal {\n+    public boolean purrs;\n+    public Cat() { }\n+    public Cat(String n, boolean p) {\n+        name = n;\n+        purrs = p;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        return super.equals(o) && ((Cat) o).purrs == purrs;\n+    }\n+}\n+\n+/* uses default name (\"MaineCoon\") since there's no @JsonTypeName,\n+ * nor did supertype specify name\n+ */\n+class MaineCoon extends Cat {\n+    public MaineCoon() { super(); }\n+    public MaineCoon(String n, boolean p) {\n+        super(n, p);\n+    }\n+}\n+\n+@JsonTypeName(\"persialaisKissa\")\n+class Persian extends Cat {\n+    public Persian() { super(); }\n+    public Persian(String n, boolean p) {\n+        super(n, p);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArrayDeserialization.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+public class TestTypedArrayDeserialization\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Let's claim we need type here too (although we won't\n+     * really use any sub-classes)\n+     */\n+    @SuppressWarnings(\"serial\")\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)\n+    static class TypedList<T> extends ArrayList<T> { }\n+\n+    @SuppressWarnings(\"serial\")\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)\n+    static class TypedListAsProp<T> extends ArrayList<T> { }\n+    \n+    @SuppressWarnings(\"serial\")\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n+    static class TypedListAsWrapper<T> extends LinkedList<T> { }\n+    \n+    // Mix-in to force wrapper for things like primitive arrays\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n+    interface WrapperMixIn { }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests, Lists\n+    /**********************************************************\n+     */\n+    \n+    public void testIntList() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // uses WRAPPER_OBJECT inclusion\n+        String JSON = \"{\\\"\"+TypedListAsWrapper.class.getName()+\"\\\":[4,5, 6]}\";\n+        JavaType type = TypeFactory.defaultInstance().constructCollectionType(TypedListAsWrapper.class, Integer.class);        \n+        TypedListAsWrapper<Integer> result = m.readValue(JSON, type);\n+        assertNotNull(result);\n+        assertEquals(3, result.size());\n+        assertEquals(Integer.valueOf(4), result.get(0));\n+        assertEquals(Integer.valueOf(5), result.get(1));\n+        assertEquals(Integer.valueOf(6), result.get(2));\n+    }\n+\n+    /**\n+     * Similar to above, but this time let's request adding type info\n+     * as property. That would not work (since there's no JSON Object to\n+     * add property in), so it will basically be same as using WRAPPER_ARRAY\n+     */\n+    public void testBooleanListAsProp() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // tries to use PROPERTY inclusion; but for ARRAYS (and scalars) will become ARRAY_WRAPPER\n+        String JSON = \"[\\\"\"+TypedListAsProp.class.getName()+\"\\\",[true, false]]\";\n+        JavaType type = TypeFactory.defaultInstance().constructCollectionType(TypedListAsProp.class, Boolean.class);        \n+        TypedListAsProp<Object> result = m.readValue(JSON, type);\n+        assertNotNull(result);\n+        assertEquals(2, result.size());\n+        assertEquals(Boolean.TRUE, result.get(0));\n+        assertEquals(Boolean.FALSE, result.get(1));\n+    }\n+\n+    public void testLongListAsWrapper() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // uses OBJECT_ARRAY, works just fine\n+        \n+        String JSON = \"{\\\"\"+TypedListAsWrapper.class.getName()+\"\\\":[1, 3]}\";\n+        JavaType type = TypeFactory.defaultInstance().constructCollectionType(TypedListAsWrapper.class, Long.class);        \n+        TypedListAsWrapper<Object> result = m.readValue(JSON, type);\n+        assertNotNull(result);\n+        assertEquals(2, result.size());\n+\n+        assertEquals(Long.class, result.get(0).getClass());\n+        assertEquals(Long.valueOf(1), result.get(0));\n+        assertEquals(Long.class, result.get(1).getClass());\n+        assertEquals(Long.valueOf(3), result.get(1));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests, primitive arrays\n+    /**********************************************************\n+     */\n+\n+    public void testLongArray() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // use class name, WRAPPER_OBJECT\n+        m.getDeserializationConfig().addMixInAnnotations(long[].class, WrapperMixIn.class);\n+        String JSON = \"{\\\"\"+long[].class.getName()+\"\\\":[5, 6, 7]}\";\n+        long[] value = m.readValue(JSON, long[].class);\n+        assertNotNull(value);\n+        assertEquals(3, value.length);\n+        assertArrayEquals(new long[] { 5L, 6L, 7L} , value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedArraySerialization.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for verifying that types that serialize as JSON Arrays\n+ * get properly serialized with types (esp. for contents, and\n+ * gracefully handling Lists themselves too)\n+ * \n+ * @author tatus\n+ * @since 1.5\n+ */\n+public class TestTypedArraySerialization\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Let's claim we need type here too (although we won't\n+     * really use any sub-classes)\n+     */\n+    @SuppressWarnings(\"serial\")\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_ARRAY)\n+    static class TypedList<T> extends ArrayList<T> { }\n+\n+    @SuppressWarnings(\"serial\")\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)\n+    static class TypedListAsProp<T> extends ArrayList<T> { }\n+    \n+    @SuppressWarnings(\"serial\")\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n+    static class TypedListAsWrapper<T> extends LinkedList<T> { }\n+    \n+    // Mix-in to force wrapper for things like primitive arrays\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n+    interface WrapperMixIn { }\n+\n+    // for [JACKSON-341]\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n+    @JsonSubTypes({ @JsonSubTypes.Type(B.class) })\n+    interface A { }\n+\n+    @JsonTypeName(\"BB\")\n+    static class B implements A {\n+        public int value = 2;\n+    }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.NAME, include=JsonTypeInfo.As.PROPERTY)\n+    @JsonTypeName(\"bean\")\n+    static class Bean {\n+        public int x = 0;\n+    }\n+\n+    static class BeanListWrapper {\n+        @JsonView({Object.class})\n+        public List<Bean> beans = new ArrayList<Bean>();\n+        {\n+            beans.add(new Bean());\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests, Lists\n+    /**********************************************************\n+     */\n+\n+    public void testListWithPolymorphic() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        BeanListWrapper beans = new BeanListWrapper();\n+        assertEquals(\"{\\\"beans\\\":[{\\\"@type\\\":\\\"bean\\\",\\\"x\\\":0}]}\", mapper.writeValueAsString(beans));\n+        // Related to [JACKSON-364]\n+        ObjectWriter w = mapper.writerWithView(Object.class);\n+        assertEquals(\"{\\\"beans\\\":[{\\\"@type\\\":\\\"bean\\\",\\\"x\\\":0}]}\", w.writeValueAsString(beans));\n+    }\n+    \n+    public void testIntList() throws Exception\n+    {\n+        TypedList<Integer> input = new TypedList<Integer>();\n+        input.add(5);\n+        input.add(13);\n+        // uses WRAPPER_ARRAY inclusion:\n+        assertEquals(\"[\\\"\"+TypedList.class.getName()+\"\\\",[5,13]]\", serializeAsString(input));\n+    }\n+    \n+    // Similar to above, but this time let's request adding type info\n+    // as property. That would not work (since there's no JSON Object to\n+    // add property in), so it should revert to method used with\n+    // ARRAY_WRAPPER method.\n+    public void testStringListAsProp() throws Exception\n+    {\n+        TypedListAsProp<String> input = new TypedListAsProp<String>();\n+        input.add(\"a\");\n+        input.add(\"b\");\n+        assertEquals(\"[\\\"\"+TypedListAsProp.class.getName()+\"\\\",[\\\"a\\\",\\\"b\\\"]]\",\n+                serializeAsString(input));\n+    }\n+\n+    public void testStringListAsObjectWrapper() throws Exception\n+    {\n+        TypedListAsWrapper<Boolean> input = new TypedListAsWrapper<Boolean>();\n+        input.add(true);\n+        input.add(null);\n+        input.add(false);\n+        // Can wrap in JSON Object for wrapped style... also, will use\n+        // non-qualified class name as type name, since there are no\n+        // annotations\n+        String expName = \"TestTypedArraySerialization$TypedListAsWrapper\";\n+        assertEquals(\"{\\\"\"+expName+\"\\\":[true,null,false]}\",\n+                serializeAsString(input));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests, primitive arrays\n+    /**********************************************************\n+     */\n+\n+    public void testIntArray() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getSerializationConfig().addMixInAnnotations(int[].class, WrapperMixIn.class);\n+        int[] input = new int[] { 1, 2, 3 };\n+        String clsName = int[].class.getName();\n+        assertEquals(\"{\\\"\"+clsName+\"\\\":[1,2,3]}\", serializeAsString(m, input));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests, generic arrays\n+    /**********************************************************\n+     */\n+\n+    public void testGenericArray() throws Exception\n+    {\n+        ObjectMapper m;\n+        final A[] input = new A[] { new B() };\n+        final String EXP = \"[{\\\"BB\\\":{\\\"value\\\":2}}]\";\n+\n+        // first, with defaults\n+        m = new ObjectMapper();\n+        assertEquals(EXP, m.writeValueAsString(input));\n+\n+        // then with static typing enabled:\n+        m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        assertEquals(EXP, m.writeValueAsString(input));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedContainerSerialization.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import org.junit.Assert;\n+\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+public class TestTypedContainerSerialization\n+\textends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    @JsonTypeInfo(use = Id.NAME, include = As.PROPERTY, property = \"object-type\")\n+    @JsonSubTypes( { @Type(value = Dog.class, name = \"doggy\"),\n+        @Type(value = Cat.class, name = \"kitty\") })\n+    static abstract class Animal {\n+\t    public String name;\n+\n+\t    protected Animal(String n) {\n+\t        name = n;\n+\t    }\n+\t}\n+\n+\t@JsonTypeName(\"doggie\")\n+\tstatic class Dog extends Animal {\n+\t\tpublic int boneCount;\n+\n+\t\tpublic Dog() {\n+\t\t\tsuper(null);\n+\t\t}\n+\n+\t\t@JsonCreator\n+\t\tpublic Dog(@JsonProperty(\"name\") String name) {\n+\t\t\tsuper(name);\n+\t\t}\n+\n+\t\tpublic void setBoneCount(int i) {\n+\t\t\tboneCount = i;\n+\t\t}\n+\t}\n+\n+\t@JsonTypeName(\"kitty\")\n+\tstatic class Cat extends Animal {\n+\t\tpublic String furColor;\n+\n+\t\tpublic Cat() {\n+\t\t\tsuper(null);\n+\t\t}\n+\n+\t\t@JsonCreator\n+\t\tpublic Cat(@JsonProperty(\"furColor\") String c) {\n+\t\t\tsuper(null);\n+\t\t\tfurColor = c;\n+\t\t}\n+\n+\t\tpublic void setName(String n) {\n+\t\t\tname = n;\n+\t\t}\n+\t}\n+\n+\tstatic class Container1 {\n+\t\tAnimal animal;\n+\n+\t\tpublic Animal getAnimal() {\n+\t\t\treturn animal;\n+\t\t}\n+\n+\t\tpublic void setAnimal(Animal animal) {\n+\t\t\tthis.animal = animal;\n+\t\t}\n+\t}\n+\n+\tstatic class Container2<T extends Animal> {\n+\t\t@JsonSerialize\n+\t\tT animal;\n+\n+\t\tpublic T getAnimal() {\n+\t\t\treturn animal;\n+\t\t}\n+\n+\t\tpublic void setAnimal(T animal) {\n+\t\t\tthis.animal = animal;\n+\t\t}\n+\n+\t}\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property=\"@class\")\n+    static class Issue508A { }\n+    static class Issue508B extends Issue508A { }\n+\n+    private final static ObjectMapper mapper = new ObjectMapper();\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\t\n+    public void testIssue265() throws Exception\n+    {\n+\t\tDog dog = new Dog(\"medor\");\n+\t\tdog.setBoneCount(3);\n+\t\tContainer1 c1 = new Container1();\n+\t\tc1.setAnimal(dog);\n+\t\tString s1 = mapper.writeValueAsString(c1);\n+\t\tAssert.assertTrue(\"polymorphic type info is kept (1)\", s1\n+\t\t\t\t.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") >= 0);\n+\t\tContainer2<Animal> c2 = new Container2<Animal>();\n+\t\tc2.setAnimal(dog);\n+\t\tString s2 = mapper.writeValueAsString(c2);\n+\t\tAssert.assertTrue(\"polymorphic type info is kept (2)\", s2\n+\t\t\t\t.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") >= 0);\n+    }\n+\n+    public void testIssue329() throws Exception\n+    {\n+            ArrayList<Animal> animals = new ArrayList<Animal>();\n+            animals.add(new Dog(\"Spot\"));\n+            JavaType rootType = TypeFactory.defaultInstance().constructParametricType(Iterator.class, Animal.class);\n+            String json = mapper.writerWithType(rootType).writeValueAsString(animals.iterator());\n+            if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n+                fail(\"No polymorphic type retained, should be; JSON = '\"+json+\"'\");\n+            }\n+    }\n+\n+    public void testIssue508() throws Exception\n+    {\n+            List<List<Issue508A>> l = new ArrayList<List<Issue508A>>();\n+            List<Issue508A> l2 = new ArrayList<Issue508A>();\n+            l2.add(new Issue508A());\n+            l.add(l2);\n+            TypeReference<?> typeRef = new TypeReference<List<List<Issue508A>>>() {};\n+            String json = mapper.writerWithType(typeRef).writeValueAsString(l);\n+\n+            List<?> output = mapper.readValue(json, typeRef);\n+            assertEquals(1, output.size());\n+            Object ob = output.get(0);\n+            assertTrue(ob instanceof List<?>);\n+            List<?> list2 = (List<?>) ob;\n+            assertEquals(1, list2.size());\n+            ob = list2.get(0);\n+            assertSame(Issue508A.class, ob.getClass());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedDeserialization.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+public class TestTypedDeserialization\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Polymorphic base class\n+     */\n+    @JsonTypeInfo(use=Id.CLASS, include=As.PROPERTY, property=\"@classy\")\n+    static abstract class Animal {\n+        public String name;\n+        \n+        protected Animal(String n)  { name = n; }\n+    }\n+\n+    @JsonTypeName(\"doggie\")\n+    static class Dog extends Animal\n+    {\n+        public int boneCount;\n+        \n+        @JsonCreator\n+        public Dog(@JsonProperty(\"name\") String name) {\n+            super(name);\n+        }\n+\n+        public void setBoneCount(int i) { boneCount = i; }\n+    }\n+    \n+    @JsonTypeName(\"kitty\")\n+    static class Cat extends Animal\n+    {\n+        public String furColor;\n+\n+        @JsonCreator\n+        public Cat(@JsonProperty(\"furColor\") String c) {\n+            super(null);\n+            furColor = c;\n+        }\n+\n+        public void setName(String n) { name = n; }\n+    }\n+\n+    // for [JACKSON-319] -- allow \"empty\" beans\n+    @JsonTypeName(\"fishy\")\n+    static class Fish extends Animal\n+    {\n+        @JsonCreator\n+        public Fish()\n+        {\n+            super(null);\n+        }\n+    }\n+\n+    static class AnimalContainer {\n+        public Animal animal;\n+    }\n+\n+    // base class with no useful info\n+    @JsonTypeInfo(use=Id.CLASS, include=As.WRAPPER_ARRAY)\n+    static abstract class DummyBase {\n+        protected DummyBase(boolean foo) { }\n+    }\n+\n+    static class DummyImpl extends DummyBase {\n+        public int x;\n+\n+        public DummyImpl() { super(true); }\n+    }\n+    \n+    @JsonTypeInfo(use=Id.MINIMAL_CLASS, include=As.WRAPPER_OBJECT)\n+    interface TypeWithWrapper { }\n+\n+    @JsonTypeInfo(use=Id.CLASS, include=As.WRAPPER_ARRAY)\n+    interface TypeWithArray { }\n+\n+    static class Issue506DateBean {\n+        @JsonTypeInfo(use = Id.NAME, include = As.PROPERTY, property = \"type2\")\n+        public Date date;\n+    }\n+        \n+    static class Issue506NumberBean\n+    {\n+        @JsonTypeInfo(use = Id.NAME, include = As.PROPERTY, property = \"type3\")\n+        @JsonSubTypes({ @Type(Long.class),\n+            @Type(Integer.class) })\n+        public Number number;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * First things first, let's ensure we can serialize using\n+     * class name, written as main-level property name\n+     */\n+    public void testSimpleClassAsProperty() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Animal a = m.readValue(asJSONObjectValueString(\"@classy\", Cat.class.getName(),\n+                \"furColor\", \"tabby\", \"name\", \"Garfield\"), Animal.class);\n+        assertNotNull(a);\n+        assertEquals(Cat.class, a.getClass());\n+        Cat c = (Cat) a;\n+        assertEquals(\"Garfield\", c.name);\n+        assertEquals(\"tabby\", c.furColor);\n+    }\n+\n+    // Test inclusion using wrapper style\n+    public void testTypeAsWrapper() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getDeserializationConfig().addMixInAnnotations(Animal.class, TypeWithWrapper.class);\n+        String JSON = \"{\\\".TestTypedDeserialization$Dog\\\" : \"\n+            +asJSONObjectValueString(m, \"name\", \"Scooby\", \"boneCount\", \"6\")+\" }\";\n+        Animal a = m.readValue(JSON, Animal.class);\n+        assertTrue(a instanceof Animal);\n+        assertEquals(Dog.class, a.getClass());\n+        Dog d = (Dog) a;\n+        assertEquals(\"Scooby\", d.name);\n+        assertEquals(6, d.boneCount);\n+    }\n+\n+    // Test inclusion using 2-element array\n+    public void testTypeAsArray() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getDeserializationConfig().addMixInAnnotations(Animal.class, TypeWithArray.class);\n+        // hmmh. Not good idea to rely on exact output, order may change. But...\n+        String JSON = \"[\\\"\"+Dog.class.getName()+\"\\\", \"\n+            +asJSONObjectValueString(m, \"name\", \"Martti\", \"boneCount\", \"11\")+\" ]\";\n+        Animal a = m.readValue(JSON, Animal.class);\n+        assertEquals(Dog.class, a.getClass());\n+        Dog d = (Dog) a;\n+        assertEquals(\"Martti\", d.name);\n+        assertEquals(11, d.boneCount);\n+    }\n+\n+    // Use basic Animal as contents of a regular List\n+    public void testListAsArray() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // This time using PROPERTY style (default) again\n+        String JSON = \"[\\n\"\n+            +asJSONObjectValueString(m, \"@classy\", Cat.class.getName(), \"name\", \"Hello\", \"furColor\", \"white\")\n+            +\",\\n\"\n+            // let's shuffle doggy's fields a bit for testing\n+            +asJSONObjectValueString(m,\n+                                     \"boneCount\", Integer.valueOf(1),\n+                                     \"@classy\", Dog.class.getName(),\n+                                     \"name\", \"Bob\"\n+                                     )\n+            +\",\\n\"\n+            +asJSONObjectValueString(m, \"@classy\", Fish.class.getName())\n+            +\", null\\n]\";\n+        \n+        JavaType expType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, Animal.class);\n+        List<Animal> animals = m.readValue(JSON, expType);\n+        assertNotNull(animals);\n+        assertEquals(4, animals.size());\n+        Cat c = (Cat) animals.get(0);\n+        assertEquals(\"Hello\", c.name);\n+        assertEquals(\"white\", c.furColor);\n+        Dog d = (Dog) animals.get(1);\n+        assertEquals(\"Bob\", d.name);\n+        assertEquals(1, d.boneCount);\n+        Fish f = (Fish) animals.get(2);\n+        assertNotNull(f);\n+        assertNull(animals.get(3));\n+    }\n+\n+    public void testCagedAnimal() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        String jsonCat = asJSONObjectValueString(m, \"@classy\", Cat.class.getName(), \"name\", \"Nilson\", \"furColor\", \"black\");\n+        String JSON = \"{\\\"animal\\\":\"+jsonCat+\"}\";\n+\n+        AnimalContainer cont = m.readValue(JSON, AnimalContainer.class);\n+        assertNotNull(cont);\n+        Animal a = cont.animal;\n+        assertNotNull(a);\n+        Cat c = (Cat) a;\n+        assertEquals(\"Nilson\", c.name);\n+        assertEquals(\"black\", c.furColor);\n+    }\n+\n+    /**\n+     * Test that verifies that there are few limitations on polymorphic\n+     * base class.\n+     */\n+    public void testAbstractEmptyBaseClass() throws Exception\n+    {\n+        DummyBase result = new ObjectMapper().readValue(\n+                \"[\\\"\"+DummyImpl.class.getName()+\"\\\",{\\\"x\\\":3}]\", DummyBase.class);\n+        assertNotNull(result);\n+        assertEquals(DummyImpl.class, result.getClass());\n+        assertEquals(3, ((DummyImpl) result).x);\n+    }\n+\n+    // [JACKSON-506], wrt Date\n+    public void testIssue506WithDate() throws Exception\n+    {\n+        Issue506DateBean input = new Issue506DateBean();\n+        input.date = new Date(1234L);\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(input);\n+\n+        Issue506DateBean output = mapper.readValue(json, Issue506DateBean.class);\n+        assertEquals(input.date, output.date);\n+    }\n+    \n+    // [JACKSON-506], wrt Number\n+    public void testIssue506WithNumber() throws Exception\n+    {\n+        Issue506NumberBean input = new Issue506NumberBean();\n+        input.number = Long.valueOf(4567L);\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(input);\n+\n+        Issue506NumberBean output = mapper.readValue(json, Issue506NumberBean.class);\n+        assertEquals(input.number, output.number);\n+    }\n+}\n+\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestTypedSerialization.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.*;\n+\n+import static com.fasterxml.jackson.annotation.JsonTypeInfo.*;\n+\n+public class TestTypedSerialization\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Polymorphic base class\n+     */\n+    @JsonTypeInfo(use=Id.CLASS, include=As.PROPERTY)\n+    static abstract class Animal {\n+        public String name;\n+        \n+        protected Animal(String n)  { name = n; }\n+    }\n+\n+    @JsonTypeName(\"doggie\")\n+    static class Dog extends Animal\n+    {\n+        public int boneCount;\n+        \n+        private Dog() { super(null); }\n+        public Dog(String name, int b) {\n+            super(name);\n+            boneCount = b;\n+        }\n+    }\n+    \n+    @JsonTypeName(\"kitty\")\n+    static class Cat extends Animal\n+    {\n+        public String furColor;\n+        \n+        private Cat() { super(null); }\n+        public Cat(String name, String c) {\n+            super(name);\n+            furColor = c;\n+        }\n+    }\n+\n+    public class AnimalWrapper {\n+        public Animal animal;\n+        \n+        public AnimalWrapper(Animal a) { animal = a; }\n+    }\n+\n+    @JsonTypeInfo(use=Id.MINIMAL_CLASS, include=As.WRAPPER_OBJECT)\n+    interface TypeWithWrapper { }\n+\n+    @JsonTypeInfo(use=Id.CLASS, include=As.WRAPPER_ARRAY)\n+    interface TypeWithArray { }\n+\n+    @JsonTypeInfo(use=Id.NAME)\n+    @JsonTypeName(\"empty\")\n+    public class Empty { }\n+\n+    @JsonTypeInfo(include=As.PROPERTY, use=Id.CLASS)\n+    public class Super {}\n+    public class A extends Super {}\n+    public class B extends Super {}\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * First things first, let's ensure we can serialize using\n+     * class name, written as main-level property name\n+     */\n+    public void testSimpleClassAsProperty() throws Exception\n+    {\n+        Map<String,Object> result = writeAndMap(new Cat(\"Beelzebub\", \"tabby\"));\n+        assertEquals(3, result.size());\n+        assertEquals(\"Beelzebub\", result.get(\"name\"));\n+        assertEquals(\"tabby\", result.get(\"furColor\"));\n+        // should we try customized class name?\n+        String classProp = Id.CLASS.getDefaultPropertyName();\n+        assertEquals(Cat.class.getName(), result.get(classProp));\n+    }\n+\n+    /**\n+     * Test inclusion using wrapper style\n+     */\n+    public void testTypeAsWrapper() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getSerializationConfig().addMixInAnnotations(Animal.class, TypeWithWrapper.class);\n+        Map<String,Object> result = writeAndMap(m, new Cat(\"Venla\", \"black\"));\n+        // should get a wrapper; keyed by minimal class name (\"Cat\" here)\n+        assertEquals(1, result.size());\n+        // minimal class name is prefixed by dot, and for inner classes it's bit longer\n+        Map<?,?> cat = (Map<?,?>) result.get(\".TestTypedSerialization$Cat\");\n+        assertNotNull(cat);\n+        assertEquals(2, cat.size());\n+        assertEquals(\"Venla\", cat.get(\"name\"));\n+        assertEquals(\"black\", cat.get(\"furColor\"));\n+    }\n+\n+    /**\n+     * Test inclusion using 2-element array\n+     */\n+    public void testTypeAsArray() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getSerializationConfig().addMixInAnnotations(Animal.class, TypeWithArray.class);\n+        // hmmh. Not good idea to rely on exact output, order may change. But...\n+        Map<String,Object> result = writeAndMap(m, new AnimalWrapper(new Dog(\"Amadeus\", 7)));\n+        // First level, wrapper\n+        assertEquals(1, result.size());\n+        List<?> l = (List<?>) result.get(\"animal\");\n+        assertNotNull(l);\n+        assertEquals(2, l.size());\n+        assertEquals(Dog.class.getName(), l.get(0));\n+        Map<?,?> doggie = (Map<?,?>) l.get(1);\n+        assertNotNull(doggie);\n+        assertEquals(2, doggie.size());\n+        assertEquals(\"Amadeus\", doggie.get(\"name\"));\n+        assertEquals(Integer.valueOf(7), doggie.get(\"boneCount\"));\n+    }\n+\n+    /* !!! 30-Jan-2010, tatus: I am not completely sure below works as it should\n+     *    Problem is, context of \"untyped\" map should prevent type information\n+     *    being added to Animal entries, because Object.class has no type.\n+     *    If type information is included, it will not be useful for deserialization,\n+     *    since static type does not carry through (unlike in serialization).\n+     *    \n+     *    But it is not quite clear how type information should be pushed through\n+     *    array types...\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testInArray() throws Exception\n+    {\n+        // ensure we'll use mapper with default configs\n+        ObjectMapper m = new ObjectMapper();\n+        // ... so this should NOT be needed...\n+        m.disableDefaultTyping();\n+        \n+        Animal[] animals = new Animal[] { new Cat(\"Miuku\", \"white\"), new Dog(\"Murre\", 9) };\n+        Map<String,Object> map = new HashMap<String,Object>();\n+        map.put(\"a\", animals);\n+        String json = m.writeValueAsString(map);\n+        Map<String,Object> result = m.readValue(json, Map.class);\n+        assertEquals(1, result.size());\n+        Object ob = result.get(\"a\");\n+        if (!(ob instanceof List<?>)) {\n+            // 03-Feb-2010, tatu: Weird; seems to fail sometimes...\n+            fail(\"Did not map to entry with 'a' as List (but as \"+ob.getClass().getName()+\"): JSON == '\"+json+\"'\");\n+        }\n+        List<?> l = (List<?>)ob;\n+        assertNotNull(l);\n+        assertEquals(2, l.size());\n+        Map<?,?> a1 = (Map<?,?>) l.get(0);\n+        assertEquals(3, a1.size());\n+        String classProp = Id.CLASS.getDefaultPropertyName();\n+        assertEquals(Cat.class.getName(), a1.get(classProp));\n+        Map<?,?> a2 = (Map<?,?>) l.get(1);\n+        assertEquals(3, a2.size());\n+        assertEquals(Dog.class.getName(), a2.get(classProp));\n+    }\n+\n+    /**\n+     * Simple unit test to verify that serializing \"empty\" beans is ok\n+     */\n+    public void testEmptyBean() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        assertEquals(\"{\\\"@type\\\":\\\"empty\\\"}\", m.writeValueAsString(new Empty()));\n+    }\n+\n+    /**\n+     * Unit test for [JACKSON-543]\n+     */\n+    public void testTypedMaps() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        Map<Long, Collection<Super>> map = new HashMap<Long, Collection<Super>>();\n+        List<Super> list = new ArrayList<Super>();\n+        list.add(new A());\n+        map.put(1L, list);\n+        String json = mapper.writerWithType(new TypeReference<Map<Long, Collection<Super>>>() {}).writeValueAsString(map);\n+        assertTrue(json, json.contains(\"@class\"));\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonSubTypes.Type;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n+import com.fasterxml.jackson.databind.ser.BeanSerializerFactory;\n+import com.fasterxml.jackson.databind.ser.ResolvableSerializer;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+public class TestWithGenerics extends BaseMapTest\n+{\n+    @JsonTypeInfo(use = Id.NAME, include = As.PROPERTY, property = \"object-type\")\n+    @JsonSubTypes( { @Type(value = Dog.class, name = \"doggy\") })\n+    static abstract class Animal {\n+        public String name;\n+    }    \n+\n+    static class Dog extends Animal {\n+        public int boneCount;\n+\n+        public Dog(String name, int b) {\n+            super();\n+            this.name = name;\n+            boneCount = b;\n+        }\n+    }\n+\n+    static class ContainerWithGetter<T extends Animal> {\n+        private T animal;\n+\n+        public ContainerWithGetter(T a) { animal = a; }\n+\n+        public T getAnimal() { return animal; }\n+    }\n+\n+    static class ContainerWithField<T extends Animal> {\n+        public T animal;\n+\n+        public ContainerWithField(T a) { animal = a; }\n+    }\n+    \n+    // Beans for [JACKSON-387], [JACKSON-430]\n+    \n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property=\"@classAttr1\")\n+    static class MyClass {\n+        public List<MyParam<?>> params = new ArrayList<MyParam<?>>();\n+    }\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY, property=\"@classAttr2\")\n+    static class MyParam<T>{\n+        public T value;\n+\n+        public MyParam() { }\n+        public MyParam(T v) { value = v; }\n+    }\n+\n+    private static class SomeObject {\n+        @SuppressWarnings(\"unused\")\n+        public String someValue = UUID.randomUUID().toString();\n+    }\n+    \n+    // Beans for [JACKSON-430]\n+    \n+    static class CustomJsonSerializer extends JsonSerializer<Object>\n+        implements ResolvableSerializer\n+    {\n+        private final JsonSerializer<Object> beanSerializer;\n+    \n+        public CustomJsonSerializer( JsonSerializer<Object> beanSerializer ) { this.beanSerializer = beanSerializer; }\n+    \n+        @Override\n+        public void serialize( Object value, JsonGenerator jgen, SerializerProvider provider )\n+            throws IOException, JsonProcessingException\n+        {\n+            beanSerializer.serialize( value, jgen, provider );\n+        }\n+    \n+        @Override\n+        public Class<Object> handledType() { return beanSerializer.handledType(); }\n+    \n+        @Override\n+        public void serializeWithType( Object value, JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer )\n+            throws IOException, JsonProcessingException\n+        {\n+            beanSerializer.serializeWithType( value, jgen, provider, typeSer );\n+        }\n+\n+        @Override\n+        public void resolve(SerializerProvider provider) throws JsonMappingException\n+        {\n+            if (beanSerializer instanceof ResolvableSerializer) {\n+                ((ResolvableSerializer) beanSerializer).resolve(provider);\n+            }\n+        }\n+    }\n+    \n+    protected static class CustomJsonSerializerFactory extends BeanSerializerFactory\n+    {\n+        public CustomJsonSerializerFactory() { super(null); }\n+\n+        @Override\n+        protected JsonSerializer<Object> constructBeanSerializer( SerializationConfig config, BasicBeanDescription beanDesc,\n+                BeanProperty property)\n+            throws JsonMappingException\n+        {                \n+            return new CustomJsonSerializer( super.constructBeanSerializer( config, beanDesc, property) );\n+        }\n+    }\n+\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testWrapperWithGetter() throws Exception\n+    {\n+        Dog dog = new Dog(\"Fluffy\", 3);\n+        String json = new ObjectMapper().writeValueAsString(new ContainerWithGetter<Animal>(dog));\n+        if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n+            fail(\"polymorphic type not kept, result == \"+json+\"; should contain 'object-type':'...'\");\n+        }\n+    }\n+\n+    public void testWrapperWithField() throws Exception\n+    {\n+        Dog dog = new Dog(\"Fluffy\", 3);\n+        String json = new ObjectMapper().writeValueAsString(new ContainerWithField<Animal>(dog));\n+        if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n+            fail(\"polymorphic type not kept, result == \"+json+\"; should contain 'object-type':'...'\");\n+        }\n+    }\n+    \n+    public void testWrapperWithExplicitType() throws Exception\n+    {\n+        Dog dog = new Dog(\"Fluffy\", 3);\n+        ContainerWithGetter<Animal> c2 = new ContainerWithGetter<Animal>(dog);\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writerWithType(TypeFactory.defaultInstance().constructParametricType(ContainerWithGetter.class, Animal.class)).writeValueAsString(c2);\n+        if (json.indexOf(\"\\\"object-type\\\":\\\"doggy\\\"\") < 0) {\n+            fail(\"polymorphic type not kept, result == \"+json+\"; should contain 'object-type':'...'\");\n+        }\n+    }\n+    \n+    public void testJackson387() throws Exception\n+    {\n+        ObjectMapper om = new ObjectMapper();\n+        om.enableDefaultTyping( ObjectMapper.DefaultTyping.JAVA_LANG_OBJECT, JsonTypeInfo.As.PROPERTY );\n+        om.setSerializationInclusion( JsonSerialize.Inclusion.NON_NULL );\n+        om.enable( SerializationConfig.Feature.INDENT_OUTPUT);\n+\n+        MyClass mc = new MyClass();\n+\n+        MyParam<Integer> moc1 = new MyParam<Integer>(1);\n+        MyParam<String> moc2 = new MyParam<String>(\"valueX\");\n+\n+        SomeObject so = new SomeObject();\n+        so.someValue = \"xxxxxx\"; \n+        MyParam<SomeObject> moc3 = new MyParam<SomeObject>(so);\n+\n+        List<SomeObject> colist = new ArrayList<SomeObject>();\n+        colist.add( new SomeObject() );\n+        colist.add( new SomeObject() );\n+        colist.add( new SomeObject() );\n+        MyParam<List<SomeObject>> moc4 = new MyParam<List<SomeObject>>(colist);\n+\n+        mc.params.add( moc1 );\n+        mc.params.add( moc2 );\n+        mc.params.add( moc3 );\n+        mc.params.add( moc4 );\n+\n+        String json = om.writeValueAsString( mc );\n+        \n+        MyClass mc2 = om.readValue(json, MyClass.class );\n+        assertNotNull(mc2);\n+        assertNotNull(mc2.params);\n+        assertEquals(4, mc2.params.size());\n+    }\n+\n+    public void testJackson430() throws Exception\n+    {\n+        ObjectMapper om = new ObjectMapper();\n+//        om.getSerializationConfig().setSerializationInclusion( Inclusion.NON_NULL );\n+        om.setSerializerFactory( new CustomJsonSerializerFactory() );\n+        MyClass mc = new MyClass();\n+        mc.params.add(new MyParam<Integer>(1));\n+\n+        String str = om.writeValueAsString( mc );\n+//        System.out.println( str );\n+        \n+        MyClass mc2 = om.readValue( str, MyClass.class );\n+        assertNotNull(mc2);\n+        assertNotNull(mc2.params);\n+        assertEquals(1, mc2.params.size());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForClass.java\n+package com.fasterxml.jackson.databind.mixins;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestMixinDeserForClass\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper bean classes\n+    /**********************************************************\n+     */\n+\n+    static class BaseClass\n+    {\n+        /* property that is always found; but has lower priority than\n+         * setter method if both found\n+         */\n+        @JsonProperty\n+        public String a;\n+\n+        // setter that may or may not be auto-detected\n+        public void setA(String v) { a = \"XXX\"+v; }\n+    }\n+\n+    @JsonAutoDetect(getterVisibility=Visibility.ANY, fieldVisibility=Visibility.ANY)\n+    static class LeafClass\n+        extends BaseClass { }\n+\n+    @JsonAutoDetect(getterVisibility=Visibility.NONE, fieldVisibility=Visibility.NONE)\n+    interface MixIn { }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testClassMixInsTopLevel() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // First: test default behavior: should use setter\n+        LeafClass result = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\", LeafClass.class);\n+        assertEquals(\"XXXvalue\", result.a);\n+\n+        /* Then with leaf-level mix-in; without (method) auto-detect, should\n+         * use field\n+         */\n+        m = new ObjectMapper();\n+        m.getDeserializationConfig().addMixInAnnotations(LeafClass.class, MixIn.class);\n+        result = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\", LeafClass.class);\n+        assertEquals(\"value\", result.a);\n+    }\n+\n+    /* and then a test for mid-level mixin; should have no effect\n+     * when deserializing leaf (but will if deserializing base class)\n+     */\n+    public void testClassMixInsMidLevel() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getDeserializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        {\n+            BaseClass result = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\", BaseClass.class);\n+            assertEquals(\"value\", result.a);\n+        }\n+\n+        // whereas with leaf class, reverts to default\n+        {\n+            LeafClass result = m.readValue(\"{\\\"a\\\":\\\"value\\\"}\", LeafClass.class);\n+            assertEquals(\"XXXvalue\", result.a);\n+        }\n+    }\n+\n+    /* Also: when mix-in attached to Object.class, will work, if\n+     * visible (similar to mid-level, basically)\n+     */\n+    public void testClassMixInsForObjectClass() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getDeserializationConfig().addMixInAnnotations(Object.class, MixIn.class);\n+        // will be seen for BaseClass\n+        {\n+            BaseClass result = m.readValue(\"{\\\"a\\\":\\\"\\\"}\", BaseClass.class);\n+            assertEquals(\"\", result.a);\n+        }\n+\n+        // but LeafClass still overrides\n+        {\n+            LeafClass result = m.readValue(\"{\\\"a\\\":\\\"\\\"}\", LeafClass.class);\n+            assertEquals(\"XXX\", result.a);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForCreators.java\n+package com.fasterxml.jackson.databind.mixins;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestMixinDeserForCreators\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper bean classes\n+    /**********************************************************\n+     */\n+\n+    static class BaseClass\n+    {\n+        protected String _a;\n+\n+        public BaseClass(String a) {\n+            _a = a+\"...\";\n+        }\n+\n+        private BaseClass(String value, boolean dummy) {\n+            _a = value;\n+        }\n+\n+        public static BaseClass myFactory(String a) {\n+            return new BaseClass(a+\"X\", true);\n+        }\n+    }\n+\n+    static class BaseClassWithPrivateCtor\n+    {\n+        protected String _a;\n+        private BaseClassWithPrivateCtor(String a) {\n+            _a = a+\"...\";\n+        }\n+\n+    }\n+\n+    /**\n+     * Mix-in class that will effectively suppresses String constructor,\n+     * and marks a non-auto-detectable static method as factory method\n+     * as a creator.\n+     *<p>\n+     * Note that method implementations are not used for anything; but\n+     * we have to a class: interface won't do, as they can't have\n+     * constructors or static methods.\n+     */\n+    static class MixIn\n+    {\n+        @JsonIgnore protected MixIn(String s) { }\n+\n+        @JsonCreator\n+        static BaseClass myFactory(String a) { return null; }\n+    }\n+\n+    static class MixInForPrivate\n+    {\n+        @JsonCreator MixInForPrivate(String s) { }\n+    }\n+\n+    static class StringWrapper {\n+        String _value;\n+        private StringWrapper(String s, boolean foo) { _value = s; }\n+\n+        @SuppressWarnings(\"unused\")\n+\t\tprivate static StringWrapper create(String str) {\n+            return new StringWrapper(str, false);\n+        }\n+    }\n+\n+    abstract static class StringWrapperMixIn {\n+        @JsonCreator static StringWrapper create(String str) { return null; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testForConstructor() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getDeserializationConfig().addMixInAnnotations(BaseClassWithPrivateCtor.class, MixInForPrivate.class);\n+        BaseClassWithPrivateCtor result = m.readValue(\"\\\"?\\\"\", BaseClassWithPrivateCtor.class);\n+        assertEquals(\"?...\", result._a);\n+    }\n+\n+    public void testForFactoryAndCtor() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        BaseClass result;\n+\n+        // First: test default behavior: should use constructor\n+        result = m.readValue(\"\\\"string\\\"\", BaseClass.class);\n+        assertEquals(\"string...\", result._a);\n+\n+        // Then with simple mix-in: should change to use the factory method\n+        m = new ObjectMapper();\n+        m.getDeserializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        result = m.readValue(\"\\\"string\\\"\", BaseClass.class);\n+        assertEquals(\"stringX\", result._a);\n+    }\n+\n+    public void testFactoryMixIn() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getDeserializationConfig().addMixInAnnotations(StringWrapper.class, StringWrapperMixIn.class);\n+        StringWrapper result = m.readValue(\"\\\"a\\\"\", StringWrapper.class);\n+        assertEquals(\"a\", result._value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinDeserForMethods.java\n+package com.fasterxml.jackson.databind.mixins;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestMixinDeserForMethods\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper bean classes\n+    /**********************************************************\n+     */\n+\n+    static class BaseClass\n+    {\n+        protected HashMap<String,Object> values = new HashMap<String,Object>();\n+\n+        public BaseClass() { }\n+\n+        protected void addValue(String key, Object value) {\n+            values.put(key, value);\n+        }\n+    }\n+\n+    interface MixIn\n+    {\n+        @JsonAnySetter void addValue(String key, Object value);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Unit test that verifies that we can mix in @JsonAnySetter\n+     * annotation, as expected.\n+     */\n+    public void testWithAnySetter() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getDeserializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        BaseClass result = m.readValue(\"{ \\\"a\\\" : 3, \\\"b\\\" : true }\", BaseClass.class);\n+        assertNotNull(result);\n+        assertEquals(2, result.values.size());\n+        assertEquals(Integer.valueOf(3), result.values.get(\"a\"));\n+        assertEquals(Boolean.TRUE, result.values.get(\"b\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForClass.java\n+package com.fasterxml.jackson.databind.mixins;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+public class TestMixinSerForClass\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper bean classes\n+    /**********************************************************\n+     */\n+\n+    @JsonSerialize(include=JsonSerialize.Inclusion.ALWAYS)\n+    static class BaseClass\n+    {\n+        protected String _a, _b;\n+        protected String _c = \"c\";\n+\n+        protected BaseClass() { }\n+\n+        public BaseClass(String a) {\n+            _a = a;\n+        }\n+\n+        // will be auto-detectable unless disabled:\n+        public String getA() { return _a; }\n+\n+        @JsonProperty\n+        public String getB() { return _b; }\n+\n+        @JsonProperty\n+        public String getC() { return _c; }\n+    }\n+\n+    @JsonSerialize(include=JsonSerialize.Inclusion.NON_DEFAULT)\n+    static class LeafClass\n+        extends BaseClass\n+    {\n+        public LeafClass() { super(null); }\n+\n+        public LeafClass(String a) {\n+            super(a);\n+        }\n+    }\n+\n+    /**\n+     * This interface only exists to add \"mix-in annotations\": that is, any\n+     * annotations it has can be virtually added to mask annotations\n+     * of other classes\n+     */\n+    @JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)\n+    interface MixIn { }\n+\n+    // test disabling of autodetect...\n+    @JsonAutoDetect(getterVisibility=Visibility.NONE, fieldVisibility=Visibility.NONE)\n+    interface MixInAutoDetect { }\n+\n+    /*\n+    /**********************************************************\n+    /( Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testClassMixInsTopLevel() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Map<String,Object> result;\n+\n+        // first: with no mix-ins:\n+        result = writeAndMap(mapper, new LeafClass(\"abc\"));\n+        assertEquals(1, result.size());\n+        assertEquals(\"abc\", result.get(\"a\"));\n+\n+        // then with top-level override\n+        mapper = new ObjectMapper();\n+        mapper.getSerializationConfig().addMixInAnnotations(LeafClass.class, MixIn.class);\n+        result = writeAndMap(mapper, new LeafClass(\"abc\"));\n+        assertEquals(2, result.size());\n+        assertEquals(\"abc\", result.get(\"a\"));\n+        assertEquals(\"c\", result.get(\"c\"));\n+\n+        // mid-level override; should not have any effect\n+        mapper = new ObjectMapper();\n+        mapper.getSerializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        result = writeAndMap(mapper, new LeafClass(\"abc\"));\n+        assertEquals(1, result.size());\n+        assertEquals(\"abc\", result.get(\"a\"));\n+    }\n+\n+    public void testClassMixInsMidLevel() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Map<String,Object> result;\n+        LeafClass bean = new LeafClass(\"xyz\");\n+        bean._c = \"c2\";\n+\n+        // with no mix-ins first...\n+        result = writeAndMap(mapper, bean);\n+        assertEquals(2, result.size());\n+        assertEquals(\"xyz\", result.get(\"a\"));\n+        assertEquals(\"c2\", result.get(\"c\"));\n+\n+        // then with working mid-level override, which effectively suppresses 'a'\n+        mapper = new ObjectMapper();\n+        mapper.getSerializationConfig().addMixInAnnotations(BaseClass.class, MixInAutoDetect.class);\n+        result = writeAndMap(mapper, bean);\n+        assertEquals(1, result.size());\n+        assertEquals(\"c2\", result.get(\"c\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForFields.java\n+package com.fasterxml.jackson.databind.mixins;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestMixinSerForFields\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper bean classes\n+    /**********************************************************\n+     */\n+\n+    static class BaseClass\n+    {\n+        public String a;\n+        protected String b;\n+\n+        public BaseClass(String a, String b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+    }\n+\n+    static class SubClass\n+        extends BaseClass\n+    {\n+        public SubClass(String a, String b) {\n+            super(a, b);\n+        }\n+    }\n+\n+    abstract class MixIn {\n+        // Let's add 'b' as \"banana\"\n+        @JsonProperty(\"banana\")\n+        public String b;\n+    }\n+\n+    abstract class MixIn2 {\n+        // Let's remove 'a'\n+        @JsonIgnore\n+        public String a;\n+\n+        // also: add a dummy field that is NOT to match anything\n+        @JsonProperty public String xyz;\n+    }\n+\n+    /*\n+    ///////////////////////////////////////////////////////////\n+    // Unit tests\n+    ///////////////////////////////////////////////////////////\n+     */\n+\n+    public void testFieldMixInsTopLevel() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Map<String,Object> result;\n+        BaseClass bean = new BaseClass(\"1\", \"2\");\n+\n+        // first: with no mix-ins:\n+        result = writeAndMap(mapper, bean);\n+        assertEquals(1, result.size());\n+        assertEquals(\"1\", result.get(\"a\"));\n+\n+        // and then with simple mix-in\n+        mapper = new ObjectMapper();\n+        mapper.getSerializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        result = writeAndMap(mapper, bean);\n+        assertEquals(2, result.size());\n+        assertEquals(\"1\", result.get(\"a\"));\n+        assertEquals(\"2\", result.get(\"banana\"));\n+    }\n+\n+    public void testMultipleFieldMixIns() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Map<String,Object> result;\n+        // ordering here shouldn't matter really...\n+        HashMap<Class<?>,Class<?>> mixins = new HashMap<Class<?>,Class<?>>();\n+        // first, clear (not strictly needed -- just for fun)\n+        mapper.getSerializationConfig().setMixInAnnotations(null);\n+        mixins.put(SubClass.class, MixIn.class);\n+        mixins.put(BaseClass.class, MixIn2.class);\n+        mapper.getSerializationConfig().setMixInAnnotations(mixins);\n+\n+        result = writeAndMap(mapper, new SubClass(\"1\", \"2\"));\n+        assertEquals(1, result.size());\n+        // 'a' should be suppressed; 'b' mapped to 'banana'\n+        assertEquals(\"2\", result.get(\"banana\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForMethods.java\n+package com.fasterxml.jackson.databind.mixins;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestMixinSerForMethods\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper bean classes\n+    /**********************************************************\n+     */\n+\n+    // base class: just one visible property ('b')\n+    static class BaseClass\n+    {\n+        @SuppressWarnings(\"unused\") private String a;\n+        private String b;\n+\n+        protected BaseClass() { }\n+\n+        public BaseClass(String a, String b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+\n+        @JsonProperty(\"b\")\n+        public String takeB() { return b; }\n+    }\n+\n+    /* extends, just for fun; and to show possible benefit of being\n+     * able to declare that a method is overridden (compile-time check\n+     * that our intended mix-in override will match a method)\n+     */\n+    abstract static class MixIn\n+        extends BaseClass\n+    {\n+        // let's make 'a' visible\n+        @JsonProperty String a;\n+\n+        @Override\n+            @JsonProperty(\"b2\")\n+            public abstract String takeB();\n+\n+        // also: just for fun; add a \"red herring\"... unmatched method\n+        @JsonProperty abstract String getFoobar();\n+    }\n+\n+    static class LeafClass\n+        extends BaseClass\n+    {\n+        public LeafClass(String a, String b) { super(a, b); }\n+\n+        @Override\n+        @JsonIgnore\n+        public String takeB() { return null; }\n+    }\n+               \n+    interface ObjectMixIn\n+    {\n+        // and then ditto for hashCode..\n+        @Override\n+        @JsonProperty public int hashCode();\n+    }\n+\n+    static class EmptyBean { }\n+\n+    static class SimpleBean extends EmptyBean\n+    {\n+        int x() { return 42; }\n+    }\n+\n+    /**\n+     * This mix-in is to be attached to EmptyBean, but really modify\n+     * methods that its subclass, SimpleBean, has.\n+     */\n+    abstract class MixInForSimple\n+    {\n+        // This should apply to sub-class\n+        @JsonProperty(\"x\") abstract int x();\n+\n+        // and this matches nothing, should be ignored\n+        @JsonProperty(\"notreally\") public int xxx() { return 3; }\n+\n+        // nor this\n+        public abstract int getIt();\n+    }\n+\n+    /*\n+    ///////////////////////////////////////////////////////////\n+    // Unit tests\n+    ///////////////////////////////////////////////////////////\n+     */\n+\n+    /**\n+     * Unit test for verifying that leaf-level mix-ins work ok; \n+     * that is, any annotations added properly override all annotations\n+     * that masked methods (fields etc) have.\n+     */\n+    public void testLeafMixin() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Map<String,Object> result;\n+        BaseClass bean = new BaseClass(\"a1\", \"b2\");\n+\n+        // first: with no mix-ins:\n+        result = writeAndMap(mapper, bean);\n+        assertEquals(1, result.size());\n+        assertEquals(\"b2\", result.get(\"b\"));\n+\n+        // then with leaf-level mix-in\n+        mapper = new ObjectMapper();\n+        mapper.getSerializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        result = writeAndMap(mapper, bean);\n+        assertEquals(2, result.size());\n+        assertEquals(\"b2\", result.get(\"b2\"));\n+        assertEquals(\"a1\", result.get(\"a\"));\n+    }\n+\n+    /**\n+     * Unit test for verifying that having a mix-in \"between\" classes\n+     * (overriding annotations of a base class, but being overridden\n+     * further by a sub-class) works as expected\n+     */\n+    public void testIntermediateMixin() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Map<String,Object> result;\n+        LeafClass bean = new LeafClass(\"XXX\", \"b2\");\n+\n+        mapper.getSerializationConfig().addMixInAnnotations(BaseClass.class, MixIn.class);\n+        result = writeAndMap(mapper, bean);\n+        assertEquals(1, result.size());\n+        assertEquals(\"XXX\", result.get(\"a\"));\n+    }\n+\n+    /**\n+     * Another intermediate mix-in, to verify that annotations\n+     * properly \"trickle up\"\n+     */\n+    public void testIntermediateMixin2() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.getSerializationConfig().addMixInAnnotations(EmptyBean.class, MixInForSimple.class);\n+        Map<String,Object> result = writeAndMap(mapper, new SimpleBean());\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(42), result.get(\"x\"));\n+    }\n+\n+    /**\n+     * Unit test for verifying that it is actually possible to attach\n+     * mix-in annotations to basic <code>Object.class</code>. This\n+     * will essentially apply to any and all Objects.\n+     */\n+    public void testObjectMixin() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.getSerializationConfig().addMixInAnnotations(Object.class, ObjectMixIn.class);\n+\n+        // First, with our bean...\n+        Map<String,Object> result = writeAndMap(mapper, new BaseClass(\"a\", \"b\"));\n+\n+        assertEquals(2, result.size());\n+        assertEquals(\"b\", result.get(\"b\"));\n+        Object ob = result.get(\"hashCode\");\n+        assertNotNull(ob);\n+        assertEquals(Integer.class, ob.getClass());\n+\n+        /* 15-Oct-2010, tatu: Actually, we now block serialization (attemps) of plain Objects, by default\n+         *    (since generally that makes no sense -- may need to revisit). As such, need to comment out\n+         *    this part of test\n+         */\n+        /* Hmmh. For plain Object.class... I suppose getClass() does\n+         * get serialized (and can't really be blocked either).\n+         * Fine.\n+         */\n+       /*\n+        result = writeAndMap(mapper, new Object());\n+        assertEquals(2, result.size());\n+        ob = result.get(\"hashCode\");\n+        assertNotNull(ob);\n+        assertEquals(Integer.class, ob.getClass());\n+        assertEquals(\"java.lang.Object\", result.get(\"class\"));\n+        */\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerWithViews.java\n+package com.fasterxml.jackson.databind.mixins;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+public class TestMixinSerWithViews\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper bean classes\n+    /**********************************************************\n+     */\n+\n+    static class SimpleTestData\n+    {\n+        private String name = \"shown\";\n+        private String nameHidden = \"hidden\";\n+\n+        public String getName() { return name; }\n+        public String getNameHidden( ) { return nameHidden; }\n+\n+      public void setName( String name ) {\n+        this.name = name;\n+      }\n+\n+      public void setNameHidden( String nameHidden ) {\n+        this.nameHidden = nameHidden;\n+      }\n+    }\n+\n+    static class ComplexTestData\n+    {\n+      String nameNull = null;\n+\n+      String nameComplex = \"complexValue\";\n+\n+      String nameComplexHidden = \"nameComplexHiddenValue\";\n+\n+      SimpleTestData testData = new SimpleTestData( );\n+\n+      SimpleTestData[] testDataArray = new SimpleTestData[] { new SimpleTestData( ), null };\n+\n+      public String getNameNull()\n+      {\n+        return nameNull;\n+      }\n+\n+      public void setNameNull( String nameNull )\n+      {\n+        this.nameNull = nameNull;\n+      }\n+\n+      public String getNameComplex()\n+      {\n+        return nameComplex;\n+      }\n+\n+      public void setNameComplex( String nameComplex )\n+      {\n+        this.nameComplex = nameComplex;\n+      }\n+\n+      public String getNameComplexHidden()\n+      {\n+        return nameComplexHidden;\n+      }\n+\n+      public void setNameComplexHidden( String nameComplexHidden )\n+      {\n+        this.nameComplexHidden = nameComplexHidden;\n+      }\n+\n+      public SimpleTestData getTestData()\n+      {\n+        return testData;\n+      }\n+\n+      public void setTestData( SimpleTestData testData )\n+      {\n+        this.testData = testData;\n+      }\n+\n+      public SimpleTestData[] getTestDataArray()\n+      {\n+        return testDataArray;\n+      }\n+\n+      public void setTestDataArray( SimpleTestData[] testDataArray )\n+      {\n+        this.testDataArray = testDataArray;\n+      }\n+    }    \n+\n+    public interface TestDataJAXBMixin\n+    {\n+      @JsonView( Views.View.class )\n+      String getName( );\n+    }\n+\n+    public interface TestComplexDataJAXBMixin\n+    {\n+      @JsonView( Views.View.class )\n+      String getNameNull();\n+\n+      @JsonView( Views.View.class )\n+      String getNameComplex();\n+\n+      @JsonView( Views.View.class )\n+      String getNameComplexHidden();\n+\n+      @JsonView( Views.View.class )\n+      SimpleTestData getTestData();\n+\n+      @JsonView( Views.View.class )\n+      SimpleTestData[] getTestDataArray( );\n+    }\n+\n+    static class Views {\n+        static class View { }\n+    }\n+    \n+    public class A {\n+        private String name;\n+        private int age;\n+        private String surname;\n+\n+        public A(String name, int age, String surname) { super(); this.name = name; this.age = age; this.surname = surname; }\n+\n+        public String getName() { return name; }\n+\n+        public void setName(String name) { this.name = name; }\n+\n+        public int getAge() { return age; }\n+\n+        public void setAge(int age) { this.age = age; }\n+\n+        public String getSurname() { return surname; }\n+\n+        public void setSurname(String surname) { this.surname = surname; }\n+    }\n+\n+    public interface AView { }\n+\n+    public abstract class AMixInAnnotation {\n+        @JsonProperty(\"name\")\n+        @JsonView(AView.class)\n+        abstract String getName();\n+        @JsonProperty(\"age\") @JsonView(AView.class)\n+        abstract int getAge();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests\n+    /**********************************************************\n+     */\n+    \n+    public void testDataBindingUsage( ) throws Exception\n+    {\n+      ObjectMapper objectMapper = createObjectMapper();\n+      ObjectWriter objectWriter = objectMapper.writerWithView(Views.View.class).withDefaultPrettyPrinter();\n+      Object object = new ComplexTestData();\n+      String json = objectWriter.writeValueAsString(object);\n+      assertTrue( json.indexOf( \"nameHidden\" ) == -1 );\n+      assertTrue( json.indexOf( \"\\\"name\\\" : \\\"shown\\\"\" ) > 0 );\n+    }    \n+\n+    public void testIssue560() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        A a = new A(\"myname\", 29, \"mysurname\");\n+\n+        // Property SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION set to false\n+        mapper.configure(SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION, Boolean.FALSE);\n+        mapper.getSerializationConfig().addMixInAnnotations(A.class, AMixInAnnotation.class);\n+        String json = mapper.writerWithView(AView.class).writeValueAsString(a);\n+\n+        assertTrue(json.indexOf(\"\\\"name\\\"\") > 0);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    private ObjectMapper createObjectMapper( )\n+    {\n+      ObjectMapper objectMapper = new ObjectMapper( );\n+      objectMapper.configure( SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false );\n+      objectMapper.setSerializationInclusion( JsonSerialize.Inclusion.NON_NULL );\n+      objectMapper.configure( SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION, false );\n+\n+      Map<Class<?>, Class<?>> sourceMixins = new HashMap<Class<?>, Class<?>>( );\n+      sourceMixins.put( SimpleTestData.class, TestDataJAXBMixin.class );\n+      sourceMixins.put( ComplexTestData.class, TestComplexDataJAXBMixin.class );\n+      \n+      objectMapper.getSerializationConfig( ).setMixInAnnotations(sourceMixins);\n+      return objectMapper;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestAbstractTypes.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+public class TestAbstractTypes extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes; simple beans and their handlers\n+    /**********************************************************\n+     */\n+\n+    static class MyString implements CharSequence\n+    {\n+        protected String value;\n+        \n+        public MyString(String s) { value = s; }\n+\n+        @Override\n+        public char charAt(int index) {\n+            return value.charAt(index);\n+        }\n+\n+        @Override\n+        public int length() {\n+            return value.length();\n+        }\n+\n+        @Override\n+        public CharSequence subSequence(int arg0, int arg1) { return this; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testCollectionDefaulting() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\", Version.unknownVersion());\n+        // let's ensure we get hierarchic mapping\n+        mod.addAbstractTypeMapping(Collection.class, List.class);\n+        mod.addAbstractTypeMapping(List.class, LinkedList.class);\n+        mapper.registerModule(mod);\n+        Collection<?> result = mapper.readValue(\"[]\", Collection.class);\n+        assertEquals(LinkedList.class, result.getClass());\n+    }\n+\n+    public void testMapDefaulting() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\", Version.unknownVersion());\n+        // default is HashMap, so:\n+        mod.addAbstractTypeMapping(Map.class, TreeMap.class);\n+        mapper.registerModule(mod);\n+        Map<?,?> result = mapper.readValue(\"{}\", Map.class);\n+        assertEquals(TreeMap.class, result.getClass());\n+    }\n+    \n+    public void testInterfaceDefaulting() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\", Version.unknownVersion());\n+        // let's ensure we get hierarchic mapping\n+        mod.addAbstractTypeMapping(CharSequence.class, MyString.class);\n+        mapper.registerModule(mod);\n+        Object result = mapper.readValue(quote(\"abc\"), CharSequence.class);\n+        assertEquals(MyString.class, result.getClass());\n+        assertEquals(\"abc\", ((MyString) result).value);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.module.SimpleDeserializers;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.fasterxml.jackson.databind.module.SimpleSerializers;\n+import com.fasterxml.jackson.databind.ser.std.ScalarSerializerBase;\n+import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+\n+public class TestSimpleModule extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes; simple beans and their handlers\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Trivial bean that requires custom serializer and deserializer\n+     */\n+    final static class CustomBean\n+    {\n+        protected String str;\n+        protected int num;\n+        \n+        public CustomBean(String s, int i) {\n+            str = s;\n+            num = i;\n+        }\n+    }\n+\n+    static enum SimpleEnum { A, B; }\n+    \n+    // Extend SerializerBase to get access to declared handledType\n+    static class CustomBeanSerializer extends SerializerBase<CustomBean>\n+    {\n+        public CustomBeanSerializer() { super(CustomBean.class); }\n+\n+        @Override\n+        public void serialize(CustomBean value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonProcessingException\n+        {\n+            // We will write it as a String, with '|' as delimiter\n+            jgen.writeString(value.str + \"|\" + value.num);\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n+            return null;\n+        }\n+    }\n+    \n+    static class CustomBeanDeserializer extends JsonDeserializer<CustomBean>\n+    {\n+        @Override\n+        public CustomBean deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            String text = jp.getText();\n+            int ix = text.indexOf('|');\n+            if (ix < 0) {\n+                throw new IOException(\"Failed to parse String value of \\\"\"+text+\"\\\"\");\n+            }\n+            String str = text.substring(0, ix);\n+            int num = Integer.parseInt(text.substring(ix+1));\n+            return new CustomBean(str, num);\n+        }\n+    }\n+\n+    static class SimpleEnumSerializer extends SerializerBase<SimpleEnum>\n+    {\n+        public SimpleEnumSerializer() { super(SimpleEnum.class); }\n+\n+        @Override\n+        public void serialize(SimpleEnum value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonProcessingException\n+        {\n+            jgen.writeString(value.name().toLowerCase());\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n+            return null;\n+        }\n+    }\n+\n+    static class SimpleEnumDeserializer extends JsonDeserializer<SimpleEnum>\n+    {\n+        @Override\n+        public SimpleEnum deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return SimpleEnum.valueOf(jp.getText().toUpperCase());\n+        }\n+    }\n+\n+    interface Base {\n+        public String getText();\n+    }\n+    \n+    static class Impl1 implements Base {\n+        @Override\n+        public String getText() { return \"1\"; }\n+    }\n+\n+    static class Impl2 extends Impl1 {\n+        @Override\n+        public String getText() { return \"2\"; }\n+    }\n+\n+    static class BaseSerializer extends ScalarSerializerBase<Base>\n+    {\n+        public BaseSerializer() { super(Base.class); }\n+        \n+        @Override\n+        public void serialize(Base value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+            jgen.writeString(\"Base:\"+value.getText());\n+        }\n+    }\n+\n+    static class MixableBean {\n+        public int a = 1;\n+        public int b = 2;\n+        public int c = 3;\n+    }\n+\n+    @JsonPropertyOrder({\"c\", \"a\", \"b\"})\n+    static class MixInForOrder { }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests; first, verifying need for custom handlers\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Basic test to ensure we do not have functioning default\n+     * serializers for custom types used in tests.\n+     */\n+    public void testWithoutModule()\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // first: serialization failure:\n+        try {\n+            mapper.writeValueAsString(new CustomBean(\"foo\", 3));\n+            fail(\"Should have caused an exception\");\n+        } catch (IOException e) {\n+            verifyException(e, \"No serializer found\");\n+        }\n+\n+        // then deserialization\n+        try {\n+            mapper.readValue(\"{\\\"str\\\":\\\"ab\\\",\\\"num\\\":2}\", CustomBean.class);\n+            fail(\"Should have caused an exception\");\n+        } catch (IOException e) {\n+            verifyException(e, \"No suitable constructor found\");\n+        }\n+    }\n+\n+    protected static class MySimpleSerializers extends SimpleSerializers { }\n+    protected static class MySimpleDeserializers extends SimpleDeserializers { }\n+\n+    /**\n+     * Test module which uses custom 'serializers' and 'deserializers' container; used\n+     * to trigger type problems.\n+     */\n+    protected static class MySimpleModule extends SimpleModule\n+    {\n+        public MySimpleModule(String name, Version version) {\n+            super(name, version);\n+            _deserializers = new MySimpleDeserializers();\n+            _serializers = new MySimpleSerializers();\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests; simple serializers\n+    /**********************************************************\n+     */\n+    \n+    public void testSimpleBeanSerializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\", new Version(1, 0, 0, null));\n+        mod.addSerializer(new CustomBeanSerializer());\n+        mapper.registerModule(mod);\n+        assertEquals(quote(\"abcde|5\"), mapper.writeValueAsString(new CustomBean(\"abcde\", 5)));\n+    }\n+\n+    public void testSimpleEnumSerializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\", new Version(1, 0, 0, null));\n+        mod.addSerializer(new SimpleEnumSerializer());\n+        mapper.registerModule(mod);\n+        assertEquals(quote(\"b\"), mapper.writeValueAsString(SimpleEnum.B));\n+    }\n+\n+    // for [JACKSON-550]\n+    public void testSimpleInterfaceSerializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\", new Version(1, 0, 0, null));\n+        mod.addSerializer(new BaseSerializer());\n+        mapper.registerModule(mod);\n+        assertEquals(quote(\"Base:1\"), mapper.writeValueAsString(new Impl1()));\n+        assertEquals(quote(\"Base:2\"), mapper.writeValueAsString(new Impl2()));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests; simple deserializers\n+    /**********************************************************\n+     */\n+    \n+    public void testSimpleBeanDeserializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\", new Version(1, 0, 0, null));\n+        mod.addDeserializer(CustomBean.class, new CustomBeanDeserializer());\n+        mapper.registerModule(mod);\n+        CustomBean bean = mapper.readValue(quote(\"xyz|3\"), CustomBean.class);\n+        assertEquals(\"xyz\", bean.str);\n+        assertEquals(3, bean.num);\n+    }\n+\n+    public void testSimpleEnumDeserializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\", new Version(1, 0, 0, null));\n+        mod.addDeserializer(SimpleEnum.class, new SimpleEnumDeserializer());\n+        mapper.registerModule(mod);\n+        SimpleEnum result = mapper.readValue(quote(\"a\"), SimpleEnum.class);\n+        assertSame(SimpleEnum.A, result);\n+    }\n+ \n+    // Simple verification of [JACKSON-455]\n+    public void testMultipleModules() throws Exception\n+    {\n+        MySimpleModule mod1 = new MySimpleModule(\"test1\", new Version(1, 0, 0, null));\n+        SimpleModule mod2 = new SimpleModule(\"test2\", new Version(1, 0, 0, null));\n+        mod1.addSerializer(SimpleEnum.class, new SimpleEnumSerializer());\n+        mod1.addDeserializer(CustomBean.class, new CustomBeanDeserializer());\n+        mod2.addDeserializer(SimpleEnum.class, new SimpleEnumDeserializer());\n+        mod2.addSerializer(CustomBean.class, new CustomBeanSerializer());\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(mod1);\n+        mapper.registerModule(mod2);\n+        assertEquals(quote(\"b\"), mapper.writeValueAsString(SimpleEnum.B));\n+        SimpleEnum result = mapper.readValue(quote(\"a\"), SimpleEnum.class);\n+        assertSame(SimpleEnum.A, result);\n+\n+        // also let's try it with different order of registration, just in case\n+        mapper = new ObjectMapper();\n+        mapper.registerModule(mod2);\n+        mapper.registerModule(mod1);\n+        assertEquals(quote(\"b\"), mapper.writeValueAsString(SimpleEnum.B));\n+        result = mapper.readValue(quote(\"a\"), SimpleEnum.class);\n+        assertSame(SimpleEnum.A, result);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests; other\n+    /**********************************************************\n+     */\n+    \n+    // [JACKSON-644]: ability to register mix-ins\n+    public void testMixIns() throws Exception\n+    {\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.setMixInAnnotation(MixableBean.class, MixInForOrder.class);\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(module);\n+        Map<String,Object> props = this.writeAndMap(mapper, new MixableBean());\n+        assertEquals(3, props.size());\n+        assertEquals(Integer.valueOf(3), props.get(\"c\"));\n+        assertEquals(Integer.valueOf(1), props.get(\"a\"));\n+        assertEquals(Integer.valueOf(2), props.get(\"b\"));\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.module.SimpleDeserializers;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.fasterxml.jackson.databind.ser.Serializers;\n+import com.fasterxml.jackson.databind.type.*;\n+\n+public class TestTypeModifiers extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    static class ModifierModule extends SimpleModule\n+    {\n+        public ModifierModule() {\n+            super(\"test\", Version.unknownVersion());\n+        }\n+\n+        @Override\n+        public void setupModule(SetupContext context)\n+        {\n+            context.addSerializers(new Serializers.Base() {\n+                @Override\n+                public JsonSerializer<?> findMapLikeSerializer(SerializationConfig config,\n+                        MapLikeType type, BeanDescription beanDesc, BeanProperty property,\n+                        JsonSerializer<Object> keySerializer,\n+                        TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n+                {\n+                    if (MapMarker.class.isAssignableFrom(type.getRawClass())) {\n+                        return new MyMapSerializer(keySerializer, elementValueSerializer);\n+                    }\n+                    return null;\n+                }\n+\n+                @Override\n+                public JsonSerializer<?> findCollectionLikeSerializer(SerializationConfig config,\n+                        CollectionLikeType type, BeanDescription beanDesc, BeanProperty property,\n+                        TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n+                {\n+                    if (CollectionMarker.class.isAssignableFrom(type.getRawClass())) {\n+                        return new MyCollectionSerializer();\n+                    }\n+                    return null;\n+                }\n+            });\n+            context.addDeserializers(new SimpleDeserializers() {\n+                @Override\n+                public JsonDeserializer<?> findCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config,\n+                        DeserializerProvider provider, BeanDescription beanDesc, BeanProperty property,\n+                        TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+                    throws JsonMappingException\n+                {\n+                    if (CollectionMarker.class.isAssignableFrom(type.getRawClass())) {\n+                        return new MyCollectionDeserializer();\n+                    }\n+                    return null;\n+                }\n+                @Override\n+                public JsonDeserializer<?> findMapLikeDeserializer(MapLikeType type, DeserializationConfig config,\n+                        DeserializerProvider provider, BeanDescription beanDesc, BeanProperty property,\n+                        KeyDeserializer keyDeserializer,\n+                        TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+                    throws JsonMappingException\n+                {\n+                    if (MapMarker.class.isAssignableFrom(type.getRawClass())) {\n+                        return new MyMapDeserializer();\n+                    }\n+                    return null;\n+                }\n+            });\n+        }\n+    }\n+\n+    static class XxxSerializer extends JsonSerializer<Object>\n+    {\n+        @Override\n+        public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+            jgen.writeString(\"xxx:\"+value);\n+        }\n+    }\n+    \n+    interface MapMarker<K,V> {\n+        public K getKey();\n+        public V getValue();\n+    }\n+    interface CollectionMarker<V> {\n+        public V getValue();\n+    }\n+\n+    @JsonSerialize(contentUsing=XxxSerializer.class)\n+    static class MyMapLikeType implements MapMarker<String,Integer> {\n+        public String key;\n+        public int value;\n+\n+        public MyMapLikeType() { }\n+        public MyMapLikeType(String k, int v) {\n+            key = k;\n+            value = v;\n+        }\n+\n+        @Override\n+        public String getKey() { return key; }\n+        @Override\n+        public Integer getValue() { return value; }\n+    }\n+\n+    static class MyCollectionLikeType implements CollectionMarker<Integer>\n+    {\n+        public int value;\n+\n+        public MyCollectionLikeType() { }\n+        public MyCollectionLikeType(int v) {\n+            value = v;\n+        }\n+\n+        @Override\n+        public Integer getValue() { return value; }\n+    }\n+\n+    static class MyMapSerializer extends JsonSerializer<MapMarker<?,?>>\n+    {\n+        protected final JsonSerializer<Object> _keySerializer;\n+        protected final JsonSerializer<Object> _valueSerializer;\n+        \n+        public MyMapSerializer(JsonSerializer<Object> keySer, JsonSerializer<Object> valueSer) {\n+            _keySerializer = keySer;\n+            _valueSerializer = valueSer;\n+        }\n+        \n+        @Override\n+        public void serialize(MapMarker<?,?> value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+            jgen.writeStartObject();\n+            if (_keySerializer == null) {\n+                jgen.writeFieldName((String) value.getKey());\n+            } else {\n+                _keySerializer.serialize(value.getKey(), jgen, provider);\n+            }\n+            if (_valueSerializer == null) {\n+                jgen.writeNumber(((Number) value.getValue()).intValue());\n+            } else {\n+                _valueSerializer.serialize(value.getValue(), jgen, provider);\n+            }\n+            jgen.writeEndObject();\n+        }\n+    }\n+    static class MyMapDeserializer extends JsonDeserializer<MapMarker<?,?>>\n+    {\n+        @Override\n+        public MapMarker<?,?> deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n+            if (jp.getCurrentToken() != JsonToken.START_OBJECT) throw new IOException(\"Wrong token: \"+jp.getCurrentToken());\n+            if (jp.nextToken() != JsonToken.FIELD_NAME) throw new IOException(\"Wrong token: \"+jp.getCurrentToken());\n+            String key = jp.getCurrentName();\n+            if (jp.nextToken() != JsonToken.VALUE_NUMBER_INT) throw new IOException(\"Wrong token: \"+jp.getCurrentToken());\n+            int value = jp.getIntValue();\n+            if (jp.nextToken() != JsonToken.END_OBJECT) throw new IOException(\"Wrong token: \"+jp.getCurrentToken());\n+            return new MyMapLikeType(key, value);\n+        }        \n+    }\n+\n+    static class MyCollectionSerializer extends JsonSerializer<MyCollectionLikeType>\n+    {\n+        @Override\n+        public void serialize(MyCollectionLikeType value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n+            jgen.writeStartArray();\n+            jgen.writeNumber(value.value);\n+            jgen.writeEndArray();\n+        }\n+    }\n+    static class MyCollectionDeserializer extends JsonDeserializer<MyCollectionLikeType>\n+    {\n+        @Override\n+        public MyCollectionLikeType deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n+            if (jp.getCurrentToken() != JsonToken.START_ARRAY) throw new IOException(\"Wrong token: \"+jp.getCurrentToken());\n+            if (jp.nextToken() != JsonToken.VALUE_NUMBER_INT) throw new IOException(\"Wrong token: \"+jp.getCurrentToken());\n+            int value = jp.getIntValue();\n+            if (jp.nextToken() != JsonToken.END_ARRAY) throw new IOException(\"Wrong token: \"+jp.getCurrentToken());\n+            return new MyCollectionLikeType(value);\n+        }        \n+    }\n+    \n+    static class MyTypeModifier extends TypeModifier\n+    {\n+        @Override\n+        public JavaType modifyType(JavaType type, Type jdkType, TypeBindings context, TypeFactory typeFactory)\n+        {\n+            Class<?> raw = type.getRawClass();\n+            if (MapMarker.class.isAssignableFrom(raw)) {\n+                JavaType[] params = typeFactory.findTypeParameters(type, MapMarker.class);\n+                return typeFactory.constructMapLikeType(raw, params[0], params[1]);\n+            }\n+            if (CollectionMarker.class.isAssignableFrom(raw)) {\n+                JavaType[] params = typeFactory.findTypeParameters(type, CollectionMarker.class);\n+                return typeFactory.constructCollectionLikeType(raw, params[0]);\n+            }\n+            return type;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Basic test for ensuring that we can get \"xxx-like\" types recognized.\n+     */\n+    public void testLikeTypeConstruction() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier()));\n+        JavaType type = mapper.constructType(MyMapLikeType.class);\n+        assertTrue(type.isMapLikeType());\n+        // also, must have resolved type info\n+        JavaType param = ((MapLikeType) type).getKeyType();\n+        assertNotNull(param);\n+        assertSame(String.class, param.getRawClass());\n+        param = ((MapLikeType) type).getContentType();\n+        assertNotNull(param);\n+        assertSame(Integer.class, param.getRawClass());\n+        \n+        type = mapper.constructType(MyCollectionLikeType.class);\n+        assertTrue(type.isCollectionLikeType());\n+        param = ((CollectionLikeType) type).getContentType();\n+        assertNotNull(param);\n+        assertSame(Integer.class, param.getRawClass());\n+    }\n+\n+    public void testCollectionLikeSerialization() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier()));\n+        mapper.registerModule(new ModifierModule());\n+        assertEquals(\"[19]\", mapper.writeValueAsString(new MyCollectionLikeType(19)));\n+    }\n+\n+    public void testMapLikeSerialization() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier()));\n+        mapper.registerModule(new ModifierModule());\n+        // Due to custom serializer, should get:\n+        assertEquals(\"{\\\"x\\\":\\\"xxx:3\\\"}\", mapper.writeValueAsString(new MyMapLikeType(\"x\", 3)));\n+    }\n+\n+\n+    public void testCollectionLikeDeserialization() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier()));\n+        mapper.registerModule(new ModifierModule());\n+        // !!! TBI\n+        MyMapLikeType result = mapper.readValue(\"{\\\"a\\\":13}\", MyMapLikeType.class);\n+        assertEquals(\"a\", result.getKey());\n+        assertEquals(Integer.valueOf(13), result.getValue());\n+    }\n+\n+    public void testMapLikeDeserialization() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setTypeFactory(mapper.getTypeFactory().withModifier(new MyTypeModifier()));\n+        mapper.registerModule(new ModifierModule());\n+        // !!! TBI\n+        MyCollectionLikeType result = mapper.readValue(\"[-37]\", MyCollectionLikeType.class);\n+        assertEquals(Integer.valueOf(-37), result.getValue());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestValueInstantiator.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonValueInstantiator;\n+import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.deser.impl.CreatorProperty;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Test related to [JACKSON-580] (allow specifying custom instantiators)\n+ */\n+public class TestValueInstantiator extends BaseMapTest\n+{\n+    static class MyBean\n+    {\n+        String _secret;\n+        \n+        public MyBean(String s, boolean bogus) {\n+            _secret = s;\n+        }\n+    }\n+\n+    static class MysteryBean\n+    {\n+        Object value;\n+        \n+        public MysteryBean(Object v) { value = v; }\n+    }\n+    \n+    static class CreatorBean\n+    {\n+        String _secret;\n+\n+        public String value;\n+        \n+        protected CreatorBean(String s) {\n+            _secret = s;\n+        }\n+    }\n+\n+    static abstract class InstantiatorBase extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return \"UNKNOWN\";\n+        }\n+    }\n+    \n+    static abstract class PolymorphicBeanBase { }\n+    \n+    static class PolymorphicBean extends PolymorphicBeanBase\n+    {\n+        public String name;\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    static class MyList extends ArrayList<Object>\n+    {\n+        public MyList(boolean b) { super(); }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MyMap extends HashMap<String,Object>\n+    {\n+        public MyMap(boolean b) { super(); }\n+        public MyMap(String name) {\n+            super();\n+            put(name, name);\n+        }\n+    }\n+    \n+    static class MyBeanInstantiator extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return MyBean.class.getName();\n+        }\n+        \n+        @Override\n+        public boolean canCreateUsingDefault() { return true; }\n+\n+        @Override\n+        public MyBean createUsingDefault() {\n+            return new MyBean(\"secret!\", true);\n+        }\n+    }\n+\n+    /**\n+     * Something more ambitious: semi-automated approach to polymorphic\n+     * deserialization, using ValueInstantiator; from Object to any\n+     * type...\n+     */\n+    static class PolymorphicBeanInstantiator extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return Object.class.getName();\n+        }\n+        \n+        @Override\n+        public boolean canCreateFromObjectWith() { return true; }\n+\n+        @Override\n+        public CreatorProperty[] getFromObjectArguments() {\n+            return  new CreatorProperty[] {\n+                    new CreatorProperty(\"type\", TypeFactory.defaultInstance().constructType(Class.class),\n+                            null, null, null, 0, null)\n+            };\n+        }\n+\n+        @Override\n+        public Object createFromObjectWith(Object[] args) {\n+            try {\n+                Class<?> cls = (Class<?>) args[0];\n+                return cls.newInstance();\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+    \n+    static class CreatorMapInstantiator extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return MyMap.class.getName();\n+        }\n+        \n+        @Override\n+        public boolean canCreateFromObjectWith() { return true; }\n+\n+        @Override\n+        public CreatorProperty[] getFromObjectArguments() {\n+            return  new CreatorProperty[] {\n+                    new CreatorProperty(\"name\", TypeFactory.defaultInstance().constructType(String.class),\n+                            null, null, null, 0, null)\n+            };\n+        }\n+\n+        @Override\n+        public Object createFromObjectWith(Object[] args) {\n+            return new MyMap((String) args[0]);\n+        }\n+    }\n+    \n+    static class MyDelegateBeanInstantiator extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() { return \"xxx\"; }\n+        \n+        @Override\n+        public boolean canCreateUsingDelegate() { return true; }\n+\n+        @Override\n+        public JavaType getDelegateType() {\n+            return TypeFactory.defaultInstance().constructType(Object.class);\n+        }\n+        \n+        @Override\n+        public Object createUsingDelegate(Object delegate) {\n+            return new MyBean(\"\"+delegate, true);\n+        }\n+    }\n+    \n+    static class MyListInstantiator extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return MyList.class.getName();\n+        }\n+        \n+        @Override\n+        public boolean canCreateUsingDefault() { return true; }\n+\n+        @Override\n+        public MyList createUsingDefault() {\n+            return new MyList(true);\n+        }\n+    }\n+\n+    static class MyDelegateListInstantiator extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() { return \"xxx\"; }\n+        \n+        @Override\n+        public boolean canCreateUsingDelegate() { return true; }\n+\n+        @Override\n+        public JavaType getDelegateType() {\n+            return TypeFactory.defaultInstance().constructType(Object.class);\n+        }\n+        \n+        @Override\n+        public Object createUsingDelegate(Object delegate) {\n+            MyList list = new MyList(true);\n+            list.add(delegate);\n+            return list;\n+        }\n+    }\n+    \n+    static class MyMapInstantiator extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return MyMap.class.getName();\n+        }\n+        \n+        @Override\n+        public boolean canCreateUsingDefault() { return true; }\n+\n+        @Override\n+        public MyMap createUsingDefault() {\n+            return new MyMap(true);\n+        }\n+    }\n+\n+    static class MyDelegateMapInstantiator extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() { return \"xxx\"; }\n+        \n+        @Override\n+        public boolean canCreateUsingDelegate() { return true; }\n+\n+        @Override\n+        public JavaType getDelegateType() {\n+            return TypeFactory.defaultInstance().constructType(Object.class);\n+        }\n+        \n+        @Override\n+        public Object createUsingDelegate(Object delegate) {\n+            MyMap map = new MyMap(true);\n+            map.put(\"value\", delegate);\n+            return map;\n+        }\n+    }\n+\n+    @JsonValueInstantiator(AnnotatedBeanInstantiator.class)\n+    static class AnnotatedBean {\n+        protected final String a;\n+        protected final int b;\n+        \n+        public AnnotatedBean(String a, int b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+    }\n+\n+    static class AnnotatedBeanInstantiator extends ValueInstantiator\n+    {\n+        @Override\n+        public String getValueTypeDesc() {\n+            return MyMap.class.getName();\n+        }\n+        \n+        @Override\n+        public boolean canCreateUsingDefault() { return true; }\n+\n+        @Override\n+        public AnnotatedBean createUsingDefault() {\n+            return new AnnotatedBean(\"foo\", 3);\n+        }\n+    }\n+    \n+    static class MyModule extends SimpleModule\n+    {\n+        public MyModule(Class<?> cls, ValueInstantiator inst)\n+        {\n+            super(\"Test\", Version.unknownVersion());\n+            this.addValueInstantiator(cls, inst);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests for default creators\n+    /**********************************************************\n+     */\n+\n+    public void testCustomBeanInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyBean.class, new MyBeanInstantiator()));\n+        MyBean bean = mapper.readValue(\"{}\", MyBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"secret!\", bean._secret);\n+    }\n+\n+    public void testCustomListInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyList.class, new MyListInstantiator()));\n+        MyList result = mapper.readValue(\"[]\", MyList.class);\n+        assertNotNull(result);\n+        assertEquals(MyList.class, result.getClass());\n+        assertEquals(0, result.size());\n+    }\n+\n+    public void testCustomMapInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyMap.class, new MyMapInstantiator()));\n+        MyMap result = mapper.readValue(\"{ \\\"a\\\":\\\"b\\\" }\", MyMap.class);\n+        assertNotNull(result);\n+        assertEquals(MyMap.class, result.getClass());\n+        assertEquals(1, result.size());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests for delegate creators\n+    /**********************************************************\n+     */\n+\n+    public void testDelegateBeanInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyBean.class, new MyDelegateBeanInstantiator()));\n+        MyBean bean = mapper.readValue(\"123\", MyBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"123\", bean._secret);\n+    }\n+\n+    public void testDelegateListInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyList.class, new MyDelegateListInstantiator()));\n+        MyList result = mapper.readValue(\"123\", MyList.class);\n+        assertNotNull(result);\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(123), result.get(0));\n+    }\n+    \n+    public void testDelegateMapInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyMap.class, new MyDelegateMapInstantiator()));\n+        MyMap result = mapper.readValue(\"123\", MyMap.class);\n+        assertNotNull(result);\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(123), result.values().iterator().next());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests for property-based creators\n+    /**********************************************************\n+     */\n+\n+    public void testPropertyBasedBeanInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(CreatorBean.class,\n+                new InstantiatorBase() {\n+                    @Override\n+                    public boolean canCreateFromObjectWith() { return true; }\n+        \n+                    @Override\n+                    public CreatorProperty[] getFromObjectArguments() {\n+                        return  new CreatorProperty[] {\n+                                new CreatorProperty(\"secret\", TypeFactory.defaultInstance().constructType(String.class),\n+                                        null, null, null, 0, null)\n+                        };\n+                    }\n+        \n+                    @Override\n+                    public Object createFromObjectWith(Object[] args) {\n+                        return new CreatorBean((String) args[0]);\n+                    }\n+        }));\n+        CreatorBean bean = mapper.readValue(\"{\\\"secret\\\":123,\\\"value\\\":37}\", CreatorBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"123\", bean._secret);\n+    }\n+\n+    public void testPropertyBasedMapInstantiator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MyMap.class, new CreatorMapInstantiator()));\n+        MyMap result = mapper.readValue(\"{\\\"name\\\":\\\"bob\\\", \\\"x\\\":\\\"y\\\"}\", MyMap.class);\n+        assertNotNull(result);\n+        assertEquals(2, result.size());\n+        assertEquals(\"bob\", result.get(\"bob\"));\n+        assertEquals(\"y\", result.get(\"x\"));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests for scalar-delegates\n+    /**********************************************************\n+     */\n+\n+    public void testBeanFromString() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MysteryBean.class,\n+                new InstantiatorBase() {\n+                    @Override\n+                    public boolean canCreateFromString() { return true; }\n+                    \n+                    @Override\n+                    public Object createFromString(String value) {\n+                        return new MysteryBean(value);\n+                    }\n+        }));\n+        MysteryBean result = mapper.readValue(quote(\"abc\"), MysteryBean.class);\n+        assertNotNull(result);\n+        assertEquals(\"abc\", result.value);\n+    }\n+\n+    public void testBeanFromInt() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MysteryBean.class,\n+                new InstantiatorBase() {\n+                    @Override\n+                    public boolean canCreateFromInt() { return true; }\n+                    \n+                    @Override\n+                    public Object createFromInt(int value) {\n+                        return new MysteryBean(value+1);\n+                    }\n+        }));\n+        MysteryBean result = mapper.readValue(\"37\", MysteryBean.class);\n+        assertNotNull(result);\n+        assertEquals(Integer.valueOf(38), result.value);\n+    }\n+\n+    public void testBeanFromLong() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MysteryBean.class,\n+                new InstantiatorBase() {\n+                    @Override\n+                    public boolean canCreateFromLong() { return true; }\n+                    \n+                    @Override\n+                    public Object createFromLong(long value) {\n+                        return new MysteryBean(value+1L);\n+                    }\n+        }));\n+        MysteryBean result = mapper.readValue(\"9876543210\", MysteryBean.class);\n+        assertNotNull(result);\n+        assertEquals(Long.valueOf(9876543211L), result.value);\n+    }\n+\n+    public void testBeanFromDouble() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MysteryBean.class,\n+                new InstantiatorBase() {\n+                    @Override\n+                    public boolean canCreateFromDouble() { return true; }\n+\n+                    @Override\n+                    public Object createFromDouble(double value) {\n+                        return new MysteryBean(2.0 * value);\n+                    }\n+        }));\n+        MysteryBean result = mapper.readValue(\"0.25\", MysteryBean.class);\n+        assertNotNull(result);\n+        assertEquals(Double.valueOf(0.5), result.value);\n+    }\n+\n+    public void testBeanFromBoolean() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(MysteryBean.class,\n+                new InstantiatorBase() {\n+                    @Override\n+                    public boolean canCreateFromBoolean() { return true; }\n+                    \n+                    @Override\n+                    public Object createFromBoolean(boolean value) {\n+                        return new MysteryBean(Boolean.valueOf(value));\n+                    }\n+        }));\n+        MysteryBean result = mapper.readValue(\"true\", MysteryBean.class);\n+        assertNotNull(result);\n+        assertEquals(Boolean.TRUE, result.value);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other tests\n+    /**********************************************************\n+     */\n+\n+    \n+    /**\n+     * Beyond basic features, it should be possible to even implement\n+     * polymorphic handling...\n+     */\n+    public void testPolymorphicCreatorBean() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new MyModule(PolymorphicBeanBase.class, new PolymorphicBeanInstantiator()));\n+        String JSON = \"{\\\"type\\\":\"+quote(PolymorphicBean.class.getName())+\",\\\"name\\\":\\\"Axel\\\"}\";\n+        PolymorphicBeanBase result = mapper.readValue(JSON, PolymorphicBeanBase.class);\n+        assertNotNull(result);\n+        assertSame(PolymorphicBean.class, result.getClass());\n+        assertEquals(\"Axel\", ((PolymorphicBean) result).name);\n+    }\n+\n+    public void testJackson633() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        AnnotatedBean bean = mapper.readValue(\"{}\", AnnotatedBean.class);\n+        assertNotNull(bean);\n+        assertEquals(\"foo\", bean.a);\n+        assertEquals(3, bean.b);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestArrayNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.TextNode;\n+import com.fasterxml.jackson.databind.node.TreeTraversingParser;\n+\n+/**\n+ * Additional tests for {@link ArrayNode} container class.\n+ */\n+public class TestArrayNode\n+    extends BaseMapTest\n+{\n+    public void testBasics() throws IOException\n+    {\n+        ArrayNode n = new ArrayNode(JsonNodeFactory.instance);\n+        assertStandardEquals(n);\n+        assertFalse(n.getElements().hasNext());\n+        assertFalse(n.getFieldNames().hasNext());\n+        TextNode text = TextNode.valueOf(\"x\");\n+        n.add(text);\n+        assertEquals(1, n.size());\n+        assertFalse(0 == n.hashCode());\n+        assertTrue(n.getElements().hasNext());\n+        // no field names for arrays\n+        assertFalse(n.getFieldNames().hasNext());\n+        assertNull(n.get(\"x\")); // not used with arrays\n+        assertTrue(n.path(\"x\").isMissingNode());\n+        assertSame(text, n.get(0));\n+\n+        // single element, so:\n+        assertFalse(n.has(\"field\"));\n+        assertTrue(n.has(0));\n+        assertFalse(n.has(1));\n+        \n+        // add null node too\n+        n.add((JsonNode) null);\n+        assertEquals(2, n.size());\n+        assertTrue(n.get(1).isNull());\n+        // change to text\n+        n.set(1, text);\n+        assertSame(text, n.get(1));\n+        n.set(0, null);\n+        assertTrue(n.get(0).isNull());\n+\n+        // and finally, clear it all\n+        ArrayNode n2 = new ArrayNode(JsonNodeFactory.instance);\n+        n2.add(\"foobar\");\n+        assertFalse(n.equals(n2));\n+        n.addAll(n2);\n+        assertEquals(3, n.size());\n+\n+        assertFalse(n.get(0).isTextual());\n+        assertNotNull(n.remove(0));\n+        assertEquals(2, n.size());\n+        assertTrue(n.get(0).isTextual());\n+\n+        ArrayList<JsonNode> nodes = new ArrayList<JsonNode>();\n+        nodes.add(text);\n+        n.addAll(nodes);\n+        assertEquals(3, n.size());\n+        assertNull(n.get(10000));\n+        assertNull(n.remove(-4));\n+\n+        TextNode text2 = TextNode.valueOf(\"b\");\n+        n.insert(0, text2);\n+        assertEquals(4, n.size());\n+        assertSame(text2, n.get(0));\n+\n+        assertNotNull(n.addArray());\n+        assertEquals(5, n.size());\n+        n.addPOJO(\"foo\");\n+        assertEquals(6, n.size());\n+\n+        // Try serializing it for fun, too...\n+        JsonGenerator jg = new MappingJsonFactory().createJsonGenerator(new StringWriter());\n+        n.serialize(jg, null);\n+\n+        n.removeAll();\n+        assertEquals(0, n.size());\n+    }\n+\n+    public void testAdds()\n+    {\n+        ArrayNode n = new ArrayNode(JsonNodeFactory.instance);\n+        assertNotNull(n.addArray());\n+        assertNotNull(n.addObject());\n+        n.addPOJO(\"foobar\");\n+        n.add(1);\n+        n.add(1L);\n+        n.add(0.5);\n+        n.add(0.5f);\n+        assertEquals(7, n.size());\n+\n+        assertNotNull(n.insertArray(0));\n+        assertNotNull(n.insertObject(0));\n+        n.insertPOJO(2, \"xxx\");\n+        assertEquals(10, n.size());\n+    }\n+\n+    /**\n+     * Test to verify [JACKSON-227]\n+     */\n+    public void testNullChecking()\n+    {\n+        ArrayNode a1 = JsonNodeFactory.instance.arrayNode();\n+        ArrayNode a2 = JsonNodeFactory.instance.arrayNode();\n+        // used to throw NPE before fix:\n+        a1.addAll(a2);\n+        assertEquals(0, a1.size());\n+        assertEquals(0, a2.size());\n+\n+        a2.addAll(a1);\n+        assertEquals(0, a1.size());\n+        assertEquals(0, a2.size());\n+    }\n+\n+    /**\n+     * Another test to verify [JACKSON-227]...\n+     */\n+    public void testNullChecking2()\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ArrayNode src = mapper.createArrayNode();\n+        ArrayNode dest = mapper.createArrayNode();\n+        src.add(\"element\");\n+        dest.addAll(src);\n+    }\n+    \n+    public void testParser() throws Exception\n+    {\n+        ArrayNode n = new ArrayNode(JsonNodeFactory.instance);\n+        n.add(123);\n+        TreeTraversingParser p = new TreeTraversingParser(n, null);\n+        p.setCodec(null);\n+        assertNull(p.getCodec());\n+        assertNotNull(p.getParsingContext());\n+        assertNotNull(p.getTokenLocation());\n+        assertNotNull(p.getCurrentLocation());\n+        assertNull(p.getEmbeddedObject());\n+        assertNull(p.currentNode());\n+\n+        //assertNull(p.getNumberType());\n+\n+        assertToken(JsonToken.START_ARRAY, p.nextToken());\n+        p.skipChildren();\n+        assertToken(JsonToken.END_ARRAY, p.getCurrentToken());\n+        p.close();\n+\n+        p = new TreeTraversingParser(n, null);\n+        p.nextToken();\n+        assertToken(JsonToken.VALUE_NUMBER_INT, p.nextToken());\n+        assertEquals(JsonParser.NumberType.INT, p.getNumberType());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+\n+import static org.junit.Assert.*;\n+\n+import org.junit.Assert;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n+\n+/**\n+ * Unit tests for verifying functionality of {@link JsonNode} methods that\n+ * convert values to other types\n+ *\n+ * @since 1.7\n+ */\n+public class TestConversions extends BaseMapTest\n+{\n+    static class Root {\n+        public Leaf leaf;\n+    }\n+\n+    static class Leaf {\n+        public int value;\n+    }\n+    \n+    // MixIn for [JACKSON-554]\n+    @JsonDeserialize(using = LeafDeserializer.class)\n+    public static class LeafMixIn\n+    {\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testAsInt() throws Exception\n+    {\n+        assertEquals(9, IntNode.valueOf(9).asInt());\n+        assertEquals(7, LongNode.valueOf(7L).asInt());\n+        assertEquals(13, new TextNode(\"13\").asInt());\n+        assertEquals(0, new TextNode(\"foobar\").asInt());\n+        assertEquals(27, new TextNode(\"foobar\").asInt(27));\n+        assertEquals(1, BooleanNode.TRUE.asInt());\n+    }\n+\n+    public void testAsBoolean() throws Exception\n+    {\n+        assertEquals(false, BooleanNode.FALSE.asBoolean());\n+        assertEquals(true, BooleanNode.TRUE.asBoolean());\n+        assertEquals(false, IntNode.valueOf(0).asBoolean());\n+        assertEquals(true, IntNode.valueOf(1).asBoolean());\n+        assertEquals(false, LongNode.valueOf(0).asBoolean());\n+        assertEquals(true, LongNode.valueOf(-34L).asBoolean());\n+        assertEquals(true, new TextNode(\"true\").asBoolean());\n+        assertEquals(false, new TextNode(\"false\").asBoolean());\n+        assertEquals(false, new TextNode(\"barf\").asBoolean());\n+        assertEquals(true, new TextNode(\"barf\").asBoolean(true));\n+\n+        assertEquals(true, new POJONode(Boolean.TRUE).asBoolean());\n+    }\n+    \n+    // Deserializer to trigger the problem described in [JACKSON-554]\n+    public static class LeafDeserializer extends JsonDeserializer<Leaf>\n+    {\n+        @Override\n+        public Leaf deserialize(JsonParser jp, DeserializationContext ctxt)\n+                throws IOException, JsonProcessingException\n+        {\n+            JsonNode tree = jp.readValueAsTree();\n+            Leaf leaf = new Leaf();\n+            leaf.value = tree.get(\"value\").getIntValue();\n+            return leaf;\n+        }\n+    }\n+\n+    // Test for [JACKSON-554]\n+    public void testTreeToValue() throws Exception\n+    {\n+        String JSON = \"{\\\"leaf\\\":{\\\"value\\\":13}}\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.getDeserializationConfig().addMixInAnnotations(Leaf.class, LeafMixIn.class);\n+        JsonNode root = mapper.readTree(JSON);\n+        // Ok, try converting to bean using two mechanisms\n+        Root r1 = mapper.treeToValue(root, Root.class);\n+        assertNotNull(r1);\n+        assertEquals(13, r1.leaf.value);\n+        Root r2 = mapper.readValue(root, Root.class);\n+        assertEquals(13, r2.leaf.value);\n+    }\n+\n+    // Test for [JACKSON-631]\n+    public void testBase64Text() throws Exception\n+    {\n+        // let's actually iterate over sets of encoding modes, lengths\n+        \n+        final int[] LENS = { 1, 2, 3, 4, 7, 9, 32, 33, 34, 35 };\n+        final Base64Variant[] VARIANTS = {\n+                Base64Variants.MIME,\n+                Base64Variants.MIME_NO_LINEFEEDS,\n+                Base64Variants.MODIFIED_FOR_URL,\n+                Base64Variants.PEM\n+        };\n+\n+        for (int len : LENS) {\n+            byte[] input = new byte[len];\n+            for (int i = 0; i < input.length; ++i) {\n+                input[i] = (byte) i;\n+            }\n+            for (Base64Variant variant : VARIANTS) {\n+                TextNode n = new TextNode(variant.encode(input));\n+                byte[] data = null;\n+                try {\n+                    data = n.getBinaryValue(variant);\n+                } catch (Exception e) {\n+                    throw new IOException(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage(), e);\n+                }\n+                assertNotNull(data);\n+                assertArrayEquals(data, input);\n+            }\n+        }\n+    }\n+\n+    static class Issue709Bean {\n+        public byte[] data;\n+    }\n+    \n+    /**\n+     * Simple test to verify that byte[] values can be handled properly when\n+     * converting, as long as there is metadata (from POJO definitions).\n+     */\n+    public void testIssue709() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        byte[] inputData = new byte[] { 1, 2, 3 };\n+        ObjectNode node = mapper.createObjectNode();\n+        node.put(\"data\", inputData);\n+        Issue709Bean result = mapper.readValue(node, Issue709Bean.class);\n+        String json = mapper.writeValueAsString(node);\n+        Issue709Bean resultFromString = mapper.readValue(json, Issue709Bean.class);\n+        Issue709Bean resultFromConvert = mapper.convertValue(node, Issue709Bean.class);\n+        \n+        // all methods should work equally well:\n+        Assert.assertArrayEquals(inputData, resultFromString.data);\n+        Assert.assertArrayEquals(inputData, resultFromConvert.data);\n+        Assert.assertArrayEquals(inputData, result.data);\n+    }\n+\n+    public void testEmbeddedObject() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        TokenBuffer buf = new TokenBuffer(mapper);\n+        buf.writeObject(new byte[0]);\n+        JsonNode node = mapper.readTree(buf.asParser());\n+        assertTrue(node.isPojo());\n+        assertEquals(byte[].class, ((POJONode) node).getPojo().getClass());\n+    }\n+\n+    public void testEmbeddedObjectInArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        TokenBuffer buf = new TokenBuffer(mapper);\n+        buf.writeStartArray();\n+        buf.writeObject(new byte[0]);\n+        buf.writeEndArray();\n+        JsonNode node = mapper.readTree(buf.asParser());\n+        assertTrue(node.isArray());\n+        assertEquals(1, node.size());\n+        JsonNode n = node.get(0);\n+        assertTrue(n.isPojo());\n+        assertEquals(byte[].class, ((POJONode) n).getPojo().getClass());\n+    }\n+\n+    public void testEmbeddedObjectInObject() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        TokenBuffer buf = new TokenBuffer(mapper);\n+        buf.writeStartObject();\n+        buf.writeFieldName(\"pojo\");\n+        buf.writeObject(new byte[0]);\n+        buf.writeEndObject();\n+        JsonNode node = mapper.readTree(buf.asParser());\n+        assertTrue(node.isObject());\n+        assertEquals(1, node.size());\n+        JsonNode n = node.get(\"pojo\");\n+        assertTrue(n.isPojo());\n+        assertEquals(byte[].class, ((POJONode) n).getPojo().getClass());\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestFindMethods.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+public class TestFindMethods\n+    extends BaseMapTest\n+{\n+    public void testNonMatching() throws Exception\n+    {\n+        JsonNode root = _buildTree();\n+\n+        assertNull(root.findValue(\"boogaboo\"));\n+        assertNull(root.findParent(\"boogaboo\"));\n+        JsonNode n = root.findPath(\"boogaboo\");\n+        assertNotNull(n);\n+        assertTrue(n.isMissingNode());\n+\n+        assertTrue(root.findValues(\"boogaboo\").isEmpty());\n+        assertTrue(root.findParents(\"boogaboo\").isEmpty());\n+    }\n+\n+    public void testMatchingSingle() throws Exception\n+    {\n+        JsonNode root = _buildTree();\n+\n+        JsonNode node = root.findValue(\"b\");\n+        assertNotNull(node);\n+        assertEquals(3, node.getIntValue());\n+        node = root.findParent(\"b\");\n+        assertNotNull(node);\n+        assertTrue(node.isObject());\n+        assertEquals(1, ((ObjectNode) node).size());\n+        assertEquals(3, node.path(\"b\").getIntValue());\n+    }\n+\n+    public void testMatchingMultiple() throws Exception\n+    {\n+        JsonNode root = _buildTree();\n+\n+        List<JsonNode> nodes = root.findValues(\"value\");\n+        assertEquals(2, nodes.size());\n+        // here we count on nodes being returned in order; true with Jackson:\n+        assertEquals(3, nodes.get(0).getIntValue());\n+        assertEquals(42, nodes.get(1).getIntValue());\n+\n+        nodes = root.findParents(\"value\");\n+        assertEquals(2, nodes.size());\n+        // should only return JSON Object nodes:\n+        assertTrue(nodes.get(0).isObject());\n+        assertTrue(nodes.get(1).isObject());\n+        assertEquals(3, nodes.get(0).path(\"value\").getIntValue());\n+        assertEquals(42, nodes.get(1).path(\"value\").getIntValue());\n+\n+        // and finally, convenience conversion method\n+        List<String> values = root.findValuesAsText(\"value\");\n+        assertEquals(2, values.size());\n+        assertEquals(\"3\", values.get(0));\n+        assertEquals(\"42\", values.get(1));\n+    }\n+    \n+    private JsonNode _buildTree() throws Exception\n+    {\n+        final String SAMPLE = \"{ \\\"a\\\" : { \\\"value\\\" : 3 },\"\n+            +\"\\\"array\\\" : [ { \\\"b\\\" : 3 }, {\\\"value\\\" : 42}, { \\\"other\\\" : true } ]\"\n+            +\"}\";\n+        return new ObjectMapper().readTree(SAMPLE);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestJsonNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.math.BigInteger;\n+import java.math.BigDecimal;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.BigIntegerNode;\n+import com.fasterxml.jackson.databind.node.BinaryNode;\n+import com.fasterxml.jackson.databind.node.BooleanNode;\n+import com.fasterxml.jackson.databind.node.DecimalNode;\n+import com.fasterxml.jackson.databind.node.DoubleNode;\n+import com.fasterxml.jackson.databind.node.IntNode;\n+import com.fasterxml.jackson.databind.node.LongNode;\n+import com.fasterxml.jackson.databind.node.MissingNode;\n+import com.fasterxml.jackson.databind.node.NullNode;\n+import com.fasterxml.jackson.databind.node.POJONode;\n+import com.fasterxml.jackson.databind.node.TextNode;\n+\n+/**\n+ * Basic tests for {@link JsonNode} base class and some features\n+ * of implementation classes\n+ */\n+public class TestJsonNode\n+    extends BaseMapTest\n+{\n+    public void testBasicsWithNullNode() throws Exception\n+    {\n+        // Let's use something that doesn't add much beyond JsonNode base\n+        NullNode n = NullNode.instance;\n+\n+        // basic properties\n+        assertFalse(n.isContainerNode());\n+        assertFalse(n.isBigDecimal());\n+        assertFalse(n.isBigInteger());\n+        assertFalse(n.isBinary());\n+        assertFalse(n.isBoolean());\n+        assertFalse(n.isPojo());\n+        assertFalse(n.isMissingNode());\n+\n+        // fallback accessors\n+        assertFalse(n.getBooleanValue());\n+        assertNull(n.getNumberValue());\n+        assertEquals(0, n.getIntValue());\n+        assertEquals(0L, n.getLongValue());\n+        assertEquals(BigDecimal.ZERO, n.getDecimalValue());\n+        assertEquals(BigInteger.ZERO, n.getBigIntegerValue());\n+\n+        assertEquals(0, n.size());\n+        assertFalse(n.getElements().hasNext());\n+        assertFalse(n.getFieldNames().hasNext());\n+        // path is never null; but does point to missing node\n+        assertNotNull(n.path(\"xyz\"));\n+        assertTrue(n.path(\"xyz\").isMissingNode());\n+\n+        assertFalse(n.has(\"field\"));\n+        assertFalse(n.has(3));\n+\n+        // 1.6:\n+        assertNodeNumbers(n, 0, 0.0);\n+    }\n+\n+    public void testText()\n+    {\n+        assertNull(TextNode.valueOf(null));\n+        TextNode empty = TextNode.valueOf(\"\");\n+        assertStandardEquals(empty);\n+        assertSame(TextNode.EMPTY_STRING_NODE, empty);\n+\n+        // 1.6:\n+        assertNodeNumbers(TextNode.valueOf(\"-3\"), -3, -3.0);\n+        assertNodeNumbers(TextNode.valueOf(\"17.75\"), 17, 17.75);\n+    \n+        // [JACKSON-587]\n+        long value = 127353264013893L;\n+        TextNode n = TextNode.valueOf(String.valueOf(value));\n+        assertEquals(value, n.asLong());\n+        \n+        // and then with non-numeric input\n+        assertNodeNumbersForNonNumeric(TextNode.valueOf(\"foobar\"));\n+\n+    }\n+\n+    public void testBoolean()\n+    {\n+        BooleanNode f = BooleanNode.getFalse();\n+        assertNotNull(f);\n+        assertTrue(f.isBoolean());\n+        assertSame(f, BooleanNode.valueOf(false));\n+        assertStandardEquals(f);\n+        assertFalse(f.getBooleanValue());\n+        assertEquals(\"false\", f.asText());\n+        assertEquals(JsonToken.VALUE_FALSE, f.asToken());\n+\n+        // and ditto for true\n+        BooleanNode t = BooleanNode.getTrue();\n+        assertNotNull(t);\n+        assertTrue(t.isBoolean());\n+        assertSame(t, BooleanNode.valueOf(true));\n+        assertStandardEquals(t);\n+        assertTrue(t.getBooleanValue());\n+        assertEquals(\"true\", t.asText());\n+        assertEquals(JsonToken.VALUE_TRUE, t.asToken());\n+\n+        // 1.6:\n+        assertNodeNumbers(f, 0, 0.0);\n+        assertNodeNumbers(t, 1, 1.0);\n+    }\n+\n+    public void testInt()\n+    {\n+        IntNode n = IntNode.valueOf(1);\n+        assertStandardEquals(n);\n+        assertTrue(0 != n.hashCode());\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());\n+        assertEquals(JsonParser.NumberType.INT, n.getNumberType());\n+        assertEquals(1, n.getIntValue());\n+        assertEquals(1L, n.getLongValue());\n+        assertEquals(BigDecimal.ONE, n.getDecimalValue());\n+        assertEquals(BigInteger.ONE, n.getBigIntegerValue());\n+        assertEquals(\"1\", n.asText());\n+\n+        // 1.6:\n+        assertNodeNumbers(n, 1, 1.0);\n+    }\n+\n+    public void testLong()\n+    {\n+        LongNode n = LongNode.valueOf(1L);\n+        assertStandardEquals(n);\n+        assertTrue(0 != n.hashCode());\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());\n+        assertEquals(JsonParser.NumberType.LONG, n.getNumberType());\n+        assertEquals(1, n.getIntValue());\n+        assertEquals(1L, n.getLongValue());\n+        assertEquals(BigDecimal.ONE, n.getDecimalValue());\n+        assertEquals(BigInteger.ONE, n.getBigIntegerValue());\n+        assertEquals(\"1\", n.asText());\n+\n+        // 1.6:\n+        assertNodeNumbers(n, 1, 1.0);\n+    }\n+\n+    public void testDouble()\n+    {\n+        DoubleNode n = DoubleNode.valueOf(0.25);\n+        assertStandardEquals(n);\n+        assertTrue(0 != n.hashCode());\n+        assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());\n+        assertEquals(JsonParser.NumberType.DOUBLE, n.getNumberType());\n+        assertEquals(0, n.getIntValue());\n+        assertEquals(0.25, n.getDoubleValue());\n+        assertNotNull(n.getDecimalValue());\n+        assertEquals(BigInteger.ZERO, n.getBigIntegerValue());\n+        assertEquals(\"0.25\", n.asText());\n+\n+        // 1.6:\n+        assertNodeNumbers(DoubleNode.valueOf(4.5), 4, 4.5);\n+    }\n+\n+    public void testDecimalNode() throws Exception\n+    {\n+        DecimalNode n = DecimalNode.valueOf(BigDecimal.ONE);\n+        assertStandardEquals(n);\n+        assertTrue(n.equals(new DecimalNode(BigDecimal.ONE)));\n+        assertEquals(JsonToken.VALUE_NUMBER_FLOAT, n.asToken());\n+        assertEquals(JsonParser.NumberType.BIG_DECIMAL, n.getNumberType());\n+        assertTrue(n.isNumber());\n+        assertFalse(n.isIntegralNumber());\n+        assertTrue(n.isBigDecimal());\n+        assertEquals(BigDecimal.ONE, n.getNumberValue());\n+        assertEquals(1, n.getIntValue());\n+        assertEquals(1L, n.getLongValue());\n+        assertEquals(BigDecimal.ONE, n.getDecimalValue());\n+        assertEquals(\"1\", n.asText());\n+\n+        // 1.6:\n+        assertNodeNumbers(n, 1, 1.0);\n+    }\n+\n+    public void testBigIntegerNode() throws Exception\n+    {\n+        BigIntegerNode n = BigIntegerNode.valueOf(BigInteger.ONE);\n+        assertStandardEquals(n);\n+        assertTrue(n.equals(new BigIntegerNode(BigInteger.ONE)));\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());\n+        assertEquals(JsonParser.NumberType.BIG_INTEGER, n.getNumberType());\n+        assertTrue(n.isNumber());\n+        assertTrue(n.isIntegralNumber());\n+        assertTrue(n.isBigInteger());\n+        assertEquals(BigInteger.ONE, n.getNumberValue());\n+        assertEquals(1, n.getIntValue());\n+        assertEquals(1L, n.getLongValue());\n+        assertEquals(BigInteger.ONE, n.getBigIntegerValue());\n+        assertEquals(\"1\", n.asText());\n+        \n+        // 1.6:\n+        assertNodeNumbers(n, 1, 1.0);\n+\n+        BigInteger maxLong = BigInteger.valueOf(Long.MAX_VALUE);\n+        \n+        n = BigIntegerNode.valueOf(maxLong);\n+        assertEquals(Long.MAX_VALUE, n.getLongValue());\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode n2 = mapper.readTree(maxLong.toString());\n+        assertEquals(Long.MAX_VALUE, n2.getLongValue());\n+\n+        // then over long limit:\n+        BigInteger beyondLong = maxLong.shiftLeft(2); // 4x max long\n+        n2 = mapper.readTree(beyondLong.toString());\n+        assertEquals(beyondLong, n2.getBigIntegerValue());\n+    }\n+\n+    public void testBinary() throws Exception\n+    {\n+        assertNull(BinaryNode.valueOf(null));\n+        assertNull(BinaryNode.valueOf(null, 0, 0));\n+\n+        BinaryNode empty = BinaryNode.valueOf(new byte[1], 0, 0);\n+        assertSame(BinaryNode.EMPTY_BINARY_NODE, empty);\n+        assertStandardEquals(empty);\n+\n+        byte[] data = new byte[3];\n+        data[1] = (byte) 3;\n+        BinaryNode n = BinaryNode.valueOf(data, 1, 1);\n+        data[2] = (byte) 3;\n+        BinaryNode n2 = BinaryNode.valueOf(data, 2, 1);\n+        assertTrue(n.equals(n2));\n+        assertEquals(\"\\\"Aw==\\\"\", n.toString());\n+\n+        assertEquals(\"AAMD\", new BinaryNode(data).asText());\n+\n+        // 1.6:\n+        assertNodeNumbersForNonNumeric(n);\n+    }\n+\n+    public void testPOJO()\n+    {\n+        POJONode n = new POJONode(\"x\"); // not really a pojo but that's ok\n+        assertStandardEquals(n);\n+        assertEquals(n, new POJONode(\"x\"));\n+        assertEquals(\"x\", n.asText());\n+        // not sure if this is what it'll remain as but:\n+        assertEquals(\"x\", n.toString());\n+\n+        assertEquals(new POJONode(null), new POJONode(null));\n+\n+        // 1.6:\n+        // default; non-numeric\n+        assertNodeNumbersForNonNumeric(n);\n+        // but if wrapping actual number, use it\n+        assertNodeNumbers(new POJONode(Integer.valueOf(123)), 123, 123.0);\n+    }\n+\n+    public void testMissing()\n+    {\n+        MissingNode n = MissingNode.getInstance();\n+        assertEquals(JsonToken.NOT_AVAILABLE, n.asToken());\n+        assertNull(n.asText());\n+        assertStandardEquals(n);\n+        assertEquals(\"\", n.toString());\n+\n+        // missing acts same as null, so:\n+        assertNodeNumbers(n, 0, 0.0);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNodeFactoryConfig.java\n+package com.fasterxml.jackson.databind.node;\n+\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+/**\n+ * Unit tests for ensuring that it is possible to override default\n+ * {@link JsonNodeFactory} when doing data binding\n+ */\n+public class TestNodeFactoryConfig\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Test classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Test factory that just replaces JSON Object node with\n+     * custom version\n+     */\n+    static class MyNodeFactory\n+        extends JsonNodeFactory\n+    {\n+        @Override\n+        public ObjectNode objectNode() { return new MyObjectNode(this); }\n+        \n+    }\n+\n+    static class MyObjectNode\n+        extends ObjectNode\n+    {\n+        public MyObjectNode(JsonNodeFactory f) {\n+            super(f);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Verifying [JACKSON-321]    \n+     */\n+    public void testWithObjectMapper() throws Exception\n+    {\n+         ObjectMapper m = new ObjectMapper();\n+         m.setNodeFactory(new MyNodeFactory());\n+         JsonNode n = m.readTree(\"{ \\\"a\\\":3 }\");\n+         assertNotNull(n);\n+         assertSame(MyObjectNode.class, n.getClass());\n+    }\n+\n+    /**\n+     * Verifying [JACKSON-321]    \n+     */\n+    public void testWithObjectReader() throws Exception\n+    {\n+         ObjectMapper m = new ObjectMapper();\n+         ObjectReader reader = m.reader(new MyNodeFactory());\n+         JsonNode n = reader.readTree(\"{ \\\"a\\\":3 }\");\n+         assertNotNull(n);\n+         assertSame(MyObjectNode.class, n.getClass());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestObjectNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.math.BigDecimal;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n+import com.fasterxml.jackson.databind.node.NullNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.node.TextNode;\n+\n+/**\n+ * Additional tests for {@link ObjectNode} container class.\n+ */\n+public class TestObjectNode\n+    extends BaseMapTest\n+{\n+    public void testBasics()\n+    {\n+        ObjectNode n = new ObjectNode(JsonNodeFactory.instance);\n+        assertStandardEquals(n);\n+\n+        assertFalse(n.getElements().hasNext());\n+        assertFalse(n.getFields().hasNext());\n+        assertFalse(n.getFieldNames().hasNext());\n+        assertNull(n.get(\"a\"));\n+        assertTrue(n.path(\"a\").isMissingNode());\n+\n+        TextNode text = TextNode.valueOf(\"x\");\n+        n.put(\"a\", text);\n+        assertEquals(1, n.size());\n+        assertTrue(n.getElements().hasNext());\n+        assertTrue(n.getFields().hasNext());\n+        assertTrue(n.getFieldNames().hasNext());\n+        assertSame(text, n.get(\"a\"));\n+        assertSame(text, n.path(\"a\"));\n+        assertNull(n.get(\"b\"));\n+        assertNull(n.get(0)); // not used with objects\n+\n+        assertFalse(n.has(0));\n+        assertTrue(n.has(\"a\"));\n+        assertFalse(n.has(\"b\"));\n+\n+        ObjectNode n2 = new ObjectNode(JsonNodeFactory.instance);\n+        n2.put(\"b\", 13);\n+        assertFalse(n.equals(n2));\n+        n.putAll(n2);\n+        assertEquals(2, n.size());\n+        n.put(\"null\", (JsonNode)null);\n+        assertEquals(3, n.size());\n+        // should replace, not add\n+        n.put(\"null\", \"notReallNull\");\n+        assertEquals(3, n.size());\n+        assertNotNull(n.remove(\"null\"));\n+        assertEquals(2, n.size());\n+\n+        Map<String,JsonNode> nodes = new HashMap<String,JsonNode>();\n+        nodes.put(\"d\", text);\n+        n.putAll(nodes);\n+        assertEquals(3, n.size());\n+\n+        n.removeAll();\n+        assertEquals(0, n.size());\n+    }\n+\n+    /**\n+     * Verify null handling\n+     */\n+    public void testNullChecking()\n+    {\n+        ObjectNode o1 = JsonNodeFactory.instance.objectNode();\n+        ObjectNode o2 = JsonNodeFactory.instance.objectNode();\n+        // used to throw NPE before fix:\n+        o1.putAll(o2);\n+        assertEquals(0, o1.size());\n+        assertEquals(0, o2.size());\n+\n+        // also: nulls should be converted to NullNodes...\n+        o1.put(\"x\", (ObjectNode) null);\n+        JsonNode n = o1.get(\"x\");\n+        assertNotNull(n);\n+        assertSame(n, NullNode.instance);\n+\n+        o1.put(\"str\", (String) null);\n+        n = o1.get(\"str\");\n+        assertNotNull(n);\n+        assertSame(n, NullNode.instance);\n+\n+        o1.put(\"d\", (BigDecimal) null);\n+        n = o1.get(\"d\");\n+        assertNotNull(n);\n+        assertSame(n, NullNode.instance);\n+    }\n+\n+    /**\n+     * Another test to verify [JACKSON-227]...\n+     */\n+    public void testNullChecking2()\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ObjectNode src = mapper.createObjectNode();\n+        ObjectNode dest = mapper.createObjectNode();\n+        src.put(\"a\", \"b\");\n+        dest.putAll(src);\n+    }\n+\n+    public void testRemove()\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ObjectNode ob = mapper.createObjectNode();\n+        ob.put(\"a\", \"a\");\n+        ob.put(\"b\", \"b\");\n+        ob.put(\"c\", \"c\");\n+        assertEquals(3, ob.size());\n+        assertSame(ob, ob.remove(Arrays.asList(\"a\", \"c\")));\n+        assertEquals(1, ob.size());\n+        assertEquals(\"b\", ob.get(\"b\").getTextValue());\n+    }\n+\n+    public void testRetain()\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ObjectNode ob = mapper.createObjectNode();\n+        ob.put(\"a\", \"a\");\n+        ob.put(\"b\", \"b\");\n+        ob.put(\"c\", \"c\");\n+        assertEquals(3, ob.size());\n+        assertSame(ob, ob.retain(\"a\", \"c\"));\n+        assertEquals(2, ob.size());\n+        assertEquals(\"a\", ob.get(\"a\").getTextValue());\n+        assertNull(ob.get(\"b\"));\n+        assertEquals(\"c\", ob.get(\"c\").getTextValue());\n+    }\n+\n+    // @since 1.8\n+    public void testValidWith() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ObjectNode root = mapper.createObjectNode();\n+        assertEquals(\"{}\", mapper.writeValueAsString(root));\n+        JsonNode child = root.with(\"prop\");\n+        assertTrue(child instanceof ObjectNode);\n+        assertEquals(\"{\\\"prop\\\":{}}\", mapper.writeValueAsString(root));\n+    }\n+\n+    public void testInvalidWith() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode root = mapper.createArrayNode();\n+        try { // should not work for non-ObjectNode nodes:\n+            root.with(\"prop\");\n+            fail(\"Expected exception\");\n+        } catch (UnsupportedOperationException e) {\n+            verifyException(e, \"not of type ObjectNode\");\n+        }\n+        // also: should fail of we already have non-object property\n+        ObjectNode root2 = mapper.createObjectNode();\n+        root2.put(\"prop\", 13);\n+        try { // should not work for non-ObjectNode nodes:\n+            root2.with(\"prop\");\n+            fail(\"Expected exception\");\n+        } catch (UnsupportedOperationException e) {\n+            verifyException(e, \"has value that is not\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestTreeTraversingParser.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.util.*;\n+\n+import static org.junit.Assert.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.BinaryNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.node.POJONode;\n+import com.fasterxml.jackson.databind.node.TextNode;\n+\n+public class TestTreeTraversingParser\n+    extends BaseMapTest\n+{\n+    static class Person {\n+        public String name;\n+        public int magicNumber;\n+        public List<String> kids;\n+    }\n+\n+    // Helper class for [JACKSON-370]\n+    @JsonIgnoreProperties(ignoreUnknown=true)\n+    public static class Jackson370Bean {\n+        public Inner inner;\n+    }\n+\n+    public static class Inner {\n+        public String value;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    public void testSimple() throws Exception\n+    {\n+        // For convenience, parse tree from JSON first\n+        final String JSON =\n+            \"{ \\\"a\\\" : 123, \\\"list\\\" : [ 12.25, null, true, { }, [ ] ] }\";\n+        ObjectMapper m = new ObjectMapper();\n+        JsonNode tree = m.readTree(JSON);\n+        JsonParser jp = tree.traverse();\n+\n+        assertNull(jp.getCurrentToken());\n+        assertNull(jp.getCurrentName());\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertNull(jp.getCurrentName());\n+        assertEquals(\"Expected START_OBJECT\", JsonToken.START_OBJECT.asString(), jp.getText());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"a\", jp.getCurrentName());\n+        assertEquals(\"a\", jp.getText());\n+\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(\"a\", jp.getCurrentName());\n+        assertEquals(123, jp.getIntValue());\n+        assertEquals(\"123\", jp.getText());\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"list\", jp.getCurrentName());\n+        assertEquals(\"list\", jp.getText());\n+\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertEquals(\"list\", jp.getCurrentName());\n+        assertEquals(JsonToken.START_ARRAY.asString(), jp.getText());\n+\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        assertNull(jp.getCurrentName());\n+        assertEquals(12.25, jp.getDoubleValue());\n+        assertEquals(\"12.25\", jp.getText());\n+\n+        assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+        assertNull(jp.getCurrentName());\n+        assertEquals(JsonToken.VALUE_NULL.asString(), jp.getText());\n+\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertNull(jp.getCurrentName());\n+        assertTrue(jp.getBooleanValue());\n+        assertEquals(JsonToken.VALUE_TRUE.asString(), jp.getText());\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertNull(jp.getCurrentName());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.getCurrentName());\n+\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertNull(jp.getCurrentName());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.getCurrentName());\n+\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertNull(jp.getCurrentName());\n+\n+        assertNull(jp.nextToken());\n+\n+        jp.close();\n+        assertTrue(jp.isClosed());\n+    }\n+\n+    public void testArray() throws Exception\n+    {\n+        // For convenience, parse tree from JSON first\n+        ObjectMapper m = new ObjectMapper();\n+\n+        JsonParser jp = m.readTree(\"[]\").traverse();\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        jp.close();\n+\n+        jp = m.readTree(\"[[]]\").traverse();\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        jp.close();\n+\n+        jp = m.readTree(\"[[ 12.1 ]]\").traverse();\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        jp.close();\n+    }\n+    \n+    public void testNested() throws Exception\n+    {\n+        // For convenience, parse tree from JSON first\n+        final String JSON =\n+            \"{\\\"coordinates\\\":[[[-3,\\n1],[179.859681,51.175092]]]}\"\n+            ;\n+        ObjectMapper m = new ObjectMapper();\n+        JsonNode tree = m.readTree(JSON);\n+        JsonParser jp = tree.traverse();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        \n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+    }\n+    \n+    /**\n+     * Unit test that verifies that we can (re)parse sample document\n+     * from JSON specification.\n+     */\n+    public void testSpecDoc() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        JsonNode tree = m.readTree(SAMPLE_DOC_JSON_SPEC);\n+        JsonParser jp = tree.traverse();\n+\n+        verifyJsonSpecSampleDoc(jp, true);\n+    }\n+\n+    public void testBinaryPojo() throws Exception\n+    {\n+        byte[] inputBinary = new byte[] { 1, 2, 100 };\n+        POJONode n = new POJONode(inputBinary);\n+        JsonParser jp = n.traverse();\n+\n+        assertNull(jp.getCurrentToken());\n+        assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken());\n+        byte[] data = jp.getBinaryValue();\n+        assertNotNull(data);\n+        assertArrayEquals(inputBinary, data);\n+        Object pojo = jp.getEmbeddedObject();\n+        assertSame(data, pojo);\n+    }\n+\n+    public void testBinaryNode() throws Exception\n+    {\n+        byte[] inputBinary = new byte[] { 0, -5 };\n+        BinaryNode n = new BinaryNode(inputBinary);\n+        JsonParser jp = n.traverse();\n+\n+        assertNull(jp.getCurrentToken());\n+        // exposed as POJO... not as VALUE_STRING\n+        assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken());\n+        byte[] data = jp.getBinaryValue();\n+        assertNotNull(data);\n+        assertArrayEquals(inputBinary, data);\n+\n+        // but as importantly, can be viewed as base64 encoded thing:\n+        assertEquals(\"APs=\", jp.getText());\n+\n+        assertNull(jp.nextToken());\n+    }\n+\n+    public void testTextAsBinary() throws Exception\n+    {\n+        TextNode n = new TextNode(\"   APs=\\n\");\n+        JsonParser jp = n.traverse();\n+        assertNull(jp.getCurrentToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        byte[] data = jp.getBinaryValue();\n+        assertNotNull(data);\n+        assertArrayEquals(new byte[] { 0, -5 }, data);\n+\n+        assertNull(jp.nextToken());\n+        jp.close();\n+        assertTrue(jp.isClosed());\n+\n+        // Also: let's verify we get an exception for garbage...\n+        n = new TextNode(\"?!??\");\n+        jp = n.traverse();\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        try {\n+            jp.getBinaryValue();\n+        } catch (JsonParseException e) {\n+            verifyException(e, \"Illegal character\");\n+        }\n+    }\n+\n+    /**\n+     * Very simple test case to verify that tree-to-POJO\n+     * conversion works ok\n+     */\n+    public void testDataBind() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        JsonNode tree = m.readTree\n+            (\"{ \\\"name\\\" : \\\"Tatu\\\", \\n\"\n+             +\"\\\"magicNumber\\\" : 42,\"\n+             +\"\\\"kids\\\" : [ \\\"Leo\\\", \\\"Lila\\\", \\\"Leia\\\" ] \\n\"\n+             +\"}\");\n+        Person tatu = m.treeToValue(tree, Person.class);\n+        assertNotNull(tatu);\n+        assertEquals(42, tatu.magicNumber);\n+        assertEquals(\"Tatu\", tatu.name);\n+        assertNotNull(tatu.kids);\n+        assertEquals(3, tatu.kids.size());\n+        assertEquals(\"Leo\", tatu.kids.get(0));\n+        assertEquals(\"Lila\", tatu.kids.get(1));\n+        assertEquals(\"Leia\", tatu.kids.get(2));\n+    }\n+\n+    // [JACKSON-370]\n+    public void testSkipChildrenWrt370() throws Exception\n+    {\n+        ObjectMapper o = new ObjectMapper();\n+        ObjectNode n = o.createObjectNode();\n+        n.putObject(\"inner\").put(\"value\", \"test\");\n+        n.putObject(\"unknown\").putNull(\"inner\");\n+        Jackson370Bean obj = o.readValue(n.traverse(), Jackson370Bean.class);\n+        assertNotNull(obj.inner);\n+        assertEquals(\"test\", obj.inner.value);        \n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationAnyGetter.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+\n+public class TestAnnotationAnyGetter\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper bean classes\n+    /**********************************************************\n+     */\n+\n+    static class Bean\n+    {\n+        final static Map<String,Boolean> extra = new HashMap<String,Boolean>();\n+        static {\n+            extra.put(\"a\", Boolean.TRUE);\n+        }\n+        \n+        public int getX() { return 3; }\n+\n+        @JsonAnyGetter\n+        public Map<String,Boolean> getExtra() { return extra; }\n+    }\n+\n+    static class AnyOnlyBean\n+    {\n+        @JsonAnyGetter\n+        public Map<String,Integer> any() {\n+            HashMap<String,Integer> map = new HashMap<String,Integer>();\n+            map.put(\"a\", 3);\n+            return map;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test cases\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleJsonValue() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        String json = serializeAsString(m, new Bean());\n+        Map<?,?> map = m.readValue(json, Map.class);\n+        assertEquals(2, map.size());\n+        assertEquals(Integer.valueOf(3), map.get(\"x\"));\n+        assertEquals(Boolean.TRUE, map.get(\"a\"));\n+    }\n+\n+    // [JACKSON-392]\n+    public void testAnyOnly() throws Exception\n+    {\n+        ObjectMapper m;\n+\n+        // First, with normal fail settings:\n+        m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, true);\n+        String json = serializeAsString(m, new AnyOnlyBean());\n+        assertEquals(\"{\\\"a\\\":3}\", json);\n+\n+        // then without fail\n+        m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        json = serializeAsString(m, new AnyOnlyBean());\n+        assertEquals(\"{\\\"a\\\":3}\", json);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationIgnore.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * This unit test suite tests use of {@link JsonIgnore} annotations\n+ * with  bean serialization; as well as (since 1.7)\n+ * {@link JsonIgnoreType}.\n+ */\n+public class TestAnnotationIgnore\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes\n+    /**********************************************************\n+     */\n+\n+    /// Class for testing enabled {@link JsonIgnore} annotation\n+    final static class SizeClassEnabledIgnore\n+    {\n+        @JsonIgnore public int getY() { return 9; }\n+\n+        // note: must be public to be seen\n+        public int getX() { return 1; }\n+\n+        @JsonIgnore public int getY2() { return 1; }\n+        @JsonIgnore public int getY3() { return 2; }\n+    }\n+\n+    /// Class for testing disabled {@link JsonIgnore} annotation\n+    final static class SizeClassDisabledIgnore\n+    {\n+        // note: must be public to be seen\n+        public int getX() { return 3; }\n+        @JsonIgnore(false) public int getY() { return 4; }\n+    }\n+\n+    static class BaseClassIgnore\n+    {\n+        @JsonProperty(\"x\")\n+        @JsonIgnore\n+        public int x() { return 1; }\n+\n+        public int getY() { return 2; }\n+    }\n+\n+    static class SubClassNonIgnore\n+        extends BaseClassIgnore\n+    {\n+        /* Annotations to disable ignorance, in sub-class; note that\n+         * we must still get \"JsonProperty\" fro super class\n+         */\n+        @Override\n+        @JsonIgnore(false)\n+        public int x() { return 3; }\n+    }\n+\n+    @JsonIgnoreType\n+    static class IgnoredType { }\n+\n+    @JsonIgnoreType(false)\n+    static class NonIgnoredType\n+    {\n+        public int value = 13;\n+        \n+        public IgnoredType ignored = new IgnoredType();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleIgnore() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // Should see \"x\", not \"y\"\n+        Map<String,Object> result = writeAndMap(m, new SizeClassEnabledIgnore());\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(1), result.get(\"x\"));\n+        assertNull(result.get(\"y\"));\n+    }\n+\n+    public void testDisabledIgnore() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // Should see \"x\" and \"y\"\n+        Map<String,Object> result = writeAndMap(m, new SizeClassDisabledIgnore());\n+        assertEquals(2, result.size());\n+        assertEquals(Integer.valueOf(3), result.get(\"x\"));\n+        assertEquals(Integer.valueOf(4), result.get(\"y\"));\n+    }\n+\n+    /**\n+     * Test case to verify that ignore tag can also be disabled\n+     * via inheritance\n+     */\n+    public void testIgnoreOver() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+\n+        // should only see \"y\"\n+        Map<String,Object> result = writeAndMap(m, new BaseClassIgnore());\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(2), result.get(\"y\"));\n+\n+        // Should see \"x\" and \"y\"\n+        result = writeAndMap(m, new SubClassNonIgnore());\n+        assertEquals(2, result.size());\n+        assertEquals(Integer.valueOf(3), result.get(\"x\"));\n+        assertEquals(Integer.valueOf(2), result.get(\"y\"));\n+    }\n+\n+    /**\n+     * @since 1.7\n+     */\n+    public void testIgnoreType() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertEquals(\"{\\\"value\\\":13}\", m.writeValueAsString(new NonIgnoredType()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationInheritance.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * This unit test suite tests use of Annotations for\n+ * bean serialization.\n+ */\n+public class TestAnnotationInheritance\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes\n+    /**********************************************************\n+     */\n+\n+    /// Base class for testing {@link JsonProperty} annotations\n+    static class BasePojo\n+    {\n+        @JsonProperty public int width() { return 3; }\n+        @JsonProperty public int length() { return 7; }\n+    }\n+\n+    /**\n+     * It should also be possible to specify annotations on interfaces,\n+     * to be implemented by classes. This should not only work when interface\n+     * is used (which may be the case for de-serialization) but also\n+     * when implementing class is used and overrides methods. In latter\n+     * case overriding methods should still \"inherit\" annotations -- this\n+     * is not something JVM runtime provides, but Jackson class\n+     * instrospector does.\n+     */\n+    interface PojoInterface\n+    {\n+        @JsonProperty int width();\n+        @JsonProperty int length();\n+    }\n+\n+    /**\n+     * Sub-class for testing that inheritance is handled properly\n+     * wrt annotations.\n+     */\n+    static class PojoSubclass extends BasePojo\n+    {\n+        /**\n+         * Should still be recognized as a Getter here.\n+         */\n+        @Override\n+        public int width() { return 9; }\n+    }\n+\n+    static class PojoImpl implements PojoInterface\n+    {\n+        // Both should be recognized as getters here\n+\n+        @Override\n+        public int width() { return 1; }\n+        @Override\n+        public int length() { return 2; }\n+\n+        public int getFoobar() { return 5; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Main tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleGetterInheritance() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new PojoSubclass());\n+        assertEquals(2, result.size());\n+        assertEquals(Integer.valueOf(7), result.get(\"length\"));\n+        assertEquals(Integer.valueOf(9), result.get(\"width\"));\n+    }\n+\n+    public void testSimpleGetterInterfaceImpl() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new PojoImpl());\n+        // should get 2 from interface, and one more from impl itself\n+        assertEquals(3, result.size());\n+        assertEquals(Integer.valueOf(5), result.get(\"foobar\"));\n+        assertEquals(Integer.valueOf(1), result.get(\"width\"));\n+        assertEquals(Integer.valueOf(2), result.get(\"length\"));\n+    }\n+\n+    /*\n+    //////////////////////////////////////////////\n+    // Helper methods\n+    //////////////////////////////////////////////\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+\tprivate Map<String,Object> writeAndMap(ObjectMapper m, Object value)\n+        throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        m.writeValue(sw, value);\n+        return (Map<String,Object>) m.readValue(sw.toString(), Object.class);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonRawValue.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * This unit test suite tests functioning of {@link JsonRawValue}\n+ * annotation with bean serialization.\n+ */\n+public class TestAnnotationJsonRawValue\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    /*\n+    /*********************************************************\n+    /* Helper bean classes\n+    /*********************************************************\n+     */\n+\n+    /// Class for testing {@link JsonRawValue} annotations with getters returning String\n+    @JsonPropertyOrder(alphabetic=true)\n+    final static class ClassGetter<T>\n+    {\n+    \tprivate final T _value;\n+    \t\n+        private ClassGetter(T value) { _value = value;}\n+ \n+        public T getNonRaw() { return _value; }\n+\n+        @JsonProperty(\"raw\") @JsonRawValue public T foobar() { return _value; }\n+        \n+        @JsonProperty @JsonRawValue protected T value() { return _value; }\n+    }\n+    \n+    /*\n+    /*********************************************************\n+    /* Test cases\n+    /*********************************************************\n+     */\n+\n+    public void testSimpleStringGetter() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        String value = \"abc\";\n+        String result = m.writeValueAsString(new ClassGetter<String>(value));\n+        String expected = String.format(\"{\\\"nonRaw\\\":\\\"%s\\\",\\\"raw\\\":%s,\\\"value\\\":%s}\", value, value, value);\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testSimpleNonStringGetter() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        int value = 123;\n+        String result = m.writeValueAsString(new ClassGetter<Integer>(value));\n+        String expected = String.format(\"{\\\"nonRaw\\\":%d,\\\"raw\\\":%d,\\\"value\\\":%d}\", value, value, value);\n+        assertEquals(expected, result);\n+    }\n+\n+    public void testNullStringGetter() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        String value = null;\n+        String result = m.writeValueAsString(new ClassGetter<String>(value));\n+        String expected = String.format(\"{\\\"nonRaw\\\":%d,\\\"raw\\\":%d,\\\"value\\\":%d}\", value, value, value);\n+        assertEquals(expected, result);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonSerialize.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+/**\n+ * This unit test suite tests use of @JsonClass Annotation\n+ * with bean serialization.\n+ */\n+public class TestAnnotationJsonSerialize\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes\n+    /**********************************************************\n+     */\n+\n+    interface ValueInterface {\n+        public int getX();\n+    }\n+\n+    static class ValueClass\n+        implements ValueInterface\n+    {\n+        @Override\n+        public int getX() { return 3; }\n+        public int getY() { return 5; }\n+    }\n+\n+    /**\n+     * Test class to verify that <code>JsonSerialize.as</code>\n+     * works as expected\n+     */\n+    static class WrapperClassForAs\n+    {\n+        @JsonSerialize(as=ValueInterface.class)\n+        public ValueClass getValue() {\n+            return new ValueClass();\n+        }\n+    }\n+\n+    // This should indicate that static type be used for all fields\n+    @JsonSerialize(typing=JsonSerialize.Typing.STATIC)\n+    static class WrapperClassForStaticTyping\n+    {\n+        public ValueInterface getValue() {\n+            return new ValueClass();\n+        }\n+    }\n+\n+    static class WrapperClassForStaticTyping2\n+    {\n+        @JsonSerialize(typing=JsonSerialize.Typing.STATIC)\n+        public ValueInterface getStaticValue() {\n+            return new ValueClass();\n+        }\n+\n+        @JsonSerialize(typing=JsonSerialize.Typing.DYNAMIC)\n+        public ValueInterface getDynamicValue() {\n+            return new ValueClass();\n+        }\n+    }\n+\n+    /**\n+     * Test bean that has an invalid {@link JsonClass} annotation.\n+     */\n+    static class BrokenClass\n+    {\n+        // invalid annotation: String not a supertype of Long\n+        @JsonSerialize(as=String.class)\n+        public Long getValue() {\n+            return Long.valueOf(4L);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class ValueMap extends HashMap<String,ValueInterface> { }\n+    @SuppressWarnings(\"serial\")\n+    static class ValueList extends ArrayList<ValueInterface> { }\n+    @SuppressWarnings(\"serial\")\n+    static class ValueLinkedList extends LinkedList<ValueInterface> { }\n+    \n+    // Classes for [JACKSON-294]\n+    @SuppressWarnings(\"unused\")\n+    static class Foo294\n+    {\n+        @JsonProperty private String id;\n+        @JsonSerialize(using = Bar294Serializer.class)\n+        private Bar294 bar;\n+\n+        public Foo294() { }\n+        public Foo294(String id, String id2) {\n+            this.id = id;\n+            bar = new Bar294(id2);\n+        }\n+    }\n+\n+    static class Bar294{\n+        @JsonProperty private String id;\n+        @JsonProperty private String name;\n+\n+        public Bar294() { }\n+        public Bar294(String id) {\n+            this.id = id;\n+        }\n+\n+        public String getId() { return id; }\n+        public String getName() { return name; }\n+    }\n+\n+    static class Bar294Serializer extends JsonSerializer<Bar294>\n+    {\n+        @Override\n+        public void serialize(Bar294 bar, JsonGenerator jgen,\n+            SerializerProvider provider) throws IOException\n+        {\n+            jgen.writeString(bar.id);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Main tests\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSimpleValueDefinition() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new WrapperClassForAs());\n+        assertEquals(1, result.size());\n+        Object ob = result.get(\"value\");\n+        // Should see only \"x\", not \"y\"\n+        result = (Map<String,Object>) ob;\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(3), result.get(\"x\"));\n+    }\n+\n+    public void testBrokenAnnotation() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        try {\n+            serializeAsString(m, new BrokenClass());\n+        } catch (Exception e) {\n+            verifyException(e, \"not a super-type of\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testStaticTypingForClass() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new WrapperClassForStaticTyping());\n+        assertEquals(1, result.size());\n+        Object ob = result.get(\"value\");\n+        // Should see only \"x\", not \"y\"\n+        result = (Map<String,Object>) ob;\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(3), result.get(\"x\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testMixedTypingForClass() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new WrapperClassForStaticTyping2());\n+        assertEquals(2, result.size());\n+\n+        Object obStatic = result.get(\"staticValue\");\n+        // Should see only \"x\", not \"y\"\n+        Map<String,Object> stat = (Map<String,Object>) obStatic;\n+        assertEquals(1, stat.size());\n+        assertEquals(Integer.valueOf(3), stat.get(\"x\"));\n+\n+        Object obDynamic = result.get(\"dynamicValue\");\n+        // Should see both\n+        Map<String,Object> dyn = (Map<String,Object>) obDynamic;\n+        assertEquals(2, dyn.size());\n+        assertEquals(Integer.valueOf(3), dyn.get(\"x\"));\n+        assertEquals(Integer.valueOf(5), dyn.get(\"y\"));\n+    }\n+\n+    public void testStaticTypingWithMap() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        ValueMap map = new ValueMap();\n+        map.put(\"a\", new ValueClass());\n+        assertEquals(\"{\\\"a\\\":{\\\"x\\\":3}}\", serializeAsString(m, map));\n+    }\n+\n+    public void testStaticTypingWithArrayList() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        ValueList list = new ValueList();\n+        list.add(new ValueClass());\n+        assertEquals(\"[{\\\"x\\\":3}]\", m.writeValueAsString(list));\n+    }\n+\n+    public void testStaticTypingWithLinkedList() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        ValueLinkedList list = new ValueLinkedList();\n+        list.add(new ValueClass());\n+        assertEquals(\"[{\\\"x\\\":3}]\", serializeAsString(m, list));\n+    }\n+    \n+    public void testStaticTypingWithArray() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        ValueInterface[] array = new ValueInterface[] { new ValueClass() };\n+        assertEquals(\"[{\\\"x\\\":3}]\", serializeAsString(m, array));\n+    }\n+\n+    public void testProblem294() throws Exception\n+    {\n+        assertEquals(\"{\\\"id\\\":\\\"fooId\\\",\\\"bar\\\":\\\"barId\\\"}\",\n+                new ObjectMapper().writeValueAsString(new Foo294(\"fooId\", \"barId\")));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonSerialize2.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.ser.std.NullSerializer;\n+\n+@SuppressWarnings(\"serial\")\n+public class TestAnnotationJsonSerialize2\n+    extends BaseMapTest\n+{\n+    // [JACKSON-480]\n+\n+    static class SimpleKey {\n+        protected final String key;\n+        \n+        public SimpleKey(String str) { key = str; }\n+        \n+        @Override public String toString() { return \"toString:\"+key; }\n+    }\n+\n+    static class SimpleValue {\n+        public final String value;\n+        \n+        public SimpleValue(String str) { value = str; }\n+    }\n+\n+    @JsonPropertyOrder({\"value\", \"value2\"})\n+    static class ActualValue extends SimpleValue\n+    {\n+        public final String other = \"123\";\n+        \n+        public ActualValue(String str) { super(str); }\n+    }\n+\n+    static class SimpleKeySerializer extends JsonSerializer<SimpleKey> {\n+        @Override\n+        public void serialize(SimpleKey key, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonProcessingException {\n+            jgen.writeFieldName(\"key \"+key.key);\n+        }\n+    }\n+\n+    static class SimpleValueSerializer extends JsonSerializer<SimpleValue> {\n+        @Override\n+        public void serialize(SimpleValue value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonProcessingException {\n+            jgen.writeString(\"value \"+value.value);\n+        }\n+    }\n+\n+    @JsonSerialize(contentAs=SimpleValue.class)\n+    static class SimpleValueList extends ArrayList<ActualValue> { }\n+\n+    @JsonSerialize(contentAs=SimpleValue.class)\n+    static class SimpleValueMap extends HashMap<SimpleKey, ActualValue> { }\n+\n+    @JsonSerialize(contentUsing=SimpleValueSerializer.class)\n+    static class SimpleValueListWithSerializer extends ArrayList<ActualValue> { }\n+\n+    @JsonSerialize(keyUsing=SimpleKeySerializer.class, contentUsing=SimpleValueSerializer.class)\n+    static class SimpleValueMapWithSerializer extends HashMap<SimpleKey, ActualValue> { }\n+    \n+    static class ListWrapperSimple\n+    {\n+        @JsonSerialize(contentAs=SimpleValue.class)\n+        public final ArrayList<ActualValue> values = new ArrayList<ActualValue>();\n+        \n+        public ListWrapperSimple(String value) {\n+            values.add(new ActualValue(value));\n+        }\n+    }\n+\n+    static class ListWrapperWithSerializer\n+    {\n+        @JsonSerialize(contentUsing=SimpleValueSerializer.class)\n+        public final ArrayList<ActualValue> values = new ArrayList<ActualValue>();\n+        \n+        public ListWrapperWithSerializer(String value) {\n+            values.add(new ActualValue(value));\n+        }\n+    }\n+    \n+    static class MapWrapperSimple\n+    {\n+        @JsonSerialize(contentAs=SimpleValue.class)\n+        public final HashMap<SimpleKey, ActualValue> values = new HashMap<SimpleKey, ActualValue>();\n+        \n+        public MapWrapperSimple(String key, String value) {\n+            values.put(new SimpleKey(key), new ActualValue(value));\n+        }\n+    }\n+\n+    static class MapWrapperWithSerializer\n+    {\n+        @JsonSerialize(keyUsing=SimpleKeySerializer.class, contentUsing=SimpleValueSerializer.class)\n+        public final HashMap<SimpleKey, ActualValue> values = new HashMap<SimpleKey, ActualValue>();\n+        \n+        public MapWrapperWithSerializer(String key, String value) {\n+            values.put(new SimpleKey(key), new ActualValue(value));\n+        }\n+    }\n+\n+    static class NullBean\n+    {\n+        @JsonSerialize(using=NullSerializer.class)\n+        public String value = \"abc\";\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    // [JACKSON-480], test value annotation applied to List value class\n+    public void testSerializedAsListWithClassAnnotations() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        SimpleValueList list = new SimpleValueList();\n+        list.add(new ActualValue(\"foo\"));\n+        assertEquals(\"[{\\\"value\\\":\\\"foo\\\"}]\", m.writeValueAsString(list));\n+    }\n+\n+    // [JACKSON-480], test value annotation applied to Map value class\n+    public void testSerializedAsMapWithClassAnnotations() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        SimpleValueMap map = new SimpleValueMap();\n+        map.put(new SimpleKey(\"x\"), new ActualValue(\"y\"));\n+        assertEquals(\"{\\\"toString:x\\\":{\\\"value\\\":\\\"y\\\"}}\", m.writeValueAsString(map));\n+    }\n+\n+    // [JACKSON-480], test Serialization annotation with List\n+    public void testSerializedAsListWithClassSerializer() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        SimpleValueListWithSerializer list = new SimpleValueListWithSerializer();\n+        list.add(new ActualValue(\"foo\"));\n+        assertEquals(\"[\\\"value foo\\\"]\", m.writeValueAsString(list));\n+    }\n+\n+    // [JACKSON-480], test Serialization annotation with Map\n+    public void testSerializedAsMapWithClassSerializer() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        SimpleValueMapWithSerializer map = new SimpleValueMapWithSerializer();\n+        map.put(new SimpleKey(\"abc\"), new ActualValue(\"123\"));\n+        assertEquals(\"{\\\"key abc\\\":\\\"value 123\\\"}\", m.writeValueAsString(map));\n+    }\n+    \n+    // [JACKSON-480], test annotations when applied to List property (getter, setter)\n+    public void testSerializedAsListWithPropertyAnnotations() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        ListWrapperSimple input = new ListWrapperSimple(\"bar\");\n+        assertEquals(\"{\\\"values\\\":[{\\\"value\\\":\\\"bar\\\"}]}\", m.writeValueAsString(input));\n+    }\n+\n+    public void testSerializedAsListWithPropertyAnnotations2() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        ListWrapperWithSerializer input = new ListWrapperWithSerializer(\"abc\");\n+        assertEquals(\"{\\\"values\\\":[\\\"value abc\\\"]}\", m.writeValueAsString(input));\n+    }\n+    \n+    // [JACKSON-480], test annotations when applied to Map property (getter, setter)\n+    public void testSerializedAsMapWithPropertyAnnotations() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        MapWrapperSimple input = new MapWrapperSimple(\"a\", \"b\");\n+        assertEquals(\"{\\\"values\\\":{\\\"toString:a\\\":{\\\"value\\\":\\\"b\\\"}}}\", m.writeValueAsString(input));\n+    }\n+\n+    public void testSerializedAsMapWithPropertyAnnotations2() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        MapWrapperWithSerializer input = new MapWrapperWithSerializer(\"foo\", \"b\");\n+        assertEquals(\"{\\\"values\\\":{\\\"key foo\\\":\\\"value b\\\"}}\", m.writeValueAsString(input));\n+    }\n+\n+    // [JACKSON-602]: Include.NON_EMPTY\n+    public void testEmptyInclusion() throws IOException\n+    {\n+        ObjectMapper defMapper = new ObjectMapper();\n+        ObjectMapper inclMapper = new ObjectMapper().setSerializationInclusion(JsonSerialize.Inclusion.NON_EMPTY);\n+\n+        StringWrapper str = new StringWrapper(\"\");\n+        assertEquals(\"{\\\"str\\\":\\\"\\\"}\", defMapper.writeValueAsString(str));\n+        assertEquals(\"{}\", inclMapper.writeValueAsString(str));\n+        assertEquals(\"{}\", inclMapper.writeValueAsString(new StringWrapper()));\n+\n+        ListWrapper<String> list = new ListWrapper<String>();\n+        assertEquals(\"{\\\"list\\\":[]}\", defMapper.writeValueAsString(list));\n+        assertEquals(\"{}\", inclMapper.writeValueAsString(list));\n+        assertEquals(\"{}\", inclMapper.writeValueAsString(new ListWrapper<String>()));\n+\n+        MapWrapper<String,Integer> map = new MapWrapper<String,Integer>(new HashMap<String,Integer>());\n+        assertEquals(\"{\\\"map\\\":{}}\", defMapper.writeValueAsString(map));\n+        assertEquals(\"{}\", inclMapper.writeValueAsString(map));\n+        assertEquals(\"{}\", inclMapper.writeValueAsString(new MapWrapper<String,Integer>(null)));\n+\n+        ArrayWrapper<Integer> array = new ArrayWrapper<Integer>(new Integer[0]);\n+        assertEquals(\"{\\\"array\\\":[]}\", defMapper.writeValueAsString(array));\n+        assertEquals(\"{}\", inclMapper.writeValueAsString(array));\n+        assertEquals(\"{}\", inclMapper.writeValueAsString(new ArrayWrapper<Integer>(null)));\n+    }\n+\n+    // [JACKSON-699]\n+    public void testNullSerializer() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new NullBean());\n+        assertEquals(\"{\\\"value\\\":null}\", json);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationJsonValue.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n+\n+/**\n+ * This unit test suite tests functioning of {@link JsonValue}\n+ * annotation with bean serialization.\n+ */\n+public class TestAnnotationJsonValue\n+    extends BaseMapTest\n+{\n+    /*\n+    /*********************************************************\n+    /* Helper bean classes\n+    /*********************************************************\n+     */\n+\n+    static class ValueClass<T>\n+    {\n+        final T _value;\n+\n+        public ValueClass(T v) { _value = v; }\n+\n+        @JsonValue T value() { return _value; }\n+\n+        // shouldn't need this, but may be useful for troubleshooting:\n+        @Override\n+        public String toString() { return \"???\"; }\n+    }\n+\n+    /**\n+     * Another test class to check that it is also possible to\n+     * force specific serializer to use with @JsonValue annotated\n+     * method. Difference is between Integer serialization, and\n+     * conversion to a Json String.\n+     */\n+    final static class ToStringValueClass<T>\n+        extends ValueClass<T>\n+    {\n+        public ToStringValueClass(T value) { super(value); }\n+\n+        // Also, need to use this annotation to help\n+        @JsonSerialize(using=ToStringSerializer.class)\n+        @Override\n+        @JsonValue T value() { return super.value(); }\n+    }\n+\n+    final static class ToStringValueClass2\n+        extends ValueClass<String>\n+    {\n+        public ToStringValueClass2(String value) { super(value); }\n+\n+        /* Simple as well, but let's ensure that other getters won't matter...\n+         */\n+\n+        @JsonProperty int getFoobar() { return 4; }\n+\n+        public String[] getSomethingElse() { return new String[] { \"1\", \"a\" }; }\n+    }\n+\n+    static class ValueBase {\n+        public String a = \"a\";\n+    }\n+\n+    static class ValueType extends ValueBase {\n+        public String b = \"b\";\n+    }\n+    \n+    // Finally, let's also test static vs dynamic type\n+    static class ValueWrapper {\n+        @JsonValue\n+        public ValueBase getX() { return new ValueType(); }\n+    }\n+\n+    static class MapBean\n+    {\n+        @JsonValue\n+        public Map<String,String> toMap()\n+        {\n+            HashMap<String,String> map = new HashMap<String,String>();\n+            map.put(\"a\", \"1\");\n+            return map;\n+        }\n+    }\n+    \n+    /*\n+    /*********************************************************\n+    /* Test cases\n+    /*********************************************************\n+     */\n+\n+    public void testSimpleJsonValue() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        String result = serializeAsString(m, new ValueClass<String>(\"abc\"));\n+        assertEquals(\"\\\"abc\\\"\", result);\n+    }\n+\n+    public void testJsonValueWithUseSerializer() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        String result = serializeAsString(m, new ToStringValueClass<Integer>(Integer.valueOf(123)));\n+        assertEquals(\"\\\"123\\\"\", result);\n+    }\n+\n+    /**\n+     * Test for verifying that additional getters won't confuse serializer.\n+     */\n+    public void testMixedJsonValue() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        String result = serializeAsString(m, new ToStringValueClass2(\"xyz\"));\n+        assertEquals(\"\\\"xyz\\\"\", result);\n+    }\n+\n+    public void testValueWithStaticType() throws Exception\n+    {\n+        // Ok; first, with dynamic type:\n+        ObjectMapper m = new ObjectMapper();\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\",\\\"b\\\":\\\"b\\\"}\", serializeAsString(m, new ValueWrapper()));\n+\n+        // then static\n+        m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\"}\", serializeAsString(m, new ValueWrapper()));\n+    }\n+\n+    public void testMapWithJsonValue() throws Exception\n+    {\n+        assertEquals(\"{\\\"a\\\":\\\"1\\\"}\", new ObjectMapper().writeValueAsString(new MapBean()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotations.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+/**\n+ * This unit test suite tests use of Annotations for\n+ * bean serialization.\n+ */\n+public class TestAnnotations\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /// Class for testing {@link JsonProperty} annotations with getters\n+    final static class SizeClassGetter\n+    {\n+        @JsonProperty public int size() { return 3; }\n+        @JsonProperty(\"length\") public int foobar() { return -17; }\n+        // note: need not be public since there's annotation\n+        @JsonProperty protected int value() { return 0; }\n+\n+        // dummy method; not a getter signature\n+        protected int getNotReally(int arg) { return 0; }\n+    }\n+\n+    // And additional testing to cover [JACKSON-64]\n+    final static class SizeClassGetter2\n+    {\n+        // Should still be considered property \"x\"\n+        @JsonProperty protected int getX() { return 3; }\n+    }\n+\n+    // and some support for testing [JACKSON-120]\n+    final static class SizeClassGetter3\n+    {\n+        // Should be considered property \"y\" even tho non-public\n+        @JsonSerialize protected int getY() { return 8; }\n+    }\n+\n+\n+    /**\n+     * Class for testing {@link JsonSerializer} annotation\n+     * for class itself.\n+     */\n+    @JsonSerialize(using=BogusSerializer.class)\n+    final static class ClassSerializer {\n+    }\n+\n+    /**\n+     * Class for testing an active {@link JsonSerialize#using} annotation\n+     * for a method\n+     */\n+    final static class ClassMethodSerializer {\n+        private int _x;\n+\n+        public ClassMethodSerializer(int x) { _x = x; }\n+\n+        @JsonSerialize(using=StringSerializer.class)\n+            public int getX() { return _x; }\n+    }\n+\n+    /**\n+     * Class for testing an inactive (one that will not have any effect)\n+     * {@link JsonSerialize} annotation for a method\n+     */\n+    final static class InactiveClassMethodSerializer {\n+        private int _x;\n+\n+        public InactiveClassMethodSerializer(int x) { _x = x; }\n+\n+        // Basically, has no effect, hence gets serialized as number\n+        @JsonSerialize(using=JsonSerializer.None.class)\n+            public int getX() { return _x; }\n+    }\n+\n+    /**\n+     * Class for verifying that getter information is inherited\n+     * as expected via normal class inheritance\n+     */\n+    static class BaseBean {\n+        public int getX() { return 1; }\n+        @SuppressWarnings(\"unused\")\n+            @JsonProperty(\"y\")\n+        private int getY() { return 2; }\n+    }\n+\n+    static class SubClassBean extends BaseBean {\n+        public int getZ() { return 3; }\n+    }\n+\n+    // For [JACKSON-666] (\"Feature of the Beast!\")\n+    @JsonPropertyOrder(alphabetic=true)\n+    static class GettersWithoutSetters\n+    {\n+        public int d = 0;\n+        \n+        @JsonCreator\n+        public GettersWithoutSetters(@JsonProperty(\"a\") int a) { }\n+        \n+        // included, since there is a constructor property\n+        public int getA() { return 3; }\n+\n+        // not included, as there's nothing matching\n+        public int getB() { return 4; }\n+\n+        // include as there is setter\n+        public int getC() { return 5; }\n+        public void setC(int v) { }\n+\n+        // and included, as there is a field\n+        public int getD() { return 6; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other helper classes\n+    /**********************************************************\n+     */\n+\n+    public final static class BogusSerializer extends JsonSerializer<Object>\n+    {\n+        @Override\n+        public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeBoolean(true);\n+        }\n+    }\n+\n+    private final static class StringSerializer extends JsonSerializer<Object>\n+    {\n+        @Override\n+        public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeString(\"X\"+value+\"X\");\n+        }\n+\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Main tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleGetter() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new SizeClassGetter());\n+        assertEquals(3, result.size());\n+        assertEquals(Integer.valueOf(3), result.get(\"size\"));\n+        assertEquals(Integer.valueOf(-17), result.get(\"length\"));\n+        assertEquals(Integer.valueOf(0), result.get(\"value\"));\n+    }\n+\n+    public void testSimpleGetter2() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new SizeClassGetter2());\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(3), result.get(\"x\"));\n+    }\n+\n+    // testing [JACKSON-120], implied getter\n+    public void testSimpleGetter3() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new SizeClassGetter3());\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(8), result.get(\"y\"));\n+    }\n+\n+    /**\n+     * Let's also verify that inherited super-class getters are used\n+     * as expected\n+     */\n+    public void testGetterInheritance() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new SubClassBean());\n+        assertEquals(3, result.size());\n+        assertEquals(Integer.valueOf(1), result.get(\"x\"));\n+        assertEquals(Integer.valueOf(2), result.get(\"y\"));\n+        assertEquals(Integer.valueOf(3), result.get(\"z\"));\n+    }\n+\n+    /**\n+     * Unit test to verify that {@link JsonSerialize#using} annotation works\n+     * when applied to a class\n+     */\n+    public void testClassSerializer() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        m.writeValue(sw, new ClassSerializer());\n+        assertEquals(\"true\", sw.toString());\n+    }\n+\n+    /**\n+     * Unit test to verify that @JsonSerializer annotation works\n+     * when applied to a Method\n+     */\n+    public void testActiveMethodSerializer() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        m.writeValue(sw, new ClassMethodSerializer(13));\n+        /* Here we will get wrapped as an object, since we have\n+         * full object, just override a single property\n+         */\n+        assertEquals(\"{\\\"x\\\":\\\"X13X\\\"}\", sw.toString());\n+    }\n+\n+    public void testInactiveMethodSerializer() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        m.writeValue(sw, new InactiveClassMethodSerializer(8));\n+        /* Here we will get wrapped as an object, since we have\n+         * full object, just override a single property\n+         */\n+        assertEquals(\"{\\\"x\\\":8}\", sw.toString());\n+    }\n+\n+    public void testGettersWithoutSetters() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        GettersWithoutSetters bean = new GettersWithoutSetters(123);\n+        assertFalse(m.isEnabled(SerializationConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS));\n+    \n+        // by default, all 4 found:\n+        assertEquals(\"{\\\"a\\\":3,\\\"b\\\":4,\\\"c\\\":5,\\\"d\\\":6}\", m.writeValueAsString(bean));\n+\n+        // but 3 if we require mutator:\n+        m = new ObjectMapper();\n+        m.enable(SerializationConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS);\n+        assertEquals(\"{\\\"a\\\":3,\\\"c\\\":5,\\\"d\\\":6}\", m.writeValueAsString(bean));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestArraySerialization.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+\n+\n+import java.io.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+public class TestArraySerialization\n+    extends BaseTest\n+{\n+    public void testLongStringArray() throws Exception\n+    {\n+        final int SIZE = 40000;\n+\n+        StringBuilder sb = new StringBuilder(SIZE*2);\n+        for (int i = 0; i < SIZE; ++i) {\n+            sb.append((char) i);\n+        }\n+        String str = sb.toString();\n+        ObjectMapper mapper = new ObjectMapper();\n+        byte[] data = mapper.writeValueAsBytes(new String[] { \"abc\", str, null, str });\n+        JsonParser jp = mapper.getJsonFactory().createJsonParser(data);\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"abc\", jp.getText());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        String actual = jp.getText();\n+        assertEquals(str.length(), actual.length());\n+        assertEquals(str, actual);\n+        assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(str, jp.getText());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+    }\n+    \n+    public void testIntArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, new int[] { 1, 2, 3, -7 });\n+        assertEquals(\"[1,2,3,-7]\", sw.toString().trim());\n+    }\n+\n+    public void testBigIntArray() throws Exception\n+    {\n+        final int SIZE = 99999;\n+        ObjectMapper mapper = new ObjectMapper();\n+        int[] ints = new int[SIZE];\n+        for (int i = 0; i < ints.length; ++i) {\n+            ints[i] = i;\n+        }\n+\n+        // Let's try couple of times, to ensure that state is handled\n+        // correctly by ObjectMapper (wrt buffer recycling used\n+        // with 'writeAsBytes()')\n+        JsonFactory f = mapper.getJsonFactory();\n+        for (int round = 0; round < 3; ++round) {\n+            byte[] data = mapper.writeValueAsBytes(ints);\n+            JsonParser jp = f.createJsonParser(data);\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            for (int i = 0; i < SIZE; ++i) {\n+                assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+                assertEquals(i, jp.getIntValue());\n+            }\n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        }\n+    }\n+    \n+    public void testLongArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, new long[] { Long.MIN_VALUE, 0, Long.MAX_VALUE });\n+        assertEquals(\"[\"+Long.MIN_VALUE+\",0,\"+Long.MAX_VALUE+\"]\", sw.toString().trim());\n+    }\n+\n+    public void testStringArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, new String[] { \"a\", \"\\\"foo\\\"\", null });\n+        assertEquals(\"[\\\"a\\\",\\\"\\\\\\\"foo\\\\\\\"\\\",null]\", sw.toString().trim());\n+    }\n+\n+    public void testDoubleArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, new double[] { 1.01, 2.0, -7, Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY });\n+        assertEquals(\"[1.01,2.0,-7.0,\\\"NaN\\\",\\\"-Infinity\\\",\\\"Infinity\\\"]\", sw.toString().trim());\n+    }\n+\n+    public void testFloatArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, new float[] { 1.01f, 2.0f, -7f, Float.NaN, Float.NEGATIVE_INFINITY, Float.POSITIVE_INFINITY });\n+        assertEquals(\"[1.01,2.0,-7.0,\\\"NaN\\\",\\\"-Infinity\\\",\\\"Infinity\\\"]\", sw.toString().trim());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAutoDetect.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+\n+/**\n+ * Unit tests for checking extended auto-detect configuration,\n+ * in context of serialization\n+ */\n+public class TestAutoDetect\n+    extends BaseMapTest\n+{\n+    static class FieldBean\n+    {\n+        public String p1 = \"public\";\n+        protected String p2 = \"protected\";\n+        @SuppressWarnings(\"unused\")\n+        private String p3 = \"private\";\n+    }\n+\n+    @JsonAutoDetect(fieldVisibility=JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC)\n+    static class ProtFieldBean extends FieldBean { }\n+\n+    static class MethodBean\n+    {\n+        public String getA() { return \"a\"; }\n+        protected String getB() { return \"b\"; }\n+        @SuppressWarnings(\"unused\")\n+        private String getC() { return \"c\"; }\n+    }\n+\n+    @JsonAutoDetect(getterVisibility=JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC)\n+    static class ProtMethodBean extends MethodBean { }\n+\n+    /*\n+    /*********************************************************\n+    /* Test methods\n+    /*********************************************************\n+     */\n+\n+    public void testDefaults() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // by default, only public fields and getters are detected\n+        assertEquals(\"{\\\"p1\\\":\\\"public\\\"}\",\n+                     m.writeValueAsString(new FieldBean()));\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\"}\",\n+                     m.writeValueAsString(new MethodBean()));\n+    }\n+\n+    public void testProtectedViaAnnotations() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+\n+        Map<String,Object> result = writeAndMap(m, new ProtFieldBean());\n+        assertEquals(2, result.size());\n+        assertEquals(\"public\", result.get(\"p1\"));\n+        assertEquals(\"protected\", result.get(\"p2\"));\n+        assertNull(result.get(\"p3\"));\n+\n+        result = writeAndMap(m, new ProtMethodBean());\n+        assertEquals(2, result.size());\n+        assertEquals(\"a\", result.get(\"a\"));\n+        assertEquals(\"b\", result.get(\"b\"));\n+        assertNull(result.get(\"c\"));\n+    }\n+\n+    public void testPrivateUsingGlobals() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        VisibilityChecker<?> vc = m.getVisibilityChecker();\n+        vc = vc.withFieldVisibility(JsonAutoDetect.Visibility.ANY);\n+        m.setVisibilityChecker(vc);\n+        \n+        Map<String,Object> result = writeAndMap(m, new FieldBean());\n+        assertEquals(3, result.size());\n+        assertEquals(\"public\", result.get(\"p1\"));\n+        assertEquals(\"protected\", result.get(\"p2\"));\n+        assertEquals(\"private\", result.get(\"p3\"));\n+\n+        m = new ObjectMapper();\n+        vc = m.getVisibilityChecker();\n+        vc = vc.withGetterVisibility(JsonAutoDetect.Visibility.ANY);\n+        m.setVisibilityChecker(vc);\n+        result = writeAndMap(m, new MethodBean());\n+        assertEquals(3, result.size());\n+        assertEquals(\"a\", result.get(\"a\"));\n+        assertEquals(\"b\", result.get(\"b\"));\n+        assertEquals(\"c\", result.get(\"c\"));\n+    }\n+\n+    // [JACKSON-621]\n+    public void testBasicSetup() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        VisibilityChecker<?> vc = m.getVisibilityChecker();\n+        vc = vc.with(JsonAutoDetect.Visibility.ANY);\n+        m.setVisibilityChecker(vc);\n+\n+        Map<String,Object> result = writeAndMap(m, new FieldBean());\n+        assertEquals(3, result.size());\n+        assertEquals(\"public\", result.get(\"p1\"));\n+        assertEquals(\"protected\", result.get(\"p2\"));\n+        assertEquals(\"private\", result.get(\"p3\"));\n+    }\n+\n+    // [JACKSON-595]\n+    public void testMapperShortcutMethods() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);\n+\n+        Map<String,Object> result = writeAndMap(m, new FieldBean());\n+        assertEquals(3, result.size());\n+        assertEquals(\"public\", result.get(\"p1\"));\n+        assertEquals(\"protected\", result.get(\"p2\"));\n+        assertEquals(\"private\", result.get(\"p3\"));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestBeanSerializer.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.BeanSerializer;\n+import com.fasterxml.jackson.databind.ser.BeanSerializerBuilder;\n+import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;\n+\n+/**\n+ * Unit tests for verifying that it is possible to configure\n+ * construction of {@link BeanSerializer} instances.\n+ * \n+ * @since 1.7\n+ */\n+public class TestBeanSerializer extends BaseMapTest\n+{\n+    /*\n+    /********************************************************\n+    /* Helper types\n+    /********************************************************\n+     */\n+\n+    static class ModuleImpl extends SimpleModule\n+    {\n+        protected BeanSerializerModifier modifier;\n+        \n+        public ModuleImpl(BeanSerializerModifier modifier)\n+        {\n+            super(\"test\", Version.unknownVersion());\n+            this.modifier = modifier;\n+        }\n+        \n+        @Override\n+        public void setupModule(SetupContext context)\n+        {\n+            super.setupModule(context);\n+            if (modifier != null) {\n+                context.addBeanSerializerModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    @JsonPropertyOrder({\"b\", \"a\"})\n+    static class Bean {\n+        public String b = \"b\";\n+        public String a = \"a\";\n+    }\n+\n+    static class RemovingModifier extends BeanSerializerModifier\n+    {\n+        private final String _removedProperty;\n+        \n+        public RemovingModifier(String remove) { _removedProperty = remove; }\n+        \n+        @Override\n+        public List<BeanPropertyWriter> changeProperties(SerializationConfig config, BasicBeanDescription beanDesc,\n+                List<BeanPropertyWriter> beanProperties)\n+        {\n+            Iterator<BeanPropertyWriter> it = beanProperties.iterator();\n+            while (it.hasNext()) {\n+                BeanPropertyWriter bpw = it.next();\n+                if (bpw.getName().equals(_removedProperty)) {\n+                    it.remove();\n+                }\n+            }\n+            return beanProperties;\n+        }\n+    }\n+    \n+    static class ReorderingModifier extends BeanSerializerModifier\n+    {\n+        @Override\n+        public List<BeanPropertyWriter> orderProperties(SerializationConfig config, BasicBeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n+        {\n+            TreeMap<String,BeanPropertyWriter> props = new TreeMap<String,BeanPropertyWriter>();\n+            for (BeanPropertyWriter bpw : beanProperties) {\n+                props.put(bpw.getName(), bpw);\n+            }\n+            return new ArrayList<BeanPropertyWriter>(props.values());\n+        }\n+    }\n+\n+    static class ReplacingModifier extends BeanSerializerModifier\n+    {\n+        private final JsonSerializer<?> _serializer;\n+        \n+        public ReplacingModifier(JsonSerializer<?> s) { _serializer = s; }\n+        \n+        @Override\n+        public JsonSerializer<?> modifySerializer(SerializationConfig config, BasicBeanDescription beanDesc,\n+                JsonSerializer<?> serializer) {\n+            return _serializer;\n+        }\n+    }\n+\n+    static class BuilderModifier extends BeanSerializerModifier\n+    {\n+        private final JsonSerializer<?> _serializer;\n+        \n+        public BuilderModifier(JsonSerializer<?> ser) {\n+            _serializer = ser;\n+        }\n+        \n+        @Override\n+        public BeanSerializerBuilder updateBuilder(SerializationConfig config,\n+                BasicBeanDescription beanDesc, BeanSerializerBuilder builder) {\n+            return new BogusSerializerBuilder(builder, _serializer);\n+        }\n+    }\n+\n+    static class BogusSerializerBuilder extends BeanSerializerBuilder\n+    {\n+        private final JsonSerializer<?> _serializer;\n+        \n+        public BogusSerializerBuilder(BeanSerializerBuilder src,\n+                JsonSerializer<?> ser) {\n+            super(src);\n+            _serializer = ser;\n+        }\n+\n+        @Override\n+        public JsonSerializer<?> build() {\n+            return _serializer;\n+        }\n+    }\n+    \n+    static class BogusBeanSerializer extends JsonSerializer<Object>\n+    {\n+        private final int _value;\n+        \n+        public BogusBeanSerializer(int v) { _value = v; }\n+        \n+        @Override\n+        public void serialize(Object value, JsonGenerator jgen,\n+                SerializerProvider provider) throws IOException {\n+            jgen.writeNumber(_value);\n+        }\n+    }\n+\n+    // for [JACKSON-670]\n+    \n+    static class EmptyBean {\n+        @JsonIgnore\n+        public String name = \"foo\";\n+    }\n+    \n+    static class EmptyBeanModifier extends BeanSerializerModifier\n+    {\n+        @Override\n+        public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\n+                BasicBeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n+        {\n+            JavaType strType = config.constructType(String.class);\n+            try {\n+                beanProperties.add(new BeanPropertyWriter(\n+                        null, null,\n+                        \"bogus\", strType,\n+                        null, null, strType,\n+                        null, EmptyBean.class.getDeclaredField(\"name\"),\n+                        false, null\n+                        ));\n+            } catch (NoSuchFieldException e) {\n+                throw new IllegalStateException(e.getMessage());\n+            }\n+            return beanProperties;\n+        }\n+    }\n+\n+    // For [JACKSON-694]: error message for conflicting getters sub-optimal\n+    static class BeanWithConflict\n+    {\n+        public int getX() { return 3; }\n+        public boolean isX() { return false; }\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Unit tests: success\n+    /********************************************************\n+     */\n+\n+    public void testPropertyRemoval() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new ModuleImpl(new RemovingModifier(\"a\")));\n+        Bean bean = new Bean();\n+        assertEquals(\"{\\\"b\\\":\\\"b\\\"}\", mapper.writeValueAsString(bean));\n+    }\n+\n+    public void testPropertyReorder() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new ModuleImpl(new ReorderingModifier()));\n+        Bean bean = new Bean();\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\",\\\"b\\\":\\\"b\\\"}\", mapper.writeValueAsString(bean));\n+    }\n+\n+    public void testBuilderReplacement() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new ModuleImpl(new BuilderModifier(new BogusBeanSerializer(17))));\n+        Bean bean = new Bean();\n+        assertEquals(\"17\", mapper.writeValueAsString(bean));\n+    }    \n+    public void testSerializerReplacement() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new ModuleImpl(new ReplacingModifier(new BogusBeanSerializer(123))));\n+        Bean bean = new Bean();\n+        assertEquals(\"123\", mapper.writeValueAsString(bean));\n+    }\n+\n+    // for [JACKSON-670]\n+    public void testEmptyBean() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.registerModule(new SimpleModule(\"test\", Version.unknownVersion()) {\n+            @Override\n+            public void setupModule(SetupContext context)\n+            {\n+                super.setupModule(context);\n+                context.addBeanSerializerModifier(new EmptyBeanModifier());\n+            }\n+        });\n+        String json = mapper.writeValueAsString(new EmptyBean());\n+        assertEquals(\"{\\\"bogus\\\":\\\"foo\\\"}\", json);\n+    }\n+\n+    /*\n+    /********************************************************\n+    /* Unit tests: failure handling\n+    /********************************************************\n+     */\n+    \n+    // for [JACKSON-694]\n+    public void testFailWithDupProps() throws Exception\n+    {\n+        BeanWithConflict bean = new BeanWithConflict();\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            String json = mapper.writeValueAsString(bean);\n+            fail(\"Should have failed due to conflicting accessor definitions; got JSON = \"+json);\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"Conflicting getter definitions\");\n+        }\n+    }        \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+public class TestCollectionSerialization\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    enum Key { A, B, C };\n+\n+    // Field-based simple bean with a single property, \"values\"\n+    final static class CollectionBean\n+    {\n+        @JsonProperty // not required\n+            public Collection<Object> values;\n+\n+        public CollectionBean(Collection<Object> c) { values = c; }\n+    }\n+\n+    static class EnumMapBean\n+    {\n+        EnumMap<Key,String> _map;\n+\n+        public EnumMapBean(EnumMap<Key,String> m)\n+        {\n+            _map = m;\n+        }\n+\n+        public EnumMap<Key,String> getMap() { return _map; }\n+    }\n+\n+    final static class IterableWrapper\n+        implements Iterable<Integer>\n+    {\n+        List<Integer> _ints = new ArrayList<Integer>();\n+\n+        public IterableWrapper(int[] values) {\n+            for (int i : values) {\n+                _ints.add(Integer.valueOf(i));\n+            }\n+        }\n+\n+        @Override\n+        public Iterator<Integer> iterator() {\n+            return _ints.iterator();\n+        }\n+    }\n+\n+    /**\n+     * Class needed for testing [JACKSON-220]\n+     */\n+    @SuppressWarnings(\"serial\")\n+    @JsonSerialize(using=ListSerializer.class)    \n+    static class PseudoList extends ArrayList<String>\n+    {\n+        public PseudoList(String... values) {\n+            super(Arrays.asList(values));\n+        }\n+    }\n+\n+    static class ListSerializer extends JsonSerializer<List<String>>\n+    {\n+        @Override\n+        public void serialize(List<String> value,\n+                              JsonGenerator jgen,\n+                              SerializerProvider provider)\n+            throws IOException\n+        {\n+            // just use standard List.toString(), output as JSON String\n+            jgen.writeString(value.toString());\n+        }\n+    }\n+\n+    // for [JACKSON-254], suppression of empty collections\n+    static class EmptyListBean {\n+        public List<String> empty = new ArrayList<String>();\n+    }\n+\n+    static class EmptyArrayBean {\n+        public String[] empty = new String[0];\n+    }\n+\n+    // [JACKSIN-689]\n+    static class BeanWithIterable {\n+        private final ArrayList<String> values = new ArrayList<String>();\n+        {\n+            values.add(\"value\");\n+        }\n+\n+        public Iterable<String> getValues() { return values; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testCollections()\n+        throws IOException\n+    {\n+        // Let's try different collections, arrays etc\n+        final int entryLen = 98;\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        for (int type = 0; type < 4; ++type) {\n+            Object value;\n+\n+            if (type == 0) { // first, array\n+                int[] ints = new int[entryLen];\n+                for (int i = 0; i < entryLen; ++i) {\n+                    ints[i] = Integer.valueOf(i);\n+                }\n+                value = ints;\n+            } else {\n+                Collection<Integer> c;\n+\n+                switch (type) {\n+                case 1:\n+                    c = new LinkedList<Integer>();\n+                    break;\n+                case 2:\n+                    c = new TreeSet<Integer>(); // has to be ordered\n+                    break;\n+                default:\n+                    c = new ArrayList<Integer>();\n+                    break;\n+                }\n+                for (int i = 0; i < entryLen; ++i) {\n+                    c.add(Integer.valueOf(i));\n+                }\n+                value = c;\n+            }\n+            StringWriter sw = new StringWriter();\n+            mapper.writeValue(sw, value);\n+            \n+            // and then need to verify:\n+            JsonParser jp = new JsonFactory().createJsonParser(sw.toString());\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            for (int i = 0; i < entryLen; ++i) {\n+                assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+                assertEquals(i, jp.getIntValue());\n+            }\n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        }\n+    }\n+\n+    public void testBigCollection()\n+        throws IOException\n+    {\n+        final int COUNT = 9999;\n+        ArrayList<Integer> value = new ArrayList<Integer>();\n+        for (int i = 0; i <= COUNT; ++i) {\n+            value.add(i);\n+        }\n+        ObjectMapper mapper = new ObjectMapper();\n+        // Let's test using 3 main variants...\n+        for (int mode = 0; mode < 3; ++mode) {\n+            JsonParser jp = null;\n+            switch (mode) {\n+            case 0:\n+                {\n+                    byte[] data = mapper.writeValueAsBytes(value);\n+                    jp = new JsonFactory().createJsonParser(data);\n+                }\n+                break;\n+            case 1:\n+                {\n+                    StringWriter sw = new StringWriter(value.size());\n+                    mapper.writeValue(sw, value);\n+                    jp = createParserUsingReader(sw.toString());\n+                }\n+                break;\n+            case 2:\n+                {\n+                    String str = mapper.writeValueAsString(value);\n+                    jp = createParserUsingReader(str);\n+                }\n+                break;\n+            }\n+\n+            // and verify\n+            assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+            for (int i = 0; i <= COUNT; ++i) {\n+                assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+                assertEquals(i, jp.getIntValue());\n+            }\n+            assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    public void testEnumMap()\n+        throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        EnumMap<Key,String> map = new EnumMap<Key,String>(Key.class);\n+        map.put(Key.B, \"xyz\");\n+        map.put(Key.C, \"abc\");\n+        // assuming EnumMap uses enum entry order, which I think is true...\n+        mapper.writeValue(sw, map);\n+        assertEquals(\"{\\\"B\\\":\\\"xyz\\\",\\\"C\\\":\\\"abc\\\"}\", sw.toString().trim());\n+    }\n+\n+    public void testIterator()\n+        throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        ArrayList<Integer> l = new ArrayList<Integer>();\n+        l.add(1);\n+        l.add(-9);\n+        l.add(0);\n+        mapper.writeValue(sw, l.iterator());\n+        assertEquals(\"[1,-9,0]\", sw.toString().trim());\n+    }\n+\n+    public void testIterable()\n+        throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, new IterableWrapper(new int[] { 1, 2, 3 }));\n+        assertEquals(\"[1,2,3]\", sw.toString().trim());\n+    }\n+\n+    // Test that checks that empty collections are properly serialized\n+    // when they are Bean properties\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyBeanCollection()\n+        throws IOException\n+    {\n+        Collection<Object> x = new ArrayList<Object>();\n+        x.add(\"foobar\");\n+        CollectionBean cb = new CollectionBean(x);\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, cb);\n+        assertEquals(1, result.size());\n+        assertTrue(result.containsKey(\"values\"));\n+        Collection<Object> x2 = (Collection<Object>) result.get(\"values\");\n+        assertNotNull(x2);\n+        assertEquals(x, x2);\n+    }\n+\n+    public void testNullBeanCollection()\n+        throws IOException\n+    {\n+        CollectionBean cb = new CollectionBean(null);\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, cb);\n+        assertEquals(1, result.size());\n+        assertTrue(result.containsKey(\"values\"));\n+        assertNull(result.get(\"values\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEmptyBeanEnumMap()\n+        throws IOException\n+    {\n+        EnumMap<Key,String> map = new EnumMap<Key,String>(Key.class);\n+        EnumMapBean b = new EnumMapBean(map);\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, b);\n+\n+        assertEquals(1, result.size());\n+        assertTrue(result.containsKey(\"map\"));\n+        // we deserialized to untyped, not back to bean, so:\n+        Map<Object,Object> map2 = (Map<Object,Object>) result.get(\"map\");\n+        assertNotNull(map2);\n+        assertEquals(0, map2.size());\n+    }\n+\n+    // Should also be able to serialize null EnumMaps as expected\n+    public void testNullBeanEnumMap()\n+        throws IOException\n+    {\n+        EnumMapBean b = new EnumMapBean(null);\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, b);\n+\n+        assertEquals(1, result.size());\n+        assertTrue(result.containsKey(\"map\"));\n+        assertNull(result.get(\"map\"));\n+    }\n+\n+    // Test [JACKSON-220]\n+    public void testListSerializer() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertEquals(\"\\\"[ab, cd, ef]\\\"\", m.writeValueAsString(new PseudoList(\"ab\", \"cd\", \"ef\")));\n+    }\n+\n+    // [JACKSON-254]\n+    public void testEmptyListOrArray() throws IOException\n+    {\n+        // by default, empty lists serialized normally\n+        EmptyListBean list = new EmptyListBean();\n+        EmptyArrayBean array = new EmptyArrayBean();\n+        ObjectMapper m = new ObjectMapper();\n+        assertTrue(m.getSerializationConfig().isEnabled(SerializationConfig.Feature.WRITE_EMPTY_JSON_ARRAYS));\n+        assertEquals(\"{\\\"empty\\\":[]}\", m.writeValueAsString(list));\n+        assertEquals(\"{\\\"empty\\\":[]}\", m.writeValueAsString(array));\n+\n+        // note: value of setting may be cached when constructing serializer, need a new instance\n+        m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.WRITE_EMPTY_JSON_ARRAYS, false);\n+        assertEquals(\"{}\", m.writeValueAsString(list));\n+        assertEquals(\"{}\", m.writeValueAsString(array));\n+    }\n+    \n+    // [JACKSON-689]\n+    public void testWithIterable() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertEquals(\"{\\\"values\\\":[\\\"value\\\"]}\", m.writeValueAsString(new BeanWithIterable()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+/**\n+ * Unit tests for checking handling of SerializationConfig.\n+ */\n+public class TestConfig\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper beans\n+    /**********************************************************\n+     */\n+\n+    @JsonSerialize(include=JsonSerialize.Inclusion.NON_DEFAULT,\n+                   typing=JsonSerialize.Typing.STATIC)\n+    final static class Config { }\n+\n+    final static class ConfigNone { }\n+\n+    static class AnnoBean {\n+        public int getX() { return 1; }\n+        @SuppressWarnings(\"unused\") @JsonProperty(\"y\")\n+        private int getY() { return 2; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Main tests\n+    /**********************************************************\n+     */\n+\n+    public void testDefaults()\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        SerializationConfig cfg = m.getSerializationConfig();\n+\n+        // First, defaults:\n+        assertTrue(cfg.isEnabled(SerializationConfig.Feature.USE_ANNOTATIONS));\n+        assertTrue(cfg.isEnabled(SerializationConfig.Feature.AUTO_DETECT_GETTERS));\n+        assertTrue(cfg.isEnabled(SerializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n+\n+        assertTrue(cfg.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS));\n+\n+        assertFalse(cfg.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT));\n+        assertFalse(cfg.isEnabled(SerializationConfig.Feature.USE_STATIC_TYPING));\n+\n+        // since 1.3:\n+        assertTrue(cfg.isEnabled(SerializationConfig.Feature.AUTO_DETECT_IS_GETTERS));\n+        // since 1.4\n+        \n+        assertTrue(cfg.isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS));\n+        // since 1.5\n+        assertTrue(cfg.isEnabled(SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION));\n+\n+    }\n+\n+    public void testOverrideIntrospectors()\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        SerializationConfig cfg = m.getSerializationConfig();\n+        // and finally, ensure we could override introspectors\n+        cfg = cfg.withClassIntrospector(null); // no way to verify tho\n+        cfg = cfg.withAnnotationIntrospector(null);\n+        assertNull(cfg.getAnnotationIntrospector());\n+    }\n+\n+    public void testMisc()\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.setDateFormat(null); // just to execute the code path\n+        assertNotNull(m.getSerializationConfig().toString()); // ditto\n+    }\n+\n+    public void testIndentation() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.INDENT_OUTPUT, true);\n+        Map<String,Integer> map = new HashMap<String,Integer>();\n+        map.put(\"a\", Integer.valueOf(2));\n+        String result = serializeAsString(m, map).trim();\n+        // 02-Jun-2009, tatu: not really a clean way but...\n+        String lf = System.getProperty(\"line.separator\");\n+        assertEquals(\"{\"+lf+\"  \\\"a\\\" : 2\"+lf+\"}\", result);\n+    }\n+\n+    public void testAnnotationsDisabled() throws Exception\n+    {\n+        // first: verify that annotation introspection is enabled by default\n+        ObjectMapper m = new ObjectMapper();\n+        assertTrue(m.getSerializationConfig().isEnabled(SerializationConfig.Feature.USE_ANNOTATIONS));\n+        Map<String,Object> result = writeAndMap(m, new AnnoBean());\n+        assertEquals(2, result.size());\n+\n+        m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.USE_ANNOTATIONS, false);\n+        result = writeAndMap(m, new AnnoBean());\n+        assertEquals(1, result.size());\n+    }\n+\n+    /**\n+     * Test for verifying working of [JACKSON-191]\n+     */\n+    public void testProviderConfig() throws Exception   \n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(0, mapper.getSerializerProvider().cachedSerializersCount());\n+        // and then should get one constructed for:\n+        Map<String,Object> result = this.writeAndMap(mapper, new AnnoBean());\n+        assertEquals(2, result.size());\n+        assertEquals(Integer.valueOf(1), result.get(\"x\"));\n+        assertEquals(Integer.valueOf(2), result.get(\"y\"));\n+\n+        /* Note: it is 2 because we'll also get serializer for basic 'int', not\n+         * just AnnoBean\n+         */\n+        /* 12-Jan-2010, tatus: Actually, probably more, if and when we typing\n+         *   aspects are considered (depending on what is cached)\n+         */\n+        int count = mapper.getSerializerProvider().cachedSerializersCount();\n+        if (count < 2) {\n+            fail(\"Should have at least 2 cached serializers, got \"+count);\n+        }\n+        mapper.getSerializerProvider().flushCachedSerializers();\n+        assertEquals(0, mapper.getSerializerProvider().cachedSerializersCount());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomFactory.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.*;\n+import java.util.Date;\n+import java.sql.Timestamp;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.CustomSerializerFactory;\n+\n+public class TestCustomFactory\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    static class DummySerializer<T>\n+        extends JsonSerializer<T>\n+    {\n+        @Override\n+        public void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonProcessingException\n+        {\n+            jgen.writeString(\"XXX\");\n+        }\n+    }\n+\n+    interface BeanInterface {\n+        public int foo();\n+    }\n+\n+    static class BeanImpl implements BeanInterface {\n+        @Override\n+        public int foo() { return 13; }\n+    }\n+\n+    static class BeanSerializer\n+        extends JsonSerializer<BeanInterface>\n+    {\n+        @Override\n+        public void serialize(BeanInterface value,\n+                JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonProcessingException\n+        {\n+            jgen.writeBoolean(true);\n+        }\n+    }\n+\n+    // for [JACKSON-373]\n+    interface BaseInterface {\n+        public int getX();\n+        public void setX(int value);\n+    }\n+\n+    interface SubInterface extends BaseInterface { }\n+\n+    class SubImpl implements SubInterface\n+    {\n+        protected int x;\n+        @Override\n+        public int getX() { return x; }\n+        @Override\n+        public void setX(int value) { x = value; }\n+    }\n+\n+    static class BaseInterfaceSerializer extends JsonSerializer<BaseInterface> \n+    {\n+        @Override\n+        public void serialize(BaseInterface value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonProcessingException\n+        {\n+            jgen.writeBoolean(true);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Simple test to verify specific mappings working\n+     */\n+    public void testSpecificOverrideDate() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        CustomSerializerFactory sf = new CustomSerializerFactory();\n+        sf.addSpecificMapping(Date.class, new DummySerializer<Date>());\n+        mapper.setSerializerFactory(sf);\n+\n+        String result = serializeAsString(mapper, new Date());\n+        assertEquals(\"\\\"XXX\\\"\", result);\n+\n+        // But also: sub-classes should NOT be affected.\n+        result = serializeAsString(mapper, new Timestamp(0L));\n+        assertEquals(\"0\", result);\n+    }\n+\n+    /**\n+     * Test to verify generic mapping by using super-class\n+     */\n+    public void testGenericOverrideDate() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        CustomSerializerFactory sf = new CustomSerializerFactory();\n+\n+        sf.addGenericMapping(Date.class, new DummySerializer<Date>());\n+        mapper.setSerializerFactory(sf);\n+\n+        String result = serializeAsString(mapper, new Timestamp(0L));\n+\n+        assertEquals(\"\\\"XXX\\\"\", result);\n+    }\n+\n+    // Unit test for [JACKSON-327]\n+    public void testRegisterForInterface() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        CustomSerializerFactory sf = new CustomSerializerFactory();\n+        sf.addGenericMapping(BeanInterface.class, new BeanSerializer());\n+        mapper.setSerializerFactory(sf);\n+\n+        ObjectWriter w = mapper.writerWithType(BeanInterface.class);\n+        String result = w.writeValueAsString(new BeanImpl());\n+\n+        assertEquals(\"true\", result);\n+    }\n+\n+    // Unit test for [JACKSON-373]\n+    public void testRegisterForTransitiveInterface() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        CustomSerializerFactory sf = new CustomSerializerFactory();\n+        sf.addGenericMapping(BaseInterface.class, new BaseInterfaceSerializer());\n+        mapper.setSerializerFactory(sf);\n+\n+        String result = mapper.writeValueAsString(new SubImpl());\n+\n+        assertEquals(\"true\", result);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.util.*;\n+\n+import javax.xml.parsers.DocumentBuilderFactory;\n+\n+import org.w3c.dom.Element;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.ser.CustomSerializerFactory;\n+import com.fasterxml.jackson.databind.ser.std.CollectionSerializer;\n+\n+/**\n+ * Test for verifying [JACKSON-238]\n+ *\n+ * @author Pablo Lalloni <plalloni@gmail.com>\n+ * @author tatu\n+ */\n+public class TestCustomSerializers\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper beans\n+    /**********************************************************\n+     */\n+\n+    static class ElementSerializer extends JsonSerializer<Element>\n+    {\n+        @Override\n+        public void serialize(Element value, JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException {\n+            jgen.writeString(\"element\");\n+        }\n+    }\n+    \n+    @JsonSerialize(using = ElementSerializer.class)\n+    public static class ElementMixin {}\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+    */\n+    \n+    public void testCustomization() throws Exception\n+    {\n+        ObjectMapper objectMapper = new ObjectMapper();\n+        objectMapper.getSerializationConfig().addMixInAnnotations(Element.class, ElementMixin.class);\n+        Element element = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument().createElement(\"el\");\n+        StringWriter sw = new StringWriter();\n+        objectMapper.writeValue(sw, element);\n+        assertEquals(sw.toString(), \"\\\"element\\\"\");\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public void testCustomLists() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();    \t\n+        CustomSerializerFactory sf = new CustomSerializerFactory();\n+        JsonSerializer<?> ser = new CollectionSerializer(null, false, null, null, null);\n+        final JsonSerializer<Object> collectionSerializer = (JsonSerializer<Object>) ser;\n+        \n+        sf.addGenericMapping(Collection.class, new JsonSerializer<Collection>() {\n+            @Override\n+            public void serialize(Collection value, JsonGenerator jgen, SerializerProvider provider)\n+                    throws IOException, JsonProcessingException {\n+                if (value.size() != 0) {\n+                    collectionSerializer.serialize(value, jgen, provider);\n+                } else {\n+                    jgen.writeNull();\n+                }\n+            }\n+        });\n+        mapper.setSerializerFactory(sf);\n+        assertEquals(\"null\", mapper.writeValueAsString(new ArrayList<Object>()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCyclicTypes.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Simple unit tests to verify that it is possible to handle\n+ * potentially cyclic structures, as long as object graph itself\n+ * is not cyclic. This is the case for directed hierarchies like\n+ * trees and DAGs.\n+ */\n+public class TestCyclicTypes\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper bean classes\n+    /**********************************************************\n+     */\n+\n+    static class Bean\n+    {\n+        Bean _next;\n+        final String _name;\n+\n+        public Bean(Bean next, String name) {\n+            _next = next;\n+            _name = name;\n+        }\n+\n+        public Bean getNext() { return _next; }\n+        public String getName() { return _name; }\n+\n+        public void assignNext(Bean n) { _next = n; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Types\n+    /**********************************************************\n+     */\n+\n+    public void testLinked() throws Exception\n+    {\n+        Bean last = new Bean(null, \"last\");\n+        Bean first = new Bean(last, \"first\");\n+        Map<String,Object> map = writeAndMap(new ObjectMapper(), first);\n+\n+        assertEquals(2, map.size());\n+        assertEquals(\"first\", map.get(\"name\"));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String,Object> map2 = (Map<String,Object>) map.get(\"next\");\n+        assertNotNull(map2);\n+        assertEquals(2, map2.size());\n+        assertEquals(\"last\", map2.get(\"name\"));\n+        assertNull(map2.get(\"next\"));\n+    }\n+\n+    /**\n+     * Test for verifying that [JACKSON-158] works as expected\n+     */\n+    public void testSelfReference() throws Exception\n+    {\n+        Bean selfRef = new Bean(null, \"self-refs\");\n+        Bean first = new Bean(selfRef, \"first\");\n+        selfRef.assignNext(selfRef);\n+        ObjectMapper m = new ObjectMapper();\n+        Bean[] wrapper = new Bean[] { first };\n+        try {\n+            writeAndMap(m, wrapper);\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Direct self-reference leading to cycle\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.*;\n+import java.text.*;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestDateSerialization\n+    extends BaseMapTest\n+{\n+    static class TimeZoneBean {\n+        private TimeZone tz;\n+        \n+        public TimeZoneBean(String name) {\n+            tz = TimeZone.getTimeZone(name);\n+        }\n+\n+        public TimeZone getTz() { return tz; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    public void testDateNumeric() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        // default is to output time stamps...\n+        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS));\n+        // shouldn't matter which offset we give...\n+        mapper.writeValue(sw, new Date(199L));\n+        assertEquals(\"199\", sw.toString());\n+    }\n+\n+    public void testDateISO8601() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        mapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false);\n+        // let's hit epoch start\n+        mapper.writeValue(sw, new Date(0L));\n+        assertEquals(\"\\\"1970-01-01T00:00:00.000+0000\\\"\", sw.toString());\n+    }\n+\n+    public void testDateOther() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'X'HH:mm:ss\");\n+        df.setTimeZone(TimeZone.getTimeZone(\"PST\"));\n+        mapper.setDateFormat(df);\n+        // let's hit epoch start, offset by a bit\n+        assertEquals(quote(\"1969-12-31X16:00:00\"), mapper.writeValueAsString(new Date(0L)));\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    public void testSqlDate() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // use date 1999-04-01 (note: months are 0-based, use constant)\n+        java.sql.Date date = new java.sql.Date(99, Calendar.APRIL, 1);\n+        assertEquals(quote(\"1999-04-01\"), serializeAsString(mapper, date));\n+    }\n+\n+    public void testTimeZone() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        TimeZone input = TimeZone.getTimeZone(\"PST\");\n+        String json = mapper.writeValueAsString(input);\n+        assertEquals(quote(\"PST\"), json);\n+    }\n+\n+    // [JACKSON-663]\n+    public void testTimeZoneInBean() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new TimeZoneBean(\"PST\"));\n+        assertEquals(\"{\\\"tz\\\":\\\"PST\\\"}\", json);\n+    }\n+    \n+    // [JACKSON-648]: (re)configuring via ObjectWriter\n+    public void testDateUsingObjectWriter() throws IOException\n+    {\n+        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'X'HH:mm:ss\");\n+        df.setTimeZone(TimeZone.getTimeZone(\"PST\"));\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(quote(\"1969-12-31X16:00:00\"),\n+                mapper.writer(df).writeValueAsString(new Date(0L)));\n+        ObjectWriter w = mapper.writer((DateFormat)null);\n+        assertEquals(\"0\", w.writeValueAsString(new Date(0L)));\n+\n+        w = w.withDateFormat(df);\n+        assertEquals(quote(\"1969-12-31X16:00:00\"), w.writeValueAsString(new Date(0L)));\n+        w = w.withDateFormat(null);\n+        assertEquals(\"0\", w.writeValueAsString(new Date(0L)));\n+    }\n+\n+    // [JACKSON-606]\n+    public void testDatesAsMapKeys() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        Map<Date,Integer> map = new HashMap<Date,Integer>();\n+        assertFalse(mapper.isEnabled(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS));\n+        map.put(new Date(0L), Integer.valueOf(1));\n+        // by default will serialize as ISO-8601 values...\n+        assertEquals(\"{\\\"1970-01-01T00:00:00.000+0000\\\":1}\", mapper.writeValueAsString(map));\n+        \n+        // but can change to use timestamps too\n+        mapper.configure(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true);\n+        assertEquals(\"{\\\"0\\\":1}\", mapper.writeValueAsString(map));\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEmptyClass.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+public class TestEmptyClass\n+    extends BaseMapTest\n+{\n+    static class Empty { }\n+\n+    @JsonSerialize\n+    static class EmptyWithAnno { }\n+\n+    /**\n+     * Test to check that [JACKSON-201] works if there is a recognized\n+     * annotation (which indicates type is serializable)\n+     */\n+    public void testEmptyWithAnnotations() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // First: without annotations, should complain\n+        try {\n+            serializeAsString(mapper, new Empty());\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"No serializer found for class\");\n+        }\n+\n+        // But not if there is a recognized annotation\n+        assertEquals(\"{}\", serializeAsString(mapper, new EmptyWithAnno()));\n+\n+        // Including class annotation through mix-ins\n+        mapper = new ObjectMapper();\n+        mapper.getSerializationConfig().addMixInAnnotations(Empty.class, EmptyWithAnno.class);\n+        assertEquals(\"{}\", serializeAsString(mapper, new Empty()));\n+    }\n+\n+    /**\n+     * Alternative it is possible to use a feature to allow\n+     * serializing empty classes, too\n+     */\n+    public void testEmptyWithFeature() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // should be enabled by default\n+        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS));\n+        mapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false);\n+        assertEquals(\"{}\", serializeAsString(mapper, new Empty()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonValue;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.CustomSerializerFactory;\n+import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n+\n+/**\n+ * Unit tests for verifying serialization of simple basic non-structured\n+ * types; primitives (and/or their wrappers), Strings.\n+ */\n+public class TestEnumSerialization\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper enums\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Test enumeration for verifying Enum serialization functionality.\n+     */\n+    protected enum TestEnum {\n+        A, B, C;\n+        private TestEnum() { }\n+\n+        @Override public String toString() { return name().toLowerCase(); }\n+    }\n+\n+    /**\n+     * Alternative version that forces use of \"toString-serializer\".\n+     */\n+    @JsonSerialize(using=ToStringSerializer.class)\n+    protected enum AnnotatedTestEnum {\n+        A2, B2, C2;\n+        private AnnotatedTestEnum() { }\n+\n+        @Override public String toString() { return name().toLowerCase(); }\n+    }\n+\n+    protected enum EnumWithJsonValue {\n+        A(\"foo\"), B(\"bar\");\n+        private final String name;\n+        private EnumWithJsonValue(String n) {\n+            name = n;\n+        }\n+        @JsonValue\n+        @Override\n+        public String toString() { return name; }\n+    }\n+\n+    protected static interface ToStringMixin {\n+        @Override\n+        @JsonValue public String toString();\n+    }\n+\n+    protected enum SerializableEnum implements JsonSerializable\n+    {\n+        A, B, C;\n+\n+        private SerializableEnum() { }\n+        \n+        @Override\n+        public void serializeWithType(JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer)\n+                throws IOException, JsonProcessingException\n+        {\n+            serialize(jgen, provider);\n+        }\n+\n+        @Override\n+        public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException\n+        {\n+            jgen.writeString(\"foo\");\n+        }\n+    }\n+\n+    protected enum LowerCaseEnum {\n+        A, B, C;\n+        private LowerCaseEnum() { }\n+        @Override\n+        public String toString() { return name().toLowerCase(); }\n+    }\n+\n+    static class MapBean {\n+        public Map<TestEnum,Integer> map = new HashMap<TestEnum,Integer>();\n+        \n+        public void add(TestEnum key, int value) {\n+            map.put(key, Integer.valueOf(value));\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimple() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, TestEnum.B);\n+        assertEquals(\"\\\"B\\\"\", sw.toString());\n+    }\n+\n+    public void testEnumSet() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        EnumSet<TestEnum> value = EnumSet.of(TestEnum.B);\n+        mapper.writeValue(sw, value);\n+        assertEquals(\"[\\\"B\\\"]\", sw.toString());\n+    }\n+\n+    /**\n+     * Whereas regular Enum serializer uses enum names, some users\n+     * prefer calling toString() instead. So let's verify that\n+     * this can be done using annotation for enum class.\n+     */\n+    public void testEnumUsingToString() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, AnnotatedTestEnum.C2);\n+        assertEquals(\"\\\"c2\\\"\", sw.toString());\n+    }\n+\n+    /**\n+     * Unit test that verifies that standard enum serialization\n+     * can be overridden by using custom serializer factory\n+     * to specify alternative global enum serializer.\n+     */\n+    public void testEnumUsingCSFEnumOverride() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        CustomSerializerFactory sf = new CustomSerializerFactory();\n+        sf.setEnumSerializer(ToStringSerializer.instance);\n+        mapper.setSerializerFactory(sf);\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, TestEnum.B);\n+        assertEquals(\"\\\"b\\\"\", sw.toString());\n+    }\n+\n+    /**\n+     * Unit test that verifies that standard enum serialization\n+     * can be overridden by using custom serializer factory\n+     * to specify generic serializer for enum base class\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testEnumUsingCSFGenericMapping() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        CustomSerializerFactory sf = new CustomSerializerFactory();\n+        Class<?> enumCls = Enum.class;\n+        sf.addGenericMapping((Class<Object>) enumCls, ToStringSerializer.instance);\n+        mapper.setSerializerFactory(sf);\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, TestEnum.A);\n+        assertEquals(\"\\\"a\\\"\", sw.toString());\n+    }\n+\n+    // Test [JACKSON-214]\n+    public void testSubclassedEnums() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"\\\"B\\\"\", mapper.writeValueAsString(EnumWithSubClass.B));\n+    }\n+\n+    // [JACKSON-193]\n+    public void testEnumsWithJsonValue() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"\\\"bar\\\"\", mapper.writeValueAsString(EnumWithJsonValue.B));\n+    }\n+\n+    // also, for [JACKSON-193], needs to work via mix-ins\n+    public void testEnumsWithJsonValueUsingMixin() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.getSerializationConfig().addMixInAnnotations(TestEnum.class, ToStringMixin.class);\n+        assertEquals(\"\\\"b\\\"\", mapper.writeValueAsString(TestEnum.B));\n+    }\n+\n+    /**\n+     * Test for ensuring that @JsonSerializable is used with Enum types as well\n+     * as with any other types.\n+     */\n+    public void testSerializableEnum() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"\\\"foo\\\"\", mapper.writeValueAsString(SerializableEnum.A));\n+    }\n+\n+    // [JACKSON-212]\n+    public void testToStringEnum() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(SerializationConfig.Feature.WRITE_ENUMS_USING_TO_STRING, true);\n+        assertEquals(\"\\\"b\\\"\", mapper.writeValueAsString(LowerCaseEnum.B));\n+    }\n+\n+    // [JACKSON-212]\n+    public void testToStringEnumWithEnumMap() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        EnumMap<LowerCaseEnum,String> m = new EnumMap<LowerCaseEnum,String>(LowerCaseEnum.class);\n+        m.put(LowerCaseEnum.C, \"value\");\n+        mapper.configure(SerializationConfig.Feature.WRITE_ENUMS_USING_TO_STRING, true);\n+        assertEquals(\"{\\\"c\\\":\\\"value\\\"}\", mapper.writeValueAsString(m));\n+    }\n+\n+    // [JACKSON-576]\n+    public void testMapWithEnumKeys() throws Exception\n+    {\n+        MapBean bean = new MapBean();\n+        bean.add(TestEnum.B, 3);\n+        String json = new ObjectMapper().writeValueAsString(bean);\n+        assertEquals(\"{\\\"map\\\":{\\\"b\\\":3}}\", json);\n+    }\n+    \n+    // [JACKSON-684]\n+    public void testAsIndex() throws Exception\n+    {\n+        // By default, serialize using name\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertFalse(mapper.isEnabled(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX));\n+        assertEquals(quote(\"B\"), mapper.writeValueAsString(TestEnum.B));\n+\n+        // but we can change (dynamically, too!) it to be number-based\n+        mapper.enable(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX);\n+        assertEquals(\"1\", mapper.writeValueAsString(TestEnum.B));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestExceptionHandling.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.CustomSerializerFactory;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * Unit test for verifying that exceptions are properly handled (caught,\n+ * re-thrown or wrapped, depending)\n+ * with Object serialization.\n+ */\n+public class TestExceptionHandling\n+    extends BaseTest\n+{\n+    /*\n+    //////////////////////////////////////////////\n+    // Helper classes\n+    //////////////////////////////////////////////\n+     */\n+\n+    static class Bean {\n+        // no methods, we'll use our custom serializer\n+    }\n+\n+    static class SerializerWithErrors\n+        extends JsonSerializer<Bean>\n+    {\n+        @Override\n+        public void serialize(Bean value, JsonGenerator jgen, SerializerProvider provider)\n+        {\n+            throw new IllegalArgumentException(\"test string\");\n+        }\n+    }\n+\n+    /*\n+    //////////////////////////////////////////////\n+    // Tests\n+    //////////////////////////////////////////////\n+     */\n+\n+    /**\n+     * Unit test that verifies that by default all exceptions except for\n+     * JsonMappingException are caught and wrapped.\n+     */\n+    public void testCatchAndRethrow()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        CustomSerializerFactory sf = new CustomSerializerFactory();\n+        sf.addSpecificMapping(Bean.class, new SerializerWithErrors());\n+        mapper.setSerializerFactory(sf);\n+        try {\n+            StringWriter sw = new StringWriter();\n+            /* And just to make things more interesting, let's create\n+             * a nested data struct...\n+             */\n+            Bean[] b = { new Bean() };\n+            List<Bean[]> l = new ArrayList<Bean[]>();\n+            l.add(b);\n+            mapper.writeValue(sw, l);\n+            fail(\"Should have gotten an exception\");\n+        } catch (IOException e) {\n+            // should contain original message somewhere\n+            verifyException(e, \"test string\");\n+            Throwable root = e.getCause();\n+            assertNotNull(root);\n+\n+            if (!(root instanceof IllegalArgumentException)) {\n+                fail(\"Wrapped exception not IAE, but \"+root.getClass());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Unit test for verifying that regular IOExceptions are not wrapped\n+     * but are passed through as is.\n+     */\n+    public void testExceptionWithSimpleMapper()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            BrokenStringWriter sw = new BrokenStringWriter(\"TEST\");\n+            mapper.writeValue(sw, createLongObject());\n+            fail(\"Should have gotten an exception\");\n+        } catch (IOException e) {\n+            verifyException(e, IOException.class, \"TEST\");\n+        }\n+    }\n+\n+    public void testExceptionWithMapperAndGenerator()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonFactory f = new MappingJsonFactory();\n+        BrokenStringWriter sw = new BrokenStringWriter(\"TEST\");\n+        JsonGenerator jg = f.createJsonGenerator(sw);\n+\n+        try {\n+            mapper.writeValue(jg, createLongObject());\n+            fail(\"Should have gotten an exception\");\n+        } catch (IOException e) {\n+            verifyException(e, IOException.class, \"TEST\");\n+        }\n+    }\n+\n+    public void testExceptionWithGeneratorMapping()\n+        throws Exception\n+    {\n+        JsonFactory f = new MappingJsonFactory();\n+        JsonGenerator jg = f.createJsonGenerator(new BrokenStringWriter(\"TEST\"));\n+        try {\n+            jg.writeObject(createLongObject());\n+            fail(\"Should have gotten an exception\");\n+        } catch (Exception e) {\n+            verifyException(e, IOException.class, \"TEST\");\n+        }\n+    }\n+\n+    /*\n+    ////////////////////////////////////////////////////\n+    // Helper methods\n+    ////////////////////////////////////////////////////\n+     */\n+\n+    void verifyException(Exception e, Class<?> expType, String expMsg)\n+        throws Exception\n+    {\n+        if (e.getClass() != expType) {\n+            fail(\"Expected exception of type \"+expType.getName()+\", got \"+e.getClass().getName());\n+        }\n+        if (expMsg != null) {\n+            verifyException(e, expMsg);\n+        }\n+    }\n+\n+    Object createLongObject()\n+    {\n+        List<Object> leaf = new ArrayList<Object>();\n+        for (int i = 0; i < 256; ++i) {\n+            leaf.add(Integer.valueOf(i));\n+        }\n+        List<Object> root = new ArrayList<Object>(256);\n+        for (int i = 0; i < 256; ++i) {\n+            root.add(leaf);\n+        }\n+        return root;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestExceptionSerialization.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for verifying that simple exceptions can be serialized.\n+ */\n+public class TestExceptionSerialization\n+    extends BaseMapTest\n+{\n+    /*\n+    ///////////////////////////////////////////////////\n+    // Tests\n+    ///////////////////////////////////////////////////\n+     */\n+\n+    public void testSimple() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String TEST = \"test exception\";\n+        Map<String,Object> result = writeAndMap(mapper, new Exception(TEST));\n+        assertEquals(4, result.size());\n+        assertEquals(TEST, result.get(\"message\"));\n+        assertNull(result.get(\"cause\"));\n+        assertEquals(TEST, result.get(\"localizedMessage\"));\n+\n+        // hmmh. what should we get for stack traces?\n+        Object traces = result.get(\"stackTrace\");\n+        if (!(traces instanceof List<?>)) {\n+            fail(\"Expected a List for exception member 'stackTrace', got: \"+traces);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for checking whether JsonSerializerFactory.Feature\n+ * configuration works\n+ */\n+public class TestFeatures\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Class with one explicitly defined getter, one name-based\n+     * auto-detectable getter.\n+     */\n+    static class GetterClass\n+    {\n+        @JsonProperty(\"x\") public int getX() { return -2; }\n+        public int getY() { return 1; }\n+    }\n+\n+    /**\n+     * Another test-class that explicitly disables auto-detection\n+     */\n+    @JsonAutoDetect(getterVisibility=Visibility.NONE)\n+    static class DisabledGetterClass\n+    {\n+        @JsonProperty(\"x\") public int getX() { return -2; }\n+        public int getY() { return 1; }\n+    }\n+\n+    /**\n+     * Another test-class that explicitly enables auto-detection\n+     */\n+    @JsonAutoDetect(isGetterVisibility=Visibility.NONE)\n+    static class EnabledGetterClass\n+    {\n+        @JsonProperty(\"x\") public int getX() { return -2; }\n+        public int getY() { return 1; }\n+\n+        // not auto-detected, since \"is getter\" auto-detect disabled\n+        public boolean isOk() { return true; }\n+    }\n+\n+    /**\n+     * One more: only detect \"isXxx\", not \"getXXX\"\n+     */\n+    @JsonAutoDetect(getterVisibility=Visibility.NONE)\n+    static class EnabledIsGetterClass\n+    {\n+        // Won't be auto-detected any more\n+        public int getY() { return 1; }\n+\n+        // but this will be\n+        public boolean isOk() { return true; }\n+    }\n+\n+    static class CloseableBean implements Closeable\n+    {\n+        public int a = 3;\n+\n+        protected boolean wasClosed = false;\n+        \n+        @Override\n+        public void close() throws IOException {\n+            wasClosed = true;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testGlobalAutoDetection() throws IOException\n+    {\n+        // First: auto-detection enabled (default):\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new GetterClass());\n+        assertEquals(2, result.size());\n+        assertEquals(Integer.valueOf(-2), result.get(\"x\"));\n+        assertEquals(Integer.valueOf(1), result.get(\"y\"));\n+\n+        // Then auto-detection disabled. But note: we MUST create a new\n+        // mapper, since old version of serializer may be cached by now\n+        m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        result = writeAndMap(m, new GetterClass());\n+        assertEquals(1, result.size());\n+        assertTrue(result.containsKey(\"x\"));\n+    }\n+\n+    public void testPerClassAutoDetection() throws IOException\n+    {\n+        // First: class-level auto-detection disabling\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new DisabledGetterClass());\n+        assertEquals(1, result.size());\n+        assertTrue(result.containsKey(\"x\"));\n+\n+        // And then class-level auto-detection enabling, should override defaults\n+        m.configure(SerializationConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        result = writeAndMap(m, new EnabledGetterClass());\n+        assertEquals(2, result.size());\n+        assertTrue(result.containsKey(\"x\"));\n+        assertTrue(result.containsKey(\"y\"));\n+    }\n+\n+    public void testPerClassAutoDetectionForIsGetter() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // class level should override\n+        m.configure(SerializationConfig.Feature.AUTO_DETECT_GETTERS, true);\n+        m.configure(SerializationConfig.Feature.AUTO_DETECT_IS_GETTERS, false);\n+         Map<String,Object> result = writeAndMap(m, new EnabledIsGetterClass());\n+        assertEquals(1, result.size());\n+        assertTrue(result.containsKey(\"ok\"));\n+        assertEquals(Boolean.TRUE, result.get(\"ok\"));\n+    }\n+\n+    // Simple test verifying that chainable methods work ok...\n+    public void testConfigChainability()\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertTrue(m.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.AUTO_DETECT_SETTERS));\n+        assertTrue(m.getSerializationConfig().isEnabled(SerializationConfig.Feature.AUTO_DETECT_GETTERS));\n+        m.configure(DeserializationConfig.Feature.AUTO_DETECT_SETTERS, false).configure(SerializationConfig.Feature.AUTO_DETECT_GETTERS, false);\n+        assertFalse(m.getDeserializationConfig().isEnabled(DeserializationConfig.Feature.AUTO_DETECT_SETTERS));\n+        assertFalse(m.getSerializationConfig().isEnabled(SerializationConfig.Feature.AUTO_DETECT_GETTERS));\n+    }\n+\n+    // Test for [JACKSON-282]\n+    public void testCloseCloseable() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        // default should be disabled:\n+        CloseableBean bean = new CloseableBean();\n+        m.writeValueAsString(bean);\n+        assertFalse(bean.wasClosed);\n+\n+        // but can enable it:\n+        m.configure(SerializationConfig.Feature.CLOSE_CLOSEABLE, true);\n+        bean = new CloseableBean();\n+        m.writeValueAsString(bean);\n+        assertTrue(bean.wasClosed);\n+\n+        // also: let's ensure that ObjectWriter won't interfere with it\n+        bean = new CloseableBean();\n+        m.writerWithType(CloseableBean.class).writeValueAsString(bean);\n+        assertTrue(bean.wasClosed);\n+    }\n+\n+    // Test for [JACKSON-289]\n+    public void testCharArrays() throws IOException\n+    {\n+        char[] chars = new char[] { 'a','b','c' };\n+        ObjectMapper m = new ObjectMapper();\n+        // default: serialize as Strings\n+        assertEquals(quote(\"abc\"), m.writeValueAsString(chars));\n+        \n+        // new feature: serialize as JSON array:\n+        m.configure(SerializationConfig.Feature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS, true);\n+        assertEquals(\"[\\\"a\\\",\\\"b\\\",\\\"c\\\"]\", m.writeValueAsString(chars));\n+    }\n+\n+    // Test for [JACKSON-401]\n+    public void testFlushingAutomatic() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE));\n+        // default is to flush after writeValue()\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jgen = mapper.getJsonFactory().createJsonGenerator(sw);\n+        mapper.writeValue(jgen, Integer.valueOf(13));\n+        assertEquals(\"13\", sw.toString());\n+        jgen.close();\n+\n+        // ditto with ObjectWriter\n+        sw = new StringWriter();\n+        jgen = mapper.getJsonFactory().createJsonGenerator(sw);\n+        ObjectWriter ow = mapper.writer();\n+        ow.writeValue(jgen, Integer.valueOf(99));\n+        assertEquals(\"99\", sw.toString());\n+        jgen.close();\n+    }\n+\n+    // Test for [JACKSON-401]\n+    public void testFlushingNotAutomatic() throws IOException\n+    {\n+        // but should not occur if configured otherwise\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE, false);\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jgen = mapper.getJsonFactory().createJsonGenerator(sw);\n+\n+        mapper.writeValue(jgen, Integer.valueOf(13));\n+        // no flushing now:\n+        assertEquals(\"\", sw.toString());\n+        // except when actually flushing\n+        jgen.flush();\n+        assertEquals(\"13\", sw.toString());\n+        jgen.close();\n+        // Also, same should happen with ObjectWriter\n+        sw = new StringWriter();\n+        jgen = mapper.getJsonFactory().createJsonGenerator(sw);\n+        ObjectWriter ow = mapper.writer();\n+        ow.writeValue(jgen, Integer.valueOf(99));\n+        assertEquals(\"\", sw.toString());\n+        // except when actually flushing\n+        jgen.flush();\n+        assertEquals(\"99\", sw.toString());\n+        jgen.close();\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestFieldSerialization.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+/**\n+ * Unit tests for verifying that field-backed properties can also be serialized\n+ * (since version 1.1) as well as getter-accessible properties.\n+ */\n+public class TestFieldSerialization\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes\n+    /**********************************************************\n+     */\n+\n+    static class SimpleFieldBean\n+    {\n+        public int x, y;\n+\n+        // not auto-detectable, not public\n+        int z;\n+\n+        // ignored, not detectable either\n+        @JsonIgnore public int a;\n+    }\n+    \n+    static class SimpleFieldBean2\n+    {\n+        @JsonSerialize String[] values;\n+\n+        // note: this annotation should not matter for serialization:\n+        @JsonDeserialize int dummy;\n+    }\n+\n+    static class TransientBean\n+    {\n+        public int a;\n+        // transients should not be included\n+        public transient int b;\n+        // or statics\n+        public static int c;\n+    }\n+\n+    @JsonAutoDetect(setterVisibility=Visibility.PUBLIC_ONLY, fieldVisibility=Visibility.NONE)\n+    public class NoAutoDetectBean\n+    {\n+        // not auto-detectable any more\n+        public int x;\n+\n+        @JsonProperty(\"z\")\n+        public int _z;\n+    }\n+\n+    /**\n+     * Let's test invalid bean too: can't have 2 logical properties\n+     * with same name.\n+     *<p>\n+     * 21-Feb-2010, tatus: That is, not within same class.\n+     *    As per [JACKSON-226] it is acceptable to \"override\"\n+     *    field definitions in sub-classes.\n+     */\n+    public static class DupFieldBean\n+    {\n+        @JsonProperty(\"foo\")\n+        public int _z;\n+\n+        @SuppressWarnings(\"unused\")\n+        @JsonSerialize\n+            private int foo;\n+    }\n+\n+    public static class DupFieldBean2\n+    {\n+        public int z;\n+\n+        @JsonProperty(\"z\")\n+        public int _z;\n+    }\n+\n+    public static class OkDupFieldBean\n+        extends SimpleFieldBean\n+    {\n+        @JsonProperty(\"x\")\n+        protected int myX;\n+\n+        public int y;\n+\n+        public OkDupFieldBean(int x, int y) {\n+            this.myX = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    /**\n+     * It is ok to have a method-based and field-based property\n+     * introspectable: only one should be serialized, and since\n+     * methods have precedence, it should be the method one.\n+     */\n+    public static class FieldAndMethodBean\n+    {\n+        @JsonProperty public int z;\n+\n+        @JsonProperty(\"z\") public int getZ() { return z+1; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Main tests, success\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleAutoDetect() throws Exception\n+    {\n+        SimpleFieldBean bean = new SimpleFieldBean();\n+        // let's set x, leave y as is\n+        bean.x = 13;\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, bean);\n+        assertEquals(2, result.size());\n+        assertEquals(Integer.valueOf(13), result.get(\"x\"));\n+        assertEquals(Integer.valueOf(0), result.get(\"y\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic void testSimpleAnnotation() throws Exception\n+    {\n+        SimpleFieldBean2 bean = new SimpleFieldBean2();\n+        bean.values = new String[] { \"a\", \"b\" };\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, bean);\n+        assertEquals(1, result.size());\n+        List<String> values = (List<String>) result.get(\"values\");\n+        assertEquals(2, values.size());\n+        assertEquals(\"a\", values.get(0));\n+        assertEquals(\"b\", values.get(1));\n+    }\n+\n+    public void testTransientAndStatic() throws Exception\n+    {\n+        TransientBean bean = new TransientBean();\n+        Map<String,Object> result = writeAndMap(bean);\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(0), result.get(\"a\"));\n+    }\n+\n+    public void testNoAutoDetect() throws Exception\n+    {\n+        NoAutoDetectBean bean = new NoAutoDetectBean();\n+        bean._z = -4;\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, bean);\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(-4), result.get(\"z\"));\n+    }\n+\n+    /**\n+     * Unit test that verifies that if both a field and a getter\n+     * method exist for a logical property (which is allowed),\n+     * getter has precendence over field.\n+     */\n+    public void testMethodPrecedence() throws Exception\n+    {\n+        FieldAndMethodBean bean = new FieldAndMethodBean();\n+        bean.z = 9;\n+        assertEquals(10, bean.getZ());\n+        assertEquals(\"{\\\"z\\\":10}\", serializeAsString(bean));\n+    }\n+\n+    /**\n+     * Testing [JACKSON-226]: it is ok to have \"field override\",\n+     * as long as there are no intra-class conflicts.\n+     */\n+    public void testOkDupFields() throws Exception\n+    {\n+        OkDupFieldBean bean = new OkDupFieldBean(1, 2);\n+        Map<String,Object> json = writeAndMap(new ObjectMapper(), bean);\n+        assertEquals(2, json.size());\n+        assertEquals(Integer.valueOf(1), json.get(\"x\"));\n+        assertEquals(Integer.valueOf(2), json.get(\"y\"));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Main tests, failure cases\n+    /**********************************************************\n+     */\n+\n+    public void testFailureDueToDups() throws Exception\n+    {\n+        try {\n+            writeAndMap(new ObjectMapper(), new DupFieldBean());\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Multiple fields representing\");\n+        }\n+    }\n+\n+    public void testFailureDueToDupField() throws Exception\n+    {\n+        try {\n+            writeAndMap(new ObjectMapper(), new DupFieldBean2());\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Multiple fields representing\");\n+        }\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestFiltering.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.ser.impl.*;\n+\n+/**\n+ * Tests for verifying that bean property filtering (new with 1.7)\n+ * works as expected.\n+ * \n+ * @since 1.7\n+ */\n+public class TestFiltering extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    @JsonFilter(\"RootFilter\")\n+    static class Bean {\n+        public String a = \"a\";\n+        public String b = \"b\";\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testSimpleInclusionFilter() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        FilterProvider prov = new SimpleFilterProvider().addFilter(\"RootFilter\",\n+                SimpleBeanPropertyFilter.filterOutAllExcept(\"a\"));\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\"}\", mapper.writer(prov).writeValueAsString(new Bean()));\n+\n+        // [JACKSON-504]: also verify it works via mapper\n+        mapper = new ObjectMapper();\n+        mapper.setFilters(prov);\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\"}\", mapper.writeValueAsString(new Bean()));\n+    }\n+\n+    public void testSimpleExclusionFilter() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        FilterProvider prov = new SimpleFilterProvider().addFilter(\"RootFilter\",\n+                SimpleBeanPropertyFilter.serializeAllExcept(\"a\"));\n+        assertEquals(\"{\\\"b\\\":\\\"b\\\"}\", mapper.writer(prov).writeValueAsString(new Bean()));\n+    }\n+\n+    // should handle missing case gracefully\n+    public void testMissingFilter() throws Exception\n+    {\n+        // First: default behavior should be to throw an exception\n+        ObjectMapper mapper = new ObjectMapper();\n+        try {\n+            mapper.writeValueAsString(new Bean());\n+            fail(\"Should have failed without configured filter\");\n+        } catch (JsonMappingException e) { // should be resolved to a MappingException (internally may be something else)\n+            verifyException(e, \"Can not resolve BeanPropertyFilter with id 'RootFilter'\");\n+        }\n+        \n+        // but when changing behavior, should work difference\n+        SimpleFilterProvider fp = new SimpleFilterProvider().setFailOnUnknownId(false);\n+        mapper.setFilters(fp);\n+        String json = mapper.writeValueAsString(new Bean());\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\",\\\"b\\\":\\\"b\\\"}\", json);\n+    }\n+    \n+    // defaulting, as per [JACKSON-449]\n+    public void testDefaultFilter() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        FilterProvider prov = new SimpleFilterProvider().setDefaultFilter(SimpleBeanPropertyFilter.filterOutAllExcept(\"b\"));\n+        assertEquals(\"{\\\"b\\\":\\\"b\\\"}\", mapper.writer(prov).writeValueAsString(new Bean()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestGenericTypes.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+\n+/**\n+ * @since 1.7\n+ */\n+public class TestGenericTypes extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+    \n+    static class Account {\n+        private Long id;        \n+        private String name;\n+        \n+        public Account(String name, Long id) {\n+            this.id = id;\n+            this.name = name;\n+        }\n+\n+        public String getName() { return name; }\n+        public Long getId() { return id; }\n+    }\n+\n+    static class Key<T> {\n+        private final T id;\n+        \n+        public Key(T id) { this.id = id; }\n+        \n+        public T getId() { return id; }\n+\n+        public <V> Key<V> getParent() { return null; }\n+    }\n+ \n+    static class Person1 {\n+        private Long id;\n+        private String name;\n+        private Key<Account> account;\n+        \n+        public Person1(String name) { this.name = name; }\n+\n+        public String getName() {\n+                return name;\n+        }\n+\n+        public Key<Account> getAccount() {\n+                return account;\n+        }\n+\n+        public Long getId() {\n+                return id;\n+        }\n+\n+        public void setAccount(Key<Account> account) {\n+            this.account = account;\n+        }    \n+    }\n+\n+    static class Person2 {\n+        private Long id;\n+        private String name;\n+        private List<Key<Account>> accounts;\n+        \n+        public Person2(String name) {\n+                this.name = name;\n+        }\n+\n+        public String getName() { return name; }\n+        public List<Key<Account>> getAccounts() { return accounts; }\n+        public Long getId() { return id; }\n+\n+        public void setAccounts(List<Key<Account>> accounts) {\n+            this.accounts = accounts;\n+        }\n+    }\n+\n+    static class GenericBogusWrapper<T> {\n+        public Element wrapped;\n+\n+        public GenericBogusWrapper(T v) { wrapped = new Element(v); }\n+\n+        class Element {\n+            public T value;\n+    \n+            public Element(T v) { value = v; }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIssue468a() throws Exception\n+    {\n+        Person1 p1 = new Person1(\"John\");\n+        p1.setAccount(new Key<Account>(new Account(\"something\", 42L)));\n+        \n+        // First: ensure we can serialize (pre 1.7 this failed)\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(p1);\n+\n+        // and then verify that results make sense\n+        Map<String,Object> map = mapper.readValue(json, Map.class);\n+        assertEquals(\"John\", map.get(\"name\"));\n+        Object ob = map.get(\"account\");\n+        assertNotNull(ob);\n+        Map<String,Object> acct = (Map<String,Object>) ob;\n+        Object idOb = acct.get(\"id\");\n+        assertNotNull(idOb);\n+        Map<String,Object> key = (Map<String,Object>) idOb;\n+        assertEquals(\"something\", key.get(\"name\"));\n+        assertEquals(Integer.valueOf(42), key.get(\"id\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testIssue468b() throws Exception\n+    {\n+        Person2 p2 = new Person2(\"John\");\n+        List<Key<Account>> accounts = new ArrayList<Key<Account>>();\n+        accounts.add(new Key<Account>(new Account(\"a\", 42L)));\n+        accounts.add(new Key<Account>(new Account(\"b\", 43L)));\n+        accounts.add(new Key<Account>(new Account(\"c\", 44L)));\n+        p2.setAccounts(accounts);\n+\n+        // serialize without error:\n+        ObjectMapper mapper = new ObjectMapper();               \n+        String json = mapper.writeValueAsString(p2);\n+\n+        // then verify output\n+        Map<String,Object> map = mapper.readValue(json, Map.class);\n+        assertEquals(\"John\", map.get(\"name\"));\n+        Object ob = map.get(\"accounts\");\n+        assertNotNull(ob);\n+        List<?> acctList = (List<?>) ob;\n+        assertEquals(3, acctList.size());\n+        // ... might want to verify more, but for now that should suffice\n+    }\n+\n+    /**\n+     * Issue [JACKSON-572] is about unbound type variables, usually resulting\n+     * from inner classes of generic classes (like Sets).\n+     */\n+    public void testUnboundIssue572() throws Exception\n+    {\n+        GenericBogusWrapper<Integer> list = new GenericBogusWrapper<Integer>(Integer.valueOf(7));\n+        String json = new ObjectMapper().writeValueAsString(list);\n+        assertEquals(\"{\\\"wrapped\\\":{\\\"value\\\":7}}\", json);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestIgnoreProperties.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestIgnoreProperties\n+    extends BaseMapTest\n+{\n+    /*\n+     ****************************************************************\n+     * Helper classes\n+     ****************************************************************\n+     */\n+\n+    @JsonIgnoreProperties({\"b\", \"c\"})\n+    static class IgnoreSome\n+    {\n+        public int a = 3;\n+        public String b = \"x\";\n+\n+        public int getC() { return -6; }\n+        public String getD() { return \"abc\"; }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    @JsonIgnoreProperties({\"@class\"})\n+    static class MyMap extends HashMap<String,String> { }\n+    \n+    /*\n+     ****************************************************************\n+     * Unit tests\n+     ****************************************************************\n+     */\n+\n+    public void testExplicitIgnoralWithBean() throws Exception\n+    {\n+        IgnoreSome value = new IgnoreSome();\n+        Map<String,Object> result = writeAndMap(value);\n+        assertEquals(2, result.size());\n+        // verify that specified fields are ignored\n+        assertFalse(result.containsKey(\"b\"));\n+        assertFalse(result.containsKey(\"c\"));\n+        // and that others are not\n+        assertEquals(Integer.valueOf(value.a), result.get(\"a\"));\n+        assertEquals(value.getD(), result.get(\"d\"));\n+    }\n+\n+    public void testExplicitIgnoralWithMap() throws Exception\n+    {\n+        // test simulating need to filter out metadata like class name\n+        MyMap value = new MyMap();\n+        value.put(\"a\", \"b\");\n+        value.put(\"@class\", MyMap.class.getName());\n+        Map<String,Object> result = writeAndMap(value);\n+        assertEquals(1, result.size());\n+        // verify that specified field is ignored\n+        assertFalse(result.containsKey(\"@class\"));\n+        // and that others are not\n+        assertEquals(value.get(\"a\"), result.get(\"a\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJSONP.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.JSONPObject;\n+\n+public class TestJSONP\n+    extends BaseMapTest\n+{\n+    static class Base {\n+        public String a;\n+    }\n+    static class Impl extends Base {\n+        public String b;\n+\n+        public Impl(String a, String b) {\n+            this.a = a;\n+            this.b = b;\n+        }\n+    }\n+    \n+    public void testSimpleScalars() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertEquals(\"callback(\\\"abc\\\")\",\n+                serializeAsString(m, new JSONPObject(\"callback\", \"abc\")));\n+        assertEquals(\"calc(123)\",\n+                serializeAsString(m, new JSONPObject(\"calc\", Integer.valueOf(123))));\n+        assertEquals(\"dummy(null)\",\n+                serializeAsString(m, new JSONPObject(\"dummy\", null)));\n+    }\n+\n+    public void testSimpleBean() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertEquals(\"xxx({\\\"a\\\":\\\"123\\\",\\\"b\\\":\\\"456\\\"})\",\n+                serializeAsString(m, new JSONPObject(\"xxx\",\n+                        new Impl(\"123\", \"456\"))));\n+    }\n+    \n+    /**\n+     * Test to ensure that it is possible to force a static type for wrapped\n+     * value.\n+     */\n+    public void testWithType() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Object ob = new Impl(\"abc\", \"def\");\n+        JavaType type = TypeFactory.defaultInstance().uncheckedSimpleType(Base.class);\n+        assertEquals(\"do({\\\"a\\\":\\\"abc\\\"})\",\n+                serializeAsString(m, new JSONPObject(\"do\", ob, type)));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJacksonTypes.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n+\n+/**\n+ * Unit tests for those Jackson types we want to ensure can be serialized.\n+ */\n+public class TestJacksonTypes\n+    extends BaseMapTest\n+{\n+    public void testLocation() throws IOException\n+    {\n+        JsonLocation loc = new JsonLocation(new File(\"/tmp/test.json\"),\n+                                            -1, 100, 13);\n+        ObjectMapper mapper = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(mapper, loc);\n+        assertEquals(5, result.size());\n+        assertEquals(\"/tmp/test.json\", result.get(\"sourceRef\"));\n+        assertEquals(Integer.valueOf(-1), result.get(\"charOffset\"));\n+        assertEquals(Integer.valueOf(-1), result.get(\"byteOffset\"));\n+        assertEquals(Integer.valueOf(100), result.get(\"lineNr\"));\n+        assertEquals(Integer.valueOf(13), result.get(\"columnNr\"));\n+\n+    }\n+\n+    /**\n+     * Verify that {@link TokenBuffer} can be properly serialized\n+     * automatically, using the \"standard\" JSON sample document\n+     *\n+     * @since 1.5\n+     */\n+    public void testTokenBuffer() throws Exception\n+    {\n+        // First, copy events from known good source (StringReader)\n+        JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC);\n+        TokenBuffer tb = new TokenBuffer(null);\n+        while (jp.nextToken() != null) {\n+            tb.copyCurrentEvent(jp);\n+        }\n+        // Then serialize as String\n+        String str = serializeAsString(tb);\n+        // and verify it looks ok\n+        verifyJsonSpecSampleDoc(createParserUsingReader(str), true);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.*;\n+import java.net.InetAddress;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for JDK types not covered by other tests (i.e. things\n+ * that are not Enums, Collections, Maps, or standard Date/Time types)\n+ */\n+public class TestJdkTypes\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    /**\n+     * Unit test related to [JACKSON-155]\n+     */\n+    public void testFile() throws IOException\n+    {\n+        /* Not sure if this gets translated differently on Windows, Mac?\n+         * It'd be hard to make truly portable test tho...\n+         */\n+        File f = new File(\"/tmp/foo.txt\");\n+        String str = serializeAsString(new ObjectMapper(), f);\n+        assertEquals(\"\\\"\"+f.getAbsolutePath()+\"\\\"\", str);\n+    }\n+\n+    public void testRegexps() throws IOException\n+    {\n+        final String PATTERN_STR = \"\\\\s+([a-b]+)\\\\w?\";\n+        Pattern p = Pattern.compile(PATTERN_STR);\n+        Map<String,Object> input = new HashMap<String,Object>();\n+        input.put(\"p\", p);\n+        Map<String,Object> result = writeAndMap(input);\n+        assertEquals(p.pattern(), result.get(\"p\"));\n+    }\n+\n+    public void testCurrency() throws IOException\n+    {\n+        Currency usd = Currency.getInstance(\"USD\");\n+        assertEquals(quote(\"USD\"), new ObjectMapper().writeValueAsString(usd));\n+    }\n+\n+    // @since 1.7\n+    public void testLocale() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(quote(\"en\"), mapper.writeValueAsString(new Locale(\"en\")));\n+        assertEquals(quote(\"es_ES\"), mapper.writeValueAsString(new Locale(\"es\", \"ES\")));\n+        assertEquals(quote(\"fi_FI_savo\"), mapper.writeValueAsString(new Locale(\"FI\", \"fi\", \"savo\")));\n+    }\n+\n+    // [JACKSON-484]\n+    public void testInetAddress() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(quote(\"127.0.0.1\"), mapper.writeValueAsString(InetAddress.getByName(\"127.0.0.1\")));\n+        assertEquals(quote(\"ning.com\"), mapper.writeValueAsString(InetAddress.getByName(\"ning.com\")));\n+    }\n+\n+    // [JACKSON-597]\n+    public void testClass() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(quote(\"java.lang.String\"), mapper.writeValueAsString(String.class));\n+        assertEquals(quote(\"int\"), mapper.writeValueAsString(Integer.TYPE));\n+        assertEquals(quote(\"boolean\"), mapper.writeValueAsString(Boolean.TYPE));\n+        assertEquals(quote(\"void\"), mapper.writeValueAsString(Void.TYPE));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestMapSerialization.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.*;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+@SuppressWarnings(\"serial\")\n+public class TestMapSerialization\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Class needed for testing [JACKSON-220]\n+     */\n+    @JsonSerialize(using=MapSerializer.class)    \n+    static class PseudoMap extends LinkedHashMap<String,String>\n+    {\n+        public PseudoMap(String... values) {\n+            for (int i = 0, len = values.length; i < len; i += 2) {\n+                put(values[i], values[i+1]);\n+            }\n+        }\n+    }\n+\n+    static class MapSerializer extends JsonSerializer<Map<String,String>>\n+    {\n+        @Override\n+        public void serialize(Map<String,String> value,\n+                              JsonGenerator jgen,\n+                              SerializerProvider provider)\n+            throws IOException\n+        {\n+            // just use standard Map.toString(), output as JSON String\n+            jgen.writeString(value.toString());\n+        }\n+    }\n+\n+    // For [JACKSON-574]\n+    static class DefaultKeySerializer extends JsonSerializer<Object>\n+    {\n+        @Override\n+        public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException\n+        {\n+            jgen.writeFieldName(\"DEFAULT:\"+value);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    // Test [JACKSON-220]\n+    public void testMapSerializer() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertEquals(\"\\\"{a=b, c=d}\\\"\", m.writeValueAsString(new PseudoMap(\"a\", \"b\", \"c\", \"d\")));\n+    }\n+\n+    // Test [JACKSON-314]\n+    public void testMapNullSerialization() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,String> map = new HashMap<String,String>();\n+        map.put(\"a\", null);\n+        // by default, should output null-valued entries:\n+        assertEquals(\"{\\\"a\\\":null}\", m.writeValueAsString(map));\n+        // but not if explicitly asked not to (note: config value is dynamic here)\n+        m.configure(SerializationConfig.Feature.WRITE_NULL_MAP_VALUES, false);\n+        assertEquals(\"{}\", m.writeValueAsString(map));\n+    }\n+\n+    // [JACKSON-499], problems with map entries, values\n+    public void testMapKeyValueSerialization() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,String> map = new HashMap<String,String>();\n+        map.put(\"a\", \"b\");\n+        assertEquals(\"[\\\"a\\\"]\", m.writeValueAsString(map.keySet()));\n+        assertEquals(\"[\\\"b\\\"]\", m.writeValueAsString(map.values()));\n+\n+        // TreeMap has similar inner class(es):\n+        map = new TreeMap<String,String>();\n+        map.put(\"c\", \"d\");\n+        assertEquals(\"[\\\"c\\\"]\", m.writeValueAsString(map.keySet()));\n+        assertEquals(\"[\\\"d\\\"]\", m.writeValueAsString(map.values()));\n+\n+        // and for [JACKSON-533], same for concurrent maps\n+        map = new ConcurrentHashMap<String,String>();\n+        map.put(\"e\", \"f\");\n+        assertEquals(\"[\\\"e\\\"]\", m.writeValueAsString(map.keySet()));\n+        assertEquals(\"[\\\"f\\\"]\", m.writeValueAsString(map.values()));\n+    }\n+\n+    // For [JACKSON-574]\n+    public void testDefaultKeySerializer() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getSerializerProvider().setDefaultKeySerializer(new DefaultKeySerializer());\n+        Map<String,String> map = new HashMap<String,String>();\n+        map.put(\"a\", \"b\");\n+        assertEquals(\"{\\\"DEFAULT:a\\\":\\\"b\\\"}\", m.writeValueAsString(map));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNullProperties.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+/**\n+ * Unit tests for checking that alternative settings for\n+ * {@link JsonSerialize#include} annotation property work\n+ * as expected.\n+ */\n+public class TestNullProperties\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper beans\n+    /**********************************************************\n+     */\n+\n+    static class SimpleBean\n+    {\n+        public String getA() { return \"a\"; }\n+        public String getB() { return null; }\n+    }\n+    \n+    @JsonSerialize(include=JsonSerialize.Inclusion.ALWAYS) // just to ensure default\n+    static class NoNullsBean\n+    {\n+        @JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)\n+        public String getA() { return null; }\n+\n+        public String getB() { return null; }\n+    }\n+\n+    @JsonSerialize(include=JsonSerialize.Inclusion.NON_DEFAULT)\n+    static class NonDefaultBean\n+    {\n+        String _a = \"a\", _b = \"b\";\n+\n+        NonDefaultBean() { }\n+\n+        public String getA() { return _a; }\n+        public String getB() { return _b; }\n+    }\n+\n+    static class MixedBean\n+    {\n+        String _a = \"a\", _b = \"b\";\n+\n+        MixedBean() { }\n+\n+        @JsonSerialize(include=JsonSerialize.Inclusion.NON_DEFAULT)\n+        public String getA() { return _a; }\n+\n+        @JsonSerialize(include=JsonSerialize.Inclusion.NON_NULL)\n+        public String getB() { return _b; }\n+    }\n+\n+    // to ensure that default values work for collections as well\n+    static class ListBean {\n+        @JsonSerialize(include=JsonSerialize.Inclusion.NON_DEFAULT)\n+        public List<String> strings = new ArrayList<String>();\n+    }\n+    \n+    @JsonSerialize(include=JsonSerialize.Inclusion.NON_DEFAULT)\n+    static class ArrayBean {\n+        public int[] ints = new int[] { 1, 2 };\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testGlobal() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new SimpleBean());\n+        assertEquals(2, result.size());\n+        assertEquals(\"a\", result.get(\"a\"));\n+        assertNull(result.get(\"b\"));\n+        assertTrue(result.containsKey(\"b\"));\n+    }\n+\n+    public void testNonNullByClass() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new NoNullsBean());\n+        assertEquals(1, result.size());\n+        assertFalse(result.containsKey(\"a\"));\n+        assertNull(result.get(\"a\"));\n+        assertTrue(result.containsKey(\"b\"));\n+        assertNull(result.get(\"b\"));\n+    }\n+\n+    public void testNonDefaultByClass() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        NonDefaultBean bean = new NonDefaultBean();\n+        // need to change one of defaults\n+        bean._a = \"notA\";\n+        Map<String,Object> result = writeAndMap(m, bean);\n+        assertEquals(1, result.size());\n+        assertTrue(result.containsKey(\"a\"));\n+        assertEquals(\"notA\", result.get(\"a\"));\n+        assertFalse(result.containsKey(\"b\"));\n+        assertNull(result.get(\"b\"));\n+    }\n+\n+    public void testMixedMethod() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+\n+        MixedBean bean = new MixedBean();\n+        bean._a = \"xyz\";\n+        bean._b = null;\n+        Map<String,Object> result = writeAndMap(m, bean);\n+        assertEquals(1, result.size());\n+        assertEquals(\"xyz\", result.get(\"a\"));\n+        assertFalse(result.containsKey(\"b\"));\n+\n+        bean._a = \"a\";\n+        bean._b = \"b\";\n+        result = writeAndMap(m, bean);\n+        assertEquals(1, result.size());\n+        assertEquals(\"b\", result.get(\"b\"));\n+        assertFalse(result.containsKey(\"a\"));\n+    }\n+\n+    public void testDefaultForEmptyList() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertEquals(\"{}\", m.writeValueAsString(new ListBean()));\n+    }\n+\n+    // [JACKSON-531]: make NON_DEFAULT work for arrays too\n+    public void testNonEmptyDefaultArray() throws IOException\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertEquals(\"{}\", m.writeValueAsString(new ArrayBean()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.StdSerializerProvider;\n+\n+public class TestNullSerialization\n+    extends BaseMapTest\n+{\n+    static class NullSerializer extends JsonSerializer<Object>\n+    {\n+        @Override\n+        public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonProcessingException\n+        {\n+            jgen.writeString(\"foobar\");\n+        }\n+    }\n+\n+    public void testSimple() throws Exception\n+    {\n+        assertEquals(\"null\", new ObjectMapper().writeValueAsString(null));\n+    }\n+\n+    public void testCustom() throws Exception\n+    {\n+        StdSerializerProvider sp = new StdSerializerProvider();\n+        sp.setNullValueSerializer(new NullSerializer());\n+        ObjectMapper m = new ObjectMapper();\n+        m.setSerializerProvider(sp);\n+        assertEquals(\"\\\"foobar\\\"\", m.writeValueAsString(null));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestObjectWriter.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for checking features added to {@link ObjectWriter}, such\n+ * as adding of explicit pretty printer.\n+ * \n+ * @since 1.6\n+ */\n+public class TestObjectWriter\n+    extends BaseMapTest\n+{\n+    public void testPrettyPrinter() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ObjectWriter writer = mapper.writer();\n+        HashMap<String, Integer> data = new HashMap<String,Integer>();\n+        data.put(\"a\", 1);\n+        \n+        // default: no indentation\n+        assertEquals(\"{\\\"a\\\":1}\", writer.writeValueAsString(data));\n+\n+        // and then with standard\n+        writer = writer.withDefaultPrettyPrinter();\n+        assertEquals(\"{\\n  \\\"a\\\" : 1\\n}\", writer.writeValueAsString(data));\n+\n+        // and finally, again without indentation\n+        writer = writer.withPrettyPrinter(null);\n+        assertEquals(\"{\\\"a\\\":1}\", writer.writeValueAsString(data));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.StringWriter;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Unit tests for verifying functioning of [JACKSON-195], ability to\n+ * force specific root type for serialization (super type of value)\n+ * \n+ * @author tatu\n+ */\n+public class TestRootType\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes\n+    /**********************************************************\n+     */\n+\n+    interface BaseInterface {\n+        int getB();\n+    }\n+    \n+    static class BaseType\n+        implements BaseInterface\n+    {\n+        public String a = \"a\";\n+\n+        @Override\n+        public int getB() { return 3; }\n+    }\n+\n+    static class SubType extends BaseType {\n+        public String a2 = \"x\";\n+        \n+        public boolean getB2() { return true; }\n+    }\n+\n+    @JsonTypeInfo(use=Id.NAME, include=As.PROPERTY, property=\"beanClass\")\n+    public abstract static class BaseClass398 { }\n+\n+    public static class TestClass398 extends BaseClass398 {\n+       public String property = \"aa\";\n+    }\n+    \n+    @JsonRootName(\"root\")\n+    static class WithRootName {\n+        public int a = 3;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Main tests\n+    /**********************************************************\n+     */\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testSuperClass() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SubType bean = new SubType();\n+\n+        // first, test with dynamically detected type\n+        Map<String,Object> result = writeAndMap(mapper, bean);\n+        assertEquals(4, result.size());\n+        assertEquals(\"a\", result.get(\"a\"));\n+        assertEquals(Integer.valueOf(3), result.get(\"b\"));\n+        assertEquals(\"x\", result.get(\"a2\"));\n+        assertEquals(Boolean.TRUE, result.get(\"b2\"));\n+\n+        // and then using specified typed writer\n+        ObjectWriter w = mapper.writerWithType(BaseType.class);\n+        String json = w.writeValueAsString(bean);\n+        result = (Map<String,Object>)mapper.readValue(json, Map.class);\n+        assertEquals(2, result.size());\n+        assertEquals(\"a\", result.get(\"a\"));\n+        assertEquals(Integer.valueOf(3), result.get(\"b\"));\n+    }\n+\n+    public void testSuperInterface() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SubType bean = new SubType();\n+\n+        // let's constrain by interface:\n+        ObjectWriter w = mapper.writerWithType(BaseInterface.class);\n+        String json = w.writeValueAsString(bean);\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String,Object> result = mapper.readValue(json, Map.class);\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(3), result.get(\"b\"));\n+    }\n+\n+    public void testInArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // must force static typing, otherwise won't matter a lot\n+        mapper.configure(SerializationConfig.Feature.USE_STATIC_TYPING, true);\n+        SubType[] ob = new SubType[] { new SubType() };\n+        String json = mapper.writerWithType(BaseInterface[].class).writeValueAsString(ob);\n+        // should propagate interface type through due to root declaration; static typing\n+        assertEquals(\"[{\\\"b\\\":3}]\", json);\n+    }\n+    \n+    /**\n+     * Unit test to ensure that proper exception is thrown if declared\n+     * root type is not compatible with given value instance.\n+     */\n+    public void testIncompatibleRootType() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SubType bean = new SubType();\n+\n+        // and then let's try using incompatible type\n+        ObjectWriter w = mapper.writerWithType(HashMap.class);\n+        try {\n+            w.writeValueAsString(bean);\n+            fail(\"Should have failed due to incompatible type\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"Incompatible types\");\n+        }\n+    }\n+    \n+    /**\n+     * Unit test to verify [JACKSON-398]\n+     */\n+    public void testJackson398() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        JavaType collectionType = TypeFactory.defaultInstance().constructCollectionType(ArrayList.class, BaseClass398.class);\n+        List<TestClass398> typedList = new ArrayList<TestClass398>();\n+        typedList.add(new TestClass398());\n+\n+        final String EXP = \"[{\\\"beanClass\\\":\\\"TestRootType$TestClass398\\\",\\\"property\\\":\\\"aa\\\"}]\";\n+        \n+        // First simplest way:\n+        String json = mapper.writerWithType(collectionType).writeValueAsString(typedList);\n+        assertEquals(EXP, json);\n+\n+        StringWriter out = new StringWriter();\n+        JsonFactory f = new JsonFactory();\n+        mapper.writerWithType(collectionType).writeValue(f.createJsonGenerator(out), typedList);\n+\n+        assertEquals(EXP, out.toString());\n+    }\n+\n+    // Test to verify [JACKSON-163]\n+    public void testRootWrapping() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(SerializationConfig.Feature.WRAP_ROOT_VALUE, true);\n+        String json = mapper.writeValueAsString(new StringWrapper(\"abc\"));\n+        assertEquals(\"{\\\"StringWrapper\\\":{\\\"str\\\":\\\"abc\\\"}}\", json);\n+    }\n+\n+    /**\n+     * Test to verify that there is support for specifying root type as primitive,\n+     * even if wrapper value is passed (there is no way to pass primitive values as\n+     * Objects); this to support frameworks that may pass unprocessed\n+     * {@link java.lang.reflect.Type} from field or method.\n+     */\n+    public void testIssue456WrapperPart() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"123\", mapper.writerWithType(Integer.TYPE).writeValueAsString(Integer.valueOf(123)));\n+        assertEquals(\"456\", mapper.writerWithType(Long.TYPE).writeValueAsString(Long.valueOf(456L)));\n+    }\n+\n+    // [JACKSON-630] also, allow annotation to define root name\n+    public void testRootNameAnnotation() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.configure(SerializationConfig.Feature.WRAP_ROOT_VALUE, true);\n+        String json = mapper.writeValueAsString(new WithRootName());\n+        assertEquals(\"{\\\"root\\\":{\\\"a\\\":3}}\", json);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializationOrder.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for verifying that constraints on ordering of serialized\n+ * properties are held.\n+ */\n+public class TestSerializationOrder\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes\n+    /**********************************************************\n+     */\n+\n+    static class BeanWithCreator\n+    {\n+        public int a;\n+        public int b;\n+        public int c;\n+\n+        @JsonCreator public BeanWithCreator(@JsonProperty(\"c\") int c, @JsonProperty(\"a\") int a) {\n+            this.a = a;\n+            this.c = c;\n+        }\n+    }\n+\n+    @JsonPropertyOrder({\"c\", \"a\", \"b\"})\n+    static class BeanWithOrder\n+    {\n+        public int d, b, a, c;\n+        \n+        public BeanWithOrder(int a, int b, int c, int d) {\n+            this.a = a;\n+            this.b = b;\n+            this.c = c;\n+            this.d = d;\n+        }\n+    }\n+\n+    @JsonPropertyOrder(value={\"d\"}, alphabetic=true)\n+    static class SubBeanWithOrder extends BeanWithOrder\n+    {\n+        public SubBeanWithOrder(int a, int b, int c, int d) {\n+            super(a, b, c, d);\n+        }\n+    }\n+\n+    @JsonPropertyOrder({\"b\", \"a\",\n+        // note: including non-existant properties is fine (has no effect, but not an error)\n+        \"foobar\",\n+        \"c\"\n+    })\n+    static class OrderMixIn { }\n+\n+    @JsonPropertyOrder(value={\"a\",\"b\",\"x\",\"z\"})\n+    static class BeanFor268 { // testing [JACKSON-268]\n+    \t@JsonProperty(\"a\") public String xA = \"a\";\n+    \t@JsonProperty(\"z\") public String aZ = \"z\";\n+    \t@JsonProperty(\"b\") public String xB() { return \"b\"; }\n+    \t@JsonProperty(\"x\") public String aX() { return \"x\"; }\n+    }\n+\n+    static class BeanFor459 {\n+        public int d = 4;\n+        public int c = 3;\n+        public int b = 2;\n+        public int a = 1;\n+    }\n+    \n+    /*\n+    /*********************************************\n+    /* Unit tests\n+    /*********************************************\n+     */\n+\n+    // Test for [JACKSON-170]\n+    public void testImplicitOrderByCreator() throws Exception\n+    {\n+        assertEquals(\"{\\\"c\\\":1,\\\"a\\\":2,\\\"b\\\":0}\", serializeAsString(new BeanWithCreator(1, 2)));\n+    }\n+\n+    public void testExplicitOrder() throws Exception\n+    {\n+        assertEquals(\"{\\\"c\\\":3,\\\"a\\\":1,\\\"b\\\":2,\\\"d\\\":4}\", serializeAsString(new BeanWithOrder(1, 2, 3, 4)));\n+    }\n+\n+    public void testAlphabeticOrder() throws Exception\n+    {\n+        assertEquals(\"{\\\"d\\\":4,\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":3}\", serializeAsString(new SubBeanWithOrder(1, 2, 3, 4)));\n+    }\n+\n+\n+    public void testOrderWithMixins() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.getSerializationConfig().addMixInAnnotations(BeanWithOrder.class, OrderMixIn.class);\n+        assertEquals(\"{\\\"b\\\":2,\\\"a\\\":1,\\\"c\\\":3,\\\"d\\\":4}\", serializeAsString(m, new BeanWithOrder(1, 2, 3, 4)));\n+    }\n+\n+    // Test for [JACKSON-268]\n+    public void testOrderWrt268() throws Exception\n+    {\n+        assertEquals(\"{\\\"a\\\":\\\"a\\\",\\\"b\\\":\\\"b\\\",\\\"x\\\":\\\"x\\\",\\\"z\\\":\\\"z\\\"}\",\n+        \t\tserializeAsString(new BeanFor268()));\n+    }\n+\n+    // Test for [JACKSON-459]\n+    public void testOrderWithFeature() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        m.configure(SerializationConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY, true);\n+        assertEquals(\"{\\\"a\\\":1,\\\"b\\\":2,\\\"c\\\":3,\\\"d\\\":4}\", serializeAsString(m, new BeanFor459()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializerProvider.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.BeanSerializerFactory;\n+import com.fasterxml.jackson.databind.ser.StdSerializerProvider;\n+\n+public class TestSerializerProvider\n+    extends com.fasterxml.jackson.databind.BaseMapTest\n+{\n+    static class MyBean {\n+        public int getX() { return 3; }\n+    }\n+\n+    public void testFindExplicit() throws JsonMappingException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SerializationConfig config = mapper.getSerializationConfig();\n+        SerializerFactory f = new BeanSerializerFactory(null);\n+        StdSerializerProvider prov = new StdSerializerProvider().createInstance(config, f);\n+\n+        // Should have working default key and null key serializers\n+        assertNotNull(prov.findKeySerializer(null, null));\n+        assertNotNull(prov.getNullKeySerializer());\n+        // as well as 'unknown type' one (throws exception)\n+        assertNotNull(prov.getUnknownTypeSerializer(getClass()));\n+        \n+        assertTrue(prov.hasSerializerFor(config, String.class, f));\n+        // call twice to verify it'll be cached (second code path)\n+        assertTrue(prov.hasSerializerFor(config, String.class, f));\n+\n+        assertTrue(prov.hasSerializerFor(config, MyBean.class, f));\n+        assertTrue(prov.hasSerializerFor(config, MyBean.class, f));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleAtomicTypes.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.concurrent.atomic.*;\n+\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Unit tests for verifying serialization of simple basic non-structured\n+ * types; primitives (and/or their wrappers), Strings.\n+ */\n+public class TestSimpleAtomicTypes\n+    extends BaseMapTest\n+{\n+    public void testAtomicBoolean() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"true\", serializeAsString(mapper, new AtomicBoolean(true)));\n+        assertEquals(\"false\", serializeAsString(mapper, new AtomicBoolean(false)));\n+    }\n+\n+    public void testAtomicInteger() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"1\", serializeAsString(mapper, new AtomicInteger(1)));\n+        assertEquals(\"-9\", serializeAsString(mapper, new AtomicInteger(-9)));\n+    }\n+\n+    public void testAtomicLong() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"0\", serializeAsString(mapper, new AtomicLong(0)));\n+    }\n+\n+    public void testAtomicReference() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String[] strs = new String[] { \"abc\" };\n+        assertEquals(\"[\\\"abc\\\"]\", serializeAsString(mapper, new AtomicReference<String[]>(strs)));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSimpleTypes.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.math.BigInteger;\n+\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Unit tests for verifying serialization of simple basic non-structured\n+ * types; primitives (and/or their wrappers), Strings.\n+ */\n+public class TestSimpleTypes\n+    extends BaseMapTest\n+{\n+    public void testBoolean() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"true\", serializeAsString(mapper, Boolean.TRUE));\n+        assertEquals(\"false\", serializeAsString(mapper, Boolean.FALSE));\n+    }\n+\n+    public void testBooleanArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"[true,false]\", serializeAsString(mapper, new boolean[] { true, false} ));\n+        assertEquals(\"[true,false]\", serializeAsString(mapper, new Boolean[] { Boolean.TRUE, Boolean.FALSE} ));\n+    }\n+\n+    public void testByteArray() throws Exception\n+    {\n+        byte[] data = { 1, 17, -3, 127, -128 };\n+        Byte[] data2 = new Byte[data.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data2[i] = data[i]; // auto-boxing\n+        }\n+        ObjectMapper mapper = new ObjectMapper();\n+        // For this we need to deserialize, to get base64 codec\n+        String str1 = serializeAsString(mapper, data);\n+        String str2 = serializeAsString(mapper, data2);\n+        assertArrayEquals(data, mapper.readValue(str1, byte[].class));\n+        assertArrayEquals(data2, mapper.readValue(str2, Byte[].class));\n+    }\n+\n+    public void testShortArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"[0,1]\", serializeAsString(mapper, new short[] { 0, 1 }));\n+        assertEquals(\"[2,3]\", serializeAsString(mapper, new Short[] { 2, 3 }));\n+    }\n+\n+    public void testIntArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"[0,-3]\", serializeAsString(mapper, new int[] { 0, -3 }));\n+        assertEquals(\"[13,9]\", serializeAsString(mapper, new Integer[] { 13, 9 }));\n+    }\n+\n+    /* Note: dealing with floating-point values is tricky; not sure if\n+     * we can really use equality tests here... JDK does have decent\n+     * conversions though, to retain accuracy and round-trippability.\n+     * But still...\n+     */\n+    public void testFloat() throws Exception\n+    {\n+        double[] values = new double[] {\n+            0.0, 1.0, 0.1, -37.01, 999.99, 0.3, 33.3, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY\n+        };\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        for (double d : values) {\n+           float f = (float) d;\n+    \t   String expected = String.valueOf(f);\n+           if (Float.isNaN(f) || Float.isInfinite(f)) {\n+               expected = \"\\\"\"+expected+\"\\\"\";\n+       \t   }\n+           assertEquals(expected,serializeAsString(mapper, Float.valueOf(f)));\n+        }\n+    }\n+\n+    public void testDouble() throws Exception\n+    {\n+        double[] values = new double[] {\n+            0.0, 1.0, 0.1, -37.01, 999.99, 0.3, 33.3, Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY\n+        };\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        for (double d : values) {\n+            String expected = String.valueOf(d);\n+            if (Double.isNaN(d) || Double.isInfinite(d)) {\n+                expected = \"\\\"\"+d+\"\\\"\";\n+            }\n+            assertEquals(expected,serializeAsString(mapper, Double.valueOf(d)));\n+        }\n+    }\n+\n+    public void testBigInteger() throws Exception\n+    {\n+        BigInteger[] values = new BigInteger[] {\n+                BigInteger.ONE, BigInteger.TEN, BigInteger.ZERO,\n+                BigInteger.valueOf(1234567890L),\n+                new BigInteger(\"123456789012345678901234568\"),\n+                new BigInteger(\"-1250000124326904597090347547457\")\n+                };\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        for (BigInteger value : values) {\n+            String expected = value.toString();\n+            assertEquals(expected,serializeAsString(mapper, value));\n+        }\n+    }\n+    \n+    public void testClass() throws Exception\n+    {\n+        String result = serializeAsString(java.util.List.class);\n+        assertEquals(\"\\\"java.util.List\\\"\", result);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestStatics.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * This unit test suite verifies that static fields and methods are\n+ * ignored wrt serialization\n+ */\n+public class TestStatics\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes\n+    /**********************************************************\n+     */\n+\n+    final static class FieldBean\n+    {\n+        public int x = 1;\n+\n+        public static int y = 2;\n+\n+        // not even @JsonProperty should make statics usable...\n+        @JsonProperty public static int z = 3;\n+    }\n+\n+    final static class GetterBean\n+    {\n+        public int getX() { return 3; }\n+\n+        public static int getA() { return -3; }\n+\n+        // not even @JsonProperty should make statics usable...\n+        @JsonProperty public static int getFoo() { return 123; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testStaticFields() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new FieldBean());\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(1), result.get(\"x\"));\n+    }\n+\n+    public void testStaticMethods() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Map<String,Object> result = writeAndMap(m, new GetterBean());\n+        assertEquals(1, result.size());\n+        assertEquals(Integer.valueOf(3), result.get(\"x\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestTreeSerialization.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+\n+import java.io.*;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.*;\n+\n+/**\n+ * This unit test suite tries to verify that JsonNode-based trees\n+ * can be serialized as expected\n+ */\n+public class TestTreeSerialization\n+    extends BaseMapTest\n+{\n+    final static class Bean {\n+        public String getX() { return \"y\"; }\n+        public int getY() { return 13; }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic void testSimpleViaObjectMapper()\n+        throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // also need tree mapper to construct tree to serialize\n+        ObjectNode n = mapper.getNodeFactory().objectNode();\n+        n.put(\"number\", 15);\n+        n.put(\"string\", \"abc\");\n+        ObjectNode n2 = n.putObject(\"ob\");\n+        n2.putArray(\"arr\");\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = mapper.getJsonFactory().createJsonGenerator(sw);\n+        mapper.writeTree(jg, n);\n+\n+        Map<String,Object> result = (Map<String,Object>) mapper.readValue(sw.toString(), Map.class);\n+\n+        assertEquals(3, result.size());\n+        assertEquals(\"abc\", result.get(\"string\"));\n+        assertEquals(Integer.valueOf(15), result.get(\"number\"));\n+        Map<String,Object> ob = (Map<String,Object>) result.get(\"ob\");\n+        assertEquals(1, ob.size());\n+        List<Object> list = (List<Object>) ob.get(\"arr\");\n+        assertEquals(0, list.size());\n+    }\n+\n+    /**\n+     * Simple test to verify that POJONodes (JsonNode wrapper around\n+     * any old Java object) work with serialization\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic void testPOJOString()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // also need tree mapper to construct tree to serialize\n+        ObjectNode n = mapper.getNodeFactory().objectNode();\n+        n.put(\"pojo\", mapper.getNodeFactory().POJONode(\"abc\"));\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = mapper.getJsonFactory().createJsonGenerator(sw);\n+        mapper.writeTree(jg, n);\n+        Map<String,Object> result = (Map<String,Object>) mapper.readValue(sw.toString(), Map.class);\n+        assertEquals(1, result.size());\n+        assertEquals(\"abc\", result.get(\"pojo\"));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPOJOIntArray()\n+        throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ObjectNode n = mapper.getNodeFactory().objectNode();\n+        n.put(\"pojo\", mapper.getNodeFactory().POJONode(new int[] { 1, 2, 3 }));\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = mapper.getJsonFactory().createJsonGenerator(sw);\n+        mapper.writeTree(jg, n);\n+\n+        Map<String,Object> result = (Map<String,Object>) mapper.readValue(sw.toString(), Map.class);\n+\n+        assertEquals(1, result.size());\n+        // int array becomes a list when mapped to general Object:\n+        List<Object> list = (List<Object>) result.get(\"pojo\");\n+        assertEquals(3, list.size());\n+        for (int i = 0; i < 3; ++i) {\n+            assertEquals(Integer.valueOf(i+1), list.get(i));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testPOJOBean()\n+        throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // also need tree mapper to construct tree to serialize\n+        ObjectNode n = mapper.getNodeFactory().objectNode();\n+        n.put(\"pojo\", mapper.getNodeFactory().POJONode(new Bean()));\n+        StringWriter sw = new StringWriter();\n+        JsonGenerator jg = mapper.getJsonFactory().createJsonGenerator(sw);\n+        mapper.writeTree(jg, n);\n+\n+        Map<String,Object> result = (Map<String,Object>) mapper.readValue(sw.toString(), Map.class);\n+\n+        assertEquals(1, result.size());\n+        Map<String,Object> bean = (Map<String,Object>) result.get(\"pojo\");\n+        assertEquals(2, bean.size());\n+        assertEquals(\"y\", bean.get(\"x\"));\n+        assertEquals(Integer.valueOf(13), bean.get(\"y\"));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestViews.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for verifying JSON view functionality: ability to declaratively\n+ * suppress subset of properties from being serialized.\n+ */\n+public class TestViews\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    // Classes that represent views\n+    static class ViewA { }\n+    static class ViewAA extends ViewA { }\n+    static class ViewB { }\n+    static class ViewBB extends ViewB { }\n+    \n+    static class Bean\n+    {\n+        @JsonView(ViewA.class)\n+        public String a = \"1\";\n+\n+        @JsonView({ViewAA.class, ViewB.class})\n+        public String aa = \"2\";\n+\n+        @JsonView(ViewB.class)\n+        public String getB() { return \"3\"; }\n+    }\n+\n+    /**\n+     * Bean with mix of explicitly annotated\n+     * properties, and implicit ones that may or may\n+     * not be included in views.\n+     */\n+    static class MixedBean\n+    {\n+        @JsonView(ViewA.class)\n+        public String a = \"1\";\n+\n+        public String getB() { return \"2\"; }\n+    }\n+\n+    /**\n+     * As indicated by [JACKSON-261], @JsonView should imply\n+     * that associated element (method, field) is to be considered\n+     * a property\n+     */\n+    static class ImplicitBean {\n+    \t@SuppressWarnings(\"unused\")\n+\t\t@JsonView(ViewA.class)\n+    \tprivate int a = 1;\n+    }\n+\n+    static class VisibilityBean {\n+        @JsonProperty protected String id = \"id\";\n+    \n+        @JsonView(ViewA.class)\n+        public String value = \"x\";\n+    }   \n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */    \n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public void testSimple() throws IOException\n+    {\n+        StringWriter sw = new StringWriter();\n+        ObjectMapper mapper = new ObjectMapper();\n+        // Ok, first, using no view whatsoever; all 3\n+        Bean bean = new Bean();\n+        Map<String,Object> map = writeAndMap(mapper, bean);\n+        assertEquals(3, map.size());\n+\n+        // Then with \"ViewA\", just one property\n+        sw = new StringWriter();\n+        mapper.writerWithView(ViewA.class).writeValue(sw, bean);\n+        map = mapper.readValue(sw.toString(), Map.class);\n+        assertEquals(1, map.size());\n+        assertEquals(\"1\", map.get(\"a\"));\n+\n+        // \"ViewAA\", 2 properties\n+        sw = new StringWriter();\n+        mapper.writerWithView(ViewAA.class).writeValue(sw, bean);\n+        map = mapper.readValue(sw.toString(), Map.class);\n+        assertEquals(2, map.size());\n+        assertEquals(\"1\", map.get(\"a\"));\n+        assertEquals(\"2\", map.get(\"aa\"));\n+\n+        // \"ViewB\", 2 prop2\n+        String json = mapper.writerWithView(ViewB.class).writeValueAsString(bean);\n+        map = mapper.readValue(json, Map.class);\n+        assertEquals(2, map.size());\n+        assertEquals(\"2\", map.get(\"aa\"));\n+        assertEquals(\"3\", map.get(\"b\"));\n+\n+        // and \"ViewBB\", 2 as well\n+        json = mapper.writerWithView(ViewBB.class).writeValueAsString(bean);\n+        map = mapper.readValue(json, Map.class);\n+        assertEquals(2, map.size());\n+        assertEquals(\"2\", map.get(\"aa\"));\n+        assertEquals(\"3\", map.get(\"b\"));\n+    }\n+\n+    /**\n+     * Unit test to verify implementation of [JACKSON-232], to\n+     * allow \"opt-in\" handling for JSON Views: that is, that\n+     * default for properties is to exclude unless included in\n+     * a view.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public void testDefaultExclusion() throws IOException\n+    {\n+        MixedBean bean = new MixedBean();\n+        StringWriter sw = new StringWriter();\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        // default setting: both fields will get included\n+        mapper.writerWithView(ViewA.class).writeValue(sw, bean);\n+        Map<String,Object> map = mapper.readValue(sw.toString(), Map.class);\n+        assertEquals(2, map.size());\n+        assertEquals(\"1\", map.get(\"a\"));\n+        assertEquals(\"2\", map.get(\"b\"));\n+\n+        // but can also change (but not necessarily on the fly...)\n+        mapper = new ObjectMapper();\n+        mapper.configure(SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION, false);\n+        // with this setting, only explicit inclusions count:\n+        String json = mapper.writerWithView(ViewA.class).writeValueAsString(bean);\n+        map = mapper.readValue(json, Map.class);\n+        assertEquals(1, map.size());\n+        assertEquals(\"1\", map.get(\"a\"));\n+        assertNull(map.get(\"b\"));\n+    }\n+\n+    /**\n+     * As per [JACKSON-261], @JsonView annotation should imply that associated\n+     * method/field does indicate a property.\n+     */\n+    public void testImplicitAutoDetection() throws Exception\n+    {\n+    \tassertEquals(\"{\\\"a\\\":1}\", serializeAsString(new ImplicitBean()));\n+    }\n+\n+    public void testVisibility() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        VisibilityBean bean = new VisibilityBean();\n+        // Without view setting, should only see \"id\"\n+        String json = mapper.writerWithView(Object.class).writeValueAsString(bean);\n+        //json = mapper.writeValueAsString(bean);\n+        assertEquals(\"{\\\"id\\\":\\\"id\\\"}\", json);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestViews2.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+public class TestViews2 extends BaseMapTest\n+{\n+\n+    /*\n+    /************************************************************************ \n+    /* Tests\n+    /************************************************************************ \n+     */\n+    \n+  public void testDataBindingUsage( ) throws Exception\n+  {\n+    ObjectMapper objectMapper = createObjectMapper( null );\n+    String result = serializeWithObjectMapper(new ComplexTestData( ), Views.View.class, objectMapper );\n+    assertEquals(-1, result.indexOf( \"nameHidden\" ));\n+  }\n+\n+  public void testDataBindingUsageWithoutView( ) throws Exception\n+  {\n+    ObjectMapper objectMapper = createObjectMapper( null );\n+    String json = serializeWithObjectMapper(new ComplexTestData( ), null, objectMapper);\n+    assertTrue(json.indexOf( \"nameHidden\" ) > 0);\n+  }\n+\n+  /*\n+  /************************************************************************\n+  /* Helper  methods\n+  /************************************************************************\n+   */\n+\n+  private ObjectMapper createObjectMapper(Class<?> viewClass)\n+  {\n+    ObjectMapper objectMapper = new ObjectMapper( );\n+    objectMapper.configure( SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false );\n+    objectMapper.setSerializationInclusion(JsonSerialize.Inclusion.NON_NULL );\n+    objectMapper.configure( SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION, false );\n+//    objectMapper.getSerializationConfig( ).disable( SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION );\n+//    objectMapper.getSerializationConfig( ).setSerializationView( viewClass );\n+    return objectMapper;\n+  }\n+  \n+  private String serializeWithObjectMapper(Object object, Class<? extends Views.View> view, ObjectMapper objectMapper )\n+      throws IOException\n+  {\n+    return objectMapper.writerWithView(view).writeValueAsString(object);\n+  }\n+\n+  /*\n+  /************************************************************************\n+  /* Helper classes\n+  /************************************************************************\n+   */\n+\n+  static class Views\n+  {\n+    public interface View { }\n+    public interface ExtendedView  extends View { }\n+  }\n+  \n+  static class ComplexTestData\n+  {\n+    String nameNull = null;\n+\n+    String nameComplex = \"complexValue\";\n+\n+    String nameComplexHidden = \"nameComplexHiddenValue\";\n+\n+    SimpleTestData testData = new SimpleTestData( );\n+\n+    SimpleTestData[] testDataArray = new SimpleTestData[] { new SimpleTestData( ), null };\n+\n+    @JsonView( Views.View.class )\n+    public String getNameNull()\n+    {\n+      return nameNull;\n+    }\n+\n+    public void setNameNull( String nameNull )\n+    {\n+      this.nameNull = nameNull;\n+    }\n+\n+    @JsonView( Views.View.class )\n+    public String getNameComplex()\n+    {\n+      return nameComplex;\n+    }\n+\n+    public void setNameComplex( String nameComplex )\n+    {\n+      this.nameComplex = nameComplex;\n+    }\n+\n+    public String getNameComplexHidden()\n+    {\n+      return nameComplexHidden;\n+    }\n+\n+    public void setNameComplexHidden( String nameComplexHidden )\n+    {\n+      this.nameComplexHidden = nameComplexHidden;\n+    }\n+\n+    @JsonView( Views.View.class )\n+    public SimpleTestData getTestData()\n+    {\n+      return testData;\n+    }\n+\n+    public void setTestData( SimpleTestData testData )\n+    {\n+      this.testData = testData;\n+    }\n+\n+    @JsonView( Views.View.class )\n+    public SimpleTestData[] getTestDataArray()\n+    {\n+      return testDataArray;\n+    }\n+\n+    public void setTestDataArray( SimpleTestData[] testDataArray )\n+    {\n+      this.testDataArray = testDataArray;\n+    }\n+  }\n+\n+  static class SimpleTestData\n+  {\n+    String name = \"shown\";\n+\n+    String nameHidden = \"hidden\";\n+\n+    @JsonView( Views.View.class )\n+    public String getName()\n+    {\n+      return name;\n+    }\n+\n+    public void setName( String name )\n+    {\n+      this.name = name;\n+    }\n+\n+    public String getNameHidden( )\n+    {\n+      return nameHidden;\n+    }\n+\n+    public void setNameHidden( String nameHidden )\n+    {\n+      this.nameHidden = nameHidden;\n+    }\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrapping.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Unit tests for verifying [JACKSON-132] implementation.\n+ */\n+public class TestUnwrapping extends BaseMapTest\n+{\n+    static class Unwrapping {\n+        public String name;\n+        @JsonUnwrapped\n+        public Location location;\n+\n+        public Unwrapping() { }\n+        public Unwrapping(String str, int x, int y) {\n+            name = str;\n+            location = new Location(x, y);\n+        }\n+    }\n+\n+    static class UnwrappingWithCreator {\n+        public String name;\n+\n+        @JsonUnwrapped\n+        public Location location;\n+\n+        @JsonCreator\n+        public UnwrappingWithCreator(@JsonProperty(\"name\") String n) {\n+            name = n;\n+        }\n+    }\n+    \n+    static class Location {\n+        public int x;\n+        public int y;\n+\n+        public Location() { }\n+        public Location(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n+        }\n+    }\n+\n+    // Class with two unwrapped properties\n+    static class TwoUnwrappedProperties {\n+        @JsonUnwrapped\n+        public Location location;\n+        @JsonUnwrapped\n+        public Name name;\n+\n+        public TwoUnwrappedProperties() { }\n+    }\n+\n+    static class Name {\n+        public String first, last;\n+    }\n+\n+    static class DeepUnwrapping\n+    {\n+        @JsonUnwrapped\n+        public Unwrapping unwrapped;\n+\n+        public DeepUnwrapping() { }\n+        public DeepUnwrapping(String str, int x, int y) {\n+            unwrapped = new Unwrapping(str, x, y);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Tests, serialization\n+    /**********************************************************\n+     */\n+    \n+    public void testSimpleUnwrappingSerialize() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertEquals(\"{\\\"name\\\":\\\"Tatu\\\",\\\"x\\\":1,\\\"y\\\":2}\",\n+                m.writeValueAsString(new Unwrapping(\"Tatu\", 1, 2)));\n+    }\n+\n+    public void testDeepUnwrappingSerialize() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertEquals(\"{\\\"name\\\":\\\"Tatu\\\",\\\"x\\\":1,\\\"y\\\":2}\",\n+                m.writeValueAsString(new DeepUnwrapping(\"Tatu\", 1, 2)));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Tests, deserialization\n+    /**********************************************************\n+     */\n+    \n+    public void testSimpleUnwrappedDeserialize() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        Unwrapping bean = m.readValue(\"{\\\"name\\\":\\\"Tatu\\\",\\\"y\\\":7,\\\"x\\\":-13}\",\n+                Unwrapping.class);\n+        assertEquals(\"Tatu\", bean.name);\n+        Location loc = bean.location;\n+        assertNotNull(loc);\n+        assertEquals(-13, loc.x);\n+        assertEquals(7, loc.y);\n+    }\n+\n+    public void testDoubleUnwrapping() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        TwoUnwrappedProperties bean = m.readValue(\"{\\\"first\\\":\\\"Joe\\\",\\\"y\\\":7,\\\"last\\\":\\\"Smith\\\",\\\"x\\\":-13}\",\n+                TwoUnwrappedProperties.class);\n+        Location loc = bean.location;\n+        assertNotNull(loc);\n+        assertEquals(-13, loc.x);\n+        assertEquals(7, loc.y);\n+        Name name = bean.name;\n+        assertNotNull(name);\n+        assertEquals(\"Joe\", name.first);\n+        assertEquals(\"Smith\", name.last);\n+    }\n+\n+    public void testDeepUnwrapping() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        DeepUnwrapping bean = m.readValue(\"{\\\"x\\\":3,\\\"name\\\":\\\"Bob\\\",\\\"y\\\":27}\",\n+                DeepUnwrapping.class);\n+        Unwrapping uw = bean.unwrapped;\n+        assertNotNull(uw);\n+        assertEquals(\"Bob\", uw.name);\n+        Location loc = uw.location;\n+        assertNotNull(loc);\n+        assertEquals(3, loc.x);\n+        assertEquals(27, loc.y);\n+    }\n+    \n+    public void testUnwrappedDeserializeWithCreator() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        UnwrappingWithCreator bean = m.readValue(\"{\\\"x\\\":1,\\\"y\\\":2,\\\"name\\\":\\\"Tatu\\\"}\",\n+                UnwrappingWithCreator.class);\n+        assertEquals(\"Tatu\", bean.name);\n+        Location loc = bean.location;\n+        assertNotNull(loc);\n+        assertEquals(1, loc.x);\n+        assertEquals(2, loc.y);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeDeserialization.java\n+package com.fasterxml.jackson.databind.tree;\n+\n+\n+import java.io.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.*;\n+\n+/**\n+ * This unit test suite tries to verify that JsonNode-based trees\n+ * can be deserialized as expected.\n+ */\n+public class TestTreeDeserialization\n+    extends BaseMapTest\n+{\n+    final static class Bean {\n+        int _x;\n+        JsonNode _node;\n+\n+        public void setX(int x) { _x = x; }\n+        public void setNode(JsonNode n) { _node = n; }\n+    }\n+\n+    /**\n+     * This test checks that is possible to mix \"regular\" Java objects\n+     * and JsonNode.\n+     */\n+    public void testMixed() throws IOException\n+    {\n+        ObjectMapper om = new ObjectMapper();\n+        String JSON = \"{\\\"node\\\" : { \\\"a\\\" : 3 }, \\\"x\\\" : 9 }\";\n+        Bean bean = om.readValue(JSON, Bean.class);\n+\n+        assertEquals(9, bean._x);\n+        JsonNode n = bean._node;\n+        assertNotNull(n);\n+        assertEquals(1, n.size());\n+        ObjectNode on = (ObjectNode) n;\n+        assertEquals(3, on.get(\"a\").getIntValue());\n+    }\n+\n+    /// Verifying [JACKSON-143]\n+    public void testArrayNodeEquality()\n+    {\n+        ArrayNode n1 = new ArrayNode(null);\n+        ArrayNode n2 = new ArrayNode(null);\n+\n+        assertTrue(n1.equals(n2));\n+        assertTrue(n2.equals(n1));\n+\n+        n1.add(TextNode.valueOf(\"Test\"));\n+\n+        assertFalse(n1.equals(n2));\n+        assertFalse(n2.equals(n1));\n+\n+        n2.add(TextNode.valueOf(\"Test\"));\n+\n+        assertTrue(n1.equals(n2));\n+        assertTrue(n2.equals(n1));\n+    }\n+\n+    public void testObjectNodeEquality()\n+    {\n+        ObjectNode n1 = new ObjectNode(null);\n+        ObjectNode n2 = new ObjectNode(null);\n+\n+        assertTrue(n1.equals(n2));\n+        assertTrue(n2.equals(n1));\n+\n+        n1.put(\"x\", TextNode.valueOf(\"Test\"));\n+\n+        assertFalse(n1.equals(n2));\n+        assertFalse(n2.equals(n1));\n+\n+        n2.put(\"x\", TextNode.valueOf(\"Test\"));\n+\n+        assertTrue(n1.equals(n2));\n+        assertTrue(n2.equals(n1));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeMapperDeserializer.java\n+package com.fasterxml.jackson.databind.tree;\n+\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * This unit test suite tries to verify that ObjectMapper\n+ * can properly parse JSON and bind contents into appropriate\n+ * JsonNode instances.\n+ */\n+public class TestTreeMapperDeserializer\n+    extends BaseTest\n+{\n+\tpublic void testSimple()\n+        throws Exception\n+    {\n+        final String JSON = SAMPLE_DOC_JSON_SPEC;\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+\n+        for (int type = 0; type < 2; ++type) {\n+            JsonNode result;\n+\n+            if (type == 0) {\n+                result = mapper.readTree(new StringReader(JSON));\n+            } else {\n+                result = mapper.readTree(JSON);\n+            }\n+\n+            assertType(result, ObjectNode.class);\n+            assertEquals(1, result.size());\n+            assertTrue(result.isObject());\n+            \n+            ObjectNode main = (ObjectNode) result;\n+            assertEquals(\"Image\", main.getFieldNames().next());\n+            JsonNode ob = main.getElements().next();\n+            assertType(ob, ObjectNode.class);\n+            ObjectNode imageMap = (ObjectNode) ob;\n+            \n+            assertEquals(5, imageMap.size());\n+            ob = imageMap.get(\"Width\");\n+            assertTrue(ob.isIntegralNumber());\n+            assertFalse(ob.isFloatingPointNumber());\n+            assertEquals(SAMPLE_SPEC_VALUE_WIDTH, ob.getIntValue());\n+            ob = imageMap.get(\"Height\");\n+            assertTrue(ob.isIntegralNumber());\n+            assertEquals(SAMPLE_SPEC_VALUE_HEIGHT, ob.getIntValue());\n+            \n+            ob = imageMap.get(\"Title\");\n+            assertTrue(ob.isTextual());\n+            assertEquals(SAMPLE_SPEC_VALUE_TITLE, ob.getTextValue());\n+            \n+            ob = imageMap.get(\"Thumbnail\");\n+            assertType(ob, ObjectNode.class);\n+            ObjectNode tn = (ObjectNode) ob;\n+            ob = tn.get(\"Url\");\n+            assertTrue(ob.isTextual());\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, ob.getTextValue());\n+            ob = tn.get(\"Height\");\n+            assertTrue(ob.isIntegralNumber());\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_HEIGHT, ob.getIntValue());\n+            ob = tn.get(\"Width\");\n+            assertTrue(ob.isTextual());\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, ob.getTextValue());\n+            \n+            ob = imageMap.get(\"IDs\");\n+            assertTrue(ob.isArray());\n+            ArrayNode idList = (ArrayNode) ob;\n+            assertEquals(4, idList.size());\n+            assertEquals(4, calcLength(idList.getElements()));\n+            assertEquals(4, calcLength(idList.iterator()));\n+            {\n+                int[] values = new int[] {\n+                    SAMPLE_SPEC_VALUE_TN_ID1,\n+                    SAMPLE_SPEC_VALUE_TN_ID2,\n+                    SAMPLE_SPEC_VALUE_TN_ID3,\n+                    SAMPLE_SPEC_VALUE_TN_ID4\n+                };\n+                for (int i = 0; i < values.length; ++i) {\n+                    assertEquals(values[i], idList.get(i).getIntValue());\n+                }\n+                int i = 0;\n+                for (JsonNode n : idList) {\n+                    assertEquals(values[i], n.getIntValue());\n+                    ++i;\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testBoolean()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode result = mapper.readTree(\"true\\n\");\n+        assertFalse(result.isNull());\n+        assertFalse(result.isNumber());\n+        assertFalse(result.isTextual());\n+        assertTrue(result.isBoolean());\n+        assertType(result, BooleanNode.class);\n+        assertTrue(result.getBooleanValue());\n+        assertEquals(\"true\", result.asText());\n+        assertFalse(result.isMissingNode());\n+\n+        // also, equality should work ok\n+        assertEquals(result, BooleanNode.valueOf(true));\n+        assertEquals(result, BooleanNode.getTrue());\n+    }\n+\n+    public void testDouble()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        double value = 3.04;\n+        JsonNode result = mapper.readTree(String.valueOf(value));\n+        assertTrue(result.isNumber());\n+        assertFalse(result.isNull());\n+        assertType(result, DoubleNode.class);\n+        assertTrue(result.isFloatingPointNumber());\n+        assertTrue(result.isDouble());\n+        assertFalse(result.isInt());\n+        assertFalse(result.isLong());\n+        assertFalse(result.isIntegralNumber());\n+        assertFalse(result.isTextual());\n+        assertFalse(result.isMissingNode());\n+\n+        assertEquals(value, result.getDoubleValue());\n+        assertEquals(value, result.getNumberValue().doubleValue());\n+        assertEquals((int) value, result.getIntValue());\n+        assertEquals((long) value, result.getLongValue());\n+        assertEquals(String.valueOf(value), result.asText());\n+\n+        // also, equality should work ok\n+        assertEquals(result, DoubleNode.valueOf(value));\n+    }\n+\n+    public void testInt()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        int value = -90184;\n+        JsonNode result = mapper.readTree(String.valueOf(value));\n+        assertTrue(result.isNumber());\n+        assertTrue(result.isIntegralNumber());\n+        assertTrue(result.isInt());\n+        assertType(result, IntNode.class);\n+        assertFalse(result.isLong());\n+        assertFalse(result.isFloatingPointNumber());\n+        assertFalse(result.isDouble());\n+        assertFalse(result.isNull());\n+        assertFalse(result.isTextual());\n+        assertFalse(result.isMissingNode());\n+\n+        assertEquals(value, result.getNumberValue().intValue());\n+        assertEquals(value, result.getIntValue());\n+        assertEquals(String.valueOf(value), result.asText());\n+        assertEquals((double) value, result.getDoubleValue());\n+        assertEquals((long) value, result.getLongValue());\n+\n+        // also, equality should work ok\n+        assertEquals(result, IntNode.valueOf(value));\n+    }\n+\n+    public void testLong()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // need to use something being 32-bit value space\n+        long value = 12345678L << 32;\n+        JsonNode result = mapper.readTree(String.valueOf(value));\n+        assertTrue(result.isNumber());\n+        assertTrue(result.isIntegralNumber());\n+        assertTrue(result.isLong());\n+        assertType(result, LongNode.class);\n+        assertFalse(result.isInt());\n+        assertFalse(result.isFloatingPointNumber());\n+        assertFalse(result.isDouble());\n+        assertFalse(result.isNull());\n+        assertFalse(result.isTextual());\n+        assertFalse(result.isMissingNode());\n+\n+        assertEquals(value, result.getNumberValue().longValue());\n+        assertEquals(value, result.getLongValue());\n+        assertEquals(String.valueOf(value), result.asText());\n+        assertEquals((double) value, result.getDoubleValue());\n+\n+        // also, equality should work ok\n+        assertEquals(result, LongNode.valueOf(value));\n+    }\n+\n+    public void testNull()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode result = mapper.readTree(\"   null \");\n+        // should not get java null, but NullNode...\n+        assertNotNull(result);\n+        assertTrue(result.isNull());\n+        assertFalse(result.isNumber());\n+        assertFalse(result.isTextual());\n+        assertEquals(\"null\", result.asText());\n+\n+        // also, equality should work ok\n+        assertEquals(result, NullNode.instance);\n+    }\n+\n+    public void testDecimalNode()\n+        throws Exception\n+    {\n+        // no \"natural\" way to get it, must construct\n+        BigDecimal value = new BigDecimal(\"0.1\");\n+        JsonNode result = DecimalNode.valueOf(value);\n+\n+        assertFalse(result.isArray());\n+        assertFalse(result.isObject());\n+        assertTrue(result.isNumber());\n+        assertFalse(result.isIntegralNumber());\n+        assertFalse(result.isLong());\n+        assertType(result, DecimalNode.class);\n+        assertFalse(result.isInt());\n+        assertTrue(result.isFloatingPointNumber());\n+        assertTrue(result.isBigDecimal());\n+        assertFalse(result.isDouble());\n+        assertFalse(result.isNull());\n+        assertFalse(result.isTextual());\n+        assertFalse(result.isMissingNode());\n+\n+        assertEquals(value, result.getNumberValue());\n+        assertEquals(value.toString(), result.asText());\n+\n+        // also, equality should work ok\n+        assertEquals(result, DecimalNode.valueOf(value));\n+    }\n+\n+    public void testSimpleArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ArrayNode result = mapper.createArrayNode();\n+\n+        assertTrue(result.isArray());\n+        assertType(result, ArrayNode.class);\n+\n+        assertFalse(result.isObject());\n+        assertFalse(result.isNumber());\n+        assertFalse(result.isNull());\n+        assertFalse(result.isTextual());\n+\n+        // and let's add stuff...\n+        result.add(false);\n+        result.insertNull(0);\n+\n+        // should be equal to itself no matter what\n+        assertEquals(result, result);\n+        assertFalse(result.equals(null)); // but not to null\n+\n+        // plus see that we can access stuff\n+        assertEquals(NullNode.instance, result.path(0));\n+        assertEquals(NullNode.instance, result.get(0));\n+        assertEquals(BooleanNode.FALSE, result.path(1));\n+        assertEquals(BooleanNode.FALSE, result.get(1));\n+        assertEquals(2, result.size());\n+\n+        assertNull(result.get(-1));\n+        assertNull(result.get(2));\n+        JsonNode missing = result.path(2);\n+        assertTrue(missing.isMissingNode());\n+        assertTrue(result.path(-100).isMissingNode());\n+\n+        // then construct and compare\n+        ArrayNode array2 = mapper.createArrayNode();\n+        array2.addNull();\n+        array2.add(false);\n+        assertEquals(result, array2);\n+\n+        // plus remove entries\n+        JsonNode rm1 = array2.remove(0);\n+        assertEquals(NullNode.instance, rm1);\n+        assertEquals(1, array2.size());\n+        assertEquals(BooleanNode.FALSE, array2.get(0));\n+        assertFalse(result.equals(array2));\n+\n+        JsonNode rm2 = array2.remove(0);\n+        assertEquals(BooleanNode.FALSE, rm2);\n+        assertEquals(0, array2.size());\n+    }\n+\n+    /**\n+     * Type mappers should be able to gracefully deal with end of\n+     * input.\n+     */\n+    public void testEOF() throws Exception\n+    {\n+        String JSON =\n+            \"{ \\\"key\\\": [ { \\\"a\\\" : { \\\"name\\\": \\\"foo\\\",  \\\"type\\\": 1\\n\"\n+            +\"},  \\\"type\\\": 3, \\\"url\\\": \\\"http://www.google.com\\\" } ],\\n\"\n+            +\"\\\"name\\\": \\\"xyz\\\", \\\"type\\\": 1, \\\"url\\\" : null }\\n  \"\n+            ;\n+        JsonFactory jf = new JsonFactory();\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonParser jp = jf.createJsonParser(new StringReader(JSON));\n+        JsonNode result = mapper.readTree(jp);\n+\n+        assertTrue(result.isObject());\n+        assertEquals(4, result.size());\n+\n+        assertNull(mapper.readTree(jp));\n+    }\n+\n+    public void testMultiple() throws Exception\n+    {\n+        String JSON = \"12  \\\"string\\\" [ 1, 2, 3 ]\";\n+        JsonFactory jf = new JsonFactory();\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonParser jp = jf.createJsonParser(new StringReader(JSON));\n+        JsonNode result = mapper.readTree(jp);\n+\n+        assertTrue(result.isIntegralNumber());\n+        assertTrue(result.isInt());\n+        assertFalse(result.isTextual());\n+        assertEquals(12, result.getIntValue());\n+\n+        result = mapper.readTree(jp);\n+        assertTrue(result.isTextual());\n+        assertFalse(result.isIntegralNumber());\n+        assertFalse(result.isInt());\n+        assertEquals(\"string\", result.getTextValue());\n+\n+        result = mapper.readTree(jp);\n+        assertTrue(result.isArray());\n+        assertEquals(3, result.size());\n+\n+        assertNull(mapper.readTree(jp));\n+    }\n+\n+    /**\n+     * Let's also verify behavior of \"MissingNode\" -- one needs to be able\n+     * to traverse such bogus nodes with appropriate methods.\n+     */\n+    @SuppressWarnings(\"unused\")\n+    public void testMissingNode()\n+        throws Exception\n+    {\n+        String JSON = \"[ { }, [ ] ]\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode result = mapper.readTree(new StringReader(JSON));\n+\n+        assertTrue(result.isContainerNode());\n+        assertTrue(result.isArray());\n+        assertEquals(2, result.size());\n+\n+        int count = 0;\n+        for (JsonNode node : result) {\n+            ++count;\n+        }\n+        assertEquals(2, count);\n+\n+        Iterator<JsonNode> it = result.iterator();\n+\n+        JsonNode onode = it.next();\n+        assertTrue(onode.isContainerNode());\n+        assertTrue(onode.isObject());\n+        assertEquals(0, onode.size());\n+        assertFalse(onode.isMissingNode()); // real node\n+        assertNull(onode.getTextValue());\n+\n+        // how about dereferencing?\n+        assertNull(onode.get(0));\n+        JsonNode dummyNode = onode.path(0);\n+        assertNotNull(dummyNode);\n+        assertTrue(dummyNode.isMissingNode());\n+        assertNull(dummyNode.get(3));\n+        assertNull(dummyNode.get(\"whatever\"));\n+        JsonNode dummyNode2 = dummyNode.path(98);\n+        assertNotNull(dummyNode2);\n+        assertTrue(dummyNode2.isMissingNode());\n+        JsonNode dummyNode3 = dummyNode.path(\"field\");\n+        assertNotNull(dummyNode3);\n+        assertTrue(dummyNode3.isMissingNode());\n+\n+        // and same for the array node\n+\n+        JsonNode anode = it.next();\n+        assertTrue(anode.isContainerNode());\n+        assertTrue(anode.isArray());\n+        assertFalse(anode.isMissingNode()); // real node\n+        assertEquals(0, anode.size());\n+\n+        assertNull(anode.get(0));\n+        dummyNode = anode.path(0);\n+        assertNotNull(dummyNode);\n+        assertTrue(dummyNode.isMissingNode());\n+        assertNull(dummyNode.get(0));\n+        assertNull(dummyNode.get(\"myfield\"));\n+        dummyNode2 = dummyNode.path(98);\n+        assertNotNull(dummyNode2);\n+        assertTrue(dummyNode2.isMissingNode());\n+        dummyNode3 = dummyNode.path(\"f\");\n+        assertNotNull(dummyNode3);\n+        assertTrue(dummyNode3.isMissingNode());\n+    }\n+\n+    public void testArray() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final String JSON = \"[[[-0.027512,51.503221],[-0.008497,51.503221],[-0.008497,51.509744],[-0.027512,51.509744]]]\";\n+\n+        JsonNode n = mapper.readTree(JSON);\n+        assertNotNull(n);\n+        assertTrue(n.isArray());\n+        ArrayNode an = (ArrayNode) n;\n+        assertEquals(1, an.size());\n+        ArrayNode an2 = (ArrayNode) n.get(0);\n+        assertTrue(an2.isArray());\n+        assertEquals(4, an2.size());\n+    }\n+    \n+    /*\n+    /**********************************************\n+    /* Helper methods\n+    /**********************************************\n+     */\n+\n+    private int calcLength(Iterator<JsonNode> it)\n+    {\n+        int count = 0;\n+        while (it.hasNext()) {\n+            it.next();\n+            ++count;\n+        }\n+        return count;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeMapperMaps.java\n+package com.fasterxml.jackson.databind.tree;\n+\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * Unit tests to verify that Json Objects map property to Map-like\n+ * ObjectNodes.\n+ */\n+public class TestTreeMapperMaps\n+    extends BaseTest\n+{\n+    public void testSimpleObject() throws Exception\n+    {\n+        String JSON = \"{ \\\"key\\\" : 1, \\\"b\\\" : \\\"x\\\" }\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonNode root = mapper.readTree(JSON);\n+\n+        // basic properties first:\n+        assertFalse(root.isValueNode());\n+        assertTrue(root.isContainerNode());\n+        assertFalse(root.isArray());\n+        assertTrue(root.isObject());\n+        assertEquals(2, root.size());\n+\n+        // Related to [JACKSON-50]:\n+        Iterator<JsonNode> it = root.iterator();\n+        assertNotNull(it);\n+        assertTrue(it.hasNext());\n+        JsonNode n = it.next();\n+        assertNotNull(n);\n+        assertEquals(IntNode.valueOf(1), n);\n+\n+        assertTrue(it.hasNext());\n+        n = it.next();\n+        assertNotNull(n);\n+        assertEquals(TextNode.valueOf(\"x\"), n);\n+\n+        assertFalse(it.hasNext());\n+\n+        // Ok, then, let's traverse via extended interface\n+        ObjectNode obNode = (ObjectNode) root;\n+        Iterator<Map.Entry<String,JsonNode>> fit = obNode.getFields();\n+        // we also know that LinkedHashMap is used, i.e. order preserved\n+        assertTrue(fit.hasNext());\n+        Map.Entry<String,JsonNode> en = fit.next();\n+        assertEquals(\"key\", en.getKey());\n+        assertEquals(IntNode.valueOf(1), en.getValue());\n+\n+        assertTrue(fit.hasNext());\n+        en = fit.next();\n+        assertEquals(\"b\", en.getKey());\n+        assertEquals(TextNode.valueOf(\"x\"), en.getValue());\n+\n+        // Plus: we should be able to modify the node via iterator too:\n+        fit.remove();\n+        assertEquals(1, obNode.size());\n+        assertEquals(IntNode.valueOf(1), root.get(\"key\"));\n+        assertNull(root.get(\"b\"));\n+    }\n+\n+    public void testSimplePath() throws Exception\n+    {\n+        JsonNode root = new ObjectMapper().readTree(\"{ \\\"results\\\" : { \\\"a\\\" : 3 } }\");\n+        assertTrue(root.isObject());\n+        JsonNode rnode = root.path(\"results\");\n+        assertNotNull(rnode);\n+        assertTrue(rnode.isObject());\n+        assertEquals(3, rnode.path(\"a\").getIntValue());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/tree/TestTreeMapperSerializer.java\n+package com.fasterxml.jackson.databind.tree;\n+\n+import static org.junit.Assert.*;\n+\n+import java.io.*;\n+\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.*;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * This unit test suite tries to verify that the trees ObjectMapper\n+ * constructs can be serialized properly.\n+ */\n+public class TestTreeMapperSerializer\n+    extends BaseTest\n+{\n+    final static String FIELD1 = \"first\";\n+    final static String FIELD2 = \"Second?\";\n+    final static String FIELD3 = \"foo'n \\\"bar\\\"\";\n+    final static String FIELD4 = \"4\";\n+\n+    final static String TEXT1 = \"Some text & \\\"stuff\\\"\";\n+    final static String TEXT2 = \"Some more text:\\twith\\nlinefeeds and all!\";\n+\n+    final static double DOUBLE_VALUE = 9.25;\n+\n+    public void testFromArray()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ArrayNode root = mapper.createArrayNode();\n+        root.add(TEXT1);\n+        root.add(3);\n+        ObjectNode obj = root.addObject();\n+        obj.put(FIELD1, true);\n+        obj.putArray(FIELD2);\n+        root.add(false);\n+\n+        /* Ok, ready... let's serialize using one of two alternate\n+         * methods: first preferred (using generator)\n+         * (there are 2 variants here too)\n+         */\n+        for (int i = 0; i < 2; ++i) {\n+            StringWriter sw = new StringWriter();\n+            if (i == 0) {\n+                JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+                root.serialize(gen, null);\n+                gen.close();\n+            } else {\n+                mapper.writeValue(sw, root);\n+            }\n+            verifyFromArray(sw.toString());\n+        }\n+            \n+        // And then convenient but less efficient alternative:\n+        verifyFromArray(root.toString());\n+    }\n+\n+    public void testFromMap()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ObjectNode root = mapper.createObjectNode();\n+        root.put(FIELD4, TEXT2);\n+        root.put(FIELD3, -1);\n+        root.putArray(FIELD2);\n+        root.put(FIELD1, DOUBLE_VALUE);\n+\n+        /* Let's serialize using one of two alternate methods:\n+         * first preferred (using generator)\n+         * (there are 2 variants here too)\n+         */\n+        for (int i = 0; i < 2; ++i) {\n+            StringWriter sw = new StringWriter();\n+            if (i == 0) {\n+                JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+                root.serialize(gen, null);\n+                gen.close();\n+            } else {\n+                mapper.writeValue(sw, root);\n+            }\n+            verifyFromMap(sw.toString());\n+        }\n+\n+        // And then convenient but less efficient alternative:\n+        verifyFromMap(root.toString());\n+    }\n+\n+    /**\n+     * Unit test to check for regression of [JACKSON-18].\n+     */\n+    public void testSmallNumbers()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        ArrayNode root = mapper.createArrayNode();\n+        for (int i = -20; i <= 20; ++i) {\n+            JsonNode n = root.numberNode(i);\n+            root.add(n);\n+            // Hmmh. Not sure why toString() won't be triggered otherwise...\n+            assertEquals(String.valueOf(i), n.toString());\n+        }\n+\n+        // Loop over 2 different serialization methods\n+        for (int type = 0; type < 2; ++type) {\n+            StringWriter sw = new StringWriter();\n+            if (type == 0) {\n+                JsonGenerator gen = new JsonFactory().createJsonGenerator(sw);\n+                root.serialize(gen, null);\n+                gen.close();\n+            } else {\n+                mapper.writeValue(sw, root);\n+            }\n+            \n+            String doc = sw.toString();\n+            JsonParser jp = new JsonFactory().createJsonParser(new StringReader(doc));\n+            \n+            assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+            for (int i = -20; i <= 20; ++i) {\n+                assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+                assertEquals(i, jp.getIntValue());\n+                assertEquals(\"\"+i, jp.getText());\n+            }\n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            jp.close();\n+        }\n+    }\n+\n+    public void testNull() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, NullNode.instance);\n+        assertEquals(\"null\", sw.toString());\n+    }\n+\n+    public void testBinary()\n+        throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final int LENGTH = 13045;\n+        byte[] data = new byte[LENGTH];\n+        for (int i = 0; i < LENGTH; ++i) {\n+            data[i] = (byte) i;\n+        }\n+        StringWriter sw = new StringWriter();\n+        mapper.writeValue(sw, BinaryNode.valueOf(data));\n+\n+        JsonParser jp = new JsonFactory().createJsonParser(sw.toString());\n+        // note: can't determine it's binary from json alone:\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertArrayEquals(data, jp.getBinaryValue());\n+        jp.close();\n+    }\n+\n+    /*\n+    ///////////////////////////////////////////////////////////////\n+    // Internal methods\n+    ///////////////////////////////////////////////////////////////\n+     */\n+\n+    private void verifyFromArray(String input)\n+        throws Exception\n+    {\n+        JsonParser jp = new JsonFactory().createJsonParser(new StringReader(input));\n+        \n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        \n+        assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(TEXT1, getAndVerifyText(jp));\n+        \n+        assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(3, jp.getIntValue());\n+        \n+        assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(FIELD1, getAndVerifyText(jp));\n+        \n+        assertEquals(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(FIELD2, getAndVerifyText(jp));\n+        \n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+        assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+        \n+        assertEquals(JsonToken.VALUE_FALSE, jp.nextToken());\n+        \n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+    }\n+\n+    private void verifyFromMap(String input)\n+        throws Exception\n+    {\n+        JsonParser jp = new JsonFactory().createJsonParser(new StringReader(input));\n+        assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(FIELD4, getAndVerifyText(jp));\n+        assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(TEXT2, getAndVerifyText(jp));\n+        \n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(FIELD3, getAndVerifyText(jp));\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(-1, jp.getIntValue());\n+        \n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(FIELD2, getAndVerifyText(jp));\n+        assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+        assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+        \n+        assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(FIELD1, getAndVerifyText(jp));\n+        assertEquals(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        assertEquals(DOUBLE_VALUE, jp.getDoubleValue());\n+        \n+        assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+        \n+        assertNull(jp.nextToken());\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestAnnotatedClass.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+\n+/**\n+ * Unit test for verifying that {@link AnnotatedClass}\n+ * works as expected.\n+ */\n+public class TestAnnotatedClass\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Annotated helper classes\n+    /**********************************************************\n+     */\n+\n+    static class BaseClass\n+    {\n+        public int foo;\n+\n+        public BaseClass(int x, int y) { }\n+\n+        @JsonProperty public int x() { return 3; }\n+    }\n+\n+    static class SubClass extends BaseClass\n+    {\n+        public SubClass() { this(1); }\n+        public SubClass(int x) { super(x, 2); }\n+\n+        public int y() { return 3; }\n+    }\n+\n+    static abstract class GenericBase<T extends Number>\n+    {\n+        public abstract void setX(T value);\n+    }\n+\n+    static class NumberBean\n+        extends GenericBase<Integer>\n+    {\n+        @Override\n+        public void setX(Integer value) { }\n+    }\n+\n+    /**\n+     * Test class for checking that field introspection\n+     * works as expected\n+     */\n+    static class FieldBean\n+    {\n+        // static, not to be included:\n+        public static boolean DUMMY;\n+\n+        // not public, no annotations, shouldn't be included\n+        @SuppressWarnings(\"unused\")\n+        private long bar;\n+\n+        @SuppressWarnings(\"unused\")\n+        @JsonProperty\n+        private String props;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    public void testFieldIntrospection()\n+    {\n+        // null -> no mix-in annotations\n+        AnnotatedClass ac = AnnotatedClass.construct(FieldBean.class, new JacksonAnnotationIntrospector(), null);\n+        ac.resolveFields();\n+        /* 14-Jul-2009, tatu: AnnotatedClass does remove forcibly ignored\n+         *   entries, but will still contain non-public fields too (earlier\n+         *   versions didn't, but filtering was moved to a later point)\n+         */\n+        assertEquals(2, ac.getFieldCount());\n+        for (AnnotatedField f : ac.fields()) {\n+            String fname = f.getName();\n+            if (!\"bar\".equals(fname) && !\"props\".equals(fname)) {\n+                fail(\"Unexpected field name '\"+fname+\"'\");\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+\n+/**\n+ * Simple tests to verify that {@link JavaType} types work to\n+ * some degree\n+ */\n+public class TestJavaType\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    static class BaseType { }\n+\n+    static class SubType extends BaseType { }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    public void testSimpleClass()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType baseType = tf.constructType(BaseType.class);\n+        assertSame(BaseType.class, baseType.getRawClass());\n+        assertTrue(baseType.hasRawClass(BaseType.class));\n+\n+        assertFalse(baseType.isArrayType());\n+        assertFalse(baseType.isContainerType());\n+        assertFalse(baseType.isEnumType());\n+        assertFalse(baseType.isInterface());\n+        assertFalse(baseType.isPrimitive());\n+\n+        assertNull(baseType.getContentType());\n+        assertNull(baseType.getValueHandler());\n+\n+        /* both narrow and widen just return type itself (exact, not just\n+         * equal)\n+         * (also note that widen/narrow wouldn't work on basic simple\n+         * class type otherwise)\n+         */\n+        assertSame(baseType, baseType.narrowBy(BaseType.class));\n+        assertSame(baseType, baseType.widenBy(BaseType.class));\n+\n+        // Also: no narrowing for simple types (but should there be?)\n+        try {\n+            baseType.narrowBy(SubType.class);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"should never be called\");\n+        }\n+\n+        // Also, let's try assigning bogus handler\n+        /*\n+        baseType.setValueHandler(\"xyz\"); // untyped\n+        assertEquals(\"xyz\", baseType.getValueHandler());\n+        // illegal to re-set\n+        try {\n+            baseType.setValueHandler(\"foobar\");\n+            fail(\"Shouldn't allow re-setting value handler\");\n+        } catch (IllegalStateException iae) {\n+            verifyException(iae, \"Trying to reset\");\n+        }\n+        */\n+    }\n+\n+    public void testMapType()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType keyT = tf.constructType(String.class);\n+        JavaType baseT = tf.constructType(BaseType.class);\n+\n+        MapType mapT = MapType.construct(Map.class, keyT, baseT);\n+        assertNotNull(mapT);\n+        assertTrue(mapT.isContainerType());\n+\n+        // NOPs:\n+        assertSame(mapT, mapT.narrowContentsBy(BaseType.class));\n+        assertSame(mapT, mapT.narrowKey(String.class));\n+\n+        assertTrue(mapT.equals(mapT));\n+        assertFalse(mapT.equals(null));\n+        assertFalse(mapT.equals(\"xyz\"));\n+\n+        MapType mapT2 = MapType.construct(HashMap.class, keyT, baseT);\n+        assertFalse(mapT.equals(mapT2));\n+\n+        // Also, must use map type constructor, not simple...\n+        try {\n+            SimpleType.construct(HashMap.class);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"for a Map\");\n+        }\n+    }\n+\n+    public void testArrayType()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType arrayT = ArrayType.construct(tf.constructType(String.class), null, null);\n+        assertNotNull(arrayT);\n+        assertTrue(arrayT.isContainerType());\n+\n+        // NOPs:\n+        assertSame(arrayT, arrayT.narrowContentsBy(String.class));\n+\n+        assertNotNull(arrayT.toString());\n+\n+        assertTrue(arrayT.equals(arrayT));\n+        assertFalse(arrayT.equals(null));\n+        assertFalse(arrayT.equals(\"xyz\"));\n+\n+        assertTrue(arrayT.equals(ArrayType.construct(tf.constructType(String.class), null, null)));\n+        assertFalse(arrayT.equals(ArrayType.construct(tf.constructType(Integer.class), null, null)));\n+\n+        // Also, must NOT try to create using simple type\n+        try {\n+            SimpleType.construct(String[].class);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"for an array\");\n+        }\n+    }\n+\n+    public void testCollectionType()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        // List<String>\n+        JavaType collectionT = CollectionType.construct(List.class, tf.constructType(String.class));\n+        assertNotNull(collectionT);\n+        assertTrue(collectionT.isContainerType());\n+\n+        // NOPs:\n+        assertSame(collectionT, collectionT.narrowContentsBy(String.class));\n+\n+        assertNotNull(collectionT.toString());\n+\n+        assertTrue(collectionT.equals(collectionT));\n+        assertFalse(collectionT.equals(null));\n+        assertFalse(collectionT.equals(\"xyz\"));\n+\n+        assertTrue(collectionT.equals(CollectionType.construct(List.class, tf.constructType(String.class))));\n+        assertFalse(collectionT.equals(CollectionType.construct(Set.class, tf.constructType(String.class))));\n+\n+        // Also, must NOT try to create using simple type\n+        try {\n+            SimpleType.construct(ArrayList.class);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"for a Collection\");\n+        }\n+    }\n+\n+    public void testClassKey()\n+    {\n+        ClassKey key = new ClassKey(String.class);\n+        assertEquals(0, key.compareTo(key));\n+        assertTrue(key.equals(key));\n+        assertFalse(key.equals(null));\n+        assertFalse(key.equals(\"foo\"));\n+        assertFalse(key.equals(new ClassKey(Integer.class)));\n+        assertEquals(String.class.getName(), key.toString());\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeBindings.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+\n+/**\n+ * Simple tests to verify for generic type binding functionality\n+ * implemented by {@link TypeBindings} class.\n+ */\n+public class TestTypeBindings\n+    extends com.fasterxml.jackson.test.BaseTest\n+{    \n+    static class AbstractType<A,B> { }\n+    \n+    static class LongStringType extends AbstractType<Long,String> { }\n+\n+    static class InnerGenericTyping<K, V> extends AbstractMap<K, Collection<V>>\n+    {\n+        @Override\n+        public Set<java.util.Map.Entry<K, Collection<V>>> entrySet() {\n+            return null;\n+        }\n+        public class InnerClass extends AbstractMap<K, Collection<V>> {\n+            @Override\n+            public Set<java.util.Map.Entry<K, Collection<V>>> entrySet() {\n+                return null;\n+            }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    public void testAbstract() throws Exception\n+    {\n+        /* Abstract type does declare type parameters, but they are only\n+         * known as 'Object.class' (via lower bound)\n+         */\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        TypeBindings b = new TypeBindings(tf, AbstractType.class);\n+        assertEquals(2, b.getBindingCount());\n+        JavaType obType = tf.constructType(Object.class);\n+        assertEquals(obType, b.findType(\"A\"));\n+        assertEquals(obType, b.findType(\"B\"));\n+    }\n+\n+    public void testSimple() throws Exception\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        // concrete class does have bindings however\n+        TypeBindings b = new TypeBindings(tf, LongStringType.class);\n+        assertEquals(2, b.getBindingCount());\n+        assertEquals(tf.constructType(Long.class), b.findType(\"A\"));\n+        assertEquals(tf.constructType(String.class), b.findType(\"B\"));\n+    }\n+\n+\n+    // [JACKSON-677]\n+    public void testInnerType()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(InnerGenericTyping.InnerClass.class);\n+        assertEquals(MapType.class, type.getClass());\n+        JavaType keyType = type.getKeyType();\n+        assertEquals(Object.class, keyType.getRawClass());\n+        JavaType valueType = type.getContentType();\n+        assertEquals(Collection.class, valueType.getRawClass());\n+        JavaType vt2 = valueType.getContentType();\n+        assertEquals(Object.class, vt2.getRawClass());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.lang.reflect.Field;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.type.CollectionType;\n+import com.fasterxml.jackson.databind.type.HierarchicType;\n+import com.fasterxml.jackson.databind.type.MapType;\n+import com.fasterxml.jackson.databind.type.SimpleType;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+/**\n+ * Simple tests to verify that the {@link TypeFactory} constructs\n+ * type information as expected.\n+ */\n+public class TestTypeFactory\n+    extends BaseTest\n+{    \n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    enum EnumForCanonical { YES, NO; }\n+\n+    static class SingleArgGeneric<X> { }\n+\n+    abstract static class MyMap extends IntermediateMap<String,Long> { }\n+    abstract static class IntermediateMap<K,V> implements Map<K,V> { }\n+\n+    abstract static class MyList extends IntermediateList<Long> { }\n+    abstract static class IntermediateList<E> implements List<E> { }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class GenericList<T> extends ArrayList<T> { }\n+    \n+    interface MapInterface extends Cloneable, IntermediateInterfaceMap<String> { }\n+    interface IntermediateInterfaceMap<FOO> extends Map<FOO, Integer> { }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class MyStringIntMap extends MyStringXMap<Integer> { }\n+    @SuppressWarnings(\"serial\")\n+    static class MyStringXMap<V> extends HashMap<String,V> { }\n+\n+    // And one more, now with obfuscated type names; essentially it's just Map<Int,Long>\n+    static abstract class IntLongMap extends XLongMap<Integer> { }\n+    // trick here is that V now refers to key type, not value type\n+    static abstract class XLongMap<V> extends XXMap<V,Long> { }\n+    static abstract class XXMap<K,V> implements Map<K,V> { }\n+\n+    static class SneakyBean {\n+        public IntLongMap intMap;\n+        public MyList longList;\n+    }\n+\n+    static class SneakyBean2 {\n+        // self-reference; should be resolved as \"Comparable<Object>\"\n+        public <T extends Comparable<T>> T getFoobar() { return null; }\n+    }\n+    \n+    @SuppressWarnings(\"serial\")\n+    public static class LongValuedMap<K> extends HashMap<K, Long> { }\n+\n+    static class StringLongMapBean {\n+        public LongValuedMap<String> value;\n+    }\n+\n+    static class StringListBean {\n+        public GenericList<String> value;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testSimpleTypes()\n+    {\n+        Class<?>[] classes = new Class<?>[] {\n+            boolean.class, byte.class, char.class,\n+                short.class, int.class, long.class,\n+                float.class, double.class,\n+\n+            Boolean.class, Byte.class, Character.class,\n+                Short.class, Integer.class, Long.class,\n+                Float.class, Double.class,\n+\n+                String.class,\n+                Object.class,\n+\n+                Calendar.class,\n+                Date.class,\n+        };\n+\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        for (Class<?> clz : classes) {\n+            assertSame(clz, tf.constructType(clz).getRawClass());\n+            assertSame(clz, tf.constructType(clz).getRawClass());\n+        }\n+    }\n+\n+    public void testArrays()\n+    {\n+        Class<?>[] classes = new Class<?>[] {\n+            boolean[].class, byte[].class, char[].class,\n+                short[].class, int[].class, long[].class,\n+                float[].class, double[].class,\n+\n+                String[].class, Object[].class,\n+                Calendar[].class,\n+        };\n+\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        for (Class<?> clz : classes) {\n+            assertSame(clz, tf.constructType(clz).getRawClass());\n+            Class<?> elemType = clz.getComponentType();\n+            assertSame(clz, tf.constructArrayType(elemType).getRawClass());\n+        }\n+    }\n+\n+    public void testCollections()\n+    {\n+        // Ok, first: let's test what happens when we pass 'raw' Collection:\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType t = tf.constructType(ArrayList.class);\n+        assertEquals(CollectionType.class, t.getClass());\n+        assertSame(ArrayList.class, t.getRawClass());\n+\n+        // And then the proper way\n+        t = tf.constructType(new TypeReference<ArrayList<String>>() { });\n+        assertEquals(CollectionType.class, t.getClass());\n+        assertSame(ArrayList.class, t.getRawClass());\n+\n+        JavaType elemType = ((CollectionType) t).getContentType();\n+        assertNotNull(elemType);\n+        assertSame(SimpleType.class, elemType.getClass());\n+        assertSame(String.class, elemType.getRawClass());\n+\n+        // And alternate method too\n+        t = tf.constructCollectionType(ArrayList.class, String.class);\n+        assertEquals(CollectionType.class, t.getClass());\n+        assertSame(String.class, ((CollectionType) t).getContentType().getRawClass());\n+    }\n+    \n+    public void testMaps()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        // Ok, first: let's test what happens when we pass 'raw' Map:\n+        JavaType t = tf.constructType(HashMap.class);\n+        assertEquals(MapType.class, t.getClass());\n+        assertSame(HashMap.class, t.getRawClass());\n+\n+        // Then explicit construction\n+        t = tf.constructMapType(TreeMap.class, String.class, Integer.class);\n+        assertEquals(MapType.class, t.getClass());\n+        assertSame(String.class, ((MapType) t).getKeyType().getRawClass());\n+        assertSame(Integer.class, ((MapType) t).getContentType().getRawClass());\n+\n+        // And then with TypeReference\n+        t = tf.constructType(new TypeReference<HashMap<String,Integer>>() { });\n+        assertEquals(MapType.class, t.getClass());\n+        assertSame(HashMap.class, t.getRawClass());\n+        MapType mt = (MapType) t;\n+        assertEquals(tf.constructType(String.class), mt.getKeyType());\n+        assertEquals(tf.constructType(Integer.class), mt.getContentType());\n+\n+        t = tf.constructType(new TypeReference<LongValuedMap<Boolean>>() { });\n+        assertEquals(MapType.class, t.getClass());\n+        assertSame(LongValuedMap.class, t.getRawClass());\n+        mt = (MapType) t;\n+        assertEquals(tf.constructType(Boolean.class), mt.getKeyType());\n+        assertEquals(tf.constructType(Long.class), mt.getContentType());\n+    }\n+\n+    public void testIterator()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType t = tf.constructType(new TypeReference<Iterator<String>>() { });\n+        assertEquals(SimpleType.class, t.getClass());\n+        assertSame(Iterator.class, t.getRawClass());\n+        assertEquals(1, t.containedTypeCount());\n+        assertEquals(tf.constructType(String.class), t.containedType(0));\n+        assertNull(t.containedType(1));\n+    }\n+\n+    /**\n+     * Test for verifying that parametric types can be constructed\n+     * programmatically\n+     * \n+     * @since 1.5\n+     */\n+    public void testParametricTypes()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        // first, simple class based\n+        JavaType t = tf.constructParametricType(ArrayList.class, String.class); // ArrayList<String>\n+        assertEquals(CollectionType.class, t.getClass());\n+        JavaType strC = tf.constructType(String.class);\n+        assertEquals(1, t.containedTypeCount());\n+        assertEquals(strC, t.containedType(0));\n+        assertNull(t.containedType(1));\n+\n+        // Then using JavaType\n+        JavaType t2 = tf.constructParametricType(Map.class, strC, t); // Map<String,ArrayList<String>>\n+        // should actually produce a MapType\n+        assertEquals(MapType.class, t2.getClass());\n+        assertEquals(2, t2.containedTypeCount());\n+        assertEquals(strC, t2.containedType(0));\n+        assertEquals(t, t2.containedType(1));\n+        assertNull(t2.containedType(2));\n+\n+        // and then custom generic type as well\n+        JavaType custom = tf.constructParametricType(SingleArgGeneric.class, String.class);\n+        assertEquals(SimpleType.class, custom.getClass());\n+        assertEquals(1, custom.containedTypeCount());\n+        assertEquals(strC, custom.containedType(0));\n+        assertNull(custom.containedType(1));\n+        // should also be able to access variable name:\n+        assertEquals(\"X\", custom.containedTypeName(0));\n+\n+        // And finally, ensure that we can't create invalid combinations\n+        try {\n+            // Maps must take 2 type parameters, not just one\n+            tf.constructParametricType(Map.class, strC);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"Need exactly 2 parameter types for Map types\");\n+        }\n+\n+        try {\n+            // Type only accepts one type param\n+            tf.constructParametricType(SingleArgGeneric.class, strC, strC);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"expected 1 parameters, was given 2\");\n+        }\n+    }\n+\n+    /**\n+     * Test for checking that canonical name handling works ok\n+     * \n+     * @since 1.5\n+     */\n+    public void testCanonicalNames()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType t = tf.constructType(java.util.Calendar.class);\n+        String can = t.toCanonical();\n+        assertEquals(\"java.util.Calendar\", can);\n+        assertEquals(t, TypeFactory.fromCanonical(can));\n+\n+        // Generic maps and collections will default to Object.class if type-erased\n+        t = tf.constructType(java.util.ArrayList.class);\n+        can = t.toCanonical();\n+        assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);\n+        assertEquals(t, TypeFactory.fromCanonical(can));\n+\n+        t = tf.constructType(java.util.TreeMap.class);\n+        can = t.toCanonical();\n+        assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);\n+        assertEquals(t, TypeFactory.fromCanonical(can));\n+\n+        // And then EnumMap (actual use case for us)\n+        t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n+        can = t.toCanonical();\n+        assertEquals(\"java.util.EnumMap<org.codehaus.jackson.map.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n+                can);\n+        assertEquals(t, TypeFactory.fromCanonical(can));\n+        \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests: low-level inheritance resolution\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @since 1.6\n+     */\n+    public void testSuperTypeDetectionClass()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        HierarchicType sub = tf._findSuperTypeChain(MyStringIntMap.class, HashMap.class);\n+        assertNotNull(sub);\n+        assertEquals(2, _countSupers(sub));\n+        assertSame(MyStringIntMap.class, sub.getRawClass());\n+        HierarchicType sup = sub.getSuperType();\n+        assertSame(MyStringXMap.class, sup.getRawClass());\n+        HierarchicType sup2 = sup.getSuperType();\n+        assertSame(HashMap.class, sup2.getRawClass());\n+        assertNull(sup2.getSuperType());\n+    }\n+    \n+    /**\n+     * @since 1.6\n+     */\n+    public void testSuperTypeDetectionInterface()\n+    {\n+        // List first\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        HierarchicType sub = tf._findSuperTypeChain(MyList.class, List.class);\n+        assertNotNull(sub);\n+        assertEquals(2, _countSupers(sub));\n+        assertSame(MyList.class, sub.getRawClass());\n+        HierarchicType sup = sub.getSuperType();\n+        assertSame(IntermediateList.class, sup.getRawClass());\n+        HierarchicType sup2 = sup.getSuperType();\n+        assertSame(List.class, sup2.getRawClass());\n+        assertNull(sup2.getSuperType());\n+        \n+        // Then Map\n+        sub = tf._findSuperTypeChain(MyMap.class, Map.class);\n+        assertNotNull(sub);\n+        assertEquals(2, _countSupers(sub));\n+        assertSame(MyMap.class, sub.getRawClass());\n+        sup = sub.getSuperType();\n+        assertSame(IntermediateMap.class, sup.getRawClass());\n+        sup2 = sup.getSuperType();\n+        assertSame(Map.class, sup2.getRawClass());\n+        assertNull(sup2.getSuperType());\n+    }\n+\n+    /**\n+     * @since 1.6\n+     */\n+    public void testAtomicArrayRefParameterDetection()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(new TypeReference<AtomicReference<long[]>>() { });\n+        HierarchicType sub = tf._findSuperTypeChain(type.getRawClass(), AtomicReference.class);\n+        assertNotNull(sub);\n+        assertEquals(0, _countSupers(sub));\n+        assertTrue(AtomicReference.class.isAssignableFrom(type.getRawClass()));\n+        assertNull(sub.getSuperType());\n+    }\n+\n+    private int _countSupers(HierarchicType t)\n+    {\n+        int depth = 0;\n+        for (HierarchicType sup = t.getSuperType(); sup != null; sup = sup.getSuperType()) {\n+            ++depth;\n+        }\n+        return depth;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests: map/collection type parameter resolution\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @since 1.6\n+     */\n+    public void testMapTypesSimple()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(new TypeReference<Map<String,Boolean>>() { });\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Boolean.class), mapType.getContentType());\n+    }\n+\n+    /**\n+     * @since 1.6\n+     */\n+    public void testMapTypesRaw()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(HashMap.class);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(Object.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Object.class), mapType.getContentType());        \n+    }\n+\n+    /**\n+     * @since 1.6\n+     */\n+    public void testMapTypesAdvanced()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(MyMap.class);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n+\n+        type = tf.constructType(MapInterface.class);\n+        mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n+\n+        type = tf.constructType(MyStringIntMap.class);\n+        mapType = (MapType) type;\n+        assertEquals(tf.constructType(String.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Integer.class), mapType.getContentType());\n+    }\n+\n+    /**\n+     * Specific test to verify that complicate name mangling schemes\n+     * do not fool type resolver\n+     * \n+     * @since 1.6\n+     */\n+    public void testMapTypesSneaky()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(IntLongMap.class);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n+    }    \n+    \n+    /**\n+     * Plus sneaky types may be found via introspection as well.\n+     * \n+     * @since 1.7\n+     */\n+    public void testSneakyFieldTypes() throws Exception\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        Field field = SneakyBean.class.getDeclaredField(\"intMap\");\n+        JavaType type = tf.constructType(field.getGenericType());\n+        assertTrue(type instanceof MapType);\n+        MapType mapType = (MapType) type;\n+        assertEquals(tf.constructType(Integer.class), mapType.getKeyType());\n+        assertEquals(tf.constructType(Long.class), mapType.getContentType());\n+\n+        field = SneakyBean.class.getDeclaredField(\"longList\");\n+        type = tf.constructType(field.getGenericType());\n+        assertTrue(type instanceof CollectionType);\n+        CollectionType collectionType = (CollectionType) type;\n+        assertEquals(tf.constructType(Long.class), collectionType.getContentType());\n+    }    \n+    \n+    /**\n+     * Looks like type handling actually differs for properties, too.\n+     * \n+     * @since 1.7\n+     */\n+    public void testSneakyBeanProperties() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        StringLongMapBean bean = mapper.readValue(\"{\\\"value\\\":{\\\"a\\\":123}}\", StringLongMapBean.class);\n+        assertNotNull(bean);\n+        Map<String,Long> map = bean.value;\n+        assertEquals(1, map.size());\n+        assertEquals(Long.valueOf(123), map.get(\"a\"));\n+\n+        StringListBean bean2 = mapper.readValue(\"{\\\"value\\\":[\\\"...\\\"]}\", StringListBean.class);\n+        assertNotNull(bean2);\n+        List<String> list = bean2.value;\n+        assertSame(GenericList.class, list.getClass());\n+        assertEquals(1, list.size());\n+        assertEquals(\"...\", list.get(0));\n+    }\n+    \n+    public void testAtomicArrayRefParameters()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructType(new TypeReference<AtomicReference<long[]>>() { });\n+        JavaType[] params = tf.findTypeParameters(type, AtomicReference.class);\n+        assertNotNull(params);\n+        assertEquals(1, params.length);\n+        assertEquals(tf.constructType(long[].class), params[0]);\n+    }\n+\n+    public void testSneakySelfRefs() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(new SneakyBean2());\n+        assertEquals(\"{\\\"foobar\\\":null}\", json);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests: construction of \"raw\" types\n+    /**********************************************************\n+     */\n+\n+    public void testRawCollections()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructRawCollectionType(ArrayList.class);\n+        assertTrue(type.isContainerType());\n+        assertEquals(TypeFactory.unknownType(), type.getContentType());\n+\n+        type = tf.constructRawCollectionLikeType(String.class); // class doesn't really matter\n+        assertTrue(type.isCollectionLikeType());\n+        assertEquals(TypeFactory.unknownType(), type.getContentType());\n+    }\n+\n+    public void testRawMaps()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType type = tf.constructRawMapType(HashMap.class);\n+        assertTrue(type.isContainerType());\n+        assertEquals(TypeFactory.unknownType(), type.getKeyType());\n+        assertEquals(TypeFactory.unknownType(), type.getContentType());\n+\n+        type = tf.constructRawMapLikeType(String.class); // class doesn't really matter\n+        assertTrue(type.isMapLikeType());\n+        assertEquals(TypeFactory.unknownType(), type.getKeyType());\n+        assertEquals(TypeFactory.unknownType(), type.getContentType());\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeResolution.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.type.CollectionType;\n+import com.fasterxml.jackson.databind.type.MapType;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+@SuppressWarnings(\"serial\")\n+public class TestTypeResolution extends com.fasterxml.jackson.test.BaseTest\n+{\n+    public static class LongValuedMap<K> extends HashMap<K, Long> { }\n+\n+    static class GenericList<X> extends ArrayList<X> { }\n+    static class GenericList2<Y> extends GenericList<Y> { }\n+\n+    static class LongList extends GenericList2<Long> { }\n+    static class MyLongList<T> extends LongList { }\n+    \n+    public void testMaps()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        JavaType t = tf.constructType(new TypeReference<LongValuedMap<String>>() { });\n+        MapType type = (MapType) t;\n+        assertSame(LongValuedMap.class, type.getRawClass());\n+        assertEquals(tf.constructType(String.class), type.getKeyType());\n+        assertEquals(tf.constructType(Long.class), type.getContentType());        \n+    }\n+\n+    public void testList()\n+    {\n+        JavaType t;\n+\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        t = tf.constructType(new TypeReference<MyLongList<Integer>>() {});\n+        CollectionType type = (CollectionType) t;\n+        assertSame(MyLongList.class, type.getRawClass());\n+        assertEquals(tf.constructType(Long.class), type.getContentType());        \n+\n+        t = tf.constructType(LongList.class);\n+        type = (CollectionType) t;\n+        assertSame(LongList.class, type.getRawClass());\n+        assertEquals(tf.constructType(Long.class), type.getContentType());        \n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/ISO8601DateFormatTest.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.text.DateFormat;\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.util.ISO8601DateFormat;\n+\n+/**\n+ * @see ISO8601DateFormat\n+ */\n+public class ISO8601DateFormatTest extends BaseMapTest\n+{\n+    private ISO8601DateFormat df;\n+    private Date date;\n+\n+    @Override\n+    public void setUp()\n+    {\n+        Calendar cal = new GregorianCalendar(2007, 8 - 1, 13, 19, 51, 23);\n+        cal.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+        cal.set(Calendar.MILLISECOND, 0);\n+        date = cal.getTime();\n+        df = new ISO8601DateFormat();\n+    }\n+\n+    public void format() {\n+        String result = df.format(date);\n+        assertEquals(\"2007-08-13T19:51:23Z\", result);\n+    }\n+\n+    public void parse() throws Exception {\n+        Date result = df.parse(\"2007-08-13T19:51:23Z\");\n+        assertEquals(date, result);\n+    }\n+\n+    public void cloneObject() throws Exception {\n+        DateFormat clone = (DateFormat)df.clone();\n+        assertSame(df, clone);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/ISO8601UtilsTest.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.util.*;\n+\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.util.ISO8601Utils;\n+\n+/**\n+ * @see ISO8601Utils\n+ */\n+public class ISO8601UtilsTest extends BaseMapTest\n+{\n+    private Date date;\n+    private Date dateZeroMillis;\n+\n+    @Override\n+    public void setUp()\n+    {\n+        Calendar cal = new GregorianCalendar(2007, 8 - 1, 13, 19, 51, 23);\n+        cal.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+        cal.set(Calendar.MILLISECOND, 789);\n+        date = cal.getTime();\n+        cal.set(Calendar.MILLISECOND, 0);\n+        dateZeroMillis = cal.getTime();\n+    }\n+\n+    public void testFormat() {\n+        String result = ISO8601Utils.format(date);\n+        assertEquals(\"2007-08-13T19:51:23Z\", result);\n+    }\n+\n+    public void testFormatMillis() {\n+        String result = ISO8601Utils.format(date, true);\n+        assertEquals(\"2007-08-13T19:51:23.789Z\", result);\n+\n+        result = ISO8601Utils.format(date, false);\n+        assertEquals(\"2007-08-13T19:51:23Z\", result);\n+    }\n+\n+    public void testFormatTimeZone() {\n+        String result = ISO8601Utils.format(date, false, TimeZone.getTimeZone(\"GMT+02:00\"));\n+        assertEquals(\"2007-08-13T21:51:23+02:00\", result);\n+        result = ISO8601Utils.format(date, true, TimeZone.getTimeZone(\"GMT+02:00\"));\n+        assertEquals(\"2007-08-13T21:51:23.789+02:00\", result);\n+        result = ISO8601Utils.format(date, true, TimeZone.getTimeZone(\"GMT\"));\n+        assertEquals(\"2007-08-13T19:51:23.789Z\", result);\n+    }\n+\n+    public void testParse() {\n+        Date d = ISO8601Utils.parse(\"2007-08-13T19:51:23.789Z\");\n+        assertEquals(date, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T19:51:23Z\");\n+        assertEquals(dateZeroMillis, d);\n+\n+        d = ISO8601Utils.parse(\"2007-08-13T21:51:23.789+02:00\");\n+        assertEquals(date, d);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/TestClassUtil.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.util.*;\n+\n+import static org.junit.Assert.*;\n+\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+public class TestClassUtil\n+    extends BaseMapTest\n+{\n+    /*\n+    /**********************************************************\n+    /* Test classes, enums\n+    /**********************************************************\n+     */\n+\n+    /* Test classes and interfaces needed for testing class util\n+     * methods\n+     */\n+    static abstract class BaseClass implements Comparable<BaseClass>,\n+        BaseInt\n+    {\n+        BaseClass(String str) { }\n+    }\n+\n+    interface BaseInt { }\n+\n+    interface SubInt extends BaseInt { }\n+\n+    enum TestEnum { A; }\n+\n+    abstract class InnerNonStatic { }\n+\n+    static class Inner {\n+        protected Inner() {\n+            throw new IllegalStateException(\"test\");\n+        }\n+    }\n+\n+    static abstract class SubClass\n+        extends BaseClass\n+        implements SubInt {\n+        SubClass() { super(\"x\"); }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    public void testSuperTypes()\n+    {\n+        Collection<Class<?>> result = ClassUtil.findSuperTypes(SubClass.class, null);\n+        Class<?>[] classes = result.toArray(new Class<?>[result.size()]);\n+        Class<?>[] exp = new Class[] {\n+            SubInt.class, BaseInt.class,\n+            BaseClass.class,\n+            Comparable.class\n+        };\n+        assertArrayEquals(exp, classes);\n+    }\n+\n+    public void testSuperInterfaces()\n+    {\n+        Collection<Class<?>> result = ClassUtil.findSuperTypes(SubInt.class, null);\n+        Class<?>[] classes = result.toArray(new Class<?>[result.size()]);\n+        Class<?>[] exp = new Class[] {\n+            BaseInt.class\n+        };\n+        assertArrayEquals(exp, classes);\n+    }\n+    \n+    public void testIsConcrete()\n+    {\n+        assertTrue(ClassUtil.isConcrete(getClass()));\n+        assertFalse(ClassUtil.isConcrete(BaseClass.class));\n+        assertFalse(ClassUtil.isConcrete(BaseInt.class));\n+    }\n+\n+    public void testCanBeABeanType()\n+    {\n+        assertEquals(\"annotation\", ClassUtil.canBeABeanType(java.lang.annotation.Retention.class));\n+        assertEquals(\"array\", ClassUtil.canBeABeanType(String[].class));\n+        assertEquals(\"enum\", ClassUtil.canBeABeanType(TestEnum.class));\n+        assertEquals(\"primitive\", ClassUtil.canBeABeanType(Integer.TYPE));\n+        assertNull(ClassUtil.canBeABeanType(Integer.class));\n+\n+        assertEquals(\"non-static member class\", ClassUtil.isLocalType(InnerNonStatic.class, false));\n+        assertNull(ClassUtil.isLocalType(Integer.class, false));\n+    }\n+\n+    public void testExceptionHelpers()\n+    {\n+        RuntimeException e = new RuntimeException(\"test\");\n+        RuntimeException wrapper = new RuntimeException(e);\n+\n+        assertSame(e, ClassUtil.getRootCause(wrapper));\n+\n+        try {\n+            ClassUtil.throwAsIAE(e);\n+            fail(\"Shouldn't get this far\");\n+        } catch (RuntimeException e2) {\n+            assertSame(e, e2);\n+        }\n+\n+        try {\n+            ClassUtil.unwrapAndThrowAsIAE(wrapper);\n+            fail(\"Shouldn't get this far\");\n+        } catch (RuntimeException e2) {\n+            assertSame(e, e2);\n+        }\n+    }\n+\n+    public void testFailedCreateInstance()\n+    {\n+        try {\n+            ClassUtil.createInstance(BaseClass.class, true);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"has no default\");\n+        }\n+\n+        try {\n+            // false means ctor would need to be public\n+            ClassUtil.createInstance(Inner.class, false);\n+        } catch (IllegalArgumentException e) {\n+            verifyException(e, \"is not accessible\");\n+        }\n+\n+        // and finally, check that we'll get expected exception...\n+        try {\n+            ClassUtil.createInstance(Inner.class, true);\n+        } catch (IllegalStateException e) {\n+            verifyException(e, \"test\");\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/TestObjectBuffer.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.test.BaseTest;\n+\n+public class TestObjectBuffer\n+    extends BaseTest\n+{\n+    /**\n+     * First a test that treats results as plain old Object[]\n+     */\n+    public void testUntyped()\n+    {\n+        _testObjectBuffer(null);\n+    }\n+\n+    public void testTyped()\n+    {\n+        _testObjectBuffer(Integer.class);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    private void _testObjectBuffer(Class<?> clz)\n+    {\n+        int[] SIZES = new int[] {\n+            3, 19, 99, 1007, 79000, 256001\n+        };\n+\n+        // Let's loop separately for reused instance, new instance\n+        for (int reuse = 0; reuse < 2; ++reuse) {\n+            ObjectBuffer buf = (reuse == 0) ? null : new ObjectBuffer();\n+\n+            // then distinct sizes\n+            for (int sizeIndex = 0; sizeIndex < SIZES.length; ++sizeIndex) {\n+                int size = SIZES[sizeIndex];\n+                Random r = new Random(size);\n+                ObjectBuffer thisBuf = (buf == null) ? new ObjectBuffer() : buf;\n+                Object[] chunk = thisBuf.resetAndStart();\n+                int ix = 0;\n+\n+                for (int i = 0; i < size; ++i) {\n+                    if (ix >= chunk.length) {\n+                        chunk = thisBuf.appendCompletedChunk(chunk);\n+                        ix = 0;\n+                    }\n+                    chunk[ix++] = Integer.valueOf(r.nextInt());\n+                }\n+\n+                Object[] result;\n+                \n+                if (clz == null) {\n+                    result = thisBuf.completeAndClearBuffer(chunk, ix);\n+                } else {\n+                    result = thisBuf.completeAndClearBuffer(chunk, ix, clz);\n+                }\n+                assertEquals(size, result.length);\n+\n+                r = new Random(size);\n+                for (int i = 0; i < size; ++i) {\n+                    assertEquals(r.nextInt(), ((Integer) result[i]).intValue());\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.io.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+public class TestTokenBuffer extends com.fasterxml.jackson.test.BaseTest\n+{\n+    /**\n+     * Test writing of individual simple values\n+     */\n+    public void testSimpleWrites() throws IOException\n+    {\n+        TokenBuffer buf = new TokenBuffer(null); // no ObjectCodec\n+\n+        // First, with empty buffer\n+        JsonParser jp = buf.asParser();\n+        assertNull(jp.getCurrentToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // Then with simple text\n+        buf.writeString(\"abc\");\n+\n+        // First, simple text\n+        jp = buf.asParser();\n+        assertNull(jp.getCurrentToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(\"abc\", jp.getText());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // Then, let's append at root level\n+        buf.writeNumber(13);\n+        jp = buf.asParser();\n+        assertNull(jp.getCurrentToken());\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+        assertEquals(13, jp.getIntValue());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleArray() throws IOException\n+    {\n+        TokenBuffer buf = new TokenBuffer(null); // no ObjectCodec\n+\n+        // First, empty array\n+        assertTrue(buf.getOutputContext().inRoot());\n+        buf.writeStartArray();\n+        assertTrue(buf.getOutputContext().inArray());\n+        buf.writeEndArray();\n+        assertTrue(buf.getOutputContext().inRoot());\n+\n+        JsonParser jp = buf.asParser();\n+        assertNull(jp.getCurrentToken());\n+        assertTrue(jp.getParsingContext().inRoot());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertTrue(jp.getParsingContext().inArray());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertTrue(jp.getParsingContext().inRoot());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // Then one with simple contents\n+        buf = new TokenBuffer(null);\n+        buf.writeStartArray();\n+        buf.writeBoolean(true);\n+        buf.writeNull();\n+        buf.writeEndArray();\n+        jp = buf.asParser();\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.VALUE_TRUE, jp.nextToken());\n+        assertTrue(jp.getBooleanValue());\n+        assertToken(JsonToken.VALUE_NULL, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // And finally, with array-in-array\n+        buf = new TokenBuffer(null);\n+        buf.writeStartArray();\n+        buf.writeStartArray();\n+        buf.writeBinary(new byte[3]);\n+        buf.writeEndArray();\n+        buf.writeEndArray();\n+        jp = buf.asParser();\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken());\n+        // TokenBuffer exposes it as embedded object...\n+        assertToken(JsonToken.VALUE_EMBEDDED_OBJECT, jp.nextToken());\n+        Object ob = jp.getEmbeddedObject();\n+        assertNotNull(ob);\n+        assertTrue(ob instanceof byte[]);\n+        assertEquals(3, ((byte[]) ob).length);\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleObject() throws IOException\n+    {\n+        TokenBuffer buf = new TokenBuffer(null);\n+\n+        // First, empty JSON Object\n+        assertTrue(buf.getOutputContext().inRoot());\n+        buf.writeStartObject();\n+        assertTrue(buf.getOutputContext().inObject());\n+        buf.writeEndObject();\n+        assertTrue(buf.getOutputContext().inRoot());\n+\n+        JsonParser jp = buf.asParser();\n+        assertNull(jp.getCurrentToken());\n+        assertTrue(jp.getParsingContext().inRoot());\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertTrue(jp.getParsingContext().inObject());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        assertTrue(jp.getParsingContext().inRoot());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+\n+        // Then one with simple contents\n+        buf = new TokenBuffer(null);\n+        buf.writeStartObject();\n+        buf.writeNumberField(\"num\", 1.25);\n+        buf.writeEndObject();\n+\n+        jp = buf.asParser();\n+        assertNull(jp.getCurrentToken());\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        assertNull(jp.getCurrentName());\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n+        assertEquals(\"num\", jp.getCurrentName());\n+        assertToken(JsonToken.VALUE_NUMBER_FLOAT, jp.nextToken());\n+        assertEquals(1.25, jp.getDoubleValue());\n+        // should still have access to name\n+        assertEquals(\"num\", jp.getCurrentName());\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken());\n+        // but not any more\n+        assertNull(jp.getCurrentName());\n+        assertNull(jp.nextToken());\n+        jp.close();\n+    }\n+\n+    /**\n+     * Verify handling of that \"standard\" test document (from JSON\n+     * specification)\n+     */\n+    public void testWithJSONSampleDoc() throws Exception\n+    {\n+        // First, copy events from known good source (StringReader)\n+        JsonParser jp = createParserUsingReader(SAMPLE_DOC_JSON_SPEC);\n+        TokenBuffer tb = new TokenBuffer(null);\n+        while (jp.nextToken() != null) {\n+            tb.copyCurrentEvent(jp);\n+        }\n+\n+        // And then request verification; first structure only:\n+        verifyJsonSpecSampleDoc(tb.asParser(), false);\n+\n+        // then content check too:\n+        verifyJsonSpecSampleDoc(tb.asParser(), true);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestAbstractParentChild.java\n+package com.fasterxml.jackson.failing;\n+\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.Id;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Currently (1.8) parent/child dependencies do not work in\n+ * combination with abstract types; they should, but fixing this\n+ * require major changes to handling of both features.\n+ */\n+public class TestAbstractParentChild extends BaseMapTest\n+{\n+    @JsonTypeInfo(use=Id.NAME)\n+    @JsonSubTypes({@JsonSubTypes.Type(ConcreteNode.class)})\n+    static abstract class AbstractNode\n+    {\n+        public String id;\n+        \n+        @JsonManagedReference public AbstractNode next;\n+        @JsonBackReference public AbstractNode prev;\n+    }\n+\n+    @JsonTypeName(\"concrete\")\n+    static class ConcreteNode extends AbstractNode {\n+        public ConcreteNode() { }\n+        public ConcreteNode(String id) { this.id = id; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    /* 22-Sep-2010, tatu: This is for [JACKSON-368]. Easy to reproduce the issue,\n+     *   but alas not nearly as easy to resolve. Problem is that AbstractDeserializer\n+     *   has little knowledge of actual type, and so linkage can not be made statically.\n+     */\n+    public void testAbstract() throws Exception\n+    {\n+        AbstractNode parent = new ConcreteNode(\"p\");\n+        AbstractNode child = new ConcreteNode(\"c\");\n+        parent.next = child;\n+        child.prev = parent;\n+\n+        // serialization ought to be ok\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(parent);\n+\n+        AbstractNode root = null;\n+        try {\n+            root = mapper.readValue(json, AbstractNode.class);\n+        } catch  (IllegalArgumentException e) {\n+            fail(\"Did not expect an exception; got: \"+e.getMessage());\n+        }\n+        assertEquals(ConcreteNode.class, root.getClass());\n+        assertEquals(\"p\", root.id);\n+        assertNull(root.prev);\n+        AbstractNode leaf = root.next;\n+        assertNotNull(leaf);\n+        assertEquals(\"c\", leaf.id);\n+        assertSame(parent, leaf.prev);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestDelegatingCreators.java\n+package com.fasterxml.jackson.failing;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JacksonInject;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.InjectableValues;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestDelegatingCreators extends BaseMapTest\n+{\n+    // for [JACKSON-711]; should allow delegate-based one(s) too\n+    static class CtorBean711\n+    {\n+        protected String name;\n+        protected int age;\n+        \n+        @JsonCreator\n+        public CtorBean711(@JacksonInject String n, int a)\n+        {\n+            name = n;\n+            age = a;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    // As per [JACKSON-711]: should also work with delegate model (single non-annotated arg)\n+    public void testWithCtorAndDelegate() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setInjectableValues(new InjectableValues.Std()\n+            .addValue(String.class, \"Pooka\")\n+            );\n+        CtorBean711 bean = null;\n+        try {\n+            bean = mapper.readValue(\"38\", CtorBean711.class);\n+        } catch (JsonMappingException e) {\n+            fail(\"Did not expect problems, got: \"+e.getMessage());\n+        }\n+        assertEquals(38, bean.age);\n+        assertEquals(\"Pooka\", bean.name);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestSerializationFiltering.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.ser.impl.SimpleBeanPropertyFilter;\n+import com.fasterxml.jackson.databind.ser.impl.SimpleFilterProvider;\n+\n+/**\n+ * Currently (1.8) generic filtering does not work for \"any getter\": it should,\n+ * ideally, so here's the test.\n+ */\n+public class TestSerializationFiltering extends BaseMapTest\n+{\n+    @JsonFilter(\"anyFilter\")\n+    public static class AnyBean\n+    {\n+        private Map<String, String> properties = new HashMap<String, String>();\n+        {\n+          properties.put(\"a\", \"1\");\n+          properties.put(\"b\", \"2\");\n+        }\n+\n+        @JsonAnyGetter\n+        public Map<String, String> anyProperties()\n+        {\n+          return properties;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    // should also work for @JsonAnyGetter, as per [JACKSON-516]\n+    public void testAnyGetterFiltering() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        FilterProvider prov = new SimpleFilterProvider().addFilter(\"anyFilter\",\n+                SimpleBeanPropertyFilter.filterOutAllExcept(\"b\"));\n+        assertEquals(\"{\\\"a\\\":\\\"1\\\"}\", mapper.writer(prov).writeValueAsString(new AnyBean()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/test/BaseTest.java\n+package com.fasterxml.jackson.test;\n+\n+import java.io.*;\n+import java.util.Arrays;\n+\n+import junit.framework.TestCase;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+//import static org.junit.Assert.*;\n+\n+public abstract class BaseTest\n+    extends TestCase\n+{\n+    /*\n+    /**********************************************************\n+    /* Some sample documents:\n+    /**********************************************************\n+     */\n+\n+    protected final static int SAMPLE_SPEC_VALUE_WIDTH = 800;\n+    protected final static int SAMPLE_SPEC_VALUE_HEIGHT = 600;\n+    protected final static String SAMPLE_SPEC_VALUE_TITLE = \"View from 15th Floor\";\n+    protected final static String SAMPLE_SPEC_VALUE_TN_URL = \"http://www.example.com/image/481989943\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_HEIGHT = 125;\n+    protected final static String SAMPLE_SPEC_VALUE_TN_WIDTH = \"100\";\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID1 = 116;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID2 = 943;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID3 = 234;\n+    protected final static int SAMPLE_SPEC_VALUE_TN_ID4 = 38793;\n+\n+    protected final static String SAMPLE_DOC_JSON_SPEC = \n+        \"{\\n\"\n+        +\"  \\\"Image\\\" : {\\n\"\n+        +\"    \\\"Width\\\" : \"+SAMPLE_SPEC_VALUE_WIDTH+\",\\n\"\n+        +\"    \\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_HEIGHT+\",\"\n+        +\"\\\"Title\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TITLE+\"\\\",\\n\"\n+        +\"    \\\"Thumbnail\\\" : {\\n\"\n+        +\"      \\\"Url\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_URL+\"\\\",\\n\"\n+        +\"\\\"Height\\\" : \"+SAMPLE_SPEC_VALUE_TN_HEIGHT+\",\\n\"\n+        +\"      \\\"Width\\\" : \\\"\"+SAMPLE_SPEC_VALUE_TN_WIDTH+\"\\\"\\n\"\n+        +\"    },\\n\"\n+        +\"    \\\"IDs\\\" : [\"+SAMPLE_SPEC_VALUE_TN_ID1+\",\"+SAMPLE_SPEC_VALUE_TN_ID2+\",\"+SAMPLE_SPEC_VALUE_TN_ID3+\",\"+SAMPLE_SPEC_VALUE_TN_ID4+\"]\\n\"\n+        +\"  }\"\n+        +\"}\"\n+        ;\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes (beans)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Sample class from Jackson tutorial (\"JacksonInFiveMinutes\")\n+     */\n+    protected static class FiveMinuteUser {\n+        public enum Gender { MALE, FEMALE };\n+\n+        public static class Name\n+        {\n+          private String _first, _last;\n+\n+          public Name() { }\n+          public Name(String f, String l) {\n+              _first = f;\n+              _last = l;\n+          }\n+          \n+          public String getFirst() { return _first; }\n+          public String getLast() { return _last; }\n+\n+          public void setFirst(String s) { _first = s; }\n+          public void setLast(String s) { _last = s; }\n+\n+          @Override\n+          public boolean equals(Object o)\n+          {\n+              if (o == this) return true;\n+              if (o == null || o.getClass() != getClass()) return false;\n+              Name other = (Name) o;\n+              return _first.equals(other._first) && _last.equals(other._last); \n+          }\n+        }\n+\n+        private Gender _gender;\n+        private Name _name;\n+        private boolean _isVerified;\n+        private byte[] _userImage;\n+\n+        public FiveMinuteUser() { }\n+\n+        public FiveMinuteUser(String first, String last, boolean verified, Gender g, byte[] data)\n+        {\n+            _name = new Name(first, last);\n+            _isVerified = verified;\n+            _gender = g;\n+            _userImage = data;\n+        }\n+        \n+        public Name getName() { return _name; }\n+        public boolean isVerified() { return _isVerified; }\n+        public Gender getGender() { return _gender; }\n+        public byte[] getUserImage() { return _userImage; }\n+\n+        public void setName(Name n) { _name = n; }\n+        public void setVerified(boolean b) { _isVerified = b; }\n+        public void setGender(Gender g) { _gender = g; }\n+        public void setUserImage(byte[] b) { _userImage = b; }\n+\n+        @Override\n+        public boolean equals(Object o)\n+        {\n+            if (o == this) return true;\n+            if (o == null || o.getClass() != getClass()) return false;\n+            FiveMinuteUser other = (FiveMinuteUser) o;\n+            if (_isVerified != other._isVerified) return false;\n+            if (_gender != other._gender) return false; \n+            if (!_name.equals(other._name)) return false;\n+            byte[] otherImage = other._userImage;\n+            if (otherImage.length != _userImage.length) return false;\n+            for (int i = 0, len = _userImage.length; i < len; ++i) {\n+                if (_userImage[i] != otherImage[i]) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* High-level helpers\n+    /**********************************************************\n+     */\n+\n+    protected void verifyJsonSpecSampleDoc(JsonParser jp, boolean verifyContents)\n+        throws IOException\n+    {\n+        verifyJsonSpecSampleDoc(jp, verifyContents, true);\n+    }\n+\n+    protected void verifyJsonSpecSampleDoc(JsonParser jp, boolean verifyContents,\n+            boolean requireNumbers)\n+        throws IOException\n+    {\n+        if (!jp.hasCurrentToken()) {\n+            jp.nextToken();\n+        }\n+        assertToken(JsonToken.START_OBJECT, jp.getCurrentToken()); // main object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Image'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Image\");\n+        }\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Width\");\n+        }\n+\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_WIDTH);\n+        }\n+\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Height\");\n+        }\n+\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_HEIGHT);\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Title'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Title\");\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(jp));\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Thumbnail'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Thumbnail\");\n+        }\n+\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Url'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Url\");\n+        }\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (verifyContents) {\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(jp));\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Height\");\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers);\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_HEIGHT);\n+        }\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n+        if (verifyContents) {\n+            verifyFieldName(jp, \"Width\");\n+        }\n+        // Width value is actually a String in the example\n+        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n+        if (verifyContents) {\n+            assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(jp));\n+        }\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'IDs'\n+        assertToken(JsonToken.START_ARRAY, jp.nextToken()); // 'ids' array\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[0]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID1);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[1]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID2);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[2]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID3);\n+        }\n+        verifyIntToken(jp.nextToken(), requireNumbers); // ids[3]\n+        if (verifyContents) {\n+            verifyIntValue(jp, SAMPLE_SPEC_VALUE_TN_ID4);\n+        }\n+        assertToken(JsonToken.END_ARRAY, jp.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // main object\n+    }\n+\n+    private void verifyIntToken(JsonToken t, boolean requireNumbers)\n+    {\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return;\n+        }\n+        if (requireNumbers) { // to get error\n+            assertToken(JsonToken.VALUE_NUMBER_INT, t);\n+        }\n+        // if not number, must be String\n+        if (t != JsonToken.VALUE_STRING) {\n+            fail(\"Expected INT or STRING value, got \"+t);\n+        }\n+    }\n+    \n+    protected void verifyFieldName(JsonParser jp, String expName)\n+        throws IOException\n+    {\n+        assertEquals(expName, jp.getText());\n+        assertEquals(expName, jp.getCurrentName());\n+    }\n+\n+    protected void verifyIntValue(JsonParser jp, long expValue)\n+        throws IOException\n+    {\n+        // First, via textual\n+        assertEquals(String.valueOf(expValue), jp.getText());\n+    }\n+\n+    /**\n+     * Method that checks whether Unit tests appear to run from Ant build\n+     * scripts.\n+     * \n+     * @since 1.6\n+     */\n+    protected static boolean runsFromAnt() {\n+        return \"true\".equals(System.getProperty(\"FROM_ANT\"));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Parser/generator construction\n+    /**********************************************************\n+     */\n+\n+    protected JsonParser createParserUsingReader(String input)\n+        throws IOException, JsonParseException\n+    {\n+        return createParserUsingReader(new JsonFactory(), input);\n+    }\n+\n+    protected JsonParser createParserUsingReader(JsonFactory f, String input)\n+        throws IOException, JsonParseException\n+    {\n+        return f.createJsonParser(new StringReader(input));\n+    }\n+\n+    protected JsonParser createParserUsingStream(String input, String encoding)\n+        throws IOException, JsonParseException\n+    {\n+        return createParserUsingStream(new JsonFactory(), input, encoding);\n+    }\n+\n+    protected JsonParser createParserUsingStream(JsonFactory f,\n+                                                 String input, String encoding)\n+        throws IOException, JsonParseException\n+    {\n+\n+        /* 23-Apr-2008, tatus: UTF-32 is not supported by JDK, have to\n+         *   use our own codec too (which is not optimal since there's\n+         *   a chance both encoder and decoder might have bugs, but ones\n+         *   that cancel each other out or such)\n+         */\n+        byte[] data;\n+        if (encoding.equalsIgnoreCase(\"UTF-32\")) {\n+            data = encodeInUTF32BE(input);\n+        } else {\n+            data = input.getBytes(encoding);\n+        }\n+        InputStream is = new ByteArrayInputStream(data);\n+        return f.createJsonParser(is);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Additional assertion methods\n+    /**********************************************************\n+     */\n+\n+    protected void assertToken(JsonToken expToken, JsonToken actToken)\n+    {\n+        if (actToken != expToken) {\n+            fail(\"Expected token \"+expToken+\", current token \"+actToken);\n+        }\n+    }\n+\n+    protected void assertToken(JsonToken expToken, JsonParser jp)\n+    {\n+        assertToken(expToken, jp.getCurrentToken());\n+    }\n+\n+    protected void assertType(Object ob, Class<?> expType)\n+    {\n+        if (ob == null) {\n+            fail(\"Expected an object of type \"+expType.getName()+\", got null\");\n+        }\n+        Class<?> cls = ob.getClass();\n+        if (!expType.isAssignableFrom(cls)) {\n+            fail(\"Expected type \"+expType.getName()+\", got \"+cls.getName());\n+        }\n+    }\n+\n+    protected void verifyException(Throwable e, String... matches)\n+    {\n+        String msg = e.getMessage();\n+        String lmsg = (msg == null) ? \"\" : msg.toLowerCase();\n+        for (String match : matches) {\n+            String lmatch = match.toLowerCase();\n+            if (lmsg.indexOf(lmatch) >= 0) {\n+                return;\n+            }\n+        }\n+        fail(\"Expected an exception with one of substrings (\"+Arrays.asList(matches)+\"): got one with message \\\"\"+msg+\"\\\"\");\n+    }\n+\n+    /**\n+     * Method that gets textual contents of the current token using\n+     * available methods, and ensures results are consistent, before\n+     * returning them\n+     */\n+    protected String getAndVerifyText(JsonParser jp)\n+        throws IOException, JsonParseException\n+    {\n+        // Ok, let's verify other accessors\n+        int actLen = jp.getTextLength();\n+        char[] ch = jp.getTextCharacters();\n+        String str2 = new String(ch, jp.getTextOffset(), actLen);\n+        String str = jp.getText();\n+\n+        if (str.length() !=  actLen) {\n+            fail(\"Internal problem (jp.token == \"+jp.getCurrentToken()+\"): jp.getText().length() ['\"+str+\"'] == \"+str.length()+\"; jp.getTextLength() == \"+actLen);\n+        }\n+        assertEquals(\"String access via getText(), getTextXxx() must be the same\", str, str2);\n+\n+        return str;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* And other helpers\n+    /**********************************************************\n+     */\n+\n+    protected byte[] encodeInUTF32BE(String input)\n+    {\n+        int len = input.length();\n+        byte[] result = new byte[len * 4];\n+        int ptr = 0;\n+        for (int i = 0; i < len; ++i, ptr += 4) {\n+            char c = input.charAt(i);\n+            result[ptr] = result[ptr+1] = (byte) 0;\n+            result[ptr+2] = (byte) (c >> 8);\n+            result[ptr+3] = (byte) c;\n+        }\n+        return result;\n+    }\n+\n+    public String quote(String str) {\n+        return '\"'+str+'\"';\n+    }\n+}", "timestamp": 1324715213, "metainfo": ""}