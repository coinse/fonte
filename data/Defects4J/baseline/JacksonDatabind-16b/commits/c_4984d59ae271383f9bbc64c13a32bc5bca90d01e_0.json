{"sha": "4984d59ae271383f9bbc64c13a32bc5bca90d01e", "log": "Work on [Issue#87], delegating serializer", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n          *    information.\n          */\n         //ObjectNode o = createSchemaNode(\"array\", true);\n-        JsonArrayFormatVisitor arrayVisitor = \n-        \t\tvisitor.expectArrayFormat(typeHint);\n+        JsonArrayFormatVisitor arrayVisitor = visitor.expectArrayFormat(typeHint);\n         JavaType contentType = null;\n         if (typeHint != null) {\n             contentType = typeHint.getContentType();\n-            if (contentType == null) { // could still be parametrized (Iterators)\n+            if (contentType == null) { // could still be parameterized (Iterators)\n+                // 30-Sep-2012, tatu: This is wrong, should use TypeFactory... but it is alas\n+                //    not being passed (oversight)\n                 if (typeHint instanceof ParameterizedType) {\n                     Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();\n                     if (typeArgs.length == 1) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n     \tJsonObjectFormatVisitor objectVisitor = visitor.expectObjectFormat(typeHint);\n  \n         if (_propertyFilterId != null) {\n-        \ttry {\n-        \t\tBeanPropertyFilter filter = findFilter(visitor.getProvider());\n-\t\t\t\tfor (int i = 0; i < _props.length; i++) {\n-\t\t            BeanPropertyWriter prop = _props[i];\n-\t\t            filter.depositSchemaProperty(prop, objectVisitor, visitor.getProvider());\n-\t\t        }\n-\t\t\t\treturn;\n-\t\t\t} catch (JsonMappingException e) {\n-\t\t\t\t// TODO Auto-generated catch block\n-\n-\t\t\t}\n+            try {\n+                BeanPropertyFilter filter = findFilter(visitor.getProvider());\n+                for (int i = 0; i < _props.length; i++) {\n+                    BeanPropertyWriter prop = _props[i];\n+                    filter.depositSchemaProperty(prop, objectVisitor, visitor.getProvider());\n+                }\n+                return;\n+            } catch (JsonMappingException e) {\n+                throw new IllegalStateException(\"Internal error: \"+e.getMessage(), e);\n+            }\n         } \n         \t\t\n         for (int i = 0; i < _props.length; i++) {\n             BeanPropertyWriter prop = _props[i];\n-//            JavaType propType = prop.getSerializationType();\n             BeanSerializerBase.depositSchemaProperty(prop, objectVisitor);\n         }\n     }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdDelegatingSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitable;\n+import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Serializer implementation where given Java type is first converted\n+ * (by implemenetation sub-class provides) into an intermediate\n+ * \"delegate type\", and then serialized by Jackson.\n+ * Note that although types may be related, they must not be same; trying\n+ * to do this will result in an exception.\n+ *\n+ * @param <T> Java type being serialized and that is first converted into\n+ *   delegate type <code>DT</code>\n+ * @param <DT> Delegate type, intermediate into which sub-class converts\n+ *   Java type <code>T</code>, and that Jackson serializes using standard\n+ *   serializer of that type\n+ * \n+ * @since 2.1\n+ */\n+public abstract class StdDelegatingSerializer<T,DT>\n+    extends StdSerializer<T>\n+    implements ContextualSerializer,\n+        JsonFormatVisitable, SchemaAware\n+{\n+    /**\n+     * Fully resolved delegate type, with generic information if any available.\n+     */\n+    protected final JavaType _delegateType;\n+    \n+    /**\n+     * Underlying serializer for type <code>T<.code>.\n+     */\n+    protected final JsonSerializer<Object> _delegateSerializer;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public StdDelegatingSerializer() {\n+        super(Object.class, false);\n+        _delegateType = null;\n+        _delegateSerializer = null;\n+    }\n+\n+    public StdDelegatingSerializer(Class<T> cls) {\n+        super(cls);\n+        _delegateType = null;\n+        _delegateSerializer = null;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    protected StdDelegatingSerializer(JavaType delegateType,\n+            JsonSerializer<?> delegateSerializer)\n+    {\n+        super(delegateType);\n+        _delegateType = delegateType;\n+        _delegateSerializer = (JsonSerializer<Object>) delegateSerializer;\n+    }\n+\n+    /**\n+     * Method that sub-classes have to implement for creating the actual\n+     * serializer instance, once all delegating information has been\n+     * collected: typically simply calls a constructor.\n+     */\n+    protected abstract JsonSerializer<?> withDelegate(JavaType delegateType,\n+            JsonSerializer<?> delegateSerializer);\n+    \n+    // @Override\n+    public JsonSerializer<?> createContextual(SerializerProvider provider, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // First: figure out what is the fully generic delegate type:\n+        TypeFactory tf = provider.getTypeFactory();\n+        JavaType implType = tf.constructType(getClass());\n+        JavaType[] params = tf.findTypeParameters(implType, StdDelegatingSerializer.class);\n+        if (params == null || params.length != 2) {\n+            throw new JsonMappingException(\"Could not determine StdDelegatingSerializer parameterization for \"\n+                    +implType);\n+        }\n+        // and then we can find serializer to delegate to, construct a new instance:\n+        JavaType delegateType = params[1];\n+        return withDelegate(delegateType, provider.findValueSerializer(delegateType, property));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for sub-class to implement, used for converting given\n+     * value into delegate value, which is then serialized by standard\n+     * Jackson serializer.\n+     * \n+     * @param value Property value tyo serializer\n+     * @param provider Contextual provider to use\n+     * \n+     * @return Delegate value to serialize\n+     */\n+    public abstract DT convert(T value, SerializerProvider provider) \n+        throws JsonMappingException;\n+\n+    @Override\n+    public void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        DT delegateValue = convert(value, provider);\n+        _delegateSerializer.serialize(delegateValue, jgen, provider);\n+    }\n+\n+    @Override\n+    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException\n+    {\n+        DT delegateValue = convert(value, provider);\n+        _delegateSerializer.serializeWithType(delegateValue, jgen, provider, typeSer);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Schema functionality\n+    /**********************************************************\n+     */\n+    \n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        if (_delegateSerializer instanceof SchemaAware) {\n+            return ((SchemaAware) _delegateSerializer).getSchema(provider, typeHint);\n+        }\n+        return super.getSchema(provider, typeHint);\n+    }\n+\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint,\n+        boolean isOptional) throws JsonMappingException\n+    {\n+        if (_delegateSerializer instanceof SchemaAware) {\n+            return ((SchemaAware) _delegateSerializer).getSchema(provider, typeHint, isOptional);\n+        }\n+        return super.getSchema(provider, typeHint);\n+    }\n+\n+    public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+    {\n+        if (_delegateSerializer instanceof JsonFormatVisitable) {\n+            ((JsonFormatVisitable) _delegateSerializer).acceptJsonFormatVisitor(visitor, typeHint);\n+            return;\n+        }\n+        super.acceptJsonFormatVisitor(visitor, typeHint);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n      */\n     \n     @Override\n-    public final Class<T> handledType() { return _handledType; }\n+    public Class<T> handledType() { return _handledType; }\n \n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCustomSerializers.java\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.databind.ser.std.CollectionSerializer;\n+import com.fasterxml.jackson.databind.ser.std.StdDelegatingSerializer;\n \n /**\n  * Test for verifying [JACKSON-238]\n     \n     @JsonSerialize(using = ElementSerializer.class)\n     public static class ElementMixin {}\n+\n+    public static class Immutable {\n+        protected int x() { return 3; }\n+        protected int y() { return 7; }\n+    }\n+\n+    public static class ImmutableSerializer\n+        extends StdDelegatingSerializer<Immutable, Map<String,Integer>>\n+    {\n+        public ImmutableSerializer() { super(Immutable.class); }\n+        protected ImmutableSerializer(JavaType delegateType, JsonSerializer<?> delegateSerializer) {\n+            super(delegateType, delegateSerializer);\n+        }\n+\n+        @Override\n+        protected JsonSerializer<?> withDelegate(JavaType delegateType, JsonSerializer<?> delegateSerializer) {\n+            return new ImmutableSerializer(delegateType, delegateSerializer);\n+        }\n+\n+        @Override\n+        public Map<String, Integer> convert(Immutable value, SerializerProvider provider)\n+                throws JsonMappingException {\n+            HashMap<String,Integer> map = new LinkedHashMap<String,Integer>();\n+            map.put(\"x\", value.x());\n+            map.put(\"y\", value.y());\n+            return map;\n+        }\n+    }\n \n     /*\n     /**********************************************************\n         mapper.registerModule(module);\n         assertEquals(\"null\", mapper.writeValueAsString(new ArrayList<Object>()));\n     }\n+\n+    // [Issue#87]: delegating serializer\n+    public void testDelegating() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule(\"test\", Version.unknownVersion());\n+        module.addSerializer(Immutable.class, new ImmutableSerializer());\n+        mapper.registerModule(module);\n+        assertEquals(\"{\\\"x\\\":3,\\\"y\\\":7}\", mapper.writeValueAsString(new Immutable()));\n+    }\n }", "timestamp": 1349053479, "metainfo": ""}