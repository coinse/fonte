{"sha": "ff8c08cb7cbc88c5fee8f736d33b3b2baaf9dd68", "log": "Start work on [JACKSON-439]; serialization-side done", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n import java.lang.annotation.Annotation;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.core.Versioned;\n     public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n         return null;\n     }\n+\n+    /**\n+     * Method for finding format annotations for given member.\n+     * Return value is typically used by serializers and/or\n+     * deserializers to customize presentation aspects of the\n+     * serialized value.\n+     * \n+     * @since 2.0\n+     */\n+    public JsonFormat.Value findFormat(AnnotatedMember member) {\n+        return null;\n+    }\n     \n     /**\n      * Method for checking whether given accessor claims to represent\n             }\n             return result;\n         }\n+\n+        @Override\n+        public JsonFormat.Value findFormat(AnnotatedMember member) {\n+            JsonFormat.Value result = _primary.findFormat(member);\n+            if (result == null) {\n+                result = _secondary.findFormat(member);\n+            }\n+            return result;\n+        }\n         \n         // // // Serialization: class annotations\n \n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n import java.lang.reflect.Type;\n import java.text.DateFormat;\n import java.util.Date;\n+import java.util.Locale;\n+import java.util.TimeZone;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.ser.std.StdKeySerializers;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.ISO8601Utils;\n import com.fasterxml.jackson.databind.util.RootNameLookup;\n \n /**\n     /**\n      * Serialization configuration to use for serialization processing.\n      */\n-    protected final SerializationConfig _config;\n+    final protected SerializationConfig _config;\n \n     /**\n      * View used for currently active serialization, if any.\n      */\n-    protected final Class<?> _serializationView;\n+    final protected Class<?> _serializationView;\n     \n     /*\n     /**********************************************************\n \n     /*\n     /**********************************************************\n+    /* Configuration, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Locale used for formatting purposes.\n+     */\n+    protected Locale _locale;\n+\n+    /**\n+     * Timezone to use as the default; if not specified, will\n+     * default to GMT\n+     */\n+    protected TimeZone _timezone;\n+    \n+    /*\n+    /**********************************************************\n     /* State, for non-blueprint instances: generic\n     /**********************************************************\n      */\n         _nullValueSerializer = src._nullValueSerializer;\n         _nullKeySerializer = src._nullKeySerializer;\n         _rootNames = src._rootNames;\n+        _locale = src._locale;\n+        _timezone = src._timezone;\n \n         /* Non-blueprint instances do have a read-only map; one that doesn't\n          * need synchronization for lookups.\n         }\n         _nullKeySerializer = nks;\n     }\n-    \n+\n+    /**\n+     * @since 2.0\n+     */\n+    public void setLocale(Locale l) {\n+        _locale = l;\n+    }\n+    \n+    /**\n+     * @since 2.0\n+     */\n+    public void setTimeZone(TimeZone tz) {\n+        _timezone = tz;\n+    }\n+        \n     /*\n     /**********************************************************\n     /* Access to general configuration\n         return _config.getFilterProvider();\n     }\n \n+    /**\n+     * Method for accessing default Locale to use; can be overridden.\n+     */\n+    public Locale getLocale() {\n+        if (_locale != null) {\n+            return _locale;\n+        }\n+        return Locale.getDefault();\n+    }\n+\n+    public TimeZone getTimeZone() {\n+        if (_timezone != null) {\n+            return _timezone;\n+        }\n+        return ISO8601Utils.timeZoneGMT();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Access to type handling\n         }\n     }\n \n-    /**\n-     * Method that will handle serialization of Date(-like) values, using\n-     * {@link SerializationConfig} settings to determine expected serialization\n-     * behavior.\n-     * Note: date here means \"full\" date, that is, date AND time, as per\n-     * Java convention (and not date-only values like in SQL)\n-     */\n-    /*\n-    /**********************************************************\n-    /* Abstract method impls, convenience methods\n+    /*\n+    /**********************************************************\n+    /* Convenience methods\n     /**********************************************************\n      */\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n         }\n         return new ObjectIdInfo(info.property(), info.scope(), info.generator());\n     }\n-    \n+\n+    @Override\n+    public JsonFormat.Value findFormat(AnnotatedMember member) {\n+        JsonFormat ann = member.getAnnotation(JsonFormat.class);\n+        return (ann == null)  ? null : new JsonFormat.Value(ann);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Serialization: class annotations\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n \n import java.io.IOException;\n import java.lang.reflect.Type;\n-import java.util.Date;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.core.*;\n \n-import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.SerializationFeature;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n \n /**\n  * For efficiency, we will serialize Dates as longs, instead of\n @JacksonStdImpl\n public class DateSerializer\n     extends StdScalarSerializer<Date>\n+    implements ContextualSerializer\n {\n+    /**\n+     * Default instance that is used when no contextual configuration\n+     * is needed.\n+     */\n     public static DateSerializer instance = new DateSerializer();\n     \n-    public DateSerializer() { super(Date.class); }\n+    /**\n+     * Flag that indicates that serialization must be done as the\n+     * Java timetamp, regardless of other settings.\n+     */\n+    protected final boolean _useTimestamp;\n+    \n+    /**\n+     * Specific format to use, if not default format: non null value\n+     * also indicates that serialization is to be done as JSON String,\n+     * not numeric timestamp, unless {@link #_useTimestamp} is true.\n+     */\n+    protected final DateFormat _customFormat;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    public DateSerializer() {\n+        this(false, null);\n+    }\n+        \n+    public DateSerializer(boolean useTimestamp, DateFormat customFormat)\n+    {\n+        super(Date.class);\n+        _useTimestamp = useTimestamp;\n+        _customFormat = customFormat;\n+    }\n \n+    public DateSerializer withFormat(boolean timestamp, DateFormat customFormat)\n+    {\n+        if (timestamp) {\n+            return new DateSerializer(true, null);\n+        }\n+        return new DateSerializer(false, customFormat);\n+    }\n+\n+    @Override\n+    public JsonSerializer<?> createContextual(SerializerProvider prov,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        if (property != null) {\n+            JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat(property.getMember());\n+            if (format != null) {\n+                if (format.shape.isNumeric()) {\n+                    return withFormat(true, null);\n+                }\n+                String pattern = format.pattern;\n+                if (pattern.length() > 0){\n+                    SimpleDateFormat df = new SimpleDateFormat(pattern, prov.getLocale());\n+                    df.setTimeZone(prov.getTimeZone());\n+                    return withFormat(false, df);\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+    \n     @Override\n     public boolean isEmpty(Date value) {\n         // let's assume \"null date\" (timestamp 0) qualifies for empty\n         return (value == null) || (value.getTime() == 0L);\n-    }\n-    \n-    @Override\n-    public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n-        provider.defaultSerializeDateValue(value, jgen);\n     }\n \n     @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n     {\n         //todo: (ryan) add a format for the date in the schema?\n-        return createSchemaNode(provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)\n-                ? \"number\" : \"string\", true);\n+        boolean asNumber = _useTimestamp;\n+        if (!asNumber) {\n+            if (_customFormat == null) {\n+                asNumber = provider.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+            }\n+        }\n+        return createSchemaNode(asNumber ? \"number\" : \"string\", true);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Actual serialization\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_useTimestamp) {\n+            jgen.writeNumber(value.getTime());\n+        } else if (_customFormat != null) {\n+            // 21-Feb-2011, tatu: not optimal, but better than alternatives:\n+            synchronized (_customFormat) {\n+                jgen.writeString(_customFormat.format(value));\n+            }\n+        } else {\n+            provider.defaultSerializeDateValue(value, jgen);\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n      */\n     private static final TimeZone TIMEZONE_GMT = TimeZone.getTimeZone(GMT_ID);\n \n+    /**\n+     * Accessor for static GMT timezone instance.\n+     */\n+    public static TimeZone timeZoneGMT() {\n+        return TIMEZONE_GMT;\n+    }\n+    \n     /**\n      * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (GMT timezone, no milliseconds precision)\n      *\n--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n public class StdDateFormat\n     extends DateFormat\n {\n-    /* TODO !!! 24-Nov-2009, tatu: Need to rewrite this class soon:\n+    /* TODO !!! 24-Nov-2009, tatu: Need to rewrite this class:\n      * JDK date parsing is awfully brittle, and ISO-8601 is quite\n      * permissive. The two don't mix, need to write a better one.\n      */\n+    // Note: [JACKSON-697] is the issue for rewrite\n \n     /**\n      * Defines a commonly used date format that conforms\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestDateSerialization.java\n import java.util.*;\n \n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n \n public class TestDateSerialization\n         public TimeZone getTz() { return tz; }\n     }\n \n+    static class DateAsNumberBean {\n+        @JsonFormat(shape=JsonFormat.Shape.NUMBER)\n+        public Date date;\n+        public DateAsNumberBean(long l) { date = new java.util.Date(l); }\n+    }\n+\n+    static class DateAsStringBean {\n+        @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=\"yyyy-MM-dd\")\n+        public Date date;\n+        public DateAsStringBean(long l) { date = new java.util.Date(l); }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Test methods\n     /**********************************************************\n      */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n     \n     public void testDateNumeric() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        StringWriter sw = new StringWriter();\n         // default is to output time stamps...\n-        assertTrue(mapper.getSerializationConfig().isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS));\n+        assertTrue(MAPPER.isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS));\n         // shouldn't matter which offset we give...\n-        mapper.writeValue(sw, new Date(199L));\n-        assertEquals(\"199\", sw.toString());\n+        String json = MAPPER.writeValueAsString(new Date(199L));\n+        assertEquals(\"199\", json);\n     }\n \n     public void testDateISO8601() throws IOException\n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        StringWriter sw = new StringWriter();\n         mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n         // let's hit epoch start\n-        mapper.writeValue(sw, new Date(0L));\n-        assertEquals(\"\\\"1970-01-01T00:00:00.000+0000\\\"\", sw.toString());\n+        String json = mapper.writeValueAsString(new Date(0L));\n+        assertEquals(\"\\\"1970-01-01T00:00:00.000+0000\\\"\", json);\n     }\n \n     public void testDateOther() throws IOException\n     @SuppressWarnings(\"deprecation\")\n     public void testSqlDate() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         // use date 1999-04-01 (note: months are 0-based, use constant)\n         java.sql.Date date = new java.sql.Date(99, Calendar.APRIL, 1);\n-        assertEquals(quote(\"1999-04-01\"), serializeAsString(mapper, date));\n+        assertEquals(quote(\"1999-04-01\"), MAPPER.writeValueAsString(date));\n     }\n \n     public void testTimeZone() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n         TimeZone input = TimeZone.getTimeZone(\"PST\");\n-        String json = mapper.writeValueAsString(input);\n+        String json = MAPPER.writeValueAsString(input);\n         assertEquals(quote(\"PST\"), json);\n     }\n \n     // [JACKSON-663]\n     public void testTimeZoneInBean() throws IOException\n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        String json = mapper.writeValueAsString(new TimeZoneBean(\"PST\"));\n+        String json = MAPPER.writeValueAsString(new TimeZoneBean(\"PST\"));\n         assertEquals(\"{\\\"tz\\\":\\\"PST\\\"}\", json);\n     }\n     \n     {\n         DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'X'HH:mm:ss\");\n         df.setTimeZone(TimeZone.getTimeZone(\"PST\"));\n-        ObjectMapper mapper = new ObjectMapper();\n         assertEquals(quote(\"1969-12-31X16:00:00\"),\n-                mapper.writer(df).writeValueAsString(new Date(0L)));\n-        ObjectWriter w = mapper.writer((DateFormat)null);\n+                MAPPER.writer(df).writeValueAsString(new Date(0L)));\n+        ObjectWriter w = MAPPER.writer((DateFormat)null);\n         assertEquals(\"0\", w.writeValueAsString(new Date(0L)));\n \n         w = w.withDateFormat(df);\n         mapper.configure(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS, true);\n         assertEquals(\"{\\\"0\\\":1}\", mapper.writeValueAsString(map));\n     }\n+\n+    // [JACKSON-435]\n+    public void testDateWithJsonFormat() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json;\n+\n+        // first: test overriding writing as timestamp\n+        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+        json = mapper.writeValueAsString(new DateAsNumberBean(0L));\n+        assertEquals(\"{\\\"date\\\":0}\", json);\n+\n+        // then reverse\n+        mapper.enable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);\n+        json = mapper.writeValueAsString(new DateAsStringBean(0L));\n+        assertEquals(\"{\\\"date\\\":\\\"1970-01-01\\\"}\", json);\n+    }\n }\n ", "timestamp": 1329891681, "metainfo": ""}