{"sha": "12a4abda3aeb213ed05e0aa500e2e6b70dbb9cca", "log": "parser update: normal order of selectors", "commit": "\n--- a/src/main/java/org/jsoup/select/ng/parser/Parser.java\n+++ b/src/main/java/org/jsoup/select/ng/parser/Parser.java\n package org.jsoup.select.ng.parser;\n \n-import java.util.ArrayDeque;\n import java.util.ArrayList;\n-import java.util.Deque;\n import java.util.List;\n import java.util.regex.Pattern;\n \n import org.jsoup.parser.TokenQueue;\n import org.jsoup.select.ng.AndSelector;\n import org.jsoup.select.ng.BasicSelector;\n-import org.jsoup.select.ng.ElementContainerSelector;\n import org.jsoup.select.ng.HasSelector;\n import org.jsoup.select.ng.ImmediateParentSelector;\n import org.jsoup.select.ng.NotSelector;\n \tTokenQueue tq;\n     private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\n     String query;\n-    Deque<Evaluator> s = new ArrayDeque<Evaluator>();\n+    //Deque<Evaluator> s = new ArrayDeque<Evaluator>();\n+    List<Evaluator> s = new ArrayList<Evaluator>();\n     \n     \n     \n             if (tq.matchChomp(\",\")) { // group or\n             \tOrSelector or = new OrSelector(s);\n             \ts.clear();\n-            \ts.push(or);\n+            \t//s.push(or);\n+            \ts.add(or);\n             \twhile (!tq.isEmpty()) {\n                     String subQuery = tq.chompTo(\",\");\n                     or.add(parse(subQuery));\n         }\n         \n         if(s.size() == 1)\n-        \treturn s.getFirst();\n+        \treturn s.get(0);\n         \n         return new AndSelector(s);\n     }\n         Evaluator e = null;\n         \n         if(s.size() == 1)\n-        \te = s.pop();\n+        \te = s.get(0);\n         else {\n         \te = new AndSelector(s);\n-        \ts.clear();\n-        }\n+        }\n+    \ts.clear();\n         Evaluator f = parse(subQuery);\n         \n \n         if (combinator == '>') {\n-        \ts.push(BasicSelector.and(f, new ImmediateParentSelector(e)));\n+        \ts.add(BasicSelector.and(f, new ImmediateParentSelector(e)));\n         } else if (combinator == ' ') {\n-        \ts.push(BasicSelector.and(f, new ParentSelector(e)));\n+        \ts.add(BasicSelector.and(f, new ParentSelector(e)));\n         } else if (combinator == '+') {\n-        \ts.push(BasicSelector.and(f, new PrevSiblingSelector(e)));\n+        \ts.add(BasicSelector.and(f, new PrevSiblingSelector(e)));\n         } else if (combinator == '~') {\n-        \ts.push(BasicSelector.and(f, new PreviousSequentSiblingSelector(e)));\n+        \ts.add(BasicSelector.and(f, new PreviousSequentSiblingSelector(e)));\n         } else\n             throw new IllegalStateException(\"Unknown combinator: \" + combinator);\n         \n         tq.consume(\":has\");\n         String subQuery = tq.chompBalanced('(',')');\n         Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n-        s.push(new HasSelector(parse(subQuery)));\n+        s.add(new HasSelector(parse(subQuery)));\n         \n \n \n         String searchText = TokenQueue.unescape(tq.chompBalanced('(',')'));\n         Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n         if(own)\n-        \ts.push(new Evaluator.ContainsOwnText(searchText));\n+        \ts.add(new Evaluator.ContainsOwnText(searchText));\n         else\n-        \ts.push(new Evaluator.ContainsText(searchText));\n+        \ts.add(new Evaluator.ContainsText(searchText));\n     }\n     \n     // :matches(regex), matchesOwn(regex)\n         Validate.notEmpty(regex, \":matches(regex) query must not be empty\");\n         \n         if(own)\n-        \ts.push(new Evaluator.MatchesOwn(Pattern.compile(regex)));\n+        \ts.add(new Evaluator.MatchesOwn(Pattern.compile(regex)));\n         else\n-        \ts.push(new Evaluator.Matches(Pattern.compile(regex)));\n+        \ts.add(new Evaluator.Matches(Pattern.compile(regex)));\n \n         \n     }\n         String subQuery = tq.chompBalanced('(', ')');\n         Validate.notEmpty(subQuery, \":not(selector) subselect must not be empty\");\n         \n-        s.push(new NotSelector(parse(subQuery)));\n+        s.add(new NotSelector(parse(subQuery)));\n     }\n \n \n     \t\n     \tElementContainerSelector ec = (ElementContainerSelector) p;*/\n     \t//ec.add(e);\n-    \ts.push(e);\n+    \ts.add(e);\n     }\n \n     \n     public static void main(String[] args) {\n         // make sure doesn't get nested\n+    \tEvaluator eval = Parser.parse(\"div.head, div.body\");\n         Document doc = Jsoup.parse(\"<div id=1><div id=2><div id=3></div></div></div>\");\n         Element div = SelectMatch.match(SelectMatch.match(doc, Parser.parse(\"div\")), Parser.parse(\" > div\")).first();\n \t}", "timestamp": 1309605124, "metainfo": ""}