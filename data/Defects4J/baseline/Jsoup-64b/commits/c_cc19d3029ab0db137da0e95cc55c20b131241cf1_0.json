{"sha": "cc19d3029ab0db137da0e95cc55c20b131241cf1", "log": "Reverted Node.equals() and Node.hashCode()  Back to identity (object) comparisons, as deep content inspection had negative performance impacts and hashkey stability problems. Functionality replaced with Node.hasSameContent().  Fixes #688", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n     }\n \n     @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-        if (!super.equals(o)) return false;\n-\n-        Element element = (Element) o;\n-\n-        return tag.equals(element.tag);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = super.hashCode();\n-        result = 31 * result + (tag != null ? tag.hashCode() : 0);\n-        return result;\n-    }\n-\n-    @Override\n     public Element clone() {\n         return (Element) super.clone();\n     }\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n     }\n \n     /**\n-     * Check if this node is equal to another node. A node is considered equal if its attributes and content equal the\n-     * other node; particularly its position in the tree does not influence its equality.\n+     * Check if this node is the same instance of another (object identity test).\n      * @param o other object to compare to\n      * @return true if the content of this node is the same as the other\n+     * @see Node#hasSameValue(Object) to compare nodes by their value\n      */\n     @Override\n     public boolean equals(Object o) {\n+        // implemented just so that javadoc is clear this is an identity test\n+        return this == o;\n+    }\n+\n+    /**\n+     * Check if this node is has the same content as another node. A node is considered the same if its name, attributes and content match the\n+     * other node; particularly its position in the tree does not influence its similarity.\n+     * @param o other object to compare to\n+     * @return true if the content of this node is the same as the other\n+     */\n+\n+    public boolean hasSameValue(Object o) {\n         if (this == o) return true;\n         if (o == null || getClass() != o.getClass()) return false;\n \n         Node node = (Node) o;\n-\n-        if (childNodes != null ? !childNodes.equals(node.childNodes) : node.childNodes != null) return false;\n-        return !(attributes != null ? !attributes.equals(node.attributes) : node.attributes != null);\n-    }\n-\n-    /**\n-     * Calculates a hash code for this node, which includes iterating all its attributes, and recursing into any child\n-     * nodes. This means that a node's hashcode is based on it and its child content, and not its parent or place in the\n-     * tree. So two nodes with the same content, regardless of their position in the tree, will have the same hashcode.\n-     * @return the calculated hashcode\n-     * @see Node#equals(Object)\n-     */\n-    @Override\n-    public int hashCode() {\n-        int result = childNodes != null ? childNodes.hashCode() : 0;\n-        result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n-        return result;\n+        return this.outerHtml().equals(((Node) o).outerHtml());\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n         ensureAttributes();\n         return super.absUrl(attributeKey);\n     }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o == null || getClass() != o.getClass()) return false;\n-        if (!super.equals(o)) return false;\n-\n-        TextNode textNode = (TextNode) o;\n-\n-        return !(text != null ? !text.equals(textNode.text) : textNode.text != null);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        int result = super.hashCode();\n-        result = 31 * result + (text != null ? text.hashCode() : 0);\n-        return result;\n-    }\n }\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n         Document docB = Jsoup.parse(\"<div/>One\");\n         Document docC = Jsoup.parse(\"<div/>Two\");\n \n-        assertEquals(docA, docB);\n-        assertFalse(docA.equals(docC));\n-        assertEquals(docA.hashCode(), docB.hashCode());\n+        assertFalse(docA.equals(docB));\n+        assertTrue(docA.equals(docA));\n+        assertEquals(docA.hashCode(), docA.hashCode());\n         assertFalse(docA.hashCode() == docC.hashCode());\n+    }\n+\n+    @Test public void DocumentsWithSameContentAreVerifialbe() throws Exception {\n+        Document docA = Jsoup.parse(\"<div/>One\");\n+        Document docB = Jsoup.parse(\"<div/>One\");\n+        Document docC = Jsoup.parse(\"<div/>Two\");\n+\n+        assertTrue(docA.hasSameValue(docB));\n+        assertFalse(docA.hasSameValue(docC));\n     }\n     \n     @Test\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n     }\n \n     @Test\n-    public void testHashAndEquals() {\n+    public void testHashAndEqualsAndValue() {\n+        // .equals and hashcode are identity. value is content.\n+\n         String doc1 = \"<div id=1><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\" +\n                 \"<div id=2><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\";\n \n         Element e6 = els.get(6);\n         Element e7 = els.get(7);\n \n-        assertEquals(e0, e1);\n-        assertEquals(e0, e4);\n-        assertEquals(e0, e5);\n+        assertEquals(e0, e0);\n+        assertTrue(e0.hasSameValue(e1));\n+        assertTrue(e0.hasSameValue(e4));\n+        assertTrue(e0.hasSameValue(e5));\n         assertFalse(e0.equals(e2));\n-        assertFalse(e0.equals(e3));\n-        assertFalse(e0.equals(e6));\n-        assertFalse(e0.equals(e7));\n-\n-        assertEquals(e0.hashCode(), e1.hashCode());\n-        assertEquals(e0.hashCode(), e4.hashCode());\n-        assertEquals(e0.hashCode(), e5.hashCode());\n+        assertFalse(e0.hasSameValue(e2));\n+        assertFalse(e0.hasSameValue(e3));\n+        assertFalse(e0.hasSameValue(e6));\n+        assertFalse(e0.hasSameValue(e7));\n+\n+        assertEquals(e0.hashCode(), e0.hashCode());\n         assertFalse(e0.hashCode() == (e2.hashCode()));\n         assertFalse(e0.hashCode() == (e3).hashCode());\n         assertFalse(e0.hashCode() == (e6).hashCode());\n \n         String result = doc.toString().replaceAll(\"\\\\s+\", \"\");\n         assertEquals(\"<body><div3>Check</div3><div4></div4><div1></div1><div2></div2></body>\", result);\n-\n+    }\n+\n+    @Test\n+    public void testHashcodeIsStableWithContentChanges() {\n+        Element root = new Element(Tag.valueOf(\"root\"), \"\");\n+\n+        HashSet<Element> set = new HashSet<Element>();\n+        // Add root node:\n+        set.add(root);\n+\n+        root.appendChild(new Element(Tag.valueOf(\"a\"), \"\"));\n+        assertTrue(set.contains(root));\n     }\n }", "timestamp": 1459886082, "metainfo": ""}