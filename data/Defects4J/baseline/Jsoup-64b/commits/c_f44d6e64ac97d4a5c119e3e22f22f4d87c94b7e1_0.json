{"sha": "f44d6e64ac97d4a5c119e3e22f22f4d87c94b7e1", "log": "Update isValid and cleaner methods  Stricter at enforcing that it is only body content and that there are no HTML errors.  Fixes #245 Fixes #632", "commit": "\n--- a/src/main/java/org/jsoup/Jsoup.java\n+++ b/src/main/java/org/jsoup/Jsoup.java\n \n     /**\n      * Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a white-list of\n-     * permitted\n-     * tags and attributes.\n+     * permitted tags and attributes.\n+     * <p>The HTML is treated as a body fragment; it's expected the cleaned HTML will be used within the body of an\n+     * existing document. If you want to clean full documents, use {@link Cleaner#clean(Document)} instead, and add\n+     * structural tags (<code>html, head, body</code> etc) to the whitelist.\n      *\n      * @param bodyHtml input untrusted HTML (body fragment)\n      * @param baseUri URL to resolve relative URLs against\n     }\n \n     /**\n-     Test if the input HTML has only tags and attributes allowed by the Whitelist. Useful for form validation. The input HTML should\n-     still be run through the cleaner to set up enforced attributes, and to tidy the output.\n+     Test if the input body HTML has only tags and attributes allowed by the Whitelist. Useful for form validation.\n+     <p>The input HTML should still be run through the cleaner to set up enforced attributes, and to tidy the output.\n+     <p>Assumes the HTML is a body fragment (i.e. will be used in an existing HTML document body.)\n      @param bodyHtml HTML to test\n      @param whitelist whitelist to test against\n      @return true if no tags or attributes were removed; false otherwise\n      @see #clean(String, org.jsoup.safety.Whitelist) \n      */\n     public static boolean isValid(String bodyHtml, Whitelist whitelist) {\n-        Document dirty = parseBodyFragment(bodyHtml, \"\");\n-        Cleaner cleaner = new Cleaner(whitelist);\n-        return cleaner.isValid(dirty);\n+        return new Cleaner(whitelist).isValidBodyHtml(bodyHtml);\n     }\n     \n }\n--- a/src/main/java/org/jsoup/parser/ParseErrorList.java\n+++ b/src/main/java/org/jsoup/parser/ParseErrorList.java\n  * \n  * @author Jonathan Hedley\n  */\n-class ParseErrorList extends ArrayList<ParseError>{\n+public class ParseErrorList extends ArrayList<ParseError>{\n     private static final int INITIAL_CAPACITY = 16;\n     private final int maxSize;\n     \n         return maxSize;\n     }\n \n-    static ParseErrorList noTracking() {\n+    public static ParseErrorList noTracking() {\n         return new ParseErrorList(0, 0);\n     }\n     \n-    static ParseErrorList tracking(int maxSize) {\n+    public static ParseErrorList tracking(int maxSize) {\n         return new ParseErrorList(INITIAL_CAPACITY, maxSize);\n     }\n }\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n     public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n         HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n         return treeBuilder.parseFragment(fragmentHtml, context, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n+    }\n+\n+    /**\n+     * Parse a fragment of HTML into a list of nodes. The context element, if supplied, supplies parsing context.\n+     *\n+     * @param fragmentHtml the fragment of HTML to parse\n+     * @param context (optional) the element that this HTML fragment is being parsed for (i.e. for inner HTML). This\n+     * provides stack context (for implicit element creation).\n+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     * @param errorList list to add errors to\n+     *\n+     * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n+     */\n+    public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri, ParseErrorList errorList) {\n+        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, errorList, treeBuilder.defaultSettings());\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/safety/Cleaner.java\n+++ b/src/main/java/org/jsoup/safety/Cleaner.java\n package org.jsoup.safety;\n \n import org.jsoup.helper.Validate;\n-import org.jsoup.nodes.*;\n+import org.jsoup.nodes.Attribute;\n+import org.jsoup.nodes.Attributes;\n+import org.jsoup.nodes.DataNode;\n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Node;\n+import org.jsoup.nodes.TextNode;\n+import org.jsoup.parser.ParseErrorList;\n+import org.jsoup.parser.Parser;\n import org.jsoup.parser.Tag;\n import org.jsoup.select.NodeTraversor;\n import org.jsoup.select.NodeVisitor;\n+\n+import java.util.List;\n \n \n /**\n     }\n \n     /**\n-     Determines if the input document is valid, against the whitelist. It is considered valid if all the tags and attributes\n-     in the input HTML are allowed by the whitelist.\n+     Determines if the input document <b>body</b>is valid, against the whitelist. It is considered valid if all the tags and attributes\n+     in the input HTML are allowed by the whitelist, and that there is no content in the <code>head</code>.\n      <p>\n-     This method can be used as a validator for user input forms. An invalid document will still be cleaned successfully\n+     This method can be used as a validator for user input. An invalid document will still be cleaned successfully\n      using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document\n      to ensure enforced attributes are set correctly, and that the output is tidied.\n      </p>\n \n         Document clean = Document.createShell(dirtyDocument.baseUri());\n         int numDiscarded = copySafeNodes(dirtyDocument.body(), clean.body());\n-        return numDiscarded == 0;\n+        return numDiscarded == 0\n+            && dirtyDocument.head().childNodes().size() == 0; // because we only look at the body, but we start from a shell, make sure there's nothing in the head\n+    }\n+\n+    public boolean isValidBodyHtml(String bodyHtml) {\n+        Document clean = Document.createShell(\"\");\n+        Document dirty = Document.createShell(\"\");\n+        ParseErrorList errorList = ParseErrorList.tracking(1);\n+        List<Node> nodes = Parser.parseFragment(bodyHtml, dirty.body(), \"\", errorList);\n+        dirty.body().insertChildren(0, nodes);\n+        int numDiscarded = copySafeNodes(dirty.body(), clean.body());\n+        return numDiscarded == 0 && errorList.size() == 0;\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/safety/Whitelist.java\n+++ b/src/main/java/org/jsoup/safety/Whitelist.java\n         TagName tag = TagName.valueOf(tagName);\n         AttributeKey key = AttributeKey.valueOf(attr.getKey());\n \n-        if (attributes.containsKey(tag)) {\n-            if (attributes.get(tag).contains(key)) {\n-                if (protocols.containsKey(tag)) {\n-                    Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag);\n-                    // ok if not defined protocol; otherwise test\n-                    return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key));\n-                } else { // attribute found, no protocols defined, so OK\n-                    return true;\n-                }\n+        Set<AttributeKey> okSet = attributes.get(tag);\n+        if (okSet != null && okSet.contains(key)) {\n+            if (protocols.containsKey(tag)) {\n+                Map<AttributeKey, Set<Protocol>> attrProts = protocols.get(tag);\n+                // ok if not defined protocol; otherwise test\n+                return !attrProts.containsKey(key) || testValidProtocol(el, attr, attrProts.get(key));\n+            } else { // attribute found, no protocols defined, so OK\n+                return true;\n+            }\n+        }\n+        // might be an enforced attribute?\n+        Map<AttributeKey, AttributeValue> enforcedSet = enforcedAttributes.get(tag);\n+        if (enforcedSet != null) {\n+            Attributes expect = getEnforcedAttributes(tagName);\n+            String attrKey = attr.getKey();\n+            if (expect.hasKeyIgnoreCase(attrKey)) {\n+                return expect.getIgnoreCase(attrKey).equals(attr.getValue());\n             }\n         }\n         // no attributes defined for tag, try :all tag\n--- a/src/test/java/org/jsoup/safety/CleanerTest.java\n+++ b/src/test/java/org/jsoup/safety/CleanerTest.java\n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Entities;\n import org.junit.Test;\n \n         assertEquals(\"<img alt=\\\"\\\">\", cleanHtml);\n     }\n \n-    @Test public void testIsValid() {\n-        String ok = \"<p>Test <b><a href='http://example.com/'>OK</a></b></p>\";\n+    @Test public void testIsValidBodyHtml() {\n+        String ok = \"<p>Test <b><a href='http://example.com/' rel='nofollow'>OK</a></b></p>\";\n+        String ok1 = \"<p>Test <b><a href='http://example.com/'>OK</a></b></p>\"; // missing enforced is OK because still needs run thru cleaner\n         String nok1 = \"<p><script></script>Not <b>OK</b></p>\";\n         String nok2 = \"<p align=right>Test Not <b>OK</b></p>\";\n         String nok3 = \"<!-- comment --><p>Not OK</p>\"; // comments and the like will be cleaned\n+        String nok4 = \"<html><head>Foo</head><body><b>OK</b></body></html>\"; // not body html\n+        String nok5 = \"<p>Test <b><a href='http://example.com/' rel='nofollowme'>OK</a></b></p>\";\n+        String nok6 = \"<p>Test <b><a href='http://example.com/'>OK</b></p>\"; // missing close tag\n+        String nok7 = \"</div>What\";\n         assertTrue(Jsoup.isValid(ok, Whitelist.basic()));\n+        assertTrue(Jsoup.isValid(ok1, Whitelist.basic()));\n         assertFalse(Jsoup.isValid(nok1, Whitelist.basic()));\n         assertFalse(Jsoup.isValid(nok2, Whitelist.basic()));\n         assertFalse(Jsoup.isValid(nok3, Whitelist.basic()));\n+        assertFalse(Jsoup.isValid(nok4, Whitelist.basic()));\n+        assertFalse(Jsoup.isValid(nok5, Whitelist.basic()));\n+        assertFalse(Jsoup.isValid(nok6, Whitelist.basic()));\n+        assertFalse(Jsoup.isValid(ok, Whitelist.none()));\n+        assertFalse(Jsoup.isValid(nok7, Whitelist.basic()));\n+    }\n+\n+    @Test public void testIsValidDocument() {\n+        String ok = \"<html><head></head><body><p>Hello</p></body><html>\";\n+        String nok = \"<html><head><script>woops</script><title>Hello</title></head><body><p>Hello</p></body><html>\";\n+\n+        Whitelist relaxed = Whitelist.relaxed();\n+        Cleaner cleaner = new Cleaner(relaxed);\n+        Document okDoc = Jsoup.parse(ok);\n+        assertTrue(cleaner.isValid(okDoc));\n+        assertFalse(cleaner.isValid(Jsoup.parse(nok)));\n+        assertFalse(new Cleaner(Whitelist.none()).isValid(okDoc));\n     }\n     \n     @Test public void resolvesRelativeLinks() {", "timestamp": 1480026973, "metainfo": ""}