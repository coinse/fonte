{"sha": "af77fd3ffb2973f255419df9ef591df5f8a7409f", "log": "Support for file uploads in posts", "commit": "\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n \n+import java.io.IOException;\n+import java.io.InputStream;\n import java.net.URL;\n+import java.util.Collection;\n import java.util.Map;\n-import java.util.Collection;\n-import java.io.IOException;\n \n /**\n  * A Connection provides a convenient interface to fetch content from the web, and parse them into Documents.\n- * <p>\n+ * <p/>\n  * To get a new Connection, use {@link org.jsoup.Jsoup#connect(String)}. Connections contain {@link Connection.Request}\n  * and {@link Connection.Response} objects. The request objects are reusable as prototype requests.\n- * <p>\n+ * <p/>\n  * Request configuration can be made using either the shortcut methods in Connection (e.g. {@link #userAgent(String)}),\n- * or by methods in the Connection.Request object directly. All request configuration must be made before the request\n- * is executed.\n+ * or by methods in the Connection.Request object directly. All request configuration must be made before the request is\n+ * executed.\n  */\n public interface Connection {\n \n     public Connection ignoreContentType(boolean ignoreContentType);\n \n     /**\n-     * Add a request data parameter. Request parameters are sent in the request query string for GETs, and in the request\n-     * body for POSTs. A request may have multiple values of the same name.\n+     * Add a request data parameter. Request parameters are sent in the request query string for GETs, and in the\n+     * request body for POSTs. A request may have multiple values of the same name.\n      * @param key data key\n      * @param value data value\n      * @return this Connection, for chaining\n     public Connection data(String key, String value);\n \n     /**\n+     * Add an input stream as a request data paramater. For GETs, has no effect, but for POSTS this will upload the\n+     * input stream.\n+     * @param key data key (form item name)\n+     * @param filename the name of the file to present to the remove server. Typically just the name, not path,\n+     * component.\n+     * @param inputStream the input stream to upload, that you probably obtained from a {@link java.io.FileInputStream}.\n+     * You must close the InputStream in a {@code finally} block.\n+     * @return this Connections, for chaining\n+     */\n+    public Connection data(String key, String filename, InputStream inputStream);\n+\n+    /**\n      * Adds all of the supplied data to the request data parameters\n      * @param data collection of data parameters\n      * @return this Connection, for chaining\n     public Connection data(Map<String, String> data);\n \n     /**\n-     * Add a number of request data parameters. Multiple parameters may be set at once, e.g.:\n-     * <code>.data(\"name\", \"jsoup\", \"language\", \"Java\", \"language\", \"English\");</code> creates a query string like:\n+     * Add a number of request data parameters. Multiple parameters may be set at once, e.g.: <code>.data(\"name\",\n+     * \"jsoup\", \"language\", \"Java\", \"language\", \"English\");</code> creates a query string like:\n      * <code>?name=jsoup&language=Java&language=English</code>\n      * @param keyvals a set of key value pairs.\n      * @return this Connection, for chaining\n      */\n     public Connection response(Response response);\n \n-\n     /**\n      * Common methods for Requests and Responses\n      * @param <T> Type of Base, either Request or Response\n \n         /**\n          * Get the value of a header. This is a simplified header model, where a header may only have one value.\n-         * <p>\n+         * <p/>\n          * Header names are case insensitive.\n          * @param name name of header (case insensitive)\n          * @return value of header, or null if not set.\n         public String header(String name);\n \n         /**\n-         * Set a header. This method will overwrite any existing header with the same case insensitive name. \n+         * Set a header. This method will overwrite any existing header with the same case insensitive name.\n          * @param name Name of header\n          * @param value Value of header\n          * @return this, for chaining\n         public boolean hasHeader(String name);\n \n         /**\n+         * Check if a header is present, with the given value\n+         * @param name header name (case insensitive)\n+         * @param value value (case insensitive)\n+         * @return if the header and value pair are set in this req/res\n+         */\n+        public boolean hasHeaderWithValue(String name, String value);\n+\n+        /**\n          * Remove a header by name\n          * @param name name of header to remove (case insensitive)\n          * @return this, for chaining\n \n         /**\n          * Get a cookie value by name from this request/response.\n-         * <p>\n+         * <p/>\n          * Response objects have a simplified cookie model. Each cookie set in the response is added to the response\n          * object's cookie key=value map. The cookie's path, domain, and expiry date are ignored.\n          * @param name name of cookie to retrieve.\n          * @return cookies\n          */\n         public Map<String, String> cookies();\n-\n     }\n \n     /**\n \n         /**\n          * Configures the request to (not) follow server redirects. By default this is <b>true</b>.\n-         *\n          * @param followRedirects true if server redirects should be followed.\n          * @return this Request, for chaining\n          */\n \n         /**\n          * Get the current ignoreHttpErrors configuration.\n-         * @return true if errors will be ignored; false (default) if HTTP errors will cause an IOException to be thrown.\n+         * @return true if errors will be ignored; false (default) if HTTP errors will cause an IOException to be\n+         * thrown.\n          */\n         public boolean ignoreHttpErrors();\n \n-    \t/**\n-    \t * Configures the request to ignore HTTP errors in the response.\n-    \t * @param ignoreHttpErrors set to true to ignore HTTP errors.\n-         * @return this Request, for chaining\n-    \t */\n+        /**\n+         * Configures the request to ignore HTTP errors in the response.\n+         * @param ignoreHttpErrors set to true to ignore HTTP errors.\n+         * @return this Request, for chaining\n+         */\n         public Request ignoreHttpErrors(boolean ignoreHttpErrors);\n \n         /**\n          * Get the current ignoreContentType configuration.\n-         * @return true if invalid content-types will be ignored; false (default) if they will cause an IOException to be thrown.\n+         * @return true if invalid content-types will be ignored; false (default) if they will cause an IOException to\n+         * be thrown.\n          */\n         public boolean ignoreContentType();\n \n         /**\n-    \t * Configures the request to ignore the Content-Type of the response.\n-    \t * @param ignoreContentType set to true to ignore the content type.\n-         * @return this Request, for chaining\n-    \t */\n+         * Configures the request to ignore the Content-Type of the response.\n+         * @param ignoreContentType set to true to ignore the content type.\n+         * @return this Request, for chaining\n+         */\n         public Request ignoreContentType(boolean ignoreContentType);\n \n         /**\n      * Represents a HTTP response.\n      */\n     public interface Response extends Base<Response> {\n-    \t\n-    \t/**\n+\n+        /**\n          * Get the status code of the response.\n          * @return status code\n          */\n          * @return the value\n          */\n         public String value();\n+\n+        /**\n+         * Add or update an input stream to this keyVal\n+         * @param inputStream new input stream\n+         * @return this KeyVal, for chaining\n+         */\n+        public KeyVal inputStream(InputStream inputStream);\n+\n+        /**\n+         * Get the input stream associated with this keyval, if any\n+         * @return input stream if set, or null\n+         */\n+        public InputStream inputStream();\n+\n+        /**\n+         * Does this keyval have an input stream?\n+         * @return true if this keyval does indeed have an input stream\n+         */\n+        public boolean hasInputStream();\n     }\n }\n-\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Random;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n import java.util.Locale;\n  * Internal static utilities for handling data.\n  *\n  */\n-public class DataUtil {\n+public final class DataUtil {\n     private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\");\n     static final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\n     private static final int bufferSize = 0x20000; // ~130K.\n+    private static final char[] mimeBoundaryChars =\n+            \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\n+    static final int boundaryLength = 32;\n \n     private DataUtil() {}\n \n     public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n         ByteBuffer byteData = readToByteBuffer(in);\n         return parseByteData(byteData, charsetName, baseUri, parser);\n+    }\n+\n+    /**\n+     * Writes the input stream to the output stream. Doesn't close them.\n+     * @param in input stream to read from\n+     * @param out output stream to write to\n+     * @throws IOException on IO error\n+     */\n+    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n+        final byte[] buffer = new byte[bufferSize];\n+        int len;\n+        while ((len = in.read(buffer)) != -1) {\n+            out.write(buffer, 0, len);\n+        }\n     }\n \n     // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n         }\n         return null;\n     }\n-    \n-    \n+\n+    /**\n+     * Creates a random string, suitable for use as a mime boundary\n+     */\n+    static String mimeBoundary() {\n+        final StringBuilder mime = new StringBuilder(boundaryLength);\n+        final Random rand = new Random();\n+        for (int i = 0; i < boundaryLength -2; i++) {\n+            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n+        }\n+        return mime.toString();\n+    }\n }\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n  */\n public class HttpConnection implements Connection {\n     private static final int HTTP_TEMP_REDIR = 307; // http/1.1 temporary redirect, not in Java's set.\n+    public static final String  CONTENT_ENCODING = \"Content-Encoding\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n \n     public static Connection connect(String url) {\n         Connection con = new HttpConnection();\n \t\t\treturn null;\n     \treturn url.replaceAll(\" \", \"%20\");\n \t}\n+\n+    private static String encodeMimeName(String val) {\n+        if (val == null)\n+            return null;\n+        return val.replaceAll(\"\\\"\", \"%22\");\n+    }\n \n     private Connection.Request req;\n     private Connection.Response res;\n \n     public Connection data(String key, String value) {\n         req.data(KeyVal.create(key, value));\n+        return this;\n+    }\n+\n+    public Connection data(String key, String filename, InputStream inputStream) {\n+        req.data(KeyVal.create(key, filename, inputStream));\n         return this;\n     }\n \n         public boolean hasHeader(String name) {\n             Validate.notEmpty(name, \"Header name must not be empty\");\n             return getHeaderCaseInsensitive(name) != null;\n+        }\n+\n+        /**\n+         * Test if the request has a header with this value (case insensitive).\n+         */\n+        public boolean hasHeaderWithValue(String name, String value) {\n+            return hasHeader(name) && header(name).equalsIgnoreCase(value);\n         }\n \n         public T removeHeader(String name) {\n         }\n     }\n \n-    public static class Request extends Base<Connection.Request> implements Connection.Request {\n+    public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request {\n         private int timeoutMilliseconds;\n         private int maxBodySizeBytes;\n         private boolean followRedirects;\n         }\n     }\n \n-    public static class Response extends Base<Connection.Response> implements Connection.Response {\n+    public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response {\n         private static final int MAX_REDIRECTS = 20;\n         private int statusCode;\n         private String statusMessage;\n                 throw new MalformedURLException(\"Only http & https protocols supported\");\n \n             // set up the request for execution\n-            if (req.method() == Connection.Method.GET && req.data().size() > 0)\n+            String mimeBoundary = null;\n+            if (req.method() == Connection.Method.GET && req.data().size() > 0) {\n                 serialiseRequestUrl(req); // appends query string\n+            } else {\n+                mimeBoundary = setupMultipartModeIfNeeded(req);\n+            }\n             HttpURLConnection conn = createConnection(req);\n             Response res;\n             try {\n                 conn.connect();\n                 if (req.method() == Connection.Method.POST)\n-                    writePost(req.data(), conn.getOutputStream());\n+                    writePost(req, conn.getOutputStream(), mimeBoundary);\n \n                 int status = conn.getResponseCode();\n                 boolean needsRedirect = false;\n                 InputStream dataStream = null;\n                 try {\n                     dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n-                    bodyStream = res.hasHeader(\"Content-Encoding\") && res.header(\"Content-Encoding\").equalsIgnoreCase(\"gzip\") ?\n+                    bodyStream = res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\") ?\n                             new BufferedInputStream(new GZIPInputStream(dataStream)) :\n                             new BufferedInputStream(dataStream);\n \n             }\n         }\n \n-        private static void writePost(Collection<Connection.KeyVal> data, OutputStream outputStream) throws IOException {\n-            OutputStreamWriter w = new OutputStreamWriter(outputStream, DataUtil.defaultCharset);\n-            boolean first = true;\n-            for (Connection.KeyVal keyVal : data) {\n-                if (!first)\n-                    w.append('&');\n-                else\n-                    first = false;\n-\n-                w.write(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset));\n-                w.write('=');\n-                w.write(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n+        private static String setupMultipartModeIfNeeded(final Connection.Request req) {\n+            // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n+            boolean needsMulti = false;\n+            for (Connection.KeyVal keyVal : req.data()) {\n+                if (keyVal.hasInputStream()) {\n+                    needsMulti = true;\n+                    break;\n+                }\n+            }\n+            if (needsMulti) {\n+                final String bound = DataUtil.mimeBoundary();\n+                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n+                return bound;\n+            }\n+            return null;\n+        }\n+\n+        private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n+            final Collection<Connection.KeyVal> data = req.data();\n+            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, DataUtil.defaultCharset));\n+\n+            if (bound != null) {\n+                // boundary will be set if we're in multipart mode\n+                for (Connection.KeyVal keyVal : data) {\n+                    w.write(\"--\");\n+                    w.write(bound);\n+                    w.write(\"\\r\\n\");\n+                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n+                    w.write(encodeMimeName(keyVal.key())); // encodes \" to %22\n+                    w.write(\"\\\"\");\n+                    if (keyVal.hasInputStream()) {\n+                        w.write(\"; filename=\\\"\");\n+                        w.write(encodeMimeName(keyVal.value()));\n+                        w.write(\"\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\");\n+                        w.flush(); // flush\n+                        DataUtil.crossStreams(keyVal.inputStream(), outputStream);\n+                        outputStream.flush();\n+                    } else {\n+                        w.write(\"\\r\\n\\r\\n\");\n+                        w.write(keyVal.value());\n+                    }\n+                    w.write(\"\\r\\n\");\n+                }\n+                w.write(\"--\");\n+                w.write(bound);\n+                w.write(\"--\");\n+            } else {\n+                // regular form data (application/x-www-form-urlencoded)\n+                boolean first = true;\n+                for (Connection.KeyVal keyVal : data) {\n+                    if (!first)\n+                        w.append('&');\n+                    else\n+                        first = false;\n+\n+                    w.write(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset));\n+                    w.write('=');\n+                    w.write(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n+                }\n             }\n             w.close();\n         }\n     public static class KeyVal implements Connection.KeyVal {\n         private String key;\n         private String value;\n+        private InputStream stream;\n \n         public static KeyVal create(String key, String value) {\n-            Validate.notEmpty(key, \"Data key must not be empty\");\n-            Validate.notNull(value, \"Data value must not be null\");\n-            return new KeyVal(key, value);\n-        }\n-\n-        private KeyVal(String key, String value) {\n-            this.key = key;\n-            this.value = value;\n-        }\n+            return new KeyVal().key(key).value(value);\n+        }\n+\n+        public static KeyVal create(String key, String filename, InputStream stream) {\n+            return new KeyVal().key(key).value(filename).inputStream(stream);\n+        }\n+\n+        private KeyVal() {}\n \n         public KeyVal key(String key) {\n             Validate.notEmpty(key, \"Data key must not be empty\");\n             return value;\n         }\n \n+        public KeyVal inputStream(InputStream inputStream) {\n+            Validate.notNull(value, \"Data input stream must not be null\");\n+            this.stream = inputStream;\n+            return this;\n+        }\n+\n+        public InputStream inputStream() {\n+            return stream;\n+        }\n+\n+        public boolean hasInputStream() {\n+            return stream != null;\n+        }\n+\n         @Override\n         public String toString() {\n             return key + \"=\" + value;\n--- a/src/main/java/org/jsoup/nodes/FormElement.java\n+++ b/src/main/java/org/jsoup/nodes/FormElement.java\n \n             if (\"select\".equals(el.tagName())) {\n                 Elements options = el.select(\"option[selected]\");\n+                boolean set = false;\n                 for (Element option: options) {\n                     data.add(HttpConnection.KeyVal.create(name, option.val()));\n+                    set = true;\n+                }\n+                if (!set) {\n+                    Element option = el.select(\"option\").first();\n+                    if (option != null)\n+                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                 }\n             } else {\n                 data.add(HttpConnection.KeyVal.create(name, el.val()));\n--- a/src/test/java/org/jsoup/helper/DataUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/DataUtilTest.java\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n \n-import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.*;\n \n public class DataUtilTest {\n     @Test\n         assertEquals(null, DataUtil.getCharsetFromContentType(\"text/html; charset=$HJKDF\u00a7$/(\"));\n     }\n \n+    @Test\n+    public void generatesMimeBoundaries() {\n+        String m1 = DataUtil.mimeBoundary();\n+        String m2 = DataUtil.mimeBoundary();\n+\n+        assertEquals(DataUtil.boundaryLength, m1.length());\n+        assertEquals(DataUtil.boundaryLength, m2.length());\n+        assertNotSame(m1, m2);\n+        assertTrue(m1.startsWith(\"--\"));\n+    }\n+\n }\n--- a/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n+++ b/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n package org.jsoup.helper;\n \n import static org.junit.Assert.*;\n+\n+import org.jsoup.integration.ParseTest;\n import org.junit.Test;\n import org.jsoup.Connection;\n \n         con.cookie(\"Name\", \"Val\");\n         assertEquals(\"Val\", con.request().cookie(\"Name\"));\n     }\n-}\n+\n+    @Test public void inputStream() {\n+        Connection.KeyVal kv = HttpConnection.KeyVal.create(\"file\", \"thumb.jpg\", ParseTest.inputStreamFrom(\"Check\"));\n+        assertEquals(\"file\", kv.key());\n+        assertEquals(\"thumb.jpg\", kv.value());\n+        assertTrue(kv.hasInputStream());\n+\n+        kv = HttpConnection.KeyVal.create(\"one\", \"two\");\n+        assertEquals(\"one\", kv.key());\n+        assertEquals(\"two\", kv.value());\n+        assertFalse(kv.hasInputStream());\n+    }\n+}\n--- a/src/test/java/org/jsoup/integration/ParseTest.java\n+++ b/src/test/java/org/jsoup/integration/ParseTest.java\n         assertEquals(\"In July, GM said its electric Chevrolet Volt will be sold in the United States at $41,000 -- $8,000 more than its nearest competitor, the Nissan Leaf.\", p.text());\n     }\n \n-    public File getFile(String resourceName) {\n+    public static File getFile(String resourceName) {\n         try {\n             File file = new File(ParseTest.class.getResource(resourceName).toURI());\n             return file;\n         }\n     }\n \n-    private InputStream inputStreamFrom(String s) {\n+    public static InputStream inputStreamFrom(String s) {\n         try {\n             return new ByteArrayInputStream(s.getBytes(\"UTF-8\"));\n         } catch (UnsupportedEncodingException e) {\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n import org.jsoup.Jsoup;\n import org.jsoup.UnsupportedMimeTypeException;\n import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.FormElement;\n import org.junit.Ignore;\n import org.junit.Test;\n \n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.net.MalformedURLException;\n import java.net.URL;\n         assertEquals(\"http://example.com/foo.jpg\", doc.select(\"img\").first().absUrl(\"src\"));\n     }\n \n+    /**\n+     * Test fetching a form, and submitting it with a file attached.\n+     */\n+    @Test\n+    public void postHtmlFile() throws IOException {\n+        Document index = Jsoup.connect(\"http://direct.infohound.net/tidy/\").get();\n+        FormElement form = index.select(\"[name=tidy]\").forms().get(0);\n+        Connection post = form.submit();\n+\n+        File uploadFile = ParseTest.getFile(\"/htmltests/google-ipod.html\");\n+        FileInputStream stream = new FileInputStream(uploadFile);\n+\n+        // todo: need to add a better way to get an existing data field\n+        for (Connection.KeyVal keyVal : post.request().data()) {\n+            if (keyVal.key().equals(\"_file\")) {\n+                keyVal.value(\"check.html\");\n+                keyVal.inputStream(stream);\n+            }\n+        }\n+\n+        Connection.Response res;\n+        try {\n+            res = post.execute();\n+        } finally {\n+            stream.close();\n+        }\n+\n+        Document out = res.parse();\n+        assertTrue(out.text().contains(\"HTML Tidy Complete\"));\n+    }\n+\n+    /**\n+     * Tests upload of binary content to a remote service.\n+     */\n+    @Test\n+    public void postJpeg() throws IOException {\n+        File thumb = ParseTest.getFile(\"/htmltests/thumb.jpg\");\n+        Document result = Jsoup\n+                .connect(\"http://regex.info/exif.cgi\")\n+                .data(\"f\", thumb.getName(), new FileInputStream(thumb))\n+                .post();\n+\n+        assertEquals(\"Baseline DCT, Huffman coding\", result.select(\"td:contains(Process) + td\").text());\n+\n+    }\n+\n }", "timestamp": 1412745571, "metainfo": ""}