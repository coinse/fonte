{"sha": "654bc6f981587bd4b39b66702550bad33e1eacc9", "log": "Stream network loading (#905)  Implements a stream based input reader.\r \r This changes URL & file inputs from buffering the whole content into a\r string before starting to parse, into a stream based read.\r \r Memory consumption when loading large pages from the network or a file is substantially reduced.", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/jsoup/UncheckedIOException.java\n+package org.jsoup;\n+\n+import java.io.IOException;\n+\n+public class UncheckedIOException extends Error {\n+    public UncheckedIOException(IOException cause) {\n+        super(cause);\n+    }\n+\n+    public IOException ioException() {\n+        return (IOException) getCause();\n+    }\n+}\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n package org.jsoup.helper;\n \n+import org.jsoup.internal.ConstrainableInputStream;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.XmlDeclaration;\n import org.jsoup.parser.Parser;\n import org.jsoup.select.Elements;\n \n+import java.io.BufferedReader;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n+import java.io.FileInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.InputStreamReader;\n import java.io.OutputStream;\n import java.io.RandomAccessFile;\n import java.nio.ByteBuffer;\n  *\n  */\n public final class DataUtil {\n-    private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\");\n+    private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:[\\\"'])?([^\\\\s,;\\\"']*)\");\n     static final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\n-    private static final int bufferSize = 60000;\n+    private static final int firstReadBufferSize = 1024 * 5;\n+    static final int bufferSize = 1024 * 32;\n     private static final char[] mimeBoundaryChars =\n             \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\n     static final int boundaryLength = 32;\n      * @throws IOException on IO error\n      */\n     public static Document load(File in, String charsetName, String baseUri) throws IOException {\n-        ByteBuffer byteData = readFileToByteBuffer(in);\n-        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n+        return parseInputStream(new FileInputStream(in), charsetName, baseUri, Parser.htmlParser());\n     }\n \n     /**\n      * @throws IOException on IO error\n      */\n     public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n-        ByteBuffer byteData = readToByteBuffer(in);\n-        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n+        return parseInputStream(in, charsetName, baseUri, Parser.htmlParser());\n     }\n \n     /**\n      * @throws IOException on IO error\n      */\n     public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n-        ByteBuffer byteData = readToByteBuffer(in);\n-        return parseByteData(byteData, charsetName, baseUri, parser);\n+        return parseInputStream(in, charsetName, baseUri, parser);\n     }\n \n     /**\n         }\n     }\n \n-    // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n-    // switching the chartset midstream when a meta http-equiv tag defines the charset.\n-    // todo - this is getting gnarly. needs a rewrite.\n-    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n-        String docData;\n+    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n+        if (input == null) // empty body\n+            return new Document(baseUri);\n+\n+        if (!(input instanceof ConstrainableInputStream))\n+            input = new ConstrainableInputStream(input, bufferSize, 0);\n+\n         Document doc = null;\n+        boolean fullyRead = false;\n+\n+        // read the start of the stream and look for a BOM or meta charset\n+        input.mark(firstReadBufferSize);\n+        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed\n+        fullyRead = input.read() == -1;\n+        input.reset();\n \n         // look for BOM - overrides any other header or input\n-        charsetName = detectCharsetFromBom(byteData, charsetName);\n+        BomCharset bomCharset = detectCharsetFromBom(firstBytes, charsetName);\n+        if (bomCharset != null) {\n+            charsetName = bomCharset.charset;\n+            input.skip(bomCharset.offset);\n+        }\n \n         if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n+            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n+            doc = parser.parseInput(docData, baseUri);\n+\n             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n-            docData = Charset.forName(defaultCharset).decode(byteData).toString();\n-            doc = parser.parseInput(docData, baseUri);\n             Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n             String foundCharset = null; // if not found, will keep utf-8 as best attempt\n             for (Element meta : metaElements) {\n-                if (meta.hasAttr(\"http-equiv\")) {\n+                if (meta.hasAttr(\"http-equiv\"))\n                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-                }\n-                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n+                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                     foundCharset = meta.attr(\"charset\");\n-                }\n-                if (foundCharset != null) {\n+                if (foundCharset != null)\n                     break;\n-                }\n             }\n \n             // look for <?xml encoding='ISO-8859-1'?>\n             if (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\n                 XmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\n-                if (prolog.name().equals(\"xml\")) {\n+                if (prolog.name().equals(\"xml\"))\n                     foundCharset = prolog.attr(\"encoding\");\n-                }\n             }\n             foundCharset = validateCharset(foundCharset);\n             if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                 foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                 charsetName = foundCharset;\n-                byteData.rewind();\n-                docData = Charset.forName(foundCharset).decode(byteData).toString();\n+                doc = null;\n+            } else if (!fullyRead) {\n                 doc = null;\n             }\n         } else { // specified by content type header (or by user on file load)\n             Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n-            docData = Charset.forName(charsetName).decode(byteData).toString();\n         }\n         if (doc == null) {\n-            doc = parser.parseInput(docData, baseUri);\n+            if (charsetName == null)\n+                charsetName = defaultCharset;\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n+            doc = parser.parseInput(reader, baseUri);\n             doc.outputSettings().charset(charsetName);\n         }\n+        input.close();\n         return doc;\n     }\n \n     public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\n         Validate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\n         final boolean capped = maxSize > 0;\n-        byte[] buffer = new byte[capped && maxSize < bufferSize ? maxSize : bufferSize];\n-        ByteArrayOutputStream outStream = new ByteArrayOutputStream(capped ? maxSize : bufferSize);\n+        final byte[] buffer = new byte[capped && maxSize < bufferSize ? maxSize : bufferSize];\n+        final ByteArrayOutputStream outStream = new ByteArrayOutputStream(capped ? maxSize : bufferSize);\n+\n         int read;\n         int remaining = maxSize;\n \n-        while (!Thread.interrupted()) {\n+        while (true) {\n             read = inStream.read(buffer);\n             if (read == -1) break;\n             if (capped) {\n-                if (read > remaining) {\n+                if (read >= remaining) {\n                     outStream.write(buffer, 0, remaining);\n                     break;\n                 }\n             }\n             outStream.write(buffer, 0, read);\n         }\n-\n         return ByteBuffer.wrap(outStream.toByteArray());\n     }\n \n         return mime.toString();\n     }\n \n-    private static String detectCharsetFromBom(ByteBuffer byteData, String charsetName) {\n+    private static BomCharset detectCharsetFromBom(final ByteBuffer byteData, final String charsetName) {\n         byteData.mark();\n         byte[] bom = new byte[4];\n         if (byteData.remaining() >= bom.length) {\n         }\n         if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\n             bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\n-            charsetName = \"UTF-32\"; // and I hope it's on your system\n+            return new BomCharset(\"UTF-32\", 0); // and I hope it's on your system\n         } else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE\n             bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\n-            charsetName = \"UTF-16\"; // in all Javas\n+            return new BomCharset(\"UTF-16\", 0); // in all Javas\n         } else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\n-            charsetName = \"UTF-8\"; // in all Javas\n-            byteData.position(3); // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed here\n-        }\n-        return charsetName;\n+            return new BomCharset(\"UTF-8\", 3); // in all Javas\n+            // 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed here\n+        }\n+        return null;\n+    }\n+\n+    private static class BomCharset {\n+        private final String charset;\n+        private final int offset;\n+\n+        public BomCharset(String charset, int offset) {\n+            this.charset = charset;\n+            this.offset = offset;\n+        }\n     }\n }\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n package org.jsoup.helper;\n \n-import org.jsoup.*;\n+import org.jsoup.Connection;\n+import org.jsoup.HttpStatusException;\n+import org.jsoup.UncheckedIOException;\n+import org.jsoup.UnsupportedMimeTypeException;\n+import org.jsoup.internal.ConstrainableInputStream;\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n \n-import javax.net.ssl.*;\n-import java.io.*;\n-import java.net.*;\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+import java.io.BufferedWriter;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.UnsupportedEncodingException;\n+import java.net.HttpURLConnection;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.Proxy;\n+import java.net.URI;\n+import java.net.URL;\n+import java.net.URLEncoder;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n import java.nio.charset.IllegalCharsetNameException;\n import java.security.KeyManagementException;\n import java.security.NoSuchAlgorithmException;\n import java.security.cert.X509Certificate;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n import java.util.regex.Pattern;\n import java.util.zip.GZIPInputStream;\n \n  * @see org.jsoup.Jsoup#connect(String)\n  */\n public class HttpConnection implements Connection {\n-    public static final String  CONTENT_ENCODING = \"Content-Encoding\";\n+    public static final String CONTENT_ENCODING = \"Content-Encoding\";\n     /**\n      * Many users would get caught by not setting a user-agent and therefore getting different responses on their desktop\n      * vs in jsoup, which would otherwise default to {@code Java}. So by default, use a desktop UA.\n         }\n \t}\n \n-\tprivate static URL encodeUrl(URL u) {\n+    static URL encodeUrl(URL u) {\n         try {\n             //  odd way to encode urls, but it works!\n-            final URI uri = new URI(u.toExternalForm());\n+            String urlS = u.toExternalForm(); // URL external form may have spaces which is illegal in new URL() (odd asymmetry)\n+            urlS = urlS.replaceAll(\" \", \"%20\");\n+            final URI uri = new URI(urlS);\n             return new URL(uri.toASCIIString());\n         } catch (Exception e) {\n             return u;\n         private int statusCode;\n         private String statusMessage;\n         private ByteBuffer byteData;\n+        private InputStream bodyStream;\n         private String charset;\n         private String contentType;\n         private boolean executed = false;\n+        private boolean inputStreamRead = false;\n         private int numRedirects = 0;\n         private Connection.Request req;\n \n \n                 res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n                 if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n-                    InputStream bodyStream = null;\n-                    try {\n-                        bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n-                        if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n-                            bodyStream = new GZIPInputStream(bodyStream);\n-\n-                        res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n-                    } finally {\n-                        if (bodyStream != null) bodyStream.close();\n-                    }\n+                    res.bodyStream = null;\n+                    res.bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n+                    if (res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\"))\n+                        res.bodyStream = new GZIPInputStream(res.bodyStream);\n+                    res.bodyStream = new ConstrainableInputStream(res.bodyStream, DataUtil.bufferSize, req.maxBodySize());\n                 } else {\n                     res.byteData = DataUtil.emptyByteBuffer();\n                 }\n-            } finally {\n+            } catch (IOException e){\n                 // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                 // connection errors will not be released quickly enough and can cause a too many open files error.\n                 conn.disconnect();\n+                throw e;\n             }\n \n             res.executed = true;\n \n         public Document parse() throws IOException {\n             Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before parsing response\");\n-            Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm(), req.parser());\n-            byteData.rewind();\n+            if (byteData != null) { // bytes have been read in to the buffer, parse that\n+                bodyStream = new ByteArrayInputStream(byteData.array());\n+                inputStreamRead = false; // ok to reparse if in bytes\n+            }\n+            Validate.isFalse(inputStreamRead, \"Input stream already read and parsed, cannot re-read.\");\n+            Document doc = DataUtil.parseInputStream(bodyStream, charset, url.toExternalForm(), req.parser());\n             charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n+            // todo - disconnect here?\n+            inputStreamRead = true;\n             return doc;\n         }\n \n+        private void prepareByteData() {\n+            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n+            if (byteData == null) {\n+                Validate.isFalse(inputStreamRead, \"Request has already been read (with .parse())\");\n+                try {\n+                    byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }\n+        }\n+\n         public String body() {\n-            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n+            prepareByteData();\n             // charset gets set from header on execute, and from meta-equiv on parse. parse may not have happened yet\n             String body;\n             if (charset == null)\n         }\n \n         public byte[] bodyAsBytes() {\n-            Validate.isTrue(executed, \"Request must be executed (with .execute(), .get(), or .post() before getting response body\");\n+            prepareByteData();\n             return byteData.array();\n         }\n \n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n             for (Attribute attribute : source.attributes()) {\n                 // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n                 String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n-                if (key.matches(\"[a-zA-Z_:]{1}[-a-zA-Z0-9_:.]*\"))\n+                if (key.matches(\"[a-zA-Z_:][-a-zA-Z0-9_:.]*\"))\n                     el.setAttribute(key, attribute.getValue());\n             }\n         }\n--- /dev/null\n+++ b/src/main/java/org/jsoup/internal/ConstrainableInputStream.java\n+package org.jsoup.internal;\n+\n+import org.jsoup.helper.Validate;\n+\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+/**\n+ * A jsoup internal class (so don't use it as there is no contract API) that enables constraints on an Input Stream,\n+ * namely a maximum read size, and the ability to Thread.interrupt() the read.\n+ */\n+public final class ConstrainableInputStream extends BufferedInputStream {\n+    private final boolean capped;\n+    private int remaining;\n+\n+    public ConstrainableInputStream(InputStream in, int bufferSize, int maxSize) {\n+        super(in, bufferSize);\n+        Validate.isTrue(maxSize >= 0);\n+        remaining = maxSize;\n+        capped = maxSize != 0;\n+    }\n+\n+    @Override\n+    public int read(byte[] b, int off, int len) throws IOException {\n+        if (Thread.interrupted() || remaining < 0)\n+            return -1;\n+\n+        final int read = super.read(b, off, len);\n+        if (capped) {\n+            remaining -= read;\n+        }\n+        return read;\n+    }\n+}\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n package org.jsoup.nodes;\n \n import org.jsoup.SerializationException;\n-import org.jsoup.helper.DataUtil;\n import org.jsoup.helper.StringUtil;\n+import org.jsoup.helper.Validate;\n import org.jsoup.parser.CharacterReader;\n import org.jsoup.parser.Parser;\n \n+import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.nio.ByteBuffer;\n+import java.io.InputStreamReader;\n import java.nio.charset.Charset;\n import java.nio.charset.CharsetEncoder;\n import java.util.Arrays;\n     private static final int empty = -1;\n     private static final String emptyName = \"\";\n     static final int codepointRadix = 36;\n+    private static final Charset ASCII = Charset.forName(\"ascii\");\n \n     public enum EscapeMode {\n         /**\n             throw new IllegalStateException(\"Could not read resource \" + file + \". Make sure you copy resources for \" + Entities.class.getCanonicalName());\n \n         int i = 0;\n-        try {\n-            ByteBuffer bytes = DataUtil.readToByteBuffer(stream, 0);\n-            String contents = Charset.forName(\"ascii\").decode(bytes).toString();\n-            CharacterReader reader = new CharacterReader(contents);\n-\n-            while (!reader.isEmpty()) {\n-                // NotNestedLessLess=10913,824;1887\n-\n-                final String name = reader.consumeTo('=');\n+        BufferedReader input = new BufferedReader(new InputStreamReader(stream, ASCII));\n+        CharacterReader reader = new CharacterReader(input);\n+\n+        while (!reader.isEmpty()) {\n+            // NotNestedLessLess=10913,824;1887\n+\n+            final String name = reader.consumeTo('=');\n+            reader.advance();\n+            final int cp1 = Integer.parseInt(reader.consumeToAny(codeDelims), codepointRadix);\n+            final char codeDelim = reader.current();\n+            reader.advance();\n+            final int cp2;\n+            if (codeDelim == ',') {\n+                cp2 = Integer.parseInt(reader.consumeTo(';'), codepointRadix);\n                 reader.advance();\n-                final int cp1 = Integer.parseInt(reader.consumeToAny(codeDelims), codepointRadix);\n-                final char codeDelim = reader.current();\n-                reader.advance();\n-                final int cp2;\n-                if (codeDelim == ',') {\n-                    cp2 = Integer.parseInt(reader.consumeTo(';'), codepointRadix);\n-                    reader.advance();\n-                } else {\n-                    cp2 = empty;\n-                }\n-                String indexS = reader.consumeTo('\\n');\n-                // default git checkout on windows will add a \\r there, so remove\n-                if (indexS.charAt(indexS.length() - 1) == '\\r') {\n-                    indexS = indexS.substring(0, indexS.length() - 1);\n-                }\n-                final int index = Integer.parseInt(indexS, codepointRadix);\n-                reader.advance();\n-\n-                e.nameKeys[i] = name;\n-                e.codeVals[i] = cp1;\n-                e.codeKeys[index] = cp1;\n-                e.nameVals[index] = name;\n-\n-                if (cp2 != empty) {\n-                    multipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\n-                }\n-                i++;\n-\n-\n-            }\n-        } catch (IOException err) {\n-            throw new IllegalStateException(\"Error reading resource \" + file);\n-        }\n+            } else {\n+                cp2 = empty;\n+            }\n+            String indexS = reader.consumeTo('\\n');\n+            // default git checkout on windows will add a \\r there, so remove\n+            if (indexS.charAt(indexS.length() - 1) == '\\r') {\n+                indexS = indexS.substring(0, indexS.length() - 1);\n+            }\n+            final int index = Integer.parseInt(indexS, codepointRadix);\n+            reader.advance();\n+\n+            e.nameKeys[i] = name;\n+            e.codeVals[i] = cp1;\n+            e.codeKeys[index] = cp1;\n+            e.nameVals[index] = name;\n+\n+            if (cp2 != empty) {\n+                multipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\n+            }\n+            i++;\n+        }\n+        Validate.isTrue(i == size, \"Unexpected count of entities loaded for \" + file);\n     }\n }\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n package org.jsoup.parser;\n \n+import org.jsoup.UncheckedIOException;\n import org.jsoup.helper.Validate;\n \n+import java.io.IOException;\n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.Arrays;\n import java.util.Locale;\n \n  */\n public final class CharacterReader {\n     static final char EOF = (char) -1;\n-    private static final int maxCacheLen = 12;\n-\n-    private final char[] input;\n-    private final int length;\n-    private int pos = 0;\n-    private int mark = 0;\n+    private static final int maxStringCacheLen = 12;\n+    private static final int maxBufferLen = 1024 * 32;\n+    private static final int readAheadLimit = (int) (maxBufferLen * 0.75);\n+\n+    private final char[] charBuf;\n+    private final Reader reader;\n+    private int bufLength;\n+    private int bufSplitPoint;\n+    private int bufPos;\n+    private int readerPos;\n+    private int bufMark;\n     private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n \n+    public CharacterReader(Reader input, int sz) {\n+        Validate.notNull(input);\n+        Validate.isTrue(input.markSupported());\n+        reader = input;\n+        charBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\n+        bufferUp();\n+    }\n+\n+    public CharacterReader(Reader input) {\n+        this(input, maxBufferLen);\n+    }\n+\n     public CharacterReader(String input) {\n-        Validate.notNull(input);\n-        this.input = input.toCharArray();\n-        this.length = this.input.length;\n+        this(new StringReader(input), input.length());\n+    }\n+\n+    private void bufferUp() {\n+        if (bufPos < bufSplitPoint)\n+            return;\n+\n+        try {\n+            readerPos += bufPos;\n+            reader.skip(bufPos);\n+            reader.mark(maxBufferLen);\n+            bufLength = reader.read(charBuf);\n+            reader.reset();\n+            bufPos = 0;\n+            bufMark = 0;\n+            bufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n     }\n \n     /**\n      * @return current position\n      */\n     public int pos() {\n-        return pos;\n+        return readerPos + bufPos;\n     }\n \n     /**\n      * @return true if nothing left to read.\n      */\n     public boolean isEmpty() {\n-        return pos >= length;\n+        return bufPos >= bufLength;\n     }\n \n     /**\n      * @return char\n      */\n     public char current() {\n-        return pos >= length ? EOF : input[pos];\n+        bufferUp();\n+        return isEmpty() ? EOF : charBuf[bufPos];\n     }\n \n     char consume() {\n-        char val = pos >= length ? EOF : input[pos];\n-        pos++;\n+        bufferUp();\n+        char val = isEmpty() ? EOF : charBuf[bufPos];\n+        bufPos++;\n         return val;\n     }\n \n     void unconsume() {\n-        pos--;\n+        bufPos--;\n     }\n \n     /**\n      * Moves the current position by one.\n      */\n     public void advance() {\n-        pos++;\n+        bufPos++;\n     }\n \n     void mark() {\n-        mark = pos;\n+        bufMark = bufPos;\n     }\n \n     void rewindToMark() {\n-        pos = mark;\n-    }\n-\n-    String consumeAsString() {\n-        return new String(input, pos++, 1);\n+        bufPos = bufMark;\n     }\n \n     /**\n      */\n     int nextIndexOf(char c) {\n         // doesn't handle scanning for surrogates\n-        for (int i = pos; i < length; i++) {\n-            if (c == input[i])\n-                return i - pos;\n+        bufferUp();\n+        for (int i = bufPos; i < bufLength; i++) {\n+            if (c == charBuf[i])\n+                return i - bufPos;\n         }\n         return -1;\n     }\n      * @return offset between current position and next instance of target. -1 if not found.\n      */\n     int nextIndexOf(CharSequence seq) {\n+        bufferUp();\n         // doesn't handle scanning for surrogates\n         char startChar = seq.charAt(0);\n-        for (int offset = pos; offset < length; offset++) {\n+        for (int offset = bufPos; offset < bufLength; offset++) {\n             // scan to first instance of startchar:\n-            if (startChar != input[offset])\n-                while(++offset < length && startChar != input[offset]) { /* empty */ }\n+            if (startChar != charBuf[offset])\n+                while(++offset < bufLength && startChar != charBuf[offset]) { /* empty */ }\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length && last <= length) {\n-                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) { /* empty */ }\n+            if (offset < bufLength && last <= bufLength) {\n+                for (int j = 1; i < last && seq.charAt(j) == charBuf[i]; i++, j++) { /* empty */ }\n                 if (i == last) // found full sequence\n-                    return offset - pos;\n+                    return offset - bufPos;\n             }\n         }\n         return -1;\n     public String consumeTo(char c) {\n         int offset = nextIndexOf(c);\n         if (offset != -1) {\n-            String consumed = cacheString(pos, offset);\n-            pos += offset;\n+            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n+            bufPos += offset;\n             return consumed;\n         } else {\n             return consumeToEnd();\n     String consumeTo(String seq) {\n         int offset = nextIndexOf(seq);\n         if (offset != -1) {\n-            String consumed = cacheString(pos, offset);\n-            pos += offset;\n+            String consumed = cacheString(charBuf, stringCache, bufPos, offset);\n+            bufPos += offset;\n             return consumed;\n         } else {\n             return consumeToEnd();\n      * @return characters read up to the matched delimiter.\n      */\n     public String consumeToAny(final char... chars) {\n-        final int start = pos;\n-        final int remaining = length;\n-        final char[] val = input;\n-\n-        OUTER: while (pos < remaining) {\n+        bufferUp();\n+        final int start = bufPos;\n+        final int remaining = bufLength;\n+        final char[] val = charBuf;\n+\n+        OUTER: while (bufPos < remaining) {\n             for (char c : chars) {\n-                if (val[pos] == c)\n+                if (val[bufPos] == c)\n                     break OUTER;\n             }\n-            pos++;\n-        }\n-\n-        return pos > start ? cacheString(start, pos-start) : \"\";\n+            bufPos++;\n+        }\n+\n+        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n     }\n \n     String consumeToAnySorted(final char... chars) {\n-        final int start = pos;\n-        final int remaining = length;\n-        final char[] val = input;\n-\n-        while (pos < remaining) {\n-            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n-                break;\n-            pos++;\n-        }\n-\n-        return pos > start ? cacheString(start, pos-start) : \"\";\n+        bufferUp();\n+        final int start = bufPos;\n+        final int remaining = bufLength;\n+        final char[] val = charBuf;\n+\n+        while (bufPos < remaining) {\n+            if (Arrays.binarySearch(chars, val[bufPos]) >= 0)\n+                break;\n+            bufPos++;\n+        }\n+\n+        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n     }\n \n     String consumeData() {\n         // &, <, null\n-        final int start = pos;\n-        final int remaining = length;\n-        final char[] val = input;\n-\n-        while (pos < remaining) {\n-            final char c = val[pos];\n+        bufferUp();\n+        final int start = bufPos;\n+        final int remaining = bufLength;\n+        final char[] val = charBuf;\n+\n+        while (bufPos < remaining) {\n+            final char c = val[bufPos];\n             if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n                 break;\n-            pos++;\n-        }\n-\n-        return pos > start ? cacheString(start, pos-start) : \"\";\n+            bufPos++;\n+        }\n+\n+        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n     }\n \n     String consumeTagName() {\n         // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n-        final int start = pos;\n-        final int remaining = length;\n-        final char[] val = input;\n-\n-        while (pos < remaining) {\n-            final char c = val[pos];\n+        bufferUp();\n+        final int start = bufPos;\n+        final int remaining = bufLength;\n+        final char[] val = charBuf;\n+\n+        while (bufPos < remaining) {\n+            final char c = val[bufPos];\n             if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n                 break;\n-            pos++;\n-        }\n-\n-        return pos > start ? cacheString(start, pos-start) : \"\";\n+            bufPos++;\n+        }\n+\n+        return bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n     }\n \n     String consumeToEnd() {\n-        String data = cacheString(pos, length-pos);\n-        pos = length;\n+        bufferUp();\n+        String data = cacheString(charBuf, stringCache, bufPos, bufLength - bufPos);\n+        bufPos = bufLength;\n         return data;\n     }\n \n     String consumeLetterSequence() {\n-        int start = pos;\n-        while (pos < length) {\n-            char c = input[pos];\n+        bufferUp();\n+        int start = bufPos;\n+        while (bufPos < bufLength) {\n+            char c = charBuf[bufPos];\n             if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n-                pos++;\n+                bufPos++;\n             else\n                 break;\n         }\n \n-        return cacheString(start, pos - start);\n+        return cacheString(charBuf, stringCache, start, bufPos - start);\n     }\n \n     String consumeLetterThenDigitSequence() {\n-        int start = pos;\n-        while (pos < length) {\n-            char c = input[pos];\n+        bufferUp();\n+        int start = bufPos;\n+        while (bufPos < bufLength) {\n+            char c = charBuf[bufPos];\n             if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\n-                pos++;\n+                bufPos++;\n             else\n                 break;\n         }\n         while (!isEmpty()) {\n-            char c = input[pos];\n+            char c = charBuf[bufPos];\n             if (c >= '0' && c <= '9')\n-                pos++;\n+                bufPos++;\n             else\n                 break;\n         }\n \n-        return cacheString(start, pos - start);\n+        return cacheString(charBuf, stringCache, start, bufPos - start);\n     }\n \n     String consumeHexSequence() {\n-        int start = pos;\n-        while (pos < length) {\n-            char c = input[pos];\n+        bufferUp();\n+        int start = bufPos;\n+        while (bufPos < bufLength) {\n+            char c = charBuf[bufPos];\n             if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f'))\n-                pos++;\n+                bufPos++;\n             else\n                 break;\n         }\n-        return cacheString(start, pos - start);\n+        return cacheString(charBuf, stringCache, start, bufPos - start);\n     }\n \n     String consumeDigitSequence() {\n-        int start = pos;\n-        while (pos < length) {\n-            char c = input[pos];\n+        bufferUp();\n+        int start = bufPos;\n+        while (bufPos < bufLength) {\n+            char c = charBuf[bufPos];\n             if (c >= '0' && c <= '9')\n-                pos++;\n+                bufPos++;\n             else\n                 break;\n         }\n-        return cacheString(start, pos - start);\n+        return cacheString(charBuf, stringCache, start, bufPos - start);\n     }\n \n     boolean matches(char c) {\n-        return !isEmpty() && input[pos] == c;\n+        return !isEmpty() && charBuf[bufPos] == c;\n \n     }\n \n     boolean matches(String seq) {\n+        bufferUp();\n         int scanLength = seq.length();\n-        if (scanLength > length - pos)\n+        if (scanLength > bufLength - bufPos)\n             return false;\n \n         for (int offset = 0; offset < scanLength; offset++)\n-            if (seq.charAt(offset) != input[pos+offset])\n+            if (seq.charAt(offset) != charBuf[bufPos +offset])\n                 return false;\n         return true;\n     }\n \n     boolean matchesIgnoreCase(String seq) {\n+        bufferUp();\n         int scanLength = seq.length();\n-        if (scanLength > length - pos)\n+        if (scanLength > bufLength - bufPos)\n             return false;\n \n         for (int offset = 0; offset < scanLength; offset++) {\n             char upScan = Character.toUpperCase(seq.charAt(offset));\n-            char upTarget = Character.toUpperCase(input[pos + offset]);\n+            char upTarget = Character.toUpperCase(charBuf[bufPos + offset]);\n             if (upScan != upTarget)\n                 return false;\n         }\n         if (isEmpty())\n             return false;\n \n-        char c = input[pos];\n+        bufferUp();\n+        char c = charBuf[bufPos];\n         for (char seek : seq) {\n             if (seek == c)\n                 return true;\n     }\n \n     boolean matchesAnySorted(char[] seq) {\n-        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n+        bufferUp();\n+        return !isEmpty() && Arrays.binarySearch(seq, charBuf[bufPos]) >= 0;\n     }\n \n     boolean matchesLetter() {\n         if (isEmpty())\n             return false;\n-        char c = input[pos];\n+        char c = charBuf[bufPos];\n         return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n     }\n \n     boolean matchesDigit() {\n         if (isEmpty())\n             return false;\n-        char c = input[pos];\n+        char c = charBuf[bufPos];\n         return (c >= '0' && c <= '9');\n     }\n \n     boolean matchConsume(String seq) {\n+        bufferUp();\n         if (matches(seq)) {\n-            pos += seq.length();\n+            bufPos += seq.length();\n             return true;\n         } else {\n             return false;\n \n     boolean matchConsumeIgnoreCase(String seq) {\n         if (matchesIgnoreCase(seq)) {\n-            pos += seq.length();\n+            bufPos += seq.length();\n             return true;\n         } else {\n             return false;\n \n     @Override\n     public String toString() {\n-        return new String(input, pos, length - pos);\n+        return new String(charBuf, bufPos, bufLength - bufPos);\n     }\n \n     /**\n      * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n      * some more duplicates.\n      */\n-    private String cacheString(final int start, final int count) {\n-        final char[] val = input;\n-        final String[] cache = stringCache;\n-\n+    private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n         // limit (no cache):\n-        if (count > maxCacheLen)\n-            return new String(val, start, count);\n+        if (count > maxStringCacheLen)\n+            return new String(charBuf, start, count);\n \n         // calculate hash:\n         int hash = 0;\n         int offset = start;\n         for (int i = 0; i < count; i++) {\n-            hash = 31 * hash + val[offset++];\n+            hash = 31 * hash + charBuf[offset++];\n         }\n \n         // get from cache\n-        final int index = hash & cache.length - 1;\n-        String cached = cache[index];\n+        final int index = hash & stringCache.length - 1;\n+        String cached = stringCache[index];\n \n         if (cached == null) { // miss, add\n-            cached = new String(val, start, count);\n-            cache[index] = cached;\n+            cached = new String(charBuf, start, count);\n+            stringCache[index] = cached;\n         } else { // hashcode hit, check equality\n-            if (rangeEquals(start, count, cached)) { // hit\n+            if (rangeEquals(charBuf, start, count, cached)) { // hit\n                 return cached;\n             } else { // hashcode conflict\n-                cached = new String(val, start, count);\n-                cache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n+                cached = new String(charBuf, start, count);\n+                stringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n             }\n         }\n         return cached;\n     /**\n      * Check if the value of the provided range equals the string.\n      */\n-    boolean rangeEquals(final int start, int count, final String cached) {\n+    static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\n         if (count == cached.length()) {\n-            char one[] = input;\n             int i = start;\n             int j = 0;\n             while (count-- != 0) {\n-                if (one[i++] != cached.charAt(j++))\n+                if (charBuf[i++] != cached.charAt(j++))\n                     return false;\n             }\n             return true;\n         }\n         return false;\n     }\n+\n+    // just used for testing\n+    boolean rangeEquals(final int start, final int count, final String cached) {\n+        return rangeEquals(charBuf, start, count, cached);\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n import org.jsoup.nodes.TextNode;\n import org.jsoup.select.Elements;\n \n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.ArrayList;\n import java.util.List;\n \n     }\n \n     @Override\n-    protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         super.initialiseParse(input, baseUri, errors, settings);\n \n         // this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\n     List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         // context may be null\n         state = HtmlTreeBuilderState.Initial;\n-        initialiseParse(inputFragment, baseUri, errors, settings);\n+        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n         contextElement = context;\n         fragmentParsing = true;\n         Element root = null;\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n \n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.List;\n \n /**\n     \n     public Document parseInput(String html, String baseUri) {\n         errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n-        return treeBuilder.parse(html, baseUri, errors, settings);\n+        return treeBuilder.parse(new StringReader(html), baseUri, errors, settings);\n+    }\n+\n+    public Document parseInput(Reader inputHtml, String baseUri) {\n+        errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n+        return treeBuilder.parse(inputHtml, baseUri, errors, settings);\n     }\n \n     // gets & sets\n      */\n     public static Document parse(String html, String baseUri) {\n         TreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parse(html, baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n+        return treeBuilder.parse(new StringReader(html), baseUri, ParseErrorList.noTracking(), treeBuilder.defaultSettings());\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n                 t.emit(new Token.EOF());\n                 break;\n             default:\n-                String data = r.consumeToAny('<', nullChar);\n+                String data = r.consumeToAny('<', nullChar); // todo - why hunt for null here? Just consumeTo'<'?\n                 t.emit(data);\n                 break;\n         }\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n \n+import java.io.Reader;\n import java.util.ArrayList;\n \n /**\n \n     abstract ParseSettings defaultSettings();\n \n-    protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         Validate.notNull(input, \"String input must not be null\");\n         Validate.notNull(baseUri, \"BaseURI must not be null\");\n \n         this.baseUri = baseUri;\n     }\n \n-    Document parse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+    Document parse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         initialiseParse(input, baseUri, errors, settings);\n         runParser();\n         return doc;\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n \n+import java.io.Reader;\n+import java.io.StringReader;\n import java.util.List;\n \n /**\n         return ParseSettings.preserveCase;\n     }\n \n-    Document parse(String input, String baseUri) {\n+    Document parse(Reader input, String baseUri) {\n         return parse(input, baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n     }\n \n+    Document parse(String input, String baseUri) {\n+        return parse(new StringReader(input), baseUri, ParseErrorList.noTracking(), ParseSettings.preserveCase);\n+    }\n+\n     @Override\n-    protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n+    protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\n         super.initialiseParse(input, baseUri, errors, settings);\n         stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n         doc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n     }\n \n     List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors, ParseSettings settings) {\n-        initialiseParse(inputFragment, baseUri, errors, settings);\n+        initialiseParse(new StringReader(inputFragment), baseUri, errors, settings);\n         runParser();\n         return doc.childNodes();\n     }\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n     }\n     \n     //pseudo selectors :first-child, :last-child, :nth-child, ...\n-    private static final Pattern NTH_AB = Pattern.compile(\"((\\\\+|-)?(\\\\d+)?)n(\\\\s*(\\\\+|-)?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE);\n-    private static final Pattern NTH_B  = Pattern.compile(\"(\\\\+|-)?(\\\\d+)\");\n+    private static final Pattern NTH_AB = Pattern.compile(\"(([+-])?(\\\\d+)?)n(\\\\s*([+-])?\\\\s*\\\\d+)?\", Pattern.CASE_INSENSITIVE);\n+    private static final Pattern NTH_B  = Pattern.compile(\"([+-])?(\\\\d+)\");\n \n \tprivate void cssNthChild(boolean backwards, boolean ofType) {\n \t\tString argS = normalize(tq.chompTo(\")\"));\n--- a/src/test/java/org/jsoup/helper/DataUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/DataUtilTest.java\n package org.jsoup.helper;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.UnsupportedEncodingException;\n \n import org.jsoup.Jsoup;\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.junit.Test;\n \n-import java.nio.ByteBuffer;\n-import java.nio.charset.Charset;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n \n import static org.jsoup.integration.ParseTest.getFile;\n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n \n public class DataUtilTest {\n     @Test\n         assertEquals(\"UTF-8\", DataUtil.getCharsetFromContentType(\"text/html; charset='UTF-8'\"));\n     }\n \n-    @Test public void discardsSpuriousByteOrderMark() {\n+    private InputStream stream(String data) {\n+        return new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));\n+    }\n+\n+    private InputStream stream(String data, String charset) {\n+        try {\n+            return new ByteArrayInputStream(data.getBytes(charset));\n+        } catch (UnsupportedEncodingException e) {\n+            fail();\n+        }\n+        return null;\n+    }\n+\n+    @Test public void discardsSpuriousByteOrderMark() throws IOException {\n         String html = \"\\uFEFF<html><head><title>One</title></head><body>Two</body></html>\";\n-        ByteBuffer buffer = Charset.forName(\"UTF-8\").encode(html);\n-        Document doc = DataUtil.parseByteData(buffer, \"UTF-8\", \"http://foo.com/\", Parser.htmlParser());\n+        Document doc = DataUtil.parseInputStream(stream(html), \"UTF-8\", \"http://foo.com/\", Parser.htmlParser());\n         assertEquals(\"One\", doc.head().text());\n     }\n \n-    @Test public void discardsSpuriousByteOrderMarkWhenNoCharsetSet() {\n+    @Test public void discardsSpuriousByteOrderMarkWhenNoCharsetSet() throws IOException {\n         String html = \"\\uFEFF<html><head><title>One</title></head><body>Two</body></html>\";\n-        ByteBuffer buffer = Charset.forName(\"UTF-8\").encode(html);\n-        Document doc = DataUtil.parseByteData(buffer, null, \"http://foo.com/\", Parser.htmlParser());\n+        Document doc = DataUtil.parseInputStream(stream(html), null, \"http://foo.com/\", Parser.htmlParser());\n         assertEquals(\"One\", doc.head().text());\n         assertEquals(\"UTF-8\", doc.outputSettings().charset().displayName());\n     }\n     }\n     \n     @Test\n-    public void wrongMetaCharsetFallback() {\n-        try {\n-            final byte[] input = \"<html><head><meta charset=iso-8></head><body></body></html>\".getBytes(\"UTF-8\");\n-            final ByteBuffer inBuffer = ByteBuffer.wrap(input);\n-            \n-            Document doc = DataUtil.parseByteData(inBuffer, null, \"http://example.com\", Parser.htmlParser());\n-            \n-            final String expected = \"<html>\\n\" +\n-                                    \" <head>\\n\" +\n-                                    \"  <meta charset=\\\"iso-8\\\">\\n\" +\n-                                    \" </head>\\n\" +\n-                                    \" <body></body>\\n\" +\n-                                    \"</html>\";\n-            \n-            assertEquals(expected, doc.toString());\n-        } catch( UnsupportedEncodingException ex ) {\n-            fail(ex.getMessage());\n-        }\n+    public void wrongMetaCharsetFallback() throws IOException {\n+        String html = \"<html><head><meta charset=iso-8></head><body></body></html>\";\n+\n+        Document doc = DataUtil.parseInputStream(stream(html), null, \"http://example.com\", Parser.htmlParser());\n+\n+        final String expected = \"<html>\\n\" +\n+            \" <head>\\n\" +\n+            \"  <meta charset=\\\"iso-8\\\">\\n\" +\n+            \" </head>\\n\" +\n+            \" <body></body>\\n\" +\n+            \"</html>\";\n+\n+        assertEquals(expected, doc.toString());\n     }\n \n     @Test\n     public void secondMetaElementWithContentTypeContainsCharsetParameter() throws Exception {\n-        ByteBuffer inBuffer = ByteBuffer.wrap((\"<html><head>\" +\n+        String html = \"<html><head>\" +\n                 \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html\\\">\" +\n                 \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=euc-kr\\\">\" +\n-                \"</head><body>\ud55c\uad6d\uc5b4</body></html>\").getBytes(\"euc-kr\"));\n+                \"</head><body>\ud55c\uad6d\uc5b4</body></html>\";\n \n-        Document doc = DataUtil.parseByteData(inBuffer, null, \"http://example.com\", Parser.htmlParser());\n+        Document doc = DataUtil.parseInputStream(stream(html, \"euc-kr\"), null, \"http://example.com\", Parser.htmlParser());\n \n         assertEquals(\"\ud55c\uad6d\uc5b4\", doc.body().text());\n     }\n \n     @Test\n     public void firstMetaElementWithCharsetShouldBeUsedForDecoding() throws Exception {\n-        ByteBuffer inBuffer = ByteBuffer.wrap((\"<html><head>\" +\n+        String html = \"<html><head>\" +\n                 \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=iso-8859-1\\\">\" +\n                 \"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=koi8-u\\\">\" +\n-                \"</head><body>\u00dcbergr\u00f6\u00dfentr\u00e4ger</body></html>\").getBytes(\"iso-8859-1\"));\n+                \"</head><body>\u00dcbergr\u00f6\u00dfentr\u00e4ger</body></html>\";\n \n-        Document doc = DataUtil.parseByteData(inBuffer, null, \"http://example.com\", Parser.htmlParser());\n+        Document doc = DataUtil.parseInputStream(stream(html, \"iso-8859-1\"), null, \"http://example.com\", Parser.htmlParser());\n \n         assertEquals(\"\u00dcbergr\u00f6\u00dfentr\u00e4ger\", doc.body().text());\n     }\n--- a/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n+++ b/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n package org.jsoup.helper;\n \n-import static org.junit.Assert.*;\n-\n+import org.jsoup.Connection;\n import org.jsoup.MultiLocaleRule;\n import org.jsoup.MultiLocaleRule.MultiLocaleTest;\n import org.jsoup.integration.ParseTest;\n import org.junit.Rule;\n import org.junit.Test;\n-import org.jsoup.Connection;\n \n import java.io.IOException;\n-import java.util.*;\n+import java.net.MalformedURLException;\n import java.net.URL;\n-import java.net.MalformedURLException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n \n public class HttpConnectionTest {\n     /* most actual network http connection tests are in integration */\n         con.requestBody(\"foo\");\n         assertEquals(\"foo\", con.request().requestBody());\n     }\n+\n+    @Test public void encodeUrl() throws MalformedURLException {\n+        URL url1 = new URL(\"http://test.com/?q=white space\");\n+        URL url2 = HttpConnection.encodeUrl(url1);\n+        assertEquals(\"http://test.com/?q=white%20space\", url2.toExternalForm());\n+    }\n }\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n @Ignore // ignored by default so tests don't require network access. comment out to enable.\n+// todo: rebuild these into a local Jetty test server, so not reliant on the vagaries of the internet.\n public class UrlConnectTest {\n     private static final String WEBSITE_WITH_INVALID_CERTIFICATE = \"https://certs.cac.washington.edu/CAtest/\";\n     private static final String WEBSITE_WITH_SNI = \"https://jsoup.org/\";\n         Connection.Response largeRes = Jsoup.connect(url).maxBodySize(300 * 1024).execute(); // does not crop\n         Connection.Response unlimitedRes = Jsoup.connect(url).maxBodySize(0).execute();\n \n-        int actualString = 280735;\n-        assertEquals(actualString, defaultRes.body().length());\n-        assertEquals(50 * 1024, smallRes.body().length());\n-        assertEquals(200 * 1024, mediumRes.body().length());\n-        assertEquals(actualString, largeRes.body().length());\n-        assertEquals(actualString, unlimitedRes.body().length());\n-\n         int actualDocText = 269541;\n         assertEquals(actualDocText, defaultRes.parse().text().length());\n-        assertEquals(49165, smallRes.parse().text().length());\n+        assertEquals(47200, smallRes.parse().text().length());\n         assertEquals(196577, mediumRes.parse().text().length());\n         assertEquals(actualDocText, largeRes.parse().text().length());\n         assertEquals(actualDocText, unlimitedRes.parse().text().length());\n         final Document doc1 = res1.parse();\n         assertEquals(\"windows-1252\", doc1.charset().displayName()); // but determined at parse time\n         assertEquals(\"Cost is \u20ac100\", doc1.select(\"p\").text());\n-        assertTrue(res1.body().contains(\"\u20ac\"));\n+        assertTrue(doc1.text().contains(\"\u20ac\"));\n \n         // no meta, no override\n         Connection.Response res2 = Jsoup.connect(noCharsetUrl).execute();\n         final Document doc2 = res2.parse();\n         assertEquals(\"UTF-8\", doc2.charset().displayName()); // so defaults to utf-8\n         assertEquals(\"Cost is \ufffd100\", doc2.select(\"p\").text());\n-        assertTrue(res2.body().contains(\"\ufffd\"));\n+        assertTrue(doc2.text().contains(\"\ufffd\"));\n \n         // no meta, let's override\n         Connection.Response res3 = Jsoup.connect(noCharsetUrl).execute();\n         final Document doc3 = res3.parse();\n         assertEquals(\"windows-1252\", doc3.charset().displayName()); // from override\n         assertEquals(\"Cost is \u20ac100\", doc3.select(\"p\").text());\n-        assertTrue(res3.body().contains(\"\u20ac\"));\n+        assertTrue(doc3.text().contains(\"\u20ac\"));\n     }\n \n     @Test\n         // if we didn't notice it was utf8, would look like: Location: /tools/test\u00f0\u009f\u0092\u00a9.html\n     }\n \n+    @Test public void handlesEscapesInRedirecct() throws IOException {\n+        Document doc = Jsoup.connect(\"http://infohound.net/tools/302-escaped.pl\").get();\n+        assertEquals(\"http://infohound.net/tools/q.pl?q=one%20two\", doc.location());\n+\n+        doc = Jsoup.connect(\"http://infohound.net/tools/302-white.pl\").get();\n+        assertEquals(\"http://infohound.net/tools/q.pl?q=one%20two\", doc.location());\n+    }\n+\n     @Test\n     public void handlesUt8fInUrl() throws IOException {\n         String url = \"http://direct.infohound.net/tools/test\\uD83D\\uDCA9.html\";\n         Connection.Response res = Jsoup.connect(\"https://ssl.souq.com/sa-en/2724288604627/s\").execute();\n         Document doc = res.parse();\n         assertEquals(\n-            \"http://saudi.souq.com/sa-en/%D8%AE%D8%B2%D9%86%D8%A9-%D8%A2%D9%85%D9%86%D8%A9-3-%D8%B7%D8%A8%D9%82%D8%A7%D8%AA-%D8%A8%D9%86%D8%B8%D8%A7%D9%85-%D9%82%D9%81%D9%84-%D8%A5%D9%84%D9%83%D8%AA%D8%B1%D9%88%D9%86%D9%8A-bsd11523-6831477/i/?ctype=dsrch\",\n+            \"https://saudi.souq.com/sa-en/%D8%AE%D8%B2%D9%86%D8%A9-%D8%A2%D9%85%D9%86%D8%A9-3-%D8%B7%D8%A8%D9%82%D8%A7%D8%AA-%D8%A8%D9%86%D8%B8%D8%A7%D9%85-%D9%82%D9%81%D9%84-%D8%A5%D9%84%D9%83%D8%AA%D8%B1%D9%88%D9%86%D9%8A-bsd11523-6831477/i/?ctype=dsrch\",\n             doc.location()\n         );\n     }\n \n-    @Test public void canInterruptRead() throws IOException, InterruptedException {\n+    @Test public void canInterruptBodyStringRead() throws IOException, InterruptedException {\n+        // todo - implement in interruptable channels, so it's immediate\n         final String[] body = new String[1];\n         Thread runner = new Thread(new Runnable() {\n             public void run() {\n                 try {\n                     Connection.Response res = Jsoup.connect(\"http://jsscxml.org/serverload.stream\")\n-                        .timeout(10 * 1000)\n+                        .timeout(15 * 1000)\n                         .execute();\n                     body[0] = res.body();\n                 } catch (IOException e) {\n         });\n \n         runner.start();\n-        Thread.sleep(1000 * 5);\n+        Thread.sleep(1000 * 7);\n+        runner.interrupt();\n+        assertTrue(runner.isInterrupted());\n+        runner.join();\n+\n+        assertTrue(body[0].length() > 0);\n+    }\n+\n+    @Test public void canInterruptDocumentRead() throws IOException, InterruptedException {\n+        // todo - implement in interruptable channels, so it's immediate\n+        final String[] body = new String[1];\n+        Thread runner = new Thread(new Runnable() {\n+            public void run() {\n+                try {\n+                    Connection.Response res = Jsoup.connect(\"http://jsscxml.org/serverload.stream\")\n+                        .timeout(15 * 1000)\n+                        .execute();\n+                    body[0] = res.parse().text();\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+\n+            }\n+        });\n+\n+        runner.start();\n+        Thread.sleep(1000 * 7);\n         runner.interrupt();\n         assertTrue(runner.isInterrupted());\n         runner.join();\n         doc = Jsoup.connect(\"http://mov-world.net/archiv/TV/A/%23No.Title/\").get();\n         assertEquals(\"Index of /archiv/TV/A/%23No.Title\", doc.title());\n     }\n+\n+    @Test(expected=IllegalArgumentException.class) public void bodyAfterParseThrowsValidationError() throws IOException {\n+        Connection.Response res = Jsoup.connect(echoURL).execute();\n+        Document doc = res.parse();\n+        String body = res.body();\n+    }\n+\n+    @Test public void bodyAndBytesAvailableBeforeParse() throws IOException {\n+        Connection.Response res = Jsoup.connect(echoURL).execute();\n+        String body = res.body();\n+        assertTrue(body.contains(\"Environment\"));\n+        byte[] bytes = res.bodyAsBytes();\n+        assertTrue(bytes.length > 100);\n+\n+        Document doc = res.parse();\n+        assertTrue(doc.title().contains(\"Environment\"));\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class) public void parseParseThrowsValidates() throws IOException {\n+        Connection.Response res = Jsoup.connect(echoURL).execute();\n+        Document doc = res.parse();\n+        assertTrue(doc.title().contains(\"Environment\"));\n+        Document doc2 = res.parse();\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n+++ b/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n         assertFalse(r.matches(\"ne Two Three Four\"));\n         assertEquals(\"ne Two Three\", r.consumeToEnd());\n         assertFalse(r.matches(\"ne\"));\n+        assertTrue(r.isEmpty());\n     }\n \n     @Test\n         assertFalse(r.rangeEquals(18, 5, \"CHIKE\"));\n     }\n \n+    @Test\n+    public void empty() {\n+        CharacterReader r = new CharacterReader(\"One\");\n+        assertTrue(r.matchConsume(\"One\"));\n+        assertTrue(r.isEmpty());\n+\n+        r = new CharacterReader(\"Two\");\n+        String two = r.consumeToEnd();\n+        assertEquals(\"Two\", two);\n+    }\n+\n \n }", "timestamp": 1498373265, "metainfo": ""}