{"sha": "aa81e10c34f48a3c4ac7160aa90ee18af4f5c0c2", "log": "Improved HTML entity support  Fixes #602, #603", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n import org.jsoup.helper.StringUtil;\n import org.jsoup.parser.Parser;\n \n+import java.io.BufferedReader;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.InputStreamReader;\n import java.nio.charset.CharsetEncoder;\n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static org.jsoup.nodes.Entities.EscapeMode.base;\n+import static org.jsoup.nodes.Entities.EscapeMode.extended;\n \n /**\n  * HTML entities, and escape routines.\n  * named character references</a>.\n  */\n public class Entities {\n+    private static Pattern entityPattern = Pattern.compile(\"^(\\\\w+)=(\\\\w+)(?:,(\\\\w+))?;(\\\\w+)$\");\n+    static final int empty = -1;\n+    static final String emptyName = \"\";\n+    static final int codepointRadix = 36;\n+\n     public enum EscapeMode {\n         /** Restricted entities suitable for XHTML output: lt, gt, amp, and quot only. */\n-        xhtml(xhtmlByVal),\n+        xhtml(\"entities-xhtml.properties\", 4),\n         /** Default HTML output entities. */\n-        base(baseByVal),\n+        base(\"entities-base.properties\", 106),\n         /** Complete HTML entities. */\n-        extended(fullByVal);\n-\n-        private Map<Character, String> map;\n-\n-        EscapeMode(Map<Character, String> map) {\n-            this.map = map;\n-        }\n-\n-        public Map<Character, String> getMap() {\n-            return map;\n-        }\n-    }\n-\n-    private static final Map<String, Character> full;\n-    private static final Map<Character, String> xhtmlByVal;\n-    private static final Map<String, Character> base;\n-    private static final Map<Character, String> baseByVal;\n-    private static final Map<Character, String> fullByVal;\n-\n-    private Entities() {}\n+        extended(\"entities-full.properties\", 2125);\n+\n+        // table of named references to their codepoints. sorted so we can binary search. built by BuildEntities.\n+        private String[] nameKeys;\n+        private int[] codeVals; // limitation is the few references with multiple characters; those go into multipoints.\n+\n+        // table of codepoints to named entities.\n+        private int[] codeKeys; // we don' support multicodepoints to single named value currently\n+        private String[] nameVals;\n+\n+        EscapeMode(String file, int size) {\n+            load(this, file, size);\n+        }\n+\n+        int codepointForName(final String name) {\n+            int index = Arrays.binarySearch(nameKeys, name);\n+            return index >= 0 ? codeVals[index] : empty;\n+        }\n+\n+        String nameForCodepoint(final int codepoint) {\n+            final int index = Arrays.binarySearch(codeKeys, codepoint);\n+            if (index >= 0) {\n+                // the results are ordered so lower case versions of same codepoint come after uppercase, and we prefer to emit lower\n+                // (and binary search for same item with multi results is undefined\n+                return (index < nameVals.length-1 && codeKeys[index+1] == codepoint) ?\n+                    nameVals[index+1] : nameVals[index];\n+            }\n+            return emptyName;\n+        }\n+\n+        private int size() {\n+            return nameKeys.length;\n+        }\n+    }\n+\n+    private static final HashMap<String, String> multipoints = new HashMap<String, String>(); // name -> multiple character references\n+\n+    private Entities() {\n+    }\n \n     /**\n      * Check if the input is a known named entity\n      * @param name the possible entity name (e.g. \"lt\" or \"amp\")\n      * @return true if a known named entity\n      */\n-    public static boolean isNamedEntity(String name) {\n-        return full.containsKey(name);\n+    public static boolean isNamedEntity(final String name) {\n+        return extended.codepointForName(name) != empty;\n     }\n \n     /**\n      * @return true if a known named entity in the base set\n      * @see #isNamedEntity(String)\n      */\n-    public static boolean isBaseNamedEntity(String name) {\n-        return base.containsKey(name);\n+    public static boolean isBaseNamedEntity(final String name) {\n+        return base.codepointForName(name) != empty;\n     }\n \n     /**\n      * Get the Character value of the named entity\n      * @param name named entity (e.g. \"lt\" or \"amp\")\n      * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')\n+     * @deprecated does not support characters outside the BMP or multiple character names\n      */\n     public static Character getCharacterByName(String name) {\n-        return full.get(name);\n-    }\n-    \n+        return (char) extended.codepointForName(name);\n+    }\n+\n+    /**\n+     * Get the character(s) represented by the named entitiy\n+     * @param name entity (e.g. \"lt\" or \"amp\")\n+     * @return the string value of the character(s) represented by this entity, or \"\" if not defined\n+     */\n+    public static String getByName(String name) {\n+        String val = multipoints.get(name);\n+        if (val != null)\n+            return val;\n+        int codepoint = extended.codepointForName(name);\n+        if (codepoint != empty)\n+            return new String(new int[]{codepoint}, 0, 1);\n+        return emptyName;\n+    }\n+\n+    public static int codepointsForName(final String name, final int[] codepoints) {\n+        String val = multipoints.get(name);\n+        if (val != null) {\n+            codepoints[0] = val.codePointAt(0);\n+            codepoints[1] = val.codePointAt(1);\n+            return 2;\n+        }\n+        int codepoint = extended.codepointForName(name);\n+        if (codepoint != empty) {\n+            codepoints[0] = codepoint;\n+            return 1;\n+        }\n+        return 0;\n+    }\n+\n     static String escape(String string, Document.OutputSettings out) {\n         StringBuilder accum = new StringBuilder(string.length() * 2);\n         try {\n         final EscapeMode escapeMode = out.escapeMode();\n         final CharsetEncoder encoder = out.encoder();\n         final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n-        final Map<Character, String> map = escapeMode.getMap();\n         final int length = string.length();\n \n         int codePoint;\n                     default:\n                         if (canEncode(coreCharset, c, encoder))\n                             accum.append(c);\n-                        else if (map.containsKey(c))\n-                            accum.append('&').append(map.get(c)).append(';');\n-                        else\n-                            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n+                        else\n+                            appendEncoded(accum, escapeMode, codePoint);\n                 }\n             } else {\n                 final String c = new String(Character.toChars(codePoint));\n                 if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                     accum.append(c);\n                 else\n-                    accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n+                    appendEncoded(accum, escapeMode, codePoint);\n             }\n         }\n+    }\n+\n+    private static void appendEncoded(Appendable accum, EscapeMode escapeMode, int codePoint) throws IOException {\n+        final String name = escapeMode.nameForCodepoint(codePoint);\n+        if (name != emptyName) // ok for identity check\n+            accum.append('&').append(name).append(';');\n+        else\n+            accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n     }\n \n     static String unescape(String string) {\n      * Alterslash: 3013, 28\n      * Jsoup: 167, 2\n      */\n-\n     private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {\n         // todo add more charset tests if impacted by Android's bad perf in canEncode\n         switch (charset) {\n         }\n     }\n \n-\n-    // xhtml has restricted entities\n-    private static final Object[][] xhtmlArray = {\n-            {\"quot\", 0x00022},\n-            {\"amp\", 0x00026},\n-            {\"lt\", 0x0003C},\n-            {\"gt\", 0x0003E}\n-    };\n-\n-    static {\n-        xhtmlByVal = new HashMap<Character, String>();\n-        base = loadEntities(\"entities-base.properties\");  // most common / default\n-        baseByVal = toCharacterKey(base);\n-        full = loadEntities(\"entities-full.properties\"); // extended and overblown.\n-        fullByVal = toCharacterKey(full);\n-\n-        for (Object[] entity : xhtmlArray) {\n-            Character c = Character.valueOf((char) ((Integer) entity[1]).intValue());\n-            xhtmlByVal.put(c, ((String) entity[0]));\n-        }\n-    }\n-\n-    private static Map<String, Character> loadEntities(String filename) {\n-        Properties properties = new Properties();\n-        Map<String, Character> entities = new HashMap<String, Character>();\n+    private static void load(EscapeMode e, String file, int size) {\n+        e.nameKeys = new String[size];\n+        e.codeVals = new int[size];\n+        e.codeKeys = new int[size];\n+        e.nameVals = new String[size];\n+\n+        InputStream stream = Entities.class.getResourceAsStream(file);\n+        if (stream == null)\n+            throw new IllegalStateException(\"Could not read resource \" + file + \". Make sure you copy resources for \" + Entities.class.getCanonicalName());\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(stream));\n+        String entry;\n+        int i = 0;\n         try {\n-            InputStream in = Entities.class.getResourceAsStream(filename);\n-            properties.load(in);\n-            in.close();\n-        } catch (IOException e) {\n-            throw new MissingResourceException(\"Error loading entities resource: \" + e.getMessage(), \"Entities\", filename);\n-        }\n-\n-        for (Map.Entry entry: properties.entrySet()) {\n-            Character val = Character.valueOf((char) Integer.parseInt((String) entry.getValue(), 16));\n-            String name = (String) entry.getKey();\n-            entities.put(name, val);\n-        }\n-        return entities;\n-    }\n-\n-    private static Map<Character, String> toCharacterKey(Map<String, Character> inMap) {\n-        Map<Character, String> outMap = new HashMap<Character, String>();\n-        for (Map.Entry<String, Character> entry: inMap.entrySet()) {\n-            Character character = entry.getValue();\n-            String name = entry.getKey();\n-\n-            if (outMap.containsKey(character)) {\n-                // dupe, prefer the lower case version\n-                if (name.toLowerCase().equals(name))\n-                    outMap.put(character, name);\n-            } else {\n-                outMap.put(character, name);\n+            while ((entry = reader.readLine()) != null) {\n+                // NotNestedLessLess=10913,824;1887\n+                final Matcher match = entityPattern.matcher(entry);\n+                if (match.find()) {\n+                    final String name = match.group(1);\n+                    final int cp1 = Integer.parseInt(match.group(2), codepointRadix);\n+                    final int cp2 = match.group(3) != null ? Integer.parseInt(match.group(3), codepointRadix) : empty;\n+                    final int index = Integer.parseInt(match.group(4), codepointRadix);\n+\n+                    e.nameKeys[i] = name;\n+                    e.codeVals[i] = cp1;\n+                    e.codeKeys[index] = cp1;\n+                    e.nameVals[index] = name;\n+\n+                    if (cp2 != empty) {\n+                        multipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\n+                    }\n+                    i++;\n+                }\n+\n             }\n-        }\n-        return outMap;\n+            reader.close();\n+        } catch (IOException err) {\n+            throw new IllegalStateException(\"Error reading resource \" + file);\n+        }\n     }\n }\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n             ensureAttributeValue();\n             pendingAttributeValue.append(append);\n         }\n+\n+        final void appendAttributeValue(int[] appendCodepoints) {\n+            ensureAttributeValue();\n+            for (int codepoint : appendCodepoints) {\n+                pendingAttributeValue.appendCodePoint(codepoint);\n+            }\n+        }\n         \n         final void setEmptyAttributeValue() {\n             hasEmptyAttributeValue = true;\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n         emit(String.valueOf(chars));\n     }\n \n+    void emit(int[] codepoints) {\n+        emit(new String(codepoints, 0, codepoints.length));\n+    }\n+\n     void emit(char c) {\n         emit(String.valueOf(c));\n     }\n         selfClosingFlagAcknowledged = true;\n     }\n \n-    final private char[] charRefHolder = new char[1]; // holder to not have to keep creating arrays\n-    char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n+    final private int[] codepointHolder = new int[1]; // holder to not have to keep creating arrays\n+    final private int[] multipointHolder = new int[2];\n+    int[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n         if (reader.isEmpty())\n             return null;\n         if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n         if (reader.matchesAnySorted(notCharRefCharsSorted))\n             return null;\n \n-        final char[] charRef = charRefHolder;\n+        final int[] codeRef = codepointHolder;\n         reader.mark();\n         if (reader.matchConsume(\"#\")) { // numbered\n             boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n             } // skip\n             if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                 characterReferenceError(\"character outside of valid range\");\n-                charRef[0] = replacementChar;\n-                return charRef;\n+                codeRef[0] = replacementChar;\n+                return codeRef;\n             } else {\n                 // todo: implement number replacement table\n                 // todo: check for extra illegal unicode points as parse errors\n-                if (charval < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n-                    charRef[0] = (char) charval;\n-                    return charRef;\n-                } else\n-                return Character.toChars(charval);\n+                codeRef[0] = charval;\n+                return codeRef;\n             }\n         } else { // named\n             // get as many letters as possible, and look for matching entities.\n             }\n             if (!reader.matchConsume(\";\"))\n                 characterReferenceError(\"missing semicolon\"); // missing semi\n-            charRef[0] = Entities.getCharacterByName(nameRef);\n-            return charRef;\n+            int numChars = Entities.codepointsForName(nameRef, multipointHolder);\n+            if (numChars == 1) {\n+                codeRef[0] = multipointHolder[0];\n+                return codeRef;\n+            } else if (numChars ==2) {\n+                return multipointHolder;\n+            } else {\n+                Validate.fail(\"Unexpected characters returned for \" + nameRef);\n+                return multipointHolder;\n+            }\n         }\n     }\n \n             builder.append(reader.consumeTo('&'));\n             if (reader.matches('&')) {\n                 reader.consume();\n-                char[] c = consumeCharacterReference(null, inAttribute);\n+                int[] c = consumeCharacterReference(null, inAttribute);\n                 if (c == null || c.length==0)\n                     builder.append('&');\n-                else\n-                    builder.append(c);\n+                else {\n+                    builder.appendCodePoint(c[0]);\n+                    if (c.length == 2)\n+                        builder.appendCodePoint(c[1]);\n+                }\n+\n             }\n         }\n         return builder.toString();\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n                     t.transition(AfterAttributeValue_quoted);\n                     break;\n                 case '&':\n-                    char[] ref = t.consumeCharacterReference('\"', true);\n+                    int[] ref = t.consumeCharacterReference('\"', true);\n                     if (ref != null)\n                         t.tagPending.appendAttributeValue(ref);\n                     else\n                     t.transition(AfterAttributeValue_quoted);\n                     break;\n                 case '&':\n-                    char[] ref = t.consumeCharacterReference('\\'', true);\n+                    int[] ref = t.consumeCharacterReference('\\'', true);\n                     if (ref != null)\n                         t.tagPending.appendAttributeValue(ref);\n                     else\n                     t.transition(BeforeAttributeName);\n                     break;\n                 case '&':\n-                    char[] ref = t.consumeCharacterReference('>', true);\n+                    int[] ref = t.consumeCharacterReference('>', true);\n                     if (ref != null)\n                         t.tagPending.appendAttributeValue(ref);\n                     else\n     }\n \n     private static void readCharRef(Tokeniser t, TokeniserState advance) {\n-        char[] c = t.consumeCharacterReference(null, false);\n+        int[] c = t.consumeCharacterReference(null, false);\n         if (c == null)\n             t.emit('&');\n         else\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n     private static final String WEBSITE_WITH_INVALID_CERTIFICATE = \"https://certs.cac.washington.edu/CAtest/\";\n     private static final String WEBSITE_WITH_SNI = \"https://jsoup.org/\";\n     private static String echoURL = \"http://direct.infohound.net/tools/q.pl\";\n-    private static String browserUa = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36\";\n+    public static String browserUa = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36\";\n \n     @Test\n     public void fetchURl() throws IOException {\n--- /dev/null\n+++ b/src/test/java/org/jsoup/nodes/BuildEntities.java\n+package org.jsoup.nodes;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.reflect.TypeToken;\n+import org.jsoup.Connection;\n+import org.jsoup.Jsoup;\n+import org.jsoup.integration.UrlConnectTest;\n+import org.jsoup.nodes.Entities;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+\n+/**\n+ * Fetches HTML entity names from w3.org json, and outputs data files for optimized used in Entities.\n+ * I refuse to believe that entity names like \"NotNestedLessLess\" are valuable or useful for HTML authors. Implemented\n+ * only to be complete.\n+ */\n+class BuildEntities {\n+    private static final String projectDir = \"/Users/jhy/projects/jsoup\";\n+\n+    public static void main(String[] args) throws IOException {\n+        String url = \"https://www.w3.org/TR/2012/WD-html5-20121025/entities.json\";\n+        Connection.Response res = Jsoup.connect(url)\n+            .ignoreContentType(true)\n+            .userAgent(UrlConnectTest.browserUa)\n+            .execute();\n+\n+        Gson gson = new Gson();\n+        Map<String, CharacterRef> input = gson.fromJson(res.body(),\n+            new TypeToken<Map<String, CharacterRef>>() {\n+            }.getType());\n+\n+\n+        // build name sorted base and full character lists:\n+        ArrayList<CharacterRef> base = new ArrayList<CharacterRef>();\n+        ArrayList<CharacterRef> full = new ArrayList<CharacterRef>();\n+\n+        for (Map.Entry<String, CharacterRef> entry : input.entrySet()) {\n+            String name = entry.getKey().substring(1); // name is like &acute or &acute; , trim &\n+            CharacterRef ref = entry.getValue();\n+            if (name.endsWith(\";\")) {\n+                name = name.substring(0, name.length() - 1);\n+                full.add(ref);\n+            } else {\n+                base.add(ref);\n+            }\n+            ref.name = name;\n+        }\n+        Collections.sort(base, byName);\n+        Collections.sort(full, byName);\n+\n+        // now determine code point order\n+        ArrayList<CharacterRef> baseByCode = new ArrayList<CharacterRef>(base);\n+        ArrayList<CharacterRef> fullByCode = new ArrayList<CharacterRef>(full);\n+        Collections.sort(baseByCode, byCode);\n+        Collections.sort(fullByCode, byCode);\n+\n+        // and update their codepoint index. Don't\n+        ArrayList<CharacterRef>[] codelists = new ArrayList[]{baseByCode, fullByCode};\n+        for (ArrayList<CharacterRef> codelist : codelists) {\n+            for (int i = 0; i < codelist.size(); i++) {\n+                codelist.get(i).codeIndex = i;\n+            }\n+        }\n+\n+        // now write them\n+        persist(\"entities-full.properties\", full);\n+        persist(\"entities-base.properties\", base);\n+\n+        System.out.println(\"Full size: \" + full.size() + \", base size: \" + base.size());\n+    }\n+\n+    private static void persist(String name, ArrayList<CharacterRef> refs) throws IOException {\n+        String base = projectDir + \"/src/main/java/org/jsoup/nodes\";\n+        File file = new File(base, name);\n+        FileWriter writer = new FileWriter(file, false);\n+        for (CharacterRef ref : refs) {\n+            writer.append(ref.toString()).append(\"\\n\");\n+        }\n+        writer.close();\n+    }\n+\n+\n+    private static class CharacterRef {\n+        int[] codepoints;\n+        String name;\n+        int codeIndex;\n+\n+        @Override\n+        public String toString() {\n+            return name\n+                + \"=\"\n+                + d(codepoints[0])\n+                + (codepoints.length > 1 ? \",\" + d(codepoints[1]) : \"\")\n+                + \";\" + d(codeIndex);\n+        }\n+    }\n+\n+    private static String d(int d) {\n+        return Integer.toString(d, Entities.codepointRadix);\n+    }\n+\n+    private static class ByName implements Comparator<CharacterRef> {\n+        public int compare(CharacterRef o1, CharacterRef o2) {\n+            return o1.name.compareTo(o2.name);\n+        }\n+    }\n+\n+    private static class ByCode implements Comparator<CharacterRef> {\n+        public int compare(CharacterRef o1, CharacterRef o2) {\n+            int[] c1 = o1.codepoints;\n+            int[] c2 = o2.codepoints;\n+            int first = c1[0] - c2[0];\n+            if (first != 0)\n+                return first;\n+            if (c1.length == 1 && c2.length == 1) { // for the same code, use the shorter name\n+                int len = o2.name.length() - o1.name.length();\n+                if (len != 0)\n+                    return len;\n+                return o1.name.compareTo(o2.name);\n+            }\n+            if (c1.length == 2 && c2.length == 2)\n+                return c1[1] - c2[1];\n+            else\n+                return c2.length - c1.length; // pushes multi down the list so hits on singles first (don't support multi lookup by codepoint yet)\n+        }\n+    }\n+\n+    private static ByName byName = new ByName();\n+    private static ByCode byCode = new ByCode();\n+}\n--- a/src/test/java/org/jsoup/nodes/EntitiesTest.java\n+++ b/src/test/java/org/jsoup/nodes/EntitiesTest.java\n         assertEquals(text, Entities.unescape(escapedUtfMin));\n     }\n \n+    @Test public void escapedSupplemtary() {\n+        String text = \"\\uD835\\uDD59\";\n+        String escapedAscii = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(base));\n+        assertEquals(\"&#x1d559;\", escapedAscii);\n+        String escapedAsciiFull = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(extended));\n+        assertEquals(\"&hopf;\", escapedAsciiFull);\n+        String escapedUtf= Entities.escape(text, new OutputSettings().charset(\"UTF-8\").escapeMode(extended));\n+        assertEquals(text, escapedUtf);\n+    }\n+\n+    @Test public void unescapeMultiChars() {\n+        String text = \"&NestedGreaterGreater; &nGg; &nGt; &nGtv; &Gt; &gg;\"; // gg is not combo, but 8811 could conflict with NestedGreaterGreater or others\n+        String un = \"\u226b \u22d9\u0338 \u226b\u20d2 \u226b\u0338 \u226b \u226b\";\n+        assertEquals(un, Entities.unescape(text));\n+        String escaped = Entities.escape(un, new OutputSettings().charset(\"ascii\").escapeMode(extended));\n+        assertEquals(\"&Gt; &Gg;&#x338; &Gt;&#x20d2; &Gt;&#x338; &Gt; &Gt;\", escaped);\n+        assertEquals(un, Entities.unescape(escaped));\n+    }\n+\n+    @Test public void xhtml() {\n+        String text = \"&amp; &gt; &lt; &quot;\";\n+        assertEquals(38, xhtml.codepointForName(\"amp\"));\n+        assertEquals(62, xhtml.codepointForName(\"gt\"));\n+        assertEquals(60, xhtml.codepointForName(\"lt\"));\n+        assertEquals(34, xhtml.codepointForName(\"quot\"));\n+\n+        assertEquals(\"amp\", xhtml.nameForCodepoint(38));\n+        assertEquals(\"gt\", xhtml.nameForCodepoint(62));\n+        assertEquals(\"lt\", xhtml.nameForCodepoint(60));\n+        assertEquals(\"quot\", xhtml.nameForCodepoint(34));\n+    }\n+\n+    @Test public void getByName() {\n+        assertEquals(\"\u226b\u20d2\", Entities.getByName(\"nGt\"));\n+        assertEquals(\"fj\", Entities.getByName(\"fjlig\"));\n+        assertEquals(\"\u226b\", Entities.getByName(\"gg\"));\n+        assertEquals(\"\u00a9\", Entities.getByName(\"copy\"));\n+    }\n+\n     @Test public void escapeSupplementaryCharacter() {\n         String text = new String(Character.toChars(135361));\n         String escapedAscii = Entities.escape(text, new OutputSettings().charset(\"ascii\").escapeMode(base));\n         assertEquals(text, escapedUtf);\n     }\n \n+    @Test public void notMissingMultis() {\n+        String text = \"&nparsl;\";\n+        String un = \"\\u2AFD\\u20E5\";\n+        assertEquals(un, Entities.unescape(text));\n+    }\n+\n+    @Test public void notMissingSupplementals() {\n+        String text = \"&npolint; &qfr;\";\n+        String un = \"\u2a14 \\uD835\\uDD2E\"; // \ud835\udd2e\n+        assertEquals(un, Entities.unescape(text));\n+    }\n+\n     @Test public void unescape() {\n-        String text = \"Hello &amp;&LT&gt; &reg &angst; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;\";\n-        assertEquals(\"Hello &<> \u00ae \u00c5 &angst \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 \u00a9\", Entities.unescape(text));\n+        String text = \"Hello &AElig; &amp;&LT&gt; &reg &angst; &angst &#960; &#960 &#x65B0; there &! &frac34; &copy; &COPY;\";\n+        assertEquals(\"Hello \u00c6 &<> \u00ae \u00c5 &angst \u03c0 \u03c0 \u65b0 there &! \u00be \u00a9 \u00a9\", Entities.unescape(text));\n \n         assertEquals(\"&0987654321; &unknown\", Entities.unescape(\"&0987654321; &unknown\"));\n     }\n--- a/src/test/java/org/jsoup/safety/CleanerTest.java\n+++ b/src/test/java/org/jsoup/safety/CleanerTest.java\n         String defaultOut = Jsoup.clean(html, \"http://foo.com/\", Whitelist.relaxed());\n         assertNotSame(defaultOut, customOut);\n \n-        assertEquals(\"<div><p>&bernou;</p></div>\", customOut);\n+        assertEquals(\"<div><p>&Bscr;</p></div>\", customOut); // entities now prefers shorted names if aliased\n         assertEquals(\"<div>\\n\" +\n             \" <p>\u212c</p>\\n\" +\n             \"</div>\", defaultOut);", "timestamp": 1471633461, "metainfo": ""}