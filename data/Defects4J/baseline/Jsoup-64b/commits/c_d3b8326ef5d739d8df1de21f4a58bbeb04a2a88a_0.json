{"sha": "d3b8326ef5d739d8df1de21f4a58bbeb04a2a88a", "log": "Added support for sending plain HTTP request bodies", "commit": "\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n     Connection data(String... keyvals);\n \n     /**\n+     * Set a POST (or PUT) request body. Useful when a server expects a plain request body, not a set for URL\n+     * encoded form key/value pairs. E.g.:\n+     * <code><pre>Jsoup.connect(url)\n+     * .requestBody(json)\n+     * .header(\"Content-Type\", \"application/json\")\n+     * .post();</pre></code>\n+     * If any data key/vals are supplied, they will be send as URL query params.\n+     * @return this Request, for chaining\n+     */\n+    Connection requestBody(String body);\n+\n+    /**\n      * Set a request header.\n      * @param name header name\n      * @param value header value\n         Collection<KeyVal> data();\n \n         /**\n+         * Set a POST (or PUT) request body. Useful when a server expects a plain request body, not a set for URL\n+         * encoded form key/value pairs. E.g.:\n+         * <code><pre>Jsoup.connect(url)\n+         * .requestBody(json)\n+         * .header(\"Content-Type\", \"application/json\")\n+         * .post();</pre></code>\n+         * If any data key/vals are supplied, they will be send as URL query params.\n+         * @return this Request, for chaining\n+         */\n+        Request requestBody(String body);\n+\n+        /**\n+         * Get the current request body.\n+         * @return null if not set.\n+         */\n+        String requestBody();\n+\n+        /**\n          * Specify the parser to use when parsing the document.\n          * @param parser parser to use.\n          * @return this Request, for chaining\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n         // look for BOM - overrides any other header or input\n         byteData.mark();\n         byte[] bom = new byte[4];\n-        byteData.get(bom);\n-        byteData.rewind();\n+        if (byteData.remaining() >= bom.length) {\n+            byteData.get(bom);\n+            byteData.rewind();\n+        }\n         if (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\n                 bom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\n             charsetName = \"UTF-32\"; // and I hope it's on your system\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import java.util.regex.Pattern;\n import java.util.zip.GZIPInputStream;\n \n+import static org.jsoup.Connection.Method.HEAD;\n+\n /**\n  * Implementation of {@link Connection}.\n  * @see org.jsoup.Jsoup#connect(String)\n         return this;\n     }\n \n+    public Connection requestBody(String body) {\n+        req.requestBody(body);\n+        return this;\n+    }\n+\n     public Connection header(String name, String value) {\n         req.header(name, value);\n         return this;\n         private int maxBodySizeBytes;\n         private boolean followRedirects;\n         private Collection<Connection.KeyVal> data;\n+        private String body = null;\n         private boolean ignoreHttpErrors = false;\n         private boolean ignoreContentType = false;\n         private Parser parser;\n \n         public Collection<Connection.KeyVal> data() {\n             return data;\n+        }\n+\n+        public Connection.Request requestBody(String body) {\n+            this.body = body;\n+            return this;\n+        }\n+\n+        public String requestBody() {\n+            return body;\n         }\n \n         public Request parser(Parser parser) {\n             String protocol = req.url().getProtocol();\n             if (!protocol.equals(\"http\") && !protocol.equals(\"https\"))\n                 throw new MalformedURLException(\"Only http & https protocols supported\");\n+            final boolean methodHasBody = req.method().hasBody();\n+            final boolean hasRequestBody = req.requestBody() != null;\n+            if (!methodHasBody)\n+                Validate.isFalse(hasRequestBody, \"Cannot set a request body for HTTP method \" + req.method());\n \n             // set up the request for execution\n             String mimeBoundary = null;\n-            if (!req.method().hasBody() && req.data().size() > 0) {\n-                serialiseRequestUrl(req); // appends query string\n-            } else if (req.method().hasBody()) {\n+            if (req.data().size() > 0 && (!methodHasBody || hasRequestBody))\n+                serialiseRequestUrl(req);\n+            else if (methodHasBody)\n                 mimeBoundary = setOutputContentType(req);\n-            }\n+\n             HttpURLConnection conn = createConnection(req);\n             Response res;\n             try {\n                 }\n \n                 res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n-                if (conn.getContentLength() != 0) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n+                if (conn.getContentLength() != 0 && req.method() != HEAD) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n                     InputStream bodyStream = null;\n                     try {\n                         bodyStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n         }\n \n         private static String setOutputContentType(final Connection.Request req) {\n-            // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n-            boolean needsMulti = false;\n-            for (Connection.KeyVal keyVal : req.data()) {\n-                if (keyVal.hasInputStream()) {\n-                    needsMulti = true;\n-                    break;\n-                }\n-            }\n             String bound = null;\n-            if (needsMulti) {\n+            if (needsMultipart(req)) {\n                 bound = DataUtil.mimeBoundary();\n                 req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n             } else {\n \n         private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n             final Collection<Connection.KeyVal> data = req.data();\n-            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, DataUtil.defaultCharset));\n+            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, req.postDataCharset()));\n \n             if (bound != null) {\n                 // boundary will be set if we're in multipart mode\n                 w.write(\"--\");\n                 w.write(bound);\n                 w.write(\"--\");\n-            } else {\n+            } else if (req.requestBody() != null) {\n+                // data will be in query string, we're sending a plaintext body\n+                w.write(req.requestBody());\n+            }\n+            else {\n                 // regular form data (application/x-www-form-urlencoded)\n                 boolean first = true;\n                 for (Connection.KeyVal keyVal : data) {\n                 first = false;\n             }\n             for (Connection.KeyVal keyVal : req.data()) {\n+                Validate.isFalse(keyVal.hasInputStream(), \"InputStream data not supported in URL query string.\");\n                 if (!first)\n                     url.append('&');\n                 else\n         }\n     }\n \n+    private static boolean needsMultipart(Connection.Request req) {\n+        // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n+        boolean needsMulti = false;\n+        for (Connection.KeyVal keyVal : req.data()) {\n+            if (keyVal.hasInputStream()) {\n+                needsMulti = true;\n+                break;\n+            }\n+        }\n+        return needsMulti;\n+    }\n+\n     public static class KeyVal implements Connection.KeyVal {\n         private String key;\n         private String value;\n--- a/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n+++ b/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n         assertEquals(\"two\", kv.value());\n         assertFalse(kv.hasInputStream());\n     }\n+\n+    @Test public void requestBody() {\n+        Connection con = HttpConnection.connect(\"http://example.com/\");\n+        con.requestBody(\"foo\");\n+        assertEquals(\"foo\", con.request().requestBody());\n+    }\n }\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.IOException;\n-import java.net.*;\n+import java.net.ConnectException;\n+import java.net.InetSocketAddress;\n+import java.net.MalformedURLException;\n+import java.net.Proxy;\n+import java.net.URL;\n import java.util.Map;\n \n-import static org.hamcrest.core.Is.is;\n-import static org.junit.Assert.*;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n /**\n  Tests the URL connection. Not enabled by default, so tests don't require network connection.\n     private static final String WEBSITE_WITH_INVALID_CERTIFICATE = \"https://certs.cac.washington.edu/CAtest/\";\n     private static final String WEBSITE_WITH_SNI = \"https://jsoup.org/\";\n     private static String echoURL = \"http://direct.infohound.net/tools/q.pl\";\n+    private static String browserUa = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.112 Safari/537.36\";\n \n     @Test\n     public void fetchURl() throws IOException {\n         assertEquals(\"auth=token\", ihVal(\"HTTP_COOKIE\", doc));\n         assertEquals(\"\u5ea6\u4e00\u4e0b\", ihVal(\"\u767e\", doc));\n         assertEquals(\"Jsoup, Jonathan\", ihVal(\"uname\", doc));\n+    }\n+\n+    @Test\n+    public void sendsRequestBody() throws IOException {\n+        final String body = \"{key:value}\";\n+        Document doc = Jsoup.connect(echoURL)\n+            .requestBody(body)\n+            .header(\"Content-Type\", \"text/plain\")\n+            .userAgent(browserUa)\n+            .post();\n+        assertEquals(\"POST\", ihVal(\"REQUEST_METHOD\", doc));\n+        assertEquals(body, ihVal(\"keywords\", doc));\n+    }\n+\n+    @Test\n+    public void sendsRequestBodyWithUrlParams() throws IOException {\n+        final String body = \"{key:value}\";\n+        Document doc = Jsoup.connect(echoURL)\n+            .requestBody(body)\n+            .data(\"uname\", \"Jsoup\", \"uname\", \"Jonathan\", \"\u767e\", \"\u5ea6\u4e00\u4e0b\")\n+            .header(\"Content-Type\", \"text/plain\") // todo - if user sets content-type, we should append postcharset\n+            .userAgent(browserUa)\n+            .post();\n+        assertEquals(\"POST\", ihVal(\"REQUEST_METHOD\", doc));\n+        assertEquals(\"uname=Jsoup&uname=Jonathan&%E7%99%BE=%E5%BA%A6%E4%B8%80%E4%B8%8B\", ihVal(\"QUERY_STRING\", doc));\n+        assertEquals(body, ihVal(\"POSTDATA\", doc));\n     }\n \n     @Test\n     public void testSNIPass() throws Exception {\n         String url = WEBSITE_WITH_SNI;\n         Connection.Response defaultRes = Jsoup.connect(url).validateTLSCertificates(false).execute();\n-        assertThat(defaultRes.statusCode(), is(200));\n+        assertEquals(defaultRes.statusCode(), 200);\n     }\n \n     /**\n     public void testUnsafePass() throws Exception {\n         String url = WEBSITE_WITH_INVALID_CERTIFICATE;\n         Connection.Response defaultRes = Jsoup.connect(url).validateTLSCertificates(false).execute();\n-        assertThat(defaultRes.statusCode(), is(200));\n+        assertEquals(defaultRes.statusCode(), 200);\n     }\n \n     @Test\n     public void postJpeg() throws IOException {\n         File thumb = ParseTest.getFile(\"/htmltests/thumb.jpg\");\n         Document result = Jsoup\n-                .connect(\"http://regex.info/exif.cgi\")\n-                .data(\"f\", thumb.getName(), new FileInputStream(thumb))\n-                .post();\n+            .connect(\"http://regex.info/exif.cgi\")\n+            .data(\"f\", thumb.getName(), new FileInputStream(thumb))\n+            .userAgent(browserUa)\n+            .post();\n \n         assertEquals(\"Baseline DCT, Huffman coding\", result.select(\"td:contains(Process) + td\").text());\n+        assertEquals(\"1052 bytes 30 \u00d7 30\", result.select(\"td:contains(Size) + td\").text());\n     }\n \n     @Test\n         Document doc = con.get();\n         assertTrue(doc.title().contains(\"jsoup\")); // would fail if actually went via proxy\n     }\n+\n+    @Test\n+    public void throwsIfRequestBodyForGet() throws IOException {\n+        boolean caught = false;\n+        String url = \"http://jsoup.org\";\n+        try {\n+            Document doc = Jsoup.connect(url).requestBody(\"fail\").get();\n+        } catch (IllegalArgumentException e) {\n+            caught = true;\n+        }\n+        assertTrue(caught);\n+    }\n }", "timestamp": 1460672569, "metainfo": ""}