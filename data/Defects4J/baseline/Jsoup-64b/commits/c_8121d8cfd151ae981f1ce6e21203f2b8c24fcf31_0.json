{"sha": "8121d8cfd151ae981f1ce6e21203f2b8c24fcf31", "log": "Always use Locale.ENGLISH when converting to lower case  Fixes #256", "commit": "\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import java.util.zip.GZIPInputStream;\n \n import static org.jsoup.Connection.Method.HEAD;\n+import static org.jsoup.internal.Normalizer.lowerCase;\n \n /**\n  * Implementation of {@link Connection}.\n             // quick evals for common case of title case, lower case, then scan for mixed\n             String value = headers.get(name);\n             if (value == null)\n-                value = headers.get(name.toLowerCase());\n+                value = headers.get(lowerCase(name));\n             if (value == null) {\n                 Map.Entry<String, String> entry = scanHeaders(name);\n                 if (entry != null)\n         }\n \n         private Map.Entry<String, String> scanHeaders(String name) {\n-            String lc = name.toLowerCase();\n+            String lc = lowerCase(name);\n             for (Map.Entry<String, String> entry : headers.entrySet()) {\n-                if (entry.getKey().toLowerCase().equals(lc))\n+                if (lowerCase(entry.getKey()).equals(lc))\n                     return entry;\n             }\n             return null;\n--- /dev/null\n+++ b/src/main/java/org/jsoup/internal/Normalizer.java\n+package org.jsoup.internal;\n+\n+import java.util.Locale;\n+\n+public class Normalizer {\n+    public static String lowerCase(String input) {\n+        return input.toLowerCase(Locale.ENGLISH);\n+    }\n+\n+    public static String normalize(String input) {\n+        return lowerCase(input).trim();\n+    }\n+}\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n import java.util.regex.Pattern;\n import java.util.regex.PatternSyntaxException;\n \n+import static org.jsoup.internal.Normalizer.normalize;\n+\n /**\n  * A HTML element consists of a tag name, attributes, and child nodes (including text nodes and\n  * other elements).\n      */\n     public Elements getElementsByTag(String tagName) {\n         Validate.notEmpty(tagName);\n-        tagName = tagName.toLowerCase().trim();\n+        tagName = normalize(tagName);\n \n         return Collector.collect(new Evaluator.Tag(tagName), this);\n     }\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n import java.util.Collections;\n import java.util.LinkedList;\n import java.util.List;\n+\n+import static org.jsoup.internal.Normalizer.lowerCase;\n \n /**\n  The base, abstract Node model. Elements, Documents, Comments etc are all Node instances.\n         String val = attributes.getIgnoreCase(attributeKey);\n         if (val.length() > 0)\n             return val;\n-        else if (attributeKey.toLowerCase().startsWith(\"abs:\"))\n+        else if (lowerCase(attributeKey).startsWith(\"abs:\"))\n             return absUrl(attributeKey.substring(\"abs:\".length()));\n         else return \"\";\n     }\n--- a/src/main/java/org/jsoup/parser/ParseSettings.java\n+++ b/src/main/java/org/jsoup/parser/ParseSettings.java\n \n import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n+\n+import static org.jsoup.internal.Normalizer.lowerCase;\n \n /**\n  * Controls parser settings, to optionally preserve tag and/or attribute name case.\n     String normalizeTag(String name) {\n         name = name.trim();\n         if (!preserveTagCase)\n-            name = name.toLowerCase();\n+            name = lowerCase(name);\n         return name;\n     }\n \n     String normalizeAttribute(String name) {\n         name = name.trim();\n         if (!preserveAttributeCase)\n-            name = name.toLowerCase();\n+            name = lowerCase(name);\n         return name;\n     }\n \n     Attributes normalizeAttributes(Attributes attributes) {\n         if (!preserveAttributeCase) {\n             for (Attribute attr : attributes) {\n-                attr.setKey(attr.getKey().toLowerCase());\n+                attr.setKey(lowerCase(attr.getKey()));\n             }\n         }\n         return attributes;\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n import org.jsoup.nodes.Attribute;\n import org.jsoup.nodes.Attributes;\n import org.jsoup.nodes.BooleanAttribute;\n+\n+import static org.jsoup.internal.Normalizer.lowerCase;\n \n /**\n  * Parse tokens for the Tokeniser.\n \n         final Tag name(String name) {\n             tagName = name;\n-            normalName = name.toLowerCase();\n+            normalName = lowerCase(name);\n             return this;\n         }\n \n         // these appenders are rarely hit in not null state-- caused by null chars.\n         final void appendTagName(String append) {\n             tagName = tagName == null ? append : tagName.concat(append);\n-            normalName = tagName.toLowerCase();\n+            normalName = lowerCase(tagName);\n         }\n \n         final void appendTagName(char append) {\n         StartTag nameAttr(String name, Attributes attributes) {\n             this.tagName = name;\n             this.attributes = attributes;\n-            normalName = tagName.toLowerCase();\n+            normalName = lowerCase(tagName);\n             return this;\n         }\n \n--- a/src/main/java/org/jsoup/safety/Whitelist.java\n+++ b/src/main/java/org/jsoup/safety/Whitelist.java\n import java.util.HashSet;\n import java.util.Map;\n import java.util.Set;\n+\n+import static org.jsoup.internal.Normalizer.lowerCase;\n \n \n /**\n \n             prot += \":\";\n \n-            if (value.toLowerCase().startsWith(prot)) {\n+            if (lowerCase(value).startsWith(prot)) {\n                 return true;\n             }\n         }\n--- a/src/main/java/org/jsoup/select/Evaluator.java\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n+import static org.jsoup.internal.Normalizer.lowerCase;\n+import static org.jsoup.internal.Normalizer.normalize;\n+\n \n /**\n  * Evaluates that an element matches the selector.\n \n         public AttributeStarting(String keyPrefix) {\n             Validate.notEmpty(keyPrefix);\n-            this.keyPrefix = keyPrefix.toLowerCase();\n+            this.keyPrefix = lowerCase(keyPrefix);\n         }\n \n         @Override\n         public boolean matches(Element root, Element element) {\n             List<org.jsoup.nodes.Attribute> values = element.attributes().asList();\n             for (org.jsoup.nodes.Attribute attribute : values) {\n-                if (attribute.getKey().toLowerCase().startsWith(keyPrefix))\n+                if (lowerCase(attribute.getKey()).startsWith(keyPrefix))\n                     return true;\n             }\n             return false;\n \n         @Override\n         public boolean matches(Element root, Element element) {\n-            return element.hasAttr(key) && element.attr(key).toLowerCase().startsWith(value); // value is lower case already\n+            return element.hasAttr(key) && lowerCase(element.attr(key)).startsWith(value); // value is lower case already\n         }\n \n         @Override\n \n         @Override\n         public boolean matches(Element root, Element element) {\n-            return element.hasAttr(key) && element.attr(key).toLowerCase().endsWith(value); // value is lower case\n+            return element.hasAttr(key) && lowerCase(element.attr(key)).endsWith(value); // value is lower case\n         }\n \n         @Override\n \n         @Override\n         public boolean matches(Element root, Element element) {\n-            return element.hasAttr(key) && element.attr(key).toLowerCase().contains(value); // value is lower case\n+            return element.hasAttr(key) && lowerCase(element.attr(key)).contains(value); // value is lower case\n         }\n \n         @Override\n         Pattern pattern;\n \n         public AttributeWithValueMatching(String key, Pattern pattern) {\n-            this.key = key.trim().toLowerCase();\n+            this.key = normalize(key);\n             this.pattern = pattern;\n         }\n \n             Validate.notEmpty(key);\n             Validate.notEmpty(value);\n \n-            this.key = key.trim().toLowerCase();\n+            this.key = normalize(key);\n             if (value.startsWith(\"\\\"\") && value.endsWith(\"\\\"\")\n                     || value.startsWith(\"'\") && value.endsWith(\"'\")) {\n                 value = value.substring(1, value.length()-1);\n             }\n-            this.value = value.trim().toLowerCase();\n+            this.value = normalize(value);\n         }\n     }\n \n         private String searchText;\n \n         public ContainsText(String searchText) {\n-            this.searchText = searchText.toLowerCase();\n-        }\n-\n-        @Override\n-        public boolean matches(Element root, Element element) {\n-            return (element.text().toLowerCase().contains(searchText));\n+            this.searchText = lowerCase(searchText);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return lowerCase(element.text()).contains(searchText);\n         }\n \n         @Override\n         private String searchText;\n \n         public ContainsData(String searchText) {\n-            this.searchText = searchText.toLowerCase();\n-        }\n-\n-        @Override\n-        public boolean matches(Element root, Element element) {\n-            return (element.data().toLowerCase().contains(searchText));\n+            this.searchText = lowerCase(searchText);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return lowerCase(element.data()).contains(searchText);\n         }\n \n         @Override\n         private String searchText;\n \n         public ContainsOwnText(String searchText) {\n-            this.searchText = searchText.toLowerCase();\n-        }\n-\n-        @Override\n-        public boolean matches(Element root, Element element) {\n-            return (element.ownText().toLowerCase().contains(searchText));\n+            this.searchText = lowerCase(searchText);\n+        }\n+\n+        @Override\n+        public boolean matches(Element root, Element element) {\n+            return lowerCase(element.ownText()).contains(searchText);\n         }\n \n         @Override\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.parser.TokenQueue;\n+\n+import static org.jsoup.internal.Normalizer.normalize;\n \n /**\n  * Parses a CSS selector into an Evaluator tree.\n \n         // namespaces: wildcard match equals(tagName) or ending in \":\"+tagName\n         if (tagName.startsWith(\"*|\")) {\n-            evals.add(new CombiningEvaluator.Or(new Evaluator.Tag(tagName.trim().toLowerCase()), new Evaluator.TagEndsWith(tagName.replace(\"*|\", \":\").trim().toLowerCase())));\n+            evals.add(new CombiningEvaluator.Or(new Evaluator.Tag(normalize(tagName)), new Evaluator.TagEndsWith(normalize(tagName.replace(\"*|\", \":\")))));\n         } else {\n             // namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\n             if (tagName.contains(\"|\"))\n     private static final Pattern NTH_B  = Pattern.compile(\"(\\\\+|-)?(\\\\d+)\");\n \n \tprivate void cssNthChild(boolean backwards, boolean ofType) {\n-\t\tString argS = tq.chompTo(\")\").trim().toLowerCase();\n+\t\tString argS = normalize(tq.chompTo(\")\"));\n \t\tMatcher mAB = NTH_AB.matcher(argS);\n \t\tMatcher mB = NTH_B.matcher(argS);\n \t\tfinal int a, b;", "timestamp": 1485819721, "metainfo": ""}