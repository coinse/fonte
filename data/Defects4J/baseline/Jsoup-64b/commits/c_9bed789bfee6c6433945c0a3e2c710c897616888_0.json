{"sha": "9bed789bfee6c6433945c0a3e2c710c897616888", "log": "Element documentation.", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n import java.util.*;\n \n /**\n- A HTML element: tag + data, e.g. <code>&lt;div id=\"foo\"&gt;content&lt;/div&gt;</code>\n-\n- @author Jonathan Hedley, jonathan@hedley.net */\n+ * A HTML element consists of a tag name, attributes, and child nodes (including text nodes and\n+ * other elements).\n+ * \n+ * From an Element, you can extract data, traverse the node graph, and manipulate the HTML.\n+ * \n+ * @author Jonathan Hedley, jonathan@hedley.net\n+ */\n public class Element extends Node {\n     private final Tag tag;\n     private final List<Element> elementChildren; // subset of Node.children, only holds Elements\n     private Set<String> classNames;\n-\n+    \n+    /**\n+     * Create a new, standalone Element. (Standalone in that is has no parent.)\n+     * \n+     * @param startTag provides tag, base URI, and initial attributes\n+     * @see #appendChild(Element)\n+     * @see #appendElement(String)\n+     */\n     public Element(StartTag startTag) {\n         super(startTag.getBaseUri(), startTag.getAttributes());\n         this.tag = startTag.getTag();\n         elementChildren = new ArrayList<Element>();\n     }\n-\n+    \n+    /**\n+     * Create a new Element from a tag and a base URI.\n+     * \n+     * @param tag element tag\n+     * @param baseUri the base URI of this element. It is acceptable for the base URI to be an empty\n+     *            string, but not null.\n+     * @see Tag#valueOf(String)\n+     */\n     public Element(Tag tag, String baseUri) {\n         this(new StartTag(tag, baseUri));\n     }\n \n+    @Override\n     public String nodeName() {\n         return tag.getName();\n     }\n \n+    /**\n+     * Get the name of the tag for this element. E.g. {@code div}\n+     * \n+     * @return the tag name\n+     */\n     public String tagName() {\n         return tag.getName();\n     }\n \n+    /**\n+     * Get the Tag for this element.\n+     * \n+     * @return the tag object\n+     */\n     public Tag getTag() {\n         return tag;\n     }\n-\n+    \n+    /**\n+     * Test if this element is a block-level element (e.g. {@code <div>} or an inline element (e.g.\n+     * {@code <p>}).\n+     * \n+     * @return true if block, false if not (and thus inline)\n+     */\n     public boolean isBlock() {\n         return tag.isBlock();\n     }\n \n+    /**\n+     * Get the {@code id} attribute of this element.\n+     * \n+     * @return The id attribute, if present, or an empty string if not.\n+     */\n     public String id() {\n         String id = attr(\"id\");\n         return id == null ? \"\" : id;\n     }\n \n-    @Override\n+    /**\n+     * Set an attribute value on this element. If this element already has an attribute with the\n+     * key, its value is updated; otherwise, a new attribute is added.\n+     * \n+     * @return this element\n+     */\n     public Element attr(String attributeKey, String attributeValue) {\n         super.attr(attributeKey, attributeValue);\n         return this;\n         return (Element) super.parent();\n     }\n \n+    /**\n+     * Get a child element of this element, by its 0-based index number.\n+     * <p/>\n+     * Note that an element can have both mixed Nodes and Elements as children. This method inspects\n+     * a filtered list of children that are elements, and the index is based on that filtered list.\n+     * \n+     * @param index the index number of the element to retrieve\n+     * @return the child element, if it exists, or {@code null} if absent.\n+     * @see #childNode(int)\n+     */\n     public Element child(int index) {\n         return elementChildren.get(index);\n     }\n \n+    /**\n+     * Get this element's child elements.\n+     * <p/>\n+     * This is effectively a filter on {@link #childNodes()} to get Element nodes.\n+     * @return an unmodifiable list of children elements. If this element has no children, returns an\n+     * empty list.\n+     * @see #childNodes()\n+     */\n     public List<Element> children() {\n         return Collections.unmodifiableList(elementChildren);\n     }\n \n+    /**\n+     * Find elements that match the selector query, with this element as the starting context. Matched elements\n+     * may include this element, or any of its children.\n+     * <p/>\n+     * This method is generally more powerful to use than the DOM-type {@code getElementBy*} methods, because\n+     * multiple filters can be combined, e.g.:\n+     * <ul>\n+     * <li>{@code el.select(\"a[href]\")} - finds links ({@code a} tags with {@code href} attributes)\n+     * <li>{@code el.select(\"a[href*=example.com]\")} - finds links pointing to example.com (loosely)\n+     * </ul>\n+     * \n+     * @param query a {@link Selector} query\n+     * @return elements that match the query (empty if none match)\n+     */\n     public Elements select(String query) {\n         return Selector.select(query, this);\n     }\n \n-    public Element appendChild(Element child) {\n+    /**\n+     * Adds the supplied Element to this element's children.\n+     * @param child the Element to add. It should be a new element, without an existing parent.\n+     * @return this element, so that you can add more children.\n+     */\n+    public Element appendChild(Element child) { // TODO remove, and dynamically filter for children()\n         Validate.notNull(child);\n         \n         elementChildren.add(child);\n         return this;\n     }\n \n+    /**\n+     * Adds the Node to this element. \n+     * @param child the Node to add. Must not already have a parent.\n+     * @return this element, so that you can add more child nodes or elements.\n+     */\n     public Element appendChild(Node child) {\n         Validate.notNull(child);\n         \n         return this;\n     }\n     \n+    /**\n+     * Create a new Element by tag name, and add it to this element.\n+     * \n+     * @param tagName the name of the tag (e.g. {@code div}).\n+     * @return the new element, to allow you to add content to it, e.g.:\n+     *  {@code parent.appendElement(\"h1\").attr(\"id\", \"header\").text(\"Welcome\");}\n+     */\n     public Element appendElement(String tagName) {\n         Validate.notEmpty(tagName);\n         \n         return child;\n     }\n     \n+    /**\n+     * Create and append a new TextNode to this element.\n+     * \n+     * @param text the unencoded text to add\n+     * @return this element\n+     */\n     public Element appendText(String text) {\n         TextNode node = new TextNode(text, baseUri());\n         appendChild(node);\n         return this;\n     }\n     \n+    /**\n+     * Add inner HTML to this element. The supplied HTML will be parsed, and each node appended.\n+     * @param html HTML to add inside this element, after the existing HTML\n+     * @return this element\n+     * @see #html(String)\n+     */\n     public Element append(String html) {\n         Validate.notNull(html);\n         \n         Element fragment = Parser.parseBodyFragment(html, baseUri).getBody();\n+        // TODO: must parse without implicit elements, so you can e.g. add <td> to a <tr> (without creating a whole new table)\n         for (Node node : fragment.childNodes()) {\n             node.parentNode = null;\n             appendChild(node);\n         return this;\n     }\n     \n+    /**\n+     * Remove all of the element's child nodes. Any attributes are left as-is.\n+     * @return this element\n+     */\n     public Element empty() {\n         childNodes.clear();\n         elementChildren.clear();\n         return this;\n     }\n \n+    /**\n+     * Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s, \n+     * the {@code nextElementSibling} of the first {@code p} is the second {@code p}.\n+     * <p/>\n+     * This is similar to {@link #nextSibling()}, but specifically finds only Elements\n+     * @return the next element, or null if there is no next element\n+     * @see #previousElementSibling()\n+     */\n     public Element nextElementSibling() {\n         List<Element> siblings = parent().elementChildren;\n         Integer index = indexInList(this, siblings);\n             return null;\n     }\n \n+    /**\n+     * Gets the previous element sibling of this element.\n+     * @return the previous element, or null if there is no previous element\n+     * @see #nextElementSibling()\n+     */\n     public Element previousElementSibling() {\n         List<Element> siblings = parent().elementChildren;\n         Integer index = indexInList(this, siblings);\n             return null;\n     }\n \n+    /**\n+     * Gets the first element sibling of this element.\n+     * @return the first sibling that is an element (aka the parent's first element child) \n+     */\n     public Element firstElementSibling() {\n         // todo: should firstSibling() exclude this?\n         List<Element> siblings = parent().elementChildren;\n         return siblings.size() > 1 ? siblings.get(0) : null;\n     }\n \n+    /**\n+     * Gets the last element sibling of this element\n+     * @return the last sibling that is an element (aka the parent's last element child) \n+     */\n     public Element lastElementSibling() {\n         List<Element> siblings = parent().elementChildren;\n         return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n      * Find an element by ID, including or under this element.\n      * <p>\n      * Note that this finds the first matching ID, starting with this element. If you search down from a different\n-     * starting point, it is possible to find a different element by ID. For unique element by ID withing a Document,\n-     * use Document.getElementById.\n+     * starting point, it is possible to find a different element by ID. For unique element by ID within a Document,\n+     * use {@link Document#getElementById(String)}\n      * @param id The ID to search for.\n      * @return The first matching element by ID, starting with this element, or null if none found.\n      */\n             return null;\n     }\n \n+    /**\n+     * Find elements that have this class, including or under this element. Case insensitive.\n+     * <p>\n+     * Elements can have multiple classes (e.g. {@code <div class=\"header round first\">}. This method\n+     * checks each class, so you can find the above with {@code el.getElementsByClass(\"header\");}.\n+     * \n+     * @param className the name of the class to search for.\n+     * @return elements with the supplied class name, empty if none\n+     * @see #hasClass(String)\n+     * @see #classNames()\n+     */\n     public Elements getElementsByClass(String className) {\n         Validate.notEmpty(className);\n \n         return Collector.collect(new Evaluator.Class(className), this);\n     }\n \n+    /**\n+     * Find elements that have a named attribute set. Case insensitive.\n+     *\n+     * @param key name of the attribute\n+     * @return elements that have this attribute, empty if none\n+     */\n     public Elements getElementsByAttribute(String key) {\n         Validate.notEmpty(key);\n         key = key.trim().toLowerCase();\n         return Collector.collect(new Evaluator.Attribute(key), this);\n     }\n \n+    /**\n+     * Find elements that have an attribute with the specific value. Case insensitive.\n+     * \n+     * @param key name of the attribute\n+     * @param value value of the attribute\n+     * @return elements that have this attribute with this value, empty if none\n+     */\n     public Elements getElementsByAttributeValue(String key, String value) {\n         String[] kp = normaliseAttrKeyPair(key, value);\n         return Collector.collect(new Evaluator.AttributeWithValue(kp[0], kp[1]), this);\n     }\n \n+    /**\n+     * Find elements that either do not have this attribute, or have it with a different value. Case insensitive.\n+     * \n+     * @param key name of the attribute\n+     * @param value value of the attribute\n+     * @return elements that do not have a matching attribute\n+     */\n     public Elements getElementsByAttributeValueNot(String key, String value) {\n         String[] kp = normaliseAttrKeyPair(key, value);\n         return Collector.collect(new Evaluator.AttributeWithValueNot(kp[0], kp[1]), this);\n     }\n \n-    public Elements getElementsByAttributeValueStarting(String key, String value) {\n-        String[] kp = normaliseAttrKeyPair(key, value);\n+    /**\n+     * Find elements that have attributes that start with the value prefix. Case insensitive.\n+     * \n+     * @param key name of the attribute\n+     * @param valuePrefix start of attribute value\n+     * @return elements that have attributes that start with the value prefix\n+     */\n+    public Elements getElementsByAttributeValueStarting(String key, String valuePrefix) {\n+        String[] kp = normaliseAttrKeyPair(key, valuePrefix);\n         return Collector.collect(new Evaluator.AttributeWithValueStarting(kp[0], kp[1]), this);\n     }\n \n-    public Elements getElementsByAttributeValueEnding(String key, String value) {\n-        String[] kp = normaliseAttrKeyPair(key, value);\n+    /**\n+     * Find elements that have attributes that end with the value suffix. Case insensitive.\n+     * \n+     * @param key name of the attribute\n+     * @param valueSuffix end of the attribute value\n+     * @return elements that have attributes that end with the value suffix\n+     */\n+    public Elements getElementsByAttributeValueEnding(String key, String valueSuffix) {\n+        String[] kp = normaliseAttrKeyPair(key, valueSuffix);\n         return Collector.collect(new Evaluator.AttributeWithValueEnding(kp[0], kp[1]), this);\n     }\n \n-    public Elements getElementsByAttributeValueContaining(String key, String value) {\n-        String[] kp = normaliseAttrKeyPair(key, value);\n+    /**\n+     * Find elements that have attributes whose value contains the match string. Case insensitive.\n+     * \n+     * @param key name of the attribute\n+     * @param match substring of value to search for\n+     * @return elements that have attributes containing this text\n+     */\n+    public Elements getElementsByAttributeValueContaining(String key, String match) {\n+        String[] kp = normaliseAttrKeyPair(key, match);\n         return Collector.collect(new Evaluator.AttributeWithValueContaining(kp[0], kp[1]), this);\n     }\n \n         return new String[] {key, value};\n     }\n \n+    /**\n+     * Gets the combined text of this element and all its children.\n+     * \n+     * @return unencoded text, or empty string if none.\n+     */\n     public String text() {\n         StringBuilder sb = new StringBuilder();\n \n         return sb.toString();\n     }\n \n+    /**\n+     * Set the text of this element. Any existing contents (text or elements) will be cleared\n+     * @param text unencoded text\n+     * @return this element\n+     */\n     public Element text(String text) {\n         Validate.notNull(text);\n \n         return this;\n     }\n \n+    /**\n+     * Get the combined data of this element. Data is e.g. the inside of a {@code script} tag.\n+     * @return the data, or empty string if none\n+     */\n     public String data() {\n         StringBuilder sb = new StringBuilder();\n \n         return attributes.hasKey(\"class\") ? attributes.get(\"class\") : \"\";\n     }\n \n+    /**\n+     * Get the set of the element's class names. E.g. on element {@code <div class=\"header gray\"}>},\n+     * returns a set of two elements {@code \"header\", \"gray\"}.\n+     * @return set of classnames, empty if no class attribute\n+     */\n     public Set<String> classNames() {\n         if (classNames == null) {\n             String[] names = className().split(\"\\\\s+\");\n         return classNames;\n     }\n \n+    /**\n+     * Tests if this element has a class.\n+     * @param className name of class to check for\n+     * @return true if it does, false if not\n+     */\n     public boolean hasClass(String className) {\n         return classNames().contains(className);\n     }\n \n+    /**\n+     * Get the outer HTML for this element. E.g. on a {@code div} with one empty {@code p}, would return\n+     * {@code <div><p></p></div>}.\n+     * \n+     * @return the outer HTML\n+     * @see #html()\n+     */\n     public String outerHtml() {\n         StringBuilder accum = new StringBuilder();\n         accum\n     }\n \n     /**\n-     * Retrieves the element's inner HTML.\n+     * Retrieves the element's inner HTML. E.g. on a {@code div} with one empty {@code p}, would return\n+     * {@code <p></p>}.\n+     * \n      * @return String of HTML.\n+     * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         return accum.toString();\n     }\n     \n+    /**\n+     * Set this element's inner HTML. Clears the existing HTML first.\n+     * @param html HTML to parse and set into this element\n+     * @return this element\n+     * @see #append(String)\n+     */\n     public Element html(String html) {\n         empty();\n         append(html);", "timestamp": 1309605105, "metainfo": ""}