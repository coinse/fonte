{"sha": "50e2719bb646870dc08dd71f2bc2314ce46def76", "log": "Remove DISABLED character hack.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n package org.apache.commons.csv;\n \n import static org.apache.commons.csv.Constants.COMMA;\n+import static org.apache.commons.csv.Constants.CR;\n import static org.apache.commons.csv.Constants.CRLF;\n import static org.apache.commons.csv.Constants.DOUBLE_QUOTE;\n import static org.apache.commons.csv.Constants.ESCAPE;\n \n     private static final long serialVersionUID = 1L;\n \n-    private final char delimiter;\n-    private final char encapsulator;\n-    private final char commentStart;\n-    private final char escape;\n+    private final Character delimiter;\n+    private final Character encapsulator;\n+    private final Character commentStart;\n+    private final Character escape;\n     private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n     private final boolean ignoreEmptyLines;\n     private final String lineSeparator; // for outputs\n     private final String[] header;\n \n-    private final boolean isEscaping;\n-    private final boolean isCommentingEnabled;\n-    private final boolean isEncapsulating;\n-\n-    /**\n-     * Constant char to be used for disabling comments, escapes and encapsulation. The value -2 is used because it\n-     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two chars\n-     * (using surrogates) and thus there should never be a collision with a real text char.\n-     */\n-    static final char DISABLED = '\\ufffe';\n-\n     /**\n      * Starting format with no settings defined; used for creating other formats from scratch.\n      */\n-    static final CSVFormat PRISTINE = new CSVFormat(DISABLED, DISABLED, DISABLED, DISABLED, false, false, null, null);\n+    static final CSVFormat PRISTINE = new CSVFormat(null, null, null, null, false, false, null, null);\n \n     /**\n      * Standard comma separated format, as for {@link #RFC4180} but allowing blank lines.\n      * </ul>\n      */\n     public static final CSVFormat DEFAULT =\n-            PRISTINE.\n-            withDelimiter(COMMA)\n+            PRISTINE\n+            .withDelimiter(COMMA)\n             .withEncapsulator(DOUBLE_QUOTE)\n             .withIgnoreEmptyLines(true)\n             .withLineSeparator(CRLF);\n      * </ul>\n      */\n     public static final CSVFormat RFC4180 =\n-            PRISTINE.\n-            withDelimiter(COMMA)\n+            PRISTINE\n+            .withDelimiter(COMMA)\n             .withEncapsulator(DOUBLE_QUOTE)\n             .withLineSeparator(CRLF);\n \n      * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">\n      *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n      */\n-    public static final CSVFormat MYSQL =\n+    public static final CSVFormat MYSQL = \n             PRISTINE\n             .withDelimiter(TAB)\n             .withEscape(ESCAPE)\n      * @param header\n      *            the header\n      */\n-    CSVFormat(final char delimiter, final char encapsulator, final char commentStart, final char escape, final boolean surroundingSpacesIgnored,\n+    CSVFormat(final Character delimiter, final Character encapsulator, final Character commentStart, final Character escape, final boolean surroundingSpacesIgnored,\n             final boolean emptyLinesIgnored, final String lineSeparator, final String[] header) {\n         this.delimiter = delimiter;\n         this.encapsulator = encapsulator;\n         this.ignoreEmptyLines = emptyLinesIgnored;\n         this.lineSeparator = lineSeparator;\n         this.header = header;\n-        this.isEncapsulating = encapsulator != DISABLED;\n-        this.isCommentingEnabled = commentStart != DISABLED;\n-        this.isEscaping = escape != DISABLED;\n     }\n \n     /**\n      *\n      * @return true if <code>c</code> is a line break character\n      */\n-    private static boolean isLineBreak(final char c) {\n-        return c == '\\n' || c == '\\r';\n+    private static boolean isLineBreak(final Character c) {\n+        return c != null && (c == LF || c == CR);\n     }\n \n     /**\n                     commentStart + \"\\\")\");\n         }\n \n-        if (encapsulator != DISABLED && encapsulator == commentStart) {\n+        if (encapsulator != null && encapsulator == commentStart) {\n             throw new IllegalArgumentException(\n                     \"The comment start character and the encapsulator cannot be the same (\\\"\" + commentStart + \"\\\")\");\n         }\n \n-        if (escape != DISABLED && escape == commentStart) {\n+        if (escape != null && escape == commentStart) {\n             throw new IllegalArgumentException(\"The comment start and the escape character cannot be the same (\\\"\" +\n                     commentStart + \"\\\")\");\n         }\n      *             thrown if the specified character is a line break\n      */\n     public CSVFormat withDelimiter(final char delimiter) {\n+        return withDelimiter(Character.valueOf(delimiter));\n+    }\n+\n+    /**\n+     * Returns a copy of this format using the specified delimiter character.\n+     *\n+     * @param delimiter\n+     *            the delimiter character\n+     * @return A copy of this format using the specified delimiter character\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n+     */\n+    public CSVFormat withDelimiter(final Character delimiter) {\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n      *\n      * @return the encapsulator character\n      */\n-    public char getEncapsulator() {\n+    public Character getEncapsulator() {\n         return encapsulator;\n     }\n \n      *             thrown if the specified character is a line break\n      */\n     public CSVFormat withEncapsulator(final char encapsulator) {\n+        return withEncapsulator(Character.valueOf(encapsulator));\n+    }\n+\n+    /**\n+     * Returns a copy of this format using the specified encapsulator character.\n+     *\n+     * @param encapsulator\n+     *            the encapsulator character\n+     * @return A copy of this format using the specified encapsulator character\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n+     */\n+    public CSVFormat withEncapsulator(final Character encapsulator) {\n         if (isLineBreak(encapsulator)) {\n             throw new IllegalArgumentException(\"The encapsulator cannot be a line break\");\n         }\n      * @return {@code true} if an encapsulator is defined\n      */\n     public boolean isEncapsulating() {\n-        return isEncapsulating;\n+        return encapsulator != null;\n     }\n \n     /**\n      *\n      * @return the comment start marker.\n      */\n-    public char getCommentStart() {\n+    public Character getCommentStart() {\n         return commentStart;\n     }\n \n      *             thrown if the specified character is a line break\n      */\n     public CSVFormat withCommentStart(final char commentStart) {\n+        return withCommentStart(Character.valueOf(commentStart));\n+    }\n+\n+    /**\n+     * Returns a copy of this format using the specified character as the comment start marker.\n+     *\n+     * Note that the comment introducer character is only recognised at the start of a line.\n+     *\n+     * @param commentStart\n+     *            the comment start marker\n+     * @return A copy of this format using the specified character as the comment start marker\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n+     */\n+    public CSVFormat withCommentStart(final Character commentStart) {\n         if (isLineBreak(commentStart)) {\n             throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n         }\n      * @return <tt>true</tt> is comments are supported, <tt>false</tt> otherwise\n      */\n     public boolean isCommentingEnabled() {\n-        return isCommentingEnabled;\n+        return commentStart != null;\n     }\n \n     /**\n      *\n      * @return the escape character\n      */\n-    public char getEscape() {\n+    public Character getEscape() {\n         return escape;\n     }\n \n      *             thrown if the specified character is a line break\n      */\n     public CSVFormat withEscape(final char escape) {\n+        return withEscape(Character.valueOf(escape));\n+    }\n+\n+    /**\n+     * Returns a copy of this format using the specified escape character.\n+     *\n+     * @param escape\n+     *            the escape character\n+     * @return A copy of this format using the specified escape character\n+     * @throws IllegalArgumentException\n+     *             thrown if the specified character is a line break\n+     */\n+    public CSVFormat withEscape(final Character escape) {\n         if (isLineBreak(escape)) {\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n      * @return {@code true} if escapes are processed\n      */\n     public boolean isEscaping() {\n-        return isEscaping;\n+        return escape != null;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n  */\n abstract class Lexer {\n \n-    private final boolean isEncapsulating;\n-    private final boolean isEscaping;\n-    private final boolean isCommentEnabled;\n-\n-    private final char delimiter;\n-    private final char escape;\n-    private final char encapsulator;\n-    private final char commmentStart;\n+    private final Character delimiter;\n+    private final Character escape;\n+    private final Character encapsulator;\n+    private final Character commmentStart;\n \n     final boolean surroundingSpacesIgnored;\n     final boolean emptyLinesIgnored;\n     Lexer(final CSVFormat format, final ExtendedBufferedReader in) {\n         this.format = format;\n         this.in = in;\n-        this.isEncapsulating = format.isEncapsulating();\n-        this.isEscaping = format.isEscaping();\n-        this.isCommentEnabled = format.isCommentingEnabled();\n         this.delimiter = format.getDelimiter();\n         this.escape = format.getEscape();\n         this.encapsulator = format.getEncapsulator();\n     }\n \n     boolean isEscape(final int c) {\n-        return isEscaping && c == escape;\n+        return escape != null && c == escape;\n     }\n \n     boolean isEncapsulator(final int c) {\n-        return isEncapsulating && c == encapsulator;\n+        return encapsulator != null && c == encapsulator;\n     }\n \n     boolean isCommentStart(final int c) {\n-        return isCommentEnabled && c == commmentStart;\n+        return commmentStart != null && c == commmentStart;\n     }\n }\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n         format.withIgnoreEmptyLines(false);\n \n         assertEquals('!', format.getDelimiter());\n-        assertEquals('!', format.getEncapsulator());\n-        assertEquals('!', format.getCommentStart());\n-        assertEquals('!', format.getEscape());\n+        assertEquals('!', format.getEncapsulator().charValue());\n+        assertEquals('!', format.getCommentStart().charValue());\n+        assertEquals('!', format.getEscape().charValue());\n         assertEquals(CRLF, format.getLineSeparator());\n \n         assertTrue(format.getIgnoreSurroundingSpaces());\n         final CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, CRLF, null);\n \n         assertEquals('?', format.withDelimiter('?').getDelimiter());\n-        assertEquals('?', format.withEncapsulator('?').getEncapsulator());\n-        assertEquals('?', format.withCommentStart('?').getCommentStart());\n+        assertEquals('?', format.withEncapsulator('?').getEncapsulator().charValue());\n+        assertEquals('?', format.withCommentStart('?').getCommentStart().charValue());\n         assertEquals(\"?\", format.withLineSeparator(\"?\").getLineSeparator());\n-        assertEquals('?', format.withEscape('?').getEscape());\n+        assertEquals('?', format.withEscape('?').getEscape().charValue());\n \n         assertFalse(format.withIgnoreSurroundingSpaces(false).getIgnoreSurroundingSpaces());\n         assertFalse(format.withIgnoreEmptyLines(false).getIgnoreEmptyLines());\n             // expected\n         }\n \n-        format.withEncapsulator(CSVFormat.DISABLED).withCommentStart(CSVFormat.DISABLED).validate();\n+        format.withEncapsulator(null).withCommentStart(null).validate();\n \n         try {\n             format.withEscape('!').withCommentStart('!').validate();\n             // expected\n         }\n \n-        format.withEscape(CSVFormat.DISABLED).withCommentStart(CSVFormat.DISABLED).validate();\n+        format.withEscape(null).withCommentStart(null).validate();\n \n \n         try {", "timestamp": 1350109672, "metainfo": ""}