{"sha": "c81ad0328eefb438cc875b9c9f081be93f9fdcc2", "log": "[CSV-128] CSVFormat.EXCEL should ignore empty header names  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n      * Settings are:\n      * </p>\n      * <ul>\n-     *   <li>withDelimiter(',')</li>\n-     *   <li>withQuoteChar('\"')</li>\n-     *   <li>withRecordSeparator(\"\\r\\n\")</li>\n-     *   <li>withIgnoreEmptyLines(false)</li>\n+     *   <li>{@link #withDelimiter(char) withDelimiter(',')}</li>\n+     *   <li>{@link #withQuoteChar(String) withQuoteChar('\"')}</li>\n+     *   <li>{@link #withRecordSeparator(String) withRecordSeparator(\"\\r\\n\")}</li>\n+     *   <li>{@link #withIgnoreEmptyLines(boolean) withIgnoreEmptyLines(false)}</li>\n+     *   <li>{@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}</li>\n      * </ul>\n      * <p>\n-     * Note: this is currently the same as {@link #RFC4180}.\n+     * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true);\n \n     /**\n      * Tab-delimited format.\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n /**\n  * CSVParserTest\n  *\n- * The test are organized in three different sections:\n- * The 'setter/getter' section, the lexer section and finally the parser\n- * section. In case a test fails, you should follow a top-down approach for\n- * fixing a potential bug (its likely that the parser itself fails if the lexer\n- * has problems...).\n+ * The test are organized in three different sections: The 'setter/getter' section, the lexer section and finally the\n+ * parser section. In case a test fails, you should follow a top-down approach for fixing a potential bug (its likely\n+ * that the parser itself fails if the lexer has problems...).\n  *\n  * @version $Id$\n  */\n public class CSVParserTest {\n \n-    private static final String CSV_INPUT = \"a,b,c,d\\n\"\n-                    + \" a , b , 1 2 \\n\"\n-                    + \"\\\"foo baar\\\", b,\\n\"\n-                    // + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n-                    + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\"\\\"\\\",d,e\\n\";   // changed to use standard CSV escaping\n+    private static final String CSV_INPUT = \"a,b,c,d\\n\" + \" a , b , 1 2 \\n\" + \"\\\"foo baar\\\", b,\\n\"\n+    // + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n+            + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\"\\\"\\\",d,e\\n\"; // changed to use standard CSV escaping\n \n     private static final String CSV_INPUT_1 = \"a,b,c,d\";\n \n     private static final String CSV_INPUT_2 = \"a,b,1 2\";\n \n-    private static final String[][] RESULT = {\n-            {\"a\", \"b\", \"c\", \"d\"},\n-            {\"a\", \"b\", \"1 2\"},\n-            {\"foo baar\", \"b\", \"\"},\n-            {\"foo\\n,,\\n\\\",,\\n\\\"\", \"d\", \"e\"}\n-    };\n+    private static final String[][] RESULT = { { \"a\", \"b\", \"c\", \"d\" }, { \"a\", \"b\", \"1 2\" }, { \"foo baar\", \"b\", \"\" },\n+            { \"foo\\n,,\\n\\\",,\\n\\\"\", \"d\", \"e\" } };\n \n     @Test\n     public void testBackslashEscaping() throws IOException {\n         // We will test with a forward slash as the escape char, and a single\n         // quote as the encapsulator.\n \n-        final String code =\n-                \"one,two,three\\n\" // 0\n-                        + \"'',''\\n\"       // 1) empty encapsulators\n-                        + \"/',/'\\n\"       // 2) single encapsulators\n-                        + \"'/'','/''\\n\"   // 3) single encapsulators encapsulated via escape\n-                        + \"'''',''''\\n\"   // 4) single encapsulators encapsulated via doubling\n-                        + \"/,,/,\\n\"       // 5) separator escaped\n-                        + \"//,//\\n\"       // 6) escape escaped\n-                        + \"'//','//'\\n\"   // 7) escape escaped in encapsulation\n-                        + \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\"     // don't eat spaces\n-                        + \"9,   /\\n   \\n\"  // escaped newline\n-                        + \"\";\n-        final String[][] res = {\n-                {\"one\", \"two\", \"three\"}, // 0\n-                {\"\", \"\"},                // 1\n-                {\"'\", \"'\"},              // 2\n-                {\"'\", \"'\"},              // 3\n-                {\"'\", \"'\"},              // 4\n-                {\",\", \",\"},              // 5\n-                {\"/\", \"/\"},              // 6\n-                {\"/\", \"/\"},              // 7\n-                {\"   8   \", \"   \\\"quoted \\\"\\\" /\\\" / string\\\"   \"},\n-                {\"9\", \"   \\n   \"},\n-        };\n-\n-\n-        final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'')\n-                               .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true);\n+        final String code = \"one,two,three\\n\" // 0\n+                + \"'',''\\n\" // 1) empty encapsulators\n+                + \"/',/'\\n\" // 2) single encapsulators\n+                + \"'/'','/''\\n\" // 3) single encapsulators encapsulated via escape\n+                + \"'''',''''\\n\" // 4) single encapsulators encapsulated via doubling\n+                + \"/,,/,\\n\" // 5) separator escaped\n+                + \"//,//\\n\" // 6) escape escaped\n+                + \"'//','//'\\n\" // 7) escape escaped in encapsulation\n+                + \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\" // don't eat spaces\n+                + \"9,   /\\n   \\n\" // escaped newline\n+                + \"\";\n+        final String[][] res = { { \"one\", \"two\", \"three\" }, // 0\n+                { \"\", \"\" }, // 1\n+                { \"'\", \"'\" }, // 2\n+                { \"'\", \"'\" }, // 3\n+                { \"'\", \"'\" }, // 4\n+                { \",\", \",\" }, // 5\n+                { \"/\", \"/\" }, // 6\n+                { \"/\", \"/\" }, // 7\n+                { \"   8   \", \"   \\\"quoted \\\"\\\" /\\\" / string\\\"   \" }, { \"9\", \"   \\n   \" }, };\n+\n+        final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(CRLF).withEscape('/')\n+                .withIgnoreEmptyLines(true);\n \n         final CSVParser parser = CSVParser.parse(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n         // We will test with a forward slash as the escape char, and a single\n         // quote as the encapsulator.\n \n-        final String code = \"\"\n-                + \" , , \\n\"           // 1)\n-                + \" \\t ,  , \\n\"       // 2)\n-                + \" // , /, , /,\\n\"   // 3)\n+        final String code = \"\" + \" , , \\n\" // 1)\n+                + \" \\t ,  , \\n\" // 2)\n+                + \" // , /, , /,\\n\" // 3)\n                 + \"\";\n-        final String[][] res = {\n-                {\" \", \" \", \" \"},         // 1\n-                {\" \\t \", \"  \", \" \"},     // 2\n-                {\" / \", \" , \", \" ,\"},    // 3\n+        final String[][] res = { { \" \", \" \", \" \" }, // 1\n+                { \" \\t \", \"  \", \" \" }, // 2\n+                { \" / \", \" , \", \" ,\" }, // 3\n         };\n \n-\n-        final CSVFormat format = CSVFormat.newFormat(',')\n-                .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true);\n+        final CSVFormat format = CSVFormat.newFormat(',').withRecordSeparator(CRLF).withEscape('/')\n+                .withIgnoreEmptyLines(true);\n \n         final CSVParser parser = CSVParser.parse(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n     @Test\n     @Ignore\n     public void testBackslashEscapingOld() throws IOException {\n-        final String code =\n-                \"one,two,three\\n\"\n-                        + \"on\\\\\\\"e,two\\n\"\n-                        + \"on\\\"e,two\\n\"\n-                        + \"one,\\\"tw\\\\\\\"o\\\"\\n\"\n-                        + \"one,\\\"t\\\\,wo\\\"\\n\"\n-                        + \"one,two,\\\"th,ree\\\"\\n\"\n-                        + \"\\\"a\\\\\\\\\\\"\\n\"\n-                        + \"a\\\\,b\\n\"\n-                        + \"\\\"a\\\\\\\\,b\\\"\";\n-        final String[][] res = {\n-                {\"one\", \"two\", \"three\"},\n-                {\"on\\\\\\\"e\", \"two\"},\n-                {\"on\\\"e\", \"two\"},\n-                {\"one\", \"tw\\\"o\"},\n-                {\"one\", \"t\\\\,wo\"},  // backslash in quotes only escapes a delimiter (\",\")\n-                {\"one\", \"two\", \"th,ree\"},\n-                {\"a\\\\\\\\\"},     // backslash in quotes only escapes a delimiter (\",\")\n-                {\"a\\\\\", \"b\"},  // a backslash must be returnd\n-                {\"a\\\\\\\\,b\"}    // backslash in quotes only escapes a delimiter (\",\")\n+        final String code = \"one,two,three\\n\" + \"on\\\\\\\"e,two\\n\" + \"on\\\"e,two\\n\" + \"one,\\\"tw\\\\\\\"o\\\"\\n\"\n+                + \"one,\\\"t\\\\,wo\\\"\\n\" + \"one,two,\\\"th,ree\\\"\\n\" + \"\\\"a\\\\\\\\\\\"\\n\" + \"a\\\\,b\\n\" + \"\\\"a\\\\\\\\,b\\\"\";\n+        final String[][] res = { { \"one\", \"two\", \"three\" }, { \"on\\\\\\\"e\", \"two\" }, { \"on\\\"e\", \"two\" },\n+                { \"one\", \"tw\\\"o\" }, { \"one\", \"t\\\\,wo\" }, // backslash in quotes only escapes a delimiter (\",\")\n+                { \"one\", \"two\", \"th,ree\" }, { \"a\\\\\\\\\" }, // backslash in quotes only escapes a delimiter (\",\")\n+                { \"a\\\\\", \"b\" }, // a backslash must be returnd\n+                { \"a\\\\\\\\,b\" } // backslash in quotes only escapes a delimiter (\",\")\n         };\n         final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n         final List<CSVRecord> records = parser.getRecords();\n             for (final CSVRecord record : parser) {\n                 final String string = record.get(\"Date\");\n                 Assert.assertNotNull(string);\n-                //System.out.println(\"date: \" + record.get(\"Date\"));\n+                // System.out.println(\"date: \" + record.get(\"Date\"));\n             }\n         } finally {\n             parser.close();\n             for (final CSVRecord record : parser) {\n                 final String string = record.get(\"Date\");\n                 Assert.assertNotNull(string);\n-                //System.out.println(\"date: \" + record.get(\"Date\"));\n+                // System.out.println(\"date: \" + record.get(\"Date\"));\n             }\n         } finally {\n             parser.close();\n \n     @Test\n     public void testDefaultFormat() throws IOException {\n-        final String code = \"\"\n-                + \"a,b#\\n\"           // 1)\n-                + \"\\\"\\n\\\",\\\" \\\",#\\n\"   // 2)\n-                + \"#,\\\"\\\"\\n\"         // 3)\n+        final String code = \"\" + \"a,b#\\n\" // 1)\n+                + \"\\\"\\n\\\",\\\" \\\",#\\n\" // 2)\n+                + \"#,\\\"\\\"\\n\" // 3)\n                 + \"# Final comment\\n\"// 4)\n-                ;\n-        final String[][] res = {\n-                {\"a\", \"b#\"},\n-                {\"\\n\", \" \", \"#\"},\n-                {\"#\", \"\"},\n-                {\"# Final comment\"}\n-        };\n+        ;\n+        final String[][] res = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" }, { \"#\", \"\" }, { \"# Final comment\" } };\n \n         CSVFormat format = CSVFormat.DEFAULT;\n         assertFalse(format.isCommentMarkerSet());\n \n         Utils.compare(\"Failed to parse without comments\", res, records);\n \n-        final String[][] res_comments = {\n-                {\"a\", \"b#\"},\n-                {\"\\n\", \" \", \"#\"},\n-        };\n+        final String[][] res_comments = { { \"a\", \"b#\" }, { \"\\n\", \" \", \"#\" }, };\n \n         format = CSVFormat.DEFAULT.withCommentMarker('#');\n         parser.close();\n \n     @Test\n     public void testEmptyLineBehaviourCSV() throws Exception {\n-        final String[] codes = {\n-                \"hello,\\r\\n\\r\\n\\r\\n\",\n-                \"hello,\\n\\n\\n\",\n-                \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n-                \"hello,\\\"\\\"\\n\\n\\n\"\n-        };\n-        final String[][] res = {\n-                {\"hello\", \"\"}  // CSV format ignores empty lines\n+        final String[] codes = { \"hello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\n+        final String[][] res = { { \"hello\", \"\" } // CSV format ignores empty lines\n         };\n         for (final String code : codes) {\n             final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n \n     @Test\n     public void testEmptyLineBehaviourExcel() throws Exception {\n-        final String[] codes = {\n-                \"hello,\\r\\n\\r\\n\\r\\n\",\n-                \"hello,\\n\\n\\n\",\n-                \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n-                \"hello,\\\"\\\"\\n\\n\\n\"\n-        };\n-        final String[][] res = {\n-                {\"hello\", \"\"},\n-                {\"\"},  // Excel format does not ignore empty lines\n-                {\"\"}\n-        };\n+        final String[] codes = { \"hello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\n+        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\n+                { \"\" } };\n         for (final String code : codes) {\n             final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n             final List<CSVRecord> records = parser.getRecords();\n \n     @Test\n     public void testEndOfFileBehaviorCSV() throws Exception {\n-        final String[] codes = {\n-                \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n-                \"hello,\\r\\n\\r\\nworld,\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n-        };\n-        final String[][] res = {\n-                {\"hello\", \"\"},  // CSV format ignores empty lines\n-                {\"world\", \"\"}\n-        };\n+        final String[] codes = { \"hello,\\r\\n\\r\\nworld,\\r\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\", \"hello,\\r\\n\\r\\nworld,\\n\", \"hello,\\r\\n\\r\\nworld,\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\" };\n+        final String[][] res = { { \"hello\", \"\" }, // CSV format ignores empty lines\n+                { \"world\", \"\" } };\n         for (final String code : codes) {\n             final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n             final List<CSVRecord> records = parser.getRecords();\n \n     @Test\n     public void testEndOfFileBehaviourExcel() throws Exception {\n-        final String[] codes = {\n-                \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n-                \"hello,\\r\\n\\r\\nworld,\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n-                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n-        };\n-        final String[][] res = {\n-                {\"hello\", \"\"},\n-                {\"\"},  // Excel format does not ignore empty lines\n-                {\"world\", \"\"}\n-        };\n+        final String[] codes = { \"hello,\\r\\n\\r\\nworld,\\r\\n\", \"hello,\\r\\n\\r\\nworld,\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\", \"hello,\\r\\n\\r\\nworld,\\n\", \"hello,\\r\\n\\r\\nworld,\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\", \"hello,\\r\\n\\r\\nworld,\\\"\\\"\" };\n+        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\n+                { \"world\", \"\" } };\n \n         for (final String code : codes) {\n             final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n \n     @Test\n     public void testExcelFormat1() throws IOException {\n-        final String code =\n-                \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\"\n-                        + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\n-        final String[][] res = {\n-                {\"value1\", \"value2\", \"value3\", \"value4\"},\n-                {\"a\", \"b\", \"c\", \"d\"},\n-                {\"  x\", \"\", \"\", \"\"},\n-                {\"\"},\n-                {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"}\n-        };\n+        final String code = \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\"\n+                + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\n+        final String[][] res = { { \"value1\", \"value2\", \"value3\", \"value4\" }, { \"a\", \"b\", \"c\", \"d\" },\n+                { \"  x\", \"\", \"\", \"\" }, { \"\" }, { \"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\" } };\n         final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(res.length, records.size());\n     @Test\n     public void testExcelFormat2() throws Exception {\n         final String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\n-        final String[][] res = {\n-                {\"foo\", \"baar\"},\n-                {\"\"},\n-                {\"hello\", \"\"},\n-                {\"\"},\n-                {\"world\", \"\"}\n-        };\n+        final String[][] res = { { \"foo\", \"baar\" }, { \"\" }, { \"hello\", \"\" }, { \"\" }, { \"world\", \"\" } };\n         final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(res.length, records.size());\n         parser.close();\n     }\n \n+    /**\n+     * Tests an exported Excel worksheet with a header row and rows that have more columns than the headers\n+     */\n+    @Test\n+    public void testExcelHeaderCountLessThanData() throws Exception {\n+        final String code = \"A,B,C,,\\r\\na,b,c,d,e\\r\\n\";\n+        final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL.withHeader());\n+        try {\n+            for (CSVRecord record : parser.getRecords()) {\n+                Assert.assertEquals(\"a\", record.get(\"A\"));\n+                Assert.assertEquals(\"b\", record.get(\"B\"));\n+                Assert.assertEquals(\"c\", record.get(\"C\"));\n+            }\n+        } finally {\n+            parser.close();\n+        }\n+    }\n+\n     @Test\n     public void testForEach() throws Exception {\n         final List<CSVRecord> records = new ArrayList<CSVRecord>();\n         }\n \n         assertEquals(3, records.size());\n-        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, records.get(0).values());\n-        assertArrayEquals(new String[]{\"1\", \"2\", \"3\"}, records.get(1).values());\n-        assertArrayEquals(new String[]{\"x\", \"y\", \"z\"}, records.get(2).values());\n+        assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, records.get(0).values());\n+        assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, records.get(1).values());\n+        assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, records.get(2).values());\n     }\n \n     @Test\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testDuplicateHeaders() throws Exception {\n-        CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(new String[]{}));\n+        CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(new String[] {}));\n     }\n \n     @Test\n \n     @Test\n     public void testGetRecordWithMultiLineValues() throws Exception {\n-        final CSVParser parser = CSVParser.parse(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\n-                CSVFormat.DEFAULT.withRecordSeparator(CRLF));\n+        final CSVParser parser = CSVParser.parse(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF +\n+                \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\", CSVFormat.DEFAULT.withRecordSeparator(CRLF));\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n         assertEquals(0, parser.getCurrentLineNumber());\n         assertFalse(records.hasNext());\n     }\n \n-    @Test(expected=IllegalArgumentException.class)\n+    @Test(expected = IllegalArgumentException.class)\n     public void testHeadersMissingException() throws Exception {\n         final Reader in = new StringReader(\"a,,c,,d\\n1,2,3,4\\nx,y,z,zz\");\n         CSVFormat.DEFAULT.withHeader().parse(in).iterator();\n     @Test\n     public void testIgnoreEmptyLines() throws IOException {\n         final String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n-        //String code = \"world\\r\\n\\n\";\n-        //String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n+        // String code = \"world\\r\\n\\n\";\n+        // String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n         final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT);\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(3, records.size());\n         } catch (final UnsupportedOperationException expected) {\n             // expected\n         }\n-        assertArrayEquals(new String[]{\"a\", \"b\", \"c\"}, iterator.next().values());\n-        assertArrayEquals(new String[]{\"1\", \"2\", \"3\"}, iterator.next().values());\n+        assertArrayEquals(new String[] { \"a\", \"b\", \"c\" }, iterator.next().values());\n+        assertArrayEquals(new String[] { \"1\", \"2\", \"3\" }, iterator.next().values());\n         assertTrue(iterator.hasNext());\n         assertTrue(iterator.hasNext());\n         assertTrue(iterator.hasNext());\n-        assertArrayEquals(new String[]{\"x\", \"y\", \"z\"}, iterator.next().values());\n+        assertArrayEquals(new String[] { \"x\", \"y\", \"z\" }, iterator.next().values());\n         assertFalse(iterator.hasNext());\n \n         try {\n         assertFalse(records.hasNext());\n     }\n \n-    @Test // TODO this may lead to strange behavior, throw an exception if iterator() has already been called?\n+    @Test\n+    // TODO this may lead to strange behavior, throw an exception if iterator() has already been called?\n     public void testMultipleIterators() throws Exception {\n         final CSVParser parser = CSVParser.parse(\"a,b,c\" + CR + \"d,e,f\", CSVFormat.DEFAULT);\n \n     }\n \n     private void validateLineNumbers(final String lineSeparator) throws IOException {\n-        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n+        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\",\n+                CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n         assertEquals(0, parser.getCurrentLineNumber());\n         assertNotNull(parser.nextRecord());\n         assertEquals(1, parser.getCurrentLineNumber());\n     }\n \n     private void validateRecordNumbers(final String lineSeparator) throws IOException {\n-        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n+        final CSVParser parser = CSVParser.parse(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\",\n+                CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n         assertNotNull(record = parser.nextRecord());", "timestamp": 1409148760, "metainfo": ""}