{"sha": "e28e28e1f27c554850dc0449f5f290e222121c62", "log": "[CSV-131] Save positions of records to enable random access. The floor is open for code review and further discussion based on the comments in the Jira.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     private final List<String> record = new ArrayList<String>();\n \n     private long recordNumber;\n+    \n+    /**\n+     * Lexer offset if the parser does not start parsing at the beginning of the source. Usually used in combination\n+     * with {@link #setNextRecordNumber(long)}\n+     */\n+    private long characterOffset;\n \n     private final Token reusableToken = new Token();\n \n         return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n     }\n \n+    /**\n+     * Sets the record number to be assigned to the next record read.\n+     * <p>\n+     * Use this if the reader is not positioned at the first record when you create the parser. For example, the first\n+     * record read might be the 51st record in the source file.\n+     * </p>\n+     * <p>\n+     * If you want the records to also have the correct character position referring to the underlying source, call\n+     * {@link #setNextCharacterPosition(long)}.\n+     * </p>\n+     * \n+     * @param nextRecordNumber\n+     *            the next record number\n+     * @since 1.1\n+     */\n+    public void setNextRecordNumber(long nextRecordNumber) {\n+        this.recordNumber = nextRecordNumber - 1;\n+    }\n+    \n+    /**\n+     * Sets the current position in the source stream regardless of where the parser and lexer start reading.\n+     * <p>\n+     * For example: We open a file and seek to position 5434 in order to start reading at record 42. In order to have\n+     * the parser assign the correct characterPosition to records, we call this method.\n+     * </p>\n+     * <p>\n+     * If you want the records to also have the correct record numbers, call {@link #setNextRecordNumber(long)}\n+     * </p>\n+     * \n+     * @param position\n+     *            the new character position\n+     * @since 1.1\n+     */\n+    public void setNextCharacterPosition(long position) {\n+        this.characterOffset = position - lexer.getCharacterPosition();\n+    }\n+    \n     /**\n      * Returns the current record number in the input stream.\n      *\n         CSVRecord result = null;\n         this.record.clear();\n         StringBuilder sb = null;\n+        final long startCharPosition = lexer.getCharacterPosition() + this.characterOffset;\n         do {\n             this.reusableToken.reset();\n             this.lexer.nextToken(this.reusableToken);\n             this.recordNumber++;\n             final String comment = sb == null ? null : sb.toString();\n             result = new CSVRecord(this.record.toArray(new String[this.record.size()]), this.headerMap, comment,\n-                    this.recordNumber);\n+                    this.recordNumber, startCharPosition);\n         }\n         return result;\n     }\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n \n     private static final long serialVersionUID = 1L;\n \n+    private final long characterPosition;\n+\n     /** The accumulated comments (if any) */\n     private final String comment;\n \n \n     /** The record number. */\n     private final long recordNumber;\n-\n+    \n     /** The values of the record */\n     private final String[] values;\n \n-    CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber) {\n+    CSVRecord(final String[] values, final Map<String, Integer> mapping, final String comment, final long recordNumber, long characterPosition) {\n         this.recordNumber = recordNumber;\n         this.values = values != null ? values : EMPTY_STRING_ARRAY;\n         this.mapping = mapping;\n         this.comment = comment;\n+        this.characterPosition = characterPosition;\n     }\n \n     /**\n     }\n \n     /**\n+     * Returns the start position of this record as a character position in the source stream. This may or may not\n+     * correspond to the byte position depending on the character set.\n+     *\n+     * @return the position of this record in the source stream.\n+     */\n+    public long getCharacterPosition() {\n+        return characterPosition;\n+    }\n+    \n+    /**\n      * Returns the comment for this record, if any.\n      *\n      * @return the comment for this record, or null if no comment for this record is available.\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n         }\n     }\n \n-//    @Test\n-//    public void testStartWithEmptyLinesThenHeaders() throws Exception {\n-//        final String[] codes = { \"\\r\\n\\r\\n\\r\\nhello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\", \"hello,\\\"\\\"\\n\\n\\n\" };\n-//        final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\n-//                { \"\" } };\n-//        for (final String code : codes) {\n-//            final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n-//            final List<CSVRecord> records = parser.getRecords();\n-//            assertEquals(res.length, records.size());\n-//            assertTrue(records.size() > 0);\n-//            for (int i = 0; i < res.length; i++) {\n-//                assertArrayEquals(res[i], records.get(i).values());\n-//            }\n-//            parser.close();\n-//        }\n-//    }\n+    // @Test\n+    // public void testStartWithEmptyLinesThenHeaders() throws Exception {\n+    // final String[] codes = { \"\\r\\n\\r\\n\\r\\nhello,\\r\\n\\r\\n\\r\\n\", \"hello,\\n\\n\\n\", \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n+    // \"hello,\\\"\\\"\\n\\n\\n\" };\n+    // final String[][] res = { { \"hello\", \"\" }, { \"\" }, // Excel format does not ignore empty lines\n+    // { \"\" } };\n+    // for (final String code : codes) {\n+    // final CSVParser parser = CSVParser.parse(code, CSVFormat.EXCEL);\n+    // final List<CSVRecord> records = parser.getRecords();\n+    // assertEquals(res.length, records.size());\n+    // assertTrue(records.size() > 0);\n+    // for (int i = 0; i < res.length; i++) {\n+    // assertArrayEquals(res[i], records.get(i).values());\n+    // }\n+    // parser.close();\n+    // }\n+    // }\n \n     @Test\n     public void testEndOfFileBehaviorCSV() throws Exception {\n     @Test\n     public void testGetLineNumberWithLF() throws Exception {\n         this.validateLineNumbers(String.valueOf(LF));\n+    }\n+\n+    @Test\n+    public void testGetRecordPositionWithCRLF() throws Exception {\n+        this.validateRecordPosition(CRLF);\n+    }\n+\n+    @Test\n+    public void testGetRecordPositionWithLF() throws Exception {\n+        this.validateRecordPosition(String.valueOf(LF));\n     }\n \n     @Test\n         parser.close();\n     }\n \n+    private void validateRecordPosition(final String lineSeparator) throws IOException {\n+        final String nl = lineSeparator; // used as linebreak in values for better distinction\n+\n+        String code = \"a,b,c\" + lineSeparator + \"1,2,3\" + lineSeparator +\n+        // to see if recordPosition correctly points to the enclosing quote\n+                \"'A\" + nl + \"A','B\" + nl + \"B',CC\" + lineSeparator +\n+                // unicode test... not very relevant while operating on strings instead of bytes, but for\n+                // completeness...\n+                \"\\u00c4,\\u00d6,\\u00dc\" + lineSeparator + \"EOF,EOF,EOF\";\n+\n+        final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'').withRecordSeparator(lineSeparator);\n+        CSVParser parser = CSVParser.parse(code, format);\n+\n+        CSVRecord record;\n+        assertEquals(0, parser.getRecordNumber());\n+\n+        assertNotNull(record = parser.nextRecord());\n+        assertEquals(1, record.getRecordNumber());\n+        assertEquals(code.indexOf('a'), record.getCharacterPosition());\n+\n+        assertNotNull(record = parser.nextRecord());\n+        assertEquals(2, record.getRecordNumber());\n+        assertEquals(code.indexOf('1'), record.getCharacterPosition());\n+\n+        assertNotNull(record = parser.nextRecord());\n+        final long positionRecord3 = record.getCharacterPosition();\n+        assertEquals(3, record.getRecordNumber());\n+        assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\n+        assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\n+        assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\n+        assertEquals(\"CC\", record.get(2));\n+\n+        assertNotNull(record = parser.nextRecord());\n+        assertEquals(4, record.getRecordNumber());\n+        assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\n+\n+        assertNotNull(record = parser.nextRecord());\n+        assertEquals(5, record.getRecordNumber());\n+        assertEquals(code.indexOf(\"EOF\"), record.getCharacterPosition());\n+\n+        parser.close();\n+\n+        // now try to read starting at record 3\n+        parser = CSVParser.parse(code.substring((int) positionRecord3), format);\n+        parser.setNextRecordNumber(3);\n+        parser.setNextCharacterPosition(positionRecord3);\n+\n+        assertNotNull(record = parser.nextRecord());\n+        assertEquals(3, record.getRecordNumber());\n+        assertEquals(code.indexOf(\"'A\"), record.getCharacterPosition());\n+        assertEquals(\"A\" + lineSeparator + \"A\", record.get(0));\n+        assertEquals(\"B\" + lineSeparator + \"B\", record.get(1));\n+        assertEquals(\"CC\", record.get(2));\n+\n+        assertNotNull(record = parser.nextRecord());\n+        assertEquals(4, record.getRecordNumber());\n+        assertEquals(code.indexOf('\\u00c4'), record.getCharacterPosition());\n+        assertEquals(\"\\u00c4\", record.get(0));\n+\n+        parser.close();\n+    }\n }\n--- a/src/test/java/org/apache/commons/csv/CSVRecordTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVRecordTest.java\n     @Before\n     public void setUp() throws Exception {\n         values = new String[] { \"A\", \"B\", \"C\" };\n-        record = new CSVRecord(values, null, null, 0);\n+        record = new CSVRecord(values, null, null, 0, -1);\n         header = new HashMap<String, Integer>();\n         header.put(\"first\", Integer.valueOf(0));\n         header.put(\"second\", Integer.valueOf(1));\n         header.put(\"third\", Integer.valueOf(2));\n-        recordWithHeader = new CSVRecord(values, header, null, 0);\n+        recordWithHeader = new CSVRecord(values, header, null, 0, -1);\n     }\n \n     @Test", "timestamp": 1414561480, "metainfo": ""}