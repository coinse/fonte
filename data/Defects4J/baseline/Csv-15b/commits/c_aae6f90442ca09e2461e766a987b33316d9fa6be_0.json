{"sha": "aae6f90442ca09e2461e766a987b33316d9fa6be", "log": "[CSV-214] Adding a placeholder in the Lexer and CSV parser to store the end-of-line string. I applied the patch in spirit and made changes: there is no need to use a boolean to track the state of the EOL String (set vs. not set). I also allowed for CR to be saved as an EOL string since we allow that already.", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     }\n \n     /**\n+     * Gets the first end-of-line string encountered.\n+     * \n+     * @return the first end-of-line string\n+     * @since 1.5  \n+     */\n+    public String getFirstEndOfLine() {\n+        return lexer.getFirstEol();\n+    }\n+\n+    /**\n      * Returns a copy of the header map that iterates in column order.\n      * <p>\n      * The map keys are column names. The map values are 0-based indices.\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n  */\n final class Lexer implements Closeable {\n \n+    private static final String CR_STRING = Character.toString(Constants.CR);\n+    private static final String LF_STRING = Character.toString(Constants.LF);\n+\n     /**\n      * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n      * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n \n     /** The input stream */\n     private final ExtendedBufferedReader reader;\n-\n+    private String firstEol;\n+\n+    String getFirstEol(){\n+        return firstEol;\n+    }\n+    \n     Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n         this.reader = reader;\n         this.delimiter = format.getDelimiter();\n         if (ch == CR && reader.lookAhead() == LF) {\n             // note: does not change ch outside of this method!\n             ch = reader.read();\n-        }\n+            // Save the EOL state\n+            if (firstEol == null) {\n+                this.firstEol = Constants.CRLF;\n+            }\n+        }\n+        // save EOL state here.\n+        if (firstEol == null) {\n+            if (ch == LF) {\n+                this.firstEol = LF_STRING;\n+            } else if (ch == CR) {\n+                this.firstEol = CR_STRING;\n+            }\n+        }\n+\n         return ch == LF || ch == CR;\n     }\n \n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n         try (final CSVParser parser = CSVParser.parse(code, CSVFormat.DEFAULT)) {\n             final List<CSVRecord> records = parser.getRecords();\n             assertEquals(4, records.size());\n+        }\n+    }\n+    \n+    @Test\n+    public void testFirstEndOfLineCrLf() throws IOException {\n+        final String data = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n+        try (final CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+            assertEquals(\"\\r\\n\", parser.getFirstEndOfLine());\n+        }\n+    }\n+    \n+    @Test\n+    public void testFirstEndOfLineLf() throws IOException {\n+        final String data = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n+        try (final CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+            assertEquals(\"\\n\", parser.getFirstEndOfLine());\n+        }\n+    }\n+\n+    @Test\n+    public void testFirstEndOfLineCr() throws IOException {\n+        final String data = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n+        try (final CSVParser parser = CSVParser.parse(data, CSVFormat.DEFAULT)) {\n+            final List<CSVRecord> records = parser.getRecords();\n+            assertEquals(4, records.size());\n+            assertEquals(\"\\r\", parser.getFirstEndOfLine());\n         }\n     }\n ", "timestamp": 1502485527, "metainfo": ""}