{"sha": "7ac5dd3ec633d64603bb836d0576f34a51f93f08", "log": "Rename methods that create a builder newBuilder().  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n      * </ul>\n      */\n     public static final CSVFormat RFC4180 =\n-            defaults()\n+            newBuilder()\n             .withIgnoreEmptyLines(false)\n             .build();\n \n      * </ul>\n      */\n     public static final CSVFormat DEFAULT = // TODO rename to something more meaningful\n-            defaults()\n+            newBuilder()\n             .build();\n \n     /**\n      * Note: this is currently the same as RFC4180\n      */\n     public static final CSVFormat EXCEL =\n-            defaults()\n+            newBuilder()\n             .withIgnoreEmptyLines(false)\n             .build();\n \n     /** Tab-delimited format, with quote; leading and trailing spaces ignored. */\n     public static final CSVFormat TDF =\n-            defaults()\n+            newBuilder()\n             .withDelimiter(TAB)\n             .withIgnoreSurroundingSpaces(true)\n             .build();\n      *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n      */\n     public static final CSVFormat MYSQL =\n-            defaults()\n+            newBuilder()\n             .withDelimiter(TAB)\n             .withQuoteChar(null)\n             .withEscape(ESCAPE)\n             .build();\n \n     /**\n-     * Factory method for creating CSV formats.\n+     * Creates a new CSV format builds.\n      * \n      * @param delimiter \n      *            the char used for value separation, must not be a line break character\n      * @throws IllegalArgumentException if the delimiter is a line break character\n      */\n-    public static CSVFormatBuilder newFormat(char delimiter) {\n+    public static CSVFormatBuilder newBuilder(char delimiter) {\n         return new CSVFormatBuilder(delimiter);\n     }\n \n      * <li>withLineSeparator(CRLF)</li>\n      * </ul>\n      */\n-    public static CSVFormatBuilder defaults() {\n+    public static CSVFormatBuilder newBuilder() {\n         return new CSVFormatBuilder(COMMA, DOUBLE_QUOTE, null, null, null, false, true, CRLF, null);\n     }\n \n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n         assertTrue(testName+\" require 1 param\", split.length >= 1);\n          // first line starts with csv data file name\n         final BufferedReader csvFile = new BufferedReader(new FileReader(new File(BASE, split[0])));\n-        CSVFormatBuilder builder = CSVFormat.newFormat(',').withQuoteChar('\"');\n+        CSVFormatBuilder builder = CSVFormat.newBuilder(',').withQuoteChar('\"');\n         CSVFormat fmt = builder.build(); \n         boolean checkComments = false;\n         for(int i=1; i < split.length; i++) {\n--- a/src/test/java/org/apache/commons/csv/CSVFormatBuilderTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatBuilderTest.java\n     \n     @Test(expected = IllegalArgumentException.class)\n     public void testNewFormatLFThrowsException() {\n-        CSVFormat.newFormat(LF);\n+        CSVFormat.newBuilder(LF);\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testNewFormatCRThrowsException() {\n-        CSVFormat.newFormat(CR);\n+        CSVFormat.newBuilder(CR);\n     }\n     \n     @Test(expected = IllegalArgumentException.class)\n     \n     @Test(expected = IllegalStateException.class)\n     public void testQuotePolicyNoneWithoutEscapeThrowsException() {\n-        CSVFormat.newFormat('!').withQuotePolicy(Quote.NONE).build();\n+        CSVFormat.newBuilder('!').withQuotePolicy(Quote.NONE).build();\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n     @Test\n     public void testNextToken1() throws IOException {\n         final String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n-        final Lexer parser = getLexer(code, CSVFormat.defaults().withIgnoreSurroundingSpaces(true).build());\n+        final Lexer parser = getLexer(code, CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());\n         assertTokenEquals(TOKEN, \"abc\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"def\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"hijk\", parser.nextToken(new Token()));\n                 \"\\n\"+\n                 \"\\n\"+\n                 \"# Final comment\\n\";       // 7\n-        final CSVFormat format = CSVFormat.defaults().withCommentStart('#').build();\n+        final CSVFormat format = CSVFormat.newBuilder().withCommentStart('#').build();\n         assertTrue(\"Should ignore empty lines\", format.getIgnoreEmptyLines());\n \n         final Lexer parser = getLexer(code, format);\n                 \"\\n\"+                      // 6b\n                 \"\\n\"+                      // 6c\n                 \"# Final comment\\n\";       // 7\n-        final CSVFormat format = CSVFormat.defaults().withCommentStart('#').withIgnoreEmptyLines(false).build();\n+        final CSVFormat format = CSVFormat.newBuilder().withCommentStart('#').withIgnoreEmptyLines(false).build();\n         assertFalse(\"Should not ignore empty lines\", format.getIgnoreEmptyLines());\n \n         final Lexer parser = getLexer(code, format);\n         *       \\,,\n         */\n         final String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\n-        final CSVFormat format = CSVFormat.defaults().withEscape('\\\\').withIgnoreEmptyLines(false).build();\n+        final CSVFormat format = CSVFormat.newBuilder().withEscape('\\\\').withIgnoreEmptyLines(false).build();\n         assertTrue(format.isEscaping());\n         final Lexer parser = getLexer(code, format);\n \n     @Test\n     public void testNextToken3BadEscaping() throws IOException {\n         final String code = \"a,b,c\\\\\";\n-        final CSVFormat format = CSVFormat.defaults().withEscape('\\\\').build();\n+        final CSVFormat format = CSVFormat.newBuilder().withEscape('\\\\').build();\n         assertTrue(format.isEscaping());\n         final Lexer parser = getLexer(code, format);\n \n         *        a,  \" foo \" ,b\n         */\n         final String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n-        final Lexer parser = getLexer(code, CSVFormat.defaults().withIgnoreSurroundingSpaces(true).build());\n+        final Lexer parser = getLexer(code, CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"foo\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n         *       ;;\n         */\n         final String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n-        final CSVFormat format = CSVFormat.defaults().withDelimiter(';').withQuoteChar('\\'').withCommentStart('!').build();\n+        final CSVFormat format = CSVFormat.newBuilder().withDelimiter(';').withQuoteChar('\\'').withCommentStart('!').build();\n         final Lexer parser = getLexer(code, format);\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b and ' more\\n\", parser.nextToken(new Token()));\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n \n     @Test\n     public void testGetLine() throws IOException {\n-        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.defaults().withIgnoreSurroundingSpaces(true).build());\n+        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());\n         for (final String[] re : RESULT) {\n             assertArrayEquals(re, parser.nextRecord().values());\n         }\n \n     @Test\n     public void testGetRecords() throws IOException {\n-        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.defaults().withIgnoreSurroundingSpaces(true).build());\n+        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.newBuilder().withIgnoreSurroundingSpaces(true).build());\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(RESULT.length, records.size());\n         assertTrue(records.size() > 0);\n         };\n \n \n-        final CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\\'').withEscape('/')\n+        final CSVFormat format = CSVFormat.newBuilder(',').withQuoteChar('\\'').withEscape('/')\n                                .withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build();\n \n         final CSVParser parser = new CSVParser(code, format);\n         };\n \n \n-        final CSVFormat format = CSVFormat.newFormat(',').withEscape('/')\n+        final CSVFormat format = CSVFormat.newBuilder(',').withEscape('/')\n                 .withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build();\n \n         final CSVParser parser = new CSVParser(code, format);\n                 {\"\\n\", \" \", \"#\"},\n         };\n \n-        format = CSVFormat.defaults().withCommentStart('#').build();\n+        format = CSVFormat.newBuilder().withCommentStart('#').build();\n         parser = new CSVParser(code, format);\n         records = parser.getRecords();\n \n     public void testHeader() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.defaults().withHeader().build().parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader().build().parse(in).iterator();\n \n         for (int i = 0; i < 2; i++) {\n             assertTrue(records.hasNext());\n     public void testHeaderComment() throws Exception {\n         final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.defaults().withCommentStart('#').withHeader().build().parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withCommentStart('#').withHeader().build().parse(in).iterator();\n \n         for (int i = 0; i < 2; i++) {\n             assertTrue(records.hasNext());\n     public void testProvidedHeader() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.defaults().withHeader(\"A\", \"B\", \"C\").build().parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").build().parse(in).iterator();\n \n         for (int i = 0; i < 3; i++) {\n             assertTrue(records.hasNext());\n     public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.defaults().withHeader(\"A\", \"B\", \"C\").build().parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").build().parse(in).iterator();\n \n         // header record\n         assertTrue(records.hasNext());\n     }\n \n     public void testGetHeaderMap() throws Exception {\n-        final CSVParser parser = new CSVParser(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.defaults().withHeader(\"A\", \"B\", \"C\").build());\n+        final CSVParser parser = new CSVParser(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.newBuilder().withHeader(\"A\", \"B\", \"C\").build());\n         final Map<String, Integer> headerMap = parser.getHeaderMap();\n         final Iterator<String> columnNames = headerMap.keySet().iterator();\n         // Headers are iterated in column order.\n     @Test\n     public void testGetRecordWithMultiiLineValues() throws Exception {\n         final CSVParser parser = new CSVParser(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\n-                CSVFormat.defaults().withRecordSeparator(CRLF).build());\n+                CSVFormat.newBuilder().withRecordSeparator(CRLF).build());\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n         assertEquals(0, parser.getLineNumber());\n     }\n \n     private void validateRecordNumbers(String lineSeparator) throws IOException {\n-        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.defaults().withRecordSeparator(lineSeparator).build());\n+        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.newBuilder().withRecordSeparator(lineSeparator).build());\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n         assertNotNull(record = parser.nextRecord());\n     }\n \n     private void validateLineNumbers(String lineSeparator) throws IOException {\n-        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.defaults().withRecordSeparator(lineSeparator).build());\n+        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.newBuilder().withRecordSeparator(lineSeparator).build());\n         assertEquals(0, parser.getLineNumber());\n         assertNotNull(parser.nextRecord());\n         assertEquals(1, parser.getLineNumber());\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n     @Test\n     public void testMultiLineComment() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.defaults().withCommentStart('#').build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withCommentStart('#').build());\n         printer.printComment(\"This is a comment\\non multiple lines\");\n \n         assertEquals(\"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator, sw.toString());\n     @Test\n     public void testQuoteAll() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.defaults().withQuotePolicy(Quote.ALL).build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuotePolicy(Quote.ALL).build());\n         printer.printRecord(\"a\", \"b\\nc\", \"d\");\n         assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",\\\"d\\\"\" + recordSeparator, sw.toString());\n     }\n     @Test\n     public void testQuoteNonNumeric() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.defaults().withQuotePolicy(Quote.NON_NUMERIC).build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withQuotePolicy(Quote.NON_NUMERIC).build());\n         printer.printRecord(\"a\", \"b\\nc\", Integer.valueOf(1));\n         assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",1\" + recordSeparator, sw.toString());\n     }\n     @Test\n     public void testSingleLineComment() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.defaults().withCommentStart('#').build());\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.newBuilder().withCommentStart('#').build());\n         printer.printComment(\"This is a comment\");\n \n         assertEquals(\"# This is a comment\" + recordSeparator, sw.toString());\n--- a/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n     }\n \n     private long parse(final Reader in, boolean traverseColumns) throws IOException {\n-        final CSVFormat format = CSVFormat.defaults().withIgnoreSurroundingSpaces(false).build();\n+        final CSVFormat format = CSVFormat.newBuilder().withIgnoreSurroundingSpaces(false).build();\n         long recordCount = 0;\n         for (final CSVRecord record : format.parse(in)) {\n             recordCount++;", "timestamp": 1352930056, "metainfo": ""}