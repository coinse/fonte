{"sha": "6a34b823c807325bc251ef43c66c307adcd947b8", "log": "[CSV-68] Use the Builder pattern for CSVFormat.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n import java.io.Serializable;\n import java.io.StringWriter;\n \n+import org.apache.commons.csv.CSVFormat.CSVFormatBuilder;\n+\n /**\n  * The format specification of a CSV file.\n  *\n public class CSVFormat implements Serializable {\n \n     private static final long serialVersionUID = 1L;\n-\n-    /**\n-     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n-     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two chars\n-     * (using surrogates) and thus there should never be a collision with a real text char.\n-     */\n-    private static final char DISABLED = '\\ufffe';\n \n     private final char delimiter;\n     private final Character quoteChar;\n     private final String[] header;\n \n     /**\n-     * Starting format; used for creating other formats.\n-     */\n-    private static final CSVFormat PRISTINE = new CSVFormat(DISABLED, null, null, null, null, false, false, null, null);\n-\n-    /**\n      * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n      * <ul>\n      * <li>withDelimiter(',')</li>\n      * </ul>\n      */\n     public static final CSVFormat RFC4180 =\n-            PRISTINE\n-            .withDelimiter(COMMA)\n-            .withQuoteChar(DOUBLE_QUOTE)\n-            .withRecordSeparator(CRLF);\n+            defaults()\n+            .withIgnoreEmptyLines(false)\n+            .build();\n \n     /**\n      * Standard comma separated format, as for {@link #RFC4180} but allowing blank lines.\n      * </ul>\n      */\n     public static final CSVFormat DEFAULT = // TODO rename to something more meaningful\n-            RFC4180\n-            .withIgnoreEmptyLines(true);\n+            defaults()\n+            .build();\n \n     /**\n      * Excel file format (using a comma as the value delimiter). Note that the actual value delimiter used by Excel is\n      * Note: this is currently the same as RFC4180\n      */\n     public static final CSVFormat EXCEL =\n-            PRISTINE\n-            .withDelimiter(COMMA)\n-            .withQuoteChar(DOUBLE_QUOTE)\n-            .withRecordSeparator(CRLF);\n+            defaults()\n+            .withIgnoreEmptyLines(false)\n+            .build();\n \n     /** Tab-delimited format, with quote; leading and trailing spaces ignored. */\n     public static final CSVFormat TDF =\n-            PRISTINE\n+            defaults()\n             .withDelimiter(TAB)\n-            .withQuoteChar(DOUBLE_QUOTE)\n             .withIgnoreSurroundingSpaces(true)\n-            .withIgnoreEmptyLines(true)\n-            .withRecordSeparator(CRLF);\n+            .build();\n \n     /**\n      * Default MySQL format used by the <tt>SELECT INTO OUTFILE</tt> and <tt>LOAD DATA INFILE</tt> operations. This is\n      *      http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n      */\n     public static final CSVFormat MYSQL =\n-            PRISTINE\n+            defaults()\n             .withDelimiter(TAB)\n+            .withQuoteChar(null)\n             .withEscape(ESCAPE)\n-            .withRecordSeparator(LF);\n-\n-    /**\n-     * Creates a basic CSV format.\n+            .withIgnoreEmptyLines(false)\n+            .withRecordSeparator(LF)\n+            .build();\n+\n+    /**\n+     * Factory method for creating CSV formats.\n      * \n      * @param delimiter \n      *            the char used for value separation, must not be a line break character\n      * @throws IllegalArgumentException if the delimiter is a line break character\n      */\n-    public CSVFormat(char delimiter){\n-        this(delimiter,  null, null, null, null, false, false, null, null);\n+    public static CSVFormatBuilder newFormat(char delimiter) {\n+        return new CSVFormatBuilder(delimiter);\n+    }\n+\n+    /**\n+     * Standard comma separated format, as for {@link #RFC4180} but allowing blank lines.\n+     * <ul>\n+     * <li>withDelimiter(',')</li>\n+     * <li>withQuoteChar('\"')</li>\n+     * <li>withEmptyLinesIgnored(true)</li>\n+     * <li>withLineSeparator(CRLF)</li>\n+     * </ul>\n+     */\n+    public static CSVFormatBuilder defaults() {\n+        return new CSVFormatBuilder(COMMA, DOUBLE_QUOTE, null, null, null, false, true, CRLF, null);\n     }\n \n     /**\n      *            the header\n      * @throws IllegalArgumentException if the delimiter is a line break character\n      */\n-    // package protected for use by test code\n-    CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final \n+    private CSVFormat(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final \n                     boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String lineSeparator, \n             final String[] header) {\n         if (isLineBreak(delimiter)) {\n     }\n \n     /**\n-     * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n-     * \n-     * @throws IllegalStateException\n-     */\n-    void validate() throws IllegalStateException {\n-        if (quoteChar != null && delimiter == quoteChar.charValue()) {\n-            throw new IllegalStateException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n-        }\n-\n-        if (escape != null && delimiter == escape.charValue()) {\n-            throw new IllegalStateException(\"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n-        }\n-\n-        if (commentStart != null && delimiter == commentStart.charValue()) {\n-            throw new IllegalStateException(\"The comment start character and the delimiter cannot be the same ('\" + commentStart + \n-                    \"')\");\n-        }\n-\n-        if (quoteChar != null && quoteChar.equals(commentStart)) {\n-            throw new IllegalStateException(\"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \n-                    \"')\");\n-        }\n-\n-        if (escape != null && escape.equals(commentStart)) {\n-            throw new IllegalStateException(\"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n-        }\n-\n-        if (escape == null && quotePolicy == Quote.NONE) {\n-            throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n-        }\n-    }\n-\n-    /**\n      * Returns the character delimiting the values (typically ';', ',' or '\\t').\n      *\n      * @return the delimiter character\n     }\n \n     /**\n-     * Returns a copy of this format using the specified delimiter character.\n-     *\n-     * @param delimiter\n-     *            the delimiter character\n-     * @return A copy of this format using the specified delimiter character\n-     * @throws IllegalArgumentException\n-     *             thrown if the specified character is a line break\n-     */\n-    public CSVFormat withDelimiter(final char delimiter) {\n-        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, header);\n-    }\n-\n-    /**\n      * Returns the character used to encapsulate values containing special characters.\n      *\n      * @return the quoteChar character\n     }\n \n     /**\n-     * Returns a copy of this format using the specified quoteChar character.\n-     *\n-     * @param quoteChar\n-     *            the quoteChar character\n-     * @return A copy of this format using the specified quoteChar character\n-     * @throws IllegalArgumentException\n-     *             thrown if the specified character is a line break\n-     */\n-    public CSVFormat withQuoteChar(final char quoteChar) {\n-        return withQuoteChar(Character.valueOf(quoteChar));\n-    }\n-\n-    /**\n-     * Returns a copy of this format using the specified quoteChar character.\n-     *\n-     * @param quoteChar\n-     *            the quoteChar character\n-     * @return A copy of this format using the specified quoteChar character\n-     * @throws IllegalArgumentException\n-     *             thrown if the specified character is a line break\n-     */\n-    public CSVFormat withQuoteChar(final Character quoteChar) {\n-        if (isLineBreak(quoteChar)) {\n-            throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n-        }\n-        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, header);\n-    }\n-\n-    /**\n      * Returns whether an quoteChar has been defined.\n      *\n      * @return {@code true} if an quoteChar is defined\n     }\n \n     /**\n-     * Returns a copy of this format using the specified character as the comment start marker.\n-     *\n-     * Note that the comment introducer character is only recognised at the start of a line.\n-     *\n-     * @param commentStart\n-     *            the comment start marker\n-     * @return A copy of this format using the specified character as the comment start marker\n-     * @throws IllegalArgumentException\n-     *             thrown if the specified character is a line break\n-     */\n-    public CSVFormat withCommentStart(final char commentStart) {\n-        return withCommentStart(Character.valueOf(commentStart));\n-    }\n-\n-    /**\n-     * Returns a copy of this format using the specified character as the comment start marker.\n-     *\n-     * Note that the comment introducer character is only recognised at the start of a line.\n-     *\n-     * @param commentStart\n-     *            the comment start marker\n-     * @return A copy of this format using the specified character as the comment start marker\n-     * @throws IllegalArgumentException\n-     *             thrown if the specified character is a line break\n-     */\n-    public CSVFormat withCommentStart(final Character commentStart) {\n-        if (isLineBreak(commentStart)) {\n-            throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n-        }\n-        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, header);\n-    }\n-\n-    /**\n      * Specifies whether comments are supported by this format.\n      *\n      * Note that the comment introducer character is only recognised at the start of a line.\n     }\n \n     /**\n-     * Returns a copy of this format using the specified escape character.\n-     *\n-     * @param escape\n-     *            the escape character\n-     * @return A copy of this format using the specified escape character\n-     * @throws IllegalArgumentException\n-     *             thrown if the specified character is a line break\n-     */\n-    public CSVFormat withEscape(final char escape) {\n-        return withEscape(Character.valueOf(escape));\n-    }\n-\n-    /**\n-     * Returns a copy of this format using the specified escape character.\n-     *\n-     * @param escape\n-     *            the escape character\n-     * @return A copy of this format using the specified escape character\n-     * @throws IllegalArgumentException\n-     *             thrown if the specified character is a line break\n-     */\n-    public CSVFormat withEscape(final Character escape) {\n-        if (isLineBreak(escape)) {\n-            throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n-        }\n-        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, header);\n-    }\n-\n-    /**\n      * Returns whether escape are being processed.\n      *\n      * @return {@code true} if escapes are processed\n     }\n \n     /**\n-     * Returns a copy of this format with the specified trimming behavior.\n-     *\n-     * @param ignoreSurroundingSpaces\n-     *            the trimming behavior, <tt>true</tt> to remove the surrounding spaces, <tt>false</tt> to leave the\n-     *            spaces as is.\n-     * @return A copy of this format with the specified trimming behavior.\n-     */\n-    public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n-        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, header);\n-    }\n-\n-    /**\n      * Specifies whether empty lines between records are ignored when parsing input.\n      *\n      * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty\n     }\n \n     /**\n-     * Returns a copy of this format with the specified empty line skipping behavior.\n-     *\n-     * @param ignoreEmptyLines\n-     *            the empty line skipping behavior, <tt>true</tt> to ignore the empty lines between the records,\n-     *            <tt>false</tt> to translate empty lines to empty records.\n-     * @return A copy of this format with the specified empty line skipping behavior.\n-     */\n-    public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n-        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, header);\n-    }\n-\n-    /**\n      * Returns the line separator delimiting output records.\n      *\n      * @return the line separator\n         return recordSeparator;\n     }\n \n-    /**\n-     * Returns a copy of this format using the specified output record separator.\n-     *\n-     * @param recordSeparator\n-     *            the record separator to use for output.\n-     *\n-     * @return A copy of this format using the specified output record separator\n-     */\n-    public CSVFormat withRecordSeparator(final char recordSeparator) {\n-        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, String.valueOf(recordSeparator), header);\n-    }\n-\n-    /**\n-     * Returns a copy of this format using the specified output record separator.\n-     *\n-     * @param recordSeparator\n-     *            the record separator to use for output.\n-     *\n-     * @return A copy of this format using the specified output record separator\n-     */\n-    public CSVFormat withRecordSeparator(final String recordSeparator) {\n-        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, header);\n-    }\n-\n-    /**\n-     * Returns a copy of this format using the specified output quote policy.\n-     *\n-     * @param quotePolicy\n-     *            the quote policy to use for output.\n-     *\n-     * @return A copy of this format using the specified output line separator\n-     */\n-    public CSVFormat withQuotePolicy(final Quote quotePolicy) {\n-        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, header);\n-    }\n-\n     String[] getHeader() {\n         return header;\n-    }\n-\n-    /**\n-     * Returns a copy of this format using the specified header. The header can either be parsed automatically from the\n-     * input file with:\n-     *\n-     * <pre>\n-     * CSVFormat format = aformat.withHeader();\n-     * </pre>\n-     *\n-     * or specified manually with:\n-     *\n-     * <pre>\n-     * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n-     * </pre>\n-     *\n-     * @param header\n-     *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n-     *\n-     * @return A copy of this format using the specified header\n-     */\n-    public CSVFormat withHeader(final String... header) {\n-        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, header);\n     }\n \n     /**\n     public Quote getQuotePolicy() {\n         return quotePolicy;\n     }\n-\n+    \n+    public static class CSVFormatBuilder {\n+\n+        private char delimiter;\n+        private Character quoteChar;\n+        private Quote quotePolicy;\n+        private Character commentStart;\n+        private Character escape;\n+        private boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n+        private boolean ignoreEmptyLines;\n+        private String recordSeparator; // for outputs\n+        private String[] header;\n+\n+        /**\n+         * Creates a customized CSV format.\n+         *\n+         * @param delimiter\n+         *            the char used for value separation, must not be a line break character\n+         * @param quoteChar\n+         *            the char used as value encapsulation marker\n+         * @param quotePolicy \n+         *            the quote policy\n+         * @param commentStart\n+         *            the char used for comment identification\n+         * @param escape\n+         *            the char used to escape special characters in values\n+         * @param ignoreSurroundingSpaces\n+         *            <tt>true</tt> when whitespaces enclosing values should be ignored\n+         * @param ignoreEmptyLines\n+         *            <tt>true</tt> when the parser should skip empty lines\n+         * @param recordSeparator\n+         *            the line separator to use for output\n+         * @param header\n+         *            the header\n+         * @throws IllegalArgumentException if the delimiter is a line break character\n+         */\n+        // package protected for use by test code\n+        CSVFormatBuilder(final char delimiter, final Character quoteChar, final Quote quotePolicy, final Character commentStart, final Character escape, final \n+                        boolean ignoreSurroundingSpaces, final boolean ignoreEmptyLines, final String lineSeparator, \n+                final String[] header) {\n+            if (isLineBreak(delimiter)) {\n+                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n+            }\n+            this.delimiter = delimiter;\n+            this.quoteChar = quoteChar;\n+            this.quotePolicy = quotePolicy;\n+            this.commentStart = commentStart;\n+            this.escape = escape;\n+            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n+            this.ignoreEmptyLines = ignoreEmptyLines;\n+            this.recordSeparator = lineSeparator;\n+            this.header = header;\n+        }\n+\n+        /**\n+         * Creates a basic CSVFormatBuilder.\n+         * \n+         * @param delimiter \n+         *            the char used for value separation, must not be a line break character\n+         * @throws IllegalArgumentException if the delimiter is a line break character\n+         */\n+        private CSVFormatBuilder(char delimiter){\n+            this(delimiter, null, null, null, null, false, false, null, null);\n+        }\n+\n+        public CSVFormat build() {\n+            validate();\n+            return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, header);\n+        }\n+        \n+        /**\n+         * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n+         * \n+         * @throws IllegalStateException\n+         */\n+        private void validate() throws IllegalStateException {\n+            if (quoteChar != null && delimiter == quoteChar.charValue()) {\n+                throw new IllegalStateException(\"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n+            }\n+        \n+            if (escape != null && delimiter == escape.charValue()) {\n+                throw new IllegalStateException(\"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n+            }\n+        \n+            if (commentStart != null && delimiter == commentStart.charValue()) {\n+                throw new IllegalStateException(\"The comment start character and the delimiter cannot be the same ('\" + commentStart + \n+                        \"')\");\n+            }\n+        \n+            if (quoteChar != null && quoteChar.equals(commentStart)) {\n+                throw new IllegalStateException(\"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \n+                        \"')\");\n+            }\n+        \n+            if (escape != null && escape.equals(commentStart)) {\n+                throw new IllegalStateException(\"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n+            }\n+        \n+            if (escape == null && quotePolicy == Quote.NONE) {\n+                throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n+            }\n+        }\n+\n+        /**\n+         * Sets the delimiter of the format to the specified character.\n+         *\n+         * @param delimiter\n+         *            the delimiter character\n+         * @return This builder with the specified character as delimiter\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withDelimiter(final char delimiter) {\n+            if (isLineBreak(delimiter)) {\n+                throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n+            }\n+            this.delimiter = delimiter; \n+            return this;\n+        }\n+\n+        /**\n+         * Sets the quoteChar of the format to the specified character.\n+         *\n+         * @param quoteChar\n+         *            the quoteChar character\n+         * @return This builder with the specified character as quoteChar\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withQuoteChar(final char quoteChar) {\n+            return withQuoteChar(Character.valueOf(quoteChar));\n+        }\n+\n+        /**\n+         * Sets the quoteChar of the format to the specified character.\n+         *\n+         * @param quoteChar\n+         *            the quoteChar character\n+         * @return This builder with the specified character as quoteChar\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withQuoteChar(final Character quoteChar) {\n+            if (isLineBreak(quoteChar)) {\n+                throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n+            }\n+            this.quoteChar = quoteChar;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the comment start marker of the format to the specified character.\n+         *\n+         * Note that the comment introducer character is only recognised at the start of a line.\n+         *\n+         * @param commentStart\n+         *            the comment start marker\n+         * @return This builder with the specified character as the comment start marker\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withCommentStart(final char commentStart) {\n+            return withCommentStart(Character.valueOf(commentStart));\n+        }\n+\n+        /**\n+         * Sets the comment start marker of the format to the specified character.\n+         *\n+         * Note that the comment introducer character is only recognised at the start of a line.\n+         *\n+         * @param commentStart\n+         *            the comment start marker\n+         * @return This builder with the specified character as the comment start marker\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withCommentStart(final Character commentStart) {\n+            if (isLineBreak(commentStart)) {\n+                throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n+            }\n+            this.commentStart = commentStart;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the escape character of the format to the specified character.\n+         *\n+         * @param escape\n+         *            the escape character\n+         * @return This builder with the specified character as the escape character\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withEscape(final char escape) {\n+            return withEscape(Character.valueOf(escape));\n+        }\n+\n+        /**\n+         * Sets the escape character of the format to the specified character.\n+         *\n+         * @param escape\n+         *            the escape character\n+         * @return This builder with the specified character as the escape character\n+         * @throws IllegalArgumentException\n+         *             thrown if the specified character is a line break\n+         */\n+        public CSVFormatBuilder withEscape(final Character escape) {\n+            if (isLineBreak(escape)) {\n+                throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n+            }\n+            this.escape = escape;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the header of the format. The header can either be parsed automatically from the\n+         * input file with:\n+         *\n+         * <pre>\n+         * CSVFormat format = aformat.withHeader();\n+         * </pre>\n+         *\n+         * or specified manually with:\n+         *\n+         * <pre>\n+         * CSVFormat format = aformat.withHeader(&quot;name&quot;, &quot;email&quot;, &quot;phone&quot;);\n+         * </pre>\n+         *\n+         * @param header\n+         *            the header, <tt>null</tt> if disabled, empty if parsed automatically, user specified otherwise.\n+         *\n+         * @return This builder with the specified header\n+         */\n+        public CSVFormatBuilder withHeader(final String... header) {\n+            this.header = header;\n+            return this;\n+        }\n+        \n+        /**\n+         * Sets the trimming behavior of the format.\n+         *\n+         * @param ignoreSurroundingSpaces\n+         *            the trimming behavior, <tt>true</tt> to remove the surrounding spaces, <tt>false</tt> to leave the\n+         *            spaces as is.\n+         * @return This builder with the specified trimming behavior.\n+         */\n+        public CSVFormatBuilder withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n+            this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the empty line skipping behavior of the format.\n+         *\n+         * @param ignoreEmptyLines\n+         *            the empty line skipping behavior, <tt>true</tt> to ignore the empty lines between the records,\n+         *            <tt>false</tt> to translate empty lines to empty records.\n+         * @return This builder with the specified empty line skipping behavior.\n+         */\n+        public CSVFormatBuilder withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n+            this.ignoreEmptyLines = ignoreEmptyLines;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the record separator of the format to the specified character.\n+         *\n+         * @param recordSeparator\n+         *            the record separator to use for output.\n+         *\n+         * @return This builder with the the specified output record separator\n+         */\n+        public CSVFormatBuilder withRecordSeparator(final char recordSeparator) {\n+            return withRecordSeparator(String.valueOf(recordSeparator));\n+        }\n+\n+        /**\n+         * Sets the record separator of the format to the specified String.\n+         *\n+         * @param recordSeparator\n+         *            the record separator to use for output.\n+         *\n+         * @return This builder with the the specified output record separator\n+         */\n+        public CSVFormatBuilder withRecordSeparator(final String recordSeparator) {\n+            this.recordSeparator = recordSeparator;\n+            return this;\n+        }\n+\n+        /**\n+         * Sets the output quote policy of the format to the specified value.\n+         *\n+         * @param quotePolicy\n+         *            the quote policy to use for output.\n+         *\n+         * @return This builder with the specified quote policy\n+         */\n+        public CSVFormatBuilder withQuotePolicy(final Quote quotePolicy) {\n+            this.quotePolicy = quotePolicy;\n+            return this;\n+        }\n+    }\n }\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n      *             thrown if the parameters of the format are inconsistent\n      */\n     public CSVParser(final Reader input, final CSVFormat format) throws IOException {\n-        format.validate();\n         this.lexer = new CSVLexer(format, new ExtendedBufferedReader(input));\n         this.headerMap = initializeHeader(format);\n     }\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n     public CSVPrinter(final Appendable out, final CSVFormat format) {\n         this.out = out;\n         this.format = format == null ? CSVFormat.DEFAULT : format;\n-        this.format.validate();\n     }\n \n     // ======================================================\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n import java.util.Collection;\n import java.util.List;\n \n+import org.apache.commons.csv.CSVFormat.CSVFormatBuilder;\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.Parameterized;\n         assertTrue(testName+\" require 1 param\", split.length >= 1);\n          // first line starts with csv data file name\n         final BufferedReader csvFile = new BufferedReader(new FileReader(new File(BASE, split[0])));\n-        CSVFormat fmt = new CSVFormat(',').withQuoteChar('\"');\n+        CSVFormatBuilder builder = CSVFormat.newFormat(',').withQuoteChar('\"');\n+        CSVFormat fmt = builder.build(); \n         boolean checkComments = false;\n         for(int i=1; i < split.length; i++) {\n             final String option = split[i];\n             final String[] option_parts = option.split(\"=\",2);\n             if (\"IgnoreEmpty\".equalsIgnoreCase(option_parts[0])){\n-                fmt = fmt.withIgnoreEmptyLines(Boolean.parseBoolean(option_parts[1]));\n+                fmt = builder.withIgnoreEmptyLines(Boolean.parseBoolean(option_parts[1])).build();\n             } else if (\"IgnoreSpaces\".equalsIgnoreCase(option_parts[0])) {\n-                fmt = fmt.withIgnoreSurroundingSpaces(Boolean.parseBoolean(option_parts[1]));\n+                fmt = builder.withIgnoreSurroundingSpaces(Boolean.parseBoolean(option_parts[1])).build();\n             } else if (\"CommentStart\".equalsIgnoreCase(option_parts[0])) {\n-                fmt = fmt.withCommentStart(option_parts[1].charAt(0));\n+                fmt = builder.withCommentStart(option_parts[1].charAt(0)).build();\n             } else if (\"CheckComments\".equalsIgnoreCase(option_parts[0])) {\n                 checkComments = true;\n             } else {\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatBuilderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import static org.apache.commons.csv.Constants.*;\n+import static org.junit.Assert.*;\n+\n+import org.apache.commons.csv.CSVFormat.CSVFormatBuilder;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+/**\n+ * \n+ * \n+ * @version $Id$\n+ */\n+public class CSVFormatBuilderTest {\n+\n+    private CSVFormatBuilder builder;\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        builder = new CSVFormatBuilder('+', '!', null, '#', '!', true, true, CRLF, null);\n+    }\n+\n+    @Test\n+    public void testDelimiter() {\n+        assertEquals('?', builder.withDelimiter('?').build().getDelimiter());\n+    }\n+    \n+    @Test(expected = IllegalArgumentException.class)\n+    public void testNewFormatLFThrowsException() {\n+        CSVFormat.newFormat(LF);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testNewFormatCRThrowsException() {\n+        CSVFormat.newFormat(CR);\n+    }\n+    \n+    @Test(expected = IllegalArgumentException.class)\n+    public void testWithDelimiterLFThrowsException() {\n+        builder.withDelimiter(LF).build();\n+    }\n+    \n+    @Test(expected = IllegalStateException.class)\n+    public void testDelimiterSameAsEscapeThrowsException() {\n+        builder.withDelimiter('!').withEscape('!').build();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testDelimiterSameAsCommentStartThrowsException() {\n+        builder.withDelimiter('!').withCommentStart('!').build();\n+    }\n+\n+    @Test\n+    public void testQuoteChar() {\n+        assertEquals('?', builder.withQuoteChar('?').build().getQuoteChar().charValue());\n+    }\n+    \n+    @Test(expected = IllegalStateException.class)\n+    public void testQuoteCharSameAsCommentStartThrowsException() {\n+        builder.withQuoteChar('!').withCommentStart('!').build();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType() {\n+        // Cannot assume that callers won't use different Character objects\n+        builder.withQuoteChar(new Character('!')).withCommentStart('!').build();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testQuoteCharSameAsDelimiterThrowsException() {\n+        builder.withQuoteChar('!').withDelimiter('!').build();\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testWithQuoteLFThrowsException() {\n+        builder.withQuoteChar(LF).build();\n+    }\n+\n+    @Test\n+    public void testQuotePolicy() {\n+        assertEquals(Quote.ALL, builder.withQuotePolicy(Quote.ALL).build().getQuotePolicy());\n+    }\n+    \n+    @Test(expected = IllegalStateException.class)\n+    public void testQuotePolicyNoneWithoutEscapeThrowsException() {\n+        CSVFormat.newFormat('!').withQuotePolicy(Quote.NONE).build();\n+    }\n+\n+    @Test\n+    public void testCommentStart() {\n+        assertEquals('?', builder.withCommentStart('?').build().getCommentStart().charValue());\n+    }\n+    \n+    @Test(expected = IllegalArgumentException.class)\n+    public void testWithCommentStartCRThrowsException() {\n+        builder.withCommentStart(CR).build();\n+    }\n+\n+    @Test\n+    public void testRecoardSeparator() {\n+        assertEquals(\"?\", builder.withRecordSeparator(\"?\").build().getRecordSeparator());\n+    }\n+    \n+    @Test\n+    public void testEscape() {\n+        assertEquals('?', builder.withEscape('?').build().getEscape().charValue());\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void testWithEscapeCRThrowsExceptions() {\n+        builder.withEscape(CR).build();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testEscapeSameAsCommentStartThrowsException() {\n+        builder.withEscape('!').withCommentStart('!').build();\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testEscapeSameAsCommentStartThrowsExceptionForWrapperType() {\n+        // Cannot assume that callers won't use different Character objects\n+        builder.withEscape(new Character('!')).withCommentStart(new Character('!')).build();\n+    }\n+\n+    @Test\n+    public void testIgnoreSurroundingSpaces() {\n+        assertFalse(builder.withIgnoreSurroundingSpaces(false).build().getIgnoreSurroundingSpaces());\n+    }\n+    \n+    @Test\n+    public void testIgnoreEmptyLines() {\n+        assertFalse(builder.withIgnoreEmptyLines(false).build().getIgnoreEmptyLines());\n+    }\n+}\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n \n+import org.apache.commons.csv.CSVFormat.CSVFormatBuilder;\n import org.junit.Test;\n \n /**\n public class CSVFormatTest {\n \n     @Test\n-    public void testImmutalibity() {\n-        final CSVFormat format = new CSVFormat('!', '!', Quote.MINIMAL, '!', '!', true, true, CRLF, null);\n-\n-        format.withDelimiter('?');\n-        format.withQuoteChar('?');\n-        format.withQuotePolicy(Quote.ALL);\n-        format.withCommentStart('?');\n-        format.withRecordSeparator(\"?\");\n-        format.withEscape('?');\n-        format.withIgnoreSurroundingSpaces(false);\n-        format.withIgnoreEmptyLines(false);\n-\n-        assertEquals('!', format.getDelimiter());\n-        assertEquals('!', format.getQuoteChar().charValue());\n-        assertEquals('!', format.getCommentStart().charValue());\n-        assertEquals('!', format.getEscape().charValue());\n-        assertEquals(CRLF, format.getRecordSeparator());\n-\n-        assertTrue(format.getIgnoreSurroundingSpaces());\n-        assertTrue(format.getIgnoreEmptyLines());\n-\n-        assertEquals(Quote.MINIMAL, format.getQuotePolicy());\n-    }\n-\n-    @Test\n-    public void testMutators() {\n-        final CSVFormat format = new CSVFormat('!', '!', null, '!', '!', true, true, CRLF, null);\n-\n-        assertEquals('?', format.withDelimiter('?').getDelimiter());\n-        assertEquals('?', format.withQuoteChar('?').getQuoteChar().charValue());\n-        assertEquals(Quote.ALL, format.withQuotePolicy(Quote.ALL).getQuotePolicy());\n-        assertEquals('?', format.withCommentStart('?').getCommentStart().charValue());\n-        assertEquals(\"?\", format.withRecordSeparator(\"?\").getRecordSeparator());\n-        assertEquals('?', format.withEscape('?').getEscape().charValue());\n-\n-        assertFalse(format.withIgnoreSurroundingSpaces(false).getIgnoreSurroundingSpaces());\n-        assertFalse(format.withIgnoreEmptyLines(false).getIgnoreEmptyLines());\n-    }\n-\n-    @Test\n     public void testFormat() {\n         final CSVFormat format = CSVFormat.DEFAULT;\n \n         assertEquals(\"\", format.format());\n         assertEquals(\"a,b,c\", format.format(\"a\", \"b\", \"c\"));\n         assertEquals(\"\\\"x,y\\\",z\", format.format(\"x,y\", \"z\"));\n-    }\n-\n-    @Test\n-    public void testValidation() {\n-        try {\n-            new CSVFormat('\\n');\n-            fail();\n-        } catch (final IllegalArgumentException e) {\n-            // expected\n-        }\n-\n-        try {\n-            new CSVFormat('\\r');\n-            fail();\n-        } catch (final IllegalArgumentException e) {\n-            // expected\n-        }\n-\n-        final CSVFormat format = CSVFormat.DEFAULT;\n-\n-        try {\n-            format.withDelimiter('\\n');\n-            fail();\n-        } catch (final IllegalArgumentException e) {\n-            // expected\n-        }\n-\n-        try {\n-            format.withEscape('\\r');\n-            fail();\n-        } catch (final IllegalArgumentException e) {\n-            // expected\n-        }\n-\n-        try {\n-            format.withQuoteChar('\\n');\n-            fail();\n-        } catch (final IllegalArgumentException e) {\n-            // expected\n-        }\n-\n-        try {\n-            format.withCommentStart('\\r');\n-            fail();\n-        } catch (final IllegalArgumentException e) {\n-            // expected\n-        }\n-\n-        try {\n-            format.withDelimiter('!').withEscape('!').validate();\n-            fail();\n-        } catch (final IllegalStateException e) {\n-            // expected\n-        }\n-\n-        try {\n-            format.withDelimiter('!').withCommentStart('!').validate();\n-            fail();\n-        } catch (final IllegalStateException e) {\n-            // expected\n-        }\n-\n-        try {\n-            format.withQuoteChar('!').withCommentStart('!').validate();\n-            fail();\n-        } catch (final IllegalStateException e) {\n-            // expected\n-        }\n-\n-        // Cannot assume that callers won't use different Character objects\n-        try {\n-            format.withQuoteChar(new Character('!')).withCommentStart('!').validate();\n-            fail();\n-        } catch (final IllegalStateException e) {\n-            // expected\n-        }\n-\n-        format.withQuoteChar(null).withCommentStart(null).validate();\n-\n-        try {\n-            format.withEscape('!').withCommentStart('!').validate();\n-            fail();\n-        } catch (final IllegalStateException e) {\n-            // expected\n-        }\n-\n-        // Cannot assume that callers won't use different Character objects\n-        try {\n-            format.withEscape(new Character('!')).withCommentStart(new Character('!')).validate();\n-            fail();\n-        } catch (final IllegalStateException e) {\n-            // expected\n-        }\n-\n-        format.withEscape(null).withCommentStart(null).validate();\n-\n-\n-        try {\n-            format.withQuoteChar('!').withDelimiter('!').validate();\n-            fail();\n-        } catch (final IllegalStateException e) {\n-            // expected\n-        }\n-\n-        try {\n-            format.withQuoteChar('!').withQuotePolicy(Quote.NONE).validate();\n-            fail();\n-        } catch (final IllegalStateException e) {\n-            // expected\n-        }\n     }\n \n     @SuppressWarnings(\"boxing\") // no need to worry about boxing here\n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n     @Test\n     public void testNextToken1() throws IOException {\n         final String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n-        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final Lexer parser = getLexer(code, CSVFormat.defaults().withIgnoreSurroundingSpaces(true).build());\n         assertTokenEquals(TOKEN, \"abc\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"def\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"hijk\", parser.nextToken(new Token()));\n                 \"\\n\"+\n                 \"\\n\"+\n                 \"# Final comment\\n\";       // 7\n-        final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n+        final CSVFormat format = CSVFormat.defaults().withCommentStart('#').build();\n         assertTrue(\"Should ignore empty lines\", format.getIgnoreEmptyLines());\n \n         final Lexer parser = getLexer(code, format);\n                 \"\\n\"+                      // 6b\n                 \"\\n\"+                      // 6c\n                 \"# Final comment\\n\";       // 7\n-        final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#').withIgnoreEmptyLines(false);\n+        final CSVFormat format = CSVFormat.defaults().withCommentStart('#').withIgnoreEmptyLines(false).build();\n         assertFalse(\"Should not ignore empty lines\", format.getIgnoreEmptyLines());\n \n         final Lexer parser = getLexer(code, format);\n         *       \\,,\n         */\n         final String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\n-        final CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\').withIgnoreEmptyLines(false);\n+        final CSVFormat format = CSVFormat.defaults().withEscape('\\\\').withIgnoreEmptyLines(false).build();\n         assertTrue(format.isEscaping());\n         final Lexer parser = getLexer(code, format);\n \n     @Test\n     public void testNextToken3BadEscaping() throws IOException {\n         final String code = \"a,b,c\\\\\";\n-        final CSVFormat format = CSVFormat.DEFAULT.withEscape('\\\\');\n+        final CSVFormat format = CSVFormat.defaults().withEscape('\\\\').build();\n         assertTrue(format.isEscaping());\n         final Lexer parser = getLexer(code, format);\n \n         *        a,  \" foo \" ,b\n         */\n         final String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n-        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final Lexer parser = getLexer(code, CSVFormat.defaults().withIgnoreSurroundingSpaces(true).build());\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(TOKEN, \"foo\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b\", parser.nextToken(new Token()));\n         *       ;;\n         */\n         final String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n-        final CSVFormat format = CSVFormat.DEFAULT.withDelimiter(';').withQuoteChar('\\'').withCommentStart('!');\n+        final CSVFormat format = CSVFormat.defaults().withDelimiter(';').withQuoteChar('\\'').withCommentStart('!').build();\n         final Lexer parser = getLexer(code, format);\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b and ' more\\n\", parser.nextToken(new Token()));\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n \n     @Test\n     public void testGetLine() throws IOException {\n-        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.defaults().withIgnoreSurroundingSpaces(true).build());\n         for (final String[] re : RESULT) {\n             assertArrayEquals(re, parser.nextRecord().values());\n         }\n \n     @Test\n     public void testGetRecords() throws IOException {\n-        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final CSVParser parser = new CSVParser(new StringReader(CSVINPUT), CSVFormat.defaults().withIgnoreSurroundingSpaces(true).build());\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(RESULT.length, records.size());\n         assertTrue(records.size() > 0);\n         };\n \n \n-        final CSVFormat format = new CSVFormat(',').withQuoteChar('\\'').withEscape('/')\n-                               .withIgnoreEmptyLines(true).withRecordSeparator(CRLF);\n+        final CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\\'').withEscape('/')\n+                               .withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build();\n \n         final CSVParser parser = new CSVParser(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n         };\n \n \n-        final CSVFormat format = new CSVFormat(',').withEscape('/')\n-                .withIgnoreEmptyLines(true).withRecordSeparator(CRLF);\n+        final CSVFormat format = CSVFormat.newFormat(',').withEscape('/')\n+                .withIgnoreEmptyLines(true).withRecordSeparator(CRLF).build();\n \n         final CSVParser parser = new CSVParser(code, format);\n         final List<CSVRecord> records = parser.getRecords();\n                 {\"\\n\", \" \", \"#\"},\n         };\n \n-        format = CSVFormat.DEFAULT.withCommentStart('#');\n+        format = CSVFormat.defaults().withCommentStart('#').build();\n         parser = new CSVParser(code, format);\n         records = parser.getRecords();\n \n     public void testHeader() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader().parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.defaults().withHeader().build().parse(in).iterator();\n \n         for (int i = 0; i < 2; i++) {\n             assertTrue(records.hasNext());\n     public void testHeaderComment() throws Exception {\n         final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.defaults().withCommentStart('#').withHeader().build().parse(in).iterator();\n \n         for (int i = 0; i < 2; i++) {\n             assertTrue(records.hasNext());\n     public void testProvidedHeader() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2,3\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.defaults().withHeader(\"A\", \"B\", \"C\").build().parse(in).iterator();\n \n         for (int i = 0; i < 3; i++) {\n             assertTrue(records.hasNext());\n     public void testMappedButNotSetAsOutlook2007ContactExport() throws Exception {\n         final Reader in = new StringReader(\"a,b,c\\n1,2\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\").parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.defaults().withHeader(\"A\", \"B\", \"C\").build().parse(in).iterator();\n \n         // header record\n         assertTrue(records.hasNext());\n     }\n \n     public void testGetHeaderMap() throws Exception {\n-        final CSVParser parser = new CSVParser(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\n+        final CSVParser parser = new CSVParser(\"a,b,c\\n1,2,3\\nx,y,z\", CSVFormat.defaults().withHeader(\"A\", \"B\", \"C\").build());\n         final Map<String, Integer> headerMap = parser.getHeaderMap();\n         final Iterator<String> columnNames = headerMap.keySet().iterator();\n         // Headers are iterated in column order.\n     @Test\n     public void testGetRecordWithMultiiLineValues() throws Exception {\n         final CSVParser parser = new CSVParser(\"\\\"a\\r\\n1\\\",\\\"a\\r\\n2\\\"\" + CRLF + \"\\\"b\\r\\n1\\\",\\\"b\\r\\n2\\\"\" + CRLF + \"\\\"c\\r\\n1\\\",\\\"c\\r\\n2\\\"\",\n-                CSVFormat.DEFAULT.withRecordSeparator(CRLF));\n+                CSVFormat.defaults().withRecordSeparator(CRLF).build());\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n         assertEquals(0, parser.getLineNumber());\n     }\n \n     private void validateRecordNumbers(String lineSeparator) throws IOException {\n-        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n+        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.defaults().withRecordSeparator(lineSeparator).build());\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n         assertNotNull(record = parser.nextRecord());\n     }\n \n     private void validateLineNumbers(String lineSeparator) throws IOException {\n-        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.DEFAULT.withRecordSeparator(lineSeparator));\n+        final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.defaults().withRecordSeparator(lineSeparator).build());\n         assertEquals(0, parser.getLineNumber());\n         assertNotNull(parser.nextRecord());\n         assertEquals(1, parser.getLineNumber());\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n     @Test\n     public void testMultiLineComment() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.defaults().withCommentStart('#').build());\n         printer.printComment(\"This is a comment\\non multiple lines\");\n \n         assertEquals(\"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator, sw.toString());\n     @Test\n     public void testQuoteAll() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuotePolicy(Quote.ALL));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.defaults().withQuotePolicy(Quote.ALL).build());\n         printer.printRecord(\"a\", \"b\\nc\", \"d\");\n         assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",\\\"d\\\"\" + recordSeparator, sw.toString());\n     }\n     @Test\n     public void testQuoteNonNumeric() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuotePolicy(Quote.NON_NUMERIC));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.defaults().withQuotePolicy(Quote.NON_NUMERIC).build());\n         printer.printRecord(\"a\", \"b\\nc\", Integer.valueOf(1));\n         assertEquals(\"\\\"a\\\",\\\"b\\nc\\\",1\" + recordSeparator, sw.toString());\n     }\n     @Test\n     public void testSingleLineComment() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.defaults().withCommentStart('#').build());\n         printer.printComment(\"This is a comment\");\n \n         assertEquals(\"# This is a comment\" + recordSeparator, sw.toString());\n--- a/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/perf/PerformanceTest.java\n     }\n \n     private long parse(final Reader in, boolean traverseColumns) throws IOException {\n-        final CSVFormat format = CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(false);\n+        final CSVFormat format = CSVFormat.defaults().withIgnoreSurroundingSpaces(false).build();\n         long recordCount = 0;\n         for (final CSVRecord record : format.parse(in)) {\n             recordCount++;", "timestamp": 1352929836, "metainfo": ""}