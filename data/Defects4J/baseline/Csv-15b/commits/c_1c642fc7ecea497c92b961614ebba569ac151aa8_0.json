{"sha": "1c642fc7ecea497c92b961614ebba569ac151aa8", "log": "Set EOL-style to native.  ", "commit": "\n--- a/src/java/org/apache/commons/csv/CharBuffer.java\n+++ b/src/java/org/apache/commons/csv/CharBuffer.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.commons.csv;\n-\n-/**\n- * A simple StringBuffer replacement that aims to \n- * reduce copying as much as possible. The buffer\n- * grows as necessary.\n- * This class is not thread safe.\n- * \n- * @author Ortwin Glck\n- */\n-public class CharBuffer {\n-    private char[] c;\n-    /**\n-     * Actually used number of characters in the array. \n-     * It is also the index at which\n-     * a new character will be inserted into <code>c</code>. \n-     */ \n-    private int length;\n-    \n-    /**\n-     * Creates a new CharBuffer with an initial capacity of 32 characters.\n-     */\n-    public CharBuffer() {\n-        this(32);\n-    }\n-    \n-    /**\n-     * Creates a new CharBuffer with an initial capacity \n-     * of <code>length</code> characters.\n-     */\n-    public CharBuffer(final int length) {\n-        if (length == 0) throw new IllegalArgumentException(\"Can't create an empty CharBuffer\");\n-        this.c = new char[length];\n-    }\n-    \n-    /**\n-     * Empties the buffer. The capacity still remains the same, so no memory is freed.\n-     */\n-    public void clear() {\n-        length = 0;\n-    }\n-    \n-    /**\n-     * Returns the number of characters in the buffer.\n-     * @return the number of characters\n-     */\n-    public int length() {\n-        return length;\n-    }\n-    \n-    /**\n-     * Returns the current capacity of the buffer.\n-     * @return the maximum number of characters that can be stored in this buffer without\n-     * resizing it.\n-     */\n-    public int capacity() {\n-        return c.length;\n-    }\n-    \n-    /**\n-     * Appends the contents of <code>cb</code> to the end of this CharBuffer.\n-     * @param cb the CharBuffer to append or null\n-     */\n-    public void append(final CharBuffer cb) {\n-        if (cb == null) return;\n-        provideCapacity(length + cb.length);\n-        System.arraycopy(cb.c, 0, c, length, cb.length);\n-        length += cb.length;\n-    }\n-    \n-    /**\n-     * Appends <code>s</code> to the end of this CharBuffer.\n-     * This method involves copying the new data once!\n-     * @param s the String to append or null\n-     */\n-    public void append(final String s) {\n-        if (s == null) return;\n-        append(s.toCharArray());\n-    }\n-    \n-    /**\n-     * Appends <code>sb</code> to the end of this CharBuffer.\n-     * This method involves copying the new data once!\n-     * @param sb the StringBuffer to append or null\n-     */\n-    public void append(final StringBuffer sb) {\n-        if (sb == null) return;\n-        provideCapacity(length + sb.length());\n-        sb.getChars(0, sb.length(), c, length);\n-        length += sb.length();\n-    }\n-    \n-    /**\n-     * Appends <code>data</code> to the end of this CharBuffer.\n-     * This method involves copying the new data once!\n-     * @param data the char[] to append or null\n-     */\n-    public void append(final char[] data) {\n-        if (data == null) return;\n-        provideCapacity(length + data.length);\n-        System.arraycopy(data, 0, c, length, data.length);\n-        length += data.length;\n-    }\n-    \n-    /**\n-     * Appends a single character to the end of this CharBuffer.\n-     * This method involves copying the new data once!\n-     * @param data the char to append\n-     */\n-    public void append(final char data) {\n-        provideCapacity(length + 1);\n-        c[length] = data;\n-        length++;\n-    }\n-    \n-    /**\n-     * Shrinks the capacity of the buffer to the current length if necessary.\n-     * This method involves copying the data once!\n-     */\n-    public void shrink() {\n-        if (c.length == length) return;\n-        char[] newc = new char[length];\n-        System.arraycopy(c, 0, newc, 0, length);\n-        c = newc;\n-    }\n-\n-    /**\n-     * Returns the contents of the buffer as a char[]. The returned array may\n-     * be the internal array of the buffer, so the caller must take care when\n-     * modifying it.\n-     * This method allows to avoid copying if the caller knows the exact capacity\n-     * before.\n-     * @return\n-     */\n-    public char[] getCharacters() {\n-        if (c.length == length) return c;\n-        char[] chars = new char[length];\n-        System.arraycopy(c, 0, chars, 0, length);\n-        return chars;\n-    }\n-    \n-    /**\n-     * Converts the contents of the buffer into a StringBuffer.\n-     * This method involves copying the new data once!\n-     * @return\n-     */\n-    public StringBuffer toStringBuffer() {\n-        StringBuffer sb = new StringBuffer(length);\n-        sb.append(c, 0, length);\n-        return sb;\n-    }\n-    \n-    /**\n-     * Converts the contents of the buffer into a StringBuffer.\n-     * This method involves copying the new data once!\n-     * @return\n-     */\n-    public String toString() {\n-        return new String(c, 0, length);\n-    }\n-    \n-    /**\n-     * Copies the data into a new array of at least <code>capacity</code> size.\n-     * @param capacity\n-     */\n-    public void provideCapacity(final int capacity) {\n-        if (c.length >= capacity) return;\n-        int newcapacity = capacity;\n-        char[] newc = new char[newcapacity];\n-        System.arraycopy(c, 0, newc, 0, length);\n-        c = newc;\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.csv;\n+\n+/**\n+ * A simple StringBuffer replacement that aims to \n+ * reduce copying as much as possible. The buffer\n+ * grows as necessary.\n+ * This class is not thread safe.\n+ * \n+ * @author Ortwin Glck\n+ */\n+public class CharBuffer {\n+    private char[] c;\n+    /**\n+     * Actually used number of characters in the array. \n+     * It is also the index at which\n+     * a new character will be inserted into <code>c</code>. \n+     */ \n+    private int length;\n+    \n+    /**\n+     * Creates a new CharBuffer with an initial capacity of 32 characters.\n+     */\n+    public CharBuffer() {\n+        this(32);\n+    }\n+    \n+    /**\n+     * Creates a new CharBuffer with an initial capacity \n+     * of <code>length</code> characters.\n+     */\n+    public CharBuffer(final int length) {\n+        if (length == 0) throw new IllegalArgumentException(\"Can't create an empty CharBuffer\");\n+        this.c = new char[length];\n+    }\n+    \n+    /**\n+     * Empties the buffer. The capacity still remains the same, so no memory is freed.\n+     */\n+    public void clear() {\n+        length = 0;\n+    }\n+    \n+    /**\n+     * Returns the number of characters in the buffer.\n+     * @return the number of characters\n+     */\n+    public int length() {\n+        return length;\n+    }\n+    \n+    /**\n+     * Returns the current capacity of the buffer.\n+     * @return the maximum number of characters that can be stored in this buffer without\n+     * resizing it.\n+     */\n+    public int capacity() {\n+        return c.length;\n+    }\n+    \n+    /**\n+     * Appends the contents of <code>cb</code> to the end of this CharBuffer.\n+     * @param cb the CharBuffer to append or null\n+     */\n+    public void append(final CharBuffer cb) {\n+        if (cb == null) return;\n+        provideCapacity(length + cb.length);\n+        System.arraycopy(cb.c, 0, c, length, cb.length);\n+        length += cb.length;\n+    }\n+    \n+    /**\n+     * Appends <code>s</code> to the end of this CharBuffer.\n+     * This method involves copying the new data once!\n+     * @param s the String to append or null\n+     */\n+    public void append(final String s) {\n+        if (s == null) return;\n+        append(s.toCharArray());\n+    }\n+    \n+    /**\n+     * Appends <code>sb</code> to the end of this CharBuffer.\n+     * This method involves copying the new data once!\n+     * @param sb the StringBuffer to append or null\n+     */\n+    public void append(final StringBuffer sb) {\n+        if (sb == null) return;\n+        provideCapacity(length + sb.length());\n+        sb.getChars(0, sb.length(), c, length);\n+        length += sb.length();\n+    }\n+    \n+    /**\n+     * Appends <code>data</code> to the end of this CharBuffer.\n+     * This method involves copying the new data once!\n+     * @param data the char[] to append or null\n+     */\n+    public void append(final char[] data) {\n+        if (data == null) return;\n+        provideCapacity(length + data.length);\n+        System.arraycopy(data, 0, c, length, data.length);\n+        length += data.length;\n+    }\n+    \n+    /**\n+     * Appends a single character to the end of this CharBuffer.\n+     * This method involves copying the new data once!\n+     * @param data the char to append\n+     */\n+    public void append(final char data) {\n+        provideCapacity(length + 1);\n+        c[length] = data;\n+        length++;\n+    }\n+    \n+    /**\n+     * Shrinks the capacity of the buffer to the current length if necessary.\n+     * This method involves copying the data once!\n+     */\n+    public void shrink() {\n+        if (c.length == length) return;\n+        char[] newc = new char[length];\n+        System.arraycopy(c, 0, newc, 0, length);\n+        c = newc;\n+    }\n+\n+    /**\n+     * Returns the contents of the buffer as a char[]. The returned array may\n+     * be the internal array of the buffer, so the caller must take care when\n+     * modifying it.\n+     * This method allows to avoid copying if the caller knows the exact capacity\n+     * before.\n+     * @return\n+     */\n+    public char[] getCharacters() {\n+        if (c.length == length) return c;\n+        char[] chars = new char[length];\n+        System.arraycopy(c, 0, chars, 0, length);\n+        return chars;\n+    }\n+    \n+    /**\n+     * Converts the contents of the buffer into a StringBuffer.\n+     * This method involves copying the new data once!\n+     * @return\n+     */\n+    public StringBuffer toStringBuffer() {\n+        StringBuffer sb = new StringBuffer(length);\n+        sb.append(c, 0, length);\n+        return sb;\n+    }\n+    \n+    /**\n+     * Converts the contents of the buffer into a StringBuffer.\n+     * This method involves copying the new data once!\n+     * @return\n+     */\n+    public String toString() {\n+        return new String(c, 0, length);\n+    }\n+    \n+    /**\n+     * Copies the data into a new array of at least <code>capacity</code> size.\n+     * @param capacity\n+     */\n+    public void provideCapacity(final int capacity) {\n+        if (c.length >= capacity) return;\n+        int newcapacity = capacity;\n+        char[] newc = new char[newcapacity];\n+        System.arraycopy(c, 0, newc, 0, length);\n+        c = newc;\n+    }\n+}\n--- a/src/java/org/apache/commons/csv/writer/CSVConfig.java\n+++ b/src/java/org/apache/commons/csv/writer/CSVConfig.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.commons.csv.writer;\n-\n-import java.io.InputStream;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.List;\n-\n-/**\n- * The CSVConfig is used to configure the CSV writer\n- *\n- * @author Martin van den Bemt\n- * @version $Id: $\n- */\n-public class CSVConfig {\n-\n-    /** specifies if it is a fixed width csv file **/\n-    private boolean fixedWidth;\n-    /** list of fields **/\n-    private List fields;\n-\n-    /** Do no do any filling **/\n-    public static final int FILLNONE = 0;\n-    /** Fill content the the left. Mainly usable together with fixedWidth **/\n-    public static final int FILLLEFT = 1;\n-    /** Fill content to the right. Mainly usable together with fixedWidth **/\n-    public static final int FILLRIGHT = 2;\n-    \n-    /** The fill pattern */\n-    private int fill;\n-    /** The fill char. Defaults to a space */\n-    private char fillChar = ' ';\n-    /** The seperator character. Defaults to , */\n-    private char delimiter = ',';\n-    /** Should we ignore the delimiter. Defaults to false */\n-    private boolean ignoreDelimiter = false;\n-    /** the value delimiter. Defaults to \" */\n-    private char valueDelimiter = '\"';\n-    /** Should we ignore the value delimiter. Defaults to true */\n-    private boolean ignoreValueDelimiter = true;\n-    /** Specifies if we want to use a field header */\n-    private boolean fieldHeader = false;\n-    /** Specifies if the end of the line needs to be trimmed */\n-    private boolean endTrimmed = false;\n-    /**\n-     * \n-     */\n-    public CSVConfig() {\n-        super();\n-    }\n-    \n-    /**\n-     * @return if the CSV file is fixedWidth\n-     */\n-    public boolean isFixedWidth() {\n-        return fixedWidth;\n-    }\n-    \n-    /**\n-     * Specify if the CSV file is fixed width.\n-     * Defaults to false\n-     * @param fixedWidth the fixedwidth\n-     */\n-    public void setFixedWidth(boolean fixedWidth) {\n-        this.fixedWidth = fixedWidth;\n-    }\n-    \n-    public void addField(CSVField field) {\n-        if (fields == null) {\n-            fields = new ArrayList();\n-        }\n-        fields.add(field);\n-    }\n-    \n-    /**\n-     * Set the fields that should be used by the writer.\n-     * This will overwrite currently added fields completely!\n-     * @param csvFields the csvfields array. If null it will do nothing\n-     */\n-    public void setFields(CSVField[] csvFields) {\n-        if (csvFields == null) {\n-            return;\n-        }\n-        fields = new ArrayList(Arrays.asList(csvFields));\n-    }\n-    \n-    /**\n-     * Set the fields that should be used by the writer\n-     * @param csvField a collection with fields. If null it will do nothing\n-     */\n-    public void setFields(Collection csvField) {\n-        if (csvField == null) {\n-            return;\n-        }\n-        fields = new ArrayList(csvField);\n-    }\n-\n-    /**\n-     * @return an array with the known fields (even if no fields are specified)\n-     */\n-    public CSVField[] getFields() {\n-        CSVField[] csvFields = new CSVField[0];\n-        if (fields != null) {\n-            return (CSVField[]) fields.toArray(csvFields);\n-        }\n-        return csvFields;\n-    }\n-    \n-    public CSVField getField(String name) {\n-        if (fields == null || name == null) {\n-            return null;\n-        }\n-        for(int i = 0; i < fields.size(); i++) {\n-            CSVField field = (CSVField) fields.get(i);\n-            if (name.equals(field.getName())) {\n-                return field;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    /**\n-     * @return the fill pattern.\n-     */\n-    public int getFill() {\n-        return fill;\n-    }\n-\n-    /**\n-     * Set the fill pattern. Defaults to {@link #FILLNONE}\n-     * <br/>Other options are : {@link #FILLLEFT} and {@link #FILLRIGHT}\n-     * @param fill the fill pattern.\n-     */\n-    public void setFill(int fill) {\n-        this.fill = fill;\n-    }\n-\n-    /**\n-     * \n-     * @return the fillchar. Defaults to a space.\n-     */\n-    public char getFillChar() {\n-        return fillChar;\n-    }\n-\n-    /**\n-     * Set the fill char\n-     * @param fillChar the fill char\n-     */\n-    public void setFillChar(char fillChar) {\n-        this.fillChar = fillChar;\n-    }\n-\n-    /**\n-     * @return the delimeter used.\n-     */\n-    public char getDelimiter() {\n-        return delimiter;\n-    }\n-\n-    /**\n-     * Set the delimiter to use\n-     * @param delimiter the delimiter character.\n-     */\n-    public void setDelimiter(char delimiter) {\n-        this.delimiter = delimiter;\n-    }\n-\n-    /**\n-     * @return if the writer should ignore the delimiter character.\n-     */\n-    public boolean isDelimiterIgnored() {\n-        return ignoreDelimiter;\n-    }\n-\n-    /**\n-     * Specify if the writer should ignore the delimiter. \n-     * @param ignoreDelimiter defaults to false.\n-     */\n-    public void setIgnoreDelimiter(boolean ignoreDelimiter) {\n-        this.ignoreDelimiter = ignoreDelimiter;\n-    }\n-\n-    /**\n-     * @return the value delimeter used. Defaults to \"\n-     */\n-    public char getValueDelimiter() {\n-        return valueDelimiter;\n-    }\n-\n-    /**\n-     * Set the value delimiter to use\n-     * @param valueDelimiter the value delimiter character.\n-     */\n-    public void setValueDelimiter(char valueDelimiter) {\n-        this.valueDelimiter = valueDelimiter;\n-    }\n-\n-    /**\n-     * @return if the writer should ignore the value delimiter character.\n-     *         Defaults to true.\n-     */\n-    public boolean isValueDelimiterIgnored() {\n-        return ignoreValueDelimiter;\n-    }\n-\n-    /**\n-     * Specify if the writer should ignore the value delimiter. \n-     * @param ignoreValueDelimiter defaults to false.\n-     */\n-    public void setIgnoreValueDelimiter(boolean ignoreValueDelimiter) {\n-        this.ignoreValueDelimiter = ignoreValueDelimiter;\n-    }\n-\n-    /**\n-     * @return if a field header is used. Defaults to false\n-     */\n-    public boolean isFieldHeader() {\n-        return fieldHeader;\n-    }\n-    /**\n-     * Specify if you want to use a field header.\n-     * @param fieldHeader true or false.\n-     */\n-    public void setFieldHeader(boolean fieldHeader) {\n-        this.fieldHeader = fieldHeader;\n-    }\n-    \n-    /**\n-     * TODO..\n-     * @see java.lang.Object#equals(java.lang.Object)\n-     */\n-    public boolean equals(Object obj) {\n-        if (obj == null && !(obj instanceof CSVConfig)) {\n-            return false;\n-        }\n-        return super.equals(obj);\n-//        CSVConfig config = (CSVConfig) obj;\n-//        getFill() == config.getFill()\n-//        getFields().equals(config.getFields())\n-    }\n-\n-    /**\n-     * Creates a config based on a stream. It tries to guess<br/>\n-     * NOTE : The stream will be closed.\n-     * @param inputStream the inputstream. \n-     * @return the guessed config. \n-     */\n-    public static CSVConfig guessConfig(InputStream inputStream) {\n-        return null;\n-    }\n-\n-    /**\n-     * @return if the end of the line should be trimmed. Default is false.\n-     */\n-    public boolean isEndTrimmed() {\n-        return endTrimmed;\n-    }\n-\n-    /**\n-     * Specify if the end of the line needs to be trimmed. Defaults to false.\n-     * @param endTrimmed\n-     */\n-    public void setEndTrimmed(boolean endTrimmed) {\n-        this.endTrimmed = endTrimmed;\n-    }\n-\n-    \n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.csv.writer;\n+\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+/**\n+ * The CSVConfig is used to configure the CSV writer\n+ *\n+ * @author Martin van den Bemt\n+ * @version $Id: $\n+ */\n+public class CSVConfig {\n+\n+    /** specifies if it is a fixed width csv file **/\n+    private boolean fixedWidth;\n+    /** list of fields **/\n+    private List fields;\n+\n+    /** Do no do any filling **/\n+    public static final int FILLNONE = 0;\n+    /** Fill content the the left. Mainly usable together with fixedWidth **/\n+    public static final int FILLLEFT = 1;\n+    /** Fill content to the right. Mainly usable together with fixedWidth **/\n+    public static final int FILLRIGHT = 2;\n+    \n+    /** The fill pattern */\n+    private int fill;\n+    /** The fill char. Defaults to a space */\n+    private char fillChar = ' ';\n+    /** The seperator character. Defaults to , */\n+    private char delimiter = ',';\n+    /** Should we ignore the delimiter. Defaults to false */\n+    private boolean ignoreDelimiter = false;\n+    /** the value delimiter. Defaults to \" */\n+    private char valueDelimiter = '\"';\n+    /** Should we ignore the value delimiter. Defaults to true */\n+    private boolean ignoreValueDelimiter = true;\n+    /** Specifies if we want to use a field header */\n+    private boolean fieldHeader = false;\n+    /** Specifies if the end of the line needs to be trimmed */\n+    private boolean endTrimmed = false;\n+    /**\n+     * \n+     */\n+    public CSVConfig() {\n+        super();\n+    }\n+    \n+    /**\n+     * @return if the CSV file is fixedWidth\n+     */\n+    public boolean isFixedWidth() {\n+        return fixedWidth;\n+    }\n+    \n+    /**\n+     * Specify if the CSV file is fixed width.\n+     * Defaults to false\n+     * @param fixedWidth the fixedwidth\n+     */\n+    public void setFixedWidth(boolean fixedWidth) {\n+        this.fixedWidth = fixedWidth;\n+    }\n+    \n+    public void addField(CSVField field) {\n+        if (fields == null) {\n+            fields = new ArrayList();\n+        }\n+        fields.add(field);\n+    }\n+    \n+    /**\n+     * Set the fields that should be used by the writer.\n+     * This will overwrite currently added fields completely!\n+     * @param csvFields the csvfields array. If null it will do nothing\n+     */\n+    public void setFields(CSVField[] csvFields) {\n+        if (csvFields == null) {\n+            return;\n+        }\n+        fields = new ArrayList(Arrays.asList(csvFields));\n+    }\n+    \n+    /**\n+     * Set the fields that should be used by the writer\n+     * @param csvField a collection with fields. If null it will do nothing\n+     */\n+    public void setFields(Collection csvField) {\n+        if (csvField == null) {\n+            return;\n+        }\n+        fields = new ArrayList(csvField);\n+    }\n+\n+    /**\n+     * @return an array with the known fields (even if no fields are specified)\n+     */\n+    public CSVField[] getFields() {\n+        CSVField[] csvFields = new CSVField[0];\n+        if (fields != null) {\n+            return (CSVField[]) fields.toArray(csvFields);\n+        }\n+        return csvFields;\n+    }\n+    \n+    public CSVField getField(String name) {\n+        if (fields == null || name == null) {\n+            return null;\n+        }\n+        for(int i = 0; i < fields.size(); i++) {\n+            CSVField field = (CSVField) fields.get(i);\n+            if (name.equals(field.getName())) {\n+                return field;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @return the fill pattern.\n+     */\n+    public int getFill() {\n+        return fill;\n+    }\n+\n+    /**\n+     * Set the fill pattern. Defaults to {@link #FILLNONE}\n+     * <br/>Other options are : {@link #FILLLEFT} and {@link #FILLRIGHT}\n+     * @param fill the fill pattern.\n+     */\n+    public void setFill(int fill) {\n+        this.fill = fill;\n+    }\n+\n+    /**\n+     * \n+     * @return the fillchar. Defaults to a space.\n+     */\n+    public char getFillChar() {\n+        return fillChar;\n+    }\n+\n+    /**\n+     * Set the fill char\n+     * @param fillChar the fill char\n+     */\n+    public void setFillChar(char fillChar) {\n+        this.fillChar = fillChar;\n+    }\n+\n+    /**\n+     * @return the delimeter used.\n+     */\n+    public char getDelimiter() {\n+        return delimiter;\n+    }\n+\n+    /**\n+     * Set the delimiter to use\n+     * @param delimiter the delimiter character.\n+     */\n+    public void setDelimiter(char delimiter) {\n+        this.delimiter = delimiter;\n+    }\n+\n+    /**\n+     * @return if the writer should ignore the delimiter character.\n+     */\n+    public boolean isDelimiterIgnored() {\n+        return ignoreDelimiter;\n+    }\n+\n+    /**\n+     * Specify if the writer should ignore the delimiter. \n+     * @param ignoreDelimiter defaults to false.\n+     */\n+    public void setIgnoreDelimiter(boolean ignoreDelimiter) {\n+        this.ignoreDelimiter = ignoreDelimiter;\n+    }\n+\n+    /**\n+     * @return the value delimeter used. Defaults to \"\n+     */\n+    public char getValueDelimiter() {\n+        return valueDelimiter;\n+    }\n+\n+    /**\n+     * Set the value delimiter to use\n+     * @param valueDelimiter the value delimiter character.\n+     */\n+    public void setValueDelimiter(char valueDelimiter) {\n+        this.valueDelimiter = valueDelimiter;\n+    }\n+\n+    /**\n+     * @return if the writer should ignore the value delimiter character.\n+     *         Defaults to true.\n+     */\n+    public boolean isValueDelimiterIgnored() {\n+        return ignoreValueDelimiter;\n+    }\n+\n+    /**\n+     * Specify if the writer should ignore the value delimiter. \n+     * @param ignoreValueDelimiter defaults to false.\n+     */\n+    public void setIgnoreValueDelimiter(boolean ignoreValueDelimiter) {\n+        this.ignoreValueDelimiter = ignoreValueDelimiter;\n+    }\n+\n+    /**\n+     * @return if a field header is used. Defaults to false\n+     */\n+    public boolean isFieldHeader() {\n+        return fieldHeader;\n+    }\n+    /**\n+     * Specify if you want to use a field header.\n+     * @param fieldHeader true or false.\n+     */\n+    public void setFieldHeader(boolean fieldHeader) {\n+        this.fieldHeader = fieldHeader;\n+    }\n+    \n+    /**\n+     * TODO..\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     */\n+    public boolean equals(Object obj) {\n+        if (obj == null && !(obj instanceof CSVConfig)) {\n+            return false;\n+        }\n+        return super.equals(obj);\n+//        CSVConfig config = (CSVConfig) obj;\n+//        getFill() == config.getFill()\n+//        getFields().equals(config.getFields())\n+    }\n+\n+    /**\n+     * Creates a config based on a stream. It tries to guess<br/>\n+     * NOTE : The stream will be closed.\n+     * @param inputStream the inputstream. \n+     * @return the guessed config. \n+     */\n+    public static CSVConfig guessConfig(InputStream inputStream) {\n+        return null;\n+    }\n+\n+    /**\n+     * @return if the end of the line should be trimmed. Default is false.\n+     */\n+    public boolean isEndTrimmed() {\n+        return endTrimmed;\n+    }\n+\n+    /**\n+     * Specify if the end of the line needs to be trimmed. Defaults to false.\n+     * @param endTrimmed\n+     */\n+    public void setEndTrimmed(boolean endTrimmed) {\n+        this.endTrimmed = endTrimmed;\n+    }\n+\n+    \n+}\n--- a/src/java/org/apache/commons/csv/writer/CSVConfigGuesser.java\n+++ b/src/java/org/apache/commons/csv/writer/CSVConfigGuesser.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.commons.csv.writer;\n-\n-import java.io.BufferedReader;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-\n-/**\n- * Tries to guess a config based on an InputStream.\n- *\n- * @author Martin van den Bemt\n- * @version $Id: $\n- */\n-public class CSVConfigGuesser {\n-\n-    /** The stream to read */\n-    private InputStream in;\n-    /** \n-     * if the file has a field header (need this info, to be able to guess better)\n-     * Defaults to false\n-     */\n-    private boolean hasFieldHeader = false;\n-    /** The found config */\n-    protected CSVConfig config;\n-    \n-    /**\n-     * \n-     */\n-    public CSVConfigGuesser() {\n-        this.config = new CSVConfig();\n-    }\n-    \n-    /**\n-     * @param in the inputstream to guess from\n-     */\n-    public CSVConfigGuesser(InputStream in) {\n-        this();\n-        setInputStream(in);\n-    }\n-    \n-    public void setInputStream(InputStream in) {\n-        this.in = in;\n-    }\n-    \n-    /**\n-     * Allow override.\n-     * @return the inputstream that was set.\n-     */\n-    protected InputStream getInputStream() {\n-        return in;\n-    }\n-    \n-    /**\n-     * Guess the config based on the first 10 (or less when less available) \n-     * records of a CSV file.\n-     * \n-     * @return the guessed config.\n-     */\n-    public CSVConfig guess() {\n-        try {\n-            // tralalal\n-            BufferedReader bIn = new BufferedReader(new InputStreamReader((getInputStream())));\n-            String[] lines = new String[10];\n-            String line = null;\n-            int counter = 0;\n-            while ( (line = bIn.readLine()) != null || counter > 10) {\n-                lines[counter] = line;\n-                counter++;\n-            }\n-            if (counter < 10) {\n-                // remove nulls from the array, so we can skip the null checking.\n-                String[] newLines = new String[counter];\n-                System.arraycopy(lines, 0, newLines, 0, counter);\n-                lines = newLines;\n-            }\n-            analyseLines(lines);\n-        } catch(Exception e) {\n-            e.printStackTrace();\n-        } finally {\n-            if (in != null) {\n-                try {\n-                    in.close();\n-                } catch(Exception e) {\n-                    // ignore exception.\n-                }\n-            }\n-        }\n-        CSVConfig conf = config;\n-        // cleanup the config.\n-        config = null;\n-        return conf;\n-    }\n-    \n-    protected void analyseLines(String[] lines) {\n-        guessFixedWidth(lines);\n-        guessFieldSeperator(lines);\n-    }\n-    \n-    /**\n-     * Guess if this file is fixedwidth.\n-     * Just basing the fact on all lines being of the same length\n-     * @param lines\n-     */\n-    protected void guessFixedWidth(String[] lines) {\n-        int lastLength = 0;\n-        // assume fixedlength.\n-        config.setFixedWidth(true);\n-        for (int i = 0; i < lines.length; i++) {\n-            if (i == 0) {\n-                lastLength = lines[i].length();\n-            } else {\n-                if (lastLength != lines[i].length()) {\n-                    config.setFixedWidth(false);\n-                }\n-            }\n-        }\n-    }\n-        \n-\n-    protected void guessFieldSeperator(String[] lines) {\n-        if (config.isFixedWidth()) {\n-            guessFixedWidthSeperator(lines);\n-            return;\n-        }\n-        for (int i = 0; i < lines.length; i++) {\n-        }\n-    }\n-    \n-    protected void guessFixedWidthSeperator(String[] lines) {\n-        // keep track of the fieldlength\n-        int previousMatch = -1;\n-        for (int i = 0; i < lines[0].length(); i++) {\n-            char last = ' ';\n-            boolean charMatches = true;\n-            for (int j = 0; j < lines.length; j++) {\n-                if (j == 0) {\n-                    last = lines[j].charAt(i);\n-                }\n-                if (last != lines[j].charAt(i)) {\n-                    charMatches = false;\n-                    break;\n-                } \n-            }\n-            if (charMatches) {\n-                if (previousMatch == -1) {\n-                    previousMatch = 0;\n-                }\n-                CSVField field = new CSVField();\n-                field.setName(\"field\"+config.getFields().length+1);\n-                field.setSize((i-previousMatch));\n-                config.addField(field);\n-            }\n-        }\n-    }\n-    /**\n-     * \n-     * @return if the field uses a field header. Defaults to false.\n-     */\n-    public boolean hasFieldHeader() {\n-        return hasFieldHeader;\n-    }\n-\n-    /**\n-     * Specify if the CSV file has a field header\n-     * @param hasFieldHeader true or false\n-     */\n-    public void setHasFieldHeader(boolean hasFieldHeader) {\n-        this.hasFieldHeader = hasFieldHeader;\n-    }\n-    \n- \n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.csv.writer;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+\n+/**\n+ * Tries to guess a config based on an InputStream.\n+ *\n+ * @author Martin van den Bemt\n+ * @version $Id: $\n+ */\n+public class CSVConfigGuesser {\n+\n+    /** The stream to read */\n+    private InputStream in;\n+    /** \n+     * if the file has a field header (need this info, to be able to guess better)\n+     * Defaults to false\n+     */\n+    private boolean hasFieldHeader = false;\n+    /** The found config */\n+    protected CSVConfig config;\n+    \n+    /**\n+     * \n+     */\n+    public CSVConfigGuesser() {\n+        this.config = new CSVConfig();\n+    }\n+    \n+    /**\n+     * @param in the inputstream to guess from\n+     */\n+    public CSVConfigGuesser(InputStream in) {\n+        this();\n+        setInputStream(in);\n+    }\n+    \n+    public void setInputStream(InputStream in) {\n+        this.in = in;\n+    }\n+    \n+    /**\n+     * Allow override.\n+     * @return the inputstream that was set.\n+     */\n+    protected InputStream getInputStream() {\n+        return in;\n+    }\n+    \n+    /**\n+     * Guess the config based on the first 10 (or less when less available) \n+     * records of a CSV file.\n+     * \n+     * @return the guessed config.\n+     */\n+    public CSVConfig guess() {\n+        try {\n+            // tralalal\n+            BufferedReader bIn = new BufferedReader(new InputStreamReader((getInputStream())));\n+            String[] lines = new String[10];\n+            String line = null;\n+            int counter = 0;\n+            while ( (line = bIn.readLine()) != null || counter > 10) {\n+                lines[counter] = line;\n+                counter++;\n+            }\n+            if (counter < 10) {\n+                // remove nulls from the array, so we can skip the null checking.\n+                String[] newLines = new String[counter];\n+                System.arraycopy(lines, 0, newLines, 0, counter);\n+                lines = newLines;\n+            }\n+            analyseLines(lines);\n+        } catch(Exception e) {\n+            e.printStackTrace();\n+        } finally {\n+            if (in != null) {\n+                try {\n+                    in.close();\n+                } catch(Exception e) {\n+                    // ignore exception.\n+                }\n+            }\n+        }\n+        CSVConfig conf = config;\n+        // cleanup the config.\n+        config = null;\n+        return conf;\n+    }\n+    \n+    protected void analyseLines(String[] lines) {\n+        guessFixedWidth(lines);\n+        guessFieldSeperator(lines);\n+    }\n+    \n+    /**\n+     * Guess if this file is fixedwidth.\n+     * Just basing the fact on all lines being of the same length\n+     * @param lines\n+     */\n+    protected void guessFixedWidth(String[] lines) {\n+        int lastLength = 0;\n+        // assume fixedlength.\n+        config.setFixedWidth(true);\n+        for (int i = 0; i < lines.length; i++) {\n+            if (i == 0) {\n+                lastLength = lines[i].length();\n+            } else {\n+                if (lastLength != lines[i].length()) {\n+                    config.setFixedWidth(false);\n+                }\n+            }\n+        }\n+    }\n+        \n+\n+    protected void guessFieldSeperator(String[] lines) {\n+        if (config.isFixedWidth()) {\n+            guessFixedWidthSeperator(lines);\n+            return;\n+        }\n+        for (int i = 0; i < lines.length; i++) {\n+        }\n+    }\n+    \n+    protected void guessFixedWidthSeperator(String[] lines) {\n+        // keep track of the fieldlength\n+        int previousMatch = -1;\n+        for (int i = 0; i < lines[0].length(); i++) {\n+            char last = ' ';\n+            boolean charMatches = true;\n+            for (int j = 0; j < lines.length; j++) {\n+                if (j == 0) {\n+                    last = lines[j].charAt(i);\n+                }\n+                if (last != lines[j].charAt(i)) {\n+                    charMatches = false;\n+                    break;\n+                } \n+            }\n+            if (charMatches) {\n+                if (previousMatch == -1) {\n+                    previousMatch = 0;\n+                }\n+                CSVField field = new CSVField();\n+                field.setName(\"field\"+config.getFields().length+1);\n+                field.setSize((i-previousMatch));\n+                config.addField(field);\n+            }\n+        }\n+    }\n+    /**\n+     * \n+     * @return if the field uses a field header. Defaults to false.\n+     */\n+    public boolean hasFieldHeader() {\n+        return hasFieldHeader;\n+    }\n+\n+    /**\n+     * Specify if the CSV file has a field header\n+     * @param hasFieldHeader true or false\n+     */\n+    public void setHasFieldHeader(boolean hasFieldHeader) {\n+        this.hasFieldHeader = hasFieldHeader;\n+    }\n+    \n+ \n+}\n--- a/src/java/org/apache/commons/csv/writer/CSVField.java\n+++ b/src/java/org/apache/commons/csv/writer/CSVField.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.commons.csv.writer;\n-\n-\n-/**\n- * \n- * @author Martin van den Bemt\n- * @version $Id: $\n- */\n-public class CSVField {\n-\n-    private String name;\n-    private int size;\n-    private int fill;\n-    private boolean overrideFill;\n-\n-    /**\n-     * \n-     */\n-    public CSVField() {\n-    }\n-\n-    /**\n-     * @param name the name of the field\n-     */\n-    public CSVField(String name) {\n-        setName(name);\n-    }\n-\n-    /**\n-     * @param name the name of the field\n-     * @param size the size of the field\n-     */\n-    public CSVField(String name, int size) {\n-        setName(name);\n-        setSize(size);\n-    }\n-\n-    /**\n-     * @return the name of the field\n-     */\n-    public String getName() {\n-        return name;\n-    }\n-    \n-    /**\n-     * Set the name of the field\n-     * @param name the name\n-     */\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    /**\n-     * \n-     * @return the size of the field\n-     */\n-    public int getSize() {\n-        return size;\n-    }\n-\n-    /**\n-     * Set the size of the field.\n-     * The size will be ignored when fixedwidth is set to false in the CSVConfig\n-     * @param size the size of the field.\n-     */\n-    public void setSize(int size) {\n-        this.size = size;\n-    }\n-\n-    /**\n-     * @return the fill pattern.\n-     */\n-    public int getFill() {\n-        return fill;\n-    }\n-\n-    /**\n-     * Sets overrideFill to true.\n-     * @param fill the file pattern\n-     */\n-    public void setFill(int fill) {\n-        overrideFill = true;\n-        this.fill = fill;\n-    }\n-    \n-    /**\n-     * Does this field override fill ?\n-     * \n-     * @return\n-     */\n-    public boolean overrideFill() {\n-        return overrideFill;\n-    }\n-\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.csv.writer;\n+\n+\n+/**\n+ * \n+ * @author Martin van den Bemt\n+ * @version $Id: $\n+ */\n+public class CSVField {\n+\n+    private String name;\n+    private int size;\n+    private int fill;\n+    private boolean overrideFill;\n+\n+    /**\n+     * \n+     */\n+    public CSVField() {\n+    }\n+\n+    /**\n+     * @param name the name of the field\n+     */\n+    public CSVField(String name) {\n+        setName(name);\n+    }\n+\n+    /**\n+     * @param name the name of the field\n+     * @param size the size of the field\n+     */\n+    public CSVField(String name, int size) {\n+        setName(name);\n+        setSize(size);\n+    }\n+\n+    /**\n+     * @return the name of the field\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+    \n+    /**\n+     * Set the name of the field\n+     * @param name the name\n+     */\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+\n+    /**\n+     * \n+     * @return the size of the field\n+     */\n+    public int getSize() {\n+        return size;\n+    }\n+\n+    /**\n+     * Set the size of the field.\n+     * The size will be ignored when fixedwidth is set to false in the CSVConfig\n+     * @param size the size of the field.\n+     */\n+    public void setSize(int size) {\n+        this.size = size;\n+    }\n+\n+    /**\n+     * @return the fill pattern.\n+     */\n+    public int getFill() {\n+        return fill;\n+    }\n+\n+    /**\n+     * Sets overrideFill to true.\n+     * @param fill the file pattern\n+     */\n+    public void setFill(int fill) {\n+        overrideFill = true;\n+        this.fill = fill;\n+    }\n+    \n+    /**\n+     * Does this field override fill ?\n+     * \n+     * @return\n+     */\n+    public boolean overrideFill() {\n+        return overrideFill;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/csv/writer/CSVWriter.java\n+++ b/src/java/org/apache/commons/csv/writer/CSVWriter.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.commons.csv.writer;\n-\n-import java.io.Writer;\n-import java.util.Arrays;\n-import java.util.Map;\n-\n-\n-/**\n- * CSVWriter\n- *\n- * @author Martin van den Bemt\n- * @version $Id: $\n- */\n-public class CSVWriter {\n-\n-    /** The CSV config **/\n-    private CSVConfig config;\n-    /** The writer **/\n-    private Writer writer;\n-    /**\n-     * \n-     */\n-    public CSVWriter() {\n-    }\n-    \n-    public CSVWriter(CSVConfig config) {\n-        setConfig(config);\n-    }\n-\n-    public void writeRecord(Map map) {\n-        CSVField[] fields = config.getFields();\n-        try {\n-            StringBuffer sb = new StringBuffer();\n-            for (int i = 0; i < fields.length; i++) {\n-                String value = (String) map.get(fields[i].getName());\n-                value = writeValue(fields[i], value);\n-                sb.append(value);\n-                if (!config.isDelimiterIgnored() && fields.length != (i+1)) {\n-                    sb.append(config.getDelimiter());\n-                }\n-            }\n-            if (config.isEndTrimmed()) {\n-                for (int i = sb.length()-1; i >= 0; i--) {\n-                    System.out.println(\"i : \" + i);\n-                    if (Character.isWhitespace(sb.charAt(i))) {\n-                        sb.deleteCharAt(i);\n-                    } else {\n-                        break;\n-                    }\n-                }\n-            }\n-            sb.append(\"\\n\");\n-            String line = sb.toString();\n-            writer.write(line);\n-        } catch(Exception e) {\n-            e.printStackTrace();\n-        }\n-    }\n-    \n-    protected String writeValue(CSVField field, String value) throws Exception {\n-        if (config.isFixedWidth()) {\n-            if (value.length() < field.getSize()) {\n-                int fillPattern = config.getFill();\n-                if (field.overrideFill()) {\n-                    fillPattern = field.getFill();\n-                }\n-                StringBuffer sb = new StringBuffer();\n-                int fillSize = (field.getSize() - value.length());\n-                char[] fill = new char[fillSize];\n-                Arrays.fill(fill, config.getFillChar());\n-                if (fillPattern == CSVConfig.FILLLEFT) {\n-                    sb.append(fill);\n-                    sb.append(value);\n-                    value = sb.toString();\n-                } else {\n-                    // defaults to fillpattern FILLRIGHT when fixedwidth is used\n-                    sb.append(value);\n-                    sb.append(fill);\n-                    value = sb.toString();\n-                }\n-            } else if (value.length() > field.getSize()) {\n-                // value to big..\n-                value = value.substring(0, field.getSize());\n-            }\n-            if (!config.isValueDelimiterIgnored()) {\n-                // add the value delimiter..\n-                value = config.getValueDelimiter()+value+config.getValueDelimiter();\n-            }\n-        }\n-        return value;\n-    }\n-    /**\n-     * @return the CVSConfig or null if not present\n-     */\n-    public CSVConfig getConfig() {\n-        return config;\n-    }\n-\n-    /**\n-     * Set the CSVConfig\n-     * @param config the CVSConfig\n-     */\n-    public void setConfig(CSVConfig config) {\n-        this.config = config;\n-    }\n-    \n-    /**\n-     * Set the writer to write the CSV file to.\n-     * @param writer the writer.\n-     */\n-    public void setWriter(Writer writer) {\n-        this.writer = writer;\n-    }\n-\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.csv.writer;\n+\n+import java.io.Writer;\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+\n+/**\n+ * CSVWriter\n+ *\n+ * @author Martin van den Bemt\n+ * @version $Id: $\n+ */\n+public class CSVWriter {\n+\n+    /** The CSV config **/\n+    private CSVConfig config;\n+    /** The writer **/\n+    private Writer writer;\n+    /**\n+     * \n+     */\n+    public CSVWriter() {\n+    }\n+    \n+    public CSVWriter(CSVConfig config) {\n+        setConfig(config);\n+    }\n+\n+    public void writeRecord(Map map) {\n+        CSVField[] fields = config.getFields();\n+        try {\n+            StringBuffer sb = new StringBuffer();\n+            for (int i = 0; i < fields.length; i++) {\n+                String value = (String) map.get(fields[i].getName());\n+                value = writeValue(fields[i], value);\n+                sb.append(value);\n+                if (!config.isDelimiterIgnored() && fields.length != (i+1)) {\n+                    sb.append(config.getDelimiter());\n+                }\n+            }\n+            if (config.isEndTrimmed()) {\n+                for (int i = sb.length()-1; i >= 0; i--) {\n+                    System.out.println(\"i : \" + i);\n+                    if (Character.isWhitespace(sb.charAt(i))) {\n+                        sb.deleteCharAt(i);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            }\n+            sb.append(\"\\n\");\n+            String line = sb.toString();\n+            writer.write(line);\n+        } catch(Exception e) {\n+            e.printStackTrace();\n+        }\n+    }\n+    \n+    protected String writeValue(CSVField field, String value) throws Exception {\n+        if (config.isFixedWidth()) {\n+            if (value.length() < field.getSize()) {\n+                int fillPattern = config.getFill();\n+                if (field.overrideFill()) {\n+                    fillPattern = field.getFill();\n+                }\n+                StringBuffer sb = new StringBuffer();\n+                int fillSize = (field.getSize() - value.length());\n+                char[] fill = new char[fillSize];\n+                Arrays.fill(fill, config.getFillChar());\n+                if (fillPattern == CSVConfig.FILLLEFT) {\n+                    sb.append(fill);\n+                    sb.append(value);\n+                    value = sb.toString();\n+                } else {\n+                    // defaults to fillpattern FILLRIGHT when fixedwidth is used\n+                    sb.append(value);\n+                    sb.append(fill);\n+                    value = sb.toString();\n+                }\n+            } else if (value.length() > field.getSize()) {\n+                // value to big..\n+                value = value.substring(0, field.getSize());\n+            }\n+            if (!config.isValueDelimiterIgnored()) {\n+                // add the value delimiter..\n+                value = config.getValueDelimiter()+value+config.getValueDelimiter();\n+            }\n+        }\n+        return value;\n+    }\n+    /**\n+     * @return the CVSConfig or null if not present\n+     */\n+    public CSVConfig getConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Set the CSVConfig\n+     * @param config the CVSConfig\n+     */\n+    public void setConfig(CSVConfig config) {\n+        this.config = config;\n+    }\n+    \n+    /**\n+     * Set the writer to write the CSV file to.\n+     * @param writer the writer.\n+     */\n+    public void setWriter(Writer writer) {\n+        this.writer = writer;\n+    }\n+\n+}\n--- a/src/test/AllTests.java\n+++ b/src/test/AllTests.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-import junit.framework.Test;\n-import junit.framework.TestSuite;\n-\n-public class AllTests {\n-\n-    public static Test suite() {\n-        TestSuite suite = new TestSuite(\"Test for default package\");\n-        //$JUnit-BEGIN$\n-        suite.addTest(org.apache.commons.csv.AllTests.suite());\n-        suite.addTest(org.apache.commons.csv.writer.AllTests.suite());\n-        //$JUnit-END$\n-        return suite;\n-    }\n-\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(\"Test for default package\");\n+        //$JUnit-BEGIN$\n+        suite.addTest(org.apache.commons.csv.AllTests.suite());\n+        suite.addTest(org.apache.commons.csv.writer.AllTests.suite());\n+        //$JUnit-END$\n+        return suite;\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/csv/AllTests.java\n+++ b/src/test/org/apache/commons/csv/AllTests.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.commons.csv;\n-\n-import junit.framework.Test;\n-import junit.framework.TestSuite;\n-\n-public class AllTests {\n-\n-    public static Test suite() {\n-        TestSuite suite = new TestSuite(\"Test for org.apache.commons.csv\");\n-        //$JUnit-BEGIN$\n-        suite.addTest(ExtendedBufferedReaderTest.suite());\n-        suite.addTest(CSVPrinterTest.suite());\n-        suite.addTest(CSVParserTest.suite());\n-        suite.addTest(CSVStrategyTest.suite());\n-        suite.addTestSuite(CSVUtilsTest.class);\n-        //$JUnit-END$\n-        return suite;\n-    }\n-\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.csv;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(\"Test for org.apache.commons.csv\");\n+        //$JUnit-BEGIN$\n+        suite.addTest(ExtendedBufferedReaderTest.suite());\n+        suite.addTest(CSVPrinterTest.suite());\n+        suite.addTest(CSVParserTest.suite());\n+        suite.addTest(CSVStrategyTest.suite());\n+        suite.addTestSuite(CSVUtilsTest.class);\n+        //$JUnit-END$\n+        return suite;\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/csv/CharBufferTest.java\n+++ b/src/test/org/apache/commons/csv/CharBufferTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.commons.csv;\n-\n-import junit.framework.TestCase;\n-\n-/**\n- * \n- * @author Ortwin Glck\n- */\n-public class CharBufferTest extends TestCase {\n-    public void testCreate() {\n-        CharBuffer cb = new CharBuffer();\n-        assertEquals(0, cb.length());\n-        try {\n-            cb = new CharBuffer(0);\n-            fail(\"Should not be possible\");\n-        } catch(IllegalArgumentException e) {\n-            // expected\n-        }\n-        \n-        cb = new CharBuffer(128);\n-        assertEquals(0, cb.length());\n-    }\n-    \n-    public void testAppendChar() {\n-        CharBuffer cb = new CharBuffer(1);\n-        String expected = \"\";\n-        for (char c = 'a'; c < 'z'; c++) {\n-            cb.append(c);\n-            expected += c;\n-            assertEquals(expected, cb.toString());\n-            assertEquals(expected.length(), cb.length());\n-        }\n-    }\n-    \n-    public void testAppendCharArray() {\n-        CharBuffer cb = new CharBuffer(1);\n-        char[] abcd = \"abcd\".toCharArray();\n-        String expected = \"\";\n-        for (int i=0; i<10; i++) {\n-            cb.append(abcd);\n-            expected += \"abcd\";\n-            assertEquals(expected, cb.toString());\n-            assertEquals(4*(i+1), cb.length());\n-        }\n-    }\n-    \n-    public void testAppendString() {\n-        CharBuffer cb = new CharBuffer(1);\n-        String abcd = \"abcd\";\n-        String expected = \"\";\n-        for (int i=0; i<10; i++) {\n-            cb.append(abcd);\n-            expected += abcd;\n-            assertEquals(expected, cb.toString());\n-            assertEquals(4*(i+1), cb.length());\n-        }\n-    }\n-    \n-    public void testAppendStringBuffer() {\n-        CharBuffer cb = new CharBuffer(1);\n-        StringBuffer abcd = new StringBuffer(\"abcd\");\n-        String expected = \"\";\n-        for (int i=0; i<10; i++) {\n-            cb.append(abcd);\n-            expected += \"abcd\";\n-            assertEquals(expected, cb.toString());\n-            assertEquals(4*(i+1), cb.length());\n-        }\n-    }\n-    \n-    public void testAppendCharBuffer() {\n-        CharBuffer cb = new CharBuffer(1);\n-        CharBuffer abcd = new CharBuffer(17);\n-        abcd.append(\"abcd\");\n-        String expected = \"\";\n-        for (int i=0; i<10; i++) {\n-            cb.append(abcd);\n-            expected += \"abcd\";\n-            assertEquals(expected, cb.toString());\n-            assertEquals(4*(i+1), cb.length());\n-        }\n-    }\n-    \n-    public void testShrink() {\n-        String data = \"123456789012345678901234567890\";\n-        \n-        CharBuffer cb = new CharBuffer(data.length() + 100);\n-        assertEquals(data.length() + 100, cb.capacity());\n-        cb.append(data);\n-        assertEquals(data.length() + 100, cb.capacity());\n-        assertEquals(data.length(), cb.length());\n-        cb.shrink();\n-        assertEquals(data.length(), cb.capacity());\n-        assertEquals(data.length(), cb.length());\n-        assertEquals(data, cb.toString());\n-    }\n-    \n-    //-- the following test cases have been adapted from the HttpComponents project\n-    //-- written by Oleg Kalnichevski\n-    \n-    public void testSimpleAppend() throws Exception {\n-        CharBuffer buffer = new CharBuffer(16);\n-        assertEquals(16, buffer.capacity()); \n-        assertEquals(0, buffer.length());\n-        char[] b1 = buffer.getCharacters();\n-        assertNotNull(b1);\n-        assertEquals(0, b1.length);\n-        assertEquals(0, buffer.length());\n-        \n-        char[] tmp = new char[] { '1', '2', '3', '4'};\n-        buffer.append(tmp);\n-        assertEquals(16, buffer.capacity()); \n-        assertEquals(4, buffer.length());\n-        \n-        char[] b2 = buffer.getCharacters();\n-        assertNotNull(b2);\n-        assertEquals(4, b2.length);\n-        for (int i = 0; i < tmp.length; i++) {\n-            assertEquals(tmp[i], b2[i]);\n-        }\n-        assertEquals(\"1234\", buffer.toString());\n-        \n-        buffer.clear();\n-        assertEquals(16, buffer.capacity()); \n-        assertEquals(0, buffer.length());\n-    }\n-    \n-    public void testAppendString2() throws Exception {\n-        CharBuffer buffer = new CharBuffer(8);\n-        buffer.append(\"stuff\");\n-        buffer.append(\" and more stuff\");\n-        assertEquals(\"stuff and more stuff\", buffer.toString());\n-    }\n-    \n-    public void testAppendNull() throws Exception {\n-        CharBuffer buffer = new CharBuffer(8);\n-        \n-        buffer.append((StringBuffer)null);\n-        assertEquals(\"\", buffer.toString());\n-        \n-        buffer.append((String)null);\n-        assertEquals(\"\", buffer.toString());\n-\n-        buffer.append((CharBuffer)null);\n-        assertEquals(\"\", buffer.toString());\n-\n-        buffer.append((char[])null);\n-        assertEquals(\"\", buffer.toString());\n-    }\n-    \n-    public void testAppendCharArrayBuffer() throws Exception {\n-        CharBuffer buffer1 = new CharBuffer(8);\n-        buffer1.append(\" and more stuff\");\n-        CharBuffer buffer2 = new CharBuffer(8);\n-        buffer2.append(\"stuff\");\n-        buffer2.append(buffer1);\n-        assertEquals(\"stuff and more stuff\", buffer2.toString());\n-    }\n-    \n-    public void testAppendSingleChar() throws Exception {\n-        CharBuffer buffer = new CharBuffer(4);\n-        buffer.append('1');\n-        buffer.append('2');\n-        buffer.append('3');\n-        buffer.append('4');\n-        buffer.append('5');\n-        buffer.append('6');\n-        assertEquals(\"123456\", buffer.toString());\n-    }\n-    \n-    public void testProvideCapacity() throws Exception {\n-        CharBuffer buffer = new CharBuffer(4);\n-        buffer.provideCapacity(2);\n-        assertEquals(4, buffer.capacity());\n-        buffer.provideCapacity(8);\n-        assertTrue(buffer.capacity() >= 8);\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.csv;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * \n+ * @author Ortwin Glck\n+ */\n+public class CharBufferTest extends TestCase {\n+    public void testCreate() {\n+        CharBuffer cb = new CharBuffer();\n+        assertEquals(0, cb.length());\n+        try {\n+            cb = new CharBuffer(0);\n+            fail(\"Should not be possible\");\n+        } catch(IllegalArgumentException e) {\n+            // expected\n+        }\n+        \n+        cb = new CharBuffer(128);\n+        assertEquals(0, cb.length());\n+    }\n+    \n+    public void testAppendChar() {\n+        CharBuffer cb = new CharBuffer(1);\n+        String expected = \"\";\n+        for (char c = 'a'; c < 'z'; c++) {\n+            cb.append(c);\n+            expected += c;\n+            assertEquals(expected, cb.toString());\n+            assertEquals(expected.length(), cb.length());\n+        }\n+    }\n+    \n+    public void testAppendCharArray() {\n+        CharBuffer cb = new CharBuffer(1);\n+        char[] abcd = \"abcd\".toCharArray();\n+        String expected = \"\";\n+        for (int i=0; i<10; i++) {\n+            cb.append(abcd);\n+            expected += \"abcd\";\n+            assertEquals(expected, cb.toString());\n+            assertEquals(4*(i+1), cb.length());\n+        }\n+    }\n+    \n+    public void testAppendString() {\n+        CharBuffer cb = new CharBuffer(1);\n+        String abcd = \"abcd\";\n+        String expected = \"\";\n+        for (int i=0; i<10; i++) {\n+            cb.append(abcd);\n+            expected += abcd;\n+            assertEquals(expected, cb.toString());\n+            assertEquals(4*(i+1), cb.length());\n+        }\n+    }\n+    \n+    public void testAppendStringBuffer() {\n+        CharBuffer cb = new CharBuffer(1);\n+        StringBuffer abcd = new StringBuffer(\"abcd\");\n+        String expected = \"\";\n+        for (int i=0; i<10; i++) {\n+            cb.append(abcd);\n+            expected += \"abcd\";\n+            assertEquals(expected, cb.toString());\n+            assertEquals(4*(i+1), cb.length());\n+        }\n+    }\n+    \n+    public void testAppendCharBuffer() {\n+        CharBuffer cb = new CharBuffer(1);\n+        CharBuffer abcd = new CharBuffer(17);\n+        abcd.append(\"abcd\");\n+        String expected = \"\";\n+        for (int i=0; i<10; i++) {\n+            cb.append(abcd);\n+            expected += \"abcd\";\n+            assertEquals(expected, cb.toString());\n+            assertEquals(4*(i+1), cb.length());\n+        }\n+    }\n+    \n+    public void testShrink() {\n+        String data = \"123456789012345678901234567890\";\n+        \n+        CharBuffer cb = new CharBuffer(data.length() + 100);\n+        assertEquals(data.length() + 100, cb.capacity());\n+        cb.append(data);\n+        assertEquals(data.length() + 100, cb.capacity());\n+        assertEquals(data.length(), cb.length());\n+        cb.shrink();\n+        assertEquals(data.length(), cb.capacity());\n+        assertEquals(data.length(), cb.length());\n+        assertEquals(data, cb.toString());\n+    }\n+    \n+    //-- the following test cases have been adapted from the HttpComponents project\n+    //-- written by Oleg Kalnichevski\n+    \n+    public void testSimpleAppend() throws Exception {\n+        CharBuffer buffer = new CharBuffer(16);\n+        assertEquals(16, buffer.capacity()); \n+        assertEquals(0, buffer.length());\n+        char[] b1 = buffer.getCharacters();\n+        assertNotNull(b1);\n+        assertEquals(0, b1.length);\n+        assertEquals(0, buffer.length());\n+        \n+        char[] tmp = new char[] { '1', '2', '3', '4'};\n+        buffer.append(tmp);\n+        assertEquals(16, buffer.capacity()); \n+        assertEquals(4, buffer.length());\n+        \n+        char[] b2 = buffer.getCharacters();\n+        assertNotNull(b2);\n+        assertEquals(4, b2.length);\n+        for (int i = 0; i < tmp.length; i++) {\n+            assertEquals(tmp[i], b2[i]);\n+        }\n+        assertEquals(\"1234\", buffer.toString());\n+        \n+        buffer.clear();\n+        assertEquals(16, buffer.capacity()); \n+        assertEquals(0, buffer.length());\n+    }\n+    \n+    public void testAppendString2() throws Exception {\n+        CharBuffer buffer = new CharBuffer(8);\n+        buffer.append(\"stuff\");\n+        buffer.append(\" and more stuff\");\n+        assertEquals(\"stuff and more stuff\", buffer.toString());\n+    }\n+    \n+    public void testAppendNull() throws Exception {\n+        CharBuffer buffer = new CharBuffer(8);\n+        \n+        buffer.append((StringBuffer)null);\n+        assertEquals(\"\", buffer.toString());\n+        \n+        buffer.append((String)null);\n+        assertEquals(\"\", buffer.toString());\n+\n+        buffer.append((CharBuffer)null);\n+        assertEquals(\"\", buffer.toString());\n+\n+        buffer.append((char[])null);\n+        assertEquals(\"\", buffer.toString());\n+    }\n+    \n+    public void testAppendCharArrayBuffer() throws Exception {\n+        CharBuffer buffer1 = new CharBuffer(8);\n+        buffer1.append(\" and more stuff\");\n+        CharBuffer buffer2 = new CharBuffer(8);\n+        buffer2.append(\"stuff\");\n+        buffer2.append(buffer1);\n+        assertEquals(\"stuff and more stuff\", buffer2.toString());\n+    }\n+    \n+    public void testAppendSingleChar() throws Exception {\n+        CharBuffer buffer = new CharBuffer(4);\n+        buffer.append('1');\n+        buffer.append('2');\n+        buffer.append('3');\n+        buffer.append('4');\n+        buffer.append('5');\n+        buffer.append('6');\n+        assertEquals(\"123456\", buffer.toString());\n+    }\n+    \n+    public void testProvideCapacity() throws Exception {\n+        CharBuffer buffer = new CharBuffer(4);\n+        buffer.provideCapacity(2);\n+        assertEquals(4, buffer.capacity());\n+        buffer.provideCapacity(8);\n+        assertTrue(buffer.capacity() >= 8);\n+    }\n+}\n--- a/src/test/org/apache/commons/csv/writer/AllTests.java\n+++ b/src/test/org/apache/commons/csv/writer/AllTests.java\n-package org.apache.commons.csv.writer;\n-\n-import junit.framework.Test;\n-import junit.framework.TestSuite;\n-\n-public class AllTests {\n-\n-    public static Test suite() {\n-        TestSuite suite = new TestSuite(\"Test for org.apache.commons.csv.writer\");\n-        //$JUnit-BEGIN$\n-        suite.addTestSuite(CSVConfigGuesserTest.class);\n-        suite.addTestSuite(CSVConfigTest.class);\n-        suite.addTestSuite(CSVFieldTest.class);\n-        suite.addTestSuite(CSVWriterTest.class);\n-        //$JUnit-END$\n-        return suite;\n-    }\n-\n-}\n+package org.apache.commons.csv.writer;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+public class AllTests {\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(\"Test for org.apache.commons.csv.writer\");\n+        //$JUnit-BEGIN$\n+        suite.addTestSuite(CSVConfigGuesserTest.class);\n+        suite.addTestSuite(CSVConfigTest.class);\n+        suite.addTestSuite(CSVFieldTest.class);\n+        suite.addTestSuite(CSVWriterTest.class);\n+        //$JUnit-END$\n+        return suite;\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/csv/writer/CSVConfigGuesserTest.java\n+++ b/src/test/org/apache/commons/csv/writer/CSVConfigGuesserTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.  \n- */\n-package org.apache.commons.csv.writer;\n-\n-import java.io.ByteArrayInputStream;\n-\n-import junit.framework.TestCase;\n-\n-/**\n- * Tests for the config guesser.\n- *\n- * @author Martin van den Bemt\n- * @version $Id: $\n- */\n-public class CSVConfigGuesserTest extends TestCase {\n-\n-    public void testSetters() throws Exception {\n-        CSVConfigGuesser guesser = new CSVConfigGuesser();\n-        ByteArrayInputStream in = new ByteArrayInputStream(new byte[0]);\n-        guesser.setInputStream(in);\n-        assertEquals(in, guesser.getInputStream());\n-        guesser = new CSVConfigGuesser(in);\n-        assertEquals(in, guesser.getInputStream());\n-        assertEquals(false, guesser.hasFieldHeader());\n-        guesser.setHasFieldHeader(true);\n-        assertEquals(true, guesser.hasFieldHeader());\n-    }\n-    /**\n-     * Test a format like\n-     *  1234 ; abcd ; 1234 ;\n-     *\n-     */\n-    public void testConfigGuess1() {\n-        CSVConfig expected = new CSVConfig();\n-        expected.setDelimiter(';');\n-        expected.setValueDelimiter(' ');\n-        expected.setFill(CSVConfig.FILLRIGHT);\n-        expected.setIgnoreValueDelimiter(false);\n-        expected.setFixedWidth(true);\n-        CSVField field = new CSVField();\n-        field.setSize(4);\n-        expected.addField(field);\n-        expected.addField(field);\n-        StringBuffer sb = new StringBuffer();\n-        sb.append(\"1234;abcd;1234\\n\");\n-        sb.append(\"abcd;1234;abcd\");\n-        ByteArrayInputStream in = new ByteArrayInputStream(sb.toString().getBytes());\n-        CSVConfigGuesser guesser = new CSVConfigGuesser(in);\n-        CSVConfig guessed = guesser.guess();\n-        assertEquals(expected.isFixedWidth(), guessed.isFixedWidth());\n-        assertEquals(expected.getFields().length, guessed.getFields().length);\n-        assertEquals(expected.getFields()[0].getSize(), guessed.getFields()[0].getSize());\n-    }\n-    /**\n-     * Test a format like\n-     *  1234,123123,12312312,213123\n-     *  1,2,3,4\n-     *\n-     */\n-    public void testConfigGuess2() {\n-        CSVConfig expected = new CSVConfig();\n-        expected.setDelimiter(';');\n-        expected.setValueDelimiter(' ');\n-        expected.setFill(CSVConfig.FILLRIGHT);\n-        expected.setIgnoreValueDelimiter(false);\n-//        expected.setFixedWidth(false);\n-        StringBuffer sb = new StringBuffer();\n-        sb.append(\"1,2,3,4\\n\");\n-        sb.append(\"abcd,1234,abcd,1234\");\n-        ByteArrayInputStream in = new ByteArrayInputStream(sb.toString().getBytes());\n-        CSVConfigGuesser guesser = new CSVConfigGuesser(in);\n-        CSVConfig guessed = guesser.guess();\n-        assertEquals(expected.isFixedWidth(), guessed.isFixedWidth());\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.  \n+ */\n+package org.apache.commons.csv.writer;\n+\n+import java.io.ByteArrayInputStream;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests for the config guesser.\n+ *\n+ * @author Martin van den Bemt\n+ * @version $Id: $\n+ */\n+public class CSVConfigGuesserTest extends TestCase {\n+\n+    public void testSetters() throws Exception {\n+        CSVConfigGuesser guesser = new CSVConfigGuesser();\n+        ByteArrayInputStream in = new ByteArrayInputStream(new byte[0]);\n+        guesser.setInputStream(in);\n+        assertEquals(in, guesser.getInputStream());\n+        guesser = new CSVConfigGuesser(in);\n+        assertEquals(in, guesser.getInputStream());\n+        assertEquals(false, guesser.hasFieldHeader());\n+        guesser.setHasFieldHeader(true);\n+        assertEquals(true, guesser.hasFieldHeader());\n+    }\n+    /**\n+     * Test a format like\n+     *  1234 ; abcd ; 1234 ;\n+     *\n+     */\n+    public void testConfigGuess1() {\n+        CSVConfig expected = new CSVConfig();\n+        expected.setDelimiter(';');\n+        expected.setValueDelimiter(' ');\n+        expected.setFill(CSVConfig.FILLRIGHT);\n+        expected.setIgnoreValueDelimiter(false);\n+        expected.setFixedWidth(true);\n+        CSVField field = new CSVField();\n+        field.setSize(4);\n+        expected.addField(field);\n+        expected.addField(field);\n+        StringBuffer sb = new StringBuffer();\n+        sb.append(\"1234;abcd;1234\\n\");\n+        sb.append(\"abcd;1234;abcd\");\n+        ByteArrayInputStream in = new ByteArrayInputStream(sb.toString().getBytes());\n+        CSVConfigGuesser guesser = new CSVConfigGuesser(in);\n+        CSVConfig guessed = guesser.guess();\n+        assertEquals(expected.isFixedWidth(), guessed.isFixedWidth());\n+        assertEquals(expected.getFields().length, guessed.getFields().length);\n+        assertEquals(expected.getFields()[0].getSize(), guessed.getFields()[0].getSize());\n+    }\n+    /**\n+     * Test a format like\n+     *  1234,123123,12312312,213123\n+     *  1,2,3,4\n+     *\n+     */\n+    public void testConfigGuess2() {\n+        CSVConfig expected = new CSVConfig();\n+        expected.setDelimiter(';');\n+        expected.setValueDelimiter(' ');\n+        expected.setFill(CSVConfig.FILLRIGHT);\n+        expected.setIgnoreValueDelimiter(false);\n+//        expected.setFixedWidth(false);\n+        StringBuffer sb = new StringBuffer();\n+        sb.append(\"1,2,3,4\\n\");\n+        sb.append(\"abcd,1234,abcd,1234\");\n+        ByteArrayInputStream in = new ByteArrayInputStream(sb.toString().getBytes());\n+        CSVConfigGuesser guesser = new CSVConfigGuesser(in);\n+        CSVConfig guessed = guesser.guess();\n+        assertEquals(expected.isFixedWidth(), guessed.isFixedWidth());\n+    }\n+}\n--- a/src/test/org/apache/commons/csv/writer/CSVConfigTest.java\n+++ b/src/test/org/apache/commons/csv/writer/CSVConfigTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.commons.csv.writer;\n-\n-import java.util.Collection;\n-\n-import junit.framework.TestCase;\n-\n-/**\n- * Testcase for the CSVConfig\n- *\n- * @author Martin van den Bemt\n- * @version $Id: $\n- */\n-public class CSVConfigTest extends TestCase {\n-    \n-\n-    public void testFixedWith() {\n-        CSVConfig config = new CSVConfig();\n-        assertEquals(false, config.isFixedWidth());\n-        config.setFixedWidth(true);\n-        assertEquals(true, config.isFixedWidth());\n-    }\n-    \n-    public void testFields() {\n-        CSVConfig config = new CSVConfig();\n-        assertEquals(0, config.getFields().length);\n-        config.setFields((CSVField[])null);\n-        assertEquals(0, config.getFields().length);\n-        config.setFields((Collection)null);\n-        assertEquals(0, config.getFields().length);\n-        CSVField field = new CSVField();\n-        field.setName(\"field1\");\n-        config.addField(field);\n-        assertEquals(field, config.getFields()[0]);\n-        assertEquals(null, config.getField(null));\n-        assertEquals(null, config.getField(\"field11\"));\n-        assertEquals(field, config.getField(\"field1\"));\n-    }\n-    \n-    public void testFill() {\n-        CSVConfig config = new CSVConfig();\n-        assertEquals(CSVConfig.FILLNONE, config.getFill());\n-        config.setFill(CSVConfig.FILLLEFT);\n-        assertEquals(CSVConfig.FILLLEFT, config.getFill());\n-        config.setFill(CSVConfig.FILLRIGHT);\n-        assertEquals(CSVConfig.FILLRIGHT, config.getFill());\n-        assertEquals(' ', config.getFillChar());\n-        config.setFillChar('m');\n-        assertEquals('m', config.getFillChar());\n-    }\n-    \n-    public void testDelimiter() {\n-        CSVConfig config = new CSVConfig();\n-        assertEquals(',', config.getDelimiter());\n-        config.setDelimiter(';');\n-        assertEquals(';', config.getDelimiter());\n-        assertEquals(false, config.isDelimiterIgnored());\n-        config.setIgnoreDelimiter(true);\n-        assertEquals(true, config.isDelimiterIgnored());\n-    }\n-    \n-    public void testValueDelimiter() {\n-        CSVConfig config = new CSVConfig();\n-        assertEquals('\"', config.getValueDelimiter());\n-        config.setValueDelimiter('m');\n-        assertEquals('m', config.getValueDelimiter());\n-        assertEquals(true, config.isValueDelimiterIgnored());\n-        config.setIgnoreValueDelimiter(false);\n-        assertEquals(false, config.isValueDelimiterIgnored());\n-    }\n-    \n-    public void testFieldHeader() {\n-        CSVConfig config = new CSVConfig();\n-        assertEquals(false, config.isFieldHeader());\n-        config.setFieldHeader(true);\n-        assertEquals(true, config.isFieldHeader());\n-    }\n-    \n-    public void testTrimEnd() {\n-        CSVConfig config = new CSVConfig();\n-        assertEquals(false, config.isEndTrimmed());\n-        config.setEndTrimmed(true);\n-        assertEquals(true, config.isEndTrimmed());\n-    }\n-\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.csv.writer;\n+\n+import java.util.Collection;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for the CSVConfig\n+ *\n+ * @author Martin van den Bemt\n+ * @version $Id: $\n+ */\n+public class CSVConfigTest extends TestCase {\n+    \n+\n+    public void testFixedWith() {\n+        CSVConfig config = new CSVConfig();\n+        assertEquals(false, config.isFixedWidth());\n+        config.setFixedWidth(true);\n+        assertEquals(true, config.isFixedWidth());\n+    }\n+    \n+    public void testFields() {\n+        CSVConfig config = new CSVConfig();\n+        assertEquals(0, config.getFields().length);\n+        config.setFields((CSVField[])null);\n+        assertEquals(0, config.getFields().length);\n+        config.setFields((Collection)null);\n+        assertEquals(0, config.getFields().length);\n+        CSVField field = new CSVField();\n+        field.setName(\"field1\");\n+        config.addField(field);\n+        assertEquals(field, config.getFields()[0]);\n+        assertEquals(null, config.getField(null));\n+        assertEquals(null, config.getField(\"field11\"));\n+        assertEquals(field, config.getField(\"field1\"));\n+    }\n+    \n+    public void testFill() {\n+        CSVConfig config = new CSVConfig();\n+        assertEquals(CSVConfig.FILLNONE, config.getFill());\n+        config.setFill(CSVConfig.FILLLEFT);\n+        assertEquals(CSVConfig.FILLLEFT, config.getFill());\n+        config.setFill(CSVConfig.FILLRIGHT);\n+        assertEquals(CSVConfig.FILLRIGHT, config.getFill());\n+        assertEquals(' ', config.getFillChar());\n+        config.setFillChar('m');\n+        assertEquals('m', config.getFillChar());\n+    }\n+    \n+    public void testDelimiter() {\n+        CSVConfig config = new CSVConfig();\n+        assertEquals(',', config.getDelimiter());\n+        config.setDelimiter(';');\n+        assertEquals(';', config.getDelimiter());\n+        assertEquals(false, config.isDelimiterIgnored());\n+        config.setIgnoreDelimiter(true);\n+        assertEquals(true, config.isDelimiterIgnored());\n+    }\n+    \n+    public void testValueDelimiter() {\n+        CSVConfig config = new CSVConfig();\n+        assertEquals('\"', config.getValueDelimiter());\n+        config.setValueDelimiter('m');\n+        assertEquals('m', config.getValueDelimiter());\n+        assertEquals(true, config.isValueDelimiterIgnored());\n+        config.setIgnoreValueDelimiter(false);\n+        assertEquals(false, config.isValueDelimiterIgnored());\n+    }\n+    \n+    public void testFieldHeader() {\n+        CSVConfig config = new CSVConfig();\n+        assertEquals(false, config.isFieldHeader());\n+        config.setFieldHeader(true);\n+        assertEquals(true, config.isFieldHeader());\n+    }\n+    \n+    public void testTrimEnd() {\n+        CSVConfig config = new CSVConfig();\n+        assertEquals(false, config.isEndTrimmed());\n+        config.setEndTrimmed(true);\n+        assertEquals(true, config.isEndTrimmed());\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/csv/writer/CSVFieldTest.java\n+++ b/src/test/org/apache/commons/csv/writer/CSVFieldTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.commons.csv.writer;\n-\n-import junit.framework.TestCase;\n-\n-/**\n- * \n- * @author Martin van den Bemt\n- * @version $Id: $\n- */\n-public class CSVFieldTest extends TestCase {\n-\n-    public void testCSVField() {\n-        CSVField field = new CSVField();\n-        assertEquals(null, field.getName());\n-        field.setName(\"id\");\n-        assertEquals(\"id\", field.getName());\n-        assertEquals(0, field.getSize());\n-        field.setSize(10);\n-        assertEquals(10, field.getSize());\n-        field = new CSVField(\"name\");\n-        assertEquals(\"name\", field.getName());\n-        field = new CSVField(\"name\", 10);\n-        assertEquals(\"name\", field.getName());\n-        assertEquals(10, field.getSize());\n-    }\n-    \n-    public void testFill() {\n-        CSVField field = new CSVField();\n-        assertEquals(CSVConfig.FILLNONE, field.getFill());\n-        assertEquals(false, field.overrideFill());\n-        field.setFill(CSVConfig.FILLLEFT);\n-        assertEquals(true, field.overrideFill());\n-        assertEquals(CSVConfig.FILLLEFT, field.getFill());\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.csv.writer;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * \n+ * @author Martin van den Bemt\n+ * @version $Id: $\n+ */\n+public class CSVFieldTest extends TestCase {\n+\n+    public void testCSVField() {\n+        CSVField field = new CSVField();\n+        assertEquals(null, field.getName());\n+        field.setName(\"id\");\n+        assertEquals(\"id\", field.getName());\n+        assertEquals(0, field.getSize());\n+        field.setSize(10);\n+        assertEquals(10, field.getSize());\n+        field = new CSVField(\"name\");\n+        assertEquals(\"name\", field.getName());\n+        field = new CSVField(\"name\", 10);\n+        assertEquals(\"name\", field.getName());\n+        assertEquals(10, field.getSize());\n+    }\n+    \n+    public void testFill() {\n+        CSVField field = new CSVField();\n+        assertEquals(CSVConfig.FILLNONE, field.getFill());\n+        assertEquals(false, field.overrideFill());\n+        field.setFill(CSVConfig.FILLLEFT);\n+        assertEquals(true, field.overrideFill());\n+        assertEquals(CSVConfig.FILLLEFT, field.getFill());\n+    }\n+}\n--- a/src/test/org/apache/commons/csv/writer/CSVWriterTest.java\n+++ b/src/test/org/apache/commons/csv/writer/CSVWriterTest.java\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.commons.csv.writer;\n-\n-import java.io.StringWriter;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import junit.framework.TestCase;\n-\n-/**\n- * The testcase for the csv writer.\n- * \n- * @author Martin van den Bemt\n- * @version $Id: $\n- */\n-public class CSVWriterTest extends TestCase {\n-\n-    public void testCSVConfig() {\n-        CSVWriter writer = new CSVWriter();\n-        assertEquals(null, writer.getConfig());\n-        CSVConfig config = new CSVConfig();\n-        writer.setConfig(config);\n-        assertEquals(config, writer.getConfig());\n-        writer = new CSVWriter(config);\n-        assertEquals(config, writer.getConfig());\n-    }\n-    \n-    public void testWriter() {\n-        CSVWriter writer = new CSVWriter();\n-        CSVConfig config = new CSVConfig();\n-        config.addField(new CSVField(\"field1\", 5));\n-        config.addField(new CSVField(\"field2\", 4));\n-        writer.setConfig(config);\n-        StringWriter sw = new StringWriter();\n-        writer.setWriter(sw);\n-        Map map = new HashMap();\n-        map.put(\"field1\", \"12345\");\n-        map.put(\"field2\", \"1234\");\n-        writer.writeRecord(map);\n-        assertEquals(\"12345,1234\\n\",sw.toString());\n-    }\n-}\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.commons.csv.writer;\n+\n+import java.io.StringWriter;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * The testcase for the csv writer.\n+ * \n+ * @author Martin van den Bemt\n+ * @version $Id: $\n+ */\n+public class CSVWriterTest extends TestCase {\n+\n+    public void testCSVConfig() {\n+        CSVWriter writer = new CSVWriter();\n+        assertEquals(null, writer.getConfig());\n+        CSVConfig config = new CSVConfig();\n+        writer.setConfig(config);\n+        assertEquals(config, writer.getConfig());\n+        writer = new CSVWriter(config);\n+        assertEquals(config, writer.getConfig());\n+    }\n+    \n+    public void testWriter() {\n+        CSVWriter writer = new CSVWriter();\n+        CSVConfig config = new CSVConfig();\n+        config.addField(new CSVField(\"field1\", 5));\n+        config.addField(new CSVField(\"field2\", 4));\n+        writer.setConfig(config);\n+        StringWriter sw = new StringWriter();\n+        writer.setWriter(sw);\n+        Map map = new HashMap();\n+        map.put(\"field1\", \"12345\");\n+        map.put(\"field2\", \"1234\");\n+        writer.writeRecord(map);\n+        assertEquals(\"12345,1234\\n\",sw.toString());\n+    }\n+}", "timestamp": 1168098040, "metainfo": ""}