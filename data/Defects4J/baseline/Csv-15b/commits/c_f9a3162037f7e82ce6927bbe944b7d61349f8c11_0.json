{"sha": "f9a3162037f7e82ce6927bbe944b7d61349f8c11", "log": "Use \"Character\" as the postfix is ivar names. Use the method name pattern isFooSet() for ivar \"foo\" for methods that test foo for null (foo != null).  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n     private static final long serialVersionUID = 1L;\n \n     private final char delimiter;\n-    private final Character quoteChar; // null if quoting is disabled\n+    private final Character quoteCharacter; // null if quoting is disabled\n     private final QuoteMode quoteMode;\n-    private final Character commentStart; // null if commenting is disabled\n-    private final Character escape; // null if escaping is disabled\n+    private final Character commentStartCharacter; // null if commenting is disabled\n+    private final Character escapeCharacter; // null if escaping is disabled\n     private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n     private final boolean allowMissingColumnNames;\n     private final boolean ignoreEmptyLines;\n             .withDelimiter(TAB)\n             .withEscape(BACKSLASH)\n             .withIgnoreEmptyLines(false)\n-            .withQuoteChar(null)\n+            .withQuote(null)\n             .withRecordSeparator(LF);\n \n     /**\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n         this.delimiter = delimiter;\n-        this.quoteChar = quoteChar;\n+        this.quoteCharacter = quoteChar;\n         this.quoteMode = quoteMode;\n-        this.commentStart = commentStart;\n-        this.escape = escape;\n+        this.commentStartCharacter = commentStart;\n+        this.escapeCharacter = escape;\n         this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n         this.allowMissingColumnNames = allowMissingColumnNames;\n         this.ignoreEmptyLines = ignoreEmptyLines;\n         if (quoteMode != other.quoteMode) {\n             return false;\n         }\n-        if (quoteChar == null) {\n-            if (other.quoteChar != null) {\n+        if (quoteCharacter == null) {\n+            if (other.quoteCharacter != null) {\n                 return false;\n             }\n-        } else if (!quoteChar.equals(other.quoteChar)) {\n-            return false;\n-        }\n-        if (commentStart == null) {\n-            if (other.commentStart != null) {\n+        } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n+            return false;\n+        }\n+        if (commentStartCharacter == null) {\n+            if (other.commentStartCharacter != null) {\n                 return false;\n             }\n-        } else if (!commentStart.equals(other.commentStart)) {\n-            return false;\n-        }\n-        if (escape == null) {\n-            if (other.escape != null) {\n+        } else if (!commentStartCharacter.equals(other.commentStartCharacter)) {\n+            return false;\n+        }\n+        if (escapeCharacter == null) {\n+            if (other.escapeCharacter != null) {\n                 return false;\n             }\n-        } else if (!escape.equals(other.escape)) {\n+        } else if (!escapeCharacter.equals(other.escapeCharacter)) {\n             return false;\n         }\n         if (nullString == null) {\n      *\n      * @return the comment start marker, may be {@code null}\n      */\n-    public Character getCommentStart() {\n-        return commentStart;\n+    public Character getCommentStartCharacter() {\n+        return commentStartCharacter;\n     }\n \n     /**\n      *\n      * @return the escape character, may be {@code null}\n      */\n-    public Character getEscape() {\n-        return escape;\n+    public Character getEscapeCharacter() {\n+        return escapeCharacter;\n     }\n \n     /**\n      *\n      * @return the quoteChar character, may be {@code null}\n      */\n-    public Character getQuoteChar() {\n-        return quoteChar;\n+    public Character getQuoteCharacter() {\n+        return quoteCharacter;\n     }\n \n     /**\n \n         result = prime * result + delimiter;\n         result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n-        result = prime * result + ((quoteChar == null) ? 0 : quoteChar.hashCode());\n-        result = prime * result + ((commentStart == null) ? 0 : commentStart.hashCode());\n-        result = prime * result + ((escape == null) ? 0 : escape.hashCode());\n+        result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n+        result = prime * result + ((commentStartCharacter == null) ? 0 : commentStartCharacter.hashCode());\n+        result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n         result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n         result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n         result = prime * result + (ignoreEmptyLines ? 1231 : 1237);\n      *\n      * @return {@code true} is comments are supported, {@code false} otherwise\n      */\n-    public boolean isCommentingEnabled() {\n-        return commentStart != null;\n+    public boolean isCommentStartCharacterSet() {\n+        return commentStartCharacter != null;\n     }\n \n     /**\n      *\n      * @return {@code true} if escapes are processed\n      */\n-    public boolean isEscaping() {\n-        return escape != null;\n+    public boolean isEscapeCharacterSet() {\n+        return escapeCharacter != null;\n     }\n \n     /**\n      *\n      * @return {@code true} if a nullString is defined\n      */\n-    public boolean isHandlingNull() {\n+    public boolean isNullStringSet() {\n         return nullString != null;\n     }\n \n      *\n      * @return {@code true} if a quoteChar is defined\n      */\n-    public boolean isQuoting() {\n-        return quoteChar != null;\n+    public boolean isQuoteCharacterSet() {\n+        return quoteCharacter != null;\n     }\n \n     /**\n     public String toString() {\n         final StringBuilder sb = new StringBuilder();\n         sb.append(\"Delimiter=<\").append(delimiter).append('>');\n-        if (isEscaping()) {\n+        if (isEscapeCharacterSet()) {\n             sb.append(' ');\n-            sb.append(\"Escape=<\").append(escape).append('>');\n-        }\n-        if (isQuoting()) {\n+            sb.append(\"Escape=<\").append(escapeCharacter).append('>');\n+        }\n+        if (isQuoteCharacterSet()) {\n             sb.append(' ');\n-            sb.append(\"QuoteChar=<\").append(quoteChar).append('>');\n-        }\n-        if (isCommentingEnabled()) {\n+            sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n+        }\n+        if (isCommentStartCharacterSet()) {\n             sb.append(' ');\n-            sb.append(\"CommentStart=<\").append(commentStart).append('>');\n-        }\n-        if (isHandlingNull()) {\n+            sb.append(\"CommentStart=<\").append(commentStartCharacter).append('>');\n+        }\n+        if (isNullStringSet()) {\n             sb.append(' ');\n             sb.append(\"NullString=<\").append(nullString).append('>');\n         }\n      * @throws IllegalArgumentException\n      */\n     private void validate() throws IllegalArgumentException {\n-        if (quoteChar != null && delimiter == quoteChar.charValue()) {\n+        if (quoteCharacter != null && delimiter == quoteCharacter.charValue()) {\n             throw new IllegalArgumentException(\n-                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n-        }\n-\n-        if (escape != null && delimiter == escape.charValue()) {\n+                    \"The quoteChar character and the delimiter cannot be the same ('\" + quoteCharacter + \"')\");\n+        }\n+\n+        if (escapeCharacter != null && delimiter == escapeCharacter.charValue()) {\n             throw new IllegalArgumentException(\n-                    \"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n-        }\n-\n-        if (commentStart != null && delimiter == commentStart.charValue()) {\n+                    \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n+        }\n+\n+        if (commentStartCharacter != null && delimiter == commentStartCharacter.charValue()) {\n             throw new IllegalArgumentException(\n-                    \"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\n-        }\n-\n-        if (quoteChar != null && quoteChar.equals(commentStart)) {\n+                    \"The comment start character and the delimiter cannot be the same ('\" + commentStartCharacter + \"')\");\n+        }\n+\n+        if (quoteCharacter != null && quoteCharacter.equals(commentStartCharacter)) {\n             throw new IllegalArgumentException(\n-                    \"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\n-        }\n-\n-        if (escape != null && escape.equals(commentStart)) {\n+                    \"The comment start character and the quoteChar cannot be the same ('\" + commentStartCharacter + \"')\");\n+        }\n+\n+        if (escapeCharacter != null && escapeCharacter.equals(commentStartCharacter)) {\n             throw new IllegalArgumentException(\n-                    \"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n-        }\n-\n-        if (escape == null && quoteMode == QuoteMode.NONE) {\n+                    \"The comment start and the escape character cannot be the same ('\" + commentStartCharacter + \"')\");\n+        }\n+\n+        if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n             throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n         }\n     }\n         if (isLineBreak(commentMarker)) {\n             throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escape,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, quoteChar, quoteMode, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n         if (isLineBreak(escape)) {\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, quoteChar, quoteMode, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @see #withSkipHeaderRecord(boolean)\n      */\n     public CSVFormat withHeader(final String... header) {\n-        return new CSVFormat(delimiter, quoteChar, quoteMode, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n      */\n     public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n-        return new CSVFormat(delimiter, quoteChar, quoteMode, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n      */\n     public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n-        return new CSVFormat(delimiter, quoteChar, quoteMode, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n      */\n     public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n-        return new CSVFormat(delimiter, quoteChar, quoteMode, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n      */\n     public CSVFormat withNullString(final String nullString) {\n-        return new CSVFormat(delimiter, quoteChar, quoteMode, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @throws IllegalArgumentException\n      *             thrown if the specified character is a line break\n      */\n-    public CSVFormat withQuoteChar(final char quoteChar) {\n-        return withQuoteChar(Character.valueOf(quoteChar));\n+    public CSVFormat withQuote(final char quoteChar) {\n+        return withQuote(Character.valueOf(quoteChar));\n     }\n \n     /**\n      * @throws IllegalArgumentException\n      *             thrown if the specified character is a line break\n      */\n-    public CSVFormat withQuoteChar(final Character quoteChar) {\n+    public CSVFormat withQuote(final Character quoteChar) {\n         if (isLineBreak(quoteChar)) {\n             throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, quoteChar, quoteMode, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteChar, quoteMode, commentStartCharacter, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @return A new CSVFormat that is equal to this but with the specified quote policy\n      */\n     public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n-        return new CSVFormat(delimiter, quoteChar, quoteModePolicy, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentStartCharacter, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      *              if recordSeparator is none of CR, LF or CRLF\n      */\n     public CSVFormat withRecordSeparator(final String recordSeparator) {\n-        return new CSVFormat(delimiter, quoteChar, quoteMode, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @see #withHeader(String...)\n      */\n     public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n-        return new CSVFormat(delimiter, quoteChar, quoteMode, commentStart, escape,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n         if (!newRecord) {\n             out.append(format.getDelimiter());\n         }\n-        if (format.isQuoting()) {\n+        if (format.isQuoteCharacterSet()) {\n             // the original object is needed so can check for Number\n             printAndQuote(object, value, offset, len);\n-        } else if (format.isEscaping()) {\n+        } else if (format.isEscapeCharacterSet()) {\n             printAndEscape(value, offset, len);\n         } else {\n             out.append(value, offset, offset + len);\n         final int end = offset + len;\n \n         final char delim = format.getDelimiter();\n-        final char escape = format.getEscape().charValue();\n+        final char escape = format.getEscapeCharacter().charValue();\n \n         while (pos < end) {\n             char c = value.charAt(pos);\n         final int end = offset + len;\n \n         final char delimChar = format.getDelimiter();\n-        final char quoteChar = format.getQuoteChar().charValue();\n+        final char quoteChar = format.getQuoteCharacter().charValue();\n \n         QuoteMode quoteModePolicy = format.getQuoteMode();\n         if (quoteModePolicy == null) {\n      *             If an I/O error occurs\n      */\n     public void printComment(final String comment) throws IOException {\n-        if (!format.isCommentingEnabled()) {\n+        if (!format.isCommentStartCharacterSet()) {\n             return;\n         }\n         if (!newRecord) {\n             println();\n         }\n-        out.append(format.getCommentStart().charValue());\n+        out.append(format.getCommentStartCharacter().charValue());\n         out.append(SP);\n         for (int i = 0; i < comment.length(); i++) {\n             final char c = comment.charAt(i);\n                 //$FALL-THROUGH$ break intentionally excluded.\n             case LF:\n                 println();\n-                out.append(format.getCommentStart().charValue());\n+                out.append(format.getCommentStartCharacter().charValue());\n                 out.append(SP);\n                 break;\n             default:\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n     Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n         this.reader = reader;\n         this.delimiter = format.getDelimiter();\n-        this.escape = mapNullToDisabled(format.getEscape());\n-        this.quoteChar = mapNullToDisabled(format.getQuoteChar());\n-        this.commentStart = mapNullToDisabled(format.getCommentStart());\n+        this.escape = mapNullToDisabled(format.getEscapeCharacter());\n+        this.quoteChar = mapNullToDisabled(format.getQuoteCharacter());\n+        this.commentStart = mapNullToDisabled(format.getCommentStartCharacter());\n         this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n         this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n     }\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n         final String[] split = line.split(\" \");\n         assertTrue(testName+\" require 1 param\", split.length >= 1);\n          // first line starts with csv data file name\n-        CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\"');\n+        CSVFormat format = CSVFormat.newFormat(',').withQuote('\"');\n         boolean checkComments = false;\n         for(int i=1; i < split.length; i++) {\n             final String option = split[i];\n         final String[] split = line.split(\" \");\n         assertTrue(testName + \" require 1 param\", split.length >= 1);\n         // first line starts with csv data file name\n-        CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\"');\n+        CSVFormat format = CSVFormat.newFormat(',').withQuote('\"');\n         boolean checkComments = false;\n         for (int i = 1; i < split.length; i++) {\n             final String option = split[i];\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n     @Test\n     public void testEqualsCommentStart() {\n         final CSVFormat right = CSVFormat.newFormat('\\'')\n-                .withQuoteChar('\"')\n+                .withQuote('\"')\n                 .withCommentMarker('#')\n                 .withQuoteMode(QuoteMode.ALL);\n         final CSVFormat left = right\n     @Test\n     public void testEqualsEscape() {\n         final CSVFormat right = CSVFormat.newFormat('\\'')\n-                .withQuoteChar('\"')\n+                .withQuote('\"')\n                 .withCommentMarker('#')\n                 .withEscape('+')\n                 .withQuoteMode(QuoteMode.ALL);\n                 .withHeader(\"One\", \"Two\", \"Three\")\n                 .withIgnoreEmptyLines(true)\n                 .withIgnoreSurroundingSpaces(true)\n-                .withQuoteChar('\"')\n+                .withQuote('\"')\n                 .withQuoteMode(QuoteMode.ALL);\n         final CSVFormat left = right\n                 .withHeader(\"Three\", \"Two\", \"One\");\n                 .withEscape('+')\n                 .withIgnoreEmptyLines(true)\n                 .withIgnoreSurroundingSpaces(true)\n-                .withQuoteChar('\"')\n+                .withQuote('\"')\n                 .withQuoteMode(QuoteMode.ALL);\n         final CSVFormat left = right\n                 .withIgnoreEmptyLines(false);\n                 .withCommentMarker('#')\n                 .withEscape('+')\n                 .withIgnoreSurroundingSpaces(true)\n-                .withQuoteChar('\"')\n+                .withQuote('\"')\n                 .withQuoteMode(QuoteMode.ALL);\n         final CSVFormat left = right\n                 .withIgnoreSurroundingSpaces(false);\n \n     @Test\n     public void testEqualsQuoteChar() {\n-        final CSVFormat right = CSVFormat.newFormat('\\'').withQuoteChar('\"');\n-        final CSVFormat left = right.withQuoteChar('!');\n+        final CSVFormat right = CSVFormat.newFormat('\\'').withQuote('\"');\n+        final CSVFormat left = right.withQuote('!');\n \n         assertNotEquals(right, left);\n     }\n     @Test\n     public void testEqualsQuotePolicy() {\n         final CSVFormat right = CSVFormat.newFormat('\\'')\n-                .withQuoteChar('\"')\n+                .withQuote('\"')\n                 .withQuoteMode(QuoteMode.ALL);\n         final CSVFormat left = right\n                 .withQuoteMode(QuoteMode.MINIMAL);\n                 .withEscape('+')\n                 .withIgnoreEmptyLines(true)\n                 .withIgnoreSurroundingSpaces(true)\n-                .withQuoteChar('\"')\n+                .withQuote('\"')\n                 .withQuoteMode(QuoteMode.ALL);\n         final CSVFormat left = right\n                 .withRecordSeparator(LF);\n                 .withEscape('+')\n                 .withIgnoreEmptyLines(true)\n                 .withIgnoreSurroundingSpaces(true)\n-                .withQuoteChar('\"')\n+                .withQuote('\"')\n                 .withQuoteMode(QuoteMode.ALL)\n                 .withNullString(\"null\");\n         final CSVFormat left = right\n                 .withEscape('+')\n                 .withIgnoreEmptyLines(true)\n                 .withIgnoreSurroundingSpaces(true)\n-                .withQuoteChar('\"')\n+                .withQuote('\"')\n                 .withQuoteMode(QuoteMode.ALL)\n                 .withNullString(\"null\")\n                 .withSkipHeaderRecord(true);\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testQuoteCharSameAsCommentStartThrowsException() {\n-        CSVFormat.DEFAULT.withQuoteChar('!').withCommentMarker('!');\n+        CSVFormat.DEFAULT.withQuote('!').withCommentMarker('!');\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType() {\n         // Cannot assume that callers won't use different Character objects\n-        CSVFormat.DEFAULT.withQuoteChar(new Character('!')).withCommentMarker('!');\n+        CSVFormat.DEFAULT.withQuote(new Character('!')).withCommentMarker('!');\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testQuoteCharSameAsDelimiterThrowsException() {\n-        CSVFormat.DEFAULT.withQuoteChar('!').withDelimiter('!');\n+        CSVFormat.DEFAULT.withQuote('!').withDelimiter('!');\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n \n     @Test\n     public void testRFC4180() {\n-        assertEquals(null, RFC4180.getCommentStart());\n+        assertEquals(null, RFC4180.getCommentStartCharacter());\n         assertEquals(',', RFC4180.getDelimiter());\n-        assertEquals(null, RFC4180.getEscape());\n+        assertEquals(null, RFC4180.getEscapeCharacter());\n         assertFalse(RFC4180.getIgnoreEmptyLines());\n-        assertEquals(Character.valueOf('\"'), RFC4180.getQuoteChar());\n+        assertEquals(Character.valueOf('\"'), RFC4180.getQuoteCharacter());\n         assertEquals(null, RFC4180.getQuoteMode());\n         assertEquals(\"\\r\\n\", RFC4180.getRecordSeparator());\n     }\n \n         assertNotNull(format);\n         assertEquals(\"delimiter\", CSVFormat.DEFAULT.getDelimiter(), format.getDelimiter());\n-        assertEquals(\"encapsulator\", CSVFormat.DEFAULT.getQuoteChar(), format.getQuoteChar());\n-        assertEquals(\"comment start\", CSVFormat.DEFAULT.getCommentStart(), format.getCommentStart());\n+        assertEquals(\"encapsulator\", CSVFormat.DEFAULT.getQuoteCharacter(), format.getQuoteCharacter());\n+        assertEquals(\"comment start\", CSVFormat.DEFAULT.getCommentStartCharacter(), format.getCommentStartCharacter());\n         assertEquals(\"record separator\", CSVFormat.DEFAULT.getRecordSeparator(), format.getRecordSeparator());\n-        assertEquals(\"escape\", CSVFormat.DEFAULT.getEscape(), format.getEscape());\n+        assertEquals(\"escape\", CSVFormat.DEFAULT.getEscapeCharacter(), format.getEscapeCharacter());\n         assertEquals(\"trim\", CSVFormat.DEFAULT.getIgnoreSurroundingSpaces(), format.getIgnoreSurroundingSpaces());\n         assertEquals(\"empty lines\", CSVFormat.DEFAULT.getIgnoreEmptyLines(), format.getIgnoreEmptyLines());\n     }\n     @Test\n     public void testWithCommentStart() throws Exception {\n         final CSVFormat formatWithCommentStart = CSVFormat.DEFAULT.withCommentMarker('#');\n-        assertEquals( Character.valueOf('#'), formatWithCommentStart.getCommentStart());\n+        assertEquals( Character.valueOf('#'), formatWithCommentStart.getCommentStartCharacter());\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     @Test\n     public void testWithEscape() throws Exception {\n         final CSVFormat formatWithEscape = CSVFormat.DEFAULT.withEscape('&');\n-        assertEquals(Character.valueOf('&'), formatWithEscape.getEscape());\n+        assertEquals(Character.valueOf('&'), formatWithEscape.getEscapeCharacter());\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n \n     @Test\n     public void testWithQuoteChar() throws Exception {\n-        final CSVFormat formatWithQuoteChar = CSVFormat.DEFAULT.withQuoteChar('\"');\n-        assertEquals(Character.valueOf('\"'), formatWithQuoteChar.getQuoteChar());\n+        final CSVFormat formatWithQuoteChar = CSVFormat.DEFAULT.withQuote('\"');\n+        assertEquals(Character.valueOf('\"'), formatWithQuoteChar.getQuoteCharacter());\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testWithQuoteLFThrowsException() {\n-        CSVFormat.DEFAULT.withQuoteChar(LF);\n+        CSVFormat.DEFAULT.withQuote(LF);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n         };\n \n \n-        final CSVFormat format = CSVFormat.newFormat(',').withQuoteChar('\\'')\n+        final CSVFormat format = CSVFormat.newFormat(',').withQuote('\\'')\n                                .withRecordSeparator(CRLF).withEscape('/').withIgnoreEmptyLines(true);\n \n         final CSVParser parser = CSVParser.parse(code, format);\n         };\n \n         CSVFormat format = CSVFormat.DEFAULT;\n-        assertFalse(format.isCommentingEnabled());\n+        assertFalse(format.isCommentStartCharacterSet());\n \n         CSVParser parser = CSVParser.parse(code, format);\n         List<CSVRecord> records = parser.getRecords();\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n     @Test\n     public void testPlainQuoted() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar('\\''));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n         printer.print(\"abc\");\n         assertEquals(\"abc\", sw.toString());\n         printer.close();\n     @Test\n     public void testSingleQuoteQuoted() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar('\\''));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n         printer.print(\"a'b'c\");\n         printer.print(\"xyz\");\n         assertEquals(\"'a''b''c',xyz\", sw.toString());\n     @Test\n     public void testDelimeterQuoted() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar('\\''));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n         printer.print(\"a,b,c\");\n         printer.print(\"xyz\");\n         assertEquals(\"'a,b,c',xyz\", sw.toString());\n     @Test\n     public void testEOLQuoted() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar('\\''));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote('\\''));\n         printer.print(\"a\\rb\\nc\");\n         printer.print(\"x\\by\\fz\");\n         assertEquals(\"'a\\rb\\nc',x\\by\\fz\", sw.toString());\n     @Test\n     public void testPlainEscaped() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null).withEscape('!'));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n         printer.print(\"abc\");\n         printer.print(\"xyz\");\n         assertEquals(\"abc,xyz\", sw.toString());\n     @Test\n     public void testDelimiterEscaped() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuoteChar(null));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withEscape('!').withQuote(null));\n         printer.print(\"a,b,c\");\n         printer.print(\"xyz\");\n         assertEquals(\"a!,b!,c,xyz\", sw.toString());\n     @Test\n     public void testEOLEscaped() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null).withEscape('!'));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null).withEscape('!'));\n         printer.print(\"a\\rb\\nc\");\n         printer.print(\"x\\fy\\bz\");\n         assertEquals(\"a!rb!nc,x\\fy\\bz\", sw.toString());\n     @Test\n     public void testPlainPlain() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n         printer.print(\"abc\");\n         printer.print(\"xyz\");\n         assertEquals(\"abc,xyz\", sw.toString());\n     @Test\n     public void testDelimiterPlain() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n         printer.print(\"a,b,c\");\n         printer.print(\"xyz\");\n         assertEquals(\"a,b,c,xyz\", sw.toString());\n     @Test\n     public void testHeader() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null)\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null)\n                 .withHeader(\"C1\", \"C2\", \"C3\"));\n         printer.printRecord(\"a\", \"b\", \"c\");\n         printer.printRecord(\"x\", \"y\", \"z\");\n     @Test\n     public void testEOLPlain() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuoteChar(null));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withQuote(null));\n         printer.print(\"a\\rb\\nc\");\n         printer.print(\"x\\fy\\bz\");\n         assertEquals(\"a\\rb\\nc,x\\fy\\bz\", sw.toString());\n--- a/src/test/java/org/apache/commons/csv/LexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/LexerTest.java\n         */\n         final String code = \"a,\\\\,,b\\\\\\n\\\\,,\";\n         final CSVFormat format = CSVFormat.DEFAULT;\n-        assertFalse(format.isEscaping());\n+        assertFalse(format.isEscapeCharacterSet());\n         final Lexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         */\n         final String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\n         final CSVFormat format = formatWithEscaping.withIgnoreEmptyLines(false);\n-        assertTrue(format.isEscaping());\n+        assertTrue(format.isEscapeCharacterSet());\n         final Lexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         *       ;;\n         */\n         final String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n-        final CSVFormat format = CSVFormat.DEFAULT.withQuoteChar('\\'').withCommentMarker('!').withDelimiter(';');\n+        final CSVFormat format = CSVFormat.DEFAULT.withQuote('\\'').withCommentMarker('!').withDelimiter(';');\n         final Lexer parser = getLexer(code, format);\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b and ' more\\n\"));", "timestamp": 1405963100, "metainfo": ""}