{"sha": "1c7a9910be857a4f33ed216701407806e1d20670", "log": "[CSV-201] Do not use RuntimeException in CSVParser.iterator().new Iterator() {...}.getNextRecord(). Use an IllegalStateException instead (KISS for now, no need for a custom exception)", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     /**\n      * Returns an iterator on the records.\n      *\n-     * <p>IOExceptions occurring during the iteration are wrapped in a\n-     * RuntimeException.\n-     * If the parser is closed a call to {@code next()} will throw a\n-     * NoSuchElementException.</p>\n+     * <p>\n+     * An {@link IOException} caught during the iteration are re-thrown as an\n+     * {@link IllegalStateException}.\n+     * </p>\n+     * <p>\n+     * If the parser is closed a call to {@link Iterator#next()} will throw a\n+     * {@link NoSuchElementException}.\n+     * </p>\n      */\n     @Override\n     public Iterator<CSVRecord> iterator() {\n                 try {\n                     return CSVParser.this.nextRecord();\n                 } catch (final IOException e) {\n-                    // TODO: This is not great, throw an ISE instead?\n-                    throw new RuntimeException(e);\n+                    throw new IllegalStateException(\n+                            e.getClass().getSimpleName() + \" reading next record: \" + e.toString(), e);\n                 }\n             }\n ", "timestamp": 1477429172, "metainfo": ""}