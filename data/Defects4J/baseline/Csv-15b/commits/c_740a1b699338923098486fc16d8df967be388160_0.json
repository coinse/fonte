{"sha": "740a1b699338923098486fc16d8df967be388160", "log": "Removed the volatile modifier on the fields in CSVFormat to improve the performances  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n /**\n  * The format specification of a CSV file.\n  *\n- * This class is thread-safe.\n+ * This class is immutable.\n  */\n-public class CSVFormat implements Cloneable, Serializable {\n-\n-    private volatile char delimiter = ',';\n-    private volatile char encapsulator = '\"';\n-    private volatile char commentStart = DISABLED;\n-    private volatile char escape = DISABLED;\n-    private volatile boolean leadingSpacesIgnored = true;\n-    private volatile boolean trailingSpacesIgnored = true;\n-    private volatile boolean unicodeEscapesInterpreted = false;\n-    private volatile boolean emptyLinesIgnored = true;\n-    private volatile String lineSeparator = \"\\r\\n\";\n+public class CSVFormat implements Serializable {\n+\n+    private final char delimiter;\n+    private final char encapsulator;\n+    private final char commentStart;\n+    private final char escape;\n+    private final boolean leadingSpacesIgnored;\n+    private final boolean trailingSpacesIgnored;\n+    private final boolean unicodeEscapesInterpreted;\n+    private final boolean emptyLinesIgnored;\n+    private final String lineSeparator;\n \n \n     /**\n     static final char DISABLED = '\\ufffe';\n \n     /** Standard comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>. */\n-    public static final CSVFormat DEFAULT = new CSVFormat(',', '\"', DISABLED, DISABLED, true, true, false, true);\n+    public static final CSVFormat DEFAULT = new CSVFormat(',', '\"', DISABLED, DISABLED, true, true, false, true, \"\\r\\n\");\n \n     /**\n      * Excel file format (using a comma as the value delimiter).\n      * \n      * <pre>CSVFormat fmt = CSVFormat.EXCEL.withDelimiter(';');</pre>\n      */\n-    public static final CSVFormat EXCEL = new CSVFormat(',', '\"', DISABLED, DISABLED, false, false, false, false);\n+    public static final CSVFormat EXCEL = new CSVFormat(',', '\"', DISABLED, DISABLED, false, false, false, false, \"\\r\\n\");\n \n     /** Tabulation delimited format. */\n-    public static final CSVFormat TDF = new CSVFormat('\\t', '\"', DISABLED, DISABLED, true, true, false, true);\n-    \n+    public static final CSVFormat TDF = new CSVFormat('\\t', '\"', DISABLED, DISABLED, true, true, false, true, \"\\r\\n\");\n+\n     /**\n      * Default MySQL format used by the <tt>SELECT INTO OUTFILE</tt> and\n      * <tt>LOAD DATA INFILE</tt> operations. This is a tabulation delimited\n      * \n      * @see <a href=\"http://dev.mysql.com/doc/refman/5.1/en/load-data.html\">http://dev.mysql.com/doc/refman/5.1/en/load-data.html</a>\n      */\n-    public static final CSVFormat MYSQL = new CSVFormat('\\t', DISABLED, DISABLED, '\\\\', false, false, false, false).withLineSeparator(\"\\n\");\n-\n-\n-    /**\n-     * Creates a CSV format with the default parameters.\n-     */\n-    CSVFormat() {\n-    }\n-\n-    /**\n-     * Creates a customized CSV format.\n-     * \n-     * @param delimiter                 the char used for value separation\n-     * @param encapsulator              the char used as value encapsulation marker\n-     * @param commentStart              the char used for comment identification\n-     */\n-    CSVFormat(char delimiter, char encapsulator, char commentStart) {\n-        this(delimiter, encapsulator, commentStart, DISABLED, true, true, false, true);\n-    }\n+    public static final CSVFormat MYSQL = new CSVFormat('\\t', DISABLED, DISABLED, '\\\\', false, false, false, false, \"\\n\");\n+\n \n     /**\n      * Creates a customized CSV format.\n             boolean leadingSpacesIgnored,\n             boolean trailingSpacesIgnored,\n             boolean unicodeEscapesInterpreted,\n-            boolean emptyLinesIgnored) {\n+            boolean emptyLinesIgnored,\n+            String lineSeparator) {\n         this.delimiter = delimiter;\n         this.encapsulator = encapsulator;\n         this.commentStart = commentStart;\n         this.trailingSpacesIgnored = trailingSpacesIgnored;\n         this.unicodeEscapesInterpreted = unicodeEscapesInterpreted;\n         this.emptyLinesIgnored = emptyLinesIgnored;\n+        this.lineSeparator = lineSeparator;\n     }\n \n     /**\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n-        \n-        CSVFormat format = clone();\n-        format.delimiter = delimiter;\n-        return format;\n+\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The encapsulator cannot be a line break\");\n         }\n         \n-        CSVFormat format = clone();\n-        format.encapsulator = encapsulator;\n-        return format;\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n     }\n \n     boolean isEncapsulating() {\n             throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n         }\n         \n-        CSVFormat format = clone();\n-        format.commentStart = commentStart;\n-        return format;\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n         \n-        CSVFormat format = clone();\n-        format.escape = escape;\n-        return format;\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n     }\n \n     boolean isEscaping() {\n      * @return A copy of this format with the specified left trimming behavior.\n      */\n     public CSVFormat withLeadingSpacesIgnored(boolean leadingSpacesIgnored) {\n-        CSVFormat format = clone();\n-        format.leadingSpacesIgnored = leadingSpacesIgnored;\n-        return format;\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n     }\n \n     /**\n      * @return A copy of this format with the specified right trimming behavior.\n      */\n     public CSVFormat withTrailingSpacesIgnored(boolean trailingSpacesIgnored) {\n-        CSVFormat format = clone();\n-        format.trailingSpacesIgnored = trailingSpacesIgnored;\n-        return format;\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n     }\n \n     /**\n      * @return A copy of this format with the specified trimming behavior.\n      */\n     public CSVFormat withSurroundingSpacesIgnored(boolean surroundingSpacesIgnored) {\n-        CSVFormat format = clone();\n-        format.leadingSpacesIgnored = surroundingSpacesIgnored;\n-        format.trailingSpacesIgnored = surroundingSpacesIgnored;\n-        return format;\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, surroundingSpacesIgnored, surroundingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n     }\n \n     /**\n      * @return A copy of this format with the specified unicode escaping behavior.\n      */\n     public CSVFormat withUnicodeEscapesInterpreted(boolean unicodeEscapesInterpreted) {\n-        CSVFormat format = clone();\n-        format.unicodeEscapesInterpreted = unicodeEscapesInterpreted;\n-        return format;\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n     }\n \n     /**\n      * @return A copy of this format  with the specified empty line skipping behavior.\n      */\n     public CSVFormat withEmptyLinesIgnored(boolean emptyLinesIgnored) {\n-        CSVFormat format = clone();\n-        format.emptyLinesIgnored = emptyLinesIgnored;\n-        return format;\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n     }\n \n     /**\n      * @return A copy of this format using the specified line separator\n      */\n     public CSVFormat withLineSeparator(String lineSeparator) {\n-        CSVFormat format = clone();\n-        format.lineSeparator = lineSeparator;\n-        return format;\n+        return new CSVFormat(delimiter, encapsulator, commentStart, escape, leadingSpacesIgnored, trailingSpacesIgnored, unicodeEscapesInterpreted, emptyLinesIgnored, lineSeparator);\n     }\n \n     /**\n         \n         return out.toString().trim();\n     }\n-\n-    @Override\n-    protected CSVFormat clone() {\n-        try {\n-            return (CSVFormat) super.clone();\n-        } catch (CloneNotSupportedException e) {\n-            throw (Error) new InternalError().initCause(e);\n-        }\n-    }\n }\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n public class CSVFormatTest extends TestCase {\n \n     public void testImmutalibity() {\n-        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, true);\n+        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, true, \"\\r\\n\");\n         \n         format.withDelimiter('?');\n         format.withEncapsulator('?');\n     }\n \n     public void testMutators() {\n-        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, true);\n+        CSVFormat format = new CSVFormat('!', '!', '!', '!', true, true, true, true, \"\\r\\n\");\n         \n         assertEquals('?', format.withDelimiter('?').getDelimiter());\n         assertEquals('?', format.withEncapsulator('?').getEncapsulator());\n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n         *       ;;\n         */\n         String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n-        CSVFormat format = new CSVFormat(';', '\\'', '!');\n+        CSVFormat format = CSVFormat.DEFAULT.withDelimiter(';').withEncapsulator('\\'').withCommentStart('!');\n         CSVLexer parser = getLexer(code, format);\n         assertTokenEquals(TOKEN, \"a\", parser.nextToken(new Token()));\n         assertTokenEquals(EORECORD, \"b and ' more\\n\", parser.nextToken(new Token()));\n     }\n \n-    // From SANDBOX-153\n+    // From CSV-1\n     public void testDelimiterIsWhitespace() throws IOException {\n         String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n         CSVLexer parser = getLexer(code, CSVFormat.TDF);\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n         };\n \n \n-        CSVFormat format = new CSVFormat(',', '\\'', CSVFormat.DISABLED, '/', false, false, true, true);\n+        CSVFormat format = new CSVFormat(',', '\\'', CSVFormat.DISABLED, '/', false, false, true, true, \"\\r\\n\");\n \n         CSVParser parser = new CSVParser(code, format);\n         String[][] tmp = parser.getRecords();\n         };\n \n \n-        CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, false, true, true);\n+        CSVFormat format = new CSVFormat(',',  CSVFormat.DISABLED,  CSVFormat.DISABLED, '/', false, false, true, true, \"\\r\\n\");\n \n         CSVParser parser = new CSVParser(code, format);\n         String[][] tmp = parser.getRecords();\n                 {\"\"},\n         };\n \n-        format = new CSVFormat(',', '\"', '#');\n+        format = CSVFormat.DEFAULT.withCommentStart('#');\n         parser = new CSVParser(code, format);\n         tmp = parser.getRecords();\n ", "timestamp": 1331506883, "metainfo": ""}