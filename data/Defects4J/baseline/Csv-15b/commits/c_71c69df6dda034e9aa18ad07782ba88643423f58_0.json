{"sha": "71c69df6dda034e9aa18ad07782ba88643423f58", "log": "CSV-98  Line number counting is confusing  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n      */\n     private Token parseEncapsulatedToken(final Token tkn) throws IOException {\n         // save current line number in case needed for IOE\n-        final long startLineNumber = getLineNumber();\n+        final long startLineNumber = getCurrentLineNumber();\n         int c;\n         while (true) {\n             c = in.read();\n                             return tkn;\n                         } else if (!isWhitespace(c)) {\n                             // error invalid char between token and next delimiter\n-                            throw new IOException(\"(line \" + getLineNumber() +\n+                            throw new IOException(\"(line \" + getCurrentLineNumber() +\n                                     \") invalid char between encapsulated token and delimiter\");\n                         }\n                     }\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n      *\n      * @return current line number\n      */\n-    public long getLineNumber() {\n-        return lexer.getLineNumber();\n+    public long getCurrentLineNumber() {\n+        return lexer.getCurrentLineNumber();\n     }\n \n     /**\n                 }\n                 break;\n             case INVALID:\n-                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n+                throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid parse sequence\");\n             case COMMENT: // Ignored currently\n                 if (sb == null) { // first comment for this record\n                     sb = new StringBuilder();\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n     /** The last char returned */\n     private int lastChar = UNDEFINED;\n \n-    /** The line counter */\n-    private long lineCounter;\n+    /** The count of EOLs (CR/LF/CRLF) seen so far */\n+    private long eolCounter = 0;\n \n     /**\n      * Created extended buffered reader using default buffer-size\n     public int read() throws IOException {\n         final int current = super.read();\n         if (current == CR || (current == LF && lastChar != CR)) {\n-            lineCounter++;\n+            eolCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n                 final char ch = buf[i];\n                 if (ch == LF) {\n                     if (CR != (i > 0 ? buf[i - 1] : lastChar)) {\n-                        lineCounter++;\n+                        eolCounter++;\n                     }\n                 } else if (ch == CR) {\n-                    lineCounter++;\n+                    eolCounter++;\n                 }\n             }\n \n      * Calls {@link BufferedReader#readLine()} which drops the line terminator(s). This method should only be called\n      * when processing a comment, otherwise information can be lost.\n      * <p>\n-     * Increments {@link #lineCounter}\n+     * Increments {@link #eolCounter}\n      * <p>\n      * Sets {@link #lastChar} to {@link #END_OF_STREAM} at EOF, otherwise to LF\n      *\n \n         if (line != null) {\n             lastChar = LF; // needed for detecting start of line\n-            lineCounter++;\n+            eolCounter++;\n         } else {\n             lastChar = END_OF_STREAM;\n         }\n \n     /**\n      * Returns the next character in the current reader without consuming it. So the next call to {@link #read()} will\n-     * still return this value.\n+     * still return this value. Does not affect line number or last character.\n      *\n      * @return the next character\n      *\n     }\n \n     /**\n-     * Returns the number of lines read\n+     * Returns the current line number\n      *\n-     * @return the number of EOLs seen so far\n+     * @return the current line number\n      */\n-    long getLineNumber() {\n-        return lineCounter;\n+    long getCurrentLineNumber() {\n+        // Check if we are at EOL or EOF or just starting\n+        if (lastChar == CR || lastChar == LF || lastChar == UNDEFINED || lastChar == END_OF_STREAM) {\n+            return eolCounter; // counter is accurate\n+        }\n+        return eolCounter + 1; // Allow for counter being incremented only at EOL\n     }\n }\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n     }\n \n     /**\n-     * Returns the number of lines read\n+     * Returns the current line number\n      *\n-     * @return the number of EOLs seen so far\n+     * @return the current line number\n      */\n-    long getLineNumber() {\n-        return in.getLineNumber();\n+    long getCurrentLineNumber() {\n+        return in.getCurrentLineNumber();\n     }\n \n     // TODO escape handling needs more work\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1.java\n      */\n     private Token encapsulatedTokenLexer(final Token tkn, int c) throws IOException {\n         // save current line\n-        final long startLineNumber = getLineNumber();\n+        final long startLineNumber = getCurrentLineNumber();\n         // ignore the given delimiter\n         // assert c == delimiter;\n         while (true) {\n                             return tkn;\n                         } else if (!isWhitespace(c)) {\n                             // error invalid char between token and next delimiter\n-                            throw new IOException(\"(line \" + getLineNumber() + \") invalid char between encapsulated token and delimiter\");\n+                            throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid char between encapsulated token and delimiter\");\n                         }\n                     }\n                 }\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1306663.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1306663.java\n      */\n     private Token encapsulatedTokenLexer(final Token tkn) throws IOException {\n         // save current line\n-        final long startLineNumber = getLineNumber();\n+        final long startLineNumber = getCurrentLineNumber();\n         // ignore the given delimiter\n         // assert c == delimiter;\n         int c;\n                             return tkn;\n                         } else if (!isWhitespace(c)) {\n                             // error invalid char between token and next delimiter\n-                            throw new IOException(\"(line \" + getLineNumber() + \") invalid char between encapsulated token and delimiter\");\n+                            throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid char between encapsulated token and delimiter\");\n                         }\n                     }\n                 }\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1306667.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1306667.java\n      */\n     private Token encapsulatedTokenLexer(final Token tkn) throws IOException {\n         // save current line\n-        final long startLineNumber = getLineNumber();\n+        final long startLineNumber = getCurrentLineNumber();\n         // ignore the given delimiter\n         // assert c == delimiter;\n         int c;\n                             return tkn;\n                         } else if (!isWhitespace(c)) {\n                             // error invalid char between token and next delimiter\n-                            throw new IOException(\"(line \" + getLineNumber() + \") invalid char between encapsulated token and delimiter\");\n+                            throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid char between encapsulated token and delimiter\");\n                         }\n                     }\n                 }\n--- a/src/test/java/org/apache/commons/csv/CSVLexer3.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer3.java\n                             state = State.ESCAPE_QUOTE;\n                             break;\n                         case EOFCHAR:\n-                            throw new IOException(\"(line \" + getLineNumber() + \") unexpected EOF in quoted string\");\n+                            throw new IOException(\"(line \" + getCurrentLineNumber() + \") unexpected EOF in quoted string\");\n                         default:\n                             tkn.content.append((char) intch);\n                             break;\n                         case WHITESPACE: // trailing whitespace may be allowed\n                             if (!ignoreSurroundingSpaces) {\n                                 // error invalid char between token and next delimiter\n-                                throw new IOException(\"(line \" + getLineNumber() + \") invalid char between encapsulated token and delimiter\");\n+                                throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid char between encapsulated token and delimiter\");\n                             }\n                             break;\n                         // Everything else is invalid\n                         case OTHER:\n                         case COMMENT_START:\n                             // error invalid char between token and next delimiter\n-                            throw new IOException(\"(line \" + getLineNumber() + \") invalid char between encapsulated token and delimiter\");\n+                            throw new IOException(\"(line \" + getCurrentLineNumber() + \") invalid char between encapsulated token and delimiter\");\n                     }\n                     break;\n                 case ESCAPE_PLAIN:\n                             tkn.content.append((char) intch);\n                             break;\n                         case EOFCHAR:\n-                            throw new IOException(\"(line \" + getLineNumber() + \") unexpected EOF in escape sequence\");\n+                            throw new IOException(\"(line \" + getCurrentLineNumber() + \") unexpected EOF in escape sequence\");\n                     }\n                     break;\n                 case ESCAPE_QUOTE:\n                             tkn.content.append((char) intch);\n                             break;\n                         case EOFCHAR:\n-                            throw new IOException(\"(line \" + getLineNumber() + \") unexpected EOF in escape sequence\");\n+                            throw new IOException(\"(line \" + getCurrentLineNumber() + \") unexpected EOF in escape sequence\");\n                     }\n                     break;\n                 default:\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n                 CSVFormat.newBuilder().withRecordSeparator(CRLF).build());\n         CSVRecord record;\n         assertEquals(0, parser.getRecordNumber());\n-        assertEquals(0, parser.getLineNumber());\n+        assertEquals(0, parser.getCurrentLineNumber());\n         assertNotNull(record = parser.nextRecord());\n-        assertEquals(3, parser.getLineNumber());\n+        assertEquals(3, parser.getCurrentLineNumber());\n         assertEquals(1, record.getRecordNumber());\n         assertEquals(1, parser.getRecordNumber());\n         assertNotNull(record = parser.nextRecord());\n-        assertEquals(6, parser.getLineNumber());\n+        assertEquals(6, parser.getCurrentLineNumber());\n         assertEquals(2, record.getRecordNumber());\n         assertEquals(2, parser.getRecordNumber());\n         assertNotNull(record = parser.nextRecord());\n-        assertEquals(8, parser.getLineNumber());\n+        assertEquals(8, parser.getCurrentLineNumber());\n         assertEquals(3, record.getRecordNumber());\n         assertEquals(3, parser.getRecordNumber());\n         assertNull(record = parser.nextRecord());\n-        assertEquals(8, parser.getLineNumber());\n+        assertEquals(8, parser.getCurrentLineNumber());\n         assertEquals(3, parser.getRecordNumber());\n     }\n \n \n     private void validateLineNumbers(final String lineSeparator) throws IOException {\n         final CSVParser parser = new CSVParser(\"a\" + lineSeparator + \"b\" + lineSeparator + \"c\", CSVFormat.newBuilder().withRecordSeparator(lineSeparator).build());\n-        assertEquals(0, parser.getLineNumber());\n+        assertEquals(0, parser.getCurrentLineNumber());\n         assertNotNull(parser.nextRecord());\n-        assertEquals(1, parser.getLineNumber());\n+        assertEquals(1, parser.getCurrentLineNumber());\n         assertNotNull(parser.nextRecord());\n-        assertEquals(2, parser.getLineNumber());\n+        assertEquals(2, parser.getCurrentLineNumber());\n         assertNotNull(parser.nextRecord());\n         // Still 2 because the last line is does not have EOL chars\n-        assertEquals(2, parser.getLineNumber());\n+        assertEquals(2, parser.getCurrentLineNumber());\n         assertNull(parser.nextRecord());\n         // Still 2 because the last line is does not have EOL chars\n-        assertEquals(2, parser.getLineNumber());\n+        assertEquals(2, parser.getCurrentLineNumber());\n     }\n \n }\n--- a/src/test/java/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n+++ b/src/test/java/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n     @Test\n     public void testReadLookahead1() throws Exception {\n         final ExtendedBufferedReader br = getBufferedReader(\"1\\n2\\r3\\n\");\n+        assertEquals(0, br.getCurrentLineNumber());\n         assertEquals('1', br.lookAhead());\n         assertEquals(UNDEFINED, br.getLastChar());\n-        assertEquals('1', br.read());\n+        assertEquals(0, br.getCurrentLineNumber());\n+        assertEquals('1', br.read()); // Start line 1\n         assertEquals('1', br.getLastChar());\n \n-        assertEquals(0, br.getLineNumber());\n+        assertEquals(1, br.getCurrentLineNumber());\n         assertEquals('\\n', br.lookAhead());\n-        assertEquals(0, br.getLineNumber());\n+        assertEquals(1, br.getCurrentLineNumber());\n         assertEquals('1', br.getLastChar());\n         assertEquals('\\n', br.read());\n-        assertEquals(1, br.getLineNumber());\n-        assertEquals('\\n', br.getLastChar());\n-        assertEquals(1, br.getLineNumber());\n+        assertEquals(1, br.getCurrentLineNumber());\n+        assertEquals('\\n', br.getLastChar());\n+        assertEquals(1, br.getCurrentLineNumber());\n \n         assertEquals('2', br.lookAhead());\n-        assertEquals(1, br.getLineNumber());\n-        assertEquals('\\n', br.getLastChar());\n-        assertEquals(1, br.getLineNumber());\n-        assertEquals('2', br.read());\n+        assertEquals(1, br.getCurrentLineNumber());\n+        assertEquals('\\n', br.getLastChar());\n+        assertEquals(1, br.getCurrentLineNumber());\n+        assertEquals('2', br.read()); // Start line 2\n+        assertEquals(2, br.getCurrentLineNumber());\n         assertEquals('2', br.getLastChar());\n \n         assertEquals('\\r', br.lookAhead());\n+        assertEquals(2, br.getCurrentLineNumber());\n         assertEquals('2', br.getLastChar());\n         assertEquals('\\r', br.read());\n         assertEquals('\\r', br.getLastChar());\n+        assertEquals(2, br.getCurrentLineNumber());\n \n         assertEquals('3', br.lookAhead());\n         assertEquals('\\r', br.getLastChar());\n-        assertEquals('3', br.read());\n+        assertEquals('3', br.read()); // Start line 3\n         assertEquals('3', br.getLastChar());\n+        assertEquals(3, br.getCurrentLineNumber());\n \n         assertEquals('\\n', br.lookAhead());\n-        assertEquals(2, br.getLineNumber());\n+        assertEquals(3, br.getCurrentLineNumber());\n         assertEquals('3', br.getLastChar());\n         assertEquals('\\n', br.read());\n-        assertEquals(3, br.getLineNumber());\n-        assertEquals('\\n', br.getLastChar());\n-        assertEquals(3, br.getLineNumber());\n+        assertEquals(3, br.getCurrentLineNumber());\n+        assertEquals('\\n', br.getLastChar());\n+        assertEquals(3, br.getCurrentLineNumber());\n \n         assertEquals(END_OF_STREAM, br.lookAhead());\n         assertEquals('\\n', br.getLastChar());\n         assertEquals(END_OF_STREAM, br.getLastChar());\n         assertEquals(END_OF_STREAM, br.read());\n         assertEquals(END_OF_STREAM, br.lookAhead());\n+        assertEquals(3, br.getCurrentLineNumber());\n \n     }\n \n         assertNull(br.readLine());\n \n         br = getBufferedReader(\"foo\\n\\nhello\");\n-        assertEquals(0, br.getLineNumber());\n+        assertEquals(0, br.getCurrentLineNumber());\n         assertEquals(\"foo\",br.readLine());\n-        assertEquals(1, br.getLineNumber());\n+        assertEquals(1, br.getCurrentLineNumber());\n         assertEquals(\"\",br.readLine());\n-        assertEquals(2, br.getLineNumber());\n+        assertEquals(2, br.getCurrentLineNumber());\n         assertEquals(\"hello\",br.readLine());\n-        assertEquals(3, br.getLineNumber());\n-        assertNull(br.readLine());\n-        assertEquals(3, br.getLineNumber());\n+        assertEquals(3, br.getCurrentLineNumber());\n+        assertNull(br.readLine());\n+        assertEquals(3, br.getCurrentLineNumber());\n \n         br = getBufferedReader(\"foo\\n\\nhello\");\n         assertEquals('f', br.read());\n         assertEquals('o', br.lookAhead());\n         assertEquals(\"oo\",br.readLine());\n-        assertEquals(1, br.getLineNumber());\n+        assertEquals(1, br.getCurrentLineNumber());\n         assertEquals('\\n', br.lookAhead());\n         assertEquals(\"\",br.readLine());\n-        assertEquals(2, br.getLineNumber());\n+        assertEquals(2, br.getCurrentLineNumber());\n         assertEquals('h', br.lookAhead());\n         assertEquals(\"hello\",br.readLine());\n         assertNull(br.readLine());\n-        assertEquals(3, br.getLineNumber());\n+        assertEquals(3, br.getCurrentLineNumber());\n \n \n         br = getBufferedReader(\"foo\\rbaar\\r\\nfoo\");\n         ExtendedBufferedReader br;\n \n         br = getBufferedReader(test);\n-        assertEquals(0, br.getLineNumber());\n+        assertEquals(0, br.getCurrentLineNumber());\n         while(br.readLine()!=null) {}\n-        assertEquals(EOLeolct, br.getLineNumber());\n+        assertEquals(EOLeolct, br.getCurrentLineNumber());\n \n         br = getBufferedReader(test);\n-        assertEquals(0, br.getLineNumber());\n+        assertEquals(0, br.getCurrentLineNumber());\n         while(br.read()!=-1) {}\n-        assertEquals(EOLeolct, br.getLineNumber());\n+        assertEquals(EOLeolct, br.getCurrentLineNumber());\n \n         br = getBufferedReader(test);\n-        assertEquals(0, br.getLineNumber());\n+        assertEquals(0, br.getCurrentLineNumber());\n         final char[] buff = new char[10];\n         while(br.read(buff ,0, 3)!=-1) {}\n-        assertEquals(EOLeolct, br.getLineNumber());\n+        assertEquals(EOLeolct, br.getCurrentLineNumber());\n     }\n \n     private ExtendedBufferedReader getBufferedReader(final String s) {", "timestamp": 1367939568, "metainfo": ""}