{"sha": "f78b5a14ca34f6176890b00308868b664b696148", "log": "Change CSVFormat#Iterable<CSVRecord> parse(final Reader in) to return a CSVParser, which is compatible since CSVParser implements Iterable<CSVRecord>. This allows a caller to end the parsing by calling CSVParser#close() or to use CSVParser in a Java 7 try-with-resources, without tracking a reader or input stream.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n         return quoteChar != null;\n     }\n \n-    /**\n-     * Parses the specified content.\n-     *\n-     * @param in\n-     *            the input stream\n-     * @return a stream of CSVRecord\n-     * @throws IOException\n-     *             If an I/O error occurs\n-     */\n-    public Iterable<CSVRecord> parse(final Reader in) throws IOException {\n+\t/**\n+\t * Parses the specified content.\n+\t * \n+\t * @param in\n+\t *            the input stream\n+\t * @return a parser over a stream of {@link #CSVRecord}s.\n+\t * @throws IOException\n+\t *             If an I/O error occurs\n+\t */\n+    public CSVParser parse(final Reader in) throws IOException {\n         return new CSVParser(in, this);\n     }\n \n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n \n     /**\n      * Closes resources.\n+     * \n+\t * @throws IOException\n+\t *             If an I/O error occurs\n      */\n \tpublic void close() throws IOException {\n \t\tif (lexer != null) {\n             }\n \n             public boolean hasNext() {\n+            \tif (isClosed()) {\n+            \t\treturn false;\n+            \t}\n                 if (current == null) {\n                     current = getNextRecord();\n                 }\n             }\n \n             public CSVRecord next() {\n+            \tif (isClosed()) {\n+            \t\treturn null;\n+            \t}\n                 CSVRecord next = current;\n                 current = null;\n \n         };\n     }\n \n+\tpublic boolean isClosed() {\n+\t\treturn lexer.isClosed();\n+\t}\n+\n }\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n \n     /** The count of EOLs (CR/LF/CRLF) seen so far */\n     private long eolCounter = 0;\n+    \n+    private boolean closed;\n \n     /**\n      * Created extended buffered reader using default buffer-size\n         }\n         return eolCounter + 1; // Allow for counter being incremented only at EOL\n     }\n+\n+\tpublic boolean isClosed() {\n+\t\treturn closed;\n+\t}\n+\n+\t/**\n+\t * Closes the stream.\n+\t * \n+\t * @throws IOException\n+\t *             If an I/O error occurs\n+\t */\n+\t@Override\n+\tpublic void close() throws IOException {\n+\t\t// Set ivars before calling super close() in case close() throws an IOException.\n+\t\tclosed = true;\n+\t\tlastChar = END_OF_STREAM;\n+\t\tsuper.close();\n+\t}\n+\n }\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n \n     abstract Token nextToken(Token reusableToken) throws IOException;\n \n+    boolean isClosed() {\n+    \treturn in.isClosed();\n+    }\n+    \n     /**\n      * @return true if the given char is a whitespace character\n      */\n \n     /**\n      * Closes resources.\n+     * \n+\t * @throws IOException\n+\t *             If an I/O error occurs\n      */\n \tpublic void close() throws IOException {\n-\t\tif (in != null) {\n-\t\t\tin.close();\n-\t\t}\n+\t\tin.close();\n \t}\n }\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n import java.util.NoSuchElementException;\n \n import org.junit.Assert;\n-\n import org.junit.Ignore;\n import org.junit.Test;\n \n         final CSVParser parser = new CSVParser(new StringReader(code));\n         final List<CSVRecord> records = parser.getRecords();\n         assertEquals(4, records.size());\n+    }\n+\n+    @Test\n+    public void testClose() throws Exception {\n+        final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n+        final CSVParser parser = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in);\n+        final Iterator<CSVRecord> records = parser.iterator();\n+        assertTrue(records.hasNext());\n+        parser.close();\n+        assertFalse(records.hasNext());\n+        assertNull(records.next());\n+        assertFalse(records.hasNext());\n+        assertNull(records.next());\n     }\n \n     @Test\n \n     @Test\n     public void testGetLineNumberWithLF() throws Exception {\n-        validateLineNumbers(String.valueOf(LF));\n+        this.validateLineNumbers(String.valueOf(LF));\n     }\n \n     @Test\n     public void testGetLineNumberWithCRLF() throws Exception {\n-        validateLineNumbers(CRLF);\n+        this.validateLineNumbers(CRLF);\n     }\n \n     @Test\n     public void testGetLineNumberWithCR() throws Exception {\n-        validateLineNumbers(String.valueOf(CR));\n+        this.validateLineNumbers(String.valueOf(CR));\n     }\n \n     @Test\n     public void testGetRecordNumberWithLF() throws Exception {\n-        validateRecordNumbers(String.valueOf(LF));\n+        this.validateRecordNumbers(String.valueOf(LF));\n     }\n \n     @Test\n \n     @Test\n     public void testGetRecordNumberWithCRLF() throws Exception {\n-        validateRecordNumbers(CRLF);\n+        this.validateRecordNumbers(CRLF);\n     }\n \n     @Test\n     public void testGetRecordNumberWithCR() throws Exception {\n-        validateRecordNumbers(String.valueOf(CR));\n+        this.validateRecordNumbers(String.valueOf(CR));\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testInvalidFormat() throws Exception {\n-        CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR);\n+        final CSVFormat invalidFormat = CSVFormat.DEFAULT.withDelimiter(CR);\n         new CSVParser((Reader) null, invalidFormat);\n     }\n ", "timestamp": 1375201327, "metainfo": ""}