{"sha": "299fdccfd67319a0231efe82eba424003afb371d", "log": "Fix Checkstyle warnings: Remove trailing white spaces on all lines.", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n      *\n      * @param out\n      *            the output.\n-     * @param charset \n+     * @param charset\n      *            A charset.\n      * @return a printer to an output.\n      * @throws IOException\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n \n     /**\n      * Gets the first end-of-line string encountered.\n-     * \n+     *\n      * @return the first end-of-line string\n-     * @since 1.5  \n+     * @since 1.5\n      */\n     public String getFirstEndOfLine() {\n         return lexer.getFirstEol();\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n     String getFirstEol(){\n         return firstEol;\n     }\n-    \n+\n     Lexer(final CSVFormat format, final ExtendedBufferedReader reader) {\n         this.reader = reader;\n         this.delimiter = format.getDelimiter();\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n     public void testEqualsLeftNoQuoteRightQuote() {\n     \tfinal CSVFormat left = CSVFormat.newFormat(',').withQuote(null);\n     \tfinal CSVFormat right = left.withQuote('#');\n-    \t\n+\n     \tassertNotEquals(left, right);\n     }\n \n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n         final URL url = ClassLoader.getSystemClassLoader().getResource(resource);\n         return new BOMInputStream(url.openStream());\n     }\n-    \n+\n     @Test\n     public void testBackslashEscaping() throws IOException {\n \n             assertEquals(4, records.size());\n         }\n     }\n-    \n+\n     @Test\n     public void testFirstEndOfLineCrLf() throws IOException {\n         final String data = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n             assertEquals(\"\\r\\n\", parser.getFirstEndOfLine());\n         }\n     }\n-    \n+\n     @Test\n     public void testFirstEndOfLineLf() throws IOException {\n         final String data = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n--- a/src/test/java/org/apache/commons/csv/issues/JiraCsv213Test.java\n+++ b/src/test/java/org/apache/commons/csv/issues/JiraCsv213Test.java\n \n /**\n  * Tests https://issues.apache.org/jira/browse/CSV-213\n- * \n+ *\n  * This is normal behavior with the current architecture: The iterator() API presents an object that is backed by data\n  * in the CSVParser as the parser is streaming over the file. The CSVParser is like a forward-only stream. When you\n  * create a new Iterator you are only created a new view on the same position in the parser's stream. For the behavior", "timestamp": 1502486127, "metainfo": ""}