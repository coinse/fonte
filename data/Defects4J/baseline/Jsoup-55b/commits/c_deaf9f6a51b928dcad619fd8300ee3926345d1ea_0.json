{"sha": "deaf9f6a51b928dcad619fd8300ee3926345d1ea", "log": "Added Element.insertChildren  Also tidied up JavaDoc, and returned Node.childNodes to a unmodifiable list.  Fixes #239 (with alternative implementation)", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n     /**\n      * Add a node child node to this element.\n      * \n-     * @param child node to add. Must not already have a parent.\n+     * @param child node to add.\n      * @return this element, so that you can add more child nodes or elements.\n      */\n     public Element appendChild(Node child) {\n         addChildren(child);\n         return this;\n     }\n-    \n+\n     /**\n      * Add a node to the start of this element's children.\n      * \n-     * @param child node to add. Must not already have a parent.\n+     * @param child node to add.\n      * @return this element, so that you can add more child nodes or elements.\n      */\n     public Element prependChild(Node child) {\n         Validate.notNull(child);\n         \n         addChildren(0, child);\n+        return this;\n+    }\n+\n+\n+    /**\n+     * Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the\n+     * right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.\n+     *\n+     * @param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the\n+     * end\n+     * @param children child nodes to insert\n+     * @return this element, for chaining.\n+     */\n+    public Element insertChildren(int index, Collection<? extends Node> children) {\n+        Validate.notNull(children, \"Children collection to be inserted must not be null.\");\n+        int currentSize = childNodeSize();\n+        if (index < 0) index += currentSize +1; // roll around\n+        Validate.isTrue(index >= 0 && index <= currentSize, \"Insert position out of bounds.\");\n+\n+        ArrayList<Node> nodes = new ArrayList<Node>(children);\n+        Node[] nodeArray = nodes.toArray(new Node[nodes.size()]);\n+        addChildren(index, nodeArray);\n         return this;\n     }\n     \n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n      @return list of children. If no children, returns an empty list.\n      */\n     public List<Node> childNodes() {\n-        // actually returns the real list, as this method is hit many times during selection, and so is a GC time-sink\n-        // leaving the documentation as is (warning of unmodifiability) to discourage out-of-API modifications\n-        return childNodes;\n+        return Collections.unmodifiableList(childNodes);\n+    }\n+\n+    /**\n+     * Get the number of child nodes that this node holds.\n+     * @return the number of child nodes that this node holds.\n+     */\n+    public final int childNodeSize() {\n+        return childNodes.size();\n     }\n     \n     protected Node[] childNodesAsArray() {\n-        return childNodes.toArray(new Node[childNodes().size()]);\n+        return childNodes.toArray(new Node[childNodeSize()]);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n                             }\n \n                             Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n-                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n+                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\n                             for (Node childNode : childNodes) {\n                                 adopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n                             }\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n     public Elements(Element... elements) {\n         this(Arrays.asList(elements));\n     }\n-    \n+\n+    /**\n+     * Creates a deep copy of these elements.\n+     * @return a deep copy\n+     */\n     @Override\n \tpublic Elements clone() {\n     \tList<Element> elements = new ArrayList<Element>();\n--- a/src/main/java/org/jsoup/select/NodeTraversor.java\n+++ b/src/main/java/org/jsoup/select/NodeTraversor.java\n         \n         while (node != null) {\n             visitor.head(node, depth);\n-            if (node.childNodes().size() > 0) {\n+            if (node.childNodeSize() > 0) {\n                 node = node.childNode(0);\n                 depth++;\n             } else {\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n \n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.parser.Tag;\n import org.jsoup.select.Elements;\n import org.junit.Test;\n \n import static org.junit.Assert.*;\n \n+import java.util.ArrayList;\n import java.util.List;\n import java.util.Set;\n import java.util.Map;\n             fail(\"Should throw index out of bounds\");\n         } catch (IndexOutOfBoundsException e) {}\n     }\n+\n+    @Test\n+    public void moveByAppend() {\n+        // test for https://github.com/jhy/jsoup/issues/239\n+        // can empty an element and append its children to another element\n+        Document doc = Jsoup.parse(\"<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>\");\n+        Element div1 = doc.select(\"div\").get(0);\n+        Element div2 = doc.select(\"div\").get(1);\n+\n+        assertEquals(4, div1.childNodeSize());\n+        List<Node> children = div1.childNodes();\n+        assertEquals(4, children.size());\n+\n+        div2.insertChildren(0, children);\n+\n+        assertEquals(0, children.size()); // children is backed by div1.childNodes, moved, so should be 0 now\n+        assertEquals(0, div1.childNodeSize());\n+        assertEquals(4, div2.childNodeSize());\n+        assertEquals(\"<div id=\\\"1\\\"></div>\\n<div id=\\\"2\\\">\\n Text \\n <p>One</p> Text \\n <p>Two</p>\\n</div>\",\n+            doc.body().html());\n+    }\n+\n+    @Test\n+    public void insertChildrenArgumentValidation() {\n+        Document doc = Jsoup.parse(\"<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>\");\n+        Element div1 = doc.select(\"div\").get(0);\n+        Element div2 = doc.select(\"div\").get(1);\n+        List<Node> children = div1.childNodes();\n+\n+        try {\n+            div2.insertChildren(6, children);\n+            fail();\n+        } catch (IllegalArgumentException e) {}\n+\n+        try {\n+            div2.insertChildren(-5, children);\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+\n+        try {\n+            div2.insertChildren(0, null);\n+            fail();\n+        } catch (IllegalArgumentException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void insertChildrenAtPosition() {\n+        Document doc = Jsoup.parse(\"<div id=1>Text1 <p>One</p> Text2 <p>Two</p></div><div id=2>Text3 <p>Three</p></div>\");\n+        Element div1 = doc.select(\"div\").get(0);\n+        Elements p1s = div1.select(\"p\");\n+        Element div2 = doc.select(\"div\").get(1);\n+\n+        assertEquals(2, div2.childNodeSize());\n+        div2.insertChildren(-1, p1s);\n+        assertEquals(2, div1.childNodeSize()); // moved two out\n+        assertEquals(4, div2.childNodeSize());\n+        assertEquals(3, p1s.get(1).siblingIndex()); // should be last\n+\n+        List<Node> els = new ArrayList<Node>();\n+        Element el1 = new Element(Tag.valueOf(\"span\"), \"\").text(\"Span1\");\n+        Element el2 = new Element(Tag.valueOf(\"span\"), \"\").text(\"Span2\");\n+        TextNode tn1 = new TextNode(\"Text4\", \"\");\n+        els.add(el1);\n+        els.add(el2);\n+        els.add(tn1);\n+\n+        assertNull(el1.parent());\n+        div2.insertChildren(-2, els);\n+        assertEquals(div2, el1.parent());\n+        assertEquals(7, div2.childNodeSize());\n+        assertEquals(3, el1.siblingIndex());\n+        assertEquals(4, el2.siblingIndex());\n+        assertEquals(5, tn1.siblingIndex());\n+    }\n+\n+    @Test\n+    public void insertChildrenAsCopy() {\n+        Document doc = Jsoup.parse(\"<div id=1>Text <p>One</p> Text <p>Two</p></div><div id=2></div>\");\n+        Element div1 = doc.select(\"div\").get(0);\n+        Element div2 = doc.select(\"div\").get(1);\n+        Elements ps = doc.select(\"p\").clone();\n+        ps.first().text(\"One cloned\");\n+        div2.insertChildren(-1, ps);\n+\n+        assertEquals(4, div1.childNodeSize()); // not moved -- cloned\n+        assertEquals(2, div2.childNodeSize());\n+        assertEquals(\"<div id=\\\"1\\\">Text <p>One</p> Text <p>Two</p></div><div id=\\\"2\\\"><p>One cloned</p><p>Two</p></div>\",\n+            TextUtil.stripNewlines(doc.body().html()));\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n         Element div = doc.getElementById(\"1\");\n         assertEquals(\"<html> <foo><&amp;\", div.text());\n         assertEquals(0, div.children().size());\n-        assertEquals(1, div.childNodes().size()); // no elements, one text node\n+        assertEquals(1, div.childNodeSize()); // no elements, one text node\n     }\n \n     @Test public void handlesInvalidStartTags() {\n--- a/src/test/java/org/jsoup/safety/CleanerTest.java\n+++ b/src/test/java/org/jsoup/safety/CleanerTest.java\n         Document dirtyDoc = Jsoup.parse(dirty);\n         Document cleanDoc = new Cleaner(Whitelist.basic()).clean(dirtyDoc);\n         assertFalse(cleanDoc == null);\n-        assertEquals(0, cleanDoc.body().childNodes().size());\n+        assertEquals(0, cleanDoc.body().childNodeSize());\n     }\n \n     @Test public void cleansInternationalText() {", "timestamp": 1356297434, "metainfo": ""}