{"sha": "4424fe8589b60f2c7ed0a6ddb3958198e779c803", "log": "Merge branch 'master' into speedbird", "commit": "\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n     private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\");\n     static final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\n     private static final int bufferSize = 0x20000; // ~130K.\n+    private static final int UNICODE_BOM = 0xFEFF;\n     private static final char[] mimeBoundaryChars =\n             \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\n     static final int boundaryLength = 32;\n             docData = Charset.forName(charsetName).decode(byteData).toString();\n         }\n         // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n-        if (docData.length() > 0 && docData.charAt(0) == 65279) {\n+        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n             byteData.rewind();\n             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n             docData = docData.substring(1);\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n \n import org.jsoup.helper.Validate;\n \n+import java.util.Arrays;\n import java.util.Locale;\n \n /**\n  CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n  */\n-class CharacterReader {\n+final class CharacterReader {\n     static final char EOF = (char) -1;\n+    private static final int maxCacheLen = 12;\n \n     private final char[] input;\n     private final int length;\n     private int pos = 0;\n     private int mark = 0;\n+    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n \n     CharacterReader(String input) {\n         Validate.notNull(input);\n     String consumeTo(char c) {\n         int offset = nextIndexOf(c);\n         if (offset != -1) {\n-            String consumed = new String(input, pos, offset);\n+            String consumed = cacheString(pos, offset);\n             pos += offset;\n             return consumed;\n         } else {\n     String consumeTo(String seq) {\n         int offset = nextIndexOf(seq);\n         if (offset != -1) {\n-            String consumed = new String(input, pos, offset);\n+            String consumed = cacheString(pos, offset);\n             pos += offset;\n             return consumed;\n         } else {\n     }\n \n     String consumeToAny(final char... chars) {\n-        int start = pos;\n-\n-        OUTER: while (pos < length) {\n-            for (int i = 0; i < chars.length; i++) {\n-                if (input[pos] == chars[i])\n+        final int start = pos;\n+        final int remaining = length;\n+\n+        OUTER: while (pos < remaining) {\n+            for (char c : chars) {\n+                if (input[pos] == c)\n                     break OUTER;\n             }\n             pos++;\n         }\n \n-        return pos > start ? new String(input, start, pos-start) : \"\";\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n+    }\n+\n+    String consumeToAnySorted(final char... chars) {\n+        final int start = pos;\n+        final int remaining = length;\n+        final char[] val = input;\n+\n+        while (pos < remaining) {\n+            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n+                break;\n+            pos++;\n+        }\n+\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n+    }\n+\n+    String consumeData() {\n+        // &, <, null\n+        final int start = pos;\n+        final int remaining = length;\n+        final char[] val = input;\n+\n+        while (pos < remaining) {\n+            final char c = val[pos];\n+            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n+                break;\n+            pos++;\n+        }\n+\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n+    }\n+\n+    String consumeTagName() {\n+        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n+        final int start = pos;\n+        final int remaining = length;\n+        final char[] val = input;\n+\n+        while (pos < remaining) {\n+            final char c = val[pos];\n+            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n+                break;\n+            pos++;\n+        }\n+\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n     }\n \n     String consumeToEnd() {\n-        String data = new String(input, pos, length-pos);\n+        String data = cacheString(pos, length-pos);\n         pos = length;\n         return data;\n     }\n                 break;\n         }\n \n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     String consumeLetterThenDigitSequence() {\n                 break;\n         }\n \n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     String consumeHexSequence() {\n             else\n                 break;\n         }\n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     String consumeDigitSequence() {\n             else\n                 break;\n         }\n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     boolean matches(char c) {\n         return false;\n     }\n \n+    boolean matchesAnySorted(char[] seq) {\n+        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n+    }\n+\n     boolean matchesLetter() {\n         if (isEmpty())\n             return false;\n     public String toString() {\n         return new String(input, pos, length - pos);\n     }\n+\n+    /**\n+     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n+     * <p />\n+     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n+     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n+     * some more duplicates.\n+     */\n+    private String cacheString(final int start, final int count) {\n+        final char[] val = input;\n+        final String[] cache = stringCache;\n+\n+        // limit (no cache):\n+        if (count > maxCacheLen)\n+            return new String(val, start, count);\n+\n+        // calculate hash:\n+        int hash = 0;\n+        int offset = start;\n+        for (int i = 0; i < count; i++) {\n+            hash = 31 * hash + val[offset++];\n+        }\n+\n+        // get from cache\n+        final int index = hash & cache.length - 1;\n+        String cached = cache[index];\n+\n+        if (cached == null) { // miss, add\n+            cached = new String(val, start, count);\n+            cache[index] = cached;\n+        } else { // hashcode hit, check equality\n+            if (rangeEquals(start, count, cached)) {\n+                // hit\n+                return cached;\n+            } else { // hashcode conflict\n+                cached = new String(val, start, count);\n+            }\n+        }\n+        return cached;\n+    }\n+\n+    /**\n+     * Check if the value of the provided range equals the string.\n+     */\n+    boolean rangeEquals(final int start, int count, final String cached) {\n+        if (count == cached.length()) {\n+            char one[] = input;\n+            int i = start;\n+            int j = 0;\n+            while (count-- != 0) {\n+                if (one[i++] != cached.charAt(j++))\n+                    return false;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n import org.jsoup.select.Elements;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n import java.util.List;\n \n /**\n     private Element headElement; // the current head element\n     private FormElement formElement; // the current form element\n     private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n-    private DescendableLinkedList<Element> formattingElements = new DescendableLinkedList<Element>(); // active (open) formatting elements\n+    private ArrayList<Element> formattingElements = new ArrayList<Element>(); // active (open) formatting elements\n     private List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); // chars in table to be shifted out\n \n     private boolean framesetOk = true; // if ok to go into frameset\n \n             root = new Element(Tag.valueOf(\"html\"), baseUri);\n             doc.appendChild(root);\n-            stack.push(root);\n+            stack.add(root);\n             resetInsertionMode();\n \n             // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n     }\n \n     Element pop() {\n-        // todo - dev, remove validation check\n-        if (stack.peekLast().nodeName().equals(\"td\") && !state.name().equals(\"InCell\"))\n-            Validate.isFalse(true, \"pop td not in cell\");\n-        if (stack.peekLast().nodeName().equals(\"html\"))\n-            Validate.isFalse(true, \"popping html!\");\n-        return stack.pollLast();\n+        int size = stack.size();\n+        return stack.remove(size-1);\n     }\n \n     void push(Element element) {\n         stack.add(element);\n     }\n \n-    DescendableLinkedList<Element> getStack() {\n+    ArrayList<Element> getStack() {\n         return stack;\n     }\n \n         return isElementInQueue(stack, el);\n     }\n \n-    private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element) {\n-        Iterator<Element> it = queue.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n+        for (int pos = queue.size() -1; pos >= 0; pos--) {\n+            Element next = queue.get(pos);\n             if (next == element) {\n                 return true;\n             }\n     }\n \n     Element getFromStack(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next.nodeName().equals(elName)) {\n                 return next;\n             }\n     }\n \n     boolean removeFromStack(Element el) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next == el) {\n-                it.remove();\n+                stack.remove(pos);\n                 return true;\n             }\n         }\n     }\n \n     void popStackToClose(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n+            stack.remove(pos);\n+            if (next.nodeName().equals(elName))\n+                break;\n+        }\n+    }\n+\n+    void popStackToClose(String... elNames) {\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n+            stack.remove(pos);\n+            if (StringUtil.in(next.nodeName(), elNames))\n+                break;\n+        }\n+    }\n+\n+    void popStackToBefore(String elName) {\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next.nodeName().equals(elName)) {\n-                it.remove();\n                 break;\n             } else {\n-                it.remove();\n-            }\n-        }\n-    }\n-\n-    void popStackToClose(String... elNames) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (StringUtil.in(next.nodeName(), elNames)) {\n-                it.remove();\n-                break;\n-            } else {\n-                it.remove();\n-            }\n-        }\n-    }\n-\n-    void popStackToBefore(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next.nodeName().equals(elName)) {\n-                break;\n-            } else {\n-                it.remove();\n+                stack.remove(pos);\n             }\n         }\n     }\n     }\n \n     private void clearStackToContext(String... nodeNames) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                 break;\n             else\n-                it.remove();\n+                stack.remove(pos);\n         }\n     }\n \n     Element aboveOnStack(Element el) {\n         assert onStack(el);\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next == el) {\n-                return it.next();\n+                return stack.get(pos-1);\n             }\n         }\n         return null;\n         replaceInQueue(stack, out, in);\n     }\n \n-    private void replaceInQueue(LinkedList<Element> queue, Element out, Element in) {\n+    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n         int i = queue.lastIndexOf(out);\n         Validate.isTrue(i != -1);\n-        queue.remove(i);\n-        queue.add(i, in);\n+        queue.set(i, in);\n     }\n \n     void resetInsertionMode() {\n         boolean last = false;\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element node = it.next();\n-            if (!it.hasNext()) {\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element node = stack.get(pos);\n+            if (pos == 0) {\n                 last = true;\n                 node = contextElement;\n             }\n     }\n \n     private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element el = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element el = stack.get(pos);\n             String elName = el.nodeName();\n             if (StringUtil.in(elName, targetNames))\n                 return true;\n     }\n \n     boolean inSelectScope(String targetName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element el = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element el = stack.get(pos);\n             String elName = el.nodeName();\n             if (elName.equals(targetName))\n                 return true;\n         return StringUtil.in(name, TagSearchSpecial);\n     }\n \n+    Element lastFormattingElement() {\n+        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n+    }\n+\n+    Element removeLastFormattingElement() {\n+        int size = formattingElements.size();\n+        if (size > 0)\n+            return formattingElements.remove(size-1);\n+        else\n+            return null;\n+    }\n+\n     // active formatting elements\n     void pushActiveFormattingElements(Element in) {\n         int numSeen = 0;\n-        Iterator<Element> iter = formattingElements.descendingIterator();\n-        while (iter.hasNext()) {\n-            Element el =  iter.next();\n+        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n+            Element el = formattingElements.get(pos);\n             if (el == null) // marker\n                 break;\n \n                 numSeen++;\n \n             if (numSeen == 3) {\n-                iter.remove();\n+                formattingElements.remove(pos);\n                 break;\n             }\n         }\n     }\n \n     void reconstructFormattingElements() {\n+        Element last = lastFormattingElement();\n+        if (last == null || onStack(last))\n+            return;\n+\n+        Element entry = last;\n         int size = formattingElements.size();\n-        if (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\n-            return;\n-\n-        Element entry = formattingElements.getLast();\n         int pos = size - 1;\n         boolean skip = false;\n         while (true) {\n             newEl.attributes().addAll(entry.attributes());\n \n             // 10. replace entry with new entry\n-            formattingElements.add(pos, newEl);\n-            formattingElements.remove(pos + 1);\n+            formattingElements.set(pos, newEl);\n \n             // 11\n             if (pos == size-1) // if not last entry in list, jump to 7\n \n     void clearFormattingElementsToLastMarker() {\n         while (!formattingElements.isEmpty()) {\n-            Element el = formattingElements.peekLast();\n-            formattingElements.removeLast();\n+            Element el = removeLastFormattingElement();\n             if (el == null)\n                 break;\n         }\n     }\n \n     void removeFromActiveFormattingElements(Element el) {\n-        Iterator<Element> it = formattingElements.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n+            Element next = formattingElements.get(pos);\n             if (next == el) {\n-                it.remove();\n+                formattingElements.remove(pos);\n                 break;\n             }\n         }\n     }\n \n     Element getActiveFormattingElement(String nodeName) {\n-        Iterator<Element> it = formattingElements.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n+            Element next = formattingElements.get(pos);\n             if (next == null) // scope marker\n                 break;\n             else if (next.nodeName().equals(nodeName))\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.*;\n \n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n \n /**\n  * The Tree Builder's current state. Each state embodies the processing for the state, and transitions to other states.\n                     if (name.equals(\"html\")) {\n                         tb.error(this);\n                         // merge attributes onto real html\n-                        Element html = tb.getStack().getFirst();\n+                        Element html = tb.getStack().get(0);\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                             // only in fragment case\n                             return false; // ignore\n                         }\n                     } else if (name.equals(\"frameset\")) {\n                         tb.error(this);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                             // only in fragment case\n                             return false; // ignore\n                                 second.remove();\n                             // pop up to html element\n                             while (stack.size() > 1)\n-                                stack.removeLast();\n+                                stack.remove(stack.size()-1);\n                             tb.insert(startTag);\n                             tb.transition(InFrameset);\n                         }\n                         tb.insertForm(startTag, true);\n                     } else if (name.equals(\"li\")) {\n                         tb.framesetOk(false);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         for (int i = stack.size() - 1; i > 0; i--) {\n                             Element el = stack.get(i);\n                             if (el.nodeName().equals(\"li\")) {\n                         tb.insert(startTag);\n                     } else if (StringUtil.in(name, Constants.DdDt)) {\n                         tb.framesetOk(false);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         for (int i = stack.size() - 1; i > 0; i--) {\n                             Element el = stack.get(i);\n                             if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n                             Element furthestBlock = null;\n                             Element commonAncestor = null;\n                             boolean seenFormattingElement = false;\n-                            LinkedList<Element> stack = tb.getStack();\n+                            ArrayList<Element> stack = tb.getStack();\n                             // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                             // run-aways\n                             final int stackSize = stack.size();\n \n         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n             String name = t.asEndTag().name();\n-            DescendableLinkedList<Element> stack = tb.getStack();\n-            Iterator<Element> it = stack.descendingIterator();\n-            while (it.hasNext()) {\n-                Element node = it.next();\n+            ArrayList<Element> stack = tb.getStack();\n+            for (int pos = stack.size() -1; pos >= 0; pos--) {\n+                Element node = stack.get(pos);\n                 if (node.nodeName().equals(name)) {\n                     tb.generateImpliedEndTags(name);\n                     if (!name.equals(tb.currentElement().nodeName()))\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n         return this.getClass().getSimpleName();\n     }\n \n-    static class Doctype extends Token {\n+    static final class Doctype extends Token {\n         final StringBuilder name = new StringBuilder();\n         final StringBuilder publicIdentifier = new StringBuilder();\n         final StringBuilder systemIdentifier = new StringBuilder();\n         boolean selfClosing = false;\n         Attributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n \n-        void newAttribute() {\n+        final void newAttribute() {\n             if (attributes == null)\n                 attributes = new Attributes();\n \n                 pendingAttributeValue.delete(0, pendingAttributeValue.length());\n         }\n \n-        void finaliseTag() {\n+        final void finaliseTag() {\n             // finalises for emit\n             if (pendingAttributeName != null) {\n                 // todo: check if attribute name exists; if so, drop and error\n             }\n         }\n \n-        String name() {\n+        final String name() {\n             Validate.isFalse(tagName == null || tagName.length() == 0);\n             return tagName;\n         }\n \n-        Tag name(String name) {\n+        final Tag name(String name) {\n             tagName = name;\n             return this;\n         }\n \n-        boolean isSelfClosing() {\n+        final boolean isSelfClosing() {\n             return selfClosing;\n         }\n \n         @SuppressWarnings({\"TypeMayBeWeakened\"})\n-        Attributes getAttributes() {\n+        final Attributes getAttributes() {\n             return attributes;\n         }\n \n         // these appenders are rarely hit in not null state-- caused by null chars.\n-        void appendTagName(String append) {\n+        final void appendTagName(String append) {\n             tagName = tagName == null ? append : tagName.concat(append);\n         }\n \n-        void appendTagName(char append) {\n+        final void appendTagName(char append) {\n             appendTagName(String.valueOf(append));\n         }\n \n-        void appendAttributeName(String append) {\n+        final void appendAttributeName(String append) {\n             pendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n         }\n \n-        void appendAttributeName(char append) {\n+        final void appendAttributeName(char append) {\n             appendAttributeName(String.valueOf(append));\n         }\n \n-        void appendAttributeValue(String append) {\n+        final void appendAttributeValue(String append) {\n             ensureAttributeValue();\n             pendingAttributeValue.append(append);\n         }\n \n-        void appendAttributeValue(char append) {\n+        final void appendAttributeValue(char append) {\n             ensureAttributeValue();\n             pendingAttributeValue.append(append);\n         }\n \n-        void appendAttributeValue(char[] append) {\n+        final void appendAttributeValue(char[] append) {\n             ensureAttributeValue();\n             pendingAttributeValue.append(append);\n         }\n \n-        private final void ensureAttributeValue() {\n+        private void ensureAttributeValue() {\n             if (pendingAttributeValue == null)\n                 pendingAttributeValue = new StringBuilder();\n         }\n     }\n \n-    static class StartTag extends Tag {\n+    final static class StartTag extends Tag {\n         StartTag() {\n             super();\n             attributes = new Attributes();\n         }\n     }\n \n-    static class EndTag extends Tag{\n+    final static class EndTag extends Tag{\n         EndTag() {\n             super();\n             type = TokenType.EndTag;\n         }\n     }\n \n-    static class Comment extends Token {\n+    final static class Comment extends Token {\n         final StringBuilder data = new StringBuilder();\n         boolean bogus = false;\n \n         }\n     }\n \n-    static class Character extends Token {\n+    final static class Character extends Token {\n         private final String data;\n \n         Character(String data) {\n         }\n     }\n \n-    static class EOF extends Token {\n+    final static class EOF extends Token {\n         EOF() {\n             type = Token.TokenType.EOF;\n         }\n     }\n \n-    boolean isDoctype() {\n+    final boolean isDoctype() {\n         return type == TokenType.Doctype;\n     }\n \n-    Doctype asDoctype() {\n+    final Doctype asDoctype() {\n         return (Doctype) this;\n     }\n \n-    boolean isStartTag() {\n+    final boolean isStartTag() {\n         return type == TokenType.StartTag;\n     }\n \n-    StartTag asStartTag() {\n+    final StartTag asStartTag() {\n         return (StartTag) this;\n     }\n \n-    boolean isEndTag() {\n+    final boolean isEndTag() {\n         return type == TokenType.EndTag;\n     }\n \n-    EndTag asEndTag() {\n+    final EndTag asEndTag() {\n         return (EndTag) this;\n     }\n \n-    boolean isComment() {\n+    final boolean isComment() {\n         return type == TokenType.Comment;\n     }\n \n-    Comment asComment() {\n+    final Comment asComment() {\n         return (Comment) this;\n     }\n \n-    boolean isCharacter() {\n+    final boolean isCharacter() {\n         return type == TokenType.Character;\n     }\n \n-    Character asCharacter() {\n+    final Character asCharacter() {\n         return (Character) this;\n     }\n \n-    boolean isEOF() {\n+    final boolean isEOF() {\n         return type == TokenType.EOF;\n     }\n \n-    enum TokenType {\n+    static enum TokenType {\n         Doctype,\n         StartTag,\n         EndTag,\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Entities;\n \n+import java.util.Arrays;\n \n /**\n  * Readers the input stream into tokens.\n  */\n-class Tokeniser {\n+final class Tokeniser {\n     static final char replacementChar = '\\uFFFD'; // replaces null character\n+    private static final char[] notCharRefCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '<', '&'};\n+\n+    static {\n+        Arrays.sort(notCharRefCharsSorted);\n+    }\n \n     private CharacterReader reader; // html input\n     private ParseErrorList errors; // errors found while tokenising\n     private TokeniserState state = TokeniserState.Data; // current tokenisation state\n     private Token emitPending; // the token we are about to emit on next read\n     private boolean isEmitPending = false;\n-    private StringBuilder charBuffer = new StringBuilder(); // buffers characters to output as one token\n+    private String charsString = null; // characters pending an emit. Will fall to charsBuilder if more than one\n+    private StringBuilder charsBuilder = new StringBuilder(1024); // buffers characters to output as one token, if more than one emit per read\n     StringBuilder dataBuffer; // buffers data looking for </script>\n \n     Token.Tag tagPending; // tag we are building up\n             state.read(this, reader);\n \n         // if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\n-        if (charBuffer.length() > 0) {\n-            String str = charBuffer.toString();\n-            charBuffer.delete(0, charBuffer.length());\n+        if (charsBuilder.length() > 0) {\n+            String str = charsBuilder.toString();\n+            charsBuilder.delete(0, charsBuilder.length());\n+            charsString = null;\n             return new Token.Character(str);\n+        } else if (charsString != null) {\n+            Token token = new Token.Character(charsString);\n+            charsString = null;\n+            return token;\n         } else {\n             isEmitPending = false;\n             return emitPending;\n         }\n     }\n \n-    void emit(String str) {\n+    void emit(final String str) {\n         // buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n         // does not set isEmitPending; read checks that\n-        charBuffer.append(str);\n+        if (charsString == null) {\n+            charsString = str;\n+        }\n+        else {\n+            if (charsBuilder.length() == 0) { // switching to string builder as more than one emit before read\n+                charsBuilder.append(charsString);\n+            }\n+            charsBuilder.append(str);\n+        }\n     }\n \n     void emit(char[] chars) {\n-        charBuffer.append(chars);\n+        emit(String.valueOf(chars));\n     }\n \n     void emit(char c) {\n-        charBuffer.append(c);\n+        emit(String.valueOf(c));\n     }\n \n     TokeniserState getState() {\n             return null;\n         if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n             return null;\n-        if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n+        if (reader.matchesAnySorted(notCharRefCharsSorted))\n             return null;\n \n         reader.mark();\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n package org.jsoup.parser;\n+\n+import java.util.Arrays;\n \n /**\n  * States and transition activations for the Tokeniser.\n                     t.emit(new Token.EOF());\n                     break;\n                 default:\n-                    String data = r.consumeToAny('&', '<', nullChar);\n+                    String data = r.consumeData();\n                     t.emit(data);\n                     break;\n             }\n         // from < or </ in data, will have start or end tag pending\n         void read(Tokeniser t, CharacterReader r) {\n             // previous TagOpen state did NOT consume, will have a letter char in current\n-            String tagName = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar).toLowerCase();\n+            //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n+            String tagName = r.consumeTagName().toLowerCase();\n             t.tagPending.appendTagName(tagName);\n \n             switch (r.consume()) {\n     AttributeName {\n         // from before attribute name\n         void read(Tokeniser t, CharacterReader r) {\n-            String name = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<');\n+            String name = r.consumeToAnySorted(attributeNameCharsSorted);\n             t.tagPending.appendAttributeName(name.toLowerCase());\n \n             char c = r.consume();\n     },\n     AttributeValue_doubleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAny('\"', '&', nullChar);\n+            String value = r.consumeToAnySorted(attributeDoubleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n \n     },\n     AttributeValue_singleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAny('\\'', '&', nullChar);\n+            String value = r.consumeToAnySorted(attributeSingleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n \n \n     abstract void read(Tokeniser t, CharacterReader r);\n \n-    private static final char nullChar = '\\u0000';\n+    static final char nullChar = '\\u0000';\n+    private static final char[] attributeSingleValueCharsSorted = new char[]{'\\'', '&', nullChar};\n+    private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar};\n+    private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'};\n+\n     private static final char replacementChar = Tokeniser.replacementChar;\n     private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n     private static final char eof = CharacterReader.EOF;\n+\n+    static {\n+        Arrays.sort(attributeSingleValueCharsSorted);\n+        Arrays.sort(attributeDoubleValueCharsSorted);\n+        Arrays.sort(attributeNameCharsSorted);\n+    }\n \n     /**\n      * Handles RawtextEndTagName, ScriptDataEndTagName, and ScriptDataEscapedEndTagName. Same body impl, just\n      * different else exit transitions.\n      */\n-    private static final void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n+    private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n         if (r.matchesLetter()) {\n             String name = r.consumeLetterSequence();\n             t.tagPending.appendTagName(name.toLowerCase());\n         }\n     }\n \n-    private static final void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n+    private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n         if (r.matchesLetter()) {\n             String name = r.consumeLetterSequence();\n             t.dataBuffer.append(name.toLowerCase());\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n \n+import java.util.ArrayList;\n \n /**\n  * @author Jonathan Hedley\n     CharacterReader reader;\n     Tokeniser tokeniser;\n     protected Document doc; // current doc we are building into\n-    protected DescendableLinkedList<Element> stack; // the stack of open elements\n+    protected ArrayList<Element> stack; // the stack of open elements\n     protected String baseUri; // current base uri, for creating new elements\n     protected Token currentToken; // currentToken is used only for error tracking.\n     protected ParseErrorList errors; // null when not tracking errors\n         reader = new CharacterReader(input);\n         this.errors = errors;\n         tokeniser = new Tokeniser(reader, errors);\n-        stack = new DescendableLinkedList<Element>();\n+        stack = new ArrayList<Element>(32);\n         this.baseUri = baseUri;\n     }\n \n     protected abstract boolean process(Token token);\n \n     protected Element currentElement() {\n-        return stack.getLast();\n+        int size = stack.size();\n+        return size > 0 ? stack.get(size-1) : null;\n     }\n }\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n \n-import java.util.Iterator;\n import java.util.List;\n \n /**\n         String elName = endTag.name();\n         Element firstFound = null;\n \n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next.nodeName().equals(elName)) {\n                 firstFound = next;\n                 break;\n         if (firstFound == null)\n             return; // not found, skip\n \n-        it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next == firstFound) {\n-                it.remove();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n+            stack.remove(pos);\n+            if (next == firstFound)\n                 break;\n-            } else {\n-                it.remove();\n-            }\n         }\n     }\n \n--- a/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n+++ b/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n         assertFalse(r.matchesAny(scan));\n     }\n \n+    @Test public void cachesStrings() {\n+        CharacterReader r = new CharacterReader(\"Check\\tCheck\\tCheck\\tCHOKE\\tA string that is longer than 16 chars\");\n+        String one = r.consumeTo('\\t');\n+        r.consume();\n+        String two = r.consumeTo('\\t');\n+        r.consume();\n+        String three = r.consumeTo('\\t');\n+        r.consume();\n+        String four = r.consumeTo('\\t');\n+        r.consume();\n+        String five = r.consumeTo('\\t');\n+\n+        assertEquals(\"Check\", one);\n+        assertEquals(\"Check\", two);\n+        assertEquals(\"Check\", three);\n+        assertEquals(\"CHOKE\", four);\n+        assertTrue(one == two);\n+        assertTrue(two == three);\n+        assertTrue(three != four);\n+        assertTrue(four != five);\n+        assertEquals(five, \"A string that is longer than 16 chars\");\n+    }\n+\n+    @Test\n+    public void rangeEquals() {\n+        CharacterReader r = new CharacterReader(\"Check\\tCheck\\tCheck\\tCHOKE\");\n+        assertTrue(r.rangeEquals(0, 5, \"Check\"));\n+        assertFalse(r.rangeEquals(0, 5, \"CHOKE\"));\n+        assertFalse(r.rangeEquals(0, 5, \"Chec\"));\n+\n+        assertTrue(r.rangeEquals(6, 5, \"Check\"));\n+        assertFalse(r.rangeEquals(6, 5, \"Chuck\"));\n+\n+        assertTrue(r.rangeEquals(12, 5, \"Check\"));\n+        assertFalse(r.rangeEquals(12, 5, \"Cheeky\"));\n+\n+        assertTrue(r.rangeEquals(18, 5, \"CHOKE\"));\n+        assertFalse(r.rangeEquals(18, 5, \"CHIKE\"));\n+    }\n+\n+\n }", "timestamp": 1414460737, "metainfo": ""}