{"sha": "03336ea9dd5d2aef2e31fe5e6402a04242f4d9f8", "log": "Pulled string matching stuff out of Parser ad into TokenQueue, for reuse in selector parser. Added som texts and corrected behaviour of parser.", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n     public Element getBody() {\n         return body;\n     }\n+\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    public void setTitle(String title) {\n+        this.title = title;\n+    }\n }\n \n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n public class Parser {\n     private static String SQ = \"'\";\n     private static String DQ = \"\\\"\";\n+\n     private static Tag htmlTag = Tag.valueOf(\"html\");\n     private static Tag headTag = Tag.valueOf(\"head\");\n     private static Tag bodyTag = Tag.valueOf(\"body\");\n+    private static Tag titleTag = Tag.valueOf(\"title\");\n \n     private LinkedList<Element> stack;\n-    private LinkedList<Character> queue;\n+    private TokenQueue tq;\n     private Document doc;\n \n     public Parser(String html) {\n         Validate.notNull(html);\n \n-        this.stack = new LinkedList<Element>();\n-        this.queue = new LinkedList<Character>();\n-        char[] chars = html.toCharArray();\n-        for (char c : chars) {\n-            queue.add(c);\n-        }\n+        stack = new LinkedList<Element>();\n+        tq = new TokenQueue(html);\n \n         doc = new Document();\n         stack.add(doc);\n     }\n \n     public Document parse() {\n-        while (!queue.isEmpty()) {\n-            if (matches(\"<!--\")) {\n+        while (!tq.isEmpty()) {\n+            if (tq.matches(\"<!--\")) {\n                 parseComment();\n-            } else if (matches(\"<?\") || matches(\"<!\")) {\n+            } else if (tq.matches(\"<?\") || tq.matches(\"<!\")) {\n                 parseXmlDecl();\n-            } else if (matches(\"</\")) {\n+            } else if (tq.matches(\"</\")) {\n                 parseEndTag();\n-            } else if (matches(\"<\")) {\n+            } else if (tq.matches(\"<\")) {\n                 parseStartTag();\n             } else {\n-                parseText();\n+                parseTextNode();\n             }\n         }\n         return doc;\n     }\n \n     private void parseComment() {\n-        consume(\"<!--\");\n-        String data = chompTo(\"->\");\n+        tq.consume(\"<!--\");\n+        String data = tq.chompTo(\"->\");\n \n         if (data.endsWith(\"-\")) // i.e. was -->\n             data = data.substring(0, data.length()-1);\n     }\n \n     private void parseXmlDecl() {\n-        consume(\"<\"); consume(); // <? or <!, from initial match.\n-        String data = chompTo(\">\");\n+        tq.consume(\"<\"); tq.consume(); // <? or <!, from initial match.\n+        String data = tq.chompTo(\">\");\n \n         XmlDeclaration decl = new XmlDeclaration(data);\n         last().addChild(decl);\n     }\n \n     private void parseEndTag() {\n-        consume(\"</\");\n-        String tagName = consumeWord();\n-        chompTo(\">\");\n+        tq.consume(\"</\");\n+        String tagName = tq.consumeWord();\n+        tq.chompTo(\">\");\n \n         if (!tagName.isEmpty()) {\n             Tag tag = Tag.valueOf(tagName);\n-            popStackToClose(tag);\n+            Element closed = popStackToClose(tag);\n+\n+            if (closed != null && closed.getTag().equals(titleTag))\n+                doc.setTitle(closed.text());\n         }\n     }\n \n     private void parseStartTag() {\n-        consume(\"<\");\n+        tq.consume(\"<\");\n         Attributes attributes = new Attributes();\n \n-        String tagName = consumeWord();\n-        while (!matches(\"/>\") && !matches(\">\")) {\n+        String tagName = tq.consumeWord();\n+        while (!tq.matches(\"<\") && !tq.matches(\"/>\") && !tq.matches(\">\") && !tq.isEmpty()) {\n             Attribute attribute = parseAttribute();\n             if (attribute != null)\n                 attributes.put(attribute);\n         Element child = new Element(startTag);\n \n         boolean emptyTag;\n-        if (matches(\"/>\")) { // empty tag, don't add to stack\n-            consume(\"/>\");\n+        if (tq.matchChomp(\"/>\")) { // empty tag, don't add to stack\n             emptyTag = true;\n         } else {\n-            consume(\">\");\n+            tq.matchChomp(\">\"); // safe because checked above (or ran out of data)\n             emptyTag = false;\n         }\n \n     }\n \n     private Attribute parseAttribute() {\n-        consumeWhitespace();\n-        String key = consumeWord();\n+        tq.consumeWhitespace();\n+        String key = tq.consumeWord();\n         String value = \"\";\n-        consumeWhitespace();\n-        if (matches(\"=\")) {\n-            consume(\"=\");\n-            consumeWhitespace();\n-\n-            if (matches(SQ)) {\n-                consume(SQ);\n-                value = chompTo(SQ);\n-            } else if (matches(DQ)) {\n-                consume(DQ);\n-                value = chompTo(DQ);\n+        tq.consumeWhitespace();\n+        if (tq.matchChomp(\"=\")) {\n+            tq.consumeWhitespace();\n+\n+            if (tq.matchChomp(SQ)) {\n+                value = tq.chompTo(SQ);\n+            } else if (tq.matchChomp(DQ)) {\n+                value = tq.chompTo(DQ);\n             } else {\n                 StringBuilder valueAccum = new StringBuilder();\n-                while (!matches(\"/>\") && !matches(\">\") && !Character.isWhitespace(queue.peekFirst())) {\n-                    valueAccum.append(consume());\n+                // no ' or \" to look for, so scan to end tag or space (or end of stream)\n+                while (!tq.matches(\"<\") && !tq.matches(\"/>\") && !tq.matches(\">\") && !Character.isWhitespace(tq.peek()) && !tq.isEmpty()) {\n+                    valueAccum.append(tq.consume());\n                 }\n                 value = valueAccum.toString();\n             }\n-            consumeWhitespace();\n+            tq.consumeWhitespace();\n         }\n         if (!key.isEmpty())\n             return new Attribute(key, value);\n         else {\n-            consume(); // unknown char, keep popping so not get stuck\n+            tq.consume(); // unknown char, keep popping so not get stuck\n             return null;\n         }\n     }\n \n-    private void parseText() {\n+    private void parseTextNode() {\n         // TODO: work out whitespace requirements (between blocks, between inlines)\n         StringBuilder textAccum = new StringBuilder();\n-        while (!matches(\"<\")) {\n-            textAccum.append(consume());\n+        while (!tq.matches(\"<\") && !tq.isEmpty()) { // scan to next tag\n+            textAccum.append(tq.consume());\n         }\n         TextNode textNode = new TextNode(textAccum.toString());\n         last().addChild(textNode);\n-    }\n-\n-    /**\n-     * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.\n-     * @param seq String to end on (and not include in return, but leave on queue)\n-     * @return The matched data consumed from queue.\n-     */\n-    private String consumeTo(String seq) {\n-        StringBuilder accum = new StringBuilder();\n-        while (!queue.isEmpty() && !matches(seq))\n-            accum.append(consume());\n-\n-        return accum.toString();\n-    }\n-\n-    /**\n-     * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).\n-     * @param seq String to match up to, and not include in return, and to pull off queue\n-     * @return Data matched from queue.\n-     */\n-    private String chompTo(String seq) {\n-        String data = consumeTo(seq);\n-        consume(seq);\n-        return data;\n-    }\n-\n-    /**\n-     * Consume one character off queue.\n-     * @return first character on queue.\n-     */\n-    private Character consume() {\n-        return queue.removeFirst();\n-    }\n-\n-    private void consume(String seq) {\n-        int len = seq.length();\n-        if (len > queue.size())\n-            throw new IllegalStateException(\"Queue not long enough to consume sequence\");\n-        char[] seqChars = seq.toCharArray();\n-        for (int i = 0; i < len; i++) {\n-            Character qChar = consume();\n-            if (!qChar.equals(seqChars[i]))\n-                throw new IllegalStateException(\"Queue did not match expected sequence\");\n-        }\n-    }\n-\n-    private void consumeWhitespace() {\n-        while (Character.isWhitespace(queue.peekFirst())) {\n-            consume();\n-        }\n-    }\n-\n-    private String consumeWord() {\n-        StringBuilder wordAccum = new StringBuilder();\n-        while (Character.isLetterOrDigit(queue.peekFirst())) {\n-            wordAccum.append(queue.removeFirst());\n-        }\n-        return wordAccum.toString();\n-    }\n-\n-    private boolean matches(String seq) {\n-        int len = seq.length();\n-        if (len > queue.size())\n-            return false;\n-        List<Character> chars = queue.subList(0, len);\n-        char[] seqChars = seq.toCharArray();\n-        for (int i = 0; i < len; i++) {\n-            if (!chars.get(i).equals(seqChars[i]))\n-                return false;\n-        }\n-        return true;\n     }\n \n     private Element popStackToSuitableContainer(Tag tag) {\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n+package org.jsoup.parser;\n+\n+import org.apache.commons.lang.Validate;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * A character queue with parsing helpers.\n+ *\n+ * @author Jonathan Hedley\n+ */\n+class TokenQueue {\n+    private LinkedList<Character> queue;\n+\n+    TokenQueue(String data) {\n+        Validate.notNull(data);\n+\n+        queue = new LinkedList<Character>();\n+        char[] chars = data.toCharArray();\n+        for (char c : chars) {\n+            queue.add(c);\n+        }\n+    }\n+\n+    /**\n+     * Is the queue empty?\n+     * @return true if no data left in queue.\n+     */\n+    boolean isEmpty() {\n+        return queue.isEmpty();\n+    }\n+\n+    /**\n+     * Retrieves but does not remove the first characater from the queue.\n+     * @return First character, or null if empty.\n+     */\n+    Character peek() {\n+        return queue.peek();\n+    }\n+\n+    /**\n+     * Tests if the next characters on the queue match the sequence.\n+     * @param seq String to check queue for.\n+     * @return true if the next characters match.\n+     */\n+    boolean matches(String seq) {\n+        int len = seq.length();\n+        if (len > queue.size())\n+            return false;\n+        List<Character> chars = queue.subList(0, len);\n+        char[] seqChars = seq.toCharArray();\n+        for (int i = 0; i < len; i++) {\n+            if (!chars.get(i).equals(seqChars[i]))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Tests if the queue matches the sequence (as with match), and if they do, removes the matched string from the\n+     * queue.\n+     * @param seq String to search for, and if found, remove from queue.\n+     * @return true if found and removed, false if not found.\n+     */\n+    boolean matchChomp(String seq) {\n+        if (matches(seq)) {\n+            consume(seq);\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Consume one character off queue.\n+     * @return first character on queue.\n+     */\n+    Character consume() {\n+        return queue.removeFirst();\n+    }\n+\n+    /**\n+     * Consumes the supplied sequence of the queue. If the queue does not start with the supplied sequence, will\n+     * throw an illegal state exception -- but you should be running match() against that condition.\n+     * @param seq sequence to remove from head of queue.\n+     */\n+    void consume(String seq) {\n+        int len = seq.length();\n+        if (len > queue.size())\n+            throw new IllegalStateException(\"Queue not long enough to consume sequence\");\n+        char[] seqChars = seq.toCharArray();\n+        for (int i = 0; i < len; i++) {\n+            Character qChar = consume();\n+            if (!qChar.equals(seqChars[i]))\n+                throw new IllegalStateException(\"Queue did not match expected sequence\");\n+        }\n+    }\n+\n+    /**\n+     * Pulls a string off the queue, up to but exclusive of the match sequence, or to the queue running out.\n+     * @param seq String to end on (and not include in return, but leave on queue)\n+     * @return The matched data consumed from queue.\n+     */\n+    String consumeTo(String seq) {\n+        StringBuilder accum = new StringBuilder();\n+        while (!queue.isEmpty() && !matches(seq))\n+            accum.append(consume());\n+\n+        return accum.toString();\n+    }\n+\n+    /**\n+     * Pulls a string off the queue (like consumeTo), and then pulls off the matched string (but does not return it).\n+     * <p>\n+     * If the queue runs out of characters before finding the seq, will return as much as it can (and queue will go\n+     * isEmpty() == true).\n+     * @param seq String to match up to, and not include in return, and to pull off queue\n+     * @return Data matched from queue.\n+     */\n+    String chompTo(String seq) {\n+        String data = consumeTo(seq);\n+        matchChomp(seq);\n+        return data;\n+    }\n+\n+    /**\n+     * Pulls the next run of whitespace characters of the queue.\n+     */\n+    void consumeWhitespace() {\n+        while (!queue.isEmpty() && Character.isWhitespace(queue.peekFirst())) {\n+            consume();\n+        }\n+    }\n+\n+    /**\n+     * Retrieves the next run of word type (letter or digit) off the queue.\n+     * @return String of word characters from queue, or empty string if none.\n+     */\n+    String consumeWord() {\n+        StringBuilder wordAccum = new StringBuilder();\n+        while (!queue.isEmpty() && Character.isLetterOrDigit(queue.peekFirst())) {\n+            wordAccum.append(queue.removeFirst());\n+        }\n+        return wordAccum.toString();\n+    }\n+}\n--- a/src/test/java/org/jsoup/parser/AttributeParseTest.java\n+++ b/src/test/java/org/jsoup/parser/AttributeParseTest.java\n public class AttributeParseTest {\n \n     @Test public void parsesRoughAttributeString() {\n-        String html = \"<a id=\\\"123\\\" class=\\\"baz = 'bar'\\\" style = 'border: 2px'qux zim foo = 12 mux.=18 />\";\n+        String html = \"<a id=\\\"123\\\" class=\\\"baz = 'bar'\\\" style = 'border: 2px'qux zim foo = 12 mux=18 />\";\n         // should be: <id=123>, <class=baz = 'bar'>, <qux=>, <zim=>, <foo=12>, <mux.=18>\n \n         Element el = Jsoup.parse(html).getElementsByTag(\"a\").get(0);\n         assertEquals(\"\", attr.get(\"qux\"));\n         assertEquals(\"\", attr.get(\"zim\"));\n         assertEquals(\"12\", attr.get(\"foo\"));\n-        assertEquals(\"18\", attr.get(\"mux.\"));\n+        assertEquals(\"18\", attr.get(\"mux\"));\n     }\n \n     @Test public void parsesEmptyString() {\n--- a/src/test/java/org/jsoup/parser/ParserTest.java\n+++ b/src/test/java/org/jsoup/parser/ParserTest.java\n  @author Jonathan Hedley, jonathan@hedley.net */\n public class ParserTest {\n \n-    @Test public void testParsesSimpleDocument() {\n+    @Test public void parsesSimpleDocument() {\n         String html = \"<html><head><title>First!</title></head><body><p>First post! <img src=\\\"foo.png\\\" /></p></body></html>\";\n         Document doc = Jsoup.parse(html);\n         // need a better way to verify these:\n         assertEquals(\"img\", img.tagName());\n     }\n \n-    @Test public void testParsesRoughAttributes() {\n+    @Test public void parsesRoughAttributes() {\n         String html = \"<html><head><title>First!</title></head><body><p class=\\\"foo > bar\\\">First post! <img src=\\\"foo.png\\\" /></p></body></html>\";\n         Document doc = Jsoup.parse(html);\n \n         assertEquals(\"foo > bar\", p.attr(\"class\"));\n     }\n \n-    @Test public void testParsesComments() {\n+    @Test public void parsesComments() {\n         String html = \"<html><head></head><body><!-- <table><tr><td></table> --><p>Hello</p></body></html>\";\n         Document doc = Jsoup.parse(html);\n         \n         TextNode text = (TextNode) p.childNode(0);\n         assertEquals(\"Hello\", text.getWholeText());\n     }\n+\n+    @Test public void parsesUnterminatedComments() {\n+        String html = \"<p>Hello<!-- <tr><td>\";\n+        Document doc = Jsoup.parse(html);\n+        Element p = doc.getElementsByTag(\"p\").get(0);\n+        assertEquals(\"Hello\", p.text());\n+        TextNode text = (TextNode) p.childNode(0);\n+        assertEquals(\"Hello\", text.getWholeText());\n+        Comment comment = (Comment) p.childNode(1);\n+        assertEquals(\" <tr><td>\", comment.getData());\n+    }\n+\n+    @Test public void parsesUnterminatedTag() {\n+        String h1 = \"<p\";\n+        Document doc = Jsoup.parse(h1);\n+        assertEquals(1, doc.getElementsByTag(\"p\").size());\n+\n+        String h2 = \"<div id=1<p id='2'\";\n+        doc = Jsoup.parse(h2);\n+        Element d = doc.getElementById(\"1\");\n+        assertEquals(1, d.children().size());\n+        Element p = doc.getElementById(\"2\");\n+        assertNotNull(p);\n+    }\n+\n+    @Test public void parsesUnterminatedAttribute() {\n+        String h1 = \"<p id=\\\"foo\";\n+        Document doc = Jsoup.parse(h1);\n+        Element p = doc.getElementById(\"foo\");\n+        assertNotNull(p);\n+        assertEquals(\"p\", p.tagName());\n+    }\n+\n+    @Test public void createsDocumentStructure() {\n+        String html = \"<meta name=keywords /><link rel=stylesheet /><title>jsoup</title><p>Hello world</p>\";\n+        Document doc = Jsoup.parse(html);\n+        Element head = doc.getHead();\n+        Element body = doc.getBody();\n+\n+        assertEquals(2, doc.children().size());\n+        assertEquals(3, head.children().size());\n+        assertEquals(1, body.children().size());\n+\n+        assertEquals(\"keywords\", head.getElementsByTag(\"meta\").get(0).attr(\"name\"));\n+        assertEquals(0, body.getElementsByTag(\"meta\").size());\n+        assertEquals(\"jsoup\", doc.getTitle());\n+        assertEquals(\"Hello world\", body.text());\n+        assertEquals(\"Hello world\", body.children().get(0).text());\n+    }\n+\n+\n }", "timestamp": 1309605101, "metainfo": ""}