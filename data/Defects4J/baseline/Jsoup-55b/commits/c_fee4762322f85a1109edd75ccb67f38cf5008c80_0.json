{"sha": "fee4762322f85a1109edd75ccb67f38cf5008c80", "log": "Merge remote-tracking branch 'upstream/master'  Conflicts: \tsrc/main/java/org/jsoup/helper/HttpConnection.java", "commit": "\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n      * GET and POST http methods.\n      */\n     public enum Method {\n-        GET, POST\n+        GET(false), POST(true), PUT(true), DELETE(false), PATCH(true);\n+\n+        private final boolean hasBody;\n+\n+        private Method(boolean hasBody) {\n+            this.hasBody = hasBody;\n+        }\n+\n+        /**\n+         * Check if this HTTP method has/needs a request body\n+         * @return if body needed\n+         */\n+        public final boolean hasBody() {\n+            return hasBody;\n+        }\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n+++ b/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n import org.jsoup.nodes.TextNode;\n+import org.jsoup.select.Elements;\n import org.jsoup.select.NodeTraversor;\n import org.jsoup.select.NodeVisitor;\n \n  * scrape.\n  * <p/>\n  * Note that this is a fairly simplistic formatter -- for real world use you'll want to embrace and extend.\n- *\n+ * <p/>\n+ * To invoke from the command line, assuming you've downloaded the jsoup jar to your current directory:<br/>\n+ * <code>java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]</code><br/>\n+ * where <i>url</i> is the URL to fetch, and <i>selector</i> is an optional CSS selector.\n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n public class HtmlToPlainText {\n+    private static final String userAgent = \"Mozilla/5.0 (jsoup)\";\n+    private static final int timeout = 5 * 1000;\n+\n     public static void main(String... args) throws IOException {\n-        Validate.isTrue(args.length == 1, \"usage: supply url to fetch\");\n-        String url = args[0];\n+        Validate.isTrue(args.length == 1 || args.length == 2, \"usage: java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]\");\n+        final String url = args[0];\n+        final String selector = args.length == 2 ? args[1] : null;\n \n         // fetch the specified URL and parse to a HTML DOM\n-        Document doc = Jsoup.connect(url).get();\n+        Document doc = Jsoup.connect(url).userAgent(userAgent).timeout(timeout).get();\n \n         HtmlToPlainText formatter = new HtmlToPlainText();\n-        String plainText = formatter.getPlainText(doc);\n-        System.out.println(plainText);\n+\n+        if (selector != null) {\n+            Elements elements = doc.select(selector); // get each element that matches the CSS selector\n+            for (Element element : elements) {\n+                String plainText = formatter.getPlainText(element); // format that element to plain text\n+                System.out.println(plainText);\n+            }\n+        } else { // format the whole doc\n+            String plainText = formatter.getPlainText(doc);\n+            System.out.println(plainText);\n+        }\n     }\n \n     /**\n                 append(((TextNode) node).text()); // TextNodes carry all user-readable text in the DOM.\n             else if (name.equals(\"li\"))\n                 append(\"\\n * \");\n+            else if (name.equals(\"dt\"))\n+                append(\"  \");\n+            else if (StringUtil.in(name, \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"tr\"))\n+                append(\"\\n\");\n         }\n \n         // hit when all of the node's children (if any) have been visited\n         public void tail(Node node, int depth) {\n             String name = node.nodeName();\n-            if (name.equals(\"br\"))\n+            if (StringUtil.in(name, \"br\", \"dd\", \"dt\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\"))\n                 append(\"\\n\");\n-            else if (StringUtil.in(name, \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\"))\n-                append(\"\\n\\n\");\n             else if (name.equals(\"a\"))\n                 append(String.format(\" <%s>\", node.absUrl(\"href\")));\n         }\n             }\n         }\n \n+        @Override\n         public String toString() {\n             return accum.toString();\n         }\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n     private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\");\n     static final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\n     private static final int bufferSize = 0x20000; // ~130K.\n+    private static final int UNICODE_BOM = 0xFEFF;\n     private static final char[] mimeBoundaryChars =\n             \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\n     static final int boundaryLength = 32;\n             docData = Charset.forName(charsetName).decode(byteData).toString();\n         }\n         // UTF-8 BOM indicator. takes precedence over everything else. rarely used. re-decodes incase above decoded incorrectly\n-        if (docData.length() > 0 && docData.charAt(0) == 65279) {\n+        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {\n             byteData.rewind();\n             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n             docData = docData.substring(1);\n--- a/src/main/java/org/jsoup/helper/DescendableLinkedList.java\n+++ b/src/main/java/org/jsoup/helper/DescendableLinkedList.java\n \n /**\n  * Provides a descending iterator and other 1.6 methods to allow support on the 1.5 JRE.\n+ * @param <E> Type of elements\n  */\n public class DescendableLinkedList<E> extends LinkedList<E> {\n \n      * Add a new element to the start of the list.\n      * @param e element to add\n      */\n+    @Override\n     public void push(E e) {\n         addFirst(e);\n     }\n      * Look at the last element, if there is one.\n      * @return the last element, or null\n      */\n+    @Override\n     public E peekLast() {\n         return size() == 0 ? null : getLast();\n     }\n      * Remove and return the last element, if there is one\n      * @return the last element, or null\n      */\n+    @Override\n     public E pollLast() {\n         return size() == 0 ? null : removeLast();\n     }\n      * Get an iterator that starts and the end of the list and works towards the start.\n      * @return an iterator that starts and the end of the list and works towards the start.\n      */\n+    @Override\n     public Iterator<E> descendingIterator() {\n         return new DescendingIterator<E>(size());\n     }\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import java.util.regex.Pattern;\n import java.util.zip.GZIPInputStream;\n \n+import static org.jsoup.Connection.Method;\n+\n /**\n  * Implementation of {@link Connection}.\n  * @see org.jsoup.Jsoup#connect(String)\n  */\n public class HttpConnection implements Connection {\n-    private static final int HTTP_TEMP_REDIR = 307; // http/1.1 temporary redirect, not in Java's set.\n     public static final String  CONTENT_ENCODING = \"Content-Encoding\";\n     private static final String CONTENT_TYPE = \"Content-Type\";\n     private static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n+    private static final String FORM_URL_ENCODED = \"application/x-www-form-urlencoded\";\n \n     public static Connection connect(String url) {\n         Connection con = new HttpConnection();\n             maxBodySizeBytes = 1024 * 1024; // 1MB\n             followRedirects = true;\n             data = new ArrayList<Connection.KeyVal>();\n-            method = Connection.Method.GET;\n+            method = Method.GET;\n             headers.put(\"Accept-Encoding\", \"gzip\");\n             parser = Parser.htmlParser();\n         }\n     public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response {\n         private static final int MAX_REDIRECTS = 20;\n         private static SSLSocketFactory sslSocketFactory;\n+        private static final String LOCATION = \"Location\";\n         private int statusCode;\n         private String statusMessage;\n         private ByteBuffer byteData;\n \n             // set up the request for execution\n             String mimeBoundary = null;\n-            if (req.method() == Connection.Method.GET && req.data().size() > 0) {\n+            if (!req.method().hasBody() && req.data().size() > 0) {\n                 serialiseRequestUrl(req); // appends query string\n-            } else {\n-                mimeBoundary = setupMultipartModeIfNeeded(req);\n+            } else if (req.method().hasBody()) {\n+                mimeBoundary = setOutputContentType(req);\n             }\n             HttpURLConnection conn = createConnection(req);\n             Response res;\n             try {\n                 conn.connect();\n-                if (req.method() == Connection.Method.POST)\n+                if (conn.getDoOutput())\n                     writePost(req, conn.getOutputStream(), mimeBoundary);\n \n                 int status = conn.getResponseCode();\n-                boolean needsRedirect = false;\n-                if (status != HttpURLConnection.HTTP_OK) {\n-                    if (status == HttpURLConnection.HTTP_MOVED_TEMP || status == HttpURLConnection.HTTP_MOVED_PERM || status == HttpURLConnection.HTTP_SEE_OTHER || status == HTTP_TEMP_REDIR)\n-                        needsRedirect = true;\n-                    else if (!req.ignoreHttpErrors())\n-                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n-                }\n                 res = new Response(previousResponse);\n                 res.setupFromConnection(conn, previousResponse);\n-                if (needsRedirect && req.followRedirects()) {\n+                res.req = req;\n+\n+                // redirect if there's a location header (from 3xx, or 201 etc)\n+                if (res.hasHeader(LOCATION) && req.followRedirects()) {\n                     req.method(Method.GET); // always redirect with a get. any data param from original req are dropped.\n                     req.data().clear();\n \n-                    String location = res.header(\"Location\");\n+                    String location = res.header(LOCATION);\n                     if (location != null && location.startsWith(\"http:/\") && location.charAt(6) != '/') // fix broken Location: http:/temp/AAG_New/en/index.php\n                         location = location.substring(6);\n                     req.url(new URL(req.url(), encodeUrl(location)));\n                     }\n                     return execute(req, res);\n                 }\n-                res.req = req;\n+                if ((status < 200 || status >= 400) && !req.ignoreHttpErrors())\n+                        throw new HttpStatusException(\"HTTP error fetching URL\", status, req.url().toString());\n \n                 // check that we can handle the returned content type; if not, abort before fetching it\n                 String contentType = res.contentType();\n                 }\n             }\n \n-            if (req.method() == Method.POST)\n+            if (req.method().hasBody())\n                 conn.setDoOutput(true);\n             if (req.cookies().size() > 0)\n                 conn.addRequestProperty(\"Cookie\", getRequestCookieString(req));\n \n         // set up url, method, header, cookies\n         private void setupFromConnection(HttpURLConnection conn, Connection.Response previousResponse) throws IOException {\n-            method = Connection.Method.valueOf(conn.getRequestMethod());\n+            method = Method.valueOf(conn.getRequestMethod());\n             url = conn.getURL();\n             statusCode = conn.getResponseCode();\n             statusMessage = conn.getResponseMessage();\n             }\n         }\n \n-        private static String setupMultipartModeIfNeeded(final Connection.Request req) {\n+        private static String setOutputContentType(final Connection.Request req) {\n             // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n             boolean needsMulti = false;\n             for (Connection.KeyVal keyVal : req.data()) {\n                     break;\n                 }\n             }\n+            String bound = null;\n             if (needsMulti) {\n-                final String bound = DataUtil.mimeBoundary();\n+                bound = DataUtil.mimeBoundary();\n                 req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n-                return bound;\n-            }\n-            return null;\n+            } else {\n+                req.header(CONTENT_TYPE, FORM_URL_ENCODED);\n+            }\n+            return bound;\n         }\n \n         private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n--- /dev/null\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n+package org.jsoup.helper;\n+\n+import org.jsoup.nodes.Attribute;\n+import org.jsoup.select.NodeTraversor;\n+import org.jsoup.select.NodeVisitor;\n+import org.w3c.dom.Comment;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Text;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import java.io.StringWriter;\n+import javax.xml.transform.TransformerException;\n+\n+/**\n+ * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},\n+ * for integration with toolsets that use the W3C DOM.\n+ * <p/>\n+ * This class is currently <b>experimental</b>, please provide feedback on utility and any problems experienced.\n+ */\n+public class W3CDom {\n+    protected DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n+\n+    /**\n+     * Convert a jsoup Document to a W3C Document.\n+     * @param in jsoup doc\n+     * @return w3c doc\n+     */\n+    public Document fromJsoup(org.jsoup.nodes.Document in) {\n+        Validate.notNull(in);\n+        DocumentBuilder builder;\n+        try {\n+            builder = factory.newDocumentBuilder();\n+            Document out = builder.newDocument();\n+            convert(in, out);\n+            return out;\n+        } catch (ParserConfigurationException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * Converts a jsoup document into the provided W3C Document. If required, you can set options on the output document\n+     * before converting.\n+     * @param in jsoup doc\n+     * @param out w3c doc\n+     * @see org.jsoup.helper.W3CDom#fromJsoup(org.jsoup.nodes.Document)\n+     */\n+    public void convert(org.jsoup.nodes.Document in, Document out) {\n+        if (!StringUtil.isBlank(in.location()))\n+            out.setDocumentURI(in.location());\n+\n+        org.jsoup.nodes.Element rootEl = in.child(0); // skip the #root node\n+        NodeTraversor traversor = new NodeTraversor(new W3CBuilder(out));\n+        traversor.traverse(rootEl);\n+    }\n+\n+    /**\n+     * Implements the conversion by walking the input.\n+     */\n+    protected class W3CBuilder implements NodeVisitor {\n+        private final Document doc;\n+        private Element dest;\n+\n+        public W3CBuilder(Document doc) {\n+            this.doc = doc;\n+        }\n+\n+        public void head(org.jsoup.nodes.Node source, int depth) {\n+            if (source instanceof org.jsoup.nodes.Element) {\n+                org.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n+                Element el = doc.createElement(sourceEl.tagName());\n+                copyAttributes(sourceEl, el);\n+                if (dest == null) { // sets up the root\n+                    doc.appendChild(el);\n+                } else {\n+                    dest.appendChild(el);\n+                }\n+                dest = el; // descend\n+            } else if (source instanceof org.jsoup.nodes.TextNode) {\n+                org.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\n+                Text text = doc.createTextNode(sourceText.getWholeText());\n+                dest.appendChild(text);\n+            } else if (source instanceof org.jsoup.nodes.Comment) {\n+                org.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\n+                Comment comment = doc.createComment(sourceComment.getData());\n+                dest.appendChild(comment);\n+            } else if (source instanceof org.jsoup.nodes.DataNode) {\n+                org.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\n+                Text node = doc.createTextNode(sourceData.getWholeData());\n+                dest.appendChild(node);\n+            } else {\n+                // unhandled\n+            }\n+        }\n+\n+        public void tail(org.jsoup.nodes.Node source, int depth) {\n+            if (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\n+                dest = (Element) dest.getParentNode(); // undescend. cromulent.\n+            }\n+        }\n+\n+        private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\n+            for (Attribute attribute : source.attributes()) {\n+                el.setAttribute(attribute.getKey(), attribute.getValue());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Serialize a W3C document to a String.\n+     * @param doc Document\n+     * @return Document as string\n+     */\n+    public String asString(Document doc) {\n+        try {\n+            DOMSource domSource = new DOMSource(doc);\n+            StringWriter writer = new StringWriter();\n+            StreamResult result = new StreamResult(writer);\n+            TransformerFactory tf = TransformerFactory.newInstance();\n+            Transformer transformer = tf.newTransformer();\n+            transformer.transform(domSource, result);\n+            return writer.toString();\n+        } catch (TransformerException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+}\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n      Get the string representation of this attribute, implemented as {@link #html()}.\n      @return string\n      */\n+    @Override\n     public String toString() {\n         return html();\n     }\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n         }\n     }\n     \n+    @Override\n     public String toString() {\n         return html();\n     }\n         \n         Attributes that = (Attributes) o;\n         \n-        if (attributes != null ? !attributes.equals(that.attributes) : that.attributes != null) return false;\n-        \n-        return true;\n+        return !(attributes != null ? !attributes.equals(that.attributes) : that.attributes != null);\n     }\n     \n     @Override\n--- a/src/main/java/org/jsoup/nodes/Comment.java\n+++ b/src/main/java/org/jsoup/nodes/Comment.java\n \n     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n \n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n--- a/src/main/java/org/jsoup/nodes/DataNode.java\n+++ b/src/main/java/org/jsoup/nodes/DataNode.java\n \n     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n \n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n package org.jsoup.nodes;\n \n import org.jsoup.helper.StringUtil;\n-import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.Document.OutputSettings.*;\n \n /**\n  * A {@code <!DOCTYPE>} node.\n  */\n public class DocumentType extends Node {\n+    private static final String NAME = \"name\";\n+    private static final String PUBLIC_ID = \"publicId\";\n+    private static final String SYSTEM_ID = \"systemId\";\n     // todo: quirk mode from publicId and systemId\n \n     /**\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        attr(\"name\", name);\n-        attr(\"publicId\", publicId);\n-        attr(\"systemId\", systemId);\n+        attr(NAME, name);\n+        attr(PUBLIC_ID, publicId);\n+        attr(SYSTEM_ID, systemId);\n     }\n \n     @Override\n \n     @Override\n     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n-        accum.append(\"<!DOCTYPE\");\n-        if (!StringUtil.isBlank(attr(\"name\")))\n-            accum.append(\" \").append(attr(\"name\"));\n-        if (!StringUtil.isBlank(attr(\"publicId\")))\n-            accum.append(\" PUBLIC \\\"\").append(attr(\"publicId\")).append('\"');\n-        if (!StringUtil.isBlank(attr(\"systemId\")))\n-            accum.append(\" \\\"\").append(attr(\"systemId\")).append('\"');\n+        if (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {\n+            // looks like a html5 doctype, go lowercase for aesthetics\n+            accum.append(\"<!doctype\");\n+        } else {\n+            accum.append(\"<!DOCTYPE\");\n+        }\n+        if (has(NAME))\n+            accum.append(\" \").append(attr(NAME));\n+        if (has(PUBLIC_ID))\n+            accum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"');\n+        if (has(SYSTEM_ID))\n+            accum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"');\n         accum.append('>');\n     }\n \n     @Override\n     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n     }\n+\n+    private boolean has(final String attribute) {\n+        return !StringUtil.isBlank(attr(attribute));\n+    }\n }\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n  */\n public class Element extends Node {\n     private Tag tag;\n-    private Set<String> classNames;\n-    \n     /**\n      * Create a new, standalone Element. (Standalone in that is has no parent.)\n      * \n      * @return The literal class attribute, or <b>empty string</b> if no class attribute set.\n      */\n     public String className() {\n-        return attr(\"class\");\n+        return attr(\"class\").trim();\n     }\n \n     /**\n      * @return set of classnames, empty if no class attribute\n      */\n     public Set<String> classNames() {\n-        if (classNames == null) {\n-            String[] names = className().split(\"\\\\s+\");\n-            classNames = new LinkedHashSet<String>(Arrays.asList(names));\n-        }\n+    \tString[] names = className().split(\"\\\\s+\");\n+    \tSet<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));\n+    \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n+\n         return classNames;\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames\n         return clone;\n     }\n }\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n import java.io.InputStream;\n import java.nio.charset.CharsetEncoder;\n import java.util.*;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n \n /**\n  * HTML entities, and escape routines.\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n \n     abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n \n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n \n     @Override\n     public boolean equals(Object o) {\n-        if (this == o) return true;\n         // todo: have nodes hold a child index, compare against that and parent (not children)\n-        return false;\n+\n+        return this == o;\n     }\n \n     @Override\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n \n     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n \n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n     /**\n      * Create a new TextNode from HTML encoded (aka escaped) data.\n      * @param encodedText Text containing encoded HTML (e.g. &amp;lt;)\n+     * @param baseUri Base uri\n      * @return TextNode containing unencoded data (e.g. &lt;)\n      */\n     public static TextNode createFromEncoded(String encodedText, String baseUri) {\n--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n \n     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n \n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n         for (int offset = pos; offset < length; offset++) {\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n-                while(++offset < length && startChar != input[offset]);\n+                while(++offset < length && startChar != input[offset]) { /* empty */ }\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n             if (offset < length && last <= length) {\n-                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n+                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) { /* empty */ }\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n         }\n \n         runParser();\n-        if (context != null)\n+        if (context != null && root != null)\n             return root.childNodes();\n         else\n             return doc.childNodes();\n     }\n \n     void insertInFosterParent(Node in) {\n-        Element fosterParent = null;\n+        Element fosterParent;\n         Element lastTable = getFromStack(\"table\");\n         boolean isLastTableParent = false;\n         if (lastTable != null) {\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n \n         boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n             tb.error(this);\n-            boolean processed = true;\n+            boolean processed;\n             if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                 tb.setFosterInserts(true);\n                 processed = tb.process(t, InBody);\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n \n         Tag tag = (Tag) o;\n \n+        if (!tagName.equals(tag.tagName)) return false;\n         if (canContainBlock != tag.canContainBlock) return false;\n         if (canContainInline != tag.canContainInline) return false;\n         if (empty != tag.empty) return false;\n         if (selfClosing != tag.selfClosing) return false;\n         if (formList != tag.formList) return false;\n         if (formSubmit != tag.formSubmit) return false;\n-        if (!tagName.equals(tag.tagName)) return false;\n \n         return true;\n     }\n         return result;\n     }\n \n+    @Override\n     public String toString() {\n         return tagName;\n     }\n             \"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n             \"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\",\n             \"del\", \"s\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n-            \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\"\n+            \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\", \"template\", \"article\", \"main\",\n+            \"svg\", \"math\"\n     };\n     private static final String[] inlineTags = {\n             \"object\", \"base\", \"font\", \"tt\", \"i\", \"b\", \"u\", \"big\", \"small\", \"em\", \"strong\", \"dfn\", \"code\", \"samp\", \"kbd\",\n             \"var\", \"cite\", \"abbr\", \"time\", \"acronym\", \"mark\", \"ruby\", \"rt\", \"rp\", \"a\", \"img\", \"br\", \"wbr\", \"map\", \"q\",\n             \"sub\", \"sup\", \"bdo\", \"iframe\", \"embed\", \"span\", \"input\", \"select\", \"textarea\", \"label\", \"button\", \"optgroup\",\n             \"option\", \"legend\", \"datalist\", \"keygen\", \"output\", \"progress\", \"meter\", \"area\", \"param\", \"source\", \"track\",\n-            \"summary\", \"command\", \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\"\n+            \"summary\", \"command\", \"device\", \"area\", \"basefont\", \"bgsound\", \"menuitem\", \"param\", \"source\", \"track\",\n+            \"data\", \"bdi\"\n     };\n     private static final String[] emptyTags = {\n             \"meta\", \"link\", \"base\", \"frame\", \"img\", \"br\", \"wbr\", \"embed\", \"hr\", \"input\", \"keygen\", \"col\", \"command\",\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n \n     /**\n      * Pulls the next run of whitespace characters of the queue.\n+     * @return Whether consuming whitespace or not\n      */\n     public boolean consumeWhitespace() {\n         boolean seen = false;\n         return remainder;\n     }\n     \n+    @Override\n     public String toString() {\n         return queue.substring(pos);\n     }\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Entities;\n \n-import java.util.ArrayList;\n-import java.util.List;\n \n /**\n  * Readers the input stream into tokens.\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n \n-import java.util.ArrayList;\n-import java.util.List;\n \n /**\n  * @author Jonathan Hedley\n--- a/src/main/java/org/jsoup/safety/Cleaner.java\n+++ b/src/main/java/org/jsoup/safety/Cleaner.java\n import org.jsoup.select.NodeTraversor;\n import org.jsoup.select.NodeVisitor;\n \n-import java.util.List;\n \n /**\n  The whitelist based HTML cleaner. Use to ensure that end-user provided HTML contains only the elements and attributes\n--- a/src/main/java/org/jsoup/select/CombiningEvaluator.java\n+++ b/src/main/java/org/jsoup/select/CombiningEvaluator.java\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.List;\n \n /**\n  * Base combining (and, or) evaluator.\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n      * @see #text()\n      * @see #html()\n      */\n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n \n     public void clear() {contents.clear();}\n \n+    @Override\n     public boolean equals(Object o) {return contents.equals(o);}\n \n+    @Override\n     public int hashCode() {return contents.hashCode();}\n \n     public Element get(int index) {return contents.get(index);}\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n  * <tr><td><code>[^attrPrefix]</code></td><td>elements with an attribute name starting with \"attrPrefix\". Use to find elements with HTML5 datasets</td><td><code>[^data-]</code>, <code>div[^data-]</code></td></tr>\n  * <tr><td><code>[attr=val]</code></td><td>elements with an attribute named \"attr\", and value equal to \"val\"</td><td><code>img[width=500]</code>, <code>a[rel=nofollow]</code></td></tr>\n  * <tr><td><code>[attr=&quot;val&quot;]</code></td><td>elements with an attribute named \"attr\", and value equal to \"val\"</td><td><code>span[hello=\"Cleveland\"][goodbye=\"Columbus\"]</code>, <code>a[rel=&quot;nofollow&quot;]</code></td></tr>\n- * <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named \"attr\", and value starting with \"valPrefix\"</td><td><code>a[href^=http:]</code></code></td></tr>\n+ * <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named \"attr\", and value starting with \"valPrefix\"</td><td><code>a[href^=http:]</code></td></tr>\n  * <tr><td><code>[attr$=valSuffix]</code></td><td>elements with an attribute named \"attr\", and value ending with \"valSuffix\"</td><td><code>img[src$=.png]</code></td></tr>\n  * <tr><td><code>[attr*=valContaining]</code></td><td>elements with an attribute named \"attr\", and value containing \"valContaining\"</td><td><code>a[href*=/search/]</code></td></tr>\n  * <tr><td><code>[attr~=<em>regex</em>]</code></td><td>elements with an attribute named \"attr\", and value matching the regular expression</td><td><code>img[src~=(?i)\\\\.(png|jpe?g)]</code></td></tr>\n  * <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>\n  * <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>\n  * <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>\n- * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class.<br /><code>div:not(:has(div))</code> finds divs that do not contain divs.</code></td></tr>\n+ * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class.<br /><code>div:not(:has(div))</code> finds divs that do not contain divs.</td></tr>\n  * <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text \"jsoup\".</td></tr>\n  * <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  * <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contain the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n--- a/src/main/java/org/jsoup/select/StructuralEvaluator.java\n+++ b/src/main/java/org/jsoup/select/StructuralEvaluator.java\n             return false;\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":has(%s)\", evaluator);\n         }\n             return !evaluator.matches(root, node);\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":not%s\", evaluator);\n         }\n             return false;\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":parent%s\", evaluator);\n         }\n             return parent != null && evaluator.matches(root, parent);\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":ImmediateParent%s\", evaluator);\n         }\n             return false;\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":prev*%s\", evaluator);\n         }\n             return prev != null && evaluator.matches(root, prev);\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":prev%s\", evaluator);\n         }\n--- /dev/null\n+++ b/src/test/java/org/jsoup/helper/W3CDomTest.java\n+package org.jsoup.helper;\n+\n+import org.jsoup.Jsoup;\n+import org.jsoup.integration.ParseTest;\n+import org.junit.Test;\n+import org.w3c.dom.Document;\n+\n+import java.io.File;\n+import java.io.IOException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class W3CDomTest {\n+    @Test\n+    public void simpleConversion() {\n+        String html = \"<html><head><title>W3c</title></head><body><p class='one' id=12>Text</p><!-- comment --><invalid>What<script>alert('!')\";\n+        org.jsoup.nodes.Document doc = Jsoup.parse(html);\n+\n+        W3CDom w3c = new W3CDom();\n+        Document wDoc = w3c.fromJsoup(doc);\n+        String out = w3c.asString(wDoc);\n+        assertEquals(\n+                \"<html>\\n\" +\n+                        \"<head>\\n\" +\n+                        \"<META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\">\\n\" +\n+                        \"<title>W3c</title>\\n\" +\n+                        \"</head>\\n\" +\n+                        \"<body>\\n\" +\n+                        \"<p class=\\\"one\\\" id=\\\"12\\\">Text</p>\\n\" +\n+                        \"<!-- comment -->\\n\" +\n+                        \"<invalid>What<script>alert('!')</script>\\n\" +\n+                        \"</invalid>\\n\" +\n+                        \"</body>\\n\" +\n+                        \"</html>\\n\"\n+                , out);\n+    }\n+\n+    @Test\n+    public void convertsGoogle() throws IOException {\n+        File in = ParseTest.getFile(\"/htmltests/google-ipod.html\");\n+        org.jsoup.nodes.Document doc = Jsoup.parse(in, \"UTF8\");\n+\n+        W3CDom w3c = new W3CDom();\n+        Document wDoc = w3c.fromJsoup(doc);\n+        String out = w3c.asString(wDoc);\n+        assertTrue(out.contains(\"ipod\"));\n+    }\n+}\n+\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n import org.jsoup.HttpStatusException;\n import org.jsoup.Jsoup;\n import org.jsoup.UnsupportedMimeTypeException;\n+import org.jsoup.helper.W3CDom;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.FormElement;\n import org.junit.Ignore;\n \n     @Test\n     public void fetchURl() throws IOException {\n-        String url = \"http://www.google.com\"; // no trailing / to force redir\n+        String url = \"http://jsoup.org\"; // no trailing / to force redir\n         Document doc = Jsoup.parse(new URL(url), 10*1000);\n-        assertTrue(doc.title().contains(\"Google\"));\n+        assertTrue(doc.title().contains(\"jsoup\"));\n     }\n \n     @Test\n         assertEquals(\"Mozilla\", ihVal(\"HTTP_USER_AGENT\", doc));\n         assertEquals(\"http://example.com\", ihVal(\"HTTP_REFERER\", doc));\n     }\n+\n+    @Test\n+    public void doesPut() throws IOException {\n+        Connection.Response res = Jsoup.connect(echoURL)\n+                .data(\"uname\", \"Jsoup\", \"uname\", \"Jonathan\", \"\u767e\", \"\u5ea6\u4e00\u4e0b\")\n+                .cookie(\"auth\", \"token\")\n+                .method(Connection.Method.PUT)\n+                .execute();\n+\n+        Document doc = res.parse();\n+        assertEquals(\"PUT\", ihVal(\"REQUEST_METHOD\", doc));\n+        //assertEquals(\"gzip\", ihVal(\"HTTP_ACCEPT_ENCODING\", doc)); // current proxy removes gzip on post\n+        assertEquals(\"auth=token\", ihVal(\"HTTP_COOKIE\", doc));\n+    }\n+\n \n     private static String ihVal(String key, Document doc) {\n         return doc.select(\"th:contains(\"+key+\") + td\").first().text();\n                 .post();\n \n         assertEquals(\"Baseline DCT, Huffman coding\", result.select(\"td:contains(Process) + td\").text());\n-\n+    }\n+\n+    @Test\n+    public void handles201Created() throws IOException {\n+        Document doc = Jsoup.connect(\"http://direct.infohound.net/tools/201.pl\").get(); // 201, location=jsoup\n+        assertEquals(\"http://jsoup.org\", doc.location());\n+    }\n+\n+    @Test\n+    public void fetchToW3c() throws IOException {\n+        String url = \"http://jsoup.org\";\n+        Document doc = Jsoup.connect(url).get();\n+\n+        W3CDom dom = new W3CDom();\n+        org.w3c.dom.Document wDoc = dom.fromJsoup(doc);\n+        assertEquals(url, wDoc.getDocumentURI());\n+        String html = dom.asString(wDoc);\n+        assertTrue(html.contains(\"jsoup\"));\n     }\n \n }\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n         Document clone = doc.clone();\n \n         assertEquals(doc.html(), clone.html());\n-        assertEquals(\"<!DOCTYPE html><html><head><title>Doctype test</title></head><body></body></html>\",\n+        assertEquals(\"<!doctype html><html><head><title>Doctype test</title></head><body></body></html>\",\n                 TextUtil.stripNewlines(clone.html()));\n     }\n     \n         Document doc = Jsoup.parse(h);\n \n         doc.outputSettings().syntax(Syntax.html);\n-        assertEquals(\"<!DOCTYPE html>\\n\" +\n+        assertEquals(\"<!doctype html>\\n\" +\n                 \"<html>\\n\" +\n                 \" <head></head>\\n\" +\n                 \" <body>\\n\" +\n--- a/src/test/java/org/jsoup/nodes/DocumentTypeTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTypeTest.java\n \n     @Test public void outerHtmlGeneration() {\n         DocumentType html5 = new DocumentType(\"html\", \"\", \"\", \"\");\n-        assertEquals(\"<!DOCTYPE html>\", html5.outerHtml());\n+        assertEquals(\"<!doctype html>\", html5.outerHtml());\n \n         DocumentType publicDocType = new DocumentType(\"html\", \"-//IETF//DTD HTML//\", \"\", \"\");\n         assertEquals(\"<!DOCTYPE html PUBLIC \\\"-//IETF//DTD HTML//\\\">\", publicDocType.outerHtml());\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n import static org.junit.Assert.*;\n \n import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n import java.util.List;\n import java.util.Set;\n import java.util.Map;\n     }\n     \n     @Test public void testClassDomMethods() {\n-        Document doc = Jsoup.parse(\"<div><span class='mellow yellow'>Hello <b>Yellow</b></span></div>\");\n+        Document doc = Jsoup.parse(\"<div><span class=' mellow yellow '>Hello <b>Yellow</b></span></div>\");\n         List<Element> els = doc.getElementsByAttribute(\"class\");\n         Element span = els.get(0);\n         assertEquals(\"mellow yellow\", span.className());\n         assertTrue(classes.contains(\"yellow\"));\n \n         assertEquals(\"\", doc.className());\n+        classes = doc.classNames();\n+        assertEquals(0, classes.size());\n         assertFalse(doc.hasClass(\"mellow\"));\n     }\n \n         assertTrue(divC == doc.select(divC.cssSelector()).first());\n     }\n \n+\n+    @Test\n+    public void testClassNames() {\n+        Document doc = Jsoup.parse(\"<div class=\\\"c1 c2\\\">C</div>\");\n+        Element div = doc.select(\"div\").get(0);\n+\n+        assertEquals(\"c1 c2\", div.className());\n+\n+        final Set<String> set1 = div.classNames();\n+        final Object[] arr1 = set1.toArray();\n+        assertTrue(arr1.length==2);\n+        assertEquals(\"c1\", arr1[0]);\n+        assertEquals(\"c2\", arr1[1]);\n+\n+        // Changes to the set should not be reflected in the Elements getters\n+       \tset1.add(\"c3\");\n+        assertTrue(2==div.classNames().size());\n+        assertEquals(\"c1 c2\", div.className());\n+\n+        // Update the class names to a fresh set\n+        final Set<String> newSet = new LinkedHashSet<String>(3);\n+        newSet.addAll(set1);\n+        newSet.add(\"c3\");\n+        \n+        div.classNames(newSet);\n+\n+        \n+        assertEquals(\"c1 c2 c3\", div.className());\n+\n+        final Set<String> set2 = div.classNames();\n+        final Object[] arr2 = set2.toArray();\n+        assertTrue(arr2.length==3);\n+        assertEquals(\"c1\", arr2[0]);\n+        assertEquals(\"c2\", arr2[1]);\n+        assertEquals(\"c3\", arr2[2]);\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n     @Test public void normalisesDocument() {\n         String h = \"<!doctype html>One<html>Two<head>Three<link></head>Four<body>Five </body>Six </html>Seven \";\n         Document doc = Jsoup.parse(h);\n-        assertEquals(\"<!DOCTYPE html><html><head></head><body>OneTwoThree<link>FourFive Six Seven </body></html>\",\n+        assertEquals(\"<!doctype html><html><head></head><body>OneTwoThree<link>FourFive Six Seven </body></html>\",\n                 TextUtil.stripNewlines(doc.html()));\n     }\n \n                 \"<p></b></b></b></b></b></b>X\";\n         Document doc = Jsoup.parse(h);\n         doc.outputSettings().indentAmount(0);\n-        String want = \"<!DOCTYPE html>\\n\" +\n+        String want = \"<!doctype html>\\n\" +\n                 \"<html>\\n\" +\n                 \"<head></head>\\n\" +\n                 \"<body>\\n\" +\n         // would previously throw invalid name exception on empty doctype\n         Document doc = Jsoup.parse(\"<!DOCTYPE>\");\n         assertEquals(\n-                \"<!DOCTYPE> <html> <head></head> <body></body> </html>\",\n+                \"<!doctype> <html> <head></head> <body></body> </html>\",\n                 StringUtil.normaliseWhitespace(doc.outerHtml()));\n \n         doc = Jsoup.parse(\"<!DOCTYPE><html><p>Foo</p></html>\");\n         assertEquals(\n-                \"<!DOCTYPE> <html> <head></head> <body> <p>Foo</p> </body> </html>\",\n+                \"<!doctype> <html> <head></head> <body> <p>Foo</p> </body> </html>\",\n                 StringUtil.normaliseWhitespace(doc.outerHtml()));\n \n         doc = Jsoup.parse(\"<!DOCTYPE \\u0000>\");\n         assertEquals(\n-                \"<!DOCTYPE \ufffd> <html> <head></head> <body></body> </html>\",\n+                \"<!doctype \ufffd> <html> <head></head> <body></body> </html>\",\n                 StringUtil.normaliseWhitespace(doc.outerHtml()));\n     }\n }\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n     }\n \n     /**\n+     * Setter to disable\\enable SSL certificates checks during https connection\n+     * <p/>\n+     * By default all connections over HTTPS perform normal validation of certificates.\n+     * <b>NB!</b>Use this feature at your own risk.\n+     * <p/>\n+     * Some websites use self generated certificates to sign data, which sometimes are expired,\n+     * by default request to those websites would fail, this feature allows to communicate to them.\n+     *\n+     * @param value\n+     */\n+    Connection setValidateSSLCertificates(boolean value);\n+\n+    /**\n      * Set the request URL to fetch. The protocol must be HTTP or HTTPS.\n      * @param url URL to connect to\n      * @return this Connection, for chaining\n      * Represents a HTTP request.\n      */\n     public interface Request extends Base<Request> {\n+\n+\n         /**\n          * Get the request timeout, in milliseconds.\n          * @return the timeout in milliseconds.\n          * @return current Parser\n          */\n         public Parser parser();\n+\n+        /**\n+         * get current state of security enabling\\disabling feature\n+         *\n+         * @return\n+         */\n+        boolean isValidateSSLCertificates();\n+\n+        /**\n+         * Disable SSL certificates checks.\n+         * @param value\n+         */\n+        void setValidateSSLCertificates(boolean value);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n \n+import javax.net.ssl.*;\n import java.io.*;\n import java.net.HttpURLConnection;\n import java.net.MalformedURLException;\n import java.net.URLEncoder;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.X509Certificate;\n import java.util.*;\n import java.util.regex.Pattern;\n import java.util.zip.GZIPInputStream;\n \tprivate HttpConnection() {\n         req = new Request();\n         res = new Response();\n+    }\n+\n+    public Connection setValidateSSLCertificates(boolean value) {\n+        req.setValidateSSLCertificates(value);\n+        return this;\n     }\n \n     public Connection url(URL url) {\n         private boolean ignoreHttpErrors = false;\n         private boolean ignoreContentType = false;\n         private Parser parser;\n-\n-      \tprivate Request() {\n+//      always default to validateSSLCertificates connections in https\n+        private boolean validateSSLCertificates = true;\n+\n+        private Request() {\n             timeoutMilliseconds = 3000;\n             maxBodySizeBytes = 1024 * 1024; // 1MB\n             followRedirects = true;\n         public Parser parser() {\n             return parser;\n         }\n+\n+        public boolean isValidateSSLCertificates() {\n+            return validateSSLCertificates;\n+        }\n+\n+        public void setValidateSSLCertificates(boolean value) {\n+            validateSSLCertificates = value;\n+        }\n     }\n \n     public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response {\n         private static final int MAX_REDIRECTS = 20;\n+        private static SSLSocketFactory sslSocketFactory;\n         private static final String LOCATION = \"Location\";\n         private int statusCode;\n         private String statusMessage;\n         // set up connection defaults, and details from request\n         private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n             HttpURLConnection conn = (HttpURLConnection) req.url().openConnection();\n+\n             conn.setRequestMethod(req.method().name());\n             conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n             conn.setConnectTimeout(req.timeout());\n             conn.setReadTimeout(req.timeout());\n+\n+            if (conn instanceof HttpsURLConnection) {\n+                if (!req.isValidateSSLCertificates()) {\n+                    initUnSecureSSL();\n+                    ((HttpsURLConnection)conn).setSSLSocketFactory(sslSocketFactory);\n+                    ((HttpsURLConnection)conn).setHostnameVerifier(getInsecureVerifier());\n+                }\n+            }\n+\n             if (req.method().hasBody())\n                 conn.setDoOutput(true);\n             if (req.cookies().size() > 0)\n                 conn.addRequestProperty(header.getKey(), header.getValue());\n             }\n             return conn;\n+        }\n+\n+        /**\n+         * Instantiate Hostname Verifier that does nothing.\n+         * This is used for connections with disabled SSL certificates validation.\n+         *\n+         *\n+         * @return Hostname Verifier that does nothing and accepts all hostnames\n+         */\n+        private static HostnameVerifier getInsecureVerifier() {\n+            HostnameVerifier hv = new HostnameVerifier() {\n+                public boolean verify(String urlHostName, SSLSession session) {\n+                    return true;\n+                }\n+            };\n+            return hv;\n+        }\n+\n+        /**\n+         * Initialise Trust manager that does not validate certificate chains and\n+         * add it to current SSLContext.\n+         * <p/>\n+         * please not that this method will only perform action if sslSocketFactory is not yet\n+         * instantiated.\n+         *\n+         * @throws IOException\n+         */\n+        private static synchronized void initUnSecureSSL() throws IOException {\n+            if (sslSocketFactory == null) {\n+                // Create a trust manager that does not validate certificate chains\n+                final TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {\n+\n+                    public void checkClientTrusted(final X509Certificate[] chain, final String authType) {\n+                    }\n+\n+                    public void checkServerTrusted(final X509Certificate[] chain, final String authType) {\n+                    }\n+\n+                    public X509Certificate[] getAcceptedIssuers() {\n+                        return null;\n+                    }\n+                }};\n+\n+                // Install the all-trusting trust manager\n+                final SSLContext sslContext;\n+                try {\n+                    sslContext = SSLContext.getInstance(\"SSL\");\n+                    sslContext.init(null, trustAllCerts, new java.security.SecureRandom());\n+                    // Create an ssl socket factory with our all-trusting manager\n+                    sslSocketFactory = sslContext.getSocketFactory();\n+                } catch (NoSuchAlgorithmException e) {\n+                    throw new IOException(\"Can't create unsecure trust manager\");\n+                } catch (KeyManagementException e) {\n+                    throw new IOException(\"Can't create unsecure trust manager\");\n+                }\n+            }\n+\n         }\n \n         // set up url, method, header, cookies\n                         String cookieVal = cd.consumeTo(\";\").trim();\n                         if (cookieVal == null)\n                             cookieVal = \"\";\n-                        // ignores path, date, domain, secure et al. req'd?\n+                        // ignores path, date, domain, validateSSLCertificates et al. req'd?\n                         // name not blank, value not null\n                         if (cookieName != null && cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n \n import java.io.File;\n import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.net.MalformedURLException;\n import java.net.URL;\n import java.util.Map;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.*;\n \n /**\n  Tests the URL connection. Not enabled by default, so tests don't require network connection.\n  @author Jonathan Hedley, jonathan@hedley.net */\n @Ignore // ignored by default so tests don't require network access. comment out to enable.\n public class UrlConnectTest {\n+    private static final String WEBSITE_WITH_INVALID_CERTIFICATE = \"https://certs.cac.washington.edu/CAtest/\";\n+    private static final String WEBSITE_WITH_SNI = \"https://sni.velox.ch/\";\n     private static String echoURL = \"http://direct.infohound.net/tools/q.pl\";\n \n     @Test\n         assertEquals(actualDocText, unlimitedRes.parse().text().length());\n     }\n \n+    /**\n+     * Verify that security disabling feature works properly.\n+     * <p/>\n+     * 1. try to hit url with invalid certificate and evaluate that exception is thrown\n+     *\n+     * @throws Exception\n+     */\n+    @Test(expected = IOException.class)\n+    public void testUnsafeFail() throws Exception {\n+        String url = WEBSITE_WITH_INVALID_CERTIFICATE;\n+        Jsoup.connect(url).execute();\n+    }\n+\n+\n+    /**\n+     * Verify that requests to websites with SNI fail on jdk 1.6\n+     * <p/>\n+     * read for more details:\n+     * http://en.wikipedia.org/wiki/Server_Name_Indication\n+     *\n+     * Test is ignored independent from others as it requires JDK 1.6\n+     * @throws Exception\n+     */\n+    @Test(expected = IOException.class)\n+    @Ignore\n+    public void testSNIFail() throws Exception {\n+        String url = WEBSITE_WITH_SNI;\n+        Jsoup.connect(url).execute();\n+    }\n+\n+    /**\n+     * Verify that requests to websites with SNI pass\n+     * <p/>\n+     * <b>NB!</b> this test is FAILING right now on jdk 1.6\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    @Ignore\n+    public void testSNIPass() throws Exception {\n+        String url = WEBSITE_WITH_SNI;\n+        Connection.Response defaultRes = Jsoup.connect(url).setValidateSSLCertificates(false).execute();\n+        assertThat(defaultRes.statusCode(), is(200));\n+    }\n+\n+    /**\n+     * Verify that security disabling feature works properly.\n+     * <p/>\n+     * 1. disable security checks and call the same url to verify that content is consumed correctly\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testUnsafePass() throws Exception {\n+        String url = WEBSITE_WITH_INVALID_CERTIFICATE;\n+        Connection.Response defaultRes = Jsoup.connect(url).setValidateSSLCertificates(false).execute();\n+        assertThat(defaultRes.statusCode(), is(200));\n+    }\n+\n     @Test\n     public void shouldWorkForCharsetInExtraAttribute() throws IOException {\n         Connection.Response res = Jsoup.connect(\"https://www.creditmutuel.com/groupe/fr/\").execute();", "timestamp": 1414425756, "metainfo": ""}