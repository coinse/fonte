{"sha": "4de5fe88eab987f8ac5b2df32d5574e2615ae306", "log": "changed return type of Tokeniser.consumeCharacterReference from Character to char[], and also changed TokeniserState accordingly", "commit": "\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n         selfClosingFlagAcknowledged = true;\n     }\n \n-    Character consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n+    char[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\n         if (reader.isEmpty())\n             return null;\n         if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n             } // skip\n             if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n                 characterReferenceError(\"character outside of valid range\");\n-                return replacementChar;\n+                return new char[]{replacementChar};\n             } else {\n                 // todo: implement number replacement table\n                 // todo: check for extra illegal unicode points as parse errors\n-                return (char) charval;\n+                return Character.toChars(charval);\n             }\n         } else { // named\n             // get as many letters as possible, and look for matching entities.\n             }\n             if (!reader.matchConsume(\";\"))\n                 characterReferenceError(\"missing semicolon\"); // missing semi\n-            return Entities.getCharacterByName(nameRef);\n+            return new char[]{Entities.getCharacterByName(nameRef)};\n         }\n     }\n \n             builder.append(reader.consumeTo('&'));\n             if (reader.matches('&')) {\n                 reader.consume();\n-                Character c = consumeCharacterReference(null, inAttribute);\n-                if (c == null)\n+                char[] c = consumeCharacterReference(null, inAttribute);\n+                if (c == null || c.length==0)\n                     builder.append('&');\n                 else\n                     builder.append(c);\n         }\n         return builder.toString();\n     }\n-}\n+}\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n     CharacterReferenceInData {\n         // from & in data\n         void read(Tokeniser t, CharacterReader r) {\n-            Character c = t.consumeCharacterReference(null, false);\n-            if (c == null)\n+            char[] c = t.consumeCharacterReference(null, false);\n+            if (c == null||c.length==0)\n                 t.emit('&');\n             else\n-                t.emit(c);\n+                t.emit(new String(c));\n             t.transition(Data);\n         }\n     },\n     },\n     CharacterReferenceInRcdata {\n         void read(Tokeniser t, CharacterReader r) {\n-            Character c = t.consumeCharacterReference(null, false);\n-            if (c == null)\n+            char[] c = t.consumeCharacterReference(null, false);\n+            if (c == null||c.length==0)\n                 t.emit('&');\n             else\n-                t.emit(c);\n+                t.emit(new String(c));\n             t.transition(Rcdata);\n         }\n     },\n                 case eof: // should emit pending tag?\n                     t.eofError(this);\n                     t.transition(Data);\n-                // no default, as covered with above consumeToAny\n+                    // no default, as covered with above consumeToAny\n             }\n         }\n     },\n                 anythingElse(t, r);\n             }\n         }\n-        \n+\n         private void anythingElse(Tokeniser t, CharacterReader r) {\n             t.emit(\"</\" + t.dataBuffer.toString());\n             t.transition(ScriptDataEscaped);\n                 case '<':\n                     t.error(this);\n                     t.tagPending.appendAttributeName(c);\n-                // no default, as covered in consumeToAny\n+                    // no default, as covered in consumeToAny\n             }\n         }\n     },\n                     t.transition(AfterAttributeValue_quoted);\n                     break;\n                 case '&':\n-                    Character ref = t.consumeCharacterReference('\"', true);\n-                    if (ref != null)\n-                        t.tagPending.appendAttributeValue(ref);\n+                    char[] ref = t.consumeCharacterReference('\"', true);\n+                    if (ref != null && ref.length>0)\n+                        t.tagPending.appendAttributeValue(new String(ref));\n                     else\n                         t.tagPending.appendAttributeValue('&');\n                     break;\n                     t.transition(AfterAttributeValue_quoted);\n                     break;\n                 case '&':\n-                    Character ref = t.consumeCharacterReference('\\'', true);\n-                    if (ref != null)\n-                        t.tagPending.appendAttributeValue(ref);\n+                    char[] ref = t.consumeCharacterReference('\"', true);\n+                    if (ref != null && ref.length>0)\n+                        t.tagPending.appendAttributeValue(new String(ref));\n                     else\n                         t.tagPending.appendAttributeValue('&');\n                     break;\n                     t.transition(BeforeAttributeName);\n                     break;\n                 case '&':\n-                    Character ref = t.consumeCharacterReference('>', true);\n-                    if (ref != null)\n-                        t.tagPending.appendAttributeValue(ref);\n+                    char[] ref = t.consumeCharacterReference('\"', true);\n+                    if (ref != null && ref.length>0)\n+                        t.tagPending.appendAttributeValue(new String(ref));\n                     else\n                         t.tagPending.appendAttributeValue('&');\n                     break;\n     private static final char replacementChar = Tokeniser.replacementChar;\n     private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n     private static final char eof = CharacterReader.EOF;\n-}\n+}", "timestamp": 1359184299, "metainfo": ""}