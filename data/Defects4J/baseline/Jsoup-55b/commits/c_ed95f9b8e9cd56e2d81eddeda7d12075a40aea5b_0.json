{"sha": "ed95f9b8e9cd56e2d81eddeda7d12075a40aea5b", "log": "Merge pull request #477 from offa/some_fixes  Some code improvements", "commit": "\n--- a/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n+++ b/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n             }\n         }\n \n+        @Override\n         public String toString() {\n             return accum.toString();\n         }\n--- a/src/main/java/org/jsoup/helper/DescendableLinkedList.java\n+++ b/src/main/java/org/jsoup/helper/DescendableLinkedList.java\n \n /**\n  * Provides a descending iterator and other 1.6 methods to allow support on the 1.5 JRE.\n+ * @param <E> Type of elements\n  */\n public class DescendableLinkedList<E> extends LinkedList<E> {\n \n      * Add a new element to the start of the list.\n      * @param e element to add\n      */\n+    @Override\n     public void push(E e) {\n         addFirst(e);\n     }\n      * Look at the last element, if there is one.\n      * @return the last element, or null\n      */\n+    @Override\n     public E peekLast() {\n         return size() == 0 ? null : getLast();\n     }\n      * Remove and return the last element, if there is one\n      * @return the last element, or null\n      */\n+    @Override\n     public E pollLast() {\n         return size() == 0 ? null : removeLast();\n     }\n      * Get an iterator that starts and the end of the list and works towards the start.\n      * @return an iterator that starts and the end of the list and works towards the start.\n      */\n+    @Override\n     public Iterator<E> descendingIterator() {\n         return new DescendingIterator<E>(size());\n     }\n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n import javax.xml.transform.dom.DOMSource;\n import javax.xml.transform.stream.StreamResult;\n import java.io.StringWriter;\n+import javax.xml.transform.TransformerException;\n \n /**\n  * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},\n \n     /**\n      * Serialize a W3C document to a String.\n+     * @param doc Document\n+     * @return Document as string\n      */\n     public String asString(Document doc) {\n         try {\n             Transformer transformer = tf.newTransformer();\n             transformer.transform(domSource, result);\n             return writer.toString();\n-        } catch (Exception e) {\n+        } catch (TransformerException e) {\n             throw new IllegalStateException(e);\n         }\n     }\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n      Get the string representation of this attribute, implemented as {@link #html()}.\n      @return string\n      */\n+    @Override\n     public String toString() {\n         return html();\n     }\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n         }\n     }\n     \n+    @Override\n     public String toString() {\n         return html();\n     }\n         \n         Attributes that = (Attributes) o;\n         \n-        if (attributes != null ? !attributes.equals(that.attributes) : that.attributes != null) return false;\n-        \n-        return true;\n+        return !(attributes != null ? !attributes.equals(that.attributes) : that.attributes != null);\n     }\n     \n     @Override\n--- a/src/main/java/org/jsoup/nodes/Comment.java\n+++ b/src/main/java/org/jsoup/nodes/Comment.java\n \n     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n \n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n--- a/src/main/java/org/jsoup/nodes/DataNode.java\n+++ b/src/main/java/org/jsoup/nodes/DataNode.java\n \n     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n \n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n import java.io.InputStream;\n import java.nio.charset.CharsetEncoder;\n import java.util.*;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n \n /**\n  * HTML entities, and escape routines.\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n \n     abstract void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out);\n \n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n \n     @Override\n     public boolean equals(Object o) {\n-        if (this == o) return true;\n         // todo: have nodes hold a child index, compare against that and parent (not children)\n-        return false;\n+\n+        return this == o;\n     }\n \n     @Override\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n \n     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n \n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n     /**\n      * Create a new TextNode from HTML encoded (aka escaped) data.\n      * @param encodedText Text containing encoded HTML (e.g. &amp;lt;)\n+     * @param baseUri Base uri\n      * @return TextNode containing unencoded data (e.g. &lt;)\n      */\n     public static TextNode createFromEncoded(String encodedText, String baseUri) {\n--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n \n     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {}\n \n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n         for (int offset = pos; offset < length; offset++) {\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n-                while(++offset < length && startChar != input[offset]);\n+                while(++offset < length && startChar != input[offset]) { /* empty */ }\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n             if (offset < length && last <= length) {\n-                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n+                for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) { /* empty */ }\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n         }\n \n         runParser();\n-        if (context != null)\n+        if (context != null && root != null)\n             return root.childNodes();\n         else\n             return doc.childNodes();\n     }\n \n     void insertInFosterParent(Node in) {\n-        Element fosterParent = null;\n+        Element fosterParent;\n         Element lastTable = getFromStack(\"table\");\n         boolean isLastTableParent = false;\n         if (lastTable != null) {\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n \n         boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n             tb.error(this);\n-            boolean processed = true;\n+            boolean processed;\n             if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n                 tb.setFosterInserts(true);\n                 processed = tb.process(t, InBody);\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n         return result;\n     }\n \n+    @Override\n     public String toString() {\n         return tagName;\n     }\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n \n     /**\n      * Pulls the next run of whitespace characters of the queue.\n+     * @return Whether consuming whitespace or not\n      */\n     public boolean consumeWhitespace() {\n         boolean seen = false;\n         return remainder;\n     }\n     \n+    @Override\n     public String toString() {\n         return queue.substring(pos);\n     }\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Entities;\n \n-import java.util.ArrayList;\n-import java.util.List;\n \n /**\n  * Readers the input stream into tokens.\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n \n-import java.util.ArrayList;\n-import java.util.List;\n \n /**\n  * @author Jonathan Hedley\n--- a/src/main/java/org/jsoup/safety/Cleaner.java\n+++ b/src/main/java/org/jsoup/safety/Cleaner.java\n import org.jsoup.select.NodeTraversor;\n import org.jsoup.select.NodeVisitor;\n \n-import java.util.List;\n \n /**\n  The whitelist based HTML cleaner. Use to ensure that end-user provided HTML contains only the elements and attributes\n--- a/src/main/java/org/jsoup/select/CombiningEvaluator.java\n+++ b/src/main/java/org/jsoup/select/CombiningEvaluator.java\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n-import java.util.List;\n \n /**\n  * Base combining (and, or) evaluator.\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n      * @see #text()\n      * @see #html()\n      */\n+    @Override\n     public String toString() {\n         return outerHtml();\n     }\n \n     public void clear() {contents.clear();}\n \n+    @Override\n     public boolean equals(Object o) {return contents.equals(o);}\n \n+    @Override\n     public int hashCode() {return contents.hashCode();}\n \n     public Element get(int index) {return contents.get(index);}\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n  * <tr><td><code>[^attrPrefix]</code></td><td>elements with an attribute name starting with \"attrPrefix\". Use to find elements with HTML5 datasets</td><td><code>[^data-]</code>, <code>div[^data-]</code></td></tr>\n  * <tr><td><code>[attr=val]</code></td><td>elements with an attribute named \"attr\", and value equal to \"val\"</td><td><code>img[width=500]</code>, <code>a[rel=nofollow]</code></td></tr>\n  * <tr><td><code>[attr=&quot;val&quot;]</code></td><td>elements with an attribute named \"attr\", and value equal to \"val\"</td><td><code>span[hello=\"Cleveland\"][goodbye=\"Columbus\"]</code>, <code>a[rel=&quot;nofollow&quot;]</code></td></tr>\n- * <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named \"attr\", and value starting with \"valPrefix\"</td><td><code>a[href^=http:]</code></code></td></tr>\n+ * <tr><td><code>[attr^=valPrefix]</code></td><td>elements with an attribute named \"attr\", and value starting with \"valPrefix\"</td><td><code>a[href^=http:]</code></td></tr>\n  * <tr><td><code>[attr$=valSuffix]</code></td><td>elements with an attribute named \"attr\", and value ending with \"valSuffix\"</td><td><code>img[src$=.png]</code></td></tr>\n  * <tr><td><code>[attr*=valContaining]</code></td><td>elements with an attribute named \"attr\", and value containing \"valContaining\"</td><td><code>a[href*=/search/]</code></td></tr>\n  * <tr><td><code>[attr~=<em>regex</em>]</code></td><td>elements with an attribute named \"attr\", and value matching the regular expression</td><td><code>img[src~=(?i)\\\\.(png|jpe?g)]</code></td></tr>\n  * <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>\n  * <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>\n  * <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>\n- * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class.<br /><code>div:not(:has(div))</code> finds divs that do not contain divs.</code></td></tr>\n+ * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class.<br /><code>div:not(:has(div))</code> finds divs that do not contain divs.</td></tr>\n  * <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text \"jsoup\".</td></tr>\n  * <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  * <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contain the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n--- a/src/main/java/org/jsoup/select/StructuralEvaluator.java\n+++ b/src/main/java/org/jsoup/select/StructuralEvaluator.java\n             return false;\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":has(%s)\", evaluator);\n         }\n             return !evaluator.matches(root, node);\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":not%s\", evaluator);\n         }\n             return false;\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":parent%s\", evaluator);\n         }\n             return parent != null && evaluator.matches(root, parent);\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":ImmediateParent%s\", evaluator);\n         }\n             return false;\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":prev*%s\", evaluator);\n         }\n             return prev != null && evaluator.matches(root, prev);\n         }\n \n+        @Override\n         public String toString() {\n             return String.format(\":prev%s\", evaluator);\n         }", "timestamp": 1413589015, "metainfo": ""}