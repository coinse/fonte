{"sha": "3519d82fb3b11bc3a96b3598bfa9ccde9fae4fc9", "log": "Merge branch 'master' into update_meta_charset", "commit": "\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n \n /**\n  * A Connection provides a convenient interface to fetch content from the web, and parse them into Documents.\n- * <p/>\n+ * <p>\n  * To get a new Connection, use {@link org.jsoup.Jsoup#connect(String)}. Connections contain {@link Connection.Request}\n  * and {@link Connection.Response} objects. The request objects are reusable as prototype requests.\n- * <p/>\n+ * </p>\n+ * <p>\n  * Request configuration can be made using either the shortcut methods in Connection (e.g. {@link #userAgent(String)}),\n  * or by methods in the Connection.Request object directly. All request configuration must be made before the request is\n  * executed.\n+ * </p>\n  */\n public interface Connection {\n \n \n     /**\n      * Disable/enable TSL certificates validation for HTTPS requests.\n-     * <p/>\n+     * <p>\n      * By default this is <b>true</b>; all\n      * connections over HTTPS perform normal validation of certificates, and will abort requests if the provided\n      * certificate does not validate.\n-     * <p/>\n+     * </p>\n+     * <p>\n      * Some servers use expired, self-generated certificates; or your JDK may not\n      * support SNI hosts. In which case, you may want to enable this setting.\n-     * <p/> <b>Be careful</b> and understand why you need to disable these validations.\n+     * </p>\n+     * <p>\n+     * <b>Be careful</b> and understand why you need to disable these validations.\n+     * </p>\n      * @param value if should validate TSL (SSL) certificates. <b>true</b> by default.\n      * @return this Connection, for chaining\n      */\n     /**\n      * Add a number of request data parameters. Multiple parameters may be set at once, e.g.: <code>.data(\"name\",\n      * \"jsoup\", \"language\", \"Java\", \"language\", \"English\");</code> creates a query string like:\n-     * <code>?name=jsoup&language=Java&language=English</code>\n+     * <code>{@literal ?name=jsoup&language=Java&language=English}</code>\n      * @param keyvals a set of key value pairs.\n      * @return this Connection, for chaining\n      */\n \n     /**\n      * Adds each of the supplied cookies to the request.\n-     * @param cookies map of cookie name -> value pairs\n+     * @param cookies map of cookie name {@literal ->} value pairs\n      * @return this Connection, for chaining\n      */\n     public Connection cookies(Map<String, String> cookies);\n      * @return this Connection, for chaining\n      */\n     public Connection parser(Parser parser);\n+\n+    /**\n+     * Sets the default post data character set for x-www-form-urlencoded post data\n+     * @param charset character set to encode post data\n+     * @return this Connection, for chaining\n+     */\n+    public Connection postDataCharset(String charset);\n \n     /**\n      * Execute the request as a GET, and parse the result.\n \n         /**\n          * Get the value of a header. This is a simplified header model, where a header may only have one value.\n-         * <p/>\n+         * <p>\n          * Header names are case insensitive.\n+         * </p>\n          * @param name name of header (case insensitive)\n          * @return value of header, or null if not set.\n          * @see #hasHeader(String)\n \n         /**\n          * Get a cookie value by name from this request/response.\n-         * <p/>\n+         * <p>\n          * Response objects have a simplified cookie model. Each cookie set in the response is added to the response\n          * object's cookie key=value map. The cookie's path, domain, and expiry date are ignored.\n+         * </p>\n          * @param name name of cookie to retrieve.\n          * @return value of cookie, or null if not set\n          */\n          * @return current Parser\n          */\n         public Parser parser();\n+\n+        /**\n+         * Sets the post data character set for x-www-form-urlencoded post data\n+         * @param charset character set to encode post data\n+         * @return this Request, for chaining\n+         */\n+        public Request postDataCharset(String charset);\n+\n+        /**\n+         * Gets the post data character set for x-www-form-urlencoded post data\n+         * @return character set to encode post data\n+         */\n+        public String postDataCharset();\n+\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n+++ b/src/main/java/org/jsoup/examples/HtmlToPlainText.java\n  * HTML to plain-text. This example program demonstrates the use of jsoup to convert HTML input to lightly-formatted\n  * plain-text. That is divergent from the general goal of jsoup's .text() methods, which is to get clean data from a\n  * scrape.\n- * <p/>\n+ * <p>\n  * Note that this is a fairly simplistic formatter -- for real world use you'll want to embrace and extend.\n- * <p/>\n- * To invoke from the command line, assuming you've downloaded the jsoup jar to your current directory:<br/>\n- * <code>java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]</code><br/>\n+ * </p>\n+ * <p>\n+ * To invoke from the command line, assuming you've downloaded the jsoup jar to your current directory:</p>\n+ * <p><code>java -cp jsoup.jar org.jsoup.examples.HtmlToPlainText url [selector]</code></p>\n  * where <i>url</i> is the URL to fetch, and <i>selector</i> is an optional CSS selector.\n+ * \n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n public class HtmlToPlainText {\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n             doc = parser.parseInput(docData, baseUri);\n             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n             if (meta != null) { // if not found, will keep utf-8 as best attempt\n-                String foundCharset;\n+                String foundCharset = null;\n                 if (meta.hasAttr(\"http-equiv\")) {\n                     foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-                    if (foundCharset == null && meta.hasAttr(\"charset\")) {\n-                        try {\n-                            if (Charset.isSupported(meta.attr(\"charset\"))) {\n-                                foundCharset = meta.attr(\"charset\");\n-                            }\n-                        } catch (IllegalCharsetNameException e) {\n-                            foundCharset = null;\n+                }\n+                if (foundCharset == null && meta.hasAttr(\"charset\")) {\n+                    try {\n+                        if (Charset.isSupported(meta.attr(\"charset\"))) {\n+                            foundCharset = meta.attr(\"charset\");\n                         }\n+                    } catch (IllegalCharsetNameException e) {\n+                        foundCharset = null;\n                     }\n-                } else {\n-                    foundCharset = meta.attr(\"charset\");\n                 }\n \n                 if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode\n             if (randomAccessFile != null)\n                 randomAccessFile.close();\n         }\n+    }\n+\n+    static ByteBuffer emptyByteBuffer() {\n+        return ByteBuffer.allocate(0);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import java.net.URLEncoder;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n import java.security.KeyManagementException;\n import java.security.NoSuchAlgorithmException;\n import java.security.cert.X509Certificate;\n \n     public Connection response(Connection.Response response) {\n         res = response;\n+        return this;\n+    }\n+\n+    public Connection postDataCharset(String charset) {\n+        req.postDataCharset(charset);\n         return this;\n     }\n \n         private boolean ignoreContentType = false;\n         private Parser parser;\n         private boolean validateTSLCertificates = true;\n+        private String postDataCharset = DataUtil.defaultCharset;\n \n         private Request() {\n             timeoutMilliseconds = 3000;\n \n         public Parser parser() {\n             return parser;\n+        }\n+\n+        public Connection.Request postDataCharset(String charset) {\n+            Validate.notNull(charset, \"Charset must not be null\");\n+            if (!Charset.isSupported(charset)) throw new IllegalCharsetNameException(charset);\n+            this.postDataCharset = charset;\n+            return this;\n+        }\n+\n+        public String postDataCharset() {\n+            return postDataCharset;\n         }\n     }\n \n                     throw new UnsupportedMimeTypeException(\"Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml\",\n                             contentType, req.url().toString());\n \n-                InputStream bodyStream = null;\n-                InputStream dataStream = null;\n-                try {\n-                    dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n-                    bodyStream = res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\") ?\n-                            new BufferedInputStream(new GZIPInputStream(dataStream)) :\n-                            new BufferedInputStream(dataStream);\n-\n-                    res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n-                    res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n-                } finally {\n-                    if (bodyStream != null) bodyStream.close();\n-                    if (dataStream != null) dataStream.close();\n+                res.charset = DataUtil.getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n+                if (conn.getContentLength() != 0) { // -1 means unknown, chunked. sun throws an IO exception on 500 response with no content when trying to read body\n+                    InputStream bodyStream = null;\n+                    InputStream dataStream = null;\n+                    try {\n+                        dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n+                        bodyStream = res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\") ?\n+                                new BufferedInputStream(new GZIPInputStream(dataStream)) :\n+                                new BufferedInputStream(dataStream);\n+\n+                        res.byteData = DataUtil.readToByteBuffer(bodyStream, req.maxBodySize());\n+                    } finally {\n+                        if (bodyStream != null) bodyStream.close();\n+                        if (dataStream != null) dataStream.close();\n+                    }\n+                } else {\n+                    res.byteData = DataUtil.emptyByteBuffer();\n                 }\n             } finally {\n                 // per Java's documentation, this is not necessary, and precludes keepalives. However in practise,\n                         TokenQueue cd = new TokenQueue(value);\n                         String cookieName = cd.chompTo(\"=\").trim();\n                         String cookieVal = cd.consumeTo(\";\").trim();\n-                        if (cookieVal == null)\n-                            cookieVal = \"\";\n                         // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                         // name not blank, value not null\n-                        if (cookieName != null && cookieName.length() > 0)\n+                        if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // only take the first instance of each header\n                 bound = DataUtil.mimeBoundary();\n                 req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n             } else {\n-                req.header(CONTENT_TYPE, FORM_URL_ENCODED);\n+                req.header(CONTENT_TYPE, FORM_URL_ENCODED + \"; charset=\" + req.postDataCharset());\n             }\n             return bound;\n         }\n                     else\n                         first = false;\n \n-                    w.write(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset));\n+                    w.write(URLEncoder.encode(keyVal.key(), req.postDataCharset()));\n                     w.write('=');\n-                    w.write(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n+                    w.write(URLEncoder.encode(keyVal.value(), req.postDataCharset()));\n                 }\n             }\n             w.close();\n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n /**\n  * Helper class to transform a {@link org.jsoup.nodes.Document} to a {@link org.w3c.dom.Document org.w3c.dom.Document},\n  * for integration with toolsets that use the W3C DOM.\n- * <p/>\n+ * <p>\n  * This class is currently <b>experimental</b>, please provide feedback on utility and any problems experienced.\n+ * </p>\n  */\n public class W3CDom {\n     protected DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n \n     /**\n      * Collapsible if it's a boolean attribute and value is empty or same as name\n+     * \n+     * @param out Outputsettings\n+     * @return  Returns whether collapsible or not\n      */\n     protected final boolean shouldCollapseAttribute(Document.OutputSettings out) {\n         return (\"\".equals(value) || value.equalsIgnoreCase(key))\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n \n /**\n  * The attributes of an Element.\n- * <p/>\n+ * <p>\n  * Attributes are treated as a map: there can be only one value associated with an attribute key.\n- * <p/>\n+ * </p>\n+ * <p>\n  * Attribute key and value comparisons are done case insensitively, and keys are normalised to\n  * lower-case.\n+ * </p>\n  * \n  * @author Jonathan Hedley, jonathan@hedley.net\n  */\n     public String toString() {\n         return html();\n     }\n-    \n+\n+    /**\n+     * Checks if these attributes are equal to another set of attributes, by comparing the two sets\n+     * @param o attributes to compare with\n+     * @return if both sets of attributes have the same content\n+     */\n     @Override\n     public boolean equals(Object o) {\n         if (this == o) return true;\n         \n         return !(attributes != null ? !attributes.equals(that.attributes) : that.attributes != null);\n     }\n-    \n+\n+    /**\n+     * Calculates the hashcode of these attributes, by iterating all attributes and summing their hashcodes.\n+     * @return calculated hashcode\n+     */\n     @Override\n     public int hashCode() {\n         return attributes != null ? attributes.hashCode() : 0;\n                 attributes = new LinkedHashMap<String, Attribute>(2);\n         }\n \n+        @Override\n         public Set<Entry<String, String>> entrySet() {\n             return new EntrySet();\n         }\n         }\n \n         private class EntrySet extends AbstractSet<Map.Entry<String, String>> {\n+\n+            @Override\n             public Iterator<Map.Entry<String, String>> iterator() {\n                 return new DatasetIterator();\n             }\n \n+           @Override\n             public int size() {\n                 int count = 0;\n                 Iterator iter = new DatasetIterator();\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n \n         /**\n          * Set the indent amount for pretty printing\n-         * @param indentAmount number of spaces to use for indenting each level. Must be >= 0.\n+         * @param indentAmount number of spaces to use for indenting each level. Must be {@literal >=} 0.\n          * @return this, for chaining\n          */\n         public OutputSettings indentAmount(int indentAmount) {\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n \n     /**\n      * Get a child element of this element, by its 0-based index number.\n-     * <p/>\n+     * <p>\n      * Note that an element can have both mixed Nodes and Elements as children. This method inspects\n      * a filtered list of children that are elements, and the index is based on that filtered list.\n+     * </p>\n      * \n      * @param index the index number of the element to retrieve\n      * @return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}\n \n     /**\n      * Get this element's child elements.\n-     * <p/>\n+     * <p>\n      * This is effectively a filter on {@link #childNodes()} to get Element nodes.\n+     * </p>\n      * @return child elements. If this element has no children, returns an\n      * empty list.\n      * @see #childNodes()\n \n     /**\n      * Get this element's child text nodes. The list is unmodifiable but the text nodes may be manipulated.\n-     * <p/>\n+     * <p>\n      * This is effectively a filter on {@link #childNodes()} to get Text nodes.\n      * @return child text nodes. If this element has no text nodes, returns an\n      * empty list.\n-     * <p/>\n+     * </p>\n      * For example, with the input HTML: {@code <p>One <span>Two</span> Three <br> Four</p>} with the {@code p} element selected:\n      * <ul>\n      *     <li>{@code p.text()} = {@code \"One Two Three Four\"}</li>\n \n     /**\n      * Get this element's child data nodes. The list is unmodifiable but the data nodes may be manipulated.\n-     * <p/>\n+     * <p>\n      * This is effectively a filter on {@link #childNodes()} to get Data nodes.\n+     * </p>\n      * @return child data nodes. If this element has no data nodes, returns an\n      * empty list.\n      * @see #data()\n     /**\n      * Find elements that match the {@link Selector} CSS query, with this element as the starting context. Matched elements\n      * may include this element, or any of its children.\n-     * <p/>\n+     * <p>\n      * This method is generally more powerful to use than the DOM-type {@code getElementBy*} methods, because\n      * multiple filters can be combined, e.g.:\n+     * </p>\n      * <ul>\n      * <li>{@code el.select(\"a[href]\")} - finds links ({@code a} tags with {@code href} attributes)\n      * <li>{@code el.select(\"a[href*=example.com]\")} - finds links pointing to example.com (loosely)\n      * </ul>\n-     * <p/>\n+     * <p>\n      * See the query syntax documentation in {@link org.jsoup.select.Selector}.\n-     *\n+     * </p>\n+     * \n      * @param cssQuery a {@link Selector} CSS-like query\n      * @return elements that match the query (empty if none match)\n      * @see org.jsoup.select.Selector\n         // was - Node#addChildren(child). short-circuits an array create and a loop.\n         reparentChild(child);\n         childNodes.add(child);\n-        child.setSiblingIndex(childNodes.size()-1);\n+        child.setSiblingIndex(childNodes.size() - 1);\n         return this;\n     }\n \n \n     /**\n      * Get a CSS selector that will uniquely select this element.\n-     * <p/>If the element has an ID, returns #id;\n-     * otherwise returns the parent (if any) CSS selector, followed by '>',\n+     * <p>\n+     * If the element has an ID, returns #id;\n+     * otherwise returns the parent (if any) CSS selector, followed by {@literal '>'},\n      * followed by a unique selector for the element (tag.class.class:nth-child(n)).\n+     * </p>\n      *\n      * @return the CSS Path that can be used to retrieve the element in a selector.\n      */\n     /**\n      * Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s, \n      * the {@code nextElementSibling} of the first {@code p} is the second {@code p}.\n-     * <p/>\n+     * <p>\n      * This is similar to {@link #nextSibling()}, but specifically finds only Elements\n+     * </p>\n      * @return the next element, or null if there is no next element\n      * @see #previousElementSibling()\n      */\n \n     /**\n      * Gets the literal value of this element's \"class\" attribute, which may include multiple class names, space\n-     * separated. (E.g. on <code>&lt;div class=\"header gray\"></code> returns, \"<code>header gray</code>\")\n+     * separated. (E.g. on <code>&lt;div class=\"header gray\"&gt;</code> returns, \"<code>header gray</code>\")\n      * @return The literal class attribute, or <b>empty string</b> if no class attribute set.\n      */\n     public String className() {\n     }\n \n     /**\n-     * Get all of the element's class names. E.g. on element {@code <div class=\"header gray\"}>},\n+     * Get all of the element's class names. E.g. on element {@code <div class=\"header gray\">},\n      * returns a set of two elements {@code \"header\", \"gray\"}. Note that modifications to this set are not pushed to\n      * the backing {@code class} attribute; use the {@link #classNames(java.util.Set)} method to persist them.\n      * @return set of classnames, empty if no class attribute\n \n     @Override\n     public boolean equals(Object o) {\n-        return this == o;\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        if (!super.equals(o)) return false;\n+\n+        Element element = (Element) o;\n+\n+        return tag.equals(element.tag);\n     }\n \n     @Override\n     public int hashCode() {\n-        // todo: fixup, not very useful\n         int result = super.hashCode();\n         result = 31 * result + (tag != null ? tag.hashCode() : 0);\n         return result;\n \n     @Override\n     public Element clone() {\n-        Element clone = (Element) super.clone();\n-        return clone;\n+        return (Element) super.clone();\n     }\n }\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n     /**\n      * Get the Character value of the named entity\n      * @param name named entity (e.g. \"lt\" or \"amp\")\n-     * @return the Character value of the named entity (e.g. '<' or '&')\n+     * @return the Character value of the named entity (e.g. '{@literal <}' or '{@literal &}')\n      */\n     public static Character getCharacterByName(String name) {\n         return full.get(name);\n--- a/src/main/java/org/jsoup/nodes/FormElement.java\n+++ b/src/main/java/org/jsoup/nodes/FormElement.java\n             if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n             String name = el.attr(\"name\");\n             if (name.length() == 0) continue;\n+            String type = el.attr(\"type\");\n \n             if (\"select\".equals(el.tagName())) {\n                 Elements options = el.select(\"option[selected]\");\n                     if (option != null)\n                         data.add(HttpConnection.KeyVal.create(name, option.val()));\n                 }\n+            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n+                // only add checkbox or radio if they have the checked attribute\n+                if (el.hasAttr(\"checked\"))\n+                    data.add(HttpConnection.KeyVal.create(name, el.val()));\n             } else {\n                 data.add(HttpConnection.KeyVal.create(name, el.val()));\n             }\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n \n     /**\n      * Get an attribute's value by its key.\n-     * <p/>\n+     * <p>\n      * To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code><b>abs</b></code>,\n      * which is a shortcut to the {@link #absUrl} method.\n-     * E.g.: <blockquote><code>String url = a.attr(\"abs:href\");</code></blockquote>\n+     * </p>\n+     * E.g.:\n+     * <blockquote><code>String url = a.attr(\"abs:href\");</code></blockquote>\n+     * \n      * @param attributeKey The attribute key.\n      * @return The attribute, or empty string if not present (to avoid nulls).\n      * @see #attributes()\n     }\n \n     /**\n-     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href></code> or\n-     * <code>&lt;img src></code>).\n-     * <p/>\n+     * Get an absolute URL from a URL attribute that may be relative (i.e. an <code>&lt;a href&gt;</code> or\n+     * <code>&lt;img src&gt;</code>).\n+     * <p>\n      * E.g.: <code>String absUrl = linkEl.absUrl(\"href\");</code>\n-     * <p/>\n+     * </p>\n+     * <p>\n      * If the attribute value is already absolute (i.e. it starts with a protocol, like\n      * <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is\n      * returned directly. Otherwise, it is treated as a URL relative to the element's {@link #baseUri}, and made\n      * absolute using that.\n-     * <p/>\n+     * </p>\n+     * <p>\n      * As an alternate, you can use the {@link #attr} method with the <code>abs:</code> prefix, e.g.:\n      * <code>String absUrl = linkEl.attr(\"abs:href\");</code>\n-     *\n+     * </p>\n+     * \n      * @param attributeKey The attribute key\n      * @return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or\n      * could not be made successfully into a URL.\n      * @see #before(String)\n      */\n     public Node after(String html) {\n-        addSiblingHtml(siblingIndex()+1, html);\n+        addSiblingHtml(siblingIndex() + 1, html);\n         return this;\n     }\n \n         Validate.notNull(node);\n         Validate.notNull(parentNode);\n \n-        parentNode.addChildren(siblingIndex()+1, node);\n+        parentNode.addChildren(siblingIndex() + 1, node);\n         return this;\n     }\n \n     /**\n      * Removes this node from the DOM, and moves its children up into the node's parent. This has the effect of dropping\n      * the node but keeping its children.\n-     * <p/>\n-     * For example, with the input html:<br/>\n-     * {@code <div>One <span>Two <b>Three</b></span></div>}<br/>\n-     * Calling {@code element.unwrap()} on the {@code span} element will result in the html:<br/>\n-     * {@code <div>One Two <b>Three</b></div>}<br/>\n+     * <p>\n+     * For example, with the input html:\n+     * </p>\n+     * <p>{@code <div>One <span>Two <b>Three</b></span></div>}</p>\n+     * Calling {@code element.unwrap()} on the {@code span} element will result in the html:\n+     * <p>{@code <div>One Two <b>Three</b></div>}</p>\n      * and the {@code \"Two \"} {@link TextNode} being returned.\n+     * \n      * @return the first child of this node, after the node has been unwrapped. Null if the node had no children.\n      * @see #remove()\n      * @see #wrap(String)\n         Validate.isTrue(out.parentNode == this);\n         int index = out.siblingIndex();\n         childNodes.remove(index);\n-        reindexChildren();\n+        reindexChildren(index);\n         out.parentNode = null;\n     }\n \n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren();\n+        reindexChildren(index);\n     }\n \n     protected void reparentChild(Node child) {\n         child.setParentNode(this);\n     }\n     \n-    private void reindexChildren() {\n-        for (int i = 0; i < childNodes.size(); i++) {\n+    private void reindexChildren(int start) {\n+        for (int i = start; i < childNodes.size(); i++) {\n             childNodes.get(i).setSiblingIndex(i);\n         }\n     }\n         accum.append(\"\\n\").append(StringUtil.padding(depth * out.indentAmount()));\n     }\n \n+    /**\n+     * Check if this node is equal to another node. A node is considered equal if its attributes and content equal the\n+     * other node; particularly its position in the tree does not influence its equality.\n+     * @param o other object to compare to\n+     * @return true if the content of this node is the same as the other\n+     */\n     @Override\n     public boolean equals(Object o) {\n-        // todo: have nodes hold a child index, compare against that and parent (not children)\n-\n-        return this == o;\n-    }\n-\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        Node node = (Node) o;\n+\n+        if (childNodes != null ? !childNodes.equals(node.childNodes) : node.childNodes != null) return false;\n+        return !(attributes != null ? !attributes.equals(node.attributes) : node.attributes != null);\n+    }\n+\n+    /**\n+     * Calculates a hash code for this node, which includes iterating all its attributes, and recursing into any child\n+     * nodes. This means that a node's hashcode is based on it and its child content, and not its parent or place in the\n+     * tree. So two nodes with the same content, regardless of their position in the tree, will have the same hashcode.\n+     * @return the calculated hashcode\n+     * @see Node#equals(Object)\n+     */\n     @Override\n     public int hashCode() {\n-        int result = parentNode != null ? parentNode.hashCode() : 0;\n-        // not children, or will block stack as they go back up to parent)\n+        int result = childNodes != null ? childNodes.hashCode() : 0;\n         result = 31 * result + (attributes != null ? attributes.hashCode() : 0);\n         return result;\n     }\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n             indent(accum, depth, out);\n \n         boolean normaliseWhite = out.prettyPrint() && parent() instanceof Element\n-                && !Element.preserveWhitespace((Element) parent());\n+                && !Element.preserveWhitespace(parent());\n         Entities.escape(accum, getWholeText(), out, false, normaliseWhite, false);\n     }\n \n         ensureAttributes();\n         return super.absUrl(attributeKey);\n     }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+        if (!super.equals(o)) return false;\n+\n+        TextNode textNode = (TextNode) o;\n+\n+        return !(text != null ? !text.equals(textNode.text) : textNode.text != null);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = super.hashCode();\n+        result = 31 * result + (text != null ? text.hashCode() : 0);\n+        return result;\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n \n         private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n             tb.error(this);\n-            tb.processEndTag(\"noscript\");\n-            return tb.process(t);\n+            tb.insert(new Token.Character().data(t.toString()));\n+            return true;\n         }\n     },\n     AfterHead {\n                         return anyOtherEndTag(t, tb);\n                     } else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {\n                         // Adoption Agency Algorithm.\n-                        OUTER:\n                         for (int i = 0; i < 8; i++) {\n                             Element formatEl = tb.getActiveFormattingElement(name);\n                             if (formatEl == null)\n                             // does that mean: int pos of format el in list?\n                             Element node = furthestBlock;\n                             Element lastNode = furthestBlock;\n-                            INNER:\n                             for (int j = 0; j < 3; j++) {\n                                 if (tb.onStack(node))\n                                     node = tb.aboveOnStack(node);\n                                 if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n                                     tb.removeFromStack(node);\n-                                    continue INNER;\n+                                    continue;\n                                 } else if (node == formatEl)\n-                                    break INNER;\n+                                    break;\n \n                                 Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n                                 tb.replaceActiveFormattingElement(node, replacement);\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n         Element body = doc.body();\n         List<Node> nodeList = parseFragment(bodyHtml, body, baseUri);\n         Node[] nodes = nodeList.toArray(new Node[nodeList.size()]); // the node list gets modified when re-parented\n+        for (int i = nodes.length - 1; i > 0; i--) {\n+            nodes[i].remove();\n+        }\n         for (Node node : nodes) {\n             body.appendChild(node);\n         }\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n \n     /**\n      * Get a Tag by name. If not previously defined (unknown), returns a new generic tag, that can do anything.\n-     * <p/>\n+     * <p>\n      * Pre-defined tags (P, DIV etc) will be ==, but unknown tags are not registered and will only .equals().\n-     *\n+     * </p>\n+     * \n      * @param tagName Name of tag, e.g. \"p\". Case insensitive.\n      * @return The tag, either defined or new generic.\n      */\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n package org.jsoup.parser;\n \n import org.jsoup.helper.Validate;\n-import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Entities;\n \n import java.util.Arrays;\n--- a/src/main/java/org/jsoup/safety/Cleaner.java\n+++ b/src/main/java/org/jsoup/safety/Cleaner.java\n /**\n  The whitelist based HTML cleaner. Use to ensure that end-user provided HTML contains only the elements and attributes\n  that you are expecting; no junk, and no cross-site scripting attacks!\n- <p/>\n+ <p>\n  The HTML cleaner parses the input as HTML and then runs it through a white-list, so the output HTML can only contain\n  HTML that is allowed by the whitelist.\n- <p/>\n+ </p>\n+ <p>\n  It is assumed that the input HTML is a body fragment; the clean methods only pull from the source's body, and the\n  canned white-lists only allow body contained tags.\n- <p/>\n+ </p>\n+ <p>\n  Rather than interacting directly with a Cleaner object, generally see the {@code clean} methods in {@link org.jsoup.Jsoup}.\n+ </p>\n  */\n public class Cleaner {\n     private Whitelist whitelist;\n     /**\n      Determines if the input document is valid, against the whitelist. It is considered valid if all the tags and attributes\n      in the input HTML are allowed by the whitelist.\n-     <p/>\n+     <p>\n      This method can be used as a validator for user input forms. An invalid document will still be cleaned successfully\n      using the {@link #clean(Document)} document. If using as a validator, it is recommended to still clean the document\n      to ensure enforced attributes are set correctly, and that the output is tidied.\n+     </p>\n      @param dirtyDocument document to test\n      @return true if no tags or attributes need to be removed; false if they do\n      */\n--- a/src/main/java/org/jsoup/safety/Whitelist.java\n+++ b/src/main/java/org/jsoup/safety/Whitelist.java\n \n /**\n  Whitelists define what HTML (elements and attributes) to allow through the cleaner. Everything else is removed.\n- <p/>\n+ <p>\n  Start with one of the defaults:\n+ </p>\n  <ul>\n  <li>{@link #none}\n  <li>{@link #simpleText}\n  <li>{@link #basicWithImages}\n  <li>{@link #relaxed}\n  </ul>\n- <p/>\n+ <p>\n  If you need to allow more through (please be careful!), tweak a base whitelist with:\n+ </p>\n  <ul>\n  <li>{@link #addTags}\n  <li>{@link #addAttributes}\n  <li>{@link #addEnforcedAttribute}\n  <li>{@link #addProtocols}\n  </ul>\n- <p/>\n+ <p>\n  You can remove any setting from an existing whitelist with:\n+ </p>\n  <ul>\n  <li>{@link #removeTags}\n  <li>{@link #removeAttributes}\n  <li>{@link #removeEnforcedAttribute}\n  <li>{@link #removeProtocols}\n  </ul>\n- <p/>\n+ \n+ <p>\n  The cleaner and these whitelists assume that you want to clean a <code>body</code> fragment of HTML (to add user\n  supplied HTML into a templated page), and not to clean a full HTML document. If the latter is the case, either wrap the\n  document HTML around the cleaned body HTML, or create a whitelist that allows <code>html</code> and <code>head</code>\n  elements as appropriate.\n- <p/>\n+ </p>\n+ <p>\n  If you are going to extend a whitelist, please be very careful. Make sure you understand what attributes may lead to\n  XSS attack vectors. URL attributes are particularly vulnerable and require careful validation. See \n  http://ha.ckers.org/xss.html for some XSS attack examples.\n+ </p>\n \n  @author Jonathan Hedley\n  */\n     }\n \n     /**\n+     <p>\n      This whitelist allows a fuller range of text nodes: <code>a, b, blockquote, br, cite, code, dd, dl, dt, em, i, li,\n      ol, p, pre, q, small, span, strike, strong, sub, sup, u, ul</code>, and appropriate attributes.\n-     <p/>\n+     </p>\n+     <p>\n      Links (<code>a</code> elements) can point to <code>http, https, ftp, mailto</code>, and have an enforced\n      <code>rel=nofollow</code> attribute.\n-     <p/>\n+     </p>\n+     <p>\n      Does not allow images.\n+     </p>\n \n      @return whitelist\n      */\n      This whitelist allows a full range of text and structural body HTML: <code>a, b, blockquote, br, caption, cite,\n      code, col, colgroup, dd, div, dl, dt, em, h1, h2, h3, h4, h5, h6, i, img, li, ol, p, pre, q, small, span, strike, strong, sub,\n      sup, table, tbody, td, tfoot, th, thead, tr, u, ul</code>\n-     <p/>\n+     <p>\n      Links do not have an enforced <code>rel=nofollow</code> attribute, but you can add that if desired.\n+     </p>\n \n      @return whitelist\n      */\n \n     /**\n      Add a list of allowed attributes to a tag. (If an attribute is not allowed on an element, it will be removed.)\n-     <p/>\n+     <p>\n      E.g.: <code>addAttributes(\"a\", \"href\", \"class\")</code> allows <code>href</code> and <code>class</code> attributes\n      on <code>a</code> tags.\n-     <p/>\n+     </p>\n+     <p>\n      To make an attribute valid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.\n      <code>addAttributes(\":all\", \"class\")</code>.\n+     </p>\n \n      @param tag  The tag the attributes are for. The tag will be added to the allowed tag list if necessary.\n      @param keys List of valid attributes for the tag\n \n     /**\n      Remove a list of allowed attributes from a tag. (If an attribute is not allowed on an element, it will be removed.)\n-     <p/>\n+     <p>\n      E.g.: <code>removeAttributes(\"a\", \"href\", \"class\")</code> disallows <code>href</code> and <code>class</code>\n      attributes on <code>a</code> tags.\n-     <p/>\n+     </p>\n+     <p>\n      To make an attribute invalid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.\n      <code>removeAttributes(\":all\", \"class\")</code>.\n+     </p>\n \n      @param tag  The tag the attributes are for.\n      @param keys List of invalid attributes for the tag\n     /**\n      Add an enforced attribute to a tag. An enforced attribute will always be added to the element. If the element\n      already has the attribute set, it will be overridden.\n-     <p/>\n+     <p>\n      E.g.: <code>addEnforcedAttribute(\"a\", \"rel\", \"nofollow\")</code> will make all <code>a</code> tags output as\n-     <code>&lt;a href=\"...\" rel=\"nofollow\"></code>\n+     <code>&lt;a href=\"...\" rel=\"nofollow\"&gt;</code>\n+     </p>\n \n      @param tag   The tag the enforced attribute is for. The tag will be added to the allowed tag list if necessary.\n      @param key   The attribute key\n      * Configure this Whitelist to preserve relative links in an element's URL attribute, or convert them to absolute\n      * links. By default, this is <b>false</b>: URLs will be  made absolute (e.g. start with an allowed protocol, like\n      * e.g. {@code http://}.\n-     * <p />\n+     * <p>\n      * Note that when handling relative links, the input document must have an appropriate {@code base URI} set when\n      * parsing, so that the link's protocol can be confirmed. Regardless of the setting of the {@code preserve relative\n      * links} option, the link must be resolvable against the base URI to an allowed protocol; otherwise the attribute\n      * will be removed.\n+     * </p>\n      *\n      * @param preserve {@code true} to allow relative links, {@code false} (default) to deny\n      * @return this Whitelist, for chaining.\n     /**\n      Add allowed URL protocols for an element's URL attribute. This restricts the possible values of the attribute to\n      URLs with the defined protocol.\n-     <p/>\n+     <p>\n      E.g.: <code>addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\")</code>\n-     <p/>\n+     </p>\n+     <p>\n      To allow a link to an in-page URL anchor (i.e. <code>&lt;a href=\"#anchor\"&gt;</code>, add a <code>#</code>:<br>\n      E.g.: <code>addProtocols(\"a\", \"href\", \"#\")</code>\n+     </p>\n \n      @param tag       Tag the URL protocol is for\n      @param key       Attribute key\n \n     /**\n      Remove allowed URL protocols for an element's URL attribute.\n-     <p/>\n+     <p>\n      E.g.: <code>removeProtocols(\"a\", \"href\", \"ftp\")</code>\n+     </p>\n \n      @param tag       Tag the URL protocol is for\n      @param key       Attribute key\n--- a/src/main/java/org/jsoup/select/Elements.java\n+++ b/src/main/java/org/jsoup/select/Elements.java\n \n /**\n  A list of {@link Element}s, with methods that act on every element in the list.\n- <p/>\n+ <p>\n  To get an {@code Elements} object, use the {@link Element#select(String)} method.\n+ </p>\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n-public class Elements implements List<Element>, Cloneable {\n-    private List<Element> contents;\n-\n+public class Elements extends ArrayList<Element> {\n     public Elements() {\n-        contents = new ArrayList<Element>();\n     }\n \n     public Elements(int initialCapacity) {\n-        contents = new ArrayList<Element>(initialCapacity);\n+        super(initialCapacity);\n     }\n \n     public Elements(Collection<Element> elements) {\n-        contents = new ArrayList<Element>(elements);\n+        super(elements);\n     }\n     \n     public Elements(List<Element> elements) {\n-        contents = elements;\n+        super(elements);\n     }\n     \n     public Elements(Element... elements) {\n-        this(Arrays.asList(elements));\n+    \tsuper(Arrays.asList(elements));\n     }\n \n     /**\n      */\n     @Override\n \tpublic Elements clone() {\n-        Elements clone;\n-        try {\n-            clone = (Elements) super.clone();\n-        } catch (CloneNotSupportedException e) {\n-            throw new RuntimeException(e);\n-        }\n-    \tList<Element> elements = new ArrayList<Element>();\n-        clone.contents = elements;\n-    \t\n-    \tfor(Element e : contents)\n-    \t\telements.add(e.clone());\n-\t\t\n+        Elements clone = new Elements(size());\n+\n+        for(Element e : this)\n+    \t\tclone.add(e.clone());\n     \t\n     \treturn clone;\n \t}\n      @see #hasAttr(String)\n      */\n     public String attr(String attributeKey) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (element.hasAttr(attributeKey))\n                 return element.attr(attributeKey);\n         }\n      @return true if any of the elements have the attribute; false if none do.\n      */\n     public boolean hasAttr(String attributeKey) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (element.hasAttr(attributeKey))\n                 return true;\n         }\n      * @return this\n      */\n     public Elements attr(String attributeKey, String attributeValue) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.attr(attributeKey, attributeValue);\n         }\n         return this;\n      * @return this (for chaining)\n      */\n     public Elements removeAttr(String attributeKey) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.removeAttr(attributeKey);\n         }\n         return this;\n      @return this\n      */\n     public Elements addClass(String className) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.addClass(className);\n         }\n         return this;\n      @return this\n      */\n     public Elements removeClass(String className) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.removeClass(className);\n         }\n         return this;\n      @return this\n      */\n     public Elements toggleClass(String className) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.toggleClass(className);\n         }\n         return this;\n      @return true if any do, false if none do\n      */\n     public boolean hasClass(String className) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (element.hasClass(className))\n                 return true;\n         }\n      * @return this (for chaining)\n      */\n     public Elements val(String value) {\n-        for (Element element : contents)\n+        for (Element element : this)\n             element.val(value);\n         return this;\n     }\n      */\n     public String text() {\n         StringBuilder sb = new StringBuilder();\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (sb.length() != 0)\n                 sb.append(\" \");\n             sb.append(element.text());\n     }\n \n     public boolean hasText() {\n-        for (Element element: contents) {\n+        for (Element element: this) {\n             if (element.hasText())\n                 return true;\n         }\n      */\n     public String html() {\n         StringBuilder sb = new StringBuilder();\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (sb.length() != 0)\n                 sb.append(\"\\n\");\n             sb.append(element.html());\n      */\n     public String outerHtml() {\n         StringBuilder sb = new StringBuilder();\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             if (sb.length() != 0)\n                 sb.append(\"\\n\");\n             sb.append(element.outerHtml());\n      * @see Element#tagName(String)\n      */\n     public Elements tagName(String tagName) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.tagName(tagName);\n         }\n         return this;\n      * @see Element#html(String)\n      */\n     public Elements html(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.html(html);\n         }\n         return this;\n      * @see Element#prepend(String)\n      */\n     public Elements prepend(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.prepend(html);\n         }\n         return this;\n      * @see Element#append(String)\n      */\n     public Elements append(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.append(html);\n         }\n         return this;\n      * @see Element#before(String)\n      */\n     public Elements before(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.before(html);\n         }\n         return this;\n      * @see Element#after(String)\n      */\n     public Elements after(String html) {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.after(html);\n         }\n         return this;\n      */\n     public Elements wrap(String html) {\n         Validate.notEmpty(html);\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.wrap(html);\n         }\n         return this;\n     /**\n      * Removes the matched elements from the DOM, and moves their children up into their parents. This has the effect of\n      * dropping the elements but keeping their children.\n-     * <p/>\n+     * <p>\n      * This is useful for e.g removing unwanted formatting elements but keeping their contents.\n-     * <p/>\n-     * E.g. with HTML: {@code <div><font>One</font> <font><a href=\"/\">Two</a></font></div>}<br/>\n-     * {@code doc.select(\"font\").unwrap();}<br/>\n-     * HTML = {@code <div>One <a href=\"/\">Two</a></div>}\n+     * </p>\n+     * \n+     * E.g. with HTML: <p>{@code <div><font>One</font> <font><a href=\"/\">Two</a></font></div>}</p>\n+     * <p>{@code doc.select(\"font\").unwrap();}</p>\n+     * <p>HTML = {@code <div>One <a href=\"/\">Two</a></div>}</p>\n      *\n      * @return this (for chaining)\n      * @see Node#unwrap\n      */\n     public Elements unwrap() {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.unwrap();\n         }\n         return this;\n      * @see #remove()\n      */\n     public Elements empty() {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.empty();\n         }\n         return this;\n      * @see #empty()\n      */\n     public Elements remove() {\n-        for (Element element : contents) {\n+        for (Element element : this) {\n             element.remove();\n         }\n         return this;\n      * @return Elements containing only the specified element, or, if that element did not exist, an empty list.\n      */\n     public Elements eq(int index) {\n-        return contents.size() > index ? new Elements(get(index)) : new Elements();\n+        return size() > index ? new Elements(get(index)) : new Elements();\n     }\n     \n     /**\n      */\n     public Elements parents() {\n         HashSet<Element> combo = new LinkedHashSet<Element>();\n-        for (Element e: contents) {\n+        for (Element e: this) {\n             combo.addAll(e.parents());\n         }\n         return new Elements(combo);\n      @return The first matched element, or <code>null</code> if contents is empty.\n      */\n     public Element first() {\n-        return contents.isEmpty() ? null : contents.get(0);\n+        return isEmpty() ? null : get(0);\n     }\n \n     /**\n      @return The last matched element, or <code>null</code> if contents is empty.\n      */\n     public Element last() {\n-        return contents.isEmpty() ? null : contents.get(contents.size() - 1);\n+        return isEmpty() ? null : get(size() - 1);\n     }\n \n     /**\n     public Elements traverse(NodeVisitor nodeVisitor) {\n         Validate.notNull(nodeVisitor);\n         NodeTraversor traversor = new NodeTraversor(nodeVisitor);\n-        for (Element el: contents) {\n+        for (Element el: this) {\n             traversor.traverse(el);\n         }\n         return this;\n      */\n     public List<FormElement> forms() {\n         ArrayList<FormElement> forms = new ArrayList<FormElement>();\n-        for (Element el: contents)\n+        for (Element el: this)\n             if (el instanceof FormElement)\n                 forms.add((FormElement) el);\n         return forms;\n     }\n \n-    // implements List<Element> delegates:\n-    public int size() {return contents.size();}\n-\n-    public boolean isEmpty() {return contents.isEmpty();}\n-\n-    public boolean contains(Object o) {return contents.contains(o);}\n-\n-    public Iterator<Element> iterator() {return contents.iterator();}\n-\n-    public Object[] toArray() {return contents.toArray();}\n-\n-    public <T> T[] toArray(T[] a) {return contents.toArray(a);}\n-\n-    public boolean add(Element element) {return contents.add(element);}\n-\n-    public boolean remove(Object o) {return contents.remove(o);}\n-\n-    public boolean containsAll(Collection<?> c) {return contents.containsAll(c);}\n-\n-    public boolean addAll(Collection<? extends Element> c) {return contents.addAll(c);}\n-\n-    public boolean addAll(int index, Collection<? extends Element> c) {return contents.addAll(index, c);}\n-\n-    public boolean removeAll(Collection<?> c) {return contents.removeAll(c);}\n-\n-    public boolean retainAll(Collection<?> c) {return contents.retainAll(c);}\n-\n-    public void clear() {contents.clear();}\n-\n-    @Override\n-    public boolean equals(Object o) {return contents.equals(o);}\n-\n-    @Override\n-    public int hashCode() {return contents.hashCode();}\n-\n-    public Element get(int index) {return contents.get(index);}\n-\n-    public Element set(int index, Element element) {return contents.set(index, element);}\n-\n-    public void add(int index, Element element) {contents.add(index, element);}\n-\n-    public Element remove(int index) {return contents.remove(index);}\n-\n-    public int indexOf(Object o) {return contents.indexOf(o);}\n-\n-    public int lastIndexOf(Object o) {return contents.lastIndexOf(o);}\n-\n-    public ListIterator<Element> listIterator() {return contents.listIterator();}\n-\n-    public ListIterator<Element> listIterator(int index) {return contents.listIterator(index);}\n-\n-    public List<Element> subList(int fromIndex, int toIndex) {return contents.subList(fromIndex, toIndex);}\n }\n--- a/src/main/java/org/jsoup/select/Evaluator.java\n+++ b/src/main/java/org/jsoup/select/Evaluator.java\n      *\n      * @param root    Root of the matching subtree\n      * @param element tested element\n+     * @return Returns <tt>true</tt> if the requirements are met or\n+     * <tt>false</tt> otherwise\n      */\n     public abstract boolean matches(Element root, Element element);\n \n \n         @Override\n         public boolean matches(Element root, Element element) {\n-            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key));\n+            return element.hasAttr(key) && value.equalsIgnoreCase(element.attr(key).trim());\n         }\n \n         @Override\n     }\n \n     /**\n-     * Evaluator for matching by sibling index number (e < idx)\n+     * Evaluator for matching by sibling index number (e {@literal <} idx)\n      */\n     public static final class IndexLessThan extends IndexEvaluator {\n         public IndexLessThan(int index) {\n     }\n \n     /**\n-     * Evaluator for matching by sibling index number (e > idx)\n+     * Evaluator for matching by sibling index number (e {@literal >} idx)\n      */\n     public static final class IndexGreaterThan extends IndexEvaluator {\n         public IndexGreaterThan(int index) {\n--- a/src/main/java/org/jsoup/select/NodeTraversor.java\n+++ b/src/main/java/org/jsoup/select/NodeTraversor.java\n \n /**\n  * Depth-first node traversor. Use to iterate through all nodes under and including the specified root node.\n- * <p/>\n+ * <p>\n  * This implementation does not use recursion, so a deep DOM does not risk blowing the stack.\n+ * </p>\n  */\n public class NodeTraversor {\n     private NodeVisitor visitor;\n--- a/src/main/java/org/jsoup/select/NodeVisitor.java\n+++ b/src/main/java/org/jsoup/select/NodeVisitor.java\n \n /**\n  * Node visitor interface. Provide an implementing class to {@link NodeTraversor} to iterate through nodes.\n- * <p/>\n+ * <p>\n  * This interface provides two methods, {@code head} and {@code tail}. The head method is called when the node is first\n  * seen, and the tail method when all of the node's children have been visited. As an example, head can be used to\n  * create a start tag for a node, and tail to create the end tag.\n+ * </p>\n  */\n public interface NodeVisitor {\n     /**\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n \n /**\n  * CSS-like element selector, that finds elements matching a query.\n- * <p/>\n+ * \n  * <h2>Selector syntax</h2>\n+ * <p>\n  * A selector is a chain of simple selectors, separated by combinators. Selectors are case insensitive (including against\n  * elements, attributes, and attribute values).\n- * <p/>\n+ * </p>\n+ * <p>\n  * The universal selector (*) is implicit when no element selector is supplied (i.e. {@code *.header} and {@code .header}\n  * is equivalent).\n- * <p/>\n- * <table>\n+ * </p>\n+ * <table summary=\"\">\n  * <tr><th align=\"left\">Pattern</th><th align=\"left\">Matches</th><th align=\"left\">Example</th></tr>\n  * <tr><td><code>*</code></td><td>any element</td><td><code>*</code></td></tr>\n  * <tr><td><code>tag</code></td><td>elements with the given tag name</td><td><code>div</code></td></tr>\n- * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name></code> elements</td></tr>\n+ * <tr><td><code>ns|E</code></td><td>elements of type E in the namespace <i>ns</i></td><td><code>fb|name</code> finds <code>&lt;fb:name&gt;</code> elements</td></tr>\n  * <tr><td><code>#id</code></td><td>elements with attribute ID of \"id\"</td><td><code>div#wrap</code>, <code>#logo</code></td></tr>\n  * <tr><td><code>.class</code></td><td>elements with a class name of \"class\"</td><td><code>div.left</code>, <code>.result</code></td></tr>\n  * <tr><td><code>[attr]</code></td><td>elements with an attribute named \"attr\" (with any value)</td><td><code>a[href]</code>, <code>[title]</code></td></tr>\n  * <tr><td></td><td>The above may be combined in any order</td><td><code>div.header[title]</code></td></tr>\n  * <tr><td><td colspan=\"3\"><h3>Combinators</h3></td></tr>\n  * <tr><td><code>E F</code></td><td>an F element descended from an E element</td><td><code>div a</code>, <code>.logo h1</code></td></tr>\n- * <tr><td><code>E > F</code></td><td>an F direct child of E</td><td><code>ol > li</code></td></tr>\n+ * <tr><td><code>E {@literal >} F</code></td><td>an F direct child of E</td><td><code>ol {@literal >} li</code></td></tr>\n  * <tr><td><code>E + F</code></td><td>an F element immediately preceded by sibling E</td><td><code>li + li</code>, <code>div.head + div</code></td></tr>\n  * <tr><td><code>E ~ F</code></td><td>an F element preceded by sibling E</td><td><code>h1 ~ p</code></td></tr>\n  * <tr><td><code>E, F, G</code></td><td>all matching elements E, F, or G</td><td><code>a[href], div, h3</code></td></tr>\n  * <tr><td><code>:gt(<em>n</em>)</code></td><td>elements whose sibling index is greater than <em>n</em></td><td><code>td:gt(1)</code> finds cells after skipping the first two</td></tr>\n  * <tr><td><code>:eq(<em>n</em>)</code></td><td>elements whose sibling index is equal to <em>n</em></td><td><code>td:eq(0)</code> finds the first cell of each row</td></tr>\n  * <tr><td><code>:has(<em>selector</em>)</code></td><td>elements that contains at least one element matching the <em>selector</em></td><td><code>div:has(p)</code> finds divs that contain p elements </td></tr>\n- * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class.<br /><code>div:not(:has(div))</code> finds divs that do not contain divs.</td></tr>\n+ * <tr><td><code>:not(<em>selector</em>)</code></td><td>elements that do not match the <em>selector</em>. See also {@link Elements#not(String)}</td><td><code>div:not(.logo)</code> finds all divs that do not have the \"logo\" class.<p><code>div:not(:has(div))</code> finds divs that do not contain divs.</p></td></tr>\n  * <tr><td><code>:contains(<em>text</em>)</code></td><td>elements that contains the specified text. The search is case insensitive. The text may appear in the found element, or any of its descendants.</td><td><code>p:contains(jsoup)</code> finds p elements containing the text \"jsoup\".</td></tr>\n  * <tr><td><code>:matches(<em>regex</em>)</code></td><td>elements whose text matches the specified regular expression. The text may appear in the found element, or any of its descendants.</td><td><code>td:matches(\\\\d+)</code> finds table cells containing digits. <code>div:matches((?i)login)</code> finds divs containing the text, case insensitively.</td></tr>\n  * <tr><td><code>:containsOwn(<em>text</em>)</code></td><td>elements that directly contain the specified text. The search is case insensitive. The text must appear in the found element, not any of its descendants.</td><td><code>p:containsOwn(jsoup)</code> finds p elements with own text \"jsoup\".</td></tr>\n  * <tr><td><code>:nth-last-child(<em>a</em>n+<em>b</em>)</code></td><td>elements that have <code><em>a</em>n+<em>b</em>-1</code> siblings <b>after</b> it in the document tree. Otherwise like <code>:nth-child()</code></td><td><code>tr:nth-last-child(-n+2)</code> the last two rows of a table</td></tr>\n  * <tr><td><code>:nth-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>before</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-of-type(2n+1)</code></td></tr>\n  * <tr><td><code>:nth-last-of-type(<em>a</em>n+<em>b</em>)</code></td><td>pseudo-class notation represents an element that has <code><em>a</em>n+<em>b</em>-1</code> siblings with the same expanded element name <em>after</em> it in the document tree, for any zero or positive integer value of n, and has a parent element</td><td><code>img:nth-last-of-type(2n+1)</code></td></tr>\n- * <tr><td><code>:first-child</code></td><td>elements that are the first child of some other element.</td><td><code>div > p:first-child</code></td></tr>\n- * <tr><td><code>:last-child</code></td><td>elements that are the last child of some other element.</td><td><code>ol > li:last-child</code></td></tr>\n+ * <tr><td><code>:first-child</code></td><td>elements that are the first child of some other element.</td><td><code>div {@literal >} p:first-child</code></td></tr>\n+ * <tr><td><code>:last-child</code></td><td>elements that are the last child of some other element.</td><td><code>ol {@literal >} li:last-child</code></td></tr>\n  * <tr><td><code>:first-of-type</code></td><td>elements that are the first sibling of its type in the list of children of its parent element</td><td><code>dl dt:first-of-type</code></td></tr>\n- * <tr><td><code>:last-of-type</code></td><td>elements that are the last sibling of its type in the list of children of its parent element</td><td><code>tr > td:last-of-type</code></td></tr>\n+ * <tr><td><code>:last-of-type</code></td><td>elements that are the last sibling of its type in the list of children of its parent element</td><td><code>tr {@literal >} td:last-of-type</code></td></tr>\n  * <tr><td><code>:only-child</code></td><td>elements that have a parent element and whose parent element hasve no other element children</td><td></td></tr>\n  * <tr><td><code>:only-of-type</code></td><td> an element that has a parent element and whose parent element has no other element children with the same expanded element name</td><td></td></tr>\n  * <tr><td><code>:empty</code></td><td>elements that have no children at all</td><td></td></tr>\n  * </table>\n- *\n+ * \n  * @author Jonathan Hedley, jonathan@hedley.net\n  * @see Element#select(String)\n  */\n         this.root = root;\n     }\n \n+    private Selector(Evaluator evaluator, Element root) {\n+        Validate.notNull(evaluator);\n+        Validate.notNull(root);\n+\n+        this.evaluator = evaluator;\n+        this.root = root;\n+    }\n+\n     /**\n      * Find elements matching selector.\n      *\n      * @param query CSS selector\n      * @param root  root element to descend into\n-     * @return matching elements, empty if not\n+     * @return matching elements, empty if none\n      */\n     public static Elements select(String query, Element root) {\n         return new Selector(query, root).select();\n     /**\n      * Find elements matching selector.\n      *\n+     * @param evaluator CSS selector\n+     * @param root root element to descend into\n+     * @return matching elements, empty if none\n+     */\n+    public static Elements select(Evaluator evaluator, Element root) {\n+        return new Selector(evaluator, root).select();\n+    }\n+\n+    /**\n+     * Find elements matching selector.\n+     *\n      * @param query CSS selector\n      * @param roots root elements to descend into\n-     * @return matching elements, empty if not\n+     * @return matching elements, empty if none\n      */\n     public static Elements select(String query, Iterable<Element> roots) {\n         Validate.notEmpty(query);\n         Validate.notNull(roots);\n+        Evaluator evaluator = QueryParser.parse(query);\n         LinkedHashSet<Element> elements = new LinkedHashSet<Element>();\n \n         for (Element root : roots) {\n-            elements.addAll(select(query, root));\n+            elements.addAll(select(evaluator, root));\n         }\n         return new Elements(elements);\n     }\n--- a/src/test/java/org/jsoup/TextUtil.java\n+++ b/src/test/java/org/jsoup/TextUtil.java\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class TextUtil {\n+    public static final String LE = String.format(\"%n\");\n+\n     public static String stripNewlines(String text) {\n         text = text.replaceAll(\"\\\\n\\\\s*\", \"\");\n         return text;\n--- a/src/test/java/org/jsoup/helper/DataUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/DataUtilTest.java\n package org.jsoup.helper;\n \n+import java.io.UnsupportedEncodingException;\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n import org.junit.Test;\n         assertEquals(DataUtil.boundaryLength, m2.length());\n         assertNotSame(m1, m2);\n     }\n-\n+    \n+    @Test\n+    public void wrongMetaCharsetFallback() {\n+        try {\n+            final byte[] input = \"<html><head><meta charset=iso-8></head><body></body></html>\".getBytes(\"UTF-8\");\n+            final ByteBuffer inBuffer = ByteBuffer.wrap(input);\n+            \n+            Document doc = DataUtil.parseByteData(inBuffer, null, \"http://example.com\", Parser.htmlParser());\n+            \n+            final String expected = \"<html>\\n\" +\n+                                    \" <head>\\n\" +\n+                                    \"  <meta charset=\\\"iso-8\\\">\\n\" +\n+                                    \" </head>\\n\" +\n+                                    \" <body></body>\\n\" +\n+                                    \"</html>\";\n+            \n+            assertEquals(expected, doc.toString());\n+        } catch( UnsupportedEncodingException ex ) {\n+            fail(ex.getMessage());\n+        }\n+    }\n }\n--- a/src/test/java/org/jsoup/helper/StringUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/StringUtilTest.java\n public class StringUtilTest {\n \n     @Test public void join() {\n-        assertEquals(\"\", StringUtil.join(Arrays.<String>asList(\"\"), \" \"));\n-        assertEquals(\"one\", StringUtil.join(Arrays.<String>asList(\"one\"), \" \"));\n-        assertEquals(\"one two three\", StringUtil.join(Arrays.<String>asList(\"one\", \"two\", \"three\"), \" \"));\n+        assertEquals(\"\", StringUtil.join(Arrays.asList(\"\"), \" \"));\n+        assertEquals(\"one\", StringUtil.join(Arrays.asList(\"one\"), \" \"));\n+        assertEquals(\"one two three\", StringUtil.join(Arrays.asList(\"one\", \"two\", \"three\"), \" \"));\n     }\n \n     @Test public void padding() {\n--- a/src/test/java/org/jsoup/helper/W3CDomTest.java\n+++ b/src/test/java/org/jsoup/helper/W3CDomTest.java\n \n import java.io.File;\n import java.io.IOException;\n+\n+import static org.jsoup.TextUtil.LE;\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertTrue;\n         Document wDoc = w3c.fromJsoup(doc);\n         String out = w3c.asString(wDoc);\n         assertEquals(\n-                \"<html>\\n\" +\n-                        \"<head>\\n\" +\n-                        \"<META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\">\\n\" +\n-                        \"<title>W3c</title>\\n\" +\n-                        \"</head>\\n\" +\n-                        \"<body>\\n\" +\n-                        \"<p class=\\\"one\\\" id=\\\"12\\\">Text</p>\\n\" +\n-                        \"<!-- comment -->\\n\" +\n-                        \"<invalid>What<script>alert('!')</script>\\n\" +\n-                        \"</invalid>\\n\" +\n-                        \"</body>\\n\" +\n-                        \"</html>\\n\"\n+                \"<html>\" + LE +\n+                        \"<head>\" + LE +\n+                        \"<META http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=UTF-8\\\">\" + LE +\n+                        \"<title>W3c</title>\" + LE +\n+                        \"</head>\" + LE +\n+                        \"<body>\" + LE +\n+                        \"<p class=\\\"one\\\" id=\\\"12\\\">Text</p>\" + LE +\n+                        \"<!-- comment -->\" + LE +\n+                        \"<invalid>What<script>alert('!')</script>\" + LE +\n+                        \"</invalid>\" + LE +\n+                        \"</body>\" + LE +\n+                        \"</html>\" + LE\n                 , out);\n     }\n \n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n     \n     @Test\n     public void exceptOnUnknownContentType() {\n-        String url = \"http://jsoup.org/rez/osi_logo.png\"; // not text/* but image/png, should throw\n+        String url = \"http://direct.jsoup.org/rez/osi_logo.png\"; // not text/* but image/png, should throw\n         boolean threw = false;\n         try {\n             Document doc = Jsoup.parse(new URL(url), 3000);\n         } catch (UnsupportedMimeTypeException e) {\n             threw = true;\n-            assertEquals(\"org.jsoup.UnsupportedMimeTypeException: Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml. Mimetype=image/png, URL=http://jsoup.org/rez/osi_logo.png\", e.toString());\n+            assertEquals(\"org.jsoup.UnsupportedMimeTypeException: Unhandled content type. Must be text/*, application/xml, or application/xhtml+xml. Mimetype=image/png, URL=http://direct.jsoup.org/rez/osi_logo.png\", e.toString());\n             assertEquals(url, e.getUrl());\n             assertEquals(\"image/png\", e.getMimeType());\n         } catch (IOException e) {\n     }\n \n     @Test\n+    public void ignores500tExceptionIfSoConfigured() throws IOException {\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/500.pl\").ignoreHttpErrors(true);\n+        Connection.Response res = con.execute();\n+        Document doc = res.parse();\n+        assertEquals(500, res.statusCode());\n+        assertEquals(\"Application Error\", res.statusMessage());\n+        assertEquals(\"Woops\", doc.select(\"h1\").first().text());\n+    }\n+\n+    @Test\n+    public void ignores500NoWithContentExceptionIfSoConfigured() throws IOException {\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/500-no-content.pl\").ignoreHttpErrors(true);\n+        Connection.Response res = con.execute();\n+        Document doc = res.parse();\n+        assertEquals(500, res.statusCode());\n+        assertEquals(\"Application Error\", res.statusMessage());\n+    }\n+\n+    @Test\n+    public void ignores200NoWithContentExceptionIfSoConfigured() throws IOException {\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/200-no-content.pl\").ignoreHttpErrors(true);\n+        Connection.Response res = con.execute();\n+        Document doc = res.parse();\n+        assertEquals(200, res.statusCode());\n+        assertEquals(\"All Good\", res.statusMessage());\n+    }\n+\n+    @Test\n     public void doesntRedirectIfSoConfigured() throws IOException {\n         Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302.pl\").followRedirects(false);\n         Connection.Response res = con.execute();\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n \n     @Test public void testNormalisesStructure() {\n         Document doc = Jsoup.parse(\"<html><head><script>one</script><noscript><p>two</p></noscript></head><body><p>three</p></body><p>four</p></html>\");\n-        assertEquals(\"<html><head><script>one</script><noscript></noscript></head><body><p>two</p><p>three</p><p>four</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n+        assertEquals(\"<html><head><script>one</script><noscript>&lt;p&gt;two</noscript></head><body><p>three</p><p>four</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n     }\n \n     @Test public void testClone() {\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n         assertEquals(\"<div><div class=\\\"head\\\"><p>Hello</p></div><p>There</p></div>\", TextUtil.stripNewlines(doc.body().html()));\n \n         Element ret = p.wrap(\"<div><div class=foo></div><p>What?</p></div>\");\n-        assertEquals(\"<div><div class=\\\"head\\\"><div><div class=\\\"foo\\\"><p>Hello</p></div><p>What?</p></div></div><p>There</p></div>\", \n+        assertEquals(\"<div><div class=\\\"head\\\"><div><div class=\\\"foo\\\"><p>Hello</p></div><p>What?</p></div></div><p>There</p></div>\",\n                 TextUtil.stripNewlines(doc.body().html()));\n \n         assertEquals(ret, p);\n         assertEquals(\"c2\", arr2[1]);\n         assertEquals(\"c3\", arr2[2]);\n     }\n+\n+    @Test\n+    public void testHashAndEquals() {\n+        String doc1 = \"<div id=1><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\" +\n+                \"<div id=2><p class=one>One</p><p class=one>One</p><p class=one>Two</p><p class=two>One</p></div>\";\n+\n+        Document doc = Jsoup.parse(doc1);\n+        Elements els = doc.select(\"p\");\n+\n+        /*\n+        for (Element el : els) {\n+            System.out.println(el.hashCode() + \" - \" + el.outerHtml());\n+        }\n+\n+        0 1534787905 - <p class=\"one\">One</p>\n+        1 1534787905 - <p class=\"one\">One</p>\n+        2 1539683239 - <p class=\"one\">Two</p>\n+        3 1535455211 - <p class=\"two\">One</p>\n+        4 1534787905 - <p class=\"one\">One</p>\n+        5 1534787905 - <p class=\"one\">One</p>\n+        6 1539683239 - <p class=\"one\">Two</p>\n+        7 1535455211 - <p class=\"two\">One</p>\n+        */\n+        assertEquals(8, els.size());\n+        Element e0 = els.get(0);\n+        Element e1 = els.get(1);\n+        Element e2 = els.get(2);\n+        Element e3 = els.get(3);\n+        Element e4 = els.get(4);\n+        Element e5 = els.get(5);\n+        Element e6 = els.get(6);\n+        Element e7 = els.get(7);\n+\n+        assertEquals(e0, e1);\n+        assertEquals(e0, e4);\n+        assertEquals(e0, e5);\n+        assertFalse(e0.equals(e2));\n+        assertFalse(e0.equals(e3));\n+        assertFalse(e0.equals(e6));\n+        assertFalse(e0.equals(e7));\n+\n+        assertEquals(e0.hashCode(), e1.hashCode());\n+        assertEquals(e0.hashCode(), e4.hashCode());\n+        assertEquals(e0.hashCode(), e5.hashCode());\n+        assertFalse(e0.hashCode() == (e2.hashCode()));\n+        assertFalse(e0.hashCode() == (e3).hashCode());\n+        assertFalse(e0.hashCode() == (e6).hashCode());\n+        assertFalse(e0.hashCode() == (e7).hashCode());\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/EntitiesTest.java\n+++ b/src/test/java/org/jsoup/nodes/EntitiesTest.java\n import static org.jsoup.nodes.Entities.EscapeMode.*;\n import static org.junit.Assert.*;\n \n-import java.nio.charset.Charset;\n \n public class EntitiesTest {\n     @Test public void escape() {\n--- a/src/test/java/org/jsoup/nodes/FormElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/FormElementTest.java\n import org.jsoup.Jsoup;\n import org.junit.Test;\n \n-import java.io.IOException;\n-import java.util.Collection;\n import java.util.List;\n \n import static org.junit.Assert.*;\n \n     @Test public void createsFormData() {\n         String html = \"<form><input name='one' value='two'><select name='three'><option value='not'>\" +\n-                \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea></form>\";\n+                \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>\" +\n+                \"<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>\" +\n+                \"<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>\" +\n+                \"</form>\";\n         Document doc = Jsoup.parse(html);\n         FormElement form = (FormElement) doc.select(\"form\").first();\n         List<Connection.KeyVal> data = form.formData();\n \n-        assertEquals(4, data.size());\n+        assertEquals(6, data.size());\n         assertEquals(\"one=two\", data.get(0).toString());\n         assertEquals(\"three=four\", data.get(1).toString());\n         assertEquals(\"three=five\", data.get(2).toString());\n         assertEquals(\"six=seven\", data.get(3).toString());\n+        assertEquals(\"seven=on\", data.get(4).toString());\n+        assertEquals(\"eight=\", data.get(5).toString());\n     }\n \n     @Test public void createsSubmitableConnection() {\n--- a/src/test/java/org/jsoup/nodes/NodeTest.java\n+++ b/src/test/java/org/jsoup/nodes/NodeTest.java\n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.jsoup.parser.Tag;\n-import org.jsoup.select.Elements;\n import org.jsoup.select.NodeVisitor;\n import org.junit.Test;\n \n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n import java.util.List;\n \n import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertTrue;\n \n /**\n     @Test public void testNoImagesInNoScriptInHead() {\n         // jsoup used to allow, but against spec if parsing with noscript\n         Document doc = Jsoup.parse(\"<html><head><noscript><img src='foo'></noscript></head><body><p>Hello</p></body></html>\");\n-        assertEquals(\"<html><head><noscript></noscript></head><body><img src=\\\"foo\\\"><p>Hello</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n+        assertEquals(\"<html><head><noscript>&lt;img src=\\\"foo\\\"&gt;</noscript></head><body><p>Hello</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n     }\n \n     @Test public void testAFlowContents() {\n                 \"<!doctype \ufffd> <html> <head></head> <body></body> </html>\",\n                 StringUtil.normaliseWhitespace(doc.outerHtml()));\n     }\n+    \n+    @Test public void handlesManyChildren() {\n+        // Arrange\n+        StringBuilder longBody = new StringBuilder(500000);\n+        for (int i = 0; i < 25000; i++) {\n+            longBody.append(i).append(\"<br>\");\n+        }\n+        \n+        // Act\n+        long start = System.currentTimeMillis();\n+        Document doc = Parser.parseBodyFragment(longBody.toString(), \"\");\n+        \n+        // Assert\n+        assertEquals(50000, doc.body().childNodeSize());\n+        assertTrue(System.currentTimeMillis() - start < 1000);\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n import org.jsoup.TextUtil;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.Document;\n-import org.jsoup.nodes.Element;\n import org.jsoup.nodes.Node;\n import org.jsoup.nodes.TextNode;\n import org.junit.Ignore;\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n         assertEquals(\"div\", doc.select(\"div[k\" + s + \"]\").first().tagName());\n         assertEquals(\"div\", doc.select(\"div:containsOwn(\" + s + \")\").first().tagName());\n     }\n+    \n+    @Test\n+    public void selectClassWithSpace() {\n+        final String html = \"<div class=\\\"value\\\">class without space</div>\\n\"\n+                          + \"<div class=\\\"value \\\">class with space</div>\";\n+        \n+        Document doc = Jsoup.parse(html);\n+        \n+        Elements found = doc.select(\"div[class=value ]\");\n+        assertEquals(2, found.size());\n+        assertEquals(\"class without space\", found.get(0).text());\n+        assertEquals(\"class with space\", found.get(1).text());\n+        \n+        found = doc.select(\"div[class=\\\"value \\\"]\");\n+        assertEquals(2, found.size());\n+        assertEquals(\"class without space\", found.get(0).text());\n+        assertEquals(\"class with space\", found.get(1).text());\n+        \n+        found = doc.select(\"div[class=\\\"value\\\\ \\\"]\");\n+        assertEquals(0, found.size());\n+    }\n+    \n }\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n     private OutputSettings outputSettings = new OutputSettings();\n     private QuirksMode quirksMode = QuirksMode.noQuirks;\n     private String location;\n+    private boolean updateMetaCharset = false;\n \n     /**\n      Create a new, empty Document.\n \n         normaliseStructure(\"head\", htmlEl);\n         normaliseStructure(\"body\", htmlEl);\n+        \n+        ensureMetaCharset();\n         \n         return this;\n     }\n     public String nodeName() {\n         return \"#document\";\n     }\n+    \n+    /**\n+     * Sets the charset used in this document. This method is equivalent\n+     * to {@link OutputSettings#charset(java.nio.charset.Charset)\n+     * OutputSettings.charset(Charset)} but in addition it updates the\n+     * charset / encoding element within the document.\n+     * \n+     * <p>This only applies if {@link #updateMetaCharset(boolean)\n+     * updateMetaCharset} set to <tt>true</tt>; otherwise there are no elements\n+     * changed and the new value is delegated to\n+     * {@link OutputSettings#charset(java.nio.charset.Charset) \n+     * OutputSettings.charset(Charset)} only.</p>\n+     * \n+     * <p>If there's no element with charset / encoding information yet it will\n+     * be created. Obsolete charset / encoding definitions are removed!</p>\n+     * \n+     * <p><b>Elements used:</b></p>\n+     * \n+     * <ul>\n+     * <li><b>Html:</b> <i>&lt;meta charset=\"CHARSET\"&gt;</i></li>\n+     * <li><b>Xml:</b> <i>&lt;?xml version=\"1.0\" encoding=\"CHARSET\"&gt;</i></li>\n+     * </ul>\n+     * \n+     * @param charset Charset\n+     * \n+     * @see #updateMetaCharset(boolean) \n+     * @see OutputSettings#charset(java.nio.charset.Charset) \n+     */\n+    public void charset(Charset charset) {\n+        outputSettings.charset(charset);\n+        ensureMetaCharset();\n+    }\n+    \n+    /**\n+     * Returns the charset used in this document. This method is equivalent\n+     * to {@link OutputSettings#charset()}.\n+     * \n+     * @return Current Charset\n+     * \n+     * @see OutputSettings#charset() \n+     */\n+    public Charset charset() {\n+        return outputSettings.charset();\n+    }\n+    \n+    /**\n+     * Sets whether the element with charset information in this document is\n+     * updated on changes through {@link #charset(java.nio.charset.Charset)\n+     * Document.charset(Charset)} or not.\n+     * \n+     * <p>If set to <tt>false</tt> <i>(default)</i> there are no elements\n+     * modified.</p>\n+     * \n+     * @param update If <tt>true</tt> the element updated on charset\n+     * changes, <tt>false</tt> if not\n+     * \n+     * @see #charset(java.nio.charset.Charset) \n+     */\n+    public void updateMetaCharset(boolean update) {\n+        this.updateMetaCharset = true;\n+    }\n+    \n+    /**\n+     * Returns whether the element with charset information in this document is\n+     * updated on changes through {@link #charset(java.nio.charset.Charset)\n+     * Document.charset(Charset)} or not.\n+     * \n+     * @return Returns <tt>true</tt> if the element is updated on charset\n+     * changes, <tt>false</tt> if not\n+     */\n+    public boolean updateMetaCharset() {\n+        return updateMetaCharset;\n+    }\n \n     @Override\n     public Document clone() {\n         clone.outputSettings = this.outputSettings.clone();\n         return clone;\n     }\n+    \n+    /**\n+     * Ensures a meta charset (html) or xml declaration (xml) with the current\n+     * encoding used. This only applies with {@link #updateMetaCharset(boolean)\n+     * updateMetaCharset} set to <tt>true</tt>, otherwise this method does\n+     * nothing.\n+     * \n+     * <ul>\n+     * <li>An exsiting element gets updated with the current charset</li>\n+     * <li>If there's no element yet it will be inserted</li>\n+     * <li>Obsolete elements are removed</li>\n+     * </ul>\n+     * \n+     * <p><b>Elements used:</b></p>\n+     * \n+     * <ul>\n+     * <li><b>Html:</b> <i>&lt;meta charset=\"CHARSET\"&gt;</i></li>\n+     * <li><b>Xml:</b> <i>&lt;?xml version=\"1.0\" encoding=\"CHARSET\"&gt;</i></li>\n+     * </ul>\n+     */\n+    private void ensureMetaCharset() {\n+        if( updateMetaCharset == true ) {\n+            OutputSettings.Syntax syntax = outputSettings().syntax();\n+            \n+            if( syntax == OutputSettings.Syntax.html ) {\n+                Element metaCharset = select(\"meta[charset]\").first();\n+\n+                if( metaCharset != null ) {\n+                    metaCharset.attr(\"charset\", charset().displayName());\n+                }\n+                else {\n+                    Element head = head();\n+\n+                    if( head != null ) {\n+                        head.appendElement(\"meta\").attr(\"charset\", charset().displayName());\n+                    }\n+                }\n+\n+                // Remove obsolete elements\n+                select(\"meta[name=charset]\").remove();\n+            }\n+            else if( syntax == OutputSettings.Syntax.xml ) {\n+                Node node = childNodes().get(0);\n+                \n+                if( node instanceof XmlDeclaration ) {\n+                    XmlDeclaration decl = (XmlDeclaration) node;\n+                    \n+                    if( decl.attr(XmlDeclaration.DECL_KEY).equals(\"xml\") ) {\n+                        decl.attr(\"encoding\", charset().displayName());\n+\n+                        final String version = decl.attr(\"version\");\n+\n+                        if( version != null ) {\n+                            decl.attr(\"version\", \"1.0\");\n+                        }\n+                    }\n+                    else {\n+                        decl = new XmlDeclaration(\"xml\", baseUri, false);\n+                        decl.attr(\"version\", \"1.0\");\n+                        decl.attr(\"encoding\", charset().displayName());\n+                        \n+                        prependChild(decl);\n+                    }\n+                }\n+                else {\n+                    XmlDeclaration decl = new XmlDeclaration(\"xml\", baseUri, false);\n+                    decl.attr(\"version\", \"1.0\");\n+                    decl.attr(\"encoding\", charset().displayName());\n+                    \n+                    prependChild(decl);\n+                }\n+            }\n+            else {\n+                // Unsupported syntax - nothing to do yet\n+            }\n+        }\n+    }\n+    \n \n     /**\n      * A Document's output settings control the form of the text() and html() methods.\n         private Syntax syntax = Syntax.html;\n \n         public OutputSettings() {}\n-\n+        \n         /**\n          * Get the document's current HTML escape mode: <code>base</code>, which provides a limited set of named HTML\n          * entities and escapes other characters as numbered entities for maximum compatibility; or <code>extended</code>,\n          * @return the document's output settings, for chaining\n          */\n         public OutputSettings charset(Charset charset) {\n-            // todo: this should probably update the doc's meta charset\n             this.charset = charset;\n             charsetEncoder = charset.newEncoder();\n             return this;\n--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class XmlDeclaration extends Node {\n-    private static final String DECL_KEY = \"declaration\";\n+    static final String DECL_KEY = \"declaration\";\n     private final boolean isProcessingInstruction; // <! if true, <? if false, declaration (and last data char should be ?)\n \n     /**\n      @return XML declaration\n      */\n     public String getWholeDeclaration() {\n-        return attributes.get(DECL_KEY);\n+        final String decl = attributes.get(DECL_KEY);\n+        \n+        if( decl.equals(\"xml\") == true && attributes.size() > 1 ) {\n+            StringBuilder sb = new StringBuilder(decl);\n+            final String version = attributes.get(\"version\");\n+            \n+            if( version != null ) {\n+                sb.append(\" version=\\\"\").append(version).append(\"\\\"\");\n+            }\n+            \n+            final String encoding = attributes.get(\"encoding\");\n+            \n+            if( encoding != null ) {\n+                sb.append(\" encoding=\\\"\").append(encoding).append(\"\\\"\");\n+            }\n+            \n+            return sb.toString();\n+        }\n+        else {\n+            return attributes.get(DECL_KEY);\n+        }\n     }\n-\n+    \n     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n         accum\n                 .append(\"<\")\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n \n import java.io.File;\n import java.io.IOException;\n+import java.nio.charset.Charset;\n \n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n         Document doc = Jsoup.parse(builder.toString());\n         doc.clone();\n     }\n+    \n+    @Test\n+    public void testMetaCharsetUpdate() {\n+        // Existing meta charset tag\n+        final Document doc = Document.createShell(\"\");\n+        doc.updateMetaCharset(true);\n+        doc.head().appendElement(\"meta\").attr(\"charset\", \"changeThis\");        \n+        \n+        final String charsetUtf8 = \"UTF-8\";\n+        doc.charset(Charset.forName(charsetUtf8));\n+        Element selectedElement = doc.select(\"meta[charset]\").first();\n+        \n+        final String htmlCharsetUTF8 = \"<html>\\n\" +\n+                                        \" <head>\\n\" +\n+                                        \"  <meta charset=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+                                        \" </head>\\n\" +\n+                                        \" <body></body>\\n\" +\n+                                        \"</html>\";\n+        \n+        assertNotNull(selectedElement);\n+        assertEquals(charsetUtf8, doc.charset().displayName());\n+        assertEquals(charsetUtf8, selectedElement.attr(\"charset\"));\n+        assertEquals(htmlCharsetUTF8, doc.toString());\n+        assertEquals(doc.charset(), doc.outputSettings().charset());\n+        \n+        final String charsetIso8859 = \"ISO-8859-1\";\n+        doc.charset(Charset.forName(charsetIso8859));\n+        selectedElement = doc.select(\"meta[charset]\").first();\n+        \n+        final String htmlCharsetISO = \"<html>\\n\" +\n+                                        \" <head>\\n\" +\n+                                        \"  <meta charset=\\\"\" + charsetIso8859 + \"\\\">\\n\" +\n+                                        \" </head>\\n\" +\n+                                        \" <body></body>\\n\" +\n+                                        \"</html>\";\n+        \n+        assertNotNull(selectedElement);\n+        assertEquals(charsetIso8859, doc.charset().displayName());\n+        assertEquals(charsetIso8859, selectedElement.attr(\"charset\"));\n+        assertEquals(htmlCharsetISO, doc.toString());\n+        assertEquals(doc.charset(), doc.outputSettings().charset());\n+        \n+        \n+        // No meta charset tag\n+        final Document docNoCharset = Document.createShell(\"\");\n+        docNoCharset.updateMetaCharset(true);\n+        docNoCharset.charset(Charset.forName(charsetUtf8));\n+        \n+        assertEquals(charsetUtf8, docNoCharset.select(\"meta[charset]\").first().attr(\"charset\"));\n+        assertEquals(htmlCharsetUTF8, docNoCharset.toString());\n+        \n+        \n+        // Disabled update of meta charset tag\n+        final Document docDisabled = Document.createShell(\"\");\n+        assertFalse(docDisabled.updateMetaCharset());\n+        \n+        final String htmlNoCharset = \"<html>\\n\" +\n+                                        \" <head></head>\\n\" +\n+                                        \" <body></body>\\n\" +\n+                                        \"</html>\";\n+        \n+        assertEquals(htmlNoCharset, docDisabled.toString());\n+        assertNull(docDisabled.select(\"meta[charset]\").first());\n+        \n+        final String htmlCharset = \"<html>\\n\" +\n+                                    \" <head>\\n\" +\n+                                    \"  <meta charset=\\\"dontTouch\\\">\\n\" +\n+                                    \"  <meta name=\\\"charset\\\" content=\\\"dontTouch\\\">\\n\" +\n+                                    \" </head>\\n\" +\n+                                    \" <body></body>\\n\" +\n+                                    \"</html>\";\n+        \n+        docDisabled.head().appendElement(\"meta\").attr(\"charset\", \"dontTouch\");\n+        docDisabled.head().appendElement(\"meta\").attr(\"name\", \"charset\").attr(\"content\", \"dontTouch\");\n+        \n+        assertEquals(htmlCharset, docDisabled.toString());\n+        \n+        selectedElement = docDisabled.select(\"meta[charset]\").first();\n+        assertNotNull(selectedElement);\n+        assertEquals(\"dontTouch\", selectedElement.attr(\"charset\"));\n+        selectedElement = docDisabled.select(\"meta[name=charset]\").first();\n+        assertNotNull(selectedElement);\n+        assertEquals(\"dontTouch\", selectedElement.attr(\"content\"));\n+        \n+        docDisabled.charset(Charset.forName(charsetUtf8));\n+        selectedElement = docDisabled.select(\"meta[charset]\").first();\n+        assertNotNull(selectedElement);\n+        assertEquals(\"dontTouch\", selectedElement.attr(\"charset\"));\n+        selectedElement = docDisabled.select(\"meta[name=charset]\").first();\n+        assertNotNull(selectedElement);\n+        assertEquals(\"dontTouch\", selectedElement.attr(\"content\"));\n+        \n+        \n+        // Remove obsolete charset definitions\n+        final Document docCleanup = Document.createShell(\"\");\n+        docCleanup.updateMetaCharset(true);\n+        docCleanup.head().appendElement(\"meta\").attr(\"charset\", \"dontTouch\");\n+        docCleanup.head().appendElement(\"meta\").attr(\"name\", \"charset\").attr(\"content\", \"dontTouch\");\n+        docCleanup.charset(Charset.forName(charsetUtf8));\n+        \n+        assertEquals(htmlCharsetUTF8, docCleanup.toString());\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateXml() {\n+        // Existing encoding definition\n+        final Document doc = new Document(\"\");\n+        doc.appendElement(\"root\").text(\"node\");\n+        doc.outputSettings().syntax(Syntax.xml);\n+        doc.updateMetaCharset(true);\n+        \n+        XmlDeclaration decl = new XmlDeclaration(\"xml\", \"\", false);\n+        decl.attr(\"version\", \"1.0\");\n+        decl.attr(\"encoding\", \"changeThis\");\n+        doc.prependChild(decl);\n+        \n+        final String charsetUtf8 = \"UTF-8\";\n+        doc.charset(Charset.forName(charsetUtf8));\n+        \n+        Node declNode = doc.childNode(0);\n+        assertTrue(declNode instanceof XmlDeclaration);\n+        XmlDeclaration selectedNode = (XmlDeclaration) declNode;\n+        \n+        final String xmlCharsetUTF8 = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+                                        \"<root>\\n\" +\n+                                        \" node\\n\" +\n+                                        \"</root>\";\n+\n+        assertNotNull(declNode);\n+        assertEquals(charsetUtf8, doc.charset().displayName());\n+        assertEquals(charsetUtf8, selectedNode.attr(\"encoding\"));\n+        assertEquals(\"1.0\", selectedNode.attr(\"version\"));\n+        assertEquals(xmlCharsetUTF8, doc.toString());\n+        assertEquals(doc.charset(), doc.outputSettings().charset());\n+        \n+        final String charsetIso8859 = \"ISO-8859-1\";\n+        doc.charset(Charset.forName(charsetIso8859));\n+        \n+        declNode = doc.childNode(0);\n+        assertTrue(declNode instanceof XmlDeclaration);\n+        selectedNode = (XmlDeclaration) declNode;\n+        \n+        final String xmlCharsetISO = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetIso8859 + \"\\\">\\n\" +\n+                                        \"<root>\\n\" +\n+                                        \" node\\n\" +\n+                                        \"</root>\";\n+        \n+        assertNotNull(declNode);\n+        assertEquals(charsetIso8859, doc.charset().displayName());\n+        assertEquals(charsetIso8859, selectedNode.attr(\"encoding\"));\n+        assertEquals(\"1.0\", selectedNode.attr(\"version\"));\n+        assertEquals(xmlCharsetISO, doc.toString());\n+        assertEquals(doc.charset(), doc.outputSettings().charset());\n+        \n+        \n+        // No encoding definition\n+        final Document docNoCharset = new Document(\"\");\n+        docNoCharset.appendElement(\"root\").text(\"node\");\n+        docNoCharset.outputSettings().syntax(Syntax.xml);\n+        docNoCharset.updateMetaCharset(true);\n+        docNoCharset.charset(Charset.forName(charsetUtf8));\n+        \n+        declNode = docNoCharset.childNode(0);\n+        assertTrue(declNode instanceof XmlDeclaration);\n+        selectedNode = (XmlDeclaration) declNode;\n+        \n+        assertEquals(charsetUtf8, selectedNode.attr(\"encoding\"));\n+        assertEquals(xmlCharsetUTF8, docNoCharset.toString());\n+        \n+        \n+        // Disabled update of encoding definition\n+        final Document docDisabled = new Document(\"\");\n+        docDisabled.appendElement(\"root\").text(\"node\");\n+        docDisabled.outputSettings().syntax(Syntax.xml);\n+        assertFalse(docDisabled.updateMetaCharset());\n+        \n+        final String xmlNoCharset = \"<root>\\n\" +\n+                                    \" node\\n\" +\n+                                    \"</root>\";\n+        \n+        assertEquals(xmlNoCharset, docDisabled.toString());\n+        \n+        decl = new XmlDeclaration(\"xml\", \"\", false);\n+        decl.attr(\"version\", \"dontTouch\");\n+        decl.attr(\"encoding\", \"dontTouch\");\n+        docDisabled.prependChild(decl);\n+        \n+        final String xmlCharset = \"<?xml version=\\\"dontTouch\\\" encoding=\\\"dontTouch\\\">\\n\" +\n+                                    \"<root>\\n\" +\n+                                    \" node\\n\" +\n+                                    \"</root>\";\n+        \n+        assertEquals(xmlCharset, docDisabled.toString());\n+        \n+        declNode = docDisabled.childNode(0);\n+        assertTrue(declNode instanceof XmlDeclaration);\n+        selectedNode = (XmlDeclaration) declNode;\n+        \n+        assertEquals(\"dontTouch\", selectedNode.attr(\"encoding\"));\n+        assertEquals(\"dontTouch\", selectedNode.attr(\"version\"));\n+    }\n }", "timestamp": 1427733938, "metainfo": ""}