{"sha": "e6a508909272ac6f27f2f91371781b38480c1e1b", "log": "Merge pull request #67 from dmak/issue-65  Added getters (issue#65)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n      */\n \n     /**\n+     * Method for getting current {@link DeserializerFactory}.\n+     */\n+    public DeserializerFactory getFactory() {\n+        return _factory;\n+    }\n+\n+    /**\n      * Method for accessing configuration setting object for\n      * currently active deserialization.\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n         return _deserializationConfig;\n     }\n     \n+    /**\n+     * Method for getting current {@link DeserializationContext}.\n+      *<p>\n+     * Note that since instances are immutable, you can NOT change settings\n+     * by accessing an instance and calling methods: this will simply create\n+     * new instance of context object.\n+    */\n+    public DeserializationContext getDeserializationContext() {\n+        return _deserializationContext;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Configuration: ser/deser factory, provider access\n     public ObjectMapper setSerializerFactory(SerializerFactory f) {\n         _serializerFactory = f;\n         return this;\n+    }\n+\n+    /**\n+     * Method for getting current {@link SerializerFactory}.\n+      *<p>\n+     * Note that since instances are immutable, you can NOT change settings\n+     * by accessing an instance and calling methods: this will simply create\n+     * new instance of factory object.\n+     */\n+    public SerializerFactory getSerializerFactory() {\n+        return _serializerFactory;\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n     protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n         _factoryConfig = config;\n     }\n-    \n+\n+    /**\n+     * Method for getting current {@link DeserializerFactoryConfig}.\n+      *<p>\n+     * Note that since instances are immutable, you can NOT change settings\n+     * by accessing an instance and calling methods: this will simply create\n+     * new instance of config object.\n+     */\n+    public DeserializerFactoryConfig getFactoryConfig() {\n+        return _factoryConfig;\n+    }\n+\n     protected abstract DeserializerFactory withConfig(DeserializerFactoryConfig config);\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n     }\n     \n     /**\n+     * Method for getting current {@link SerializerFactoryConfig}.\n+      *<p>\n+     * Note that since instances are immutable, you can NOT change settings\n+     * by accessing an instance and calling methods: this will simply create\n+     * new instance of config object.\n+     */\n+    public SerializerFactoryConfig getFactoryConfig() {\n+        return _factoryConfig;\n+    }\n+\n+    /**\n      * Method used for creating a new instance of this factory, but with different\n      * configuration. Reason for specifying factory method (instead of plain constructor)\n      * is to allow proper sub-classing of factories.\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonInclude;\n+\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.core.Versioned;\n+\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.introspect.*;\n     }\n \n     public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2) {\n-        return new Pair(a1, a2);\n+        return new AnnotationIntrospectorPair(a1, a2);\n     }\n \n     /*\n      * for XML compatibility purposes) for given class, if one\n      * is defined. Returns null if no declaration found; can return\n      * explicit empty String, which is usually ignored as well as null.\n-     */\n-    public String findRootName(AnnotatedClass ac) {\n+     *<p> \n+     * NOTE: method signature changed in 2.1, to return {@link PropertyName}\n+     * instead of String.\n+     */\n+    public PropertyName findRootName(AnnotatedClass ac) {\n         return null;\n     }\n \n     public Boolean isTypeId(AnnotatedMember member) {\n         return null;\n     }\n+\n+\n+    /**\n+     * Method used to check if specified property has annotation that indicates\n+     * that it should be wrapped in an element; and if so, name to use.\n+     * Note that not all serializers and deserializers support use this method:\n+     * currently (2.1) it is only used by XML-backed handlers.\n+     * \n+     * @return Wrapper name to use, if any, or {@link PropertyName#USE_DEFAULT}\n+     *   to indicate that no wrapper element should be used.\n+     * \n+     * @since 2.1\n+     */\n+    public PropertyName findWrapperName(Annotated ann) {\n+        return null;\n+    }\n     \n     /*\n     /**********************************************************\n     \n     /*\n     /**********************************************************\n-    /* Serialization: method annotations\n-    /**********************************************************\n-     */\n-\n+    /* Serialization: property annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given property accessors (method,\n+     * field) has an annotation that suggests property name to use\n+     * for serialization.\n+     * Should return null if no annotation\n+     * is found; otherwise a non-null name (possibly\n+     * {@link PropertyName#USE_DEFAULT}, which means \"use default heuristics\").\n+     * \n+     * @param a Property accessor to check\n+     * \n+     * @return Name to use if found; null if not.\n+     * \n+     * @since 2.1\n+     */\n+    public PropertyName findNameForSerialization(Annotated a)\n+    {\n+        // [Issue#69], need bit of delegation \n+        // !!! TODO: in 2.2, remove old methods?\n+        String name;\n+        if (a instanceof AnnotatedField) {\n+            name = findSerializationName((AnnotatedField) a);\n+        } else if (a instanceof AnnotatedMethod) {\n+            name = findSerializationName((AnnotatedMethod) a);\n+        } else {\n+            name = null;\n+        }\n+        if (name != null) {\n+            if (name.length() == 0) { // empty String means 'default'\n+                return PropertyName.USE_DEFAULT;\n+            }\n+            return new PropertyName(name);\n+        }\n+        return null;\n+    }\n+    \n     /**\n      * Method for checking whether given method has an annotation\n      * that suggests property name associated with method that\n      * name, except for empty String (\"\") which is taken to mean\n      * \"use standard bean name detection if applicable;\n      * method name if not\".\n-     */\n+     * \n+     * @deprecated Since 2.1 should use {@link #findNameForSerialization} instead\n+     */\n+    @Deprecated\n     public String findSerializationName(AnnotatedMethod am) {\n         return null;\n     }\n-\n-    /**\n-     * Method for checking whether given method has an annotation\n-     * that suggests that the return value of annotated method\n-     * should be used as \"the value\" of the object instance; usually\n-     * serialized as a primitive value such as String or number.\n-     *\n-     * @return True if such annotation is found (and is not disabled);\n-     *   false if no enabled annotation is found\n-     */\n-    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n-        return false;\n-    }\n-\n-    /**\n-     * Method for determining the String value to use for serializing\n-     * given enumeration entry; used when serializing enumerations\n-     * as Strings (the standard method).\n-     *\n-     * @return Serialized enum value.\n-     */\n-    public String findEnumValue(Enum<?> value) {\n-        return null;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Serialization: field annotations\n-    /**********************************************************\n-     */\n \n     /**\n      * Method for checking whether given member field represent\n      * If non-null value is returned, it is used as the property\n      * name, except for empty String (\"\") which is taken to mean\n      * \"use the field name as is\".\n-     */\n+     * \n+     * @deprecated Since 2.1 should use {@link #findNameForSerialization} instead\n+     */\n+    @Deprecated\n     public String findSerializationName(AnnotatedField af) {\n         return null;\n     }\n-\n+    \n+    /**\n+     * Method for checking whether given method has an annotation\n+     * that suggests that the return value of annotated method\n+     * should be used as \"the value\" of the object instance; usually\n+     * serialized as a primitive value such as String or number.\n+     *\n+     * @return True if such annotation is found (and is not disabled);\n+     *   false if no enabled annotation is found\n+     */\n+    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n+        return false;\n+    }\n+    \n+    /**\n+     * Method for determining the String value to use for serializing\n+     * given enumeration entry; used when serializing enumerations\n+     * as Strings (the standard method).\n+     *\n+     * @return Serialized enum value.\n+     */\n+    public String findEnumValue(Enum<?> value) {\n+        return null;\n+    }\n     /*\n     /**********************************************************\n     /* Deserialization: general annotations\n     \n     /*\n     /**********************************************************\n-    /* Deserialization: method annotations\n-    /**********************************************************\n-     */\n-\n+    /* Deserialization: property annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given property accessors (method,\n+     * field) has an annotation that suggests property name to use\n+     * for deserialization (reading JSON into POJOs).\n+     * Should return null if no annotation\n+     * is found; otherwise a non-null name (possibly\n+     * {@link PropertyName#USE_DEFAULT}, which means \"use default heuristics\").\n+     * \n+     * @param a Property accessor to check\n+     * \n+     * @return Name to use if found; null if not.\n+     * \n+     * @since 2.1\n+     */\n+    public PropertyName findNameForDeserialization(Annotated a)\n+    {\n+        // [Issue#69], need bit of delegation \n+        // !!! TODO: in 2.2, remove old methods?\n+        String name;\n+        if (a instanceof AnnotatedField) {\n+            name = findDeserializationName((AnnotatedField) a);\n+        } else if (a instanceof AnnotatedMethod) {\n+            name = findDeserializationName((AnnotatedMethod) a);\n+        } else if (a instanceof AnnotatedParameter) {\n+            name = findDeserializationName((AnnotatedParameter) a);\n+        } else {\n+            name = null;\n+        }\n+        if (name != null) {\n+            if (name.length() == 0) { // empty String means 'default'\n+                return PropertyName.USE_DEFAULT;\n+            }\n+            return new PropertyName(name);\n+        }\n+        return null;\n+    }\n+    \n     /**\n      * Method for checking whether given method has an annotation\n      * that suggests property name associated with method that\n      * name, except for empty String (\"\") which is taken to mean\n      * \"use standard bean name detection if applicable;\n      * method name if not\".\n-     */\n+     * \n+     * @deprecated Since 2.1 should use {@link #findNameForDeserialization} instead\n+     */\n+    @Deprecated\n     public String findDeserializationName(AnnotatedMethod am) {\n         return null;\n     }\n-\n-    /**\n-     * Method for checking whether given method has an annotation\n-     * that suggests that the method is to serve as \"any setter\";\n-     * method to be used for setting values of any properties for\n-     * which no dedicated setter method is found.\n-     *\n-     * @return True if such annotation is found (and is not disabled),\n-     *   false otherwise\n-     */\n-    public boolean hasAnySetterAnnotation(AnnotatedMethod am) {\n-        return false;\n-    }\n-\n-    /**\n-     * Method for checking whether given method has an annotation\n-     * that suggests that the method is to serve as \"any setter\";\n-     * method to be used for accessing set of miscellaneous \"extra\"\n-     * properties, often bound with matching \"any setter\" method.\n-     *\n-     * @return True if such annotation is found (and is not disabled),\n-     *   false otherwise\n-     */\n-    public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {\n-        return false;\n-    }\n-    \n-    /**\n-     * Method for checking whether given annotated item (method, constructor)\n-     * has an annotation\n-     * that suggests that the method is a \"creator\" (aka factory)\n-     * method to be used for construct new instances of deserialized\n-     * values.\n-     *\n-     * @return True if such annotation is found (and is not disabled),\n-     *   false otherwise\n-     */\n-    public boolean hasCreatorAnnotation(Annotated a) {\n-        return false;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Deserialization: field annotations\n-    /**********************************************************\n-     */\n \n     /**\n      * Method for checking whether given member field represent\n      * If non-null value is returned, it is used as the property\n      * name, except for empty String (\"\") which is taken to mean\n      * \"use the field name as is\".\n-     */\n+     * \n+     * @deprecated Since 2.1 should use {@link #findNameForDeserialization} instead\n+     */\n+    @Deprecated\n     public String findDeserializationName(AnnotatedField af) {\n         return null;\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Deserialization: parameter annotations (for\n-    /* creator method parameters)\n-    /**********************************************************\n-     */\n \n     /**\n      * Method for checking whether given set of annotations indicates\n      * property name for associated parameter.\n      * No actual parameter object can be passed since JDK offers no\n      * representation; just annotations.\n-     */\n+     * \n+     * @deprecated Since 2.1 should use {@link #findNameForDeserialization} instead\n+     */\n+    @Deprecated\n     public String findDeserializationName(AnnotatedParameter param) {\n         return null;\n     }\n+    \n+    /**\n+     * Method for checking whether given method has an annotation\n+     * that suggests that the method is to serve as \"any setter\";\n+     * method to be used for setting values of any properties for\n+     * which no dedicated setter method is found.\n+     *\n+     * @return True if such annotation is found (and is not disabled),\n+     *   false otherwise\n+     */\n+    public boolean hasAnySetterAnnotation(AnnotatedMethod am) {\n+        return false;\n+    }\n+\n+    /**\n+     * Method for checking whether given method has an annotation\n+     * that suggests that the method is to serve as \"any setter\";\n+     * method to be used for accessing set of miscellaneous \"extra\"\n+     * properties, often bound with matching \"any setter\" method.\n+     *\n+     * @return True if such annotation is found (and is not disabled),\n+     *   false otherwise\n+     */\n+    public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {\n+        return false;\n+    }\n+    \n+    /**\n+     * Method for checking whether given annotated item (method, constructor)\n+     * has an annotation\n+     * that suggests that the method is a \"creator\" (aka factory)\n+     * method to be used for construct new instances of deserialized\n+     * values.\n+     *\n+     * @return True if such annotation is found (and is not disabled),\n+     *   false otherwise\n+     */\n+    public boolean hasCreatorAnnotation(Annotated a) {\n+        return false;\n+    }\n \n     /*\n     /**********************************************************\n      */\n \n     /**\n-     * Helper class that allows using 2 introspectors such that one\n-     * introspector acts as the primary one to use; and second one\n-     * as a fallback used if the primary does not provide conclusive\n-     * or useful result for a method.\n-     *<p>\n-     * An obvious consequence of priority is that it is easy to construct\n-     * longer chains of introspectors by linking multiple pairs.\n-     * Currently most likely combination is that of using the default\n-     * Jackson provider, along with JAXB annotation introspector.\n-     */\n+     * Old version of {@link AnnotationIntrospectorPair}.\n+     * \n+     * @deprecated Starting with 2.1, use {@link AnnotationIntrospectorPair} instead.\n+     */\n+    @Deprecated\n     public static class Pair\n-        extends AnnotationIntrospector\n+        extends AnnotationIntrospectorPair\n     {\n-        protected final AnnotationIntrospector _primary, _secondary;\n-\n-        public Pair(AnnotationIntrospector p, AnnotationIntrospector s)\n-        {\n-            _primary = p;\n-            _secondary = s;\n+        @Deprecated\n+        public Pair(AnnotationIntrospector p, AnnotationIntrospector s) {\n+            super(p, s);\n         }\n-\n-        @Override\n-        public Version version() {\n-            return _primary.version();\n-        }\n-        \n-        /**\n-         * Helper method for constructing a Pair from two given introspectors (if\n-         * neither is null); or returning non-null introspector if one is null\n-         * (and return just null if both are null)\n-         */\n-        public static AnnotationIntrospector create(AnnotationIntrospector primary,\n-                AnnotationIntrospector secondary)\n-        {\n-            if (primary == null) {\n-                return secondary;\n-            }\n-            if (secondary == null) {\n-                return primary;\n-            }\n-            return new Pair(primary, secondary);\n-        }\n-\n-        @Override\n-        public Collection<AnnotationIntrospector> allIntrospectors() {\n-            return allIntrospectors(new ArrayList<AnnotationIntrospector>());\n-        }\n-\n-        @Override\n-        public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result)\n-        {\n-            _primary.allIntrospectors(result);\n-            _secondary.allIntrospectors(result);\n-            return result;\n-        }\n-        \n-        // // // Generic annotation properties, lookup\n-        \n-        @Deprecated\n-        @Override\n-        public boolean isHandled(Annotation ann) {\n-            return _primary.isHandled(ann) || _secondary.isHandled(ann);\n-        }\n-\n-        @Override\n-        public boolean isAnnotationBundle(Annotation ann) {\n-            return _primary.isAnnotationBundle(ann) || _secondary.isAnnotationBundle(ann);\n-        }\n-        \n-        /*\n-        /******************************************************\n-        /* General class annotations\n-        /******************************************************\n-         */\n-\n-        @Override\n-        public String findRootName(AnnotatedClass ac)\n-        {\n-            String name1 = _primary.findRootName(ac);\n-            if (name1 == null) {\n-                return _secondary.findRootName(ac);\n-            } else if (name1.length() > 0) {\n-                return name1;\n-            }\n-            // name1 is empty; how about secondary?\n-            String name2 = _secondary.findRootName(ac);\n-            return (name2 == null) ? name1 : name2;\n-        }\n-\n-        @Override\n-        public String[] findPropertiesToIgnore(Annotated ac)\n-        {\n-            String[] result = _primary.findPropertiesToIgnore(ac);\n-            if (result == null) {\n-                result = _secondary.findPropertiesToIgnore(ac);\n-            }\n-            return result;            \n-        }\n-\n-        @Override\n-        public Boolean findIgnoreUnknownProperties(AnnotatedClass ac)\n-        {\n-            Boolean result = _primary.findIgnoreUnknownProperties(ac);\n-            if (result == null) {\n-                result = _secondary.findIgnoreUnknownProperties(ac);\n-            }\n-            return result;\n-        }        \n-\n-        @Override\n-        public Boolean isIgnorableType(AnnotatedClass ac)\n-        {\n-            Boolean result = _primary.isIgnorableType(ac);\n-            if (result == null) {\n-                result = _secondary.isIgnorableType(ac);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Object findFilterId(AnnotatedClass ac)\n-        {\n-            Object id = _primary.findFilterId(ac);\n-            if (id == null) {\n-                id = _secondary.findFilterId(ac);\n-            }\n-            return id;\n-        }\n-\n-        @Override\n-        public Object findNamingStrategy(AnnotatedClass ac)\n-        {\n-            Object str = _primary.findNamingStrategy(ac);\n-            if (str == null) {\n-                str = _secondary.findNamingStrategy(ac);\n-            }\n-            return str;\n-        }\n-\n-        /*\n-        /******************************************************\n-        /* Property auto-detection\n-        /******************************************************\n-        */\n-        \n-        @Override\n-        public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n-            VisibilityChecker<?> checker)\n-        {\n-            /* Note: to have proper priorities, we must actually call delegatees\n-             * in reverse order:\n-             */\n-            checker = _secondary.findAutoDetectVisibility(ac, checker);\n-            return _primary.findAutoDetectVisibility(ac, checker);\n-        }\n-\n-        /*\n-        /******************************************************\n-        /* Type handling\n-        /******************************************************\n-        */\n-        \n-        @Override\n-        public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n-                AnnotatedClass ac, JavaType baseType)\n-        {\n-            TypeResolverBuilder<?> b = _primary.findTypeResolver(config, ac, baseType);\n-            if (b == null) {\n-                b = _secondary.findTypeResolver(config, ac, baseType);\n-            }\n-            return b;\n-        }\n-\n-        @Override\n-        public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n-                AnnotatedMember am, JavaType baseType)\n-        {\n-            TypeResolverBuilder<?> b = _primary.findPropertyTypeResolver(config, am, baseType);\n-            if (b == null) {\n-                b = _secondary.findPropertyTypeResolver(config, am, baseType);\n-            }\n-            return b;\n-        }\n-\n-        @Override\n-        public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n-                AnnotatedMember am, JavaType baseType)\n-        {\n-            TypeResolverBuilder<?> b = _primary.findPropertyContentTypeResolver(config, am, baseType);\n-            if (b == null) {\n-                b = _secondary.findPropertyContentTypeResolver(config, am, baseType);\n-            }\n-            return b;\n-        }\n-        \n-        @Override\n-        public List<NamedType> findSubtypes(Annotated a)\n-        {\n-            List<NamedType> types1 = _primary.findSubtypes(a);\n-            List<NamedType> types2 = _secondary.findSubtypes(a);\n-            if (types1 == null || types1.isEmpty()) return types2;\n-            if (types2 == null || types2.isEmpty()) return types1;\n-            ArrayList<NamedType> result = new ArrayList<NamedType>(types1.size() + types2.size());\n-            result.addAll(types1);\n-            result.addAll(types2);\n-            return result;\n-        }\n-\n-        @Override\n-        public String findTypeName(AnnotatedClass ac)\n-        {\n-            String name = _primary.findTypeName(ac);\n-            if (name == null || name.length() == 0) {\n-                name = _secondary.findTypeName(ac);                \n-            }\n-            return name;\n-        }\n-        \n-        // // // General member (field, method/constructor) annotations\n-        \n-        @Override        \n-        public ReferenceProperty findReferenceType(AnnotatedMember member)\n-        {\n-            ReferenceProperty ref = _primary.findReferenceType(member);\n-            if (ref == null) {\n-                ref = _secondary.findReferenceType(member);\n-            }\n-            return ref; \n-        }\n-\n-        @Override        \n-        public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)\n-        {\n-            NameTransformer value = _primary.findUnwrappingNameTransformer(member);\n-            if (value == null) {\n-                value = _secondary.findUnwrappingNameTransformer(member);\n-            }\n-            return value;\n-        }\n-\n-        @Override\n-        public Object findInjectableValueId(AnnotatedMember m)\n-        {\n-            Object value = _primary.findInjectableValueId(m);\n-            if (value == null) {\n-                value = _secondary.findInjectableValueId(m);\n-            }\n-            return value;\n-        }\n-\n-        @Override\n-        public boolean hasIgnoreMarker(AnnotatedMember m) {\n-            return _primary.hasIgnoreMarker(m) || _secondary.hasIgnoreMarker(m);\n-        }\n-        \n-        @Override\n-        public Boolean hasRequiredMarker(AnnotatedMember m)\n-        {\n-            Boolean value = _primary.hasRequiredMarker(m);\n-            if (value == null) {\n-                value = _secondary.hasRequiredMarker(m);\n-            }\n-            return value;\n-        }\n-        \n-        // // // Serialization: general annotations\n-\n-        @Override\n-        public Object findSerializer(Annotated am)\n-        {\n-            Object result = _primary.findSerializer(am);\n-            if (result == null) {\n-                result = _secondary.findSerializer(am);\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public Object findKeySerializer(Annotated a)\n-        {\n-            Object result = _primary.findKeySerializer(a);\n-            if (result == null || result == JsonSerializer.None.class || result == NoClass.class) {\n-                result = _secondary.findKeySerializer(a);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Object findContentSerializer(Annotated a)\n-        {\n-            Object result = _primary.findContentSerializer(a);\n-            if (result == null || result == JsonSerializer.None.class || result == NoClass.class) {\n-                result = _secondary.findContentSerializer(a);\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public JsonInclude.Include findSerializationInclusion(Annotated a,\n-                JsonInclude.Include defValue)\n-        {\n-            /* This is bit trickier: need to combine results in a meaningful\n-             * way. Seems like it should be a disjoint; that is, most\n-             * restrictive value should be returned.\n-             * For enumerations, comparison is done by indexes, which\n-             * works: largest value is the last one, which is the most\n-             * restrictive value as well.\n-             */\n-            /* 09-Mar-2010, tatu: Actually, as per [JACKSON-256], it is probably better to just\n-             *    use strict overriding. Simpler, easier to understand.\n-             */\n-            // note: call secondary first, to give lower priority\n-            defValue = _secondary.findSerializationInclusion(a, defValue);\n-            defValue = _primary.findSerializationInclusion(a, defValue);\n-            return defValue;\n-        }\n-        \n-        @Override\n-        public Class<?> findSerializationType(Annotated a)\n-        {\n-            Class<?> result = _primary.findSerializationType(a);\n-            if (result == null) {\n-                result = _secondary.findSerializationType(a);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n-        {\n-            Class<?> result = _primary.findSerializationKeyType(am, baseType);\n-            if (result == null) {\n-                result = _secondary.findSerializationKeyType(am, baseType);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n-        {\n-            Class<?> result = _primary.findSerializationContentType(am, baseType);\n-            if (result == null) {\n-                result = _secondary.findSerializationContentType(am, baseType);\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public JsonSerialize.Typing findSerializationTyping(Annotated a)\n-        {\n-            JsonSerialize.Typing result = _primary.findSerializationTyping(a);\n-            if (result == null) {\n-                result = _secondary.findSerializationTyping(a);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Class<?>[] findViews(Annotated a)\n-        {\n-            /* Theoretically this could be trickier, if multiple introspectors\n-             * return non-null entries. For now, though, we'll just consider\n-             * first one to return non-null to win.\n-             */\n-            Class<?>[] result = _primary.findViews(a);\n-            if (result == null) {\n-                result = _secondary.findViews(a);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Boolean isTypeId(AnnotatedMember member) {\n-            Boolean b = _primary.isTypeId(member);\n-            if (b == null) {\n-                b = _secondary.isTypeId(member);\n-            }\n-            return b;\n-        }\n-\n-        @Override\n-        public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n-            ObjectIdInfo result = _primary.findObjectIdInfo(ann);\n-            if (result == null) {\n-                result = _secondary.findObjectIdInfo(ann);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-            // to give precedence for primary, must start with secondary:\n-            objectIdInfo = _secondary.findObjectReferenceInfo(ann, objectIdInfo);\n-            objectIdInfo = _primary.findObjectReferenceInfo(ann, objectIdInfo);\n-            return objectIdInfo;\n-        }\n-        \n-        @Override\n-        public JsonFormat.Value findFormat(Annotated ann) {\n-            JsonFormat.Value result = _primary.findFormat(ann);\n-            if (result == null) {\n-                result = _secondary.findFormat(ann);\n-            }\n-            return result;\n-        }\n-        \n-        // // // Serialization: class annotations\n-\n-        @Override\n-        public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n-            String[] result = _primary.findSerializationPropertyOrder(ac);\n-            if (result == null) {\n-                result = _secondary.findSerializationPropertyOrder(ac);\n-            }\n-            return result;            \n-        }\n-\n-        /**\n-         * Method for checking whether an annotation indicates that serialized properties\n-         * for which no explicit is defined should be alphabetically (lexicograpically)\n-         * ordered\n-         */\n-        @Override\n-        public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n-            Boolean result = _primary.findSerializationSortAlphabetically(ac);\n-            if (result == null) {\n-                result = _secondary.findSerializationSortAlphabetically(ac);\n-            }\n-            return result;            \n-        }\n-\n-        // // // Serialization: method annotations\n-        \n-        @Override\n-        public String findSerializationName(AnnotatedMethod am)\n-        {\n-            String result = _primary.findSerializationName(am);\n-            if (result == null) {\n-                result = _secondary.findSerializationName(am);\n-            } else if (result.length() == 0) {\n-                /* Empty String is a default; can be overridden by\n-                 * more explicit answer from secondary entry\n-                 */\n-                String str2 = _secondary.findSerializationName(am);\n-                if (str2 != null) {\n-                    result = str2;\n-                }\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public boolean hasAsValueAnnotation(AnnotatedMethod am)\n-        {\n-            return _primary.hasAsValueAnnotation(am) || _secondary.hasAsValueAnnotation(am);\n-        }\n-        \n-        @Override\n-        public String findEnumValue(Enum<?> value)\n-        {\n-            String result = _primary.findEnumValue(value);\n-            if (result == null) {\n-                result = _secondary.findEnumValue(value);\n-            }\n-            return result;\n-        }        \n-\n-        // // // Serialization: field annotations\n-\n-        @Override\n-        public String findSerializationName(AnnotatedField af)\n-        {\n-            String result = _primary.findSerializationName(af);\n-            if (result == null) {\n-                result = _secondary.findSerializationName(af);\n-            } else if (result.length() == 0) {\n-                /* Empty String is a default; can be overridden by\n-                 * more explicit answer from secondary entry\n-                 */\n-                String str2 = _secondary.findSerializationName(af);\n-                if (str2 != null) {\n-                    result = str2;\n-                }\n-            }\n-            return result;\n-        }\n-\n-        // // // Deserialization: general annotations\n-\n-        @Override\n-        public Object findDeserializer(Annotated am)\n-        {\n-            Object result = _primary.findDeserializer(am);\n-            if (result == null) {\n-                result = _secondary.findDeserializer(am);\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public Object findKeyDeserializer(Annotated am)\n-        {\n-            Object result = _primary.findKeyDeserializer(am);\n-            if (result == null || result == KeyDeserializer.None.class || result == NoClass.class) {\n-                result = _secondary.findKeyDeserializer(am);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Object findContentDeserializer(Annotated am)\n-        {\n-            Object result = _primary.findContentDeserializer(am);\n-            if (result == null || result == JsonDeserializer.None.class || result == NoClass.class) {\n-                result = _secondary.findContentDeserializer(am);\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public Class<?> findDeserializationType(Annotated am, JavaType baseType)\n-        {\n-            Class<?> result = _primary.findDeserializationType(am, baseType);\n-            if (result == null) {\n-                result = _secondary.findDeserializationType(am, baseType);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType)\n-        {\n-            Class<?> result = _primary.findDeserializationKeyType(am, baseKeyType);\n-            if (result == null) {\n-                result = _secondary.findDeserializationKeyType(am, baseKeyType);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)\n-        {\n-            Class<?> result = _primary.findDeserializationContentType(am, baseContentType);\n-            if (result == null) {\n-                result = _secondary.findDeserializationContentType(am, baseContentType);\n-            }\n-            return result;\n-        }\n-\n-        // // // Deserialization: class annotations\n-\n-        @Override\n-        public Object findValueInstantiator(AnnotatedClass ac)\n-        {\n-            Object result = _primary.findValueInstantiator(ac);\n-            if (result == null) {\n-                result = _secondary.findValueInstantiator(ac);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Class<?> findPOJOBuilder(AnnotatedClass ac)\n-        {\n-        \tClass<?> result = _primary.findPOJOBuilder(ac);\n-        \tif (result == null) {\n-        \t\tresult = _secondary.findPOJOBuilder(ac);\n-        \t}\n-        \treturn result;\n-        }\n-\n-        @Override\n-        public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)\n-        {\n-            JsonPOJOBuilder.Value result = _primary.findPOJOBuilderConfig(ac);\n-            if (result == null) {\n-                result = _secondary.findPOJOBuilderConfig(ac);\n-            }\n-            return result;\n-        }\n-        \n-        // // // Deserialization: method annotations\n-\n-        @Override\n-        public String findDeserializationName(AnnotatedMethod am)\n-        {\n-            String result = _primary.findDeserializationName(am);\n-            if (result == null) {\n-                result = _secondary.findDeserializationName(am);\n-            } else if (result.length() == 0) {\n-                /* Empty String is a default; can be overridden by\n-                 * more explicit answer from secondary entry\n-                 */\n-                String str2 = _secondary.findDeserializationName(am);\n-                if (str2 != null) {\n-                    result = str2;\n-                }\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n-        {\n-            return _primary.hasAnySetterAnnotation(am) || _secondary.hasAnySetterAnnotation(am);\n-        }\n-\n-        @Override\n-        public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n-        {\n-            return _primary.hasAnyGetterAnnotation(am) || _secondary.hasAnyGetterAnnotation(am);\n-        }\n-        \n-        @Override\n-        public boolean hasCreatorAnnotation(Annotated a)\n-        {\n-            return _primary.hasCreatorAnnotation(a) || _secondary.hasCreatorAnnotation(a);\n-        }\n-        \n-        // // // Deserialization: field annotations\n-\n-        @Override\n-        public String findDeserializationName(AnnotatedField af)\n-        {\n-            String result = _primary.findDeserializationName(af);\n-            if (result == null) {\n-                result = _secondary.findDeserializationName(af);\n-            } else if (result.length() == 0) {\n-                /* Empty String is a default; can be overridden by\n-                 * more explicit answer from secondary entry\n-                 */\n-                String str2 = _secondary.findDeserializationName(af);\n-                if (str2 != null) {\n-                    result = str2;\n-                }\n-            }\n-            return result;\n-        }\n-\n-        // // // Deserialization: parameter annotations (for creators)\n-\n-        @Override\n-        public String findDeserializationName(AnnotatedParameter param)\n-        {\n-            String result = _primary.findDeserializationName(param);\n-            if (result == null) {\n-                result = _secondary.findDeserializationName(param);\n-            }\n-            return result;\n-        }\n-    }\n-\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n     public JsonDeserializer<T> unwrappingDeserializer(NameTransformer unwrapper) {\n         return this;\n     }\n+\n+    /**\n+     * Method that can be called to try to replace deserializer this deserializer\n+     * delegates calls to. If not supported (either this deserializer does not\n+     * delegate anything; or it does not want any changes), should either\n+     * throw {@link UnsupportedOperationException} (if operation does not\n+     * make sense or is not allowed); or return this deserializer as is.\n+     * \n+     * @since 2.1\n+     */\n+    public JsonDeserializer<T> replaceDelegatee(JsonDeserializer<?> delegatee) {\n+        throw new UnsupportedOperationException();\n+    }\n     \n     /*\n     /**********************************************************\n      * @since 2.0\n      */\n     public ObjectIdReader getObjectIdReader() { return null; }\n+\n+    /**\n+     * Accessor that can be used to determine if this deserializer uses\n+     * another deserializer for actual deserialization, by delegating\n+     * calls. If so, will return immediate delegate (which itself may\n+     * delegate to further deserializers); otherwise will return null.\n+     * \n+     * @return Deserializer this deserializer delegates calls to, if null;\n+     *   null otherwise.\n+     * \n+     * @since 2.1\n+     */\n+    public JsonDeserializer<?> getDelegatee() {\n+        return null;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n     }\n \n     /**\n-     * Accessor for checking whether this serializer is an\n-     * \"unwrapping\" serializer; this is necessary to know since\n-     * it may also require caller to suppress writing of the\n-     * leading property name.\n-     */\n-    public boolean isUnwrappingSerializer() {\n-        return false;\n+     * Method that can be called to try to replace serializer this serializer\n+     * delegates calls to. If not supported (either this serializer does not\n+     * delegate anything; or it does not want any changes), should either\n+     * throw {@link UnsupportedOperationException} (if operation does not\n+     * make sense or is not allowed); or return this serializer as is.\n+     * \n+     * @since 2.1\n+     */\n+    public JsonSerializer<T> replaceDelegatee(JsonSerializer<?> delegatee) {\n+        throw new UnsupportedOperationException();\n     }\n     \n     /*\n     \n     /*\n     /**********************************************************\n-    /* Introspection methods needed for type handling \n+    /* Other accessors\n     /**********************************************************\n      */\n     \n     public boolean usesObjectId() {\n         return false;\n     }\n+\n+    /**\n+     * Accessor for checking whether this serializer is an\n+     * \"unwrapping\" serializer; this is necessary to know since\n+     * it may also require caller to suppress writing of the\n+     * leading property name.\n+     */\n+    public boolean isUnwrappingSerializer() {\n+        return false;\n+    }\n+    \n+    /**\n+     * Accessor that can be used to determine if this serializer uses\n+     * another serializer for actual serialization, by delegating\n+     * calls. If so, will return immediate delegate (which itself may\n+     * delegate to further serializers); otherwise will return null.\n+     * \n+     * @return Serializer this serializer delegates calls to, if null;\n+     *   null otherwise.\n+     * \n+     * @since 2.1\n+     */\n+    public JsonSerializer<?> getDelegatee() {\n+        return null;\n+    }\n     \n     /*\n     /**********************************************************\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/PropertyName.java\n+package com.fasterxml.jackson.databind;\n+\n+/**\n+ * Simple value class used for containing names of properties as defined\n+ * by annotations (and possibly other configuration sources).\n+ * \n+ * @since 2.1\n+ */\n+public class PropertyName\n+{\n+    /**\n+     * Special placeholder value that indicates that name to use should be\n+     * based on the standard heuristics. This can be different from returning\n+     * null, as null means \"no information available, whereas this value\n+     * indicates explicit defaulting.\n+     */\n+    public final static PropertyName USE_DEFAULT = new PropertyName(new String(\"\"), null);\n+    \n+    /**\n+     * Basic name of the property.\n+     */\n+    protected final String _simpleName;\n+\n+    /**\n+     * Additional namespace, for formats that have such concept (JSON\n+     * does not, XML does, for example).\n+     */\n+    protected final String _namespace;\n+\n+    public PropertyName(String simpleName) {\n+        this(simpleName, null);\n+    }\n+\n+    public PropertyName(String simpleName, String namespace)\n+    {\n+        _simpleName = (simpleName == null) ? \"\" : simpleName;\n+        _namespace = namespace;\n+    }\n+\n+    public static PropertyName construct(String simpleName, String ns)\n+    {\n+        if (simpleName == null) {\n+            simpleName = \"\";\n+        }\n+        if (ns == null && simpleName.length() == 0) {\n+            return USE_DEFAULT;\n+        }\n+        return new PropertyName(simpleName, ns);\n+    }\n+    \n+    /**\n+     * Fluent factory method for constructing an instance with different\n+     * simple name.\n+     */\n+    public PropertyName withSimpleName(String simpleName)\n+    {\n+        if (simpleName == null) {\n+            simpleName = \"\";\n+        }\n+        if (simpleName.equals(_simpleName)) {\n+            return this;\n+        }\n+        return new PropertyName(simpleName, _namespace);\n+    }\n+    \n+    /**\n+     * Fluent factory method for constructing an instance with different\n+     * namespace.\n+     */\n+    public PropertyName withNamespace(String ns) {\n+        if (ns == null) {\n+            if (_namespace == null) {\n+                return this;\n+            }\n+        } else if (ns.equals(_namespace)) {\n+            return this;\n+        }\n+        return new PropertyName(_simpleName, ns);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+    \n+    public String getSimpleName() {\n+        return _simpleName;\n+    }\n+\n+    public String getNamespace() {\n+        return _namespace;\n+    }\n+\n+    public boolean hasSimpleName() {\n+        return _simpleName.length() > 0;\n+    }\n+\n+    public boolean hasNamespace() {\n+        return _namespace != null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Std method overrides\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != PropertyName.class) return false;\n+        if (USE_DEFAULT == o) {\n+            return this == USE_DEFAULT;\n+        }\n+        PropertyName other = (PropertyName) this;\n+        if (_simpleName == null) {\n+            if (other._simpleName != null) return false;\n+        } else if (!_simpleName.equals(other._simpleName)) {\n+            return false;\n+        }\n+        if (_namespace == null) {\n+            return (null == other._namespace);\n+        }\n+        return _namespace.equals(other._namespace);\n+    }\n+    \n+    @Override\n+    public int hashCode() {\n+        if (_namespace == null) {\n+            return _simpleName.hashCode();\n+        }\n+        return _namespace.hashCode() ^  _simpleName.hashCode();\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        if (_namespace == null) {\n+            return _simpleName;\n+        }\n+        return _namespace + \":\" + _simpleName;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n import com.fasterxml.jackson.annotation.PropertyAccessor;\n import com.fasterxml.jackson.core.Base64Variant;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n     }\n \n     public BaseSettings withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n-        return withAnnotationIntrospector(AnnotationIntrospector.Pair.create(ai, _annotationIntrospector));\n+        return withAnnotationIntrospector(AnnotationIntrospectorPair.create(ai, _annotationIntrospector));\n     }\n \n     public BaseSettings withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n-        return withAnnotationIntrospector(AnnotationIntrospector.Pair.create(_annotationIntrospector, ai));\n+        return withAnnotationIntrospector(AnnotationIntrospectorPair.create(_annotationIntrospector, ai));\n     }\n     \n     public BaseSettings withVisibilityChecker(VisibilityChecker<?> vc) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n             CreatorProperty[] properties = new CreatorProperty[argCount];\n             for (int i = 0; i < argCount; ++i) {\n                 AnnotatedParameter param = ctor.getParameter(i);\n-                String name = (param == null) ? null : intr.findDeserializationName(param);\n+                PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param);\n+                String name = (pn == null) ? null : pn.getSimpleName();\n                 Object injectId = intr.findInjectableValueId(param);\n                 if (name != null && name.length() > 0) {\n                     ++namedCount;\n     {\n         // note: if we do have parameter name, it'll be \"property constructor\":\n         AnnotatedParameter param = ctor.getParameter(0);\n-        String name = intr.findDeserializationName(param);\n+        PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param);\n+        String name = (pn == null) ? null : pn.getSimpleName();\n         Object injectId = intr.findInjectableValueId(param);\n     \n         if ((injectId != null) || (name != null && name.length() > 0)) { // property-based\n             // some single-arg factory methods (String, number) are auto-detected\n             if (argCount == 1) {\n                 AnnotatedParameter param = factory.getParameter(0);\n-                String name = intr.findDeserializationName(param);\n+                PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param);\n+                String name = (pn == null) ? null : pn.getSimpleName();\n                 Object injectId = intr.findInjectableValueId(param);\n \n                 if ((injectId == null) && (name == null || name.length() == 0)) { // not property based\n             int injectCount = 0;            \n             for (int i = 0; i < argCount; ++i) {\n                 AnnotatedParameter param = factory.getParameter(i);\n-                String name = intr.findDeserializationName(param);\n+                PropertyName pn = (param == null) ? null : intr.findNameForDeserialization(param);\n+                String name = (pn == null) ? null : pn.getSimpleName();\n                 Object injectId = intr.findInjectableValueId(param);\n                 if (name != null && name.length() > 0) {\n                     ++namedCount;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n \n     /**\n      * Annotations from the bean class: used for accessing\n-     * annotations during resolution phase (see {@link #resolve}).\n+     * annotations during resolution\n+     * (see {@link #resolve}) and\n+     * contextualization (see {@link #createContextual}).\n      */\n     final private Annotations _classAnnotations;\n-    \n+\n     /**\n      * Declared type of the bean this deserializer handles.\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n         _propertyIndex = src._propertyIndex;\n         _viewMatcher = src._viewMatcher;\n     }\n-    \n+\n+    /**\n+     * Fluent factory method for constructing and returning a new instance\n+     * with specified value deserializer.\n+     * Note that this method should NOT change configuration of this instance.\n+     * \n+     * @param deser Deserializer to assign to the new property instance\n+     * \n+     * @return Newly constructed instance, if value deserializer differs from the\n+     *   one used for this instance; or 'this' if not.\n+     */\n     public abstract SettableBeanProperty withValueDeserializer(JsonDeserializer<?> deser);\n \n+    /**\n+     * Fluent factory method for constructing and returning a new instance\n+     * with specified propert name.\n+     * Note that this method should NOT change configuration of this instance.\n+     * \n+     * @param newName Name to use for the new instance.\n+     * \n+     * @return Newly constructed instance, if property name differs from the\n+     *   one used for this instance; or 'this' if not.\n+     */\n     public abstract SettableBeanProperty withName(String newName);\n     \n     public void setManagedReferenceName(String n) {\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n+\n+/**\n+ * Helper class that allows using 2 introspectors such that one\n+ * introspector acts as the primary one to use; and second one\n+ * as a fallback used if the primary does not provide conclusive\n+ * or useful result for a method.\n+ *<p>\n+ * An obvious consequence of priority is that it is easy to construct\n+ * longer chains of introspectors by linking multiple pairs.\n+ * Currently most likely combination is that of using the default\n+ * Jackson provider, along with JAXB annotation introspector.\n+ *<p>\n+ * Note: up until 2.0, this class was an inner class of\n+ * {@link AnnotationIntrospector}; moved here for convenience.\n+ * \n+ * @since 2.1\n+ */\n+public class AnnotationIntrospectorPair extends AnnotationIntrospector\n+{\n+    protected final AnnotationIntrospector _primary, _secondary;\n+\n+    public AnnotationIntrospectorPair(AnnotationIntrospector p, AnnotationIntrospector s)\n+    {\n+        _primary = p;\n+        _secondary = s;\n+    }\n+\n+    @Override\n+    public Version version() {\n+        return _primary.version();\n+    }\n+\n+    /**\n+     * Helper method for constructing a Pair from two given introspectors (if\n+     * neither is null); or returning non-null introspector if one is null\n+     * (and return just null if both are null)\n+     */\n+    public static AnnotationIntrospector create(AnnotationIntrospector primary,\n+            AnnotationIntrospector secondary)\n+    {\n+        if (primary == null) {\n+            return secondary;\n+        }\n+        if (secondary == null) {\n+            return primary;\n+        }\n+        return new AnnotationIntrospectorPair(primary, secondary);\n+    }\n+\n+    @Override\n+    public Collection<AnnotationIntrospector> allIntrospectors() {\n+        return allIntrospectors(new ArrayList<AnnotationIntrospector>());\n+    }\n+\n+    @Override\n+    public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result)\n+    {\n+        _primary.allIntrospectors(result);\n+        _secondary.allIntrospectors(result);\n+        return result;\n+    }\n+    \n+    // // // Generic annotation properties, lookup\n+    \n+    @Override\n+    public boolean isAnnotationBundle(Annotation ann) {\n+        return _primary.isAnnotationBundle(ann) || _secondary.isAnnotationBundle(ann);\n+    }\n+    \n+    /*\n+    /******************************************************\n+    /* General class annotations\n+    /******************************************************\n+     */\n+\n+    @Override\n+    public PropertyName findRootName(AnnotatedClass ac)\n+    {\n+        PropertyName name1 = _primary.findRootName(ac);\n+        if (name1 == null) {\n+            return _secondary.findRootName(ac);\n+        }\n+        if (name1.hasSimpleName()) {\n+            return name1;\n+        }\n+        // name1 is empty; how about secondary?\n+        PropertyName name2 = _secondary.findRootName(ac);\n+        return (name2 == null) ? name1 : name2;\n+    }\n+\n+    @Override\n+    public String[] findPropertiesToIgnore(Annotated ac)\n+    {\n+        String[] result = _primary.findPropertiesToIgnore(ac);\n+        if (result == null) {\n+            result = _secondary.findPropertiesToIgnore(ac);\n+        }\n+        return result;            \n+    }\n+\n+    @Override\n+    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac)\n+    {\n+        Boolean result = _primary.findIgnoreUnknownProperties(ac);\n+        if (result == null) {\n+            result = _secondary.findIgnoreUnknownProperties(ac);\n+        }\n+        return result;\n+    }        \n+\n+    @Override\n+    public Boolean isIgnorableType(AnnotatedClass ac)\n+    {\n+        Boolean result = _primary.isIgnorableType(ac);\n+        if (result == null) {\n+            result = _secondary.isIgnorableType(ac);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Object findFilterId(AnnotatedClass ac)\n+    {\n+        Object id = _primary.findFilterId(ac);\n+        if (id == null) {\n+            id = _secondary.findFilterId(ac);\n+        }\n+        return id;\n+    }\n+\n+    @Override\n+    public Object findNamingStrategy(AnnotatedClass ac)\n+    {\n+        Object str = _primary.findNamingStrategy(ac);\n+        if (str == null) {\n+            str = _secondary.findNamingStrategy(ac);\n+        }\n+        return str;\n+    }\n+\n+    /*\n+    /******************************************************\n+    /* Property auto-detection\n+    /******************************************************\n+    */\n+    \n+    @Override\n+    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n+        VisibilityChecker<?> checker)\n+    {\n+        /* Note: to have proper priorities, we must actually call delegatees\n+         * in reverse order:\n+         */\n+        checker = _secondary.findAutoDetectVisibility(ac, checker);\n+        return _primary.findAutoDetectVisibility(ac, checker);\n+    }\n+\n+    /*\n+    /******************************************************\n+    /* Type handling\n+    /******************************************************\n+    */\n+    \n+    @Override\n+    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n+            AnnotatedClass ac, JavaType baseType)\n+    {\n+        TypeResolverBuilder<?> b = _primary.findTypeResolver(config, ac, baseType);\n+        if (b == null) {\n+            b = _secondary.findTypeResolver(config, ac, baseType);\n+        }\n+        return b;\n+    }\n+\n+    @Override\n+    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n+            AnnotatedMember am, JavaType baseType)\n+    {\n+        TypeResolverBuilder<?> b = _primary.findPropertyTypeResolver(config, am, baseType);\n+        if (b == null) {\n+            b = _secondary.findPropertyTypeResolver(config, am, baseType);\n+        }\n+        return b;\n+    }\n+\n+    @Override\n+    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n+            AnnotatedMember am, JavaType baseType)\n+    {\n+        TypeResolverBuilder<?> b = _primary.findPropertyContentTypeResolver(config, am, baseType);\n+        if (b == null) {\n+            b = _secondary.findPropertyContentTypeResolver(config, am, baseType);\n+        }\n+        return b;\n+    }\n+    \n+    @Override\n+    public List<NamedType> findSubtypes(Annotated a)\n+    {\n+        List<NamedType> types1 = _primary.findSubtypes(a);\n+        List<NamedType> types2 = _secondary.findSubtypes(a);\n+        if (types1 == null || types1.isEmpty()) return types2;\n+        if (types2 == null || types2.isEmpty()) return types1;\n+        ArrayList<NamedType> result = new ArrayList<NamedType>(types1.size() + types2.size());\n+        result.addAll(types1);\n+        result.addAll(types2);\n+        return result;\n+    }\n+\n+    @Override\n+    public String findTypeName(AnnotatedClass ac)\n+    {\n+        String name = _primary.findTypeName(ac);\n+        if (name == null || name.length() == 0) {\n+            name = _secondary.findTypeName(ac);                \n+        }\n+        return name;\n+    }\n+    \n+    // // // General member (field, method/constructor) annotations\n+    \n+    @Override        \n+    public ReferenceProperty findReferenceType(AnnotatedMember member)\n+    {\n+        ReferenceProperty ref = _primary.findReferenceType(member);\n+        if (ref == null) {\n+            ref = _secondary.findReferenceType(member);\n+        }\n+        return ref; \n+    }\n+\n+    @Override        \n+    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)\n+    {\n+        NameTransformer value = _primary.findUnwrappingNameTransformer(member);\n+        if (value == null) {\n+            value = _secondary.findUnwrappingNameTransformer(member);\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public Object findInjectableValueId(AnnotatedMember m)\n+    {\n+        Object value = _primary.findInjectableValueId(m);\n+        if (value == null) {\n+            value = _secondary.findInjectableValueId(m);\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public boolean hasIgnoreMarker(AnnotatedMember m) {\n+        return _primary.hasIgnoreMarker(m) || _secondary.hasIgnoreMarker(m);\n+    }\n+    \n+    @Override\n+    public Boolean hasRequiredMarker(AnnotatedMember m)\n+    {\n+        Boolean value = _primary.hasRequiredMarker(m);\n+        if (value == null) {\n+            value = _secondary.hasRequiredMarker(m);\n+        }\n+        return value;\n+    }\n+    \n+    // // // Serialization: general annotations\n+\n+    @Override\n+    public Object findSerializer(Annotated am)\n+    {\n+        Object result = _primary.findSerializer(am);\n+        if (result == null) {\n+            result = _secondary.findSerializer(am);\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public Object findKeySerializer(Annotated a)\n+    {\n+        Object result = _primary.findKeySerializer(a);\n+        if (result == null || result == JsonSerializer.None.class || result == NoClass.class) {\n+            result = _secondary.findKeySerializer(a);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Object findContentSerializer(Annotated a)\n+    {\n+        Object result = _primary.findContentSerializer(a);\n+        if (result == null || result == JsonSerializer.None.class || result == NoClass.class) {\n+            result = _secondary.findContentSerializer(a);\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public JsonInclude.Include findSerializationInclusion(Annotated a,\n+            JsonInclude.Include defValue)\n+    {\n+        /* This is bit trickier: need to combine results in a meaningful\n+         * way. Seems like it should be a disjoint; that is, most\n+         * restrictive value should be returned.\n+         * For enumerations, comparison is done by indexes, which\n+         * works: largest value is the last one, which is the most\n+         * restrictive value as well.\n+         */\n+        /* 09-Mar-2010, tatu: Actually, as per [JACKSON-256], it is probably better to just\n+         *    use strict overriding. Simpler, easier to understand.\n+         */\n+        // note: call secondary first, to give lower priority\n+        defValue = _secondary.findSerializationInclusion(a, defValue);\n+        defValue = _primary.findSerializationInclusion(a, defValue);\n+        return defValue;\n+    }\n+    \n+    @Override\n+    public Class<?> findSerializationType(Annotated a)\n+    {\n+        Class<?> result = _primary.findSerializationType(a);\n+        if (result == null) {\n+            result = _secondary.findSerializationType(a);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n+    {\n+        Class<?> result = _primary.findSerializationKeyType(am, baseType);\n+        if (result == null) {\n+            result = _secondary.findSerializationKeyType(am, baseType);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n+    {\n+        Class<?> result = _primary.findSerializationContentType(am, baseType);\n+        if (result == null) {\n+            result = _secondary.findSerializationContentType(am, baseType);\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public JsonSerialize.Typing findSerializationTyping(Annotated a)\n+    {\n+        JsonSerialize.Typing result = _primary.findSerializationTyping(a);\n+        if (result == null) {\n+            result = _secondary.findSerializationTyping(a);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Class<?>[] findViews(Annotated a)\n+    {\n+        /* Theoretically this could be trickier, if multiple introspectors\n+         * return non-null entries. For now, though, we'll just consider\n+         * first one to return non-null to win.\n+         */\n+        Class<?>[] result = _primary.findViews(a);\n+        if (result == null) {\n+            result = _secondary.findViews(a);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Boolean isTypeId(AnnotatedMember member) {\n+        Boolean b = _primary.isTypeId(member);\n+        if (b == null) {\n+            b = _secondary.isTypeId(member);\n+        }\n+        return b;\n+    }\n+\n+    @Override\n+    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n+        ObjectIdInfo result = _primary.findObjectIdInfo(ann);\n+        if (result == null) {\n+            result = _secondary.findObjectIdInfo(ann);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n+        // to give precedence for primary, must start with secondary:\n+        objectIdInfo = _secondary.findObjectReferenceInfo(ann, objectIdInfo);\n+        objectIdInfo = _primary.findObjectReferenceInfo(ann, objectIdInfo);\n+        return objectIdInfo;\n+    }\n+    \n+    @Override\n+    public JsonFormat.Value findFormat(Annotated ann) {\n+        JsonFormat.Value result = _primary.findFormat(ann);\n+        if (result == null) {\n+            result = _secondary.findFormat(ann);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public PropertyName findWrapperName(Annotated ann) {\n+        PropertyName name = _primary.findWrapperName(ann);\n+        if (name == null) {\n+            name = _secondary.findWrapperName(ann);\n+        }\n+        return name;\n+    }\n+    \n+    // // // Serialization: class annotations\n+\n+    @Override\n+    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n+        String[] result = _primary.findSerializationPropertyOrder(ac);\n+        if (result == null) {\n+            result = _secondary.findSerializationPropertyOrder(ac);\n+        }\n+        return result;            \n+    }\n+\n+    /**\n+     * Method for checking whether an annotation indicates that serialized properties\n+     * for which no explicit is defined should be alphabetically (lexicograpically)\n+     * ordered\n+     */\n+    @Override\n+    public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n+        Boolean result = _primary.findSerializationSortAlphabetically(ac);\n+        if (result == null) {\n+            result = _secondary.findSerializationSortAlphabetically(ac);\n+        }\n+        return result;            \n+    }\n+\n+    // // // Serialization: property annotations\n+    \n+    @Override\n+    public PropertyName findNameForSerialization(Annotated a) {\n+        PropertyName n = _primary.findNameForSerialization(a);\n+        // note: \"use default\" should not block explicit answer, so:\n+        if (n == null) {\n+            n = _secondary.findNameForSerialization(a);\n+        } else if (n == PropertyName.USE_DEFAULT) {\n+            PropertyName n2 = _secondary.findNameForSerialization(a);\n+            if (n2 != null) {\n+                n = n2;\n+            }\n+        }\n+        return n;\n+    }\n+    \n+    @Override\n+    public boolean hasAsValueAnnotation(AnnotatedMethod am)\n+    {\n+        return _primary.hasAsValueAnnotation(am) || _secondary.hasAsValueAnnotation(am);\n+    }\n+    \n+    @Override\n+    public String findEnumValue(Enum<?> value)\n+    {\n+        String result = _primary.findEnumValue(value);\n+        if (result == null) {\n+            result = _secondary.findEnumValue(value);\n+        }\n+        return result;\n+    }        \n+\n+    // // // Deserialization: general annotations\n+\n+    @Override\n+    public Object findDeserializer(Annotated am)\n+    {\n+        Object result = _primary.findDeserializer(am);\n+        if (result == null) {\n+            result = _secondary.findDeserializer(am);\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public Object findKeyDeserializer(Annotated am)\n+    {\n+        Object result = _primary.findKeyDeserializer(am);\n+        if (result == null || result == KeyDeserializer.None.class || result == NoClass.class) {\n+            result = _secondary.findKeyDeserializer(am);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Object findContentDeserializer(Annotated am)\n+    {\n+        Object result = _primary.findContentDeserializer(am);\n+        if (result == null || result == JsonDeserializer.None.class || result == NoClass.class) {\n+            result = _secondary.findContentDeserializer(am);\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public Class<?> findDeserializationType(Annotated am, JavaType baseType)\n+    {\n+        Class<?> result = _primary.findDeserializationType(am, baseType);\n+        if (result == null) {\n+            result = _secondary.findDeserializationType(am, baseType);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType)\n+    {\n+        Class<?> result = _primary.findDeserializationKeyType(am, baseKeyType);\n+        if (result == null) {\n+            result = _secondary.findDeserializationKeyType(am, baseKeyType);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)\n+    {\n+        Class<?> result = _primary.findDeserializationContentType(am, baseContentType);\n+        if (result == null) {\n+            result = _secondary.findDeserializationContentType(am, baseContentType);\n+        }\n+        return result;\n+    }\n+\n+    // // // Deserialization: class annotations\n+\n+    @Override\n+    public Object findValueInstantiator(AnnotatedClass ac)\n+    {\n+        Object result = _primary.findValueInstantiator(ac);\n+        if (result == null) {\n+            result = _secondary.findValueInstantiator(ac);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Class<?> findPOJOBuilder(AnnotatedClass ac)\n+    {\n+            Class<?> result = _primary.findPOJOBuilder(ac);\n+            if (result == null) {\n+                    result = _secondary.findPOJOBuilder(ac);\n+            }\n+            return result;\n+    }\n+\n+    @Override\n+    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)\n+    {\n+        JsonPOJOBuilder.Value result = _primary.findPOJOBuilderConfig(ac);\n+        if (result == null) {\n+            result = _secondary.findPOJOBuilderConfig(ac);\n+        }\n+        return result;\n+    }\n+    \n+    // // // Deserialization: method annotations\n+\n+    @Override\n+    public PropertyName findNameForDeserialization(Annotated a)\n+    {\n+        // note: \"use default\" should not block explicit answer, so:\n+        PropertyName n = _primary.findNameForDeserialization(a);\n+        if (n == null) {\n+            n = _secondary.findNameForDeserialization(a);\n+        } else if (n == PropertyName.USE_DEFAULT) {\n+            PropertyName n2 = _secondary.findNameForDeserialization(a);\n+            if (n2 != null) {\n+                n = n2;\n+            }\n+        }\n+        return n;\n+    }\n+    \n+    @Override\n+    public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n+    {\n+        return _primary.hasAnySetterAnnotation(am) || _secondary.hasAnySetterAnnotation(am);\n+    }\n+\n+    @Override\n+    public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n+    {\n+        return _primary.hasAnyGetterAnnotation(am) || _secondary.hasAnyGetterAnnotation(am);\n+    }\n+    \n+    @Override\n+    public boolean hasCreatorAnnotation(Annotated a)\n+    {\n+        return _primary.hasCreatorAnnotation(a) || _secondary.hasCreatorAnnotation(a);\n+    }\n+ \n+    /*\n+    /******************************************************\n+    /* Deprecated methods\n+    /******************************************************\n+     */\n+    \n+    @Deprecated\n+    @Override\n+    public boolean isHandled(Annotation ann) {\n+        return _primary.isHandled(ann) || _secondary.isHandled(ann);\n+    }\n+\n+    // // // Deserialization: property annotations\n+\n+    @Deprecated\n+    @Override\n+    public String findDeserializationName(AnnotatedMethod am)\n+    {\n+        String result = _primary.findDeserializationName(am);\n+        if (result == null) {\n+            result = _secondary.findDeserializationName(am);\n+        } else if (result.length() == 0) {\n+            /* Empty String is a default; can be overridden by\n+             * more explicit answer from secondary entry\n+             */\n+            String str2 = _secondary.findDeserializationName(am);\n+            if (str2 != null) {\n+                result = str2;\n+            }\n+        }\n+        return result;\n+    }\n+    \n+    @Deprecated\n+    @Override\n+    public String findDeserializationName(AnnotatedField af)\n+    {\n+        String result = _primary.findDeserializationName(af);\n+        if (result == null) {\n+            result = _secondary.findDeserializationName(af);\n+        } else if (result.length() == 0) {\n+            /* Empty String is a default; can be overridden by\n+             * more explicit answer from secondary entry\n+             */\n+            String str2 = _secondary.findDeserializationName(af);\n+            if (str2 != null) {\n+                result = str2;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Deprecated\n+    @Override\n+    public String findDeserializationName(AnnotatedParameter param)\n+    {\n+        String result = _primary.findDeserializationName(param);\n+        if (result == null) {\n+            result = _secondary.findDeserializationName(param);\n+        }\n+        return result;\n+    }\n+\n+    // // // Serialization: property annotations\n+    \n+    @Deprecated\n+    @Override\n+    public String findSerializationName(AnnotatedMethod am)\n+    {\n+        String result = _primary.findSerializationName(am);\n+        if (result == null) {\n+            result = _secondary.findSerializationName(am);\n+        } else if (result.length() == 0) {\n+            /* Empty String is a default; can be overridden by\n+             * more explicit answer from secondary entry\n+             */\n+            String str2 = _secondary.findSerializationName(am);\n+            if (str2 != null) {\n+                result = str2;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Deprecated\n+    @Override\n+    public String findSerializationName(AnnotatedField af)\n+    {\n+        String result = _primary.findSerializationName(af);\n+        if (result == null) {\n+            result = _secondary.findSerializationName(af);\n+        } else if (result.length() == 0) {\n+            /* Empty String is a default; can be overridden by\n+             * more explicit answer from secondary entry\n+             */\n+            String str2 = _secondary.findSerializationName(af);\n+            if (str2 != null) {\n+                result = str2;\n+            }\n+        }\n+        return result;\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n             for (AnnotatedWithParams creator : l) {\n                 int argCount = creator.getParameterCount();\n                 if (argCount < 1) continue;\n-                String name = _annotationIntrospector.findDeserializationName(creator.getParameter(0));\n-                if (name == null) continue;\n+                PropertyName name = _annotationIntrospector.findNameForDeserialization(creator.getParameter(0));\n+                if (name == null) {\n+                    continue;\n+                }\n                 if (names == null) {\n                     names = new ArrayList<String>();\n                 }\n-                names.add(name);\n+                names.add(name.getSimpleName());\n                 for (int p = 1; p < argCount; ++p) {\n-                    names.add(_annotationIntrospector.findDeserializationName(creator.getParameter(p)));\n+                    name = _annotationIntrospector.findNameForDeserialization(creator.getParameter(p));\n+                    names.add((name == null) ? null : name.getSimpleName());\n                 }\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n      */\n \n     @Override\n-    public String findRootName(AnnotatedClass ac)\n+    public PropertyName findRootName(AnnotatedClass ac)\n     {\n         JsonRootName ann = ac.getAnnotation(JsonRootName.class);\n-        return (ann == null) ? null : ann.value();\n+        if (ann == null) {\n+            return null;\n+        }\n+        return new PropertyName(ann.value());\n     }\n \n     @Override\n \n     /*\n     /**********************************************************\n-    /* Serialization: method annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n-    public String findSerializationName(AnnotatedMethod am)\n-    {\n-        // @JsonGetter is most specific, has precedence\n-        JsonGetter ann = am.getAnnotation(JsonGetter.class);\n-        if (ann != null) {\n-            return ann.value();\n-        }\n-        JsonProperty pann = am.getAnnotation(JsonProperty.class);\n-        if (pann != null) {\n-            return pann.value();\n-        }\n-        /* 22-May-2009, tatu: And finally, JsonSerialize implies\n-         *   that there is a property, although doesn't define name\n-         */\n-        // 09-Apr-2010, tatu: Ditto for JsonView\n-        if (am.hasAnnotation(JsonSerialize.class) || am.hasAnnotation(JsonView.class)) {\n-            return \"\";\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public boolean hasAsValueAnnotation(AnnotatedMethod am)\n-    {\n-        JsonValue ann = am.getAnnotation(JsonValue.class);\n-        // value of 'false' means disabled...\n-        return (ann != null && ann.value());\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Serialization: field annotations\n-    /**********************************************************\n-    */\n-\n+    /* Serialization: property annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public PropertyName findNameForSerialization(Annotated a)\n+    {\n+        // [Issue#69], need bit of delegation \n+        // !!! TODO: in 2.2, remove old methods?\n+        String name;\n+        if (a instanceof AnnotatedField) {\n+            name = findSerializationName((AnnotatedField) a);\n+        } else if (a instanceof AnnotatedMethod) {\n+            name = findSerializationName((AnnotatedMethod) a);\n+        } else {\n+            name = null;\n+        }\n+        if (name != null) {\n+            if (name.length() == 0) { // empty String means 'default'\n+                return PropertyName.USE_DEFAULT;\n+            }\n+            return new PropertyName(name);\n+        }\n+        return null;\n+    }\n+    \n     @Override\n     public String findSerializationName(AnnotatedField af)\n     {\n         }\n         return null;\n     }\n+    \n+    @Override\n+    public String findSerializationName(AnnotatedMethod am)\n+    {\n+        // @JsonGetter is most specific, has precedence\n+        JsonGetter ann = am.getAnnotation(JsonGetter.class);\n+        if (ann != null) {\n+            return ann.value();\n+        }\n+        JsonProperty pann = am.getAnnotation(JsonProperty.class);\n+        if (pann != null) {\n+            return pann.value();\n+        }\n+        /* 22-May-2009, tatu: And finally, JsonSerialize implies\n+         *   that there is a property, although doesn't define name\n+         */\n+        // 09-Apr-2010, tatu: Ditto for JsonView\n+        if (am.hasAnnotation(JsonSerialize.class) || am.hasAnnotation(JsonView.class)) {\n+            return \"\";\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean hasAsValueAnnotation(AnnotatedMethod am)\n+    {\n+        JsonValue ann = am.getAnnotation(JsonValue.class);\n+        // value of 'false' means disabled...\n+        return (ann != null && ann.value());\n+    }\n \n     /*\n     /**********************************************************\n     \n     /*\n     /**********************************************************\n-    /* Deserialization: Method annotations\n-    /**********************************************************\n-     */\n-\n+    /* Deserialization: property annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public PropertyName findNameForDeserialization(Annotated a)\n+    {\n+        // [Issue#69], need bit of delegation \n+        // !!! TODO: in 2.2, remove old methods?\n+        String name;\n+        if (a instanceof AnnotatedField) {\n+            name = findDeserializationName((AnnotatedField) a);\n+        } else if (a instanceof AnnotatedMethod) {\n+            name = findDeserializationName((AnnotatedMethod) a);\n+        } else if (a instanceof AnnotatedParameter) {\n+            name = findDeserializationName((AnnotatedParameter) a);\n+        } else {\n+            name = null;\n+        }\n+        if (name != null) {\n+            if (name.length() == 0) { // empty String means 'default'\n+                return PropertyName.USE_DEFAULT;\n+            }\n+            return new PropertyName(name);\n+        }\n+        return null;\n+    }\n+    \n     @Override\n     public String findDeserializationName(AnnotatedMethod am)\n     {\n     }\n \n     @Override\n-    public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n-    {\n-        /* No dedicated disabling; regular @JsonIgnore used\n-         * if needs to be ignored (and if so, is handled prior\n-         * to this method getting called)\n-         */\n-        return am.hasAnnotation(JsonAnySetter.class);\n-    }\n-\n-    @Override\n-    public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n-    {\n-        /* No dedicated disabling; regular @JsonIgnore used\n-         * if needs to be ignored (handled separately\n-         */\n-        return am.hasAnnotation(JsonAnyGetter.class);\n-    }\n-    \n-    @Override\n-    public boolean hasCreatorAnnotation(Annotated a)\n-    {\n-        /* No dedicated disabling; regular @JsonIgnore used\n-         * if needs to be ignored (and if so, is handled prior\n-         * to this method getting called)\n-         */\n-        return a.hasAnnotation(JsonCreator.class);\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Deserialization: field annotations\n-    /**********************************************************\n-     */\n-\n-    @Override\n     public String findDeserializationName(AnnotatedField af)\n     {\n         JsonProperty pann = af.getAnnotation(JsonProperty.class);\n         }\n         return null;\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Deserialization: parameters annotations\n-    /**********************************************************\n-     */\n-\n     @Override\n     public String findDeserializationName(AnnotatedParameter param)\n     {\n              */\n         }\n         return null;\n+    }\n+    \n+    @Override\n+    public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n+    {\n+        /* No dedicated disabling; regular @JsonIgnore used\n+         * if needs to be ignored (and if so, is handled prior\n+         * to this method getting called)\n+         */\n+        return am.hasAnnotation(JsonAnySetter.class);\n+    }\n+\n+    @Override\n+    public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n+    {\n+        /* No dedicated disabling; regular @JsonIgnore used\n+         * if needs to be ignored (handled separately\n+         */\n+        return am.hasAnnotation(JsonAnyGetter.class);\n+    }\n+    \n+    @Override\n+    public boolean hasCreatorAnnotation(Annotated a)\n+    {\n+        /* No dedicated disabling; regular @JsonIgnore used\n+         * if needs to be ignored (and if so, is handled prior\n+         * to this method getting called)\n+         */\n+        return a.hasAnnotation(JsonCreator.class);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n                  *   fields, and similarly for deserialize-only annotations... so\n                  *   no fallbacks in this particular case.\n                  */\n-                explName = ai.findSerializationName(f);\n+                PropertyName pn = ai.findNameForSerialization(f);\n+                explName = (pn == null) ? null : pn.getSimpleName();\n             } else {\n-                explName = ai.findDeserializationName(f);\n+                PropertyName pn = ai.findNameForDeserialization(f);\n+                explName = (pn == null) ? null : pn.getSimpleName();\n             }\n             if (\"\".equals(explName)) { // empty String meaning \"use default name\", here just means \"same as field name\"\n                 explName = implName;\n             }\n             for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) {\n                 AnnotatedParameter param = ctor.getParameter(i);\n-                String name = ai.findDeserializationName(param);\n+                PropertyName pn = ai.findNameForDeserialization(param);\n+                String name = (pn == null) ? null : pn.getSimpleName();\n                 // is it legal not to have name?\n                 if (name != null) {\n                     // shouldn't need to worry about @JsonIgnore (no real point, so)\n             }\n             for (int i = 0, len = factory.getParameterCount(); i < len; ++i) {\n                 AnnotatedParameter param = factory.getParameter(i);\n-                String name = ai.findDeserializationName(param);\n+                PropertyName pn = ai.findNameForDeserialization(param);\n+                String name = (pn == null) ? null : pn.getSimpleName();\n                 // is it legal not to have name?\n                 if (name != null) {\n                     // shouldn't need to worry about @JsonIgnore (no real point, so)\n         String implName; // from naming convention\n         boolean visible;\n         \n-        String explName = (ai == null) ? null : ai.findSerializationName(m);\n+        PropertyName pn = (ai == null) ? null : ai.findNameForSerialization(m);\n+        String explName = (pn == null) ? null : pn.getSimpleName();\n         if (explName == null) { // no explicit name; must follow naming convention\n             implName = BeanUtil.okNameForRegularGetter(m, m.getName());\n             if (implName == null) { // if not, must skip\n     {\n         String implName; // from naming convention\n         boolean visible;\n-        String explName = (ai == null) ? null : ai.findDeserializationName(m);\n+        PropertyName pn = (ai == null) ? null : ai.findNameForDeserialization(m);\n+        String explName = (pn == null) ? null : pn.getSimpleName();\n         if (explName == null) { // no explicit name; must follow naming convention\n             implName = BeanUtil.okNameForMutator(m, _mutatorPrefix);\n             if (implName == null) { // if not, must skip\n--- a/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n         BeanDescription beanDesc = config.introspectClassAnnotations(rootType);\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n         AnnotatedClass ac = beanDesc.getClassInfo();\n-        String nameStr = intr.findRootName(ac);\n+        PropertyName pname = intr.findRootName(ac);\n+        String nameStr;\n         // No answer so far? Let's just default to using simple class name\n-        if (nameStr == null || nameStr.length() == 0) {\n+        if (pname == null || !pname.hasSimpleName()) {\n             // Should we strip out enclosing class tho? For now, nope:\n             nameStr = rootType.getSimpleName();\n+        } else {\n+            nameStr = pname.getSimpleName();\n         }\n         SerializedString name = new SerializedString(nameStr);\n         _rootNames.put(key, name);\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericCollectionDeser.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericCollectionDeser.java\n     static class ListSubClass extends ArrayList<StringWrapper> { }\n \n     /**\n-     * Map class that should behave like {@link MapSubClass}, but by\n+     * Map class that should behave like {@link ListSubClass}, but by\n      * using annotations.\n      */\n     @JsonDeserialize(contentAs=StringWrapper.class)\n--- a/src/test/java/com/fasterxml/jackson/databind/ext/TestCoreXMLTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ext/TestCoreXMLTypes.java\n      */\n     \n     // First things first: must be able to load the deserializers...\n+    @SuppressWarnings(\"unused\")\n     public void testDeserializerLoading()\n     {\n         new CoreXMLDeserializers.DurationDeserializer();\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java\n     }\n \n     /**\n-     * Test bean that has an invalid {@link JsonClass} annotation.\n+     * Test bean that has an invalid {@link JsonSerialize} annotation.\n      */\n     static class BrokenClass\n     {", "timestamp": 1346976352, "metainfo": ""}