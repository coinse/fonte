{"sha": "8e43355c20cfc8054582d21627fd73ff9b779986", "log": "refactoring", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     /**\n      * Default constructor, which will construct the default\n      * {@link JsonFactory} as necessary, use\n-     * {@link StdSerializerProvider} as its\n+     * {@link SerializerProvider} as its\n      * {@link SerializerProvider}, and\n      * {@link BeanSerializerFactory} as its\n      * {@link SerializerFactory}.\n      * serializers and deserializers.\n      * \n      * @param jf JsonFactory to use: if null, a new {@link MappingJsonFactory} will be constructed\n-     * @param sp SerializerProvider to use: if null, a {@link StdSerializerProvider} will be constructed\n+     * @param sp SerializerProvider to use: if null, a {@link SerializerProvider} will be constructed\n      * @param dp DeserializerCache to use\n      */\n     public ObjectMapper(JsonFactory jf,\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n      * for serializing given value, using serializers that\n      * this provider has access to (via caching and/or creating new serializers\n      * as need be).\n-     *\n-     * @param jsf Underlying factory object used for creating serializers\n-     *    as needed\n-     */\n-    public final void serializeValue(JsonGenerator jgen, Object value)\n+     */\n+    public void serializeValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonGenerationException\n     {\n-        // And then we can do actual serialization, through the instance\n-        _serializeValue(jgen, value);\n+        JsonSerializer<Object> ser;\n+        boolean wrap;\n+\n+        if (value == null) {\n+            // no type provided; must just use the default null serializer\n+            ser = getDefaultNullValueSerializer();\n+            wrap = false; // no name to use for wrapping; can't do!\n+        } else {\n+            Class<?> cls = value.getClass();\n+            // true, since we do want to cache root-level typed serializers (ditto for null property)\n+            ser = findTypedValueSerializer(cls, true, null);\n+\n+            // Ok: should we wrap result in an additional property (\"root name\")?\n+            String rootName = _config.getRootName();\n+            if (rootName == null) { // not explicitly specified\n+                // [JACKSON-163]\n+                wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+                if (wrap) {\n+                    jgen.writeStartObject();\n+                    jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n+                }\n+            } else if (rootName.length() == 0) {\n+                wrap = false;\n+            } else { // [JACKSON-764]\n+                // empty String means explicitly disabled; non-empty that it is enabled\n+                wrap = true;\n+                jgen.writeStartObject();\n+                jgen.writeFieldName(rootName);\n+            }\n+        }\n+        try {\n+            ser.serialize(value, jgen, this);\n+            if (wrap) {\n+                jgen.writeEndObject();\n+            }\n+        } catch (IOException ioe) {\n+            /* As per [JACKSON-99], should not wrap IOException or its\n+             * sub-classes (like JsonProcessingException, JsonMappingException)\n+             */\n+            throw ioe;\n+        } catch (Exception e) {\n+            // but others are wrapped\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n     }\n \n     /**\n      * @param rootType Type to use for locating serializer to use, instead of actual\n      *    runtime type. Must be actual type, or one of its super types\n      */\n-    public final void serializeValue(JsonGenerator jgen, Object value,\n+    public void serializeValue(JsonGenerator jgen, Object value,\n             JavaType rootType)\n         throws IOException, JsonGenerationException\n     {\n-        _serializeValue(jgen, value, rootType);\n-    }\n-\n-    /**\n-     * Generate <a href=\"http://json-schema.org/\">Json-schema</a> for\n+        boolean wrap;\n+\n+        JsonSerializer<Object> ser;\n+        if (value == null) {\n+            ser = getDefaultNullValueSerializer();\n+            wrap = false;\n+        } else {\n+            // Let's ensure types are compatible at this point\n+            if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n+                _reportIncompatibleRootType(value, rootType);\n+            }\n+            // root value, not reached via property:\n+            ser = findTypedValueSerializer(rootType, true, null);\n+            // [JACKSON-163]\n+            wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+            if (wrap) {\n+                jgen.writeStartObject();\n+                jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n+            }\n+        }\n+        try {\n+            ser.serialize(value, jgen, this);\n+            if (wrap) {\n+                jgen.writeEndObject();\n+            }\n+        } catch (IOException ioe) { // no wrapping for IO (and derived)\n+            throw ioe;\n+        } catch (Exception e) { // but others do need to be, to get path etc\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+    }\n+\n+    /**\n+     * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n+     * to generate <a href=\"http://json-schema.org/\">JSON schema</a> for\n      * given type.\n      *\n      * @param type The type for which to generate schema\n         _serializerCache.flush();\n     }\n \n-    /*\n-    /**********************************************************\n-    /* Helper methods: can be overridden by sub-classes\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * Method called on the actual non-blueprint provider instance object,\n-     * to kick off the serialization.\n-     */\n-    protected final void _serializeValue(JsonGenerator jgen, Object value)\n-        throws IOException, JsonProcessingException\n-    {\n-        JsonSerializer<Object> ser;\n-        boolean wrap;\n-\n-        if (value == null) {\n-            // no type provided; must just use the default null serializer\n-            ser = getDefaultNullValueSerializer();\n-            wrap = false; // no name to use for wrapping; can't do!\n-        } else {\n-            Class<?> cls = value.getClass();\n-            // true, since we do want to cache root-level typed serializers (ditto for null property)\n-            ser = findTypedValueSerializer(cls, true, null);\n-\n-            // Ok: should we wrap result in an additional property (\"root name\")?\n-            String rootName = _config.getRootName();\n-            if (rootName == null) { // not explicitly specified\n-                // [JACKSON-163]\n-                wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n-                if (wrap) {\n-                    jgen.writeStartObject();\n-                    jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n-                }\n-            } else if (rootName.length() == 0) {\n-                wrap = false;\n-            } else { // [JACKSON-764]\n-                // empty String means explicitly disabled; non-empty that it is enabled\n-                wrap = true;\n-                jgen.writeStartObject();\n-                jgen.writeFieldName(rootName);\n-            }\n-        }\n-        try {\n-            ser.serialize(value, jgen, this);\n-            if (wrap) {\n-                jgen.writeEndObject();\n-            }\n-        } catch (IOException ioe) {\n-            /* As per [JACKSON-99], should not wrap IOException or its\n-             * sub-classes (like JsonProcessingException, JsonMappingException)\n-             */\n-            throw ioe;\n-        } catch (Exception e) {\n-            // but others are wrapped\n-            String msg = e.getMessage();\n-            if (msg == null) {\n-                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n-            }\n-            throw new JsonMappingException(msg, e);\n-        }\n-    }\n-\n-    /**\n-     * Method called on the actual non-blueprint provider instance object,\n-     * to kick off the serialization, when root type is explicitly\n-     * specified and not determined from value.\n-     */\n-    protected  void _serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n-        throws IOException, JsonProcessingException\n-    {\n-        // [JACKSON-163]\n-        boolean wrap;\n-\n-        JsonSerializer<Object> ser;\n-        if (value == null) {\n-            ser = getDefaultNullValueSerializer();\n-            wrap = false;\n-        } else {\n-            // Let's ensure types are compatible at this point\n-            if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n-                _reportIncompatibleRootType(value, rootType);\n-            }\n-            // root value, not reached via property:\n-            ser = findTypedValueSerializer(rootType, true, null);\n-            // [JACKSON-163]\n-            wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n-            if (wrap) {\n-                jgen.writeStartObject();\n-                jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n-            }\n-        }\n-        try {\n-            ser.serialize(value, jgen, this);\n-            if (wrap) {\n-                jgen.writeEndObject();\n-            }\n-        } catch (IOException ioe) { // no wrapping for IO (and derived)\n-            throw ioe;\n-        } catch (Exception e) { // but others do need to be, to get path etc\n-            String msg = e.getMessage();\n-            if (msg == null) {\n-                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n-            }\n-            throw new JsonMappingException(msg, e);\n-        }\n-    }\n-\n     protected void _reportIncompatibleRootType(Object value, JavaType rootType)\n         throws IOException, JsonProcessingException\n     {", "timestamp": 1328147926, "metainfo": ""}