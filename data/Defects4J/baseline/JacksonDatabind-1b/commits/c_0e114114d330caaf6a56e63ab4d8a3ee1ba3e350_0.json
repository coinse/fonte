{"sha": "0e114114d330caaf6a56e63ab4d8a3ee1ba3e350", "log": "Furious JDK-serialization-support code surge continuing...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n  * for reconfiguring blueprints and creating instances.\n  */\n public abstract class DeserializationContext\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = -7727373309391091315L;\n+\n     /**\n      * Let's limit length of error messages, for cases where underlying data\n      * may be very large -- no point in spamming logs with megs of meaningless\n         _view = config.getActiveView();\n         _parser = jp;\n         _injectableValues = injectableValues;\n-    }\n-\n-    // only for JDK deserialization\n-    protected DeserializationContext() {\n-        _cache = null;\n-        _factory = null;\n-\n-        _config = null;\n-        _featureFlags = 0;\n-        _view = null;\n-        _parser = null;\n-        _injectableValues = null;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializerFactoryConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializerFactoryConfig.java\n  * Configuration settings container class for {@link DeserializerFactory}.\n  */\n public class DeserializerFactoryConfig\n+    implements java.io.Serializable // since 2.1\n {\n+    private static final long serialVersionUID = 3683541151102256824L;\n+\n     protected final static Deserializers[] NO_DESERIALIZERS = new Deserializers[0];\n     protected final static KeyDeserializers[] NO_KEY_DESERIALIZERS = new KeyDeserializers[0];\n     protected final static BeanDeserializerModifier[] NO_MODIFIERS = new BeanDeserializerModifier[0];\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n  */\n public abstract class BasicDeserializerFactory\n     extends DeserializerFactory\n+    implements java.io.Serializable\n {\n+    private static final long serialVersionUID = 1;\n+\n     /**\n      * We will pre-create serializers for common non-structured\n      * (that is things other than Collection, Map or array)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n      * buffering in some cases, but usually just a simple lookup to ensure\n      * that ordering is correct.\n      */\n+    @SuppressWarnings(\"resource\")\n     protected Object deserializeWithObjectId(JsonParser jp, DeserializationContext ctxt)\n             throws IOException, JsonProcessingException\n     {\n         return bean;\n     }\n \n+    @SuppressWarnings(\"resource\")\n     protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n                     if (bean.getClass() != _beanType.getRawClass()) {\n                         // !!! 08-Jul-2011, tatu: Could probably support; but for now\n                         //   it's too complicated, so bail out\n+                        tokens.close();\n                         throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n                     }\n                     return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n         return ext.complete(jp, ctxt, bean);\n     }        \n \n+    @SuppressWarnings(\"resource\")\n     protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n  */\n public class BeanDeserializerFactory\n     extends BasicDeserializerFactory\n+    implements java.io.Serializable // since 2.1\n {\n+    private static final long serialVersionUID = 1;\n+\n     /**\n      * Signature of <b>Throwable.initCause</b> method.\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DefaultDeserializationContext.java\n             DeserializerFactory factory) {\n         super(src, factory);\n     }\n-    \n-    // Only for JDK deserialization:\n-    DefaultDeserializationContext() {\n-        super();\n-    }\n \n     /*\n     /**********************************************************\n     {\n         private static final long serialVersionUID = 1L;\n \n-        // Only for JDK deserialization:\n-        Impl() { super(); }\n-\n         /**\n          * Default constructor for a blueprint object, which will use the standard\n          * {@link DeserializerCache}, given factory.\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n      * completed deserializers, to resolve cyclic dependencies. This is the\n      * map used for storing deserializers before they are fully complete.\n      */\n-    final transient protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers\n+    final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers\n         = new HashMap<JavaType, JsonDeserializer<Object>>(8);\n \n     /*\n      */\n \n     public DeserializerCache() { }\n+\n+    /*\n+    /**********************************************************\n+    /* JDK serialization handling\n+    /**********************************************************\n+     */\n+\n+    Object writeReplace() {\n+        // instead of making this transient, just clear it:\n+        _incompleteDeserializers.clear();\n+        // TODO: clear out \"cheap\" cached deserializers?\n+        return this;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/FieldProperty.java\n     {\n         super(src);\n         _annotated = src._annotated;\n+        if (f == null) {\n+            throw new IllegalArgumentException(\"No Field passed for property '\"+src.getName()\n+                    +\"' (class \"+src.getDeclaringClass().getName()+\")\");\n+        }\n         _field = f;\n     }\n     \n     /**********************************************************\n      */\n \n-    Object writeReplace() {\n-        // Just need to make sure we reset Field reference from AnnotatedField\n+    Object readResolve() {\n         return new FieldProperty(this, _annotated.getAnnotated());\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/MethodProperty.java\n {\n     private static final long serialVersionUID = 1;\n \n-    protected final transient AnnotatedMethod _annotated;\n+    protected final AnnotatedMethod _annotated;\n     \n     /**\n      * Setter method for modifying property value; used for\n             return null;\n         }\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* JDK serialization handling\n+    /**********************************************************\n+     */\n+\n+    Object readResolve() {\n+        return new MethodProperty(this, _annotated.getAnnotated());\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/NumberDeserializers.java\n     protected abstract static class PrimitiveOrWrapperDeserializer<T>\n         extends StdScalarDeserializer<T>\n     {\n-        final T _nullValue;\n+        private static final long serialVersionUID = 1L;\n+\n+        protected final T _nullValue;\n         \n         protected PrimitiveOrWrapperDeserializer(Class<T> vc, T nvl)\n         {\n     public final static class BooleanDeserializer\n         extends PrimitiveOrWrapperDeserializer<Boolean>\n     {\n+        private static final long serialVersionUID = 1L;\n+\n         public BooleanDeserializer(Class<Boolean> cls, Boolean nvl)\n         {\n             super(cls, nvl);\n     public final static class IntegerDeserializer\n         extends PrimitiveOrWrapperDeserializer<Integer>\n     {\n+        private static final long serialVersionUID = 1L;\n+\n         public IntegerDeserializer(Class<Integer> cls, Integer nvl)\n         {\n             super(cls, nvl);\n     public final static class LongDeserializer\n         extends PrimitiveOrWrapperDeserializer<Long>\n     {\n+        private static final long serialVersionUID = 1L;\n+\n         public LongDeserializer(Class<Long> cls, Long nvl)\n         {\n             super(cls, nvl);\n     public final static class FloatDeserializer\n         extends PrimitiveOrWrapperDeserializer<Float>\n     {\n+        private static final long serialVersionUID = 1L;\n+\n         public FloatDeserializer(Class<Float> cls, Float nvl)\n         {\n             super(cls, nvl);\n     public final static class DoubleDeserializer\n         extends PrimitiveOrWrapperDeserializer<Double>\n     {\n+        private static final long serialVersionUID = 1L;\n+\n         public DoubleDeserializer(Class<Double> cls, Double nvl)\n         {\n             super(cls, nvl);\n      * But other numeric types may need such type information.\n      * This is why {@link #deserializeWithType} must be overridden.\n      */\n+    @SuppressWarnings(\"serial\")\n     @JacksonStdImpl\n     public final static class NumberDeserializer\n         extends StdScalarDeserializer<Number>\n      * This is bit trickier to implement efficiently, while avoiding\n      * overflow problems.\n      */\n+    @SuppressWarnings(\"serial\")\n     @JacksonStdImpl\n     public static class BigIntegerDeserializer\n         extends StdScalarDeserializer<BigInteger>\n         }\n     }\n     \n+    @SuppressWarnings(\"serial\")\n     @JacksonStdImpl\n     public static class BigDecimalDeserializer\n         extends StdScalarDeserializer<BigDecimal>\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java\n package com.fasterxml.jackson.databind.introspect;\n \n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.Member;\n-import java.lang.reflect.Type;\n+import java.lang.reflect.*;\n \n \n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.type.TypeBindings;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n \n public final class AnnotatedConstructor\n     extends AnnotatedWithParams\n {\n+    private static final long serialVersionUID = 1L;\n+\n     protected final Constructor<?> _constructor;\n+\n+    /**\n+     * Field that is used to make JDK serialization work with this\n+     * object.\n+     * \n+     * @since 2.1\n+     */\n+    protected Serialization _serialization;\n     \n     /*\n     /**********************************************************\n         _constructor = constructor;\n     }\n \n+    /**\n+     * Method used for JDK serialization support\n+     * @since 2.1\n+     */\n+    protected AnnotatedConstructor(Serialization ser)\n+    {\n+        super(null, null);\n+        _constructor = null;\n+        _serialization = ser;\n+    }\n+    \n     @Override\n     public AnnotatedConstructor withAnnotations(AnnotationMap ann) {\n         return new AnnotatedConstructor(_constructor, ann, _paramAnnotations);\n     public String toString() {\n         return \"[constructor for \"+getName()+\", annotations: \"+_annotations+\"]\";\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* JDK serialization handling\n+    /**********************************************************\n+     */\n+\n+    Object writeReplace() {\n+        return new AnnotatedConstructor(new Serialization(_constructor));\n+    }\n+\n+    Object readResolve() {\n+        Class<?> clazz = _serialization.clazz;\n+        try {\n+            Constructor<?> ctor = clazz.getDeclaredConstructor(_serialization.args);\n+            // 06-Oct-2012, tatu: Has \"lost\" its security override, must force back\n+            if (!ctor.isAccessible()) {\n+                ClassUtil.checkAndFixAccess(ctor);\n+            }\n+            return new AnnotatedConstructor(ctor, null, null);\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Could not find constructor with \"\n+                    +_serialization.args.length+\" args from Class '\"+clazz.getName());\n+        }\n+    }\n+    \n+    /**\n+     * Helper class that is used as the workaround to persist\n+     * Field references. It basically just stores declaring class\n+     * and field name.\n+     */\n+    private final static class Serialization\n+        implements java.io.Serializable\n+    {\n+        private static final long serialVersionUID = 1L;\n+        protected Class<?> clazz;\n+        protected Class<?>[] args;\n+\n+        public Serialization(Constructor<?> ctor) {\n+            clazz = ctor.getDeclaringClass();\n+            args = ctor.getParameterTypes();\n+        }\n+    }\n }\n-\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java\n import java.lang.reflect.Field;\n import java.lang.reflect.Member;\n import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n \n /**\n  * Object that represents non-static (and usually non-transient/volatile)\n     Object readResolve() {\n         Class<?> clazz = _serialization.clazz;\n         try {\n-            return new AnnotatedField(clazz.getDeclaredField(_serialization.name), null);\n+            Field f = clazz.getDeclaredField(_serialization.name);\n+            // 06-Oct-2012, tatu: Has \"lost\" its security override, may need to force back\n+            if (!f.isAccessible()) {\n+                ClassUtil.checkAndFixAccess(f);\n+            }\n+            return new AnnotatedField(f, null);\n         } catch (Exception e) {\n             throw new IllegalArgumentException(\"Could not find method '\"+_serialization.name\n                         +\"' from Class '\"+clazz.getName());\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java\n \n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.type.TypeBindings;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n \n public final class AnnotatedMethod\n     extends AnnotatedWithParams\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 1347232380363777953L;\n+    private static final long serialVersionUID = 1L;\n \n     final protected transient Method _method;\n \n \n     /**\n      * Method used for JDK serialization support\n+     * @since 2.1\n      */\n     protected AnnotatedMethod(Serialization ser)\n     {\n         try {\n             Method m = clazz.getDeclaredMethod(_serialization.name,\n                     _serialization.args);\n+            // 06-Oct-2012, tatu: Has \"lost\" its security override, may need to force back\n+            if (!m.isAccessible()) {\n+                ClassUtil.checkAndFixAccess(m);\n+            }\n             return new AnnotatedMethod(m, null, null);\n         } catch (Exception e) {\n             throw new IllegalArgumentException(\"Could not find method '\"+_serialization.name\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n  */\n public class BeanSerializerFactory\n     extends BasicSerializerFactory\n+    implements java.io.Serializable // since 2.1\n {\n-    private static final long serialVersionUID = -5348294866902611332L;\n+    private static final long serialVersionUID = 1;\n \n     /**\n      * Like {@link BasicSerializerFactory}, this factory is stateless, and\n--- a/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestJDKSerialization.java\n         assertEquals(2, p2.y);\n     }\n \n+    public void testObjectMapper() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        final String EXP_JSON = \"{\\\"x\\\":2,\\\"y\\\":3}\";\n+        final MyPojo p = new MyPojo(2, 3);\n+        assertEquals(EXP_JSON, mapper.writeValueAsString(p));\n+\n+        byte[] bytes = jdkSerialize(mapper);\n+        ObjectMapper mapper2 = jdkDeserialize(bytes);\n+        assertEquals(EXP_JSON, mapper2.writeValueAsString(p));\n+        MyPojo p2 = mapper2.readValue(EXP_JSON, MyPojo.class);\n+        assertEquals(p.x, p2.x);\n+        assertEquals(p.y, p2.y);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n+import com.fasterxml.jackson.test.BrokenStringReader;\n \n /**\n  * Unit test for verifying that exceptions are properly handled (caught,\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotations.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotations.java\n         public ClassMethodSerializer(int x) { _x = x; }\n \n         @JsonSerialize(using=StringSerializer.class)\n-            public int getX() { return _x; }\n+        public int getX() { return _x; }\n     }\n \n     /**\n \n         // Basically, has no effect, hence gets serialized as number\n         @JsonSerialize(using=JsonSerializer.None.class)\n-            public int getX() { return _x; }\n+        public int getX() { return _x; }\n     }\n \n     /**\n     static class BaseBean {\n         public int getX() { return 1; }\n         @SuppressWarnings(\"unused\")\n-            @JsonProperty(\"y\")\n+        @JsonProperty(\"y\")\n         private int getY() { return 2; }\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestExceptionHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestExceptionHandling.java\n import com.fasterxml.jackson.databind.module.SimpleModule;\n \n import com.fasterxml.jackson.test.BaseTest;\n+import com.fasterxml.jackson.test.BrokenStringWriter;\n \n /**\n  * Unit test for verifying that exceptions are properly handled (caught,\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/test/BrokenStringReader.java\n+package com.fasterxml.jackson.test;\n+\n+import java.io.*;\n+\n+public class BrokenStringReader\n+    extends FilterReader\n+{\n+    final String _message;\n+\n+    public BrokenStringReader(String content, String msg)\n+    {\n+        super(new StringReader(content));\n+        _message = msg;\n+    }\n+\n+    @Override\n+    public int read(char[] cbuf, int off, int len)\n+        throws IOException\n+    {\n+        int i = super.read(cbuf, off, len);\n+        if (i < 0) {\n+            throw new IOException(_message);\n+        }\n+        return i;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/test/BrokenStringWriter.java\n+package com.fasterxml.jackson.test;\n+\n+import java.io.*;\n+\n+public class BrokenStringWriter\n+    extends FilterWriter\n+{\n+    final String _message;\n+\n+    public BrokenStringWriter(String msg) {\n+        super(new StringWriter());\n+        _message = msg;\n+    }\n+\n+    @Override\n+    public void write(char[] cbuf, int off, int len) throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+    \n+    @Override\n+    public void write(int c) throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+    \n+    @Override\n+    public void write(String str, int off, int len)  throws IOException\n+    {\n+        throw new IOException(_message);\n+    }\n+}", "timestamp": 1349545541, "metainfo": ""}