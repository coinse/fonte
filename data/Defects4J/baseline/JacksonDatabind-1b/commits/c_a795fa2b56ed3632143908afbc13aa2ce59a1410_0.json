{"sha": "a795fa2b56ed3632143908afbc13aa2ce59a1410", "log": "Fix #118", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n         for (int i = 0, len = _properties.length; i < len; ++i) {\n             String typeId = _typeIds[i];\n             if (typeId == null) {\n+                TokenBuffer tokens = _tokens[i];\n                 // let's allow missing both type and property (may already have been set, too)\n-                if (_tokens[i] == null) {\n+                // but not just one\n+                if (tokens == null) {\n                     continue;\n                 }\n-                // but not just one\n-                // 26-Oct-2012, tatu: As per [Issue#94], must allow use of 'defaultImpl'\n-                if (!_properties[i].hasDefaultType()) {\n-                    throw ctxt.mappingException(\"Missing external type id property '\"+_properties[i].getTypePropertyName()+\"'\");\n+                /* [Issue#118]: Need to mind natural types, for which no type id\n+                 *   will be included.\n+                 */\n+                JsonToken t = tokens.firstToken();\n+                if (t != null && t.isScalarValue()) {\n+                    JsonParser buffered = tokens.asParser(jp);\n+                    buffered.nextToken();\n+                    SettableBeanProperty extProp = _properties[i].getProperty();\n+                    Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType());\n+                    if (result != null) {\n+                        extProp.set(bean, result);\n+                        continue;\n+                    }\n+                    // 26-Oct-2012, tatu: As per [Issue#94], must allow use of 'defaultImpl'\n+                    if (!_properties[i].hasDefaultType()) {\n+                        throw ctxt.mappingException(\"Missing external type id property '\"+_properties[i].getTypePropertyName()+\"'\");\n+                    }\n+                    typeId = _properties[i].getDefaultTypeId();\n                 }\n-                typeId = _properties[i].getDefaultTypeId();\n             } else if (_tokens[i] == null) {\n                 SettableBeanProperty prop = _properties[i].getProperty();\n                 throw ctxt.mappingException(\"Missing property '\"+prop.getName()+\"' for external type id '\"+_properties[i].getTypePropertyName());\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n \n             DeserializationContext ctxt)\n         throws IOException, JsonProcessingException;\n \n+    /*\n+    /**********************************************************\n+    /* Shared helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method used to check if given parser might be pointing to\n+     * a \"natural\" value, and one that would be acceptable as the\n+     * result value (compatible with declared base type)\n+     */\n+    public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt,\n+            JavaType baseType)\n+        throws IOException, JsonProcessingException\n+    {\n+        return deserializeIfNatural(jp, ctxt, baseType.getRawClass());\n+    }\n+    \n+    public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt,\n+            Class<?> base)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == null) {\n+            return null;\n+        }\n+        switch (t) {\n+        case VALUE_STRING:\n+            if (base.isAssignableFrom(String.class)) {\n+                return jp.getText();\n+            }\n+            break;\n+        case VALUE_NUMBER_INT:\n+            if (base.isAssignableFrom(Integer.class)) {\n+                return jp.getIntValue();\n+            }\n+            break;\n+\n+        case VALUE_NUMBER_FLOAT:\n+            if (base.isAssignableFrom(Double.class)) {\n+                return Double.valueOf(jp.getDoubleValue());\n+            }\n+            break;\n+        case VALUE_TRUE:\n+            if (base.isAssignableFrom(Boolean.class)) {\n+                return Boolean.TRUE;\n+            }\n+            break;\n+        case VALUE_FALSE:\n+            if (base.isAssignableFrom(Boolean.class)) {\n+                return Boolean.FALSE;\n+            }\n+            break;\n+        }\n+        return null;\n+    }\n }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n             return deser.deserialize(jp, ctxt);\n         }\n         // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n-        Object result = _deserializeIfNatural(jp, ctxt);\n+        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n         if (result != null) {\n             return result;\n         }\n     // These are fine from base class:\n     //public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt)\n     //public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt)    \n-\n-    /**\n-     * Helper method used to check if given parser might be pointing to\n-     * a \"natural\" value, and one that would be acceptable as the\n-     * result value (compatible with declared base type)\n-     */\n-    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        switch (jp.getCurrentToken()) {\n-        case VALUE_STRING:\n-            if (_baseType.getRawClass().isAssignableFrom(String.class)) {\n-                return jp.getText();\n-            }\n-            break;\n-        case VALUE_NUMBER_INT:\n-            if (_baseType.getRawClass().isAssignableFrom(Integer.class)) {\n-                return jp.getIntValue();\n-            }\n-            break;\n-\n-        case VALUE_NUMBER_FLOAT:\n-            if (_baseType.getRawClass().isAssignableFrom(Double.class)) {\n-                return Double.valueOf(jp.getDoubleValue());\n-            }\n-            break;\n-        case VALUE_TRUE:\n-            if (_baseType.getRawClass().isAssignableFrom(Boolean.class)) {\n-                return Boolean.TRUE;\n-            }\n-            break;\n-        case VALUE_FALSE:\n-            if (_baseType.getRawClass().isAssignableFrom(Boolean.class)) {\n-                return Boolean.FALSE;\n-            }\n-            break;\n-        }\n-        return null;\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n     @Override\n     public String toString()\n     {\n-    \tStringBuilder sb = new StringBuilder();\n-    \tsb.append('[').append(getClass().getName());\n-    \tsb.append(\"; base-type:\").append(_baseType);\n-    \tsb.append(\"; id-resolver: \").append(_idResolver);\n-    \tsb.append(']');\n-    \treturn sb.toString();\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[').append(getClass().getName());\n+        sb.append(\"; base-type:\").append(_baseType);\n+        sb.append(\"; id-resolver: \").append(_idResolver);\n+    \t    sb.append(']');\n+    \t    return sb.toString();\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n //  @Override\n     public String idFromValueAndType(Object value, Class<?> type)\n     {\n+        /* 18-Jan-2013, tatu: We may be called with null value occasionally\n+         *   it seems; nothing much we can figure out that way.\n+         */\n+        if (value == null) {\n+            return null;\n+        }\n         return idFromValue(value);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n         Parser p = new Parser(_first, src.getCodec());\n         p.setLocation(src.getTokenLocation());\n         return p;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Additional accessors\n+    /**********************************************************\n+     */\n+\n+    public JsonToken firstToken() {\n+        if (_first != null) {\n+            return _first.type(0);\n+        }\n+        return null;\n     }\n     \n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n     }\n \n     // For [Issue#96]: should allow use of default impl, if property missing\n+    /* 18-Jan-2013, tatu: Unfortunately this collides with [Issue#118], and I don't\n+     *   know what the best resolution is. For now at least \n+     */\n+    /*\n     public void testWithDefaultAndMissing() throws Exception\n     {\n         ExternalBeanWithDefault input = new ExternalBeanWithDefault(13);\n         assertNotNull(defaulted.bean);\n         assertSame(ValueBean.class, defaulted.bean.getClass());\n     }\n+    */\n \n     // For [Issue#118]\n     // Note: String works fine, since no type id will used; other scalar types have issues\n         assertTrue(result.value instanceof java.util.Date);\n     }\n \n+    // For [Issue#118] using \"natural\" type(s)\n+    public void testWithNaturalScalar118() throws Exception\n+    {\n+        ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13));\n+        String json = MAPPER.writeValueAsString(input);\n+        assertNotNull(json);\n+        // and back just to be sure:\n+        ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);\n+        assertNotNull(result.value);\n+        assertTrue(result.value instanceof Integer);\n+\n+        // ditto with others types\n+        input = new ExternalTypeWithNonPOJO(Boolean.TRUE);\n+        json = MAPPER.writeValueAsString(input);\n+        assertNotNull(json);\n+        result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);\n+        assertNotNull(result.value);\n+        assertTrue(result.value instanceof Boolean);\n+\n+        input = new ExternalTypeWithNonPOJO(\"foobar\");\n+        json = MAPPER.writeValueAsString(input);\n+        assertNotNull(json);\n+        result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);\n+        assertNotNull(result.value);\n+        assertTrue(result.value instanceof String);\n+        assertEquals(\"foobar\", result.value);\n+    }\n+    \n     // For [Issue#119]\n     public void testWithAsValue() throws Exception\n     {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestExternalTypeId extends BaseMapTest\n+{\n+    public void testTypes() throws IOException {\n+    final ObjectMapper mapper = new ObjectMapper();\n+    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    final Point _date = new Point(new Date());\n+    final Point _integer = new Point(12231321);\n+    final Point _boolean = new Point(Boolean.TRUE);\n+    final Point _long = new Point(1234L);\n+\n+    final Point _pojo = new Point(new Pojo(1));\n+    final String s_date = mapper.writeValueAsString(_date);\n+    final String s_integer = mapper.writeValueAsString(_integer);\n+\n+System.err.println(\"Int -> \"+s_integer);   \n+    \n+    final String s_boolean = mapper.writeValueAsString(_boolean);\n+    final String s_long = mapper.writeValueAsString(_long);\n+    final String s_pojo = mapper.writeValueAsString(_pojo);\n+\n+    final Point d_date = mapper.readValue(s_date, Point.class);\n+    final Point d_long = mapper.readValue(s_long, Point.class);\n+    final Point d_pojo = mapper.readValue(s_pojo, Point.class);\n+    final Point d_integer = mapper.readValue(s_integer, Point.class);\n+    final Point d_boolean = mapper.readValue(s_boolean, Point.class);\n+    }\n+\n+    @JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY,\n+        getterVisibility = JsonAutoDetect.Visibility.NONE,\n+        setterVisibility = JsonAutoDetect.Visibility.NONE)\n+    private static class Point {\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+        property = \"t\",\n+        visible = true,\n+        include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+        defaultImpl = String.class)\n+        @JsonSubTypes({\n+        @JsonSubTypes.Type(value = Date.class, name = \"date\"),\n+        @JsonSubTypes.Type(value = Integer.class, name = \"int\"),\n+        @JsonSubTypes.Type(value = Long.class, name = \"long\"),\n+        @JsonSubTypes.Type(value = Boolean.class, name = \"bool\"),\n+        @JsonSubTypes.Type(value = Pojo.class, name = \"pojo\"),\n+        @JsonSubTypes.Type(value = String.class, name = \"\")\n+        })\n+        private final Object v;\n+    \n+        @JsonCreator\n+        @SuppressWarnings(\"unused\")\n+        public Point(@JsonProperty(\"v\") Object v) {\n+            this.v = v;\n+        }\n+    \n+        public Object getValue() {\n+            return v;\n+        }\n+    }\n+     \n+\n+    private static class Pojo {\n+        public final int p;\n+\n+        @JsonCreator\n+        private Pojo(@JsonProperty(\"p\") int p) {\n+            this.p = p;\n+        }\n+    }\n+}", "timestamp": 1358568311, "metainfo": ""}