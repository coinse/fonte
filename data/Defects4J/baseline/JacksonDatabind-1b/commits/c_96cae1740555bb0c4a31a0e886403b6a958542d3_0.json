{"sha": "96cae1740555bb0c4a31a0e886403b6a958542d3", "log": "Fix #167", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.jsontype.TypeSerializerWrapper;\n import com.fasterxml.jackson.databind.ser.BeanSerializer;\n import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n \n     {\n         try {\n             Object value = _accessorMethod.invoke(bean);\n-\n             if (value == null) {\n                 prov.defaultSerializeNull(jgen);\n                 return;\n                     return;\n                 }\n             }\n+            /* 13-Feb-2013, tatu: Turns out that work-around should NOT be required\n+             *   at all; it would not lead to correct behavior (as per #167).\n+             */\n             // and then redirect type id lookups\n-            TypeSerializer typeSer = new TypeSerializerWrapper(typeSer0, bean);\n-            ser.serializeWithType(value, jgen, provider, typeSer);\n+//            TypeSerializer typeSer = new TypeSerializerWrapper(typeSer0, bean);\n+            ser.serializeWithType(value, jgen, provider, typeSer0);\n         } catch (IOException ioe) {\n             throw ioe;\n         } catch (Exception e) {\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n         assertEquals(\"foobar\", result.value);\n     }\n     \n-    // For [Issue#119]\n+    // For [Issue#119]... and bit of [#167] as well\n     public void testWithAsValue() throws Exception\n     {\n         ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(new AsValueThingy(12345L));\n         String json = MAPPER.writeValueAsString(input);\n         assertNotNull(json);\n-        assertEquals(\"{\\\"value\\\":12345,\\\"type\\\":\\\"thingy\\\"}\", json);\n+        assertEquals(\"{\\\"value\\\":12345,\\\"type\\\":\\\"date\\\"}\", json);\n \n         // and get it back too:\n         ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);\n         assertNotNull(result);\n         assertNotNull(result.value);\n+        /* 13-Feb-2013, tatu: Urgh. I don't think this can work quite as intended...\n+         *   since POJO type, and type of thing @JsonValue annotated method returns\n+         *   are not related. Best we can do is thus this:\n+         */\n+        /*\n         assertEquals(AsValueThingy.class, result.value.getClass());\n         assertEquals(12345L, ((AsValueThingy) result.value).rawDate);\n+        */\n+        assertEquals(Date.class, result.value.getClass());\n+        assertEquals(12345L, ((Date) result.value).getTime());\n     }\n }", "timestamp": 1360803602, "metainfo": ""}