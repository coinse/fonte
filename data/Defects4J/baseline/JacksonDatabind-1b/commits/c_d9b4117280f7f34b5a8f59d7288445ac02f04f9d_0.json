{"sha": "d9b4117280f7f34b5a8f59d7288445ac02f04f9d", "log": "Merge pull request #151 from Airborn/master  Test case for #97", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/failing/TestObjectIdSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestObjectIdSerialization.java\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import java.util.LinkedHashSet;\n import java.util.Set;\n \n         @JsonIdentityReference(alwaysAsId = true)\n         public SetContainer objGroup;\n \n+        public Obj() {\n+        }\n+\n         public Obj(int id) {\n             this.id = id;\n         }\n //        @JsonSerialize(contentAs = Obj.class)\n         public Set<Obj> objs = new LinkedHashSet<Obj>();\n \n+        public SetContainer() {\n+        }\n+\n         public SetContainer(int id) {\n             this.id = id;\n         }\n         public int id;\n         @JsonIdentityReference(alwaysAsId = true)\n         public Obj[] objs;\n+\n+        public ArrContainer() {\n+        }\n \n         public ArrContainer(int id) {\n             this.id = id;\n         String json = MAPPER.writeValueAsString(os);\n         assertEquals(EXP_ARR_SET, json);\n     }\n+\n+    public void testDeserialization() throws Exception {\n+        Obj o = new Obj(1);\n+        o.objGroup = new SetContainer(4);\n+        String json = MAPPER.writeValueAsString(o);\n+        Obj deser = MAPPER.readValue(json, Obj.class);\n+        assertEquals(deser.id, 1);\n+        assertEquals(deser.objGroup.id, 4);\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.core.TreeNode;\n+import com.fasterxml.jackson.databind.node.JsonNodeType;\n import com.fasterxml.jackson.databind.util.EmptyIterator;\n \n /**\n     // // First high-level division between values, containers and \"missing\"\n \n     /**\n+     * Return the type of this node\n+     *\n+     * @return the node type as a {@link JsonNodeType} enum value\n+     */\n+    public abstract JsonNodeType getNodeType();\n+\n+    /**\n      * Method that returns true for all value nodes: ones that \n      * are not containers, and that do not represent \"missing\" nodes\n      * in the path. Such value nodes represent String, Number, Boolean\n      * {@link #isContainerNode} and {@link #isMissingNode} ever\n      * returns true for any given node.\n      */\n-    public boolean isValueNode() { return false; }\n+    public final boolean isValueNode()\n+    {\n+        switch (getNodeType()) {\n+            case ARRAY: case OBJECT: case MISSING:\n+                return false;\n+            default:\n+                return true;\n+        }\n+    }\n \n     /**\n      * Method that returns true for container nodes: Arrays and Objects.\n      * {@link #isContainerNode} and {@link #isMissingNode} ever\n      * returns true for any given node.\n      */\n-    public boolean isContainerNode() { return false; }\n+    public final boolean isContainerNode()\n+    {\n+        final JsonNodeType type = getNodeType();\n+        return type == JsonNodeType.OBJECT || type == JsonNodeType.ARRAY;\n+    }\n \n     /**\n      * Method that returns true for \"virtual\" nodes which represent\n      * {@link #isContainerNode} and {@link #isMissingNode} ever\n      * returns true for any given node.\n      */\n-    public boolean isMissingNode() { return false; }\n+    public final boolean isMissingNode()\n+    {\n+        return getNodeType() == JsonNodeType.MISSING;\n+    }\n \n     // // Then more specific type introspection\n     // // (along with defaults to be overridden)\n     /**\n      * @return True if this node represents JSON Array\n      */\n-    public boolean isArray() { return false; }\n+    public final boolean isArray()\n+    {\n+        return getNodeType() == JsonNodeType.ARRAY;\n+    }\n \n     /**\n      * @return True if this node represents JSON Object\n      */\n-    public boolean isObject() { return false; }\n+    public final boolean isObject()\n+    {\n+        return getNodeType() == JsonNodeType.OBJECT;\n+    }\n \n     /**\n      * Method that can be used to check if the node is a wrapper\n      *\n      * @return True if this node wraps a POJO\n      */\n-    public boolean isPojo() { return false; }\n+    public final boolean isPojo()\n+    {\n+        return getNodeType() == JsonNodeType.POJO;\n+    }\n \n     /**\n      * @return True if this node represents a numeric JSON\n      *   value\n      */\n-    public boolean isNumber() { return false; }\n+    public final boolean isNumber()\n+    {\n+        return getNodeType() == JsonNodeType.NUMBER;\n+    }\n \n     /**\n      * \n     public boolean isBigDecimal() { return false; }\n     public boolean isBigInteger() { return false; }\n \n-    public boolean isTextual() { return false; }\n+    public final boolean isTextual()\n+    {\n+        return getNodeType() == JsonNodeType.STRING;\n+    }\n \n     /**\n      * Method that can be used to check if this node was created from\n      * JSON boolean value (literals \"true\" and \"false\").\n      */\n-    public boolean isBoolean() { return false; }\n+    public final boolean isBoolean()\n+    {\n+        return getNodeType() == JsonNodeType.BOOLEAN;\n+    }\n \n     /**\n      * Method that can be used to check if this node was created from\n      * JSON literal null value.\n      */\n-    public boolean isNull() { return false; }\n+    public final boolean isNull()\n+    {\n+        return getNodeType() == JsonNodeType.NULL;\n+    }\n \n     /**\n      * Method that can be used to check if this node represents\n      *\n      * @return True if this node represents base64 encoded binary data\n      */\n-    public boolean isBinary() { return false; }\n+    public final boolean isBinary()\n+    {\n+        return getNodeType() == JsonNodeType.BINARY;\n+    }\n \n     /**\n      * Method that can be used for efficient type detection\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.core.util.*;\n import com.fasterxml.jackson.databind.cfg.BaseSettings;\n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.*;\n      * Method that will return version information stored in and read from jar\n      * that contains this class.\n      */\n-//  @Override\n+    @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n+        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n import com.fasterxml.jackson.core.type.ResolvedType;\n import com.fasterxml.jackson.core.type.TypeReference;\n \n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n import com.fasterxml.jackson.databind.deser.DataFormatReaders;\n import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\n import com.fasterxml.jackson.databind.deser.DeserializationProblemHandler;\n      * Method that will return version information stored in and read from jar\n      * that contains this class.\n      */\n-//  @Override\n+    @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n+        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n import com.fasterxml.jackson.core.util.Instantiatable;\n import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n+\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n      * Method that will return version information stored in and read from jar\n      * that contains this class.\n      */\n-//  @Override\n+    @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n+        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n     \n     /*\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/PackageVersion.java.in\n+package @package@;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.core.Versioned;\n+import com.fasterxml.jackson.core.util.VersionUtil;\n+\n+/**\n+ * Automatically generated from PackageVersion.java.in during\n+ * packageVersion-generate execution of maven-replacer-plugin in\n+ * pom.xml.\n+ */\n+public final class PackageVersion implements Versioned {\n+    public final static Version VERSION = VersionUtil.parseVersion(\n+        \"@projectversion@\", \"@projectgroupid@\", \"@projectartifactid@\");\n+\n+    @Override\n+    public Version version() {\n+        return VERSION;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n                 }\n             }\n         }\n-        \n+\n+        // Sanity check: does the chosen instantatior have incomplete creators?\n+        if (instantiator.getIncompleteParameter() != null) {\n+            final AnnotatedParameter nonAnnotatedParam = instantiator.getIncompleteParameter();\n+            final AnnotatedWithParams ctor = nonAnnotatedParam.getOwner();\n+            throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()+\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-paramater constructor annotated as Creator\");\n+        }\n+\n         return instantiator;\n     }\n \n                 } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) {\n                     // [712] secondary: all but one injectable, one un-annotated (un-named)\n                     creators.addDelegatingCreator(ctor, properties);\n-                } else { // otherwise, epic fail\n-                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()+\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-paramater constructor annotated as Creator\");\n+                } else { // otherwise, record the incomplete parameter for later error messaging.\n+                    creators.addIncompeteParameter(nonAnnotatedParam);\n                 }\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n package com.fasterxml.jackson.databind.deser;\n \n import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n \n \n     public AnnotatedWithParams getWithArgsCreator() {\n         return null;\n     }\n+\n+    /**\n+     * If an incomplete creator was found, this is the first parameter that\n+     * needs further annotation to help make the creator complete.\n+     */\n+    public AnnotatedParameter getIncompleteParameter() {\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n     \n     protected AnnotatedWithParams _propertyBasedCreator;\n     protected CreatorProperty[] _propertyBasedArgs = null;\n+\n+    protected AnnotatedParameter _incompleteParameter;\n \n     /*\n     /**********************************************************\n         inst.configureFromLongCreator(_longCreator);\n         inst.configureFromDoubleCreator(_doubleCreator);\n         inst.configureFromBooleanCreator(_booleanCreator);\n+        inst.configureIncompleteParameter(_incompleteParameter);\n         return inst;\n     }\n     \n         _propertyBasedArgs = properties;\n     }\n \n+    public void addIncompeteParameter(AnnotatedParameter parameter) {\n+        if (_incompleteParameter == null) {\n+            _incompleteParameter = parameter;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Accessors\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.util.TokenBuffer;\n         for (int i = 0, len = _properties.length; i < len; ++i) {\n             String typeId = _typeIds[i];\n             if (typeId == null) {\n+                TokenBuffer tokens = _tokens[i];\n                 // let's allow missing both type and property (may already have been set, too)\n-                if (_tokens[i] == null) {\n+                // but not just one\n+                if (tokens == null) {\n                     continue;\n                 }\n-                // but not just one\n-                // 26-Oct-2012, tatu: As per [Issue#94], must allow use of 'defaultImpl'\n-                if (!_properties[i].hasDefaultType()) {\n-                    throw ctxt.mappingException(\"Missing external type id property '\"+_properties[i].getTypePropertyName()+\"'\");\n+                /* [Issue#118]: Need to mind natural types, for which no type id\n+                 *   will be included.\n+                 */\n+                JsonToken t = tokens.firstToken();\n+                if (t != null && t.isScalarValue()) {\n+                    JsonParser buffered = tokens.asParser(jp);\n+                    buffered.nextToken();\n+                    SettableBeanProperty extProp = _properties[i].getProperty();\n+                    Object result = TypeDeserializer.deserializeIfNatural(buffered, ctxt, extProp.getType());\n+                    if (result != null) {\n+                        extProp.set(bean, result);\n+                        continue;\n+                    }\n+                    // 26-Oct-2012, tatu: As per [Issue#94], must allow use of 'defaultImpl'\n+                    if (!_properties[i].hasDefaultType()) {\n+                        throw ctxt.mappingException(\"Missing external type id property '\"+_properties[i].getTypePropertyName()+\"'\");\n+                    }\n+                    typeId = _properties[i].getDefaultTypeId();\n                 }\n-                typeId = _properties[i].getDefaultTypeId();\n             } else if (_tokens[i] == null) {\n                 SettableBeanProperty prop = _properties[i].getProperty();\n                 throw ctxt.mappingException(\"Missing property '\"+prop.getName()+\"' for external type id '\"+_properties[i].getTypePropertyName());\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n package com.fasterxml.jackson.databind.deser.std;\n \n import java.io.IOException;\n+import java.util.List;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.DeserializationConfig;\n import com.fasterxml.jackson.databind.deser.CreatorProperty;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n \n \n     protected AnnotatedWithParams _fromLongCreator;\n     protected AnnotatedWithParams _fromDoubleCreator;\n     protected AnnotatedWithParams _fromBooleanCreator;\n+\n+    // // // Incomplete creator\n+    protected AnnotatedParameter  _incompleteParameter;\n     \n     /*\n     /**********************************************************\n \n     public void configureFromBooleanCreator(AnnotatedWithParams creator) {\n         _fromBooleanCreator = creator;\n+    }\n+\n+    public void configureIncompleteParameter(AnnotatedParameter parameter) {\n+        _incompleteParameter = parameter;\n     }\n     \n     /*\n     public AnnotatedWithParams getWithArgsCreator() {\n         return _withArgsCreator;\n     }\n+\n+    @Override\n+    public AnnotatedParameter getIncompleteParameter() {\n+        return _incompleteParameter;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n import com.fasterxml.jackson.annotation.*;\n \n import com.fasterxml.jackson.core.Version;\n+\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.*;\n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n \n     @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n+        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n package com.fasterxml.jackson.databind.introspect;\n \n import com.fasterxml.jackson.core.Version;\n+\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n \n /**\n  * Dummy, \"no-operation\" implementation of {@link AnnotationIntrospector}.\n \n         @Override\n         public Version version() {\n-            return DatabindVersion.instance.version();\n-        }\n+            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n+       }\n     };\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n                 } else {\n                     old.addAll(prop);\n                 }\n+\n+                // replace the creatorProperty too, if there is one\n+                if (_creatorProperties != null) {\n+                    for (int i = 0; i < _creatorProperties.size(); ++i) {\n+                        if (_creatorProperties.get(i).getInternalName() == prop.getInternalName()) {\n+                            _creatorProperties.set(i, prop);\n+                            break;\n+                        }\n+                    }\n+                }\n             }\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.BeanProperty;\n import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n \n             DeserializationContext ctxt)\n         throws IOException, JsonProcessingException;\n \n+    /*\n+    /**********************************************************\n+    /* Shared helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method used to check if given parser might be pointing to\n+     * a \"natural\" value, and one that would be acceptable as the\n+     * result value (compatible with declared base type)\n+     */\n+    public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt,\n+            JavaType baseType)\n+        throws IOException, JsonProcessingException\n+    {\n+        return deserializeIfNatural(jp, ctxt, baseType.getRawClass());\n+    }\n+    \n+    public static Object deserializeIfNatural(JsonParser jp, DeserializationContext ctxt,\n+            Class<?> base)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == null) {\n+            return null;\n+        }\n+        switch (t) {\n+        case VALUE_STRING:\n+            if (base.isAssignableFrom(String.class)) {\n+                return jp.getText();\n+            }\n+            break;\n+        case VALUE_NUMBER_INT:\n+            if (base.isAssignableFrom(Integer.class)) {\n+                return jp.getIntValue();\n+            }\n+            break;\n+\n+        case VALUE_NUMBER_FLOAT:\n+            if (base.isAssignableFrom(Double.class)) {\n+                return Double.valueOf(jp.getDoubleValue());\n+            }\n+            break;\n+        case VALUE_TRUE:\n+            if (base.isAssignableFrom(Boolean.class)) {\n+                return Boolean.TRUE;\n+            }\n+            break;\n+        case VALUE_FALSE:\n+            if (base.isAssignableFrom(Boolean.class)) {\n+                return Boolean.FALSE;\n+            }\n+            break;\n+        }\n+        return null;\n+    }\n }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n             return deser.deserialize(jp, ctxt);\n         }\n         // or, perhaps we just bumped into a \"natural\" value (boolean/int/double/String)?\n-        Object result = _deserializeIfNatural(jp, ctxt);\n+        Object result = TypeDeserializer.deserializeIfNatural(jp, ctxt, _baseType);\n         if (result != null) {\n             return result;\n         }\n     // These are fine from base class:\n     //public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt)\n     //public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt)    \n-\n-    /**\n-     * Helper method used to check if given parser might be pointing to\n-     * a \"natural\" value, and one that would be acceptable as the\n-     * result value (compatible with declared base type)\n-     */\n-    protected Object _deserializeIfNatural(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {\n-        switch (jp.getCurrentToken()) {\n-        case VALUE_STRING:\n-            if (_baseType.getRawClass().isAssignableFrom(String.class)) {\n-                return jp.getText();\n-            }\n-            break;\n-        case VALUE_NUMBER_INT:\n-            if (_baseType.getRawClass().isAssignableFrom(Integer.class)) {\n-                return jp.getIntValue();\n-            }\n-            break;\n-\n-        case VALUE_NUMBER_FLOAT:\n-            if (_baseType.getRawClass().isAssignableFrom(Double.class)) {\n-                return Double.valueOf(jp.getDoubleValue());\n-            }\n-            break;\n-        case VALUE_TRUE:\n-            if (_baseType.getRawClass().isAssignableFrom(Boolean.class)) {\n-                return Boolean.TRUE;\n-            }\n-            break;\n-        case VALUE_FALSE:\n-            if (_baseType.getRawClass().isAssignableFrom(Boolean.class)) {\n-                return Boolean.FALSE;\n-            }\n-            break;\n-        }\n-        return null;\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n     @Override\n     public String toString()\n     {\n-    \tStringBuilder sb = new StringBuilder();\n-    \tsb.append('[').append(getClass().getName());\n-    \tsb.append(\"; base-type:\").append(_baseType);\n-    \tsb.append(\"; id-resolver: \").append(_idResolver);\n-    \tsb.append(']');\n-    \treturn sb.toString();\n+        StringBuilder sb = new StringBuilder();\n+        sb.append('[').append(getClass().getName());\n+        sb.append(\"; base-type:\").append(_baseType);\n+        sb.append(\"; id-resolver: \").append(_idResolver);\n+    \t    sb.append(']');\n+    \t    return sb.toString();\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n //  @Override\n     public String idFromValueAndType(Object value, Class<?> type)\n     {\n+        /* 18-Jan-2013, tatu: We may be called with null value occasionally\n+         *   it seems; nothing much we can figure out that way.\n+         */\n+        if (value == null) {\n+            return null;\n+        }\n         return idFromValue(value);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n     /**********************************************************\n      */\n \n+    @Override\n+    public final JsonNodeType getNodeType()\n+    {\n+        return JsonNodeType.ARRAY;\n+    }\n+\n     @Override public JsonToken asToken() { return JsonToken.START_ARRAY; }\n-\n-    @Override\n-    public boolean isArray() { return true; }\n \n     @Override\n     public int size()\n--- a/src/main/java/com/fasterxml/jackson/databind/node/BinaryNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BinaryNode.java\n     }\n \n     @Override\n+    public JsonNodeType getNodeType()\n+    {\n+        return JsonNodeType.BINARY;\n+    }\n+\n+    @Override\n     public JsonToken asToken() {\n         /* No distinct type; could use one for textual values,\n          * but given that it's not in text form at this point,\n          */\n         return JsonToken.VALUE_EMBEDDED_OBJECT;\n     }\n-\n-    @Override\n-    public boolean isBinary() { return true; }\n \n     /**\n      *<p>\n--- a/src/main/java/com/fasterxml/jackson/databind/node/BooleanNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BooleanNode.java\n \n     public static BooleanNode valueOf(boolean b) { return b ? TRUE : FALSE; }\n \n+    @Override\n+    public JsonNodeType getNodeType()\n+    {\n+        return JsonNodeType.BOOLEAN;\n+    }\n+\n     // Interesting... two choices...\n     @Override public JsonToken asToken() {\n         return (this == TRUE) ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE;\n     }\n-\n-    @Override\n-    public boolean isBoolean() { return true; }\n \n     @Override\n     public boolean booleanValue() {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ContainerNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ContainerNode.java\n \n     // all containers are mutable: can't define:\n //    @Override public abstract <T extends JsonNode> T deepCopy();\n-    \n-    @Override\n-    public boolean isContainerNode() { return true; }\n \n     @Override\n     public abstract JsonToken asToken();\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeType.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+\n+/**\n+ * Enumeration of all different {@link JsonNode} types\n+ *\n+ * <p>This covers all JSON types defined by <a\n+ * href=\"http://tools.ietf.org/html/rfc4627\">RFC 4627</a> (array, boolean,\n+ * null, number, object and string) but also Jackson-specific types: binary,\n+ * missing and POJO.</p>\n+ *\n+ * @see BinaryNode\n+ * @see MissingNode\n+ * @see POJONode\n+ */\n+public enum JsonNodeType\n+{\n+    ARRAY,\n+    BINARY,\n+    BOOLEAN,\n+    MISSING,\n+    NULL,\n+    NUMBER,\n+    OBJECT,\n+    POJO,\n+    STRING\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/MissingNode.java\n     \n     public static MissingNode getInstance() { return instance; }\n \n+    @Override\n+    public JsonNodeType getNodeType()\n+    {\n+        return JsonNodeType.MISSING;\n+    }\n+\n     @Override public JsonToken asToken() { return JsonToken.NOT_AVAILABLE; }\n-\n-    @Override\n-    public boolean isMissingNode() { return true; }\n \n     @Override\n     public String asText() { return \"\"; }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/NullNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NullNode.java\n \n     public static NullNode getInstance() { return instance; }\n \n+    @Override\n+    public JsonNodeType getNodeType()\n+    {\n+        return JsonNodeType.NULL;\n+    }\n+\n     @Override public JsonToken asToken() { return JsonToken.VALUE_NULL; }\n-\n-    @Override\n-    public boolean isNull() { return true; }\n \n     @Override\n     public String asText() {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/NumericNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/NumericNode.java\n     protected NumericNode() { }\n \n     @Override\n-    public final boolean isNumber() { return true; }\n+    public final JsonNodeType getNodeType()\n+    {\n+        return JsonNodeType.NUMBER;\n+    }\n \n     // // // Let's re-abstract so sub-classes handle them\n \n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n     /**********************************************************\n      */\n \n+    @Override\n+    public final JsonNodeType getNodeType()\n+    {\n+        return JsonNodeType.OBJECT;\n+    }\n+\n     @Override public JsonToken asToken() { return JsonToken.START_OBJECT; }\n-\n-    @Override\n-    public boolean isObject() { return true; }\n \n     @Override\n     public int size() {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\n     /**********************************************************\n      */\n \n+    @Override\n+    public JsonNodeType getNodeType()\n+    {\n+        return JsonNodeType.POJO;\n+    }\n+\n     @Override public JsonToken asToken() { return JsonToken.VALUE_EMBEDDED_OBJECT; }\n-\n-    @Override\n-    public boolean isPojo() { return true; }\n \n     /**\n      * As it is possible that some implementations embed byte[] as POJONode\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TextNode.java\n         return new TextNode(v);\n     }\n \n+    @Override\n+    public JsonNodeType getNodeType()\n+    {\n+        return JsonNodeType.STRING;\n+    }\n+\n     @Override public JsonToken asToken() { return JsonToken.VALUE_STRING; }\n-\n-    /**\n-     * Yes indeed it is textual\n-     */\n-    @Override\n-    public boolean isTextual() { return true; }\n \n     @Override\n     public String textValue() {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n import com.fasterxml.jackson.core.base.ParserMinimalBase;\n \n import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n \n /**\n  * Facade over {@link JsonNode} that implements {@link JsonParser} to allow\n \n     @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n+        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n     \n     /*\n                 // this will convert it to base64\n                 return n.asText();\n             }\n-        }\n-\n-        return (_currToken == null) ? null : _currToken.asString();\n+        default:\n+        \treturn (_currToken == null) ? null : _currToken.asString();\n+        }\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ValueNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ValueNode.java\n     @Override\n     public <T extends JsonNode> T deepCopy() { return (T) this; }\n     \n-    @Override public boolean isValueNode() { return true; }\n-\n     @Override public abstract JsonToken asToken();\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n      * as Java typing returned from <code>getGenericXxx</code> methods\n      * (usually for a return or argument type).\n      */\n-    public JavaType _constructType(Type type, TypeBindings context)\n+    protected JavaType _constructType(Type type, TypeBindings context)\n     {\n         JavaType resultType;\n \n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n package com.fasterxml.jackson.databind.util;\n \n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n+import java.io.*;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n \n import com.fasterxml.jackson.core.json.JsonReadContext;\n import com.fasterxml.jackson.core.json.JsonWriteContext;\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n-\n-import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n \n /**\n  * Utility class used for efficient storage of {@link JsonToken}\n \n     @Override\n     public Version version() {\n-        return DatabindVersion.instance.version();\n+        return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n     }\n \n     /**\n         Parser p = new Parser(_first, src.getCodec());\n         p.setLocation(src.getTokenLocation());\n         return p;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Additional accessors\n+    /**********************************************************\n+     */\n+\n+    public JsonToken firstToken() {\n+        if (_first != null) {\n+            return _first.type(0);\n+        }\n+        return null;\n     }\n     \n     /*\n \n         @Override\n         public Version version() {\n-            return DatabindVersion.instance.version();\n-        }\n-        \n+            return com.fasterxml.jackson.databind.cfg.PackageVersion.VERSION;\n+        }\n+\n         /*\n         /**********************************************************\n         /* Extended API beyond JsonParser\n             case VALUE_NUMBER_FLOAT:\n                 Object ob = _currentObject();\n                 return (ob == null) ? null : ob.toString();\n-            }\n-            return _currToken.asString();\n+            default:\n+            \treturn _currToken.asString();\n+            }\n         }\n \n         @Override\n             if (n instanceof BigInteger) {\n                 return (BigInteger) n;\n             }\n-            switch (getNumberType()) {\n-            case BIG_DECIMAL:\n+            if (getNumberType() == NumberType.BIG_DECIMAL) {\n                 return ((BigDecimal) n).toBigInteger();\n             }\n             // int/long is simple, but let's also just truncate float/double:\n                 return BigDecimal.valueOf(n.longValue());\n             case BIG_INTEGER:\n                 return new BigDecimal((BigInteger) n);\n+            default:\n             }\n             // float or double\n             return BigDecimal.valueOf(n.doubleValue());\n--- a/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n \n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.cfg.PackageVersion;\n \n /**\n  * Tests to ensure that we get proper Version information via\n  */\n public class TestVersions extends com.fasterxml.jackson.test.BaseTest\n {\n-    // Not a good to do this, but has to do, for now...\n-    private final static int MAJOR_VERSION = 2;\n-    private final static int MINOR_VERSION = 2;\n-\n-    private final static String GROUP_ID = \"com.fasterxml.jackson.core\";\n-    private final static String ARTIFACT_ID = \"jackson-databind\";\n-\n     public void testMapperVersions()\n     {\n         ObjectMapper mapper = new ObjectMapper();\n     {\n         Version v = vers.version();\n         assertFalse(\"Should find version information (got \"+v+\")\", v.isUknownVersion());\n-        assertEquals(MAJOR_VERSION, v.getMajorVersion());\n-        assertEquals(MINOR_VERSION, v.getMinorVersion());\n-        // Check patch level initially, comment out for maint versions\n-//        assertEquals(0, v.getPatchLevel());\n-        assertEquals(GROUP_ID, v.getGroupId());\n-        assertEquals(ARTIFACT_ID, v.getArtifactId());\n+        Version exp = PackageVersion.VERSION;\n+        assertEquals(exp.toFullString(), v.toFullString());\n+        assertEquals(exp, v);\n     }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n     }\n \n     // For [Issue#96]: should allow use of default impl, if property missing\n+    /* 18-Jan-2013, tatu: Unfortunately this collides with [Issue#118], and I don't\n+     *   know what the best resolution is. For now at least \n+     */\n+    /*\n     public void testWithDefaultAndMissing() throws Exception\n     {\n         ExternalBeanWithDefault input = new ExternalBeanWithDefault(13);\n         assertNotNull(defaulted.bean);\n         assertSame(ValueBean.class, defaulted.bean.getClass());\n     }\n+    */\n \n     // For [Issue#118]\n     // Note: String works fine, since no type id will used; other scalar types have issues\n         assertTrue(result.value instanceof java.util.Date);\n     }\n \n+    // For [Issue#118] using \"natural\" type(s)\n+    public void testWithNaturalScalar118() throws Exception\n+    {\n+        ExternalTypeWithNonPOJO input = new ExternalTypeWithNonPOJO(Integer.valueOf(13));\n+        String json = MAPPER.writeValueAsString(input);\n+        assertNotNull(json);\n+        // and back just to be sure:\n+        ExternalTypeWithNonPOJO result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);\n+        assertNotNull(result.value);\n+        assertTrue(result.value instanceof Integer);\n+\n+        // ditto with others types\n+        input = new ExternalTypeWithNonPOJO(Boolean.TRUE);\n+        json = MAPPER.writeValueAsString(input);\n+        assertNotNull(json);\n+        result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);\n+        assertNotNull(result.value);\n+        assertTrue(result.value instanceof Boolean);\n+\n+        input = new ExternalTypeWithNonPOJO(\"foobar\");\n+        json = MAPPER.writeValueAsString(input);\n+        assertNotNull(json);\n+        result = MAPPER.readValue(json, ExternalTypeWithNonPOJO.class);\n+        assertNotNull(result.value);\n+        assertTrue(result.value instanceof String);\n+        assertEquals(\"foobar\", result.value);\n+    }\n+    \n     // For [Issue#119]\n     public void testWithAsValue() throws Exception\n     {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestExternalTypeId.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestExternalTypeId extends BaseMapTest\n+{\n+    public void testTypes() throws IOException {\n+    final ObjectMapper mapper = new ObjectMapper();\n+    mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n+\n+    final Point _date = new Point(new Date());\n+    final Point _integer = new Point(12231321);\n+    final Point _boolean = new Point(Boolean.TRUE);\n+    final Point _long = new Point(1234L);\n+\n+    final Point _pojo = new Point(new Pojo(1));\n+    final String s_date = mapper.writeValueAsString(_date);\n+    final String s_integer = mapper.writeValueAsString(_integer);\n+\n+System.err.println(\"Int -> \"+s_integer);   \n+    \n+    final String s_boolean = mapper.writeValueAsString(_boolean);\n+    final String s_long = mapper.writeValueAsString(_long);\n+    final String s_pojo = mapper.writeValueAsString(_pojo);\n+\n+    final Point d_date = mapper.readValue(s_date, Point.class);\n+    final Point d_long = mapper.readValue(s_long, Point.class);\n+    final Point d_pojo = mapper.readValue(s_pojo, Point.class);\n+    final Point d_integer = mapper.readValue(s_integer, Point.class);\n+    final Point d_boolean = mapper.readValue(s_boolean, Point.class);\n+    }\n+\n+    @JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY,\n+        getterVisibility = JsonAutoDetect.Visibility.NONE,\n+        setterVisibility = JsonAutoDetect.Visibility.NONE)\n+    private static class Point {\n+        @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+        property = \"t\",\n+        visible = true,\n+        include = JsonTypeInfo.As.EXTERNAL_PROPERTY,\n+        defaultImpl = String.class)\n+        @JsonSubTypes({\n+        @JsonSubTypes.Type(value = Date.class, name = \"date\"),\n+        @JsonSubTypes.Type(value = Integer.class, name = \"int\"),\n+        @JsonSubTypes.Type(value = Long.class, name = \"long\"),\n+        @JsonSubTypes.Type(value = Boolean.class, name = \"bool\"),\n+        @JsonSubTypes.Type(value = Pojo.class, name = \"pojo\"),\n+        @JsonSubTypes.Type(value = String.class, name = \"\")\n+        })\n+        private final Object v;\n+    \n+        @JsonCreator\n+        @SuppressWarnings(\"unused\")\n+        public Point(@JsonProperty(\"v\") Object v) {\n+            this.v = v;\n+        }\n+    \n+        public Object getValue() {\n+            return v;\n+        }\n+    }\n+     \n+\n+    private static class Pojo {\n+        public final int p;\n+\n+        @JsonCreator\n+        private Pojo(@JsonProperty(\"p\") int p) {\n+            this.p = p;\n+        }\n+    }\n+}", "timestamp": 1358828487, "metainfo": ""}