{"sha": "18a3b71a809fa5c2015f93d695c5333a3e5abb47", "log": "Refactoring: create AnnotationIntrospectorPair out of AnnotationIntrospector.Pair", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n \n import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.JsonInclude;\n+\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.core.Versioned;\n+\n import com.fasterxml.jackson.databind.JsonDeserializer;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n import com.fasterxml.jackson.databind.introspect.*;\n      */\n \n     /**\n-     * Helper class that allows using 2 introspectors such that one\n-     * introspector acts as the primary one to use; and second one\n-     * as a fallback used if the primary does not provide conclusive\n-     * or useful result for a method.\n-     *<p>\n-     * An obvious consequence of priority is that it is easy to construct\n-     * longer chains of introspectors by linking multiple pairs.\n-     * Currently most likely combination is that of using the default\n-     * Jackson provider, along with JAXB annotation introspector.\n-     */\n+     * Old version of {@link AnnotationIntrospectorPair}.\n+     * \n+     * @deprecated Starting with 2.1, use\n+     * {@link AnnotationIntrospectorPair}\n+     * instead.\n+     */\n+    @Deprecated\n     public static class Pair\n-        extends AnnotationIntrospector\n+        extends AnnotationIntrospectorPair\n     {\n-        protected final AnnotationIntrospector _primary, _secondary;\n-\n-        public Pair(AnnotationIntrospector p, AnnotationIntrospector s)\n-        {\n-            _primary = p;\n-            _secondary = s;\n+        public Pair(AnnotationIntrospector p, AnnotationIntrospector s) {\n+            super(p, s);\n         }\n-\n-        @Override\n-        public Version version() {\n-            return _primary.version();\n-        }\n-        \n-        /**\n-         * Helper method for constructing a Pair from two given introspectors (if\n-         * neither is null); or returning non-null introspector if one is null\n-         * (and return just null if both are null)\n-         */\n-        public static AnnotationIntrospector create(AnnotationIntrospector primary,\n-                AnnotationIntrospector secondary)\n-        {\n-            if (primary == null) {\n-                return secondary;\n-            }\n-            if (secondary == null) {\n-                return primary;\n-            }\n-            return new Pair(primary, secondary);\n-        }\n-\n-        @Override\n-        public Collection<AnnotationIntrospector> allIntrospectors() {\n-            return allIntrospectors(new ArrayList<AnnotationIntrospector>());\n-        }\n-\n-        @Override\n-        public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result)\n-        {\n-            _primary.allIntrospectors(result);\n-            _secondary.allIntrospectors(result);\n-            return result;\n-        }\n-        \n-        // // // Generic annotation properties, lookup\n-        \n-        @Deprecated\n-        @Override\n-        public boolean isHandled(Annotation ann) {\n-            return _primary.isHandled(ann) || _secondary.isHandled(ann);\n-        }\n-\n-        @Override\n-        public boolean isAnnotationBundle(Annotation ann) {\n-            return _primary.isAnnotationBundle(ann) || _secondary.isAnnotationBundle(ann);\n-        }\n-        \n-        /*\n-        /******************************************************\n-        /* General class annotations\n-        /******************************************************\n-         */\n-\n-        @Override\n-        public String findRootName(AnnotatedClass ac)\n-        {\n-            String name1 = _primary.findRootName(ac);\n-            if (name1 == null) {\n-                return _secondary.findRootName(ac);\n-            } else if (name1.length() > 0) {\n-                return name1;\n-            }\n-            // name1 is empty; how about secondary?\n-            String name2 = _secondary.findRootName(ac);\n-            return (name2 == null) ? name1 : name2;\n-        }\n-\n-        @Override\n-        public String[] findPropertiesToIgnore(Annotated ac)\n-        {\n-            String[] result = _primary.findPropertiesToIgnore(ac);\n-            if (result == null) {\n-                result = _secondary.findPropertiesToIgnore(ac);\n-            }\n-            return result;            \n-        }\n-\n-        @Override\n-        public Boolean findIgnoreUnknownProperties(AnnotatedClass ac)\n-        {\n-            Boolean result = _primary.findIgnoreUnknownProperties(ac);\n-            if (result == null) {\n-                result = _secondary.findIgnoreUnknownProperties(ac);\n-            }\n-            return result;\n-        }        \n-\n-        @Override\n-        public Boolean isIgnorableType(AnnotatedClass ac)\n-        {\n-            Boolean result = _primary.isIgnorableType(ac);\n-            if (result == null) {\n-                result = _secondary.isIgnorableType(ac);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Object findFilterId(AnnotatedClass ac)\n-        {\n-            Object id = _primary.findFilterId(ac);\n-            if (id == null) {\n-                id = _secondary.findFilterId(ac);\n-            }\n-            return id;\n-        }\n-\n-        @Override\n-        public Object findNamingStrategy(AnnotatedClass ac)\n-        {\n-            Object str = _primary.findNamingStrategy(ac);\n-            if (str == null) {\n-                str = _secondary.findNamingStrategy(ac);\n-            }\n-            return str;\n-        }\n-\n-        /*\n-        /******************************************************\n-        /* Property auto-detection\n-        /******************************************************\n-        */\n-        \n-        @Override\n-        public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n-            VisibilityChecker<?> checker)\n-        {\n-            /* Note: to have proper priorities, we must actually call delegatees\n-             * in reverse order:\n-             */\n-            checker = _secondary.findAutoDetectVisibility(ac, checker);\n-            return _primary.findAutoDetectVisibility(ac, checker);\n-        }\n-\n-        /*\n-        /******************************************************\n-        /* Type handling\n-        /******************************************************\n-        */\n-        \n-        @Override\n-        public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n-                AnnotatedClass ac, JavaType baseType)\n-        {\n-            TypeResolverBuilder<?> b = _primary.findTypeResolver(config, ac, baseType);\n-            if (b == null) {\n-                b = _secondary.findTypeResolver(config, ac, baseType);\n-            }\n-            return b;\n-        }\n-\n-        @Override\n-        public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n-                AnnotatedMember am, JavaType baseType)\n-        {\n-            TypeResolverBuilder<?> b = _primary.findPropertyTypeResolver(config, am, baseType);\n-            if (b == null) {\n-                b = _secondary.findPropertyTypeResolver(config, am, baseType);\n-            }\n-            return b;\n-        }\n-\n-        @Override\n-        public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n-                AnnotatedMember am, JavaType baseType)\n-        {\n-            TypeResolverBuilder<?> b = _primary.findPropertyContentTypeResolver(config, am, baseType);\n-            if (b == null) {\n-                b = _secondary.findPropertyContentTypeResolver(config, am, baseType);\n-            }\n-            return b;\n-        }\n-        \n-        @Override\n-        public List<NamedType> findSubtypes(Annotated a)\n-        {\n-            List<NamedType> types1 = _primary.findSubtypes(a);\n-            List<NamedType> types2 = _secondary.findSubtypes(a);\n-            if (types1 == null || types1.isEmpty()) return types2;\n-            if (types2 == null || types2.isEmpty()) return types1;\n-            ArrayList<NamedType> result = new ArrayList<NamedType>(types1.size() + types2.size());\n-            result.addAll(types1);\n-            result.addAll(types2);\n-            return result;\n-        }\n-\n-        @Override\n-        public String findTypeName(AnnotatedClass ac)\n-        {\n-            String name = _primary.findTypeName(ac);\n-            if (name == null || name.length() == 0) {\n-                name = _secondary.findTypeName(ac);                \n-            }\n-            return name;\n-        }\n-        \n-        // // // General member (field, method/constructor) annotations\n-        \n-        @Override        \n-        public ReferenceProperty findReferenceType(AnnotatedMember member)\n-        {\n-            ReferenceProperty ref = _primary.findReferenceType(member);\n-            if (ref == null) {\n-                ref = _secondary.findReferenceType(member);\n-            }\n-            return ref; \n-        }\n-\n-        @Override        \n-        public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)\n-        {\n-            NameTransformer value = _primary.findUnwrappingNameTransformer(member);\n-            if (value == null) {\n-                value = _secondary.findUnwrappingNameTransformer(member);\n-            }\n-            return value;\n-        }\n-\n-        @Override\n-        public Object findInjectableValueId(AnnotatedMember m)\n-        {\n-            Object value = _primary.findInjectableValueId(m);\n-            if (value == null) {\n-                value = _secondary.findInjectableValueId(m);\n-            }\n-            return value;\n-        }\n-\n-        @Override\n-        public boolean hasIgnoreMarker(AnnotatedMember m) {\n-            return _primary.hasIgnoreMarker(m) || _secondary.hasIgnoreMarker(m);\n-        }\n-        \n-        @Override\n-        public Boolean hasRequiredMarker(AnnotatedMember m)\n-        {\n-            Boolean value = _primary.hasRequiredMarker(m);\n-            if (value == null) {\n-                value = _secondary.hasRequiredMarker(m);\n-            }\n-            return value;\n-        }\n-        \n-        // // // Serialization: general annotations\n-\n-        @Override\n-        public Object findSerializer(Annotated am)\n-        {\n-            Object result = _primary.findSerializer(am);\n-            if (result == null) {\n-                result = _secondary.findSerializer(am);\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public Object findKeySerializer(Annotated a)\n-        {\n-            Object result = _primary.findKeySerializer(a);\n-            if (result == null || result == JsonSerializer.None.class || result == NoClass.class) {\n-                result = _secondary.findKeySerializer(a);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Object findContentSerializer(Annotated a)\n-        {\n-            Object result = _primary.findContentSerializer(a);\n-            if (result == null || result == JsonSerializer.None.class || result == NoClass.class) {\n-                result = _secondary.findContentSerializer(a);\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public JsonInclude.Include findSerializationInclusion(Annotated a,\n-                JsonInclude.Include defValue)\n-        {\n-            /* This is bit trickier: need to combine results in a meaningful\n-             * way. Seems like it should be a disjoint; that is, most\n-             * restrictive value should be returned.\n-             * For enumerations, comparison is done by indexes, which\n-             * works: largest value is the last one, which is the most\n-             * restrictive value as well.\n-             */\n-            /* 09-Mar-2010, tatu: Actually, as per [JACKSON-256], it is probably better to just\n-             *    use strict overriding. Simpler, easier to understand.\n-             */\n-            // note: call secondary first, to give lower priority\n-            defValue = _secondary.findSerializationInclusion(a, defValue);\n-            defValue = _primary.findSerializationInclusion(a, defValue);\n-            return defValue;\n-        }\n-        \n-        @Override\n-        public Class<?> findSerializationType(Annotated a)\n-        {\n-            Class<?> result = _primary.findSerializationType(a);\n-            if (result == null) {\n-                result = _secondary.findSerializationType(a);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n-        {\n-            Class<?> result = _primary.findSerializationKeyType(am, baseType);\n-            if (result == null) {\n-                result = _secondary.findSerializationKeyType(am, baseType);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n-        {\n-            Class<?> result = _primary.findSerializationContentType(am, baseType);\n-            if (result == null) {\n-                result = _secondary.findSerializationContentType(am, baseType);\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public JsonSerialize.Typing findSerializationTyping(Annotated a)\n-        {\n-            JsonSerialize.Typing result = _primary.findSerializationTyping(a);\n-            if (result == null) {\n-                result = _secondary.findSerializationTyping(a);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Class<?>[] findViews(Annotated a)\n-        {\n-            /* Theoretically this could be trickier, if multiple introspectors\n-             * return non-null entries. For now, though, we'll just consider\n-             * first one to return non-null to win.\n-             */\n-            Class<?>[] result = _primary.findViews(a);\n-            if (result == null) {\n-                result = _secondary.findViews(a);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Boolean isTypeId(AnnotatedMember member) {\n-            Boolean b = _primary.isTypeId(member);\n-            if (b == null) {\n-                b = _secondary.isTypeId(member);\n-            }\n-            return b;\n-        }\n-\n-        @Override\n-        public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n-            ObjectIdInfo result = _primary.findObjectIdInfo(ann);\n-            if (result == null) {\n-                result = _secondary.findObjectIdInfo(ann);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n-            // to give precedence for primary, must start with secondary:\n-            objectIdInfo = _secondary.findObjectReferenceInfo(ann, objectIdInfo);\n-            objectIdInfo = _primary.findObjectReferenceInfo(ann, objectIdInfo);\n-            return objectIdInfo;\n-        }\n-        \n-        @Override\n-        public JsonFormat.Value findFormat(Annotated ann) {\n-            JsonFormat.Value result = _primary.findFormat(ann);\n-            if (result == null) {\n-                result = _secondary.findFormat(ann);\n-            }\n-            return result;\n-        }\n-        \n-        // // // Serialization: class annotations\n-\n-        @Override\n-        public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n-            String[] result = _primary.findSerializationPropertyOrder(ac);\n-            if (result == null) {\n-                result = _secondary.findSerializationPropertyOrder(ac);\n-            }\n-            return result;            \n-        }\n-\n-        /**\n-         * Method for checking whether an annotation indicates that serialized properties\n-         * for which no explicit is defined should be alphabetically (lexicograpically)\n-         * ordered\n-         */\n-        @Override\n-        public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n-            Boolean result = _primary.findSerializationSortAlphabetically(ac);\n-            if (result == null) {\n-                result = _secondary.findSerializationSortAlphabetically(ac);\n-            }\n-            return result;            \n-        }\n-\n-        // // // Serialization: property annotations\n-        \n-        @Override\n-        public PropertyName findNameForSerialization(Annotated a) {\n-            PropertyName n = _primary.findNameForSerialization(a);\n-            // note: \"use default\" should not block explicit answer, so:\n-            if (n == null) {\n-                n = _secondary.findNameForSerialization(a);\n-            } else if (n == PropertyName.USE_DEFAULT) {\n-                PropertyName n2 = _secondary.findNameForSerialization(a);\n-                if (n2 != null) {\n-                    n = n2;\n-                }\n-            }\n-            return n;\n-        }\n-        \n-        @Override\n-        public String findSerializationName(AnnotatedMethod am)\n-        {\n-            String result = _primary.findSerializationName(am);\n-            if (result == null) {\n-                result = _secondary.findSerializationName(am);\n-            } else if (result.length() == 0) {\n-                /* Empty String is a default; can be overridden by\n-                 * more explicit answer from secondary entry\n-                 */\n-                String str2 = _secondary.findSerializationName(am);\n-                if (str2 != null) {\n-                    result = str2;\n-                }\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public String findSerializationName(AnnotatedField af)\n-        {\n-            String result = _primary.findSerializationName(af);\n-            if (result == null) {\n-                result = _secondary.findSerializationName(af);\n-            } else if (result.length() == 0) {\n-                /* Empty String is a default; can be overridden by\n-                 * more explicit answer from secondary entry\n-                 */\n-                String str2 = _secondary.findSerializationName(af);\n-                if (str2 != null) {\n-                    result = str2;\n-                }\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public boolean hasAsValueAnnotation(AnnotatedMethod am)\n-        {\n-            return _primary.hasAsValueAnnotation(am) || _secondary.hasAsValueAnnotation(am);\n-        }\n-        \n-        @Override\n-        public String findEnumValue(Enum<?> value)\n-        {\n-            String result = _primary.findEnumValue(value);\n-            if (result == null) {\n-                result = _secondary.findEnumValue(value);\n-            }\n-            return result;\n-        }        \n-\n-        // // // Deserialization: general annotations\n-\n-        @Override\n-        public Object findDeserializer(Annotated am)\n-        {\n-            Object result = _primary.findDeserializer(am);\n-            if (result == null) {\n-                result = _secondary.findDeserializer(am);\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public Object findKeyDeserializer(Annotated am)\n-        {\n-            Object result = _primary.findKeyDeserializer(am);\n-            if (result == null || result == KeyDeserializer.None.class || result == NoClass.class) {\n-                result = _secondary.findKeyDeserializer(am);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Object findContentDeserializer(Annotated am)\n-        {\n-            Object result = _primary.findContentDeserializer(am);\n-            if (result == null || result == JsonDeserializer.None.class || result == NoClass.class) {\n-                result = _secondary.findContentDeserializer(am);\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public Class<?> findDeserializationType(Annotated am, JavaType baseType)\n-        {\n-            Class<?> result = _primary.findDeserializationType(am, baseType);\n-            if (result == null) {\n-                result = _secondary.findDeserializationType(am, baseType);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType)\n-        {\n-            Class<?> result = _primary.findDeserializationKeyType(am, baseKeyType);\n-            if (result == null) {\n-                result = _secondary.findDeserializationKeyType(am, baseKeyType);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)\n-        {\n-            Class<?> result = _primary.findDeserializationContentType(am, baseContentType);\n-            if (result == null) {\n-                result = _secondary.findDeserializationContentType(am, baseContentType);\n-            }\n-            return result;\n-        }\n-\n-        // // // Deserialization: class annotations\n-\n-        @Override\n-        public Object findValueInstantiator(AnnotatedClass ac)\n-        {\n-            Object result = _primary.findValueInstantiator(ac);\n-            if (result == null) {\n-                result = _secondary.findValueInstantiator(ac);\n-            }\n-            return result;\n-        }\n-\n-        @Override\n-        public Class<?> findPOJOBuilder(AnnotatedClass ac)\n-        {\n-        \tClass<?> result = _primary.findPOJOBuilder(ac);\n-        \tif (result == null) {\n-        \t\tresult = _secondary.findPOJOBuilder(ac);\n-        \t}\n-        \treturn result;\n-        }\n-\n-        @Override\n-        public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)\n-        {\n-            JsonPOJOBuilder.Value result = _primary.findPOJOBuilderConfig(ac);\n-            if (result == null) {\n-                result = _secondary.findPOJOBuilderConfig(ac);\n-            }\n-            return result;\n-        }\n-        \n-        // // // Deserialization: method annotations\n-\n-        @Override\n-        public PropertyName findNameForDeserialization(Annotated a)\n-        {\n-            // note: \"use default\" should not block explicit answer, so:\n-            PropertyName n = _primary.findNameForDeserialization(a);\n-            if (n != null) {\n-                n = _secondary.findNameForDeserialization(a);\n-            } else if (n == PropertyName.USE_DEFAULT) {\n-                PropertyName n2 = _secondary.findNameForDeserialization(a);\n-                if (n2 != null) {\n-                    n = n2;\n-                }\n-            }\n-            return n;\n-        }\n-        \n-        @Override\n-        public String findDeserializationName(AnnotatedMethod am)\n-        {\n-            String result = _primary.findDeserializationName(am);\n-            if (result == null) {\n-                result = _secondary.findDeserializationName(am);\n-            } else if (result.length() == 0) {\n-                /* Empty String is a default; can be overridden by\n-                 * more explicit answer from secondary entry\n-                 */\n-                String str2 = _secondary.findDeserializationName(am);\n-                if (str2 != null) {\n-                    result = str2;\n-                }\n-            }\n-            return result;\n-        }\n-        \n-        @Override\n-        public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n-        {\n-            return _primary.hasAnySetterAnnotation(am) || _secondary.hasAnySetterAnnotation(am);\n-        }\n-\n-        @Override\n-        public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n-        {\n-            return _primary.hasAnyGetterAnnotation(am) || _secondary.hasAnyGetterAnnotation(am);\n-        }\n-        \n-        @Override\n-        public boolean hasCreatorAnnotation(Annotated a)\n-        {\n-            return _primary.hasCreatorAnnotation(a) || _secondary.hasCreatorAnnotation(a);\n-        }\n-        \n-        // // // Deserialization: field annotations\n-\n-        @Override\n-        public String findDeserializationName(AnnotatedField af)\n-        {\n-            String result = _primary.findDeserializationName(af);\n-            if (result == null) {\n-                result = _secondary.findDeserializationName(af);\n-            } else if (result.length() == 0) {\n-                /* Empty String is a default; can be overridden by\n-                 * more explicit answer from secondary entry\n-                 */\n-                String str2 = _secondary.findDeserializationName(af);\n-                if (str2 != null) {\n-                    result = str2;\n-                }\n-            }\n-            return result;\n-        }\n-\n-        // // // Deserialization: parameter annotations (for creators)\n-\n-        @Override\n-        public String findDeserializationName(AnnotatedParameter param)\n-        {\n-            String result = _primary.findDeserializationName(param);\n-            if (result == null) {\n-                result = _secondary.findDeserializationName(param);\n-            }\n-            return result;\n-        }\n-    }\n-\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n import com.fasterxml.jackson.annotation.PropertyAccessor;\n import com.fasterxml.jackson.core.Base64Variant;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotationIntrospectorPair;\n import com.fasterxml.jackson.databind.introspect.ClassIntrospector;\n import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n     }\n \n     public BaseSettings withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n-        return withAnnotationIntrospector(AnnotationIntrospector.Pair.create(ai, _annotationIntrospector));\n+        return withAnnotationIntrospector(AnnotationIntrospectorPair.create(ai, _annotationIntrospector));\n     }\n \n     public BaseSettings withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n-        return withAnnotationIntrospector(AnnotationIntrospector.Pair.create(_annotationIntrospector, ai));\n+        return withAnnotationIntrospector(AnnotationIntrospectorPair.create(_annotationIntrospector, ai));\n     }\n     \n     public BaseSettings withVisibilityChecker(VisibilityChecker<?> vc) {\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationIntrospectorPair.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n+\n+/**\n+ * Helper class that allows using 2 introspectors such that one\n+ * introspector acts as the primary one to use; and second one\n+ * as a fallback used if the primary does not provide conclusive\n+ * or useful result for a method.\n+ *<p>\n+ * An obvious consequence of priority is that it is easy to construct\n+ * longer chains of introspectors by linking multiple pairs.\n+ * Currently most likely combination is that of using the default\n+ * Jackson provider, along with JAXB annotation introspector.\n+ *<p>\n+ * Note: up until 2.0, this class was an inner class of\n+ * {@link AnnotationIntrospector}; moved here for convenience.\n+ * \n+ * @since 2.1\n+ */\n+public class AnnotationIntrospectorPair extends AnnotationIntrospector\n+{\n+    protected final AnnotationIntrospector _primary, _secondary;\n+\n+    public AnnotationIntrospectorPair(AnnotationIntrospector p, AnnotationIntrospector s)\n+    {\n+        _primary = p;\n+        _secondary = s;\n+    }\n+\n+    @Override\n+    public Version version() {\n+        return _primary.version();\n+    }\n+\n+    /**\n+     * Helper method for constructing a Pair from two given introspectors (if\n+     * neither is null); or returning non-null introspector if one is null\n+     * (and return just null if both are null)\n+     */\n+    public static AnnotationIntrospector create(AnnotationIntrospector primary,\n+            AnnotationIntrospector secondary)\n+    {\n+        if (primary == null) {\n+            return secondary;\n+        }\n+        if (secondary == null) {\n+            return primary;\n+        }\n+        return new AnnotationIntrospectorPair(primary, secondary);\n+    }\n+\n+    @Override\n+    public Collection<AnnotationIntrospector> allIntrospectors() {\n+        return allIntrospectors(new ArrayList<AnnotationIntrospector>());\n+    }\n+\n+    @Override\n+    public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result)\n+    {\n+        _primary.allIntrospectors(result);\n+        _secondary.allIntrospectors(result);\n+        return result;\n+    }\n+    \n+    // // // Generic annotation properties, lookup\n+    \n+    @Override\n+    public boolean isAnnotationBundle(Annotation ann) {\n+        return _primary.isAnnotationBundle(ann) || _secondary.isAnnotationBundle(ann);\n+    }\n+    \n+    /*\n+    /******************************************************\n+    /* General class annotations\n+    /******************************************************\n+     */\n+\n+    @Override\n+    public String findRootName(AnnotatedClass ac)\n+    {\n+        String name1 = _primary.findRootName(ac);\n+        if (name1 == null) {\n+            return _secondary.findRootName(ac);\n+        } else if (name1.length() > 0) {\n+            return name1;\n+        }\n+        // name1 is empty; how about secondary?\n+        String name2 = _secondary.findRootName(ac);\n+        return (name2 == null) ? name1 : name2;\n+    }\n+\n+    @Override\n+    public String[] findPropertiesToIgnore(Annotated ac)\n+    {\n+        String[] result = _primary.findPropertiesToIgnore(ac);\n+        if (result == null) {\n+            result = _secondary.findPropertiesToIgnore(ac);\n+        }\n+        return result;            \n+    }\n+\n+    @Override\n+    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac)\n+    {\n+        Boolean result = _primary.findIgnoreUnknownProperties(ac);\n+        if (result == null) {\n+            result = _secondary.findIgnoreUnknownProperties(ac);\n+        }\n+        return result;\n+    }        \n+\n+    @Override\n+    public Boolean isIgnorableType(AnnotatedClass ac)\n+    {\n+        Boolean result = _primary.isIgnorableType(ac);\n+        if (result == null) {\n+            result = _secondary.isIgnorableType(ac);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Object findFilterId(AnnotatedClass ac)\n+    {\n+        Object id = _primary.findFilterId(ac);\n+        if (id == null) {\n+            id = _secondary.findFilterId(ac);\n+        }\n+        return id;\n+    }\n+\n+    @Override\n+    public Object findNamingStrategy(AnnotatedClass ac)\n+    {\n+        Object str = _primary.findNamingStrategy(ac);\n+        if (str == null) {\n+            str = _secondary.findNamingStrategy(ac);\n+        }\n+        return str;\n+    }\n+\n+    /*\n+    /******************************************************\n+    /* Property auto-detection\n+    /******************************************************\n+    */\n+    \n+    @Override\n+    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n+        VisibilityChecker<?> checker)\n+    {\n+        /* Note: to have proper priorities, we must actually call delegatees\n+         * in reverse order:\n+         */\n+        checker = _secondary.findAutoDetectVisibility(ac, checker);\n+        return _primary.findAutoDetectVisibility(ac, checker);\n+    }\n+\n+    /*\n+    /******************************************************\n+    /* Type handling\n+    /******************************************************\n+    */\n+    \n+    @Override\n+    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n+            AnnotatedClass ac, JavaType baseType)\n+    {\n+        TypeResolverBuilder<?> b = _primary.findTypeResolver(config, ac, baseType);\n+        if (b == null) {\n+            b = _secondary.findTypeResolver(config, ac, baseType);\n+        }\n+        return b;\n+    }\n+\n+    @Override\n+    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n+            AnnotatedMember am, JavaType baseType)\n+    {\n+        TypeResolverBuilder<?> b = _primary.findPropertyTypeResolver(config, am, baseType);\n+        if (b == null) {\n+            b = _secondary.findPropertyTypeResolver(config, am, baseType);\n+        }\n+        return b;\n+    }\n+\n+    @Override\n+    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n+            AnnotatedMember am, JavaType baseType)\n+    {\n+        TypeResolverBuilder<?> b = _primary.findPropertyContentTypeResolver(config, am, baseType);\n+        if (b == null) {\n+            b = _secondary.findPropertyContentTypeResolver(config, am, baseType);\n+        }\n+        return b;\n+    }\n+    \n+    @Override\n+    public List<NamedType> findSubtypes(Annotated a)\n+    {\n+        List<NamedType> types1 = _primary.findSubtypes(a);\n+        List<NamedType> types2 = _secondary.findSubtypes(a);\n+        if (types1 == null || types1.isEmpty()) return types2;\n+        if (types2 == null || types2.isEmpty()) return types1;\n+        ArrayList<NamedType> result = new ArrayList<NamedType>(types1.size() + types2.size());\n+        result.addAll(types1);\n+        result.addAll(types2);\n+        return result;\n+    }\n+\n+    @Override\n+    public String findTypeName(AnnotatedClass ac)\n+    {\n+        String name = _primary.findTypeName(ac);\n+        if (name == null || name.length() == 0) {\n+            name = _secondary.findTypeName(ac);                \n+        }\n+        return name;\n+    }\n+    \n+    // // // General member (field, method/constructor) annotations\n+    \n+    @Override        \n+    public ReferenceProperty findReferenceType(AnnotatedMember member)\n+    {\n+        ReferenceProperty ref = _primary.findReferenceType(member);\n+        if (ref == null) {\n+            ref = _secondary.findReferenceType(member);\n+        }\n+        return ref; \n+    }\n+\n+    @Override        \n+    public NameTransformer findUnwrappingNameTransformer(AnnotatedMember member)\n+    {\n+        NameTransformer value = _primary.findUnwrappingNameTransformer(member);\n+        if (value == null) {\n+            value = _secondary.findUnwrappingNameTransformer(member);\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public Object findInjectableValueId(AnnotatedMember m)\n+    {\n+        Object value = _primary.findInjectableValueId(m);\n+        if (value == null) {\n+            value = _secondary.findInjectableValueId(m);\n+        }\n+        return value;\n+    }\n+\n+    @Override\n+    public boolean hasIgnoreMarker(AnnotatedMember m) {\n+        return _primary.hasIgnoreMarker(m) || _secondary.hasIgnoreMarker(m);\n+    }\n+    \n+    @Override\n+    public Boolean hasRequiredMarker(AnnotatedMember m)\n+    {\n+        Boolean value = _primary.hasRequiredMarker(m);\n+        if (value == null) {\n+            value = _secondary.hasRequiredMarker(m);\n+        }\n+        return value;\n+    }\n+    \n+    // // // Serialization: general annotations\n+\n+    @Override\n+    public Object findSerializer(Annotated am)\n+    {\n+        Object result = _primary.findSerializer(am);\n+        if (result == null) {\n+            result = _secondary.findSerializer(am);\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public Object findKeySerializer(Annotated a)\n+    {\n+        Object result = _primary.findKeySerializer(a);\n+        if (result == null || result == JsonSerializer.None.class || result == NoClass.class) {\n+            result = _secondary.findKeySerializer(a);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Object findContentSerializer(Annotated a)\n+    {\n+        Object result = _primary.findContentSerializer(a);\n+        if (result == null || result == JsonSerializer.None.class || result == NoClass.class) {\n+            result = _secondary.findContentSerializer(a);\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public JsonInclude.Include findSerializationInclusion(Annotated a,\n+            JsonInclude.Include defValue)\n+    {\n+        /* This is bit trickier: need to combine results in a meaningful\n+         * way. Seems like it should be a disjoint; that is, most\n+         * restrictive value should be returned.\n+         * For enumerations, comparison is done by indexes, which\n+         * works: largest value is the last one, which is the most\n+         * restrictive value as well.\n+         */\n+        /* 09-Mar-2010, tatu: Actually, as per [JACKSON-256], it is probably better to just\n+         *    use strict overriding. Simpler, easier to understand.\n+         */\n+        // note: call secondary first, to give lower priority\n+        defValue = _secondary.findSerializationInclusion(a, defValue);\n+        defValue = _primary.findSerializationInclusion(a, defValue);\n+        return defValue;\n+    }\n+    \n+    @Override\n+    public Class<?> findSerializationType(Annotated a)\n+    {\n+        Class<?> result = _primary.findSerializationType(a);\n+        if (result == null) {\n+            result = _secondary.findSerializationType(a);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n+    {\n+        Class<?> result = _primary.findSerializationKeyType(am, baseType);\n+        if (result == null) {\n+            result = _secondary.findSerializationKeyType(am, baseType);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n+    {\n+        Class<?> result = _primary.findSerializationContentType(am, baseType);\n+        if (result == null) {\n+            result = _secondary.findSerializationContentType(am, baseType);\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public JsonSerialize.Typing findSerializationTyping(Annotated a)\n+    {\n+        JsonSerialize.Typing result = _primary.findSerializationTyping(a);\n+        if (result == null) {\n+            result = _secondary.findSerializationTyping(a);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Class<?>[] findViews(Annotated a)\n+    {\n+        /* Theoretically this could be trickier, if multiple introspectors\n+         * return non-null entries. For now, though, we'll just consider\n+         * first one to return non-null to win.\n+         */\n+        Class<?>[] result = _primary.findViews(a);\n+        if (result == null) {\n+            result = _secondary.findViews(a);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Boolean isTypeId(AnnotatedMember member) {\n+        Boolean b = _primary.isTypeId(member);\n+        if (b == null) {\n+            b = _secondary.isTypeId(member);\n+        }\n+        return b;\n+    }\n+\n+    @Override\n+    public ObjectIdInfo findObjectIdInfo(Annotated ann) {\n+        ObjectIdInfo result = _primary.findObjectIdInfo(ann);\n+        if (result == null) {\n+            result = _secondary.findObjectIdInfo(ann);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public ObjectIdInfo findObjectReferenceInfo(Annotated ann, ObjectIdInfo objectIdInfo) {\n+        // to give precedence for primary, must start with secondary:\n+        objectIdInfo = _secondary.findObjectReferenceInfo(ann, objectIdInfo);\n+        objectIdInfo = _primary.findObjectReferenceInfo(ann, objectIdInfo);\n+        return objectIdInfo;\n+    }\n+    \n+    @Override\n+    public JsonFormat.Value findFormat(Annotated ann) {\n+        JsonFormat.Value result = _primary.findFormat(ann);\n+        if (result == null) {\n+            result = _secondary.findFormat(ann);\n+        }\n+        return result;\n+    }\n+    \n+    // // // Serialization: class annotations\n+\n+    @Override\n+    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n+        String[] result = _primary.findSerializationPropertyOrder(ac);\n+        if (result == null) {\n+            result = _secondary.findSerializationPropertyOrder(ac);\n+        }\n+        return result;            \n+    }\n+\n+    /**\n+     * Method for checking whether an annotation indicates that serialized properties\n+     * for which no explicit is defined should be alphabetically (lexicograpically)\n+     * ordered\n+     */\n+    @Override\n+    public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n+        Boolean result = _primary.findSerializationSortAlphabetically(ac);\n+        if (result == null) {\n+            result = _secondary.findSerializationSortAlphabetically(ac);\n+        }\n+        return result;            \n+    }\n+\n+    // // // Serialization: property annotations\n+    \n+    @Override\n+    public PropertyName findNameForSerialization(Annotated a) {\n+        PropertyName n = _primary.findNameForSerialization(a);\n+        // note: \"use default\" should not block explicit answer, so:\n+        if (n == null) {\n+            n = _secondary.findNameForSerialization(a);\n+        } else if (n == PropertyName.USE_DEFAULT) {\n+            PropertyName n2 = _secondary.findNameForSerialization(a);\n+            if (n2 != null) {\n+                n = n2;\n+            }\n+        }\n+        return n;\n+    }\n+    \n+    @Override\n+    public boolean hasAsValueAnnotation(AnnotatedMethod am)\n+    {\n+        return _primary.hasAsValueAnnotation(am) || _secondary.hasAsValueAnnotation(am);\n+    }\n+    \n+    @Override\n+    public String findEnumValue(Enum<?> value)\n+    {\n+        String result = _primary.findEnumValue(value);\n+        if (result == null) {\n+            result = _secondary.findEnumValue(value);\n+        }\n+        return result;\n+    }        \n+\n+    // // // Deserialization: general annotations\n+\n+    @Override\n+    public Object findDeserializer(Annotated am)\n+    {\n+        Object result = _primary.findDeserializer(am);\n+        if (result == null) {\n+            result = _secondary.findDeserializer(am);\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public Object findKeyDeserializer(Annotated am)\n+    {\n+        Object result = _primary.findKeyDeserializer(am);\n+        if (result == null || result == KeyDeserializer.None.class || result == NoClass.class) {\n+            result = _secondary.findKeyDeserializer(am);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Object findContentDeserializer(Annotated am)\n+    {\n+        Object result = _primary.findContentDeserializer(am);\n+        if (result == null || result == JsonDeserializer.None.class || result == NoClass.class) {\n+            result = _secondary.findContentDeserializer(am);\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public Class<?> findDeserializationType(Annotated am, JavaType baseType)\n+    {\n+        Class<?> result = _primary.findDeserializationType(am, baseType);\n+        if (result == null) {\n+            result = _secondary.findDeserializationType(am, baseType);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType)\n+    {\n+        Class<?> result = _primary.findDeserializationKeyType(am, baseKeyType);\n+        if (result == null) {\n+            result = _secondary.findDeserializationKeyType(am, baseKeyType);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType)\n+    {\n+        Class<?> result = _primary.findDeserializationContentType(am, baseContentType);\n+        if (result == null) {\n+            result = _secondary.findDeserializationContentType(am, baseContentType);\n+        }\n+        return result;\n+    }\n+\n+    // // // Deserialization: class annotations\n+\n+    @Override\n+    public Object findValueInstantiator(AnnotatedClass ac)\n+    {\n+        Object result = _primary.findValueInstantiator(ac);\n+        if (result == null) {\n+            result = _secondary.findValueInstantiator(ac);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Class<?> findPOJOBuilder(AnnotatedClass ac)\n+    {\n+            Class<?> result = _primary.findPOJOBuilder(ac);\n+            if (result == null) {\n+                    result = _secondary.findPOJOBuilder(ac);\n+            }\n+            return result;\n+    }\n+\n+    @Override\n+    public JsonPOJOBuilder.Value findPOJOBuilderConfig(AnnotatedClass ac)\n+    {\n+        JsonPOJOBuilder.Value result = _primary.findPOJOBuilderConfig(ac);\n+        if (result == null) {\n+            result = _secondary.findPOJOBuilderConfig(ac);\n+        }\n+        return result;\n+    }\n+    \n+    // // // Deserialization: method annotations\n+\n+    @Override\n+    public PropertyName findNameForDeserialization(Annotated a)\n+    {\n+        // note: \"use default\" should not block explicit answer, so:\n+        PropertyName n = _primary.findNameForDeserialization(a);\n+        if (n == null) {\n+            n = _secondary.findNameForDeserialization(a);\n+        } else if (n == PropertyName.USE_DEFAULT) {\n+            PropertyName n2 = _secondary.findNameForDeserialization(a);\n+            if (n2 != null) {\n+                n = n2;\n+            }\n+        }\n+        return n;\n+    }\n+    \n+    @Override\n+    public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n+    {\n+        return _primary.hasAnySetterAnnotation(am) || _secondary.hasAnySetterAnnotation(am);\n+    }\n+\n+    @Override\n+    public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n+    {\n+        return _primary.hasAnyGetterAnnotation(am) || _secondary.hasAnyGetterAnnotation(am);\n+    }\n+    \n+    @Override\n+    public boolean hasCreatorAnnotation(Annotated a)\n+    {\n+        return _primary.hasCreatorAnnotation(a) || _secondary.hasCreatorAnnotation(a);\n+    }\n+ \n+    /*\n+    /******************************************************\n+    /* Deprecated methods\n+    /******************************************************\n+     */\n+    \n+    @Deprecated\n+    @Override\n+    public boolean isHandled(Annotation ann) {\n+        return _primary.isHandled(ann) || _secondary.isHandled(ann);\n+    }\n+\n+    // // // Deserialization: property annotations\n+\n+    @Deprecated\n+    @Override\n+    public String findDeserializationName(AnnotatedMethod am)\n+    {\n+        String result = _primary.findDeserializationName(am);\n+        if (result == null) {\n+            result = _secondary.findDeserializationName(am);\n+        } else if (result.length() == 0) {\n+            /* Empty String is a default; can be overridden by\n+             * more explicit answer from secondary entry\n+             */\n+            String str2 = _secondary.findDeserializationName(am);\n+            if (str2 != null) {\n+                result = str2;\n+            }\n+        }\n+        return result;\n+    }\n+    \n+    @Deprecated\n+    @Override\n+    public String findDeserializationName(AnnotatedField af)\n+    {\n+        String result = _primary.findDeserializationName(af);\n+        if (result == null) {\n+            result = _secondary.findDeserializationName(af);\n+        } else if (result.length() == 0) {\n+            /* Empty String is a default; can be overridden by\n+             * more explicit answer from secondary entry\n+             */\n+            String str2 = _secondary.findDeserializationName(af);\n+            if (str2 != null) {\n+                result = str2;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Deprecated\n+    @Override\n+    public String findDeserializationName(AnnotatedParameter param)\n+    {\n+        String result = _primary.findDeserializationName(param);\n+        if (result == null) {\n+            result = _secondary.findDeserializationName(param);\n+        }\n+        return result;\n+    }\n+\n+    // // // Serialization: property annotations\n+    \n+    @Deprecated\n+    @Override\n+    public String findSerializationName(AnnotatedMethod am)\n+    {\n+        String result = _primary.findSerializationName(am);\n+        if (result == null) {\n+            result = _secondary.findSerializationName(am);\n+        } else if (result.length() == 0) {\n+            /* Empty String is a default; can be overridden by\n+             * more explicit answer from secondary entry\n+             */\n+            String str2 = _secondary.findSerializationName(am);\n+            if (str2 != null) {\n+                result = str2;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Deprecated\n+    @Override\n+    public String findSerializationName(AnnotatedField af)\n+    {\n+        String result = _primary.findSerializationName(af);\n+        if (result == null) {\n+            result = _secondary.findSerializationName(af);\n+        } else if (result.length() == 0) {\n+            /* Empty String is a default; can be overridden by\n+             * more explicit answer from secondary entry\n+             */\n+            String str2 = _secondary.findSerializationName(af);\n+            if (str2 != null) {\n+                result = str2;\n+            }\n+        }\n+        return result;\n+    }\n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericCollectionDeser.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericCollectionDeser.java\n     static class ListSubClass extends ArrayList<StringWrapper> { }\n \n     /**\n-     * Map class that should behave like {@link MapSubClass}, but by\n+     * Map class that should behave like {@link ListSubClass}, but by\n      * using annotations.\n      */\n     @JsonDeserialize(contentAs=StringWrapper.class)\n--- a/src/test/java/com/fasterxml/jackson/databind/ext/TestCoreXMLTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ext/TestCoreXMLTypes.java\n      */\n     \n     // First things first: must be able to load the deserializers...\n+    @SuppressWarnings(\"unused\")\n     public void testDeserializerLoading()\n     {\n         new CoreXMLDeserializers.DurationDeserializer();\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java\n     }\n \n     /**\n-     * Test bean that has an invalid {@link JsonClass} annotation.\n+     * Test bean that has an invalid {@link JsonSerialize} annotation.\n      */\n     static class BrokenClass\n     {", "timestamp": 1346868908, "metainfo": ""}