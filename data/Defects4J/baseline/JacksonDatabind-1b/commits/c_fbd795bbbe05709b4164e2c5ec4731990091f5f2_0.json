{"sha": "fbd795bbbe05709b4164e2c5ec4731990091f5f2", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanPropertyDefinition.java\n public abstract class BeanPropertyDefinition\n     implements Named\n {\n+    /*\n+    /*****************************************************\n+    /* Fluent factory methods for creating modified copies\n+    /*****************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to create a definition with\n+     * same settings as this one, but with different\n+     * (external) name; that is, one for which\n+     * {@link #getName()} would return <code>newName</code>.\n+     */\n+    public abstract BeanPropertyDefinition withName(String newName);\n+    \n     /*\n     /*****************************************************\n     /* Basic property information, name, type\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n             BeanDescription beanDesc, BeanDeserializerBuilder builder)\n         throws JsonMappingException\n     {\n-        List<BeanPropertyDefinition> props = beanDesc.findProperties();\n         // Things specified as \"ok to ignore\"? [JACKSON-77]\n         AnnotationIntrospector intr = ctxt.getAnnotationIntrospector();\n         boolean ignoreAny = false;\n                 }\n             }\n         }\n-        HashMap<Class<?>,Boolean> ignoredTypes = new HashMap<Class<?>,Boolean>();\n+        final boolean useGettersAsSetters = (ctxt.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS)\n+                && ctxt.isEnabled(MapperConfig.Feature.AUTO_DETECT_GETTERS));\n+\n+        // Ok: let's then filter out property definitions\n+        List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt,\n+                beanDesc, builder, beanDesc.findProperties(), ignored);\n+\n+        // After which we can let custom code change the set\n+        if (_factoryConfig.hasDeserializerModifiers()) {\n+            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs);\n+            }\n+        }\n         \n-        // These are all valid setters, but we do need to introspect bit more\n-        for (BeanPropertyDefinition property : props) {\n-            String name = property.getName();\n-            if (ignored.contains(name)) { // explicit ignoral using @JsonIgnoreProperties needs to block entries\n-                continue;\n-            }\n+        // At which point we really should only have properties with mutators...\n+        for (BeanPropertyDefinition property : propDefs) {\n             if (property.hasConstructorParameter()) {\n                 /* [JACKSON-700] If property as passed via constructor parameter, we must\n                  *   handle things in special way. Not sure what is the most optimal way...\n                 builder.addCreatorProperty(property);\n                 continue;\n             }\n-            Class<?> rawPropertyType;\n-            Type propertyType;\n-            AnnotatedMethod setter = property.getSetter();\n-            if (setter != null) {\n-                rawPropertyType = setter.getRawParameterType(0);\n-                propertyType = setter.getGenericParameterType(0);\n-            } else {\n-                AnnotatedField field = property.getField();\n-                if (field != null) {\n-                    rawPropertyType = field.getRawType();\n-                    propertyType = field.getGenericType();\n-                } else {\n+            SettableBeanProperty prop = null;\n+            if (property.hasSetter()) {\n+                Type propertyType = property.getSetter().getGenericParameterType(0);\n+                prop = constructSettableProperty(ctxt,\n+                        beanDesc, property, propertyType);\n+            } else if (property.hasField()) {\n+                Type propertyType = property.getField().getGenericType();\n+                prop = constructSettableProperty(ctxt, beanDesc, property, propertyType);\n+            } else if (useGettersAsSetters && property.hasGetter()) {\n+                /* As per [JACKSON-88], may also need to consider getters\n+                 * for Map/Collection properties\n+                 */\n+                /* also, as per [JACKSON-328], should not override fields (or actual setters),\n+                 * thus these are added AFTER adding fields\n+                 */\n+                AnnotatedMethod getter = property.getGetter();\n+                // should only consider Collections and Maps, for now?\n+                Class<?> rawPropertyType = getter.getRawType();\n+                if (Collection.class.isAssignableFrom(rawPropertyType)\n+                        || Map.class.isAssignableFrom(rawPropertyType)) {\n+                    prop = constructSetterlessProperty(ctxt, beanDesc, property);\n+                }\n+            }\n+            if (prop != null) {\n+                builder.addProperty(prop);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Helper method called to filter out explicit ignored properties,\n+     * as well as properties that have \"ignorable types\".\n+     * Note that this will not remove properties that have no\n+     * setters.\n+     */\n+    protected List<BeanPropertyDefinition> filterBeanProps(DeserializationContext ctxt,\n+            BeanDescription beanDesc, BeanDeserializerBuilder builder,\n+            List<BeanPropertyDefinition> propDefsIn,\n+            Set<String> ignored)\n+        throws JsonMappingException\n+    {\n+        ArrayList<BeanPropertyDefinition> result = new ArrayList<BeanPropertyDefinition>(\n+                Math.max(4, propDefsIn.size()));\n+        HashMap<Class<?>,Boolean> ignoredTypes = new HashMap<Class<?>,Boolean>();\n+        // These are all valid setters, but we do need to introspect bit more\n+        for (BeanPropertyDefinition property : propDefsIn) {\n+            String name = property.getName();\n+            if (ignored.contains(name)) { // explicit ignoral using @JsonIgnoreProperties needs to block entries\n+                continue;\n+            }\n+            if (!property.hasConstructorParameter()) { // never skip constructor params\n+                Class<?> rawPropertyType = null;\n+                if (property.hasSetter()) {\n+                    rawPropertyType = property.getSetter().getRawParameterType(0);\n+                } else if (property.hasField()) {\n+                    rawPropertyType = property.getField().getRawType();\n+                }\n+\n+                // [JACKSON-429] Some types are declared as ignorable as well\n+                if ((rawPropertyType != null)\n+                        && (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes))) {\n+                    // important: make ignorable, to avoid errors if value is actually seen\n+                    builder.addIgnorable(name);\n                     continue;\n                 }\n             }\n-            \n-            // [JACKSON-429] Some types are declared as ignorable as well\n-            if (isIgnorableType(ctxt.getConfig(), beanDesc, rawPropertyType, ignoredTypes)) {\n-                // important: make ignorable, to avoid errors if value is actually seen\n-                builder.addIgnorable(name);\n-            } else {\n-                SettableBeanProperty prop = constructSettableProperty(ctxt,\n-                        beanDesc, property, propertyType);\n-                if (prop != null) {\n-                    builder.addProperty(prop);\n-                }\n-            }\n-        }\n-\n-        /* As per [JACKSON-88], may also need to consider getters\n-         * for Map/Collection properties\n-         */\n-        /* also, as per [JACKSON-328], should not override fields (or actual setters),\n-         * thus these are added AFTER adding fields\n-         */\n-        if (ctxt.isEnabled(MapperConfig.Feature.USE_GETTERS_AS_SETTERS)) {\n-            /* Hmmh. We have to assume that 'use getters as setters' also\n-             * implies 'yes, do auto-detect these getters'? (if not, we'd\n-             * need to add AUTO_DETECT_GETTERS to deser config too, not\n-             * just ser config)\n-             */\n-            for (BeanPropertyDefinition property : props) {\n-                if (property.hasGetter()) {\n-                    String name = property.getName();\n-                    if (builder.hasProperty(name) || ignored.contains(name)) {\n-                        continue;\n-                    }\n-                    AnnotatedMethod getter = property.getGetter();\n-                    // should only consider Collections and Maps, for now?\n-                    Class<?> rt = getter.getRawType();\n-                    if (Collection.class.isAssignableFrom(rt) || Map.class.isAssignableFrom(rt)) {\n-                        if (!ignored.contains(name) && !builder.hasProperty(name)) {\n-                            builder.addProperty(constructSetterlessProperty(ctxt, beanDesc, name, getter));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n+            result.add(property);\n+        }\n+        return result;\n+    }\n+    \n     /**\n      * Method that will find if bean has any managed- or back-reference properties,\n      * and if so add them to bean, to be linked during resolution phase.\n      *    none. Non-null for \"setterless\" properties.\n      */\n     protected SettableBeanProperty constructSetterlessProperty(DeserializationContext ctxt,\n-            BeanDescription beanDesc, String name, AnnotatedMethod getter)\n-        throws JsonMappingException\n-    {\n+            BeanDescription beanDesc, BeanPropertyDefinition propDef)\n+        throws JsonMappingException\n+    {\n+        final String name = propDef.getName();\n+        final AnnotatedMethod getter = propDef.getGetter();\n         // need to ensure it is callable now:\n         if (ctxt.canOverrideAccessModifiers()) {\n             getter.fixAccess();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java\n package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.List;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.BeanDeserializer;\n  * process; and is preferable to sub-classing of {@link BeanDeserializerFactory}.\n  *<p>\n  * Sequence in which callback methods are called is as follows:\n- *  <li>updateBuilder is called once all initial pieces for building deserializer\n+ *  <li>{@link #updateProperties} is called once all property definitions are\n+ *    collected, and initial filtering (by ignorable type and explicit ignoral-by-bean)\n+ *    has been performed.\n+ *  <li>{@link #updateBuilder} is called once all initial pieces for building deserializer\n  *    have been collected\n  *   </li>\n- *  <li><code>modifyDeserializer</code> is called after deserializer has been built\n+ *  <li>{@link #modifyDeserializer} is called after deserializer has been built\n  *    by {@link BeanDeserializerBuilder}\n  *    but before it is returned to be used\n  *   </li>\n  */\n public abstract class BeanDeserializerModifier\n {\n+    /**\n+     * Method called by {@link BeanDeserializerFactory} when it has collected\n+     * initial list of {@link BeanPropertyDefinition}s, and done basic by-name\n+     * and by-type filtering, but before constructing builder or actual\n+     * property handlers; or arranging order.\n+     * \n+     * The most common changes to make at this point are to completely remove\n+     * specified properties, or rename then: other modifications are easier\n+     * to make at later points.\n+     */\n+    public List<BeanPropertyDefinition> updateProperties(DeserializationConfig config,\n+            BeanDescription beanDesc, List<BeanPropertyDefinition> propDefs) {\n+        return propDefs;\n+    }\n+    \n     /**\n      * Method called by {@link BeanDeserializerFactory} when it has collected\n      * basic information such as tentative list of properties to deserialize.\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n         _setters = src._setters;\n         _forSerialization = src._forSerialization;\n     }\n-\n-    /**\n-     * Method for constructing a renamed instance\n-     */\n+    \n+    /*\n+    /**********************************************************\n+    /* Fluent factory methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n     public POJOPropertyBuilder withName(String newName) {\n         return new POJOPropertyBuilder(this, newName);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n         _name = name;\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Fluent factories\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public SimpleBeanPropertyDefinition withName(String newName) {\n+        if (_name.equals(newName)) {\n+            return this;\n+        }\n+        return new SimpleBeanPropertyDefinition(_member, newName);\n+    }\n+    \n     /*\n     /*****************************************************\n     /* Basic property information, name, type", "timestamp": 1327644150, "metainfo": ""}