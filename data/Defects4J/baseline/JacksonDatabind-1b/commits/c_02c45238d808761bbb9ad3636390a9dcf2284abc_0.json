{"sha": "02c45238d808761bbb9ad3636390a9dcf2284abc", "log": "Merge pull request #172 from stevenschlansker/map-unwrap  @JsonUnwrapped does not unwrap Map values as it would unwrap any other dictionary", "commit": "\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrappedWithPrefix.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestUnwrappedWithPrefix.java\n package com.fasterxml.jackson.databind.struct;\n+\n+import java.util.Collections;\n+import java.util.Map;\n \n import com.fasterxml.jackson.annotation.JsonUnwrapped;\n import com.fasterxml.jackson.databind.BaseMapTest;\n     static class ConfigMisc {\n         public int value;\n     }\n-    \n+\n+    static class MapUnwrap {\n+\n+        public MapUnwrap() { }\n+        public MapUnwrap(String key, Object value) {\n+            map = Collections.singletonMap(key, value);\n+        }\n+\n+        @JsonUnwrapped(prefix=\"map.\")\n+        public Map<String, Object> map;\n+    }\n+\n     // // // Reuse mapper to keep tests bit faster\n \n     private final ObjectMapper mapper = new ObjectMapper();\n         String json = mapper.writeValueAsString(new ConfigRoot(\"Fred\", 25));\n         assertEquals(\"{\\\"general.names.name\\\":\\\"Fred\\\",\\\"misc.value\\\":25}\", json);\n     }\n-    \n+\n+    public void testMapUnwrapSerialize() throws Exception\n+    {\n+        String json = mapper.writeValueAsString(new MapUnwrap(\"test\", 6));\n+        assertEquals(\"{\\\"map.test\\\": 6}\", json);\n+    }\n+\n     /*\n     /**********************************************************\n     /* Tests, deserialization\n         assertEquals(\"Joe\", root.general.names.name);\n         assertEquals(42, root.misc.value);\n     }\n+\n+    public void testMapUnwrapDeserialize() throws Exception\n+    {\n+        MapUnwrap root = mapper.readValue(\"{\\\"map.test\\\": 6}\", MapUnwrap.class);\n+\n+        assertEquals(1, root.map.size());\n+        assertEquals(6, ((Number)root.map.get(\"test\")).intValue());\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n \n     protected void _appendPathDesc(StringBuilder sb)\n     {\n+        if (_path == null) {\n+            return;\n+        }\n         Iterator<Reference> it = _path.iterator();\n         while (it.hasNext()) {\n             sb.append(it.next().toString());\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n      * @since 2.1\n      */\n     protected abstract BeanDeserializerBase asArrayDeserializer();\n-    \n+\n     /*\n     /**********************************************************\n     /* Validation, post-processing\n      * after deserializer itself has been registered.\n      * This is needed to handle recursive and transitive dependencies.\n      */\n-//  @Override\n+    @Override\n     public void resolve(DeserializationContext ctxt)\n         throws JsonMappingException\n     {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/failing/TestBackRefsWithPolymorphic.java\n+package com.fasterxml.jackson.failing;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+import com.fasterxml.jackson.annotation.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+\n+// Unit test for [JACKSON-890]\n+public class TestBackRefsWithPolymorphic extends BaseMapTest\n+{\n+    private final String CLASS_NAME = getClass().getName();\n+\n+    // NOTE: order is arbitrary, test is fragile... has to work for now\n+    private final String JSON =\n+        \"{\\\"@class\\\":\\\"\"+CLASS_NAME+\"$PropertySheetImpl\\\",\\\"id\\\":0,\\\"properties\\\":{\\\"p1name\\\":{\\\"@class\\\":\"\n+            +\"\\\"\" +CLASS_NAME+ \"$StringPropertyImpl\\\",\\\"id\\\":0,\\\"name\\\":\\\"p1name\\\",\\\"value\\\":\\\"p1value\\\"},\"\n+            +\"\\\"p2name\\\":{\\\"@class\\\":\\\"\"+CLASS_NAME+\"$StringPropertyImpl\\\",\\\"id\\\":0,\"\n+            +\"\\\"name\\\":\\\"p2name\\\",\\\"value\\\":\\\"p2value\\\"}}}\";\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testDeserialize() throws IOException\n+    {\n+        PropertySheet input = MAPPER.readValue(JSON, PropertySheet.class);\n+        assertEquals(JSON, MAPPER.writeValueAsString(input));\n+    }\n+\n+    public void testSerialize() throws IOException\n+    {\n+        PropertySheet sheet = new PropertySheetImpl();\n+\n+        sheet.addProperty(new StringPropertyImpl(\"p1name\", \"p1value\"));\n+        sheet.addProperty(new StringPropertyImpl(\"p2name\", \"p2value\"));\n+        String actual = MAPPER.writeValueAsString(sheet);\n+        assertEquals(JSON, actual);\n+    }\n+\n+    @JsonPropertyOrder(alphabetic=true)\n+    interface Entity\n+    {\n+        @JsonIgnore String getEntityType();\n+        Long getId();\n+        void setId(Long id);\n+        @JsonIgnore void setPersistable();\n+    }\n+\n+    @JsonDeserialize(as = NestedPropertySheetImpl.class)\n+    interface NestedPropertySheet\n+        extends Property<PropertySheet>\n+    {\n+        @Override PropertySheet getValue();\n+        void setValue(PropertySheet propertySheet);\n+    }\n+\n+    @JsonDeserialize(as = AbstractProperty.class)\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS,\n+        include  = JsonTypeInfo.As.PROPERTY,\n+        property = \"@class\")\n+    interface Property<T> extends Entity\n+    {\n+        String getName();\n+        PropertySheet getParentSheet();\n+        T getValue();\n+        void setName(String name);\n+        void setParentSheet(PropertySheet parentSheet);\n+    }\n+\n+    @JsonDeserialize(as = PropertySheetImpl.class)\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS,\n+        include  = JsonTypeInfo.As.PROPERTY,\n+        property = \"@class\")\n+    @SuppressWarnings(\"rawtypes\")\n+    interface PropertySheet extends Entity\n+    {\n+        void addProperty(Property property);\n+        Map<String, Property> getProperties();\n+        void setProperties(Map<String, Property> properties);\n+    }\n+\n+    @JsonDeserialize(as = StringPropertyImpl.class)\n+    interface StringProperty\n+        extends Property<String>\n+    {\n+        @Override String getValue();\n+        void setValue(String value);\n+    }\n+\n+    static class AbstractEntity implements Entity\n+    {\n+        private long id;\n+\n+        @Override public String getEntityType() {\n+            return \"\";\n+        }\n+\n+        @Override public Long getId() {\n+            return id;\n+        }\n+\n+        @Override public void setId(Long id)\n+        {\n+            this.id = id;\n+        }\n+\n+        @Override public void setPersistable() { }\n+    }\n+\n+    abstract static class AbstractProperty<T>\n+        extends AbstractEntity\n+        implements Property<T>\n+    {\n+        private String        m_name;\n+        private PropertySheet m_parentSheet;\n+\n+        protected AbstractProperty() { }\n+\n+        protected AbstractProperty(String name) {\n+            m_name = name;\n+        }\n+\n+        @Override public String getName() {\n+            return m_name;\n+        }\n+\n+        @JsonBackReference(\"propertySheet-properties\")\n+        @Override public PropertySheet getParentSheet() {\n+            return m_parentSheet;\n+        }\n+\n+        @Override public void setName(String name) {\n+            m_name = name;\n+        }\n+\n+        @Override public void setParentSheet(PropertySheet parentSheet) {\n+            m_parentSheet = parentSheet;\n+        }\n+    }\n+\n+    @JsonPropertyOrder(alphabetic=true)\n+    static class NestedPropertySheetImpl\n+        extends AbstractProperty<PropertySheet>\n+        implements NestedPropertySheet\n+    {\n+        private PropertySheet m_propertySheet;\n+\n+        protected NestedPropertySheetImpl(String name,\n+                PropertySheet propertySheet)\n+        {\n+            super(name);\n+            m_propertySheet = propertySheet;\n+        }\n+\n+        NestedPropertySheetImpl() { }\n+\n+        @Override public PropertySheet getValue() {\n+            return m_propertySheet;\n+        }\n+\n+        @Override public void setValue(PropertySheet propertySheet) {\n+            m_propertySheet = propertySheet;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    static class PropertySheetImpl\n+        extends AbstractEntity\n+        implements PropertySheet\n+    {\n+        private Map<String, Property> m_properties;\n+\n+        @Override public void addProperty(Property property)\n+        {\n+            if (m_properties == null) {\n+                m_properties = new TreeMap<String, Property>();\n+            }\n+            property.setParentSheet(this);\n+            m_properties.put(property.getName(), property);\n+        }\n+\n+        @JsonDeserialize(as = TreeMap.class,\n+            keyAs     = String.class,\n+            contentAs = Property.class)\n+        @JsonManagedReference(\"propertySheet-properties\")\n+        @Override public Map<String, Property> getProperties() {\n+            return m_properties;\n+        }\n+\n+        @Override public void setProperties(Map<String, Property> properties) {\n+            m_properties = properties;\n+        }\n+    }\n+\n+    static class StringPropertyImpl\n+        extends AbstractProperty<String>\n+        implements StringProperty\n+    {\n+        private String m_value;\n+\n+        public StringPropertyImpl(String name, String value) {\n+            super(name);\n+            m_value = value;\n+        }\n+\n+        StringPropertyImpl() { }\n+\n+        @Override public String getValue() {\n+            return m_value;\n+        }\n+\n+        @Override public void setValue(String value) {\n+            m_value = value;\n+        }\n+    }\n+\n+    static class YetAnotherClass extends StringPropertyImpl { }\n+}", "timestamp": 1361917786, "metainfo": ""}