{"sha": "dc65cc043479dd03dad878b22a9e5864e2e53bd7", "log": "Start work on \"POJOs-as-arrays\" serialization", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n         }\n     }\n \n+    /**\n+     * Alternative to {@link #serializeAsField} that is used when a POJO\n+     * is serialized as JSON Array; the difference is that no field names\n+     * are written.\n+     * \n+     * @since 2.1\n+     */\n+    public void serializeAsColumn(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        Object value = get(bean);\n+        if (value == null) { // nulls need specialized handling\n+            if (_nullSerializer != null) {\n+                _nullSerializer.serialize(null, jgen, prov);\n+            }\n+            return;\n+        }\n+        // otherwise find serializer to use\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+        // and then see if we must suppress certain values (default, empty)\n+        if (_suppressableValue != null) {\n+            if (MARKER_FOR_EMPTY == _suppressableValue) {\n+                if (ser.isEmpty(value)) {\n+                    return;\n+                }\n+            } else if (_suppressableValue.equals(value)) {\n+                return;\n+            }\n+        }\n+        // For non-nulls: simple check for direct cycles\n+        if (value == bean) {\n+            _handleSelfReference(bean, ser);\n+        }\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, jgen, prov);\n+        } else {\n+            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.io.SerializedString;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.impl.BeanAsArraySerializer;\n import com.fasterxml.jackson.databind.ser.impl.ObjectIdWriter;\n import com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer;\n import com.fasterxml.jackson.databind.ser.impl.WritableObjectId;\n     }\n \n     @Override\n-    protected BeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n+    public BeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n         return new BeanSerializer(this, objectIdWriter);\n     }\n \n     @Override\n     protected BeanSerializer withIgnorals(String[] toIgnore) {\n         return new BeanSerializer(this, toIgnore);\n+    }\n+\n+    /**\n+     * Implementation has to check whether as-array serialization\n+     * is possible reliably; if (and only if) so, will construct\n+     * a {@link BeanAsArraySerializer}, otherwise will return this\n+     * serializer as is.\n+     */\n+    @Override\n+    protected BeanSerializerBase asArraySerializer()\n+    {\n+        /* Can not:\n+         * \n+         * - have Object Id (may be allowed in future)\n+         * - have any getter\n+         * \n+         */\n+        if ((_objectIdWriter == null)\n+                && (_anyGetterWriter == null)\n+                && (_propertyFilterId == null)\n+                ) {\n+            return new BeanAsArraySerializer(this);\n+        }\n+        // already is one, so:\n+        return this;\n     }\n     \n     /*\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/BeanAsArraySerializer.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n+import com.fasterxml.jackson.databind.util.NameTransformer;\n+\n+/**\n+ * Specialized POJO serializer that differs from\n+ * {@link com.fasterxml.jackson.databind.ser.BeanSerializer}\n+ * in that instead of producing a JSON Object it will output\n+ * a JSON Array, omitting field names, and serializing values in\n+ * specified serialization order.\n+ * This behavior is usually triggered by using annotation\n+ * {@link com.fasterxml.jackson.annotation.JsonFormat} or its\n+ * equivalents.\n+ *<p>\n+ * This serializer can be used for \"simple\" instances; and will NOT\n+ * be used if one of following is true:\n+ *<ul>\n+ * <li>Unwrapping is used (no way to expand out array in JSON Object)\n+ *  </li>\n+ * <li>Type information (\"type id\") is to be used: while this could work\n+ *   for some embedding methods, it would likely cause conflicts.\n+ *  </li>\n+ * <li>Object Identity (\"object id\") is used: while references would work,\n+ *    the problem is inclusion of id itself.\n+ *  </li>\n+ *</ul>\n+ * Note that it is theoretically possible that last 2 issues could be addressed\n+ * (by reserving room in array, for example); and if so, support improved.\n+ *<p>\n+ * In cases where array-based output is not feasible, this serializer\n+ * can instead delegate to the original Object-based serializer; this\n+ * is why a reference is retained to the original serializer.\n+ * \n+ * @since 2.1\n+ */\n+public class BeanAsArraySerializer\n+    extends BeanSerializerBase\n+{\n+    /**\n+     * Serializer that would produce JSON Object version; used in\n+     * cases where array output can not be used.\n+     */\n+    protected final BeanSerializerBase _defaultSerializer;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructors\n+    /**********************************************************\n+     */\n+\n+\n+    public BeanAsArraySerializer(BeanSerializerBase src) {    \n+        super(src, (ObjectIdWriter) null);\n+        _defaultSerializer = src;\n+    }\n+\n+    protected BeanAsArraySerializer(BeanSerializerBase src, String[] toIgnore) {\n+        super(src, toIgnore);\n+        _defaultSerializer = src;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: factory methods, fluent factories\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonSerializer<Object> unwrappingSerializer(NameTransformer transformer) {\n+        /* If this gets called, we will just need delegate to the default\n+         * serializer, to \"undo\" as-array serialization\n+         */\n+        return _defaultSerializer.unwrappingSerializer(transformer);\n+    }\n+\n+    @Override\n+    public boolean isUnwrappingSerializer() {\n+        return false;\n+    }\n+\n+    @Override\n+    public BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n+        // can't handle Object Ids, for now, so:\n+        return _defaultSerializer.withObjectIdWriter(objectIdWriter);\n+    }\n+\n+    @Override\n+    protected BeanAsArraySerializer withIgnorals(String[] toIgnore) {\n+        return new BeanAsArraySerializer(this, toIgnore);\n+    }\n+\n+    @Override\n+    protected BeanSerializerBase asArraySerializer() {\n+        // already is one, so:\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonSerializer implementation that differs between impls\n+    /**********************************************************\n+     */\n+\n+    // Re-defined from base class...\n+    @Override\n+    public void serializeWithType(Object bean, JsonGenerator jgen,\n+            SerializerProvider provider, TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        /* Should not even get here; but let's be nice and re-routed\n+         * if need be.\n+         */\n+        _defaultSerializer.serializeWithType(bean, jgen, provider, typeSer);\n+    }\n+    \n+    /**\n+     * Main serialization method that will delegate actual output to\n+     * configured\n+     * {@link BeanPropertyWriter} instances.\n+     */\n+    @Override\n+    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        /* note: it is assumed here that limitations (type id, object id,\n+         * any getter, filtering) have already been checked; so code here\n+         * is trivial.\n+         */\n+        jgen.writeStartArray();\n+        serializeAsArray(bean, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Field serialization methods\n+    /**********************************************************\n+     */\n+\n+    protected final void serializeAsArray(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final BeanPropertyWriter[] props;\n+        if (_filteredProps != null && provider.getSerializationView() != null) {\n+            props = _filteredProps;\n+        } else {\n+            props = _props;\n+        }\n+        int i = 0;\n+        try {\n+            for (final int len = props.length; i < len; ++i) {\n+                BeanPropertyWriter prop = props[i];\n+                if (prop == null) { // can have nulls in filtered list; but if so, MUST write placeholders\n+                    jgen.writeNull();\n+                } else {\n+                    prop.serializeAsColumn(bean, jgen, provider);\n+                }\n+            }\n+            // NOTE: any getters can not be supported either\n+            //if (_anyGetterWriter != null) {\n+            //    _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+            //}\n+        } catch (Exception e) {\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            wrapAndThrow(provider, e, bean, name);\n+        } catch (StackOverflowError e) {\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n+            throw mapE;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override public String toString() {\n+        return \"BeanAsArraySerializer for \"+handledType().getName();\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n     }\n \n     @Override\n-    protected UnwrappingBeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n+    public UnwrappingBeanSerializer withObjectIdWriter(ObjectIdWriter objectIdWriter) {\n         return new UnwrappingBeanSerializer(this, objectIdWriter);\n     }\n \n     @Override\n     protected UnwrappingBeanSerializer withIgnorals(String[] toIgnore) {\n         return new UnwrappingBeanSerializer(this, toIgnore);\n+    }\n+\n+    /**\n+     * JSON Array output can not be done if unwrapping operation is\n+     * requested; so implementation will simply return 'this'.\n+     */\n+    @Override\n+    protected BeanSerializerBase asArraySerializer() {\n+        return this;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n import java.lang.reflect.Type;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n import com.fasterxml.jackson.core.*;\n      * \n      * @since 2.0\n      */\n-    protected abstract BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter);\n+    public abstract BeanSerializerBase withObjectIdWriter(ObjectIdWriter objectIdWriter);\n \n     /**\n      * Fluent factory used for creating a new instance with additional\n      * @since 2.0\n      */\n     protected abstract BeanSerializerBase withIgnorals(String[] toIgnore);\n+\n+    /**\n+     * Fluent factory for creating a variant that output POJO as a\n+     * JSON Array. Implementations may ignore this request if output\n+     * as array is not possible (either at all, or reliably).\n+     * \n+     * @since 2.1\n+     */\n+    protected abstract BeanSerializerBase asArraySerializer();\n     \n     /**\n      * Copy-constructor that is useful for sub-classes that just want to\n         ObjectIdWriter oiw = _objectIdWriter;\n         String[] ignorals = null;\n         final AnnotationIntrospector intr = provider.getAnnotationIntrospector();\n+        final AnnotatedMember accessor = (property == null || intr == null)\n+                ? null : property.getMember();\n         \n         // First: may have an override for Object Id:\n         if (property != null && intr != null) {\n-            final AnnotatedMember accessor = property.getMember();\n             ignorals = intr.findPropertiesToIgnore(accessor);\n             final ObjectIdInfo objectIdInfo = intr.findObjectIdInfo(accessor);\n             if (objectIdInfo != null) {\n         if (ignorals != null && ignorals.length != 0) {\n             contextual = contextual.withIgnorals(ignorals);\n         }\n+        // One more thing: are we asked to serialize POJO as array?\n+        if (accessor != null) {\n+            JsonFormat.Value format = intr.findFormat(accessor);\n+\n+            if (format != null) {\n+                if (format.getShape() == JsonFormat.Shape.ARRAY) {\n+                    contextual = contextual.asArraySerializer();\n+                }\n+            }\n+        }\n         return contextual;\n     }\n     \n     /* Field serialization methods\n     /**********************************************************\n      */\n-    \n+\n     protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestPOJOAsArraySerialization.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestPOJOAsArraySerialization extends BaseMapTest\n+{\n+    static class Pojo\n+    {\n+        @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+        public PojoValue value;\n+\n+        public Pojo() { }\n+        public Pojo(String name, int x, int y, boolean c) {\n+            value = new PojoValue(name, x, y, c);\n+        }\n+    }\n+\n+    // note: must be serialized/deserialized alphabetically; fields NOT declared in that order\n+    @JsonPropertyOrder(alphabetic=true)\n+    static class PojoValue\n+    {\n+        public int x, y;\n+        public String name;\n+        public boolean complete;\n+\n+        public PojoValue() { }\n+        public PojoValue(String name, int x, int y, boolean c) {\n+            this.name = name;\n+            this.x = x;\n+            this.y = y;\n+            this.complete = c;\n+        }\n+    }\n+\n+    @JsonPropertyOrder(alphabetic=true)\n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY)\n+    static class FlatPojo\n+    {\n+        public int x, y;\n+        public String name;\n+        public boolean complete;\n+\n+        public FlatPojo() { }\n+        public FlatPojo(String name, int x, int y, boolean c) {\n+            this.name = name;\n+            this.x = x;\n+            this.y = y;\n+            this.complete = c;\n+        }\n+    }\n+    \n+    /*\n+    /*****************************************************\n+    /* Unit tests\n+    /*****************************************************\n+     */\n+\n+    private final static ObjectMapper MAPPER = new ObjectMapper();\n+    \n+    /**\n+     * Test that verifies that property annotation works\n+     */\n+    public void testSimplePropertyValue() throws Exception\n+    {\n+        String json = MAPPER.writeValueAsString(new Pojo(\"Foobar\", 42, 13, true));\n+        // will have wrapper POJO, then POJO-as-array..\n+        assertEquals(\"{\\\"value\\\":[true,\\\"Foobar\\\",42,13]}\", json);\n+    }\n+\n+    /**\n+     * Test that verifies that Class annotation works\n+     */\n+    public void testSimpleRootValue() throws Exception\n+    {\n+        String json = MAPPER.writeValueAsString(new FlatPojo(\"Bubba\", 1, 2, false));\n+        // will have wrapper POJO, then POJO-as-array..\n+        assertEquals(\"[false,\\\"Bubba\\\",1,2]\", json);\n+    }\n+    \n+}", "timestamp": 1340947417, "metainfo": ""}