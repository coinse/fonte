{"sha": "2b1e3e292cf2b93f8d846e691a914cc1f269c7db", "log": "Merge pull request #9 from rawlingsj/master  Implemented the required attribute for JSON schema generation", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/jsonschema/SchemaAware.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsonschema/SchemaAware.java\n      */\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         throws JsonMappingException;\n+    \n+    /**\n+     * Get the representation of the schema to which this serializer will conform.\n+     *\n+     * @param provider The serializer provider.\n+     * @param isOptional Is the type optional\n+     * @param typeHint A hint about the type.\n+     * @return <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n+     */\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional)\n+        throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n import java.io.IOException;\n import java.lang.reflect.Type;\n import java.util.*;\n+\n+import javax.xml.bind.annotation.XmlElement;\n \n import com.fasterxml.jackson.annotation.ObjectIdGenerator;\n import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n             if (id != null && id.length() > 0) {\n                 o.put(\"id\", id);\n             }\n-        }        \n+        }\n+ \n         //todo: should the classname go in the title?\n         //o.put(\"title\", _className);\n         ObjectNode propertiesNode = o.objectNode();\n         for (int i = 0; i < _props.length; i++) {\n             BeanPropertyWriter prop = _props[i];\n             JavaType propType = prop.getSerializationType();\n+\n             // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n             Type hint = (propType == null) ? prop.getGenericPropertyType() : propType.getRawClass();\n             // Maybe it already has annotated/statically configured serializer?\n                 }\n                 ser = provider.findValueSerializer(serType, prop);\n             }\n+            boolean isOptional = !isPropertyRequired(prop, provider);\n+            \n             JsonNode schemaNode = (ser instanceof SchemaAware) ?\n-                    ((SchemaAware) ser).getSchema(provider, hint) : \n+                    ((SchemaAware) ser).getSchema(provider, hint, isOptional) : \n                     JsonSchema.getDefaultSchemaNode();\n             propertiesNode.put(prop.getName(), schemaNode);\n         }\n         o.put(\"properties\", propertiesNode);\n         return o;\n     }\n+\n+    /**\n+     * Determines if a bean property is required. Currently this looks for any XmlElement annotations\n+     * that have a require attribute.\n+     * @param prop the bean property.\n+     * @return true if the property is optional, false otherwise.\n+     */\n+\tprivate boolean isPropertyRequired(final BeanPropertyWriter prop, final SerializerProvider provider) {\n+\t\tBoolean value = provider.getAnnotationIntrospector().hasRequiredMarker(prop.getMember());\n+\t\treturn value == null ? false : value.booleanValue();\n+\t}\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n         return createSchemaNode(\"string\");\n     }\n     \n+    /**\n+     * Default implementation simply claims type is \"string\"; usually\n+     * overriden by custom serializers.\n+     */\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint, boolean isOptional)\n+        throws JsonMappingException\n+    {\n+    \tObjectNode schema = (ObjectNode) getSchema(provider, typeHint);\n+    \tif (!isOptional) {\n+    \t\tschema.put(\"required\", !isOptional);\n+    \t}\n+        return schema;\n+    }\n+    \n     protected ObjectNode createObjectNode() {\n         return JsonNodeFactory.instance.objectNode();\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsonschema/TestGenerateJsonSchema.java\n package com.fasterxml.jackson.databind.jsonschema;\n \n-import java.util.*;\n+import java.util.Collection;\n+import java.util.Map;\n \n+import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n \n /**\n         private String property2;\n         private String[] property3;\n         private Collection<Float> property4;\n-\n+        @JsonProperty(required=true)\n+        private String property5;\n+        \n         public int getProperty1()\n         {\n             return property1;\n         {\n             this.property4 = property4;\n         }\n+        \n+        public String getProperty5()\n+        {\n+            return property5;\n+        }\n+\n+        public void setProperty5(String property5)\n+        {\n+            this.property5 = property5;\n+        }\n     }\n \n     public class TrivialBean {\n         throws Exception\n     {\n         JsonSchema jsonSchema = MAPPER.generateJsonSchema(SimpleBean.class);\n+        \n         assertNotNull(jsonSchema);\n \n         // test basic equality, and that equals() handles null, other obs\n--- a/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n     /**********************************************************\n      */\n \n-    @Override\n+//  @Override\n     public abstract Version version();\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n     /**\n      * Method to get logical name of the property\n      */\n-    @Override\n+//  @Override\n     public String getName();\n     \n     /**\n             return new Std(_name, type, _contextAnnotations, _member);\n         }\n         \n-        @Override\n+//        @Override\n         public <A extends Annotation> A getAnnotation(Class<A> acls) {\n             return (_member == null) ? null : _member.getAnnotation(acls);\n         }\n \n-        @Override\n+//        @Override\n         public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n             return (_contextAnnotations == null) ? null : _contextAnnotations.get(acls);\n         }\n         \n-        @Override\n+//      @Override\n         public String getName() {\n             return _name;\n         }\n \n-        @Override\n+//      @Override\n         public JavaType getType() {\n             return _type;\n         }\n \n-        @Override\n+//      @Override\n         public AnnotatedMember getMember() {\n             return _member;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n  * passes an immutable instance to be used for deserialization process.\n  *<p>\n  * Note that instances are considered immutable and as such no copies\n- * should need to be created (there are some implementation details\n- * with respect to mix-in annotations; where this is guaranteed as\n- * long as caller follow \"copy-then-use\" pattern)\n+ * should need to be created for sharing; all copying is done with\n+ * \"fluent factory\" methods.\n+ * Note also that unlike with Jackson 1, these instances can not be\n+ * assigned to {@link ObjectMapper}; in fact, application code should\n+ * rarely interact directly with these instance (unlike core Jackson code)\n  */\n public final class DeserializationConfig\n     extends MapperConfigBase<DeserializationFeature, DeserializationConfig>\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n         _defaultState = defaultState;\n     }\n \n-    @Override\n+//  @Override\n     public boolean enabledByDefault() { return _defaultState; }\n \n-    @Override\n+//  @Override\n     public int getMask() { return (1 << ordinal()); }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JavaType.java\n         JavaType result = _narrow(subclass);\n \n         // TODO: these checks should NOT actually be needed; above should suffice:\n-        if (_valueHandler != result.getValueHandler()) {\n+        if (_valueHandler != result.<Object>getValueHandler()) {\n             result = result.withValueHandler(_valueHandler);\n         }\n-        if (_typeHandler != result.getTypeHandler()) {\n+        if (_typeHandler != result.<Object>getTypeHandler()) {\n             result = result.withTypeHandler(_typeHandler);\n         }\n         return result;\n         }\n         JavaType result = _narrow(subclass);\n         // TODO: these checks should NOT actually be needed; above should suffice:\n-        if (_valueHandler != result.getValueHandler()) {\n+        if (_valueHandler != result.<Object>getValueHandler()) {\n             result = result.withValueHandler(_valueHandler);\n         }\n-        if (_typeHandler != result.getTypeHandler()) {\n+        if (_typeHandler != result.<Object>getTypeHandler()) {\n             result = result.withTypeHandler(_typeHandler);\n         }\n         return result;\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n      * convenience \"for-each\" loop can be used for looping over elements\n      * of JSON Array constructs.\n      */\n-    @Override\n+//  @Override\n     public final Iterator<JsonNode> iterator() { return elements(); }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperFeature.java\n         _defaultState = defaultState;\n     }\n     \n-    @Override\n+//  @Override\n     public boolean enabledByDefault() { return _defaultState; }\n \n-    @Override\n+//  @Override\n     public int getMask() { return (1 << ordinal()); }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n     /**********************************************************\n      */\n \n-    @Override\n+//  @Override\n     public boolean hasNext()\n     {\n         try {\n         }\n     }\n \n-    @Override\n+//  @Override\n     public T next()\n     {\n         try {\n         }\n     }\n \n-    @Override public void remove() {\n+//  @Override\n+    public void remove() {\n         throw new UnsupportedOperationException();\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/Module.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/Module.java\n      * Method that returns version of this module. Can be used by Jackson for\n      * informational purposes.\n      */\n-    @Override\n+//  @Override\n     public abstract Version version();\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * Method that will return version information stored in and read from jar\n      * that contains this class.\n      */\n-    @Override\n+//  @Override\n     public Version version() {\n         return DatabindVersion.instance.version();\n     }\n         {\n             // // // Accessors\n \n-            @Override\n+//          @Override\n             public Version getMapperVersion() {\n                 return version();\n             }\n \n             @SuppressWarnings(\"unchecked\")\n-            @Override\n+//          @Override\n             public <C extends ObjectCodec> C getOwner() {\n                 // why do we need the cast here?!?\n                 return (C) mapper;\n             }\n \n-            @Override\n+//          @Override\n             public TypeFactory getTypeFactory() {\n                 return _typeFactory;\n             }\n             \n-            @Override\n+//          @Override\n             public boolean isEnabled(MapperFeature f) {\n                 return mapper.isEnabled(f);\n             }\n \n-            @Override\n+//          @Override\n             public boolean isEnabled(DeserializationFeature f) {\n                 return mapper.isEnabled(f);\n             }\n             \n-            @Override\n+//          @Override\n             public boolean isEnabled(SerializationFeature f) {\n                 return mapper.isEnabled(f);\n             }\n \n-            @Override\n+//          @Override\n             public boolean isEnabled(JsonFactory.Feature f) {\n                 return mapper.isEnabled(f);\n             }\n \n-            @Override\n+//          @Override\n             public boolean isEnabled(JsonParser.Feature f) {\n                 return mapper.isEnabled(f);\n             }\n             \n-            @Override\n+//          @Override\n             public boolean isEnabled(JsonGenerator.Feature f) {\n                 return mapper.isEnabled(f);\n             }\n             \n             // // // Methods for registering handlers: deserializers\n             \n-            @Override\n+//          @Override\n             public void addDeserializers(Deserializers d) {\n                 DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalDeserializers(d);\n                 mapper._deserializationContext = mapper._deserializationContext.with(df);\n             }\n \n-            @Override\n+//          @Override\n             public void addKeyDeserializers(KeyDeserializers d) {\n                 DeserializerFactory df = mapper._deserializationContext._factory.withAdditionalKeyDeserializers(d);\n                 mapper._deserializationContext = mapper._deserializationContext.with(df);\n             }\n \n-            @Override\n+//          @Override\n             public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n                 DeserializerFactory df = mapper._deserializationContext._factory.withDeserializerModifier(modifier);\n                 mapper._deserializationContext = mapper._deserializationContext.with(df);\n             \n             // // // Methods for registering handlers: serializers\n             \n-            @Override\n+//          @Override\n             public void addSerializers(Serializers s) {\n                 mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n             }\n \n-            @Override\n+//          @Override\n             public void addKeySerializers(Serializers s) {\n                 mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n             }\n             \n-            @Override\n+//          @Override\n             public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n                 mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n             }\n \n             // // // Methods for registering handlers: other\n             \n-            @Override\n+//          @Override\n             public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n                 DeserializerFactory df = mapper._deserializationContext._factory.withAbstractTypeResolver(resolver);\n                 mapper._deserializationContext = mapper._deserializationContext.with(df);\n             }\n \n-            @Override\n+//          @Override\n             public void addTypeModifier(TypeModifier modifier) {\n                 TypeFactory f = mapper._typeFactory;\n                 f = f.withModifier(modifier);\n                 mapper.setTypeFactory(f);\n             }\n \n-            @Override\n+//          @Override\n             public void addValueInstantiators(ValueInstantiators instantiators) {\n                 DeserializerFactory df = mapper._deserializationContext._factory.withValueInstantiators(instantiators);\n                 mapper._deserializationContext = mapper._deserializationContext.with(df);\n             }\n             \n-            @Override\n+//          @Override\n             public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n                 mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n                 mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n             }\n             \n-            @Override\n+//          @Override\n             public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n                 mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n                 mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n             }\n \n-            @Override\n+//          @Override\n             public void registerSubtypes(Class<?>... subtypes) {\n                 mapper.registerSubtypes(subtypes);\n             }\n \n-            @Override\n+//          @Override\n             public void registerSubtypes(NamedType... subtypes) {\n                 mapper.registerSubtypes(subtypes);\n             }\n             \n-            @Override\n+//          @Override\n             public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                 mapper.addMixInAnnotations(target, mixinSource);\n             }\n             \n-            @Override\n+//          @Override\n             public void addDeserializationProblemHandler(DeserializationProblemHandler handler) {\n                 mapper.addHandler(handler);\n             }\n      *   objectMapper.convertValue(n, valueClass);\n      *</pre>\n      */\n+    @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> T treeToValue(TreeNode n, Class<T> valueType)\n         throws JsonProcessingException\n     {\n         try {\n+            // [Issue-11]: Simple cast when we just want to cast to, say, ObjectNode\n+            if (n.getClass().isAssignableFrom(valueType)) {\n+                return (T) n;\n+            }\n             return readValue(treeAsTokens(n), valueType);\n         } catch (JsonProcessingException e) {\n             throw e;\n     public <T> T convertValue(Object fromValue, Class<T> toValueType)\n         throws IllegalArgumentException\n     {\n+        // sanity check for null first:\n+        if (fromValue == null) return null;\n+        // also, as per [Issue-11], consider case for simple cast\n+        if (fromValue.getClass().isAssignableFrom(toValueType)) {\n+            return (T) fromValue;\n+        }\n         return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n     } \n \n-    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n-    public <T> T convertValue(Object fromValue, TypeReference toValueTypeRef)\n+    public <T> T convertValue(Object fromValue, TypeReference<?> toValueTypeRef)\n         throws IllegalArgumentException\n     {\n-        return (T) _convert(fromValue, _typeFactory.constructType(toValueTypeRef));\n+        return convertValue(fromValue, _typeFactory.constructType(toValueTypeRef));\n     } \n \n     @SuppressWarnings(\"unchecked\")\n     public <T> T convertValue(Object fromValue, JavaType toValueType)\n         throws IllegalArgumentException\n     {\n+        // sanity check for null first:\n+        if (fromValue == null) return null;\n+        // also, as per [Issue-11], consider case for simple cast\n+        if (fromValue.getClass().isAssignableFrom(toValueType.getRawClass())) {\n+            return (T) fromValue;\n+        }\n         return (T) _convert(fromValue, toValueType);\n     } \n \n      */\n     protected Object _convert(Object fromValue, JavaType toValueType)\n         throws IllegalArgumentException\n-    {\n-        // sanity check for null first:\n-        if (fromValue == null) return null;\n+    {        \n         /* Then use TokenBuffer, which is a JsonGenerator:\n          * (see [JACKSON-175])\n          */\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n      * Method that will return version information stored in and read from jar\n      * that contains this class.\n      */\n-    @Override\n+//  @Override\n     public Version version() {\n         return DatabindVersion.instance.version();\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n  * new instances are constructed for different configurations.\n  * Instances are initially constructed by {@link ObjectMapper} and can be\n  * reused in completely thread-safe manner with no explicit synchronization\n- * \n- * @author tatu\n  */\n public class ObjectWriter\n     implements Versioned\n      * Method that will return version information stored in and read from jar\n      * that contains this class.\n      */\n-    @Override\n+//  @Override\n     public Version version() {\n         return DatabindVersion.instance.version();\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n  * (either directly, or through {@link ObjectWriter}.\n  *<p>\n  * Note that instances are considered immutable and as such no copies\n- * should need to be created (there are some implementation details\n- * with respect to mix-in annotations; where this is guaranteed as\n- * long as caller follow \"copy-then-use\" pattern)\n+ * should need to be created for sharing; all copying is done with\n+ * \"fluent factory\" methods.\n+ * Note also that unlike with Jackson 1, these instances can not be\n+ * assigned to {@link ObjectMapper}; in fact, application code should\n+ * rarely interact directly with these instance (unlike core Jackson code)\n  */\n public final class SerializationConfig\n     extends MapperConfigBase<SerializationFeature, SerializationConfig>\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n     private SerializationFeature(boolean defaultState) {\n         _defaultState = defaultState;\n     }\n-    \n-    @Override\n+\n+//    @Override\n     public boolean enabledByDefault() { return _defaultState; }\n \n-    @Override\n+//    @Override\n     public int getMask() { return (1 << ordinal()); }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n      * Method that will check if there are \"mix-in\" classes (with mix-in\n      * annotations) for given class\n      */\n-    @Override\n+//  @Override\n     public final Class<?> findMixInClassFor(Class<?> cls) {\n         return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean)\n         throws IOException, JsonProcessingException\n-    {        \n+    {\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n         }\n         if (_externalTypeIdHandler != null) {\n             return deserializeWithExternalTypeId(jp, ctxt, bean);\n+        }\n+        JsonToken t = jp.getCurrentToken();\n+        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n         }\n         if (_needViewProcesing) {\n             Class<?> view = ctxt.getActiveView();\n             if (view != null) {\n                 return deserializeWithView(jp, ctxt, bean, view);\n             }\n-        }\n-        JsonToken t = jp.getCurrentToken();\n-        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n-        if (t == JsonToken.START_OBJECT) {\n-            t = jp.nextToken();\n         }\n         for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n             String propName = jp.getCurrentName();\n             jp.nextToken();\n             SettableBeanProperty prop = _beanProperties.find(propName);\n             if (prop != null) { // normal case\n+                // [JACKSON-831]: may have property AND be used as external type id:\n+                if (jp.getCurrentToken().isScalarValue()) {\n+                    ext.handleTypePropertyValue(jp, ctxt, propName, bean);\n+                }\n                 if (activeView != null && !prop.visibleInView(activeView)) {\n                     jp.skipChildren();\n                     continue;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n      * after deserializer itself has been registered.\n      * This is needed to handle recursive and transitive dependencies.\n      */\n-    @Override\n+//  @Override\n     public void resolve(DeserializationContext ctxt)\n         throws JsonMappingException\n     {\n      * access to referring property's annotations here; and this is needed\n      * to support per-property ObjectIds.\n      */\n-    @Override\n+//  @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n             BeanProperty property) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n      */\n     public static class Base implements Deserializers\n     {\n-        @Override\n+//      @Override\n         public JsonDeserializer<?> findArrayDeserializer(ArrayType type,\n                 DeserializationConfig config, BeanDescription beanDesc,\n                 TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n             return null;\n         }\n \n-        @Override\n+//      @Override\n         public JsonDeserializer<?> findCollectionDeserializer(CollectionType type,\n                 DeserializationConfig config, BeanDescription beanDesc,\n                 TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n             return null;\n         }\n \n-        @Override\n+//      @Override\n         public JsonDeserializer<?> findCollectionLikeDeserializer(CollectionLikeType type,\n                 DeserializationConfig config, BeanDescription beanDesc,\n                 TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n             return null;\n         }\n \n-        @Override\n+//      @Override\n         public JsonDeserializer<?> findMapDeserializer(MapType type,\n                 DeserializationConfig config, BeanDescription beanDesc,\n                 KeyDeserializer keyDeserializer,\n             return null;\n         }\n \n-        @Override\n+//      @Override\n         public JsonDeserializer<?> findMapLikeDeserializer(MapLikeType type,\n                 DeserializationConfig config, BeanDescription beanDesc,\n                 KeyDeserializer keyDeserializer,\n             return null;\n         }\n \n-        @Override\n+//      @Override\n         public JsonDeserializer<?> findEnumDeserializer(Class<?> type,\n                 DeserializationConfig config, BeanDescription beanDesc)\n             throws JsonMappingException\n             return null;\n         }\n         \n-        @Override\n+//      @Override\n         public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType,\n                 DeserializationConfig config, BeanDescription beanDesc)\n             throws JsonMappingException\n             return null;\n         }\n \n-        @Override\n+//      @Override\n         public JsonDeserializer<?> findBeanDeserializer(JavaType type,\n                 DeserializationConfig config, BeanDescription beanDesc)\n             throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n     /**********************************************************\n      */\n     \n-    @Override\n+//  @Override\n     public final String getName() { return _propName; }\n \n-    @Override\n+//  @Override\n     public JavaType getType() { return _type; }\n \n-    @Override\n     public abstract <A extends Annotation> A getAnnotation(Class<A> acls);\n \n-    @Override\n+//  @Override\n     public abstract AnnotatedMember getMember();\n \n-    @Override\n     public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n         return _contextAnnotations.get(acls);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiators.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiators.java\n      */\n     public static class Base implements ValueInstantiators\n     {\n-        @Override\n+//      @Override\n         public ValueInstantiator findValueInstantiator(DeserializationConfig config,\n                 BeanDescription beanDesc, ValueInstantiator defaultInstantiator) {\n             return defaultInstantiator;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n     /**\n      * Accessor for traversing over all contained properties.\n      */\n-    @Override\n+//    @Override\n     public Iterator<SettableBeanProperty> iterator() {\n         return new IteratorImpl(_buckets);\n     }\n             _nextBucketIndex = i;\n         }\n \n-        @Override\n+//        @Override\n         public boolean hasNext() {\n             return _currentBucket != null;\n         }\n \n-        @Override\n+//        @Override\n         public SettableBeanProperty next()\n         {\n             Bucket curr = _currentBucket;\n             return curr.value;\n         }\n \n-        @Override\n+//       @Override\n         public void remove() {\n             throw new UnsupportedOperationException();\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n             HashMap<String,Integer> names = new HashMap<String,Integer>();\n             for (int i = 0, len = properties.length; i < len; ++i) {\n                 String name = properties[i].getName();\n+                /* [Issue-13]: Need to consider Injectables, which may not have\n+                 *   a name at all, and need to be skipped\n+                 */\n+                if (name.length() == 0 && properties[i].getInjectableValueId() != null) {\n+                    continue;\n+                }\n                 Integer old = names.put(name, Integer.valueOf(i));\n                 if (old != null) {\n                     throw new IllegalArgumentException(\"Duplicate creator property \\\"\"+name+\"\\\" (index \"+old+\" vs \"+i+\")\");\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n         return new ExternalTypeHandler(this);\n     }\n \n+    /**\n+     * Method called to see if given property/value pair is an external type\n+     * id; and if so handle it. This is <b>only</b> to be called in case\n+     * containing POJO has similarly named property as the external type id;\n+     * otherwise {@link #handlePropertyValue} should be called instead.\n+     */\n+    public boolean handleTypePropertyValue(JsonParser jp, DeserializationContext ctxt,\n+            String propName, Object bean)\n+        throws IOException, JsonProcessingException\n+    {\n+        Integer I = _nameToPropertyIndex.get(propName);\n+        if (I == null) {\n+            return false;\n+        }\n+        int index = I.intValue();\n+        ExtTypedProperty prop = _properties[index];\n+        if (!prop.hasTypePropertyName(propName)) {\n+            return false;\n+        }\n+        _typeIds[index] = jp.getText();\n+        // note: can NOT skip child values (should always be String anyway)\n+        boolean canDeserialize = (bean != null) && (_tokens[index] != null);\n+        // Minor optimization: deserialize properties as soon as we have all we need:\n+        if (canDeserialize) {\n+            _deserializeAndSet(jp, ctxt, bean, index);\n+            // clear stored data, to avoid deserializing+setting twice:\n+            _typeIds[index] = null;\n+            _tokens[index] = null;\n+        }\n+        return true;\n+    }\n+    \n     /**\n      * Method called to ask handler to handle value of given property,\n      * at point where parser points to the first token of the value.\n     public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean)\n         throws IOException, JsonProcessingException\n     {\n-\n         for (int i = 0, len = _properties.length; i < len; ++i) {\n             if (_typeIds[i] == null) {\n                 // let's allow missing both type and property (may already have been set, too)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyBasedCreator.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyBasedCreator.java\n     protected final HashMap<String, SettableBeanProperty> _properties;\n \n     /**\n+     * Number of properties: usually same as size of {@link #_properties},\n+     * but not necessarily, when we have unnamed injectable properties.\n+     */\n+    protected final int _propertyCount;\n+    \n+    /**\n      * If some property values must always have a non-null value (like\n      * primitive types do), this array contains such default values.\n      */\n         _valueInstantiator = valueInstantiator;\n         _properties = new HashMap<String, SettableBeanProperty>();\n         SettableBeanProperty[] propertiesWithInjectables = null;\n-        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n+        final int len = creatorProps.length;\n+        _propertyCount = len;\n+        for (int i = 0; i < len; ++i) {\n             SettableBeanProperty prop = creatorProps[i];\n             _properties.put(prop.getName(), prop);\n             Object injectableValueId = prop.getInjectableValueId();\n             }\n         }\n         _defaultValues = defaultValues;\n-        _propertiesWithInjectables = propertiesWithInjectables;        \n+        _propertiesWithInjectables = propertiesWithInjectables;\n     }\n \n     /**\n      */\n     public PropertyValueBuffer startBuilding(JsonParser jp, DeserializationContext ctxt)\n     {\n-        PropertyValueBuffer buffer = new PropertyValueBuffer(jp, ctxt, _properties.size());\n+        PropertyValueBuffer buffer = new PropertyValueBuffer(jp, ctxt, _propertyCount);\n         if (_propertiesWithInjectables != null) {\n             buffer.inject(_propertiesWithInjectables);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n      * when it is known for which property deserializer is needed\n      * for.\n      */\n-    @Override\n+//    @Override\n     public CollectionDeserializer createContextual(DeserializationContext ctxt,\n             BeanProperty property) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializers.java\n \n         protected abstract DateBasedDeserializer<T> withDateFormat(DateFormat df, String formatStr);\n         \n-        @Override\n+//      @Override\n         public JsonDeserializer<?> createContextual(DeserializationContext ctxt, BeanProperty property)\n            throws JsonMappingException\n         {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n     public static JsonDeserializer<?> deserializerForCreator(DeserializationConfig config,\n             Class<?> enumClass, AnnotatedMethod factory)\n     {\n+        \n         // note: caller has verified there's just one arg; but we must verify its type\n-        if (factory.getGenericParameterType(0) != String.class) {\n-            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n+        Class<?> paramClass = factory.getRawParameterType(0);\n+        if (paramClass == String.class) {\n+            paramClass = null;\n+        } else  if (paramClass == Integer.TYPE || paramClass == Integer.class) {\n+            paramClass = Integer.class;\n+        } else  if (paramClass == Long.TYPE || paramClass == Long.class) {\n+            paramClass = Long.class;\n+        } else {\n+            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory\n+                    +\") not suitable, must be java.lang.String or int/Integer/long/Long\");\n         }\n         if (config.canOverrideAccessModifiers()) {\n             ClassUtil.checkAndFixAccess(factory.getMember());\n         }\n-        return new FactoryBasedDeserializer(enumClass, factory);\n+        return new FactoryBasedDeserializer(enumClass, factory, paramClass);\n     }\n     \n     /*\n         extends StdScalarDeserializer<Object>\n     {\n         protected final Class<?> _enumClass;\n+        // Marker type; null if String expected; otherwise numeric wrapper\n+        protected final Class<?> _inputType;\n         protected final Method _factory;\n         \n-        public FactoryBasedDeserializer(Class<?> cls, AnnotatedMethod f)\n+        public FactoryBasedDeserializer(Class<?> cls, AnnotatedMethod f,\n+                Class<?> inputType)\n         {\n             super(Enum.class);\n             _enumClass = cls;\n             _factory = f.getAnnotated();\n+            _inputType = inputType;\n         }\n \n         @Override\n         public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n             throws IOException, JsonProcessingException\n         {\n-            JsonToken curr = jp.getCurrentToken();\n-            \n-            // Usually should just get string value:\n-            if (curr != JsonToken.VALUE_STRING && curr != JsonToken.FIELD_NAME) {\n+            // couple of accepted types...\n+            Object value;\n+            if (_inputType == null) {\n+                value = jp.getText();\n+            } else  if (_inputType == Integer.class) {\n+                value = Integer.valueOf(jp.getValueAsInt());\n+            } else  if (_inputType == Long.class) {\n+                value = Long.valueOf(jp.getValueAsLong());\n+            } else {\n                 throw ctxt.mappingException(_enumClass);\n             }\n-            String value = jp.getText();\n             try {\n-                return _factory.invoke(null, value);\n+                return _factory.invoke(_enumClass, value);\n             } catch (Exception e) {\n                 ClassUtil.unwrapAndThrowAsIAE(e);\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n      * Method called to finalize setup of this deserializer,\n      * when it is known for which property deserializer is needed for.\n      */\n-    @Override\n+//  @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n             BeanProperty property) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n     @Override\n     public boolean isCachable() { return true; }\n     \n-    @Override\n+//    @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n             BeanProperty property) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n             return new AtomicReference<Object>(_valueDeserializer.deserialize(jp, ctxt));\n         }\n         \n-        @Override\n+//        @Override\n         public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n                 BeanProperty property) throws JsonMappingException\n         {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n     /**********************************************************\n      */\n \n-\n-    @Override\n+//    @Override\n     public void resolve(DeserializationContext ctxt) throws JsonMappingException\n     {\n         // May need to resolve types for delegate- and/or property-based creators:\n      * Method called to finalize setup of this deserializer,\n      * when it is known for which property deserializer is needed for.\n      */\n-    @Override\n+//    @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n             BeanProperty property) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n                 (JsonDeserializer<Object>) elemDeser, elemTypeDeser);\n     }\n \n-    @Override\n+//    @Override\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n             BeanProperty property) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n     protected final static double parseDouble(String numStr) throws NumberFormatException\n     {\n         // [JACKSON-486]: avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?\n+        // for now, MIN_VALUE, since MIN_NORMAL is JDK 1.6\n         if (NumberInput.NASTY_SMALL_DOUBLE.equals(numStr)) {\n-            return Double.MIN_NORMAL;\n+            return Double.MIN_VALUE;\n         }\n         return Double.parseDouble(numStr);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n     /**********************************************************\n      */\n \n-    @Override\n+//    @Override\n     @SuppressWarnings(\"unchecked\")\n     public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n             BeanProperty property) throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLDeserializers.java\n      * Method called by {@link com.fasterxml.jackson.databind.deser.BasicDeserializerFactory}\n      * to register deserializers this class provides.\n      */\n-    @Override\n+//    @Override\n     public Collection<StdDeserializer<?>> provide()\n     {\n         return Arrays.asList(new StdDeserializer<?>[] {\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n         _serializers.put(QName.class, tss);\n     }\n     \n-    @Override\n+//    @Override\n     public Collection<Map.Entry<Class<?>,JsonSerializer<?>>> provide() {\n         return _serializers.entrySet();\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n \n         // and then augment these with annotations from super-types:\n         for (Class<?> cls : _superTypes) {\n-            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);\n+            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);         \n             _addMemberMethods(cls, _memberMethods, mixin, mixins);\n         }\n         // Special case: mix-ins for Object.class? (to apply to ALL classes)\n         if (_mixInResolver != null) {\n             Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class);\n             if (mixin != null) {\n-                _addMethodMixIns(_memberMethods, mixin, mixins);\n+                _addMethodMixIns(_class, _memberMethods, mixin, mixins);\n             }\n         }\n \n         _addAnnotationsIfNotPresent(annotations, mixin.getDeclaredAnnotations());\n \n         /* And then from its supertypes, if any. But note that we will\n-         *  only consider super-types up until reaching the masked\n+         * only consider super-types up until reaching the masked\n          * class (if found); this because often mix-in class\n          * is a sub-class (for convenience reasons). And if so, we\n          * absolutely must NOT include super types of masked class,\n     {\n         // first, mixIns, since they have higher priority then class methods\n         if (mixInCls != null) {\n-            _addMethodMixIns(methods, mixInCls, mixIns);\n+            _addMethodMixIns(cls, methods, mixInCls, mixIns);\n         }        \n         if (cls == null) { // just so caller need not check when passing super-class\n             return;\n         }\n     }\n \n-    protected void _addMethodMixIns(AnnotatedMethodMap methods,\n+    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n             Class<?> mixInCls, AnnotatedMethodMap mixIns)\n     {\n-        for (Method m : mixInCls.getDeclaredMethods()) {\n-            if (!_isIncludableMemberMethod(m)) {\n-                continue;\n-            }\n-            AnnotatedMethod am = methods.find(m);\n-            /* Do we already have a method to augment (from sub-class\n-             * that will mask this mixIn)? If so, add if visible\n-             * without masking (no such annotation)\n-             */\n-            if (am != null) {\n-                _addMixUnders(m, am);\n-                /* Otherwise will have precedence, but must wait\n-                 * until we find the real method (mixIn methods are\n-                 * just placeholder, can't be called)\n+        List<Class<?>> parents = new ArrayList<Class<?>>();\n+        parents.add(mixInCls);\n+        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n+        for (Class<?> mixin : parents) {\n+            for (Method m : mixin.getDeclaredMethods()) {\n+                if (!_isIncludableMemberMethod(m)) {\n+                    continue;\n+                }\n+                AnnotatedMethod am = methods.find(m);\n+                /* Do we already have a method to augment (from sub-class\n+                 * that will mask this mixIn)? If so, add if visible\n+                 * without masking (no such annotation)\n                  */\n-            } else {\n-                mixIns.add(_constructMethod(m));\n+                if (am != null) {\n+                    _addMixUnders(m, am);\n+                    /* Otherwise will have precedence, but must wait\n+                     * until we find the real method (mixIn methods are\n+                     * just placeholder, can't be called)\n+                     */\n+                } else {\n+                    mixIns.add(_constructMethod(m));\n+                }\n             }\n         }\n     }\n             if (_mixInResolver != null) {\n                 Class<?> mixin = _mixInResolver.findMixInClassFor(c);\n                 if (mixin != null) {\n-                    _addFieldMixIns(mixin, fields);\n+                    _addFieldMixIns(parent, mixin, fields);\n                 }\n             }\n         }\n      * into already collected actual fields (from introspected classes and their\n      * super-classes)\n      */\n-    protected void _addFieldMixIns(Class<?> mixin, Map<String,AnnotatedField> fields)\n-    {\n-        for (Field mixinField : mixin.getDeclaredFields()) {\n-            /* there are some dummy things (static, synthetic); better\n-             * ignore\n-             */\n-            if (!_isIncludableField(mixinField)) {\n-                continue;\n-            }\n-            String name = mixinField.getName();\n-            // anything to mask? (if not, quietly ignore)\n-            AnnotatedField maskedField = fields.get(name);\n-            if (maskedField != null) {\n-                _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations());\n+    protected void _addFieldMixIns(Class<?> targetClass, Class<?> mixInCls,\n+            Map<String,AnnotatedField> fields)\n+    {\n+        List<Class<?>> parents = new ArrayList<Class<?>>();\n+        parents.add(mixInCls);\n+        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n+        for (Class<?> mixin : parents) {\n+            for (Field mixinField : mixin.getDeclaredFields()) {\n+                // there are some dummy things (static, synthetic); better ignore\n+                if (!_isIncludableField(mixinField)) {\n+                    continue;\n+                }\n+                String name = mixinField.getName();\n+                // anything to mask? (if not, quietly ignore)\n+                AnnotatedField maskedField = fields.get(name);\n+                if (maskedField != null) {\n+                    _addOrOverrideAnnotations(maskedField, mixinField.getDeclaredAnnotations());\n+                }\n             }\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethodMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethodMap.java\n     /**********************************************************\n      */\n \n-    @Override\n+//  @Override\n     public Iterator<AnnotatedMethod> iterator()\n     {\n         if (_methods != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n     }\n \n     @SuppressWarnings(\"unchecked\")\n-    @Override\n+//  @Override\n     public <A extends Annotation> A get(Class<A> cls)\n     {\n         if (_annotations == null) {\n         return new AnnotationMap(annotations);\n     }\n     \n-    @Override\n+//  @Override\n     public int size() {\n         return (_annotations == null) ? 0 : _annotations.size();\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BeanPropertyDefinition.java\n     /**\n      * Accessor for name used for external representation (in JSON).\n      */\n-    @Override // from Named\n+//  @Override // from Named\n     public abstract String getName();\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n     /**********************************************************\n      */\n \n-    @Override\n+//    @Override\n     public int compareTo(POJOPropertyBuilder other)\n     {\n         // first, if one has ctor params, that should come first:\n     @Override\n     public Class<?>[] findViews() {\n         return fromMemberAnnotation(new WithMember<Class<?>[]>() {\n-            @Override public Class<?>[] withMember(AnnotatedMember member) {\n+            public Class<?>[] withMember(AnnotatedMember member) {\n                 return _annotationIntrospector.findViews(member);\n             }\n         });\n     @Override\n     public AnnotationIntrospector.ReferenceProperty findReferenceType() {\n         return fromMemberAnnotation(new WithMember<AnnotationIntrospector.ReferenceProperty>() {\n-            @Override public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member) {\n+            public AnnotationIntrospector.ReferenceProperty withMember(AnnotatedMember member) {\n                 return _annotationIntrospector.findReferenceType(member);\n             }\n         });\n     @Override\n     public boolean isTypeId() {\n         Boolean b = fromMemberAnnotation(new WithMember<Boolean>() {\n-            @Override public Boolean withMember(AnnotatedMember member) {\n+            public Boolean withMember(AnnotatedMember member) {\n                 return _annotationIntrospector.isTypeId(member);\n             }\n         });\n     @Override\n     public boolean isRequired() {\n         Boolean b = fromMemberAnnotation(new WithMember<Boolean>() {\n-            @Override public Boolean withMember(AnnotatedMember member) {\n+            public Boolean withMember(AnnotatedMember member) {\n                 return _annotationIntrospector.hasRequiredMarker(member);\n             }\n         });\n     @Override\n     public ObjectIdInfo findObjectIdInfo() {\n         return fromMemberAnnotation(new WithMember<ObjectIdInfo>() {\n-            @Override public ObjectIdInfo withMember(AnnotatedMember member) {\n+            public ObjectIdInfo withMember(AnnotatedMember member) {\n                 return _annotationIntrospector.findObjectIdInfo(member);\n             }\n         });\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n \t/********************************************************\n \t */\n \n-        @Override\n+//      @Override\n \tpublic Std with(JsonAutoDetect ann)\n \t{\n             Std curr = this;\n \t    return curr;\n \t}\n \n-        @Override\n+//      @Override\n \tpublic Std with(Visibility v)\n \t{\n \t    if (v == Visibility.DEFAULT) {\n \t    return new Std(v);\n \t}\n \n-        @Override\n+//      @Override\n \tpublic Std withVisibility(PropertyAccessor method, Visibility v)\n \t{\n \t    switch (method) {\n             return this;\n \t}\n \t\n-        @Override\n+//      @Override\n \tpublic Std withGetterVisibility(Visibility v) {\n \t    if (v == Visibility.DEFAULT)  v = DEFAULT._getterMinLevel;\n             if (_getterMinLevel == v) return this;\n \t    return new Std(v, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, _fieldMinLevel);\n \t}\n \n-        @Override\n+//      @Override\n         public Std withIsGetterVisibility(Visibility v) {\n             if (v == Visibility.DEFAULT)  v = DEFAULT._isGetterMinLevel;\n             if (_isGetterMinLevel == v) return this;\n             return new Std(_getterMinLevel, v, _setterMinLevel, _creatorMinLevel, _fieldMinLevel);\n         }\n \t\t\n-        @Override\n+//      @Override\n \tpublic Std withSetterVisibility(Visibility v) {\n             if (v == Visibility.DEFAULT)  v = DEFAULT._setterMinLevel;\n             if (_setterMinLevel == v) return this;\n             return new Std(_getterMinLevel, _isGetterMinLevel, v, _creatorMinLevel, _fieldMinLevel);\n \t}\n \n-\t@Override\n+//      @Override\n \tpublic Std withCreatorVisibility(Visibility v) {\n             if (v == Visibility.DEFAULT)  v = DEFAULT._creatorMinLevel;\n             if (_creatorMinLevel == v) return this;\n \t    return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, v, _fieldMinLevel);\n \t}\n \n-        @Override\n+//      @Override\n \tpublic Std withFieldVisibility(Visibility v) {\n             if (v == Visibility.DEFAULT)  v = DEFAULT._fieldMinLevel;\n             if (_fieldMinLevel == v) return this;\n         /********************************************************\n          */\n \n-\t@Override\n+//\t@Override\n \tpublic boolean isCreatorVisible(Member m) {\n \t    return _creatorMinLevel.isVisible(m);\n     \t}\n     \n-        @Override\n+//      @Override\n     \tpublic boolean isCreatorVisible(AnnotatedMember m) {\n     \t    return isCreatorVisible(m.getMember());\n     \t}\n     \n-        @Override\n+//      @Override\n     \tpublic boolean isFieldVisible(Field f) {\n     \t    return _fieldMinLevel.isVisible(f);\n     \t}\n     \n-        @Override\n+//      @Override\n     \tpublic boolean isFieldVisible(AnnotatedField f) {\n     \t    return isFieldVisible(f.getAnnotated());\n     \t}\n     \n-        @Override\n+//      @Override\n     \tpublic boolean isGetterVisible(Method m) {\n     \t    return _getterMinLevel.isVisible(m);\n     \t}    \n \n-        @Override\n+//      @Override\n         public boolean isGetterVisible(AnnotatedMethod m) {\n     \t    return isGetterVisible(m.getAnnotated());\n     \t}\n \n-        @Override\n+//      @Override\n         public boolean isIsGetterVisible(Method m) {\n             return _isGetterMinLevel.isVisible(m);\n         }    \n \n-        @Override\n+//      @Override\n         public boolean isIsGetterVisible(AnnotatedMethod m) {\n             return isIsGetterVisible(m.getAnnotated());\n         }\n \n-        @Override\n+//      @Override\n         public boolean isSetterVisible(Method m) {\n             return _setterMinLevel.isVisible(m);\n         }\n     \n-        @Override\n+//      @Override\n         public boolean isSetterVisible(AnnotatedMethod m) {\n             return isSetterVisible(m.getAnnotated());\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n         super(baseType, typeFactory);\n     }\n \n-    @Override\n+//  @Override\n     public JsonTypeInfo.Id getMechanism() { return JsonTypeInfo.Id.CLASS; }\n \n     public void registerSubtype(Class<?> type, String name) {\n         // not used with class name - based resolvers\n     }\n     \n-    @Override\n-    public String idFromValue(Object value)\n-    {\n+//  @Override\n+    public String idFromValue(Object value) {\n         return _idFrom(value, value.getClass());\n     }\n \n-    @Override\n-    public String idFromValueAndType(Object value, Class<?> type)\n-    {\n+//  @Override\n+    public String idFromValueAndType(Object value, Class<?> type) {\n         return _idFrom(value, type);\n     }\n \n-    @Override\n+//  @Override\n     public JavaType typeFromId(String id)\n     {\n         /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n         return new StdTypeResolverBuilder().init(JsonTypeInfo.Id.NONE, null);\n     }\n     \n-    @Override\n+//  @Override\n     public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes)\n     {\n         // sanity checks\n         return this;\n     }\n     \n-    @Override\n+//  @Override\n     public TypeSerializer buildTypeSerializer(SerializationConfig config,\n             JavaType baseType, Collection<NamedType> subtypes)\n     {\n         throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n     }\n     \n-    @Override\n+//  @Override\n     public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n             JavaType baseType, Collection<NamedType> subtypes)\n     {\n     /**********************************************************\n      */\n \n-    @Override\n+//  @Override\n     public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs) {\n         if (includeAs == null) {\n             throw new IllegalArgumentException(\"includeAs can not be null\");\n      * Method for constructing an instance with specified type property name\n      * (property name to use for type id when using \"as-property\" inclusion).\n      */\n-    @Override\n+//  @Override\n     public StdTypeResolverBuilder typeProperty(String typeIdPropName)\n     {\n         // ok to have null/empty; will restore to use defaults\n         return this;\n     }\n \n-    @Override\n+//  @Override\n     public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl)\n     {\n         _defaultImpl = defaultImpl;\n         return this;\n     }\n \n-    @Override\n+//  @Override\n     public StdTypeResolverBuilder typeIdVisibility(boolean isVisible) {\n         _typeIdVisible = isVisible;\n         return this;\n \n     public String getTypeProperty() { return _typeProperty; }\n \n-    @Override\n+//  @Override\n     public Class<?> getDefaultImpl() {\n         return _defaultImpl;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n         _typeFactory = typeFactory;\n     }\n \n-    @Override\n+//  @Override\n     public void init(JavaType bt) {\n         // Standard type id resolvers do not need this: only useful for custom ones.\n     }\n \n-    @Override\n+//  @Override\n     public String idFromBaseType()\n     {\n         /* By default we will just defer to regular handling, handing out the\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n         return new TypeNameIdResolver(config, baseType, typeToId, idToType);\n     }\n \n-    @Override\n+//  @Override\n     public JsonTypeInfo.Id getMechanism() { return JsonTypeInfo.Id.NAME; }\n \n-    @Override\n+//  @Override\n     public String idFromValue(Object value)\n     {\n         Class<?> cls = value.getClass();\n         return name;\n     }\n \n-    @Override\n+//  @Override\n     public String idFromValueAndType(Object value, Class<?> type)\n     {\n         return idFromValue(value);\n     }\n     \n-    @Override\n+//  @Override\n     public JavaType typeFromId(String id)\n         throws IllegalArgumentException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java\n     /**********************************************************\n      */\n     \n-    @Override\n+//  @Override\n     public JsonDeserializer<?> findArrayDeserializer(ArrayType type,\n             DeserializationConfig config, BeanDescription beanDesc,\n             TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n         return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass()));\n     }\n \n-    @Override\n+//  @Override\n     public JsonDeserializer<?> findBeanDeserializer(JavaType type,\n             DeserializationConfig config, BeanDescription beanDesc)\n         throws JsonMappingException\n         return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass()));\n     }\n \n-    @Override\n+//  @Override\n     public JsonDeserializer<?> findCollectionDeserializer(CollectionType type,\n             DeserializationConfig config, BeanDescription beanDesc,\n             TypeDeserializer elementTypeDeserializer,\n         return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass()));\n     }\n \n-    @Override\n+//  @Override\n     public JsonDeserializer<?> findCollectionLikeDeserializer(CollectionLikeType type,\n             DeserializationConfig config, BeanDescription beanDesc,\n             TypeDeserializer elementTypeDeserializer,\n         return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass()));\n     }\n     \n-    @Override\n+//  @Override\n     public JsonDeserializer<?> findEnumDeserializer(Class<?> type,\n             DeserializationConfig config, BeanDescription beanDesc)\n         throws JsonMappingException\n         return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type));\n     }\n \n-    @Override\n+//  @Override\n     public JsonDeserializer<?> findMapDeserializer(MapType type,\n             DeserializationConfig config, BeanDescription beanDesc,\n             KeyDeserializer keyDeserializer,\n         return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass()));\n     }\n \n-    @Override\n+//  @Override\n     public JsonDeserializer<?> findMapLikeDeserializer(MapLikeType type,\n             DeserializationConfig config, BeanDescription beanDesc,\n             KeyDeserializer keyDeserializer,\n         return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass()));\n     }\n     \n-    @Override\n+//  @Override\n     public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType,\n             DeserializationConfig config, BeanDescription beanDesc)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n     /**********************************************************\n      */\n \n-    @Override\n+//  @Override\n     public KeyDeserializer findKeyDeserializer(JavaType type,\n             DeserializationConfig config, BeanDescription beanDesc)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java\n         if (cls == null || cls == Object.class) {\n             throw new IllegalArgumentException(\"JsonSerializer of type \"+ser.getClass().getName()\n                     +\" does not define valid handledType() -- must either register with method that takes type argument \"\n-                    +\" or make serializer extend 'com.fasterxml.jackson.databind.ser.std.SerializerBase'\"); \n+                    +\" or make serializer extend 'com.fasterxml.jackson.databind.ser.std.StdSerializer'\"); \n         }\n         _addSerializer(cls, ser);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/BaseJsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BaseJsonNode.java\n     /**\n      * Method called to serialize node instances using given generator.\n      */\n-    @Override\n+//  @Override\n     public abstract void serialize(JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonProcessingException;\n \n      * Type information is needed, even if JsonNode instances are \"plain\" JSON,\n      * since they may be mixed with other types.\n      */\n-    @Override\n+//  @Override\n     public abstract void serializeWithType(JsonGenerator jgen, SerializerProvider provider,\n             TypeSerializer typeSer)\n         throws IOException, JsonProcessingException;\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ContainerNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ContainerNode.java\n \n         public static NoNodesIterator instance() { return instance; }\n \n-        @Override\n+//      @Override\n         public boolean hasNext() { return false; }\n-        @Override\n+//      @Override\n         public JsonNode next() { throw new NoSuchElementException(); }\n \n-        @Override\n+//      @Override\n         public void remove() {\n             // could as well throw IllegalOperationException?\n             throw new IllegalStateException();\n \n         public static NoStringsIterator instance() { return instance; }\n \n-        @Override\n+//      @Override\n         public boolean hasNext() { return false; }\n-        @Override\n+//      @Override\n         public String next() { throw new NoSuchElementException(); }\n \n-        @Override\n+//      @Override\n         public void remove() {\n             // could as well throw IllegalOperationException?\n             throw new IllegalStateException();\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n \n         private NoFieldsIterator() { }\n \n-        @Override\n+//      @Override\n         public boolean hasNext() { return false; }\n-        @Override\n+//      @Override\n         public Map.Entry<String,JsonNode> next() { throw new NoSuchElementException(); }\n \n-        @Override\n+//      @Override\n         public void remove() { // or IllegalOperationException?\n             throw new IllegalStateException();\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n         Class<?> elementRaw = type.getContentType().getRawClass();\n         if (isIndexedList(raw)) {\n             if (elementRaw == String.class) {\n-                return IndexedStringListSerializer.instance;\n+                // [JACKSON-829] Must NOT use if we have custom serializer\n+                if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n+                    return IndexedStringListSerializer.instance;\n+                }\n             }\n             return StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping,\n                     elementTypeSerializer, property, elementValueSerializer);\n         }\n         if (elementRaw == String.class) {\n-            return StringCollectionSerializer.instance;\n+            // [JACKSON-829] Must NOT use if we have custom serializer\n+            if (elementValueSerializer == null || ClassUtil.isJacksonStdImpl(elementValueSerializer)) {\n+                return StringCollectionSerializer.instance;\n+            }\n         }\n         return StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping,\n                 elementTypeSerializer, property, elementValueSerializer);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n     /**********************************************************\n      */\n     \n-    @Override\n+//    @Override\n     public String getName() {\n         return _name.getValue();\n     }\n \n-    @Override\n+//    @Override\n     public JavaType getType() {\n         return _declaredType;\n     }\n \n-    @Override\n+//  @Override\n     public <A extends Annotation> A getAnnotation(Class<A> acls) {\n         return _member.getAnnotation(acls);\n     }\n \n-    @Override\n+//  @Override\n     public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n         return _contextAnnotations.get(acls);\n     }\n-    \n-    @Override\n+\n+//    @Override\n     public AnnotatedMember getMember() {\n         return _member;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n         \n         // Next: we may have annotations that further define types to use...\n         JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n-        if (type == origType) { // no changes, won't force static typin\n+        if (type == origType) { // no changes, won't force static typing\n             staticTyping = false;\n         } else { // changes; assume static typing; plus, need to re-introspect if class differs\n             staticTyping = true;\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java\n      */\n     public static class Base implements Serializers\n     {\n-        @Override\n+//      @Override\n         public JsonSerializer<?> findSerializer(SerializationConfig config,\n                 JavaType type, BeanDescription beanDesc)\n         {\n             return null;\n         }\n         \n-        @Override\n+//      @Override\n         public JsonSerializer<?> findArraySerializer(SerializationConfig config,\n                 ArrayType type, BeanDescription beanDesc,\n                 TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n             return null;\n         }\n \n-        @Override\n+//      @Override\n         public JsonSerializer<?> findCollectionSerializer(SerializationConfig config,\n                 CollectionType type, BeanDescription beanDesc,\n                 TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n             return null;\n         }\n \n-        @Override\n+//      @Override\n         public JsonSerializer<?> findCollectionLikeSerializer(SerializationConfig config,\n                 CollectionLikeType type, BeanDescription beanDesc,\n                 TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n             return null;\n         }\n             \n-        @Override\n+//      @Override\n         public JsonSerializer<?> findMapSerializer(SerializationConfig config,\n                 MapType type, BeanDescription beanDesc,\n                 JsonSerializer<Object> keySerializer,\n             return null;\n         }\n \n-        @Override\n+//      @Override\n         public JsonSerializer<?> findMapLikeSerializer(SerializationConfig config,\n                 MapLikeType type, BeanDescription beanDesc,\n                 JsonSerializer<Object> keySerializer,\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/IndexedStringListSerializer.java\n     /**********************************************************\n      */\n     \n-    @Override\n+//  @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n             _propertiesToInclude = properties;\n         }\n         \n-        @Override\n+//      @Override\n         public void serializeAsField(Object bean, JsonGenerator jgen,\n                 SerializerProvider provider, BeanPropertyWriter writer)\n             throws Exception\n             _propertiesToExclude = properties;\n         }\n         \n-        @Override\n+//      @Override\n         public void serializeAsField(Object bean, JsonGenerator jgen,\n                 SerializerProvider provider, BeanPropertyWriter writer)\n             throws Exception\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringArraySerializer.java\n     /**********************************************************\n      */\n     \n-    @Override\n+//  @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/StringCollectionSerializer.java\n     /**********************************************************\n      */\n     \n-    @Override\n+//  @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n     /**********************************************************\n      */\n     \n-    @Override\n+//  @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n      * We need to implement {@link ResolvableSerializer} to be able to\n      * properly handle cyclic type references.\n      */\n-    @Override\n+//  @Override\n     public void resolve(SerializerProvider provider)\n         throws JsonMappingException\n     {\n         }\n     }\n \n-    @Override\n+//  @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\n \n     public abstract DateTimeSerializerBase<T> withFormat(boolean timestamp, DateFormat customFormat);\n \n-    @Override\n+//  @Override\n     public JsonSerializer<?> createContextual(SerializerProvider prov,\n             BeanProperty property) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n         return new EnumMapSerializer(this, prop, ser);\n     }\n     \n-    @Override\n+//  @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n     @Override\n     public boolean isEmpty(Iterable<?> value) {\n         // Not really good way to implement this, but has to do for now:\n-        return (value == null) || value.iterator().hasNext();\n+        return (value == null) || !value.iterator().hasNext();\n     }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n      * We can try to find the actual serializer for value, if we can\n      * statically figure out what the result type must be.\n      */\n-    @Override\n+//  @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n     /**********************************************************\n      */\n \n-    @Override\n+//  @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n     /**********************************************************\n      */\n \n-    @Override\n+//  @Override\n     public JsonSerializer<?> createContextual(SerializerProvider provider,\n             BeanProperty property)\n         throws JsonMappingException\n             vts = vts.forProperty(property);\n         }\n         JsonSerializer<?> ser = _elementSerializer;\n+\n         if (ser == null) {\n             if (_staticTyping) {\n                 ser = provider.findValueSerializer(_elementType, property);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n      * Method called by {@link BasicSerializerFactory} to access\n      * all serializers this class provides.\n      */\n-    @Override\n+//  @Override\n     public Collection<Map.Entry<Class<?>, Object>> provide()\n     {\n         HashMap<Class<?>,Object> sers = new HashMap<Class<?>,Object>();\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdSerializer.java\n      * Default implementation simply claims type is \"string\"; usually\n      * overriden by custom serializers.\n      */\n-    @Override\n+//  @Override\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n         throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n         return new ArrayType(_componentType, _emptyArray, _valueHandler, h);\n     }\n \n-    // Since 1.7:\n     @Override\n     public ArrayType withContentTypeHandler(Object h)\n     {\n-        if (h == _componentType.getTypeHandler()) {\n+        if (h == _componentType.<Object>getTypeHandler()) {\n             return this;\n         }\n         return new ArrayType(_componentType.withTypeHandler(h), _emptyArray,\n                 _valueHandler, _typeHandler);\n     }\n \n-    // Since 1.9:\n     @Override\n     public ArrayType withValueHandler(Object h) {\n         if (h == _valueHandler) {\n         return new ArrayType(_componentType, _emptyArray, h, _typeHandler);\n     }\n \n-    // Since 1.9:\n     @Override\n     public ArrayType withContentValueHandler(Object h) {\n-        if (h == _componentType.getValueHandler()) {\n+        if (h == _componentType.<Object>getValueHandler()) {\n             return this;\n         }\n         return new ArrayType(_componentType.withValueHandler(h), _emptyArray,\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ClassKey.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ClassKey.java\n     /**********************************************************\n      */\n \n-    @Override\n+//  @Override\n     public int compareTo(ClassKey other)\n     {\n         // Just need to sort by name, ok to collide (unless used in TreeMap/Set!)\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java\n     /**********************************************************\n      */\n \n-    @Override\n+//  @Override\n     public void serializeWithType(JsonGenerator jgen, SerializerProvider provider,\n             TypeSerializer typeSer)\n         throws IOException, JsonProcessingException\n         typeSer.writeTypeSuffixForScalar(this, jgen);\n     }\n \n-    @Override\n+//  @Override\n     public void serialize(JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonProcessingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java\n             _index = 0;\n         }\n         \n-        @Override public boolean hasNext() {\n+//      @Override\n+        public boolean hasNext() {\n             return _index < _array.length;\n         }\n \n-        @Override\n+//      @Override\n         public T next()\n         {\n             if (_index >= _array.length) {\n             return _array[_index++];\n         }\n \n-        @Override public void remove() {\n+//      @Override\n+        public void remove() {\n             throw new UnsupportedOperationException();\n         }\n \n-        @Override\n+//      @Override\n         public Iterator<T> iterator() {\n             return this;\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n     {\n         return findSuperTypes(cls, endBefore, new ArrayList<Class<?>>(8));\n     }\n-\n+    \n     public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result)\n     {\n         _addSuperTypes(cls, endBefore, result, false);\n      * Code is needed to work around design flaw in JDK.\n      */\n     public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s)\n-\t{\n+    {\n     \t// First things first: if not empty, easy to determine\n     \tif (!s.isEmpty()) {\n     \t\treturn findEnumType(s.iterator().next());\n     @SuppressWarnings(\"unchecked\")\n \tpublic static Class<? extends Enum<?>> findEnumType(Enum<?> en)\n     {\n-\t\t// enums with \"body\" are sub-classes of the formal type\n+        // enums with \"body\" are sub-classes of the formal type\n     \tClass<?> ec = en.getClass();\n-\t\tif (ec.getSuperclass() != Enum.class) {\n-\t\t\tec = ec.getSuperclass();\n-\t\t}\n-\t\treturn (Class<? extends Enum<?>>) ec;\n+    \tif (ec.getSuperclass() != Enum.class) {\n+    \t    ec = ec.getSuperclass();\n+    \t}\n+    \treturn (Class<? extends Enum<?>>) ec;\n     }\n \n     /**\n     @SuppressWarnings(\"unchecked\")\n     public static Class<? extends Enum<?>> findEnumType(Class<?> cls)\n     {\n-\t\t// enums with \"body\" are sub-classes of the formal type\n-\t\tif (cls.getSuperclass() != Enum.class) {\n-\t\t\tcls = cls.getSuperclass();\n-\t\t}\n-\t\treturn (Class<? extends Enum<?>>) cls;\n+        // enums with \"body\" are sub-classes of the formal type\n+        if (cls.getSuperclass() != Enum.class) {\n+            cls = cls.getSuperclass();\n+        }\n+        return (Class<? extends Enum<?>>) cls;\n     }\n \n     /*\n     \tprivate final Field enumMapTypeField;\n     \t\n     \tprivate EnumTypeLocator() {\n-\t\t\t/* JDK uses following fields to store information about actual Enumeration\n-\t\t\t * type for EnumSets, EnumMaps...\n-\t\t\t */\n-\t\t\tenumSetTypeField = locateField(EnumSet.class, \"elementType\", Class.class);\n-\t\t\tenumMapTypeField = locateField(EnumMap.class, \"elementType\", Class.class);\n+    \t    /* JDK uses following fields to store information about actual Enumeration\n+    \t     * type for EnumSets, EnumMaps...\n+    \t     */\n+    \t    enumSetTypeField = locateField(EnumSet.class, \"elementType\", Class.class);\n+    \t    enumMapTypeField = locateField(EnumMap.class, \"elementType\", Class.class);\n     \t}\n \n     \t@SuppressWarnings(\"unchecked\")\n     \tpublic Class<? extends Enum<?>> enumTypeFor(EnumSet<?> set)\n     \t{\n-    \t\tif (enumSetTypeField != null) {\n-    \t\t\treturn (Class<? extends Enum<?>>) get(set, enumSetTypeField);\n-    \t\t}\n-    \t\tthrow new IllegalStateException(\"Can not figure out type for EnumSet (odd JDK platform?)\");\n-\t\t}\n+    \t    if (enumSetTypeField != null) {\n+    \t        return (Class<? extends Enum<?>>) get(set, enumSetTypeField);\n+    \t    }\n+    \t    throw new IllegalStateException(\"Can not figure out type for EnumSet (odd JDK platform?)\");\n+    \t}\n \n     \t@SuppressWarnings(\"unchecked\")\n     \tpublic Class<? extends Enum<?>> enumTypeFor(EnumMap<?,?> set)\n-\t\t        {\n-    \t\tif (enumMapTypeField != null) {\n-    \t\t\treturn (Class<? extends Enum<?>>) get(set, enumMapTypeField);\n-    \t\t}\n-    \t\tthrow new IllegalStateException(\"Can not figure out type for EnumMap (odd JDK platform?)\");\n-\t\t        \n+        {\n+    \t    if (enumMapTypeField != null) {\n+    \t        return (Class<? extends Enum<?>>) get(set, enumMapTypeField);\n+    \t    }\n+    \t    throw new IllegalStateException(\"Can not figure out type for EnumMap (odd JDK platform?)\");\n         }\n     \t\n     \tprivate Object get(Object bean, Field field)\n     \t{\n-    \t\ttry {\n-    \t\t\treturn field.get(bean);\n-    \t\t} catch (Exception e) {\n-    \t\t\tthrow new IllegalArgumentException(e);\n-    \t\t}\n+    \t    try {\n+    \t        return field.get(bean);\n+    \t    } catch (Exception e) {\n+    \t        throw new IllegalArgumentException(e);\n+    \t    }\n     \t}\n     \t\n     \tprivate static Field locateField(Class<?> fromClass, String expectedName, Class<?> type)\n     \t{\n-    \t\tField found = null;\n-    \t\t// First: let's see if we can find exact match:\n-    \t\tField[] fields = fromClass.getDeclaredFields();\n-    \t\tfor (Field f : fields) {\n-    \t\t\tif (expectedName.equals(f.getName()) && f.getType() == type) {\n-    \t\t\t\tfound = f;\n-    \t\t\t\tbreak;\n-    \t\t\t}\n-    \t\t}\n-    \t\t// And if not, if there is just one field with the type, that field\n-    \t\tif (found == null) {\n-\t    \t\tfor (Field f : fields) {\n-\t    \t\t\tif (f.getType() == type) {\n-\t    \t\t\t\t// If more than one, can't choose\n-\t    \t\t\t\tif (found != null) return null;\n-\t    \t\t\t\tfound = f;\n-\t    \t\t\t}\n-\t    \t\t}\n-    \t\t}\n-    \t\tif (found != null) { // it's non-public, need to force accessible\n-    \t\t\ttry {\n-    \t\t\t\tfound.setAccessible(true);\n-    \t\t\t} catch (Throwable t) { }\n-    \t\t}\n-    \t\treturn found;\n+    \t    Field found = null;\n+    \t    // First: let's see if we can find exact match:\n+    \t    Field[] fields = fromClass.getDeclaredFields();\n+    \t    for (Field f : fields) {\n+    \t        if (expectedName.equals(f.getName()) && f.getType() == type) {\n+    \t            found = f;\n+    \t            break;\n+    \t        }\n+    \t    }\n+    \t    // And if not, if there is just one field with the type, that field\n+    \t    if (found == null) {\n+    \t        for (Field f : fields) {\n+    \t            if (f.getType() == type) {\n+    \t                // If more than one, can't choose\n+    \t                if (found != null) return null;\n+    \t                found = f;\n+    \t            }\n+    \t        }\n+    \t    }\n+    \t    if (found != null) { // it's non-public, need to force accessible\n+    \t        try {\n+    \t            found.setAccessible(true);\n+    \t        } catch (Throwable t) { }\n+    \t    }\n+    \t    return found;\n     \t}\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/JSONPObject.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/JSONPObject.java\n     /**********************************************************\n      */\n     \n-    @Override\n+//  @Override\n     public void serializeWithType(JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer)\n             throws IOException, JsonProcessingException\n     {\n         serialize(jgen, provider);\n     }\n \n-    @Override\n+//  @Override\n     public void serialize(JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonProcessingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/util/JSONWrappedObject.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/JSONWrappedObject.java\n     /**************************************************************\n      */\n     \n-    @Override\n+//  @Override\n     public void serializeWithType(JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer)\n             throws IOException, JsonProcessingException\n     {\n         serialize(jgen, provider);\n     }\n \n-    @Override\n+//  @Override\n     public void serialize(JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonProcessingException\n     {\n--- a/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n      */\n \n     static class MySchema implements FormatSchema {\n-        @Override\n+//      @Override\n         public String getSchemaType() { return \"test\"; }\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestHandlerInstantiation.java\n             _id = idForBean;\n         }\n         \n-        @Override\n+//      @Override\n         public Id getMechanism() {\n             return Id.CUSTOM;\n         }\n \n-        @Override\n+//      @Override\n         public String idFromValue(Object value)\n         {\n             if (value.getClass() == TypeIdBean.class) {\n             return \"unknown\";\n         }\n \n-        @Override\n+//      @Override\n         public String idFromValueAndType(Object value, Class<?> type) {\n             return idFromValue(value);\n         }\n         \n-        @Override\n+//      @Override\n         public void init(JavaType baseType) {\n             if (initTypes != null) {\n                 initTypes.add(baseType);\n             }\n         }\n \n-        @Override\n+//      @Override\n         public JavaType typeFromId(String id)\n         {\n             if (id.equals(_id)) {\n             return null;\n         }\n \n-        @Override\n+//      @Override\n         public String idFromBaseType() {\n             return \"xxx\";\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapperBeanDeserializer.java\n         public CtorValueBean(int value) { _desc = String.valueOf(value); }\n         public CtorValueBean(long value) { _desc = String.valueOf(value); }\n \n-        @Override\n+//      @Override\n         public void serialize(JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n             CtorValueBean other = (CtorValueBean) o;\n             return _desc.equals(other._desc);\n         }\n-        @Override\n+//      @Override\n         public void serializeWithType(JsonGenerator jgen,\n                 SerializerProvider provider, TypeSerializer typeSer)\n                 throws IOException, JsonProcessingException {\n-            // TODO Auto-generated method stub\n-            \n         }\n     }\n \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestUntypedDeserialization.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * Unit tests for verifying \"old\" data binding from JSON to JDK objects;\n+ * one that only uses core JDK types; wrappers, Maps and Lists.\n+ */\n+public class TestUntypedDeserialization\n+    extends com.fasterxml.jackson.test.BaseTest\n+{\n+    @SuppressWarnings(\"unchecked\")\n+    public void testSampleDoc()\n+        throws Exception\n+    {\n+        final String JSON = SAMPLE_DOC_JSON_SPEC;\n+\n+        JsonFactory jf = new JsonFactory();\n+\n+        /* To get \"untyped\" Mapping (to Maps, Lists, instead of beans etc),\n+         * we'll specify plain old Object.class as the target.\n+         */\n+        Object root = new ObjectMapper().readValue(jf.createJsonParser(new StringReader(JSON)), Object.class);\n+\n+        assertType(root, Map.class);\n+        Map<?,?> rootMap = (Map<?,?>) root;\n+        assertEquals(1, rootMap.size());\n+        Map.Entry<?,?> rootEntry =  rootMap.entrySet().iterator().next();\n+        assertEquals(\"Image\", rootEntry.getKey());\n+        Object image = rootEntry.getValue();\n+        assertType(image, Map.class);\n+        Map<?,?> imageMap = (Map<?,?>) image;\n+        assertEquals(5, imageMap.size());\n+\n+        Object value = imageMap.get(\"Width\");\n+        assertType(value, Integer.class);\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_WIDTH), value);\n+\n+        value = imageMap.get(\"Height\");\n+        assertType(value, Integer.class);\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), value);\n+\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, imageMap.get(\"Title\"));\n+\n+        // Another Object, \"thumbnail\"\n+        value = imageMap.get(\"Thumbnail\");\n+        assertType(value, Map.class);\n+        Map<?,?> tnMap = (Map<?,?>) value;\n+        assertEquals(3, tnMap.size());\n+\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), tnMap.get(\"Height\"));\n+        // for some reason, width is textual, not numeric...\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, tnMap.get(\"Width\"));\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, tnMap.get(\"Url\"));\n+\n+        // And then number list, \"IDs\"\n+        value = imageMap.get(\"IDs\");\n+        assertType(value, List.class);\n+        List<Object> ids = (List<Object>) value;\n+        assertEquals(4, ids.size());\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), ids.get(0));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), ids.get(1));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), ids.get(2));\n+        assertEquals(Integer.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), ids.get(3));\n+\n+        // and that's all folks!\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestUntypedSerialization.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+/**\n+ * This unit test suite tries verify simplest aspects of\n+ * \"Native\" java type mapper; basically that is can properly serialize\n+ * core JDK objects to JSON.\n+ */\n+public class TestUntypedSerialization\n+    extends BaseMapTest\n+{\n+    public void testFromArray()\n+        throws Exception\n+    {\n+        ArrayList<Object> doc = new ArrayList<Object>();\n+        doc.add(\"Elem1\");\n+        doc.add(Integer.valueOf(3));\n+        Map<String,Object> struct = new LinkedHashMap<String, Object>();\n+        struct.put(\"first\", Boolean.TRUE);\n+        struct.put(\"Second\", new ArrayList<Object>());\n+        doc.add(struct);\n+        doc.add(Boolean.FALSE);\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        JsonFactory f =  new JsonFactory();\n+\n+        // loop more than once, just to ensure caching works ok (during second round)\n+        for (int i = 0; i < 3; ++i) {\n+            String str = mapper.writeValueAsString(doc);\n+            \n+            JsonParser jp = f.createJsonParser(str);\n+            assertEquals(JsonToken.START_ARRAY, jp.nextToken());\n+            \n+            assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(\"Elem1\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(3, jp.getIntValue());\n+            \n+            assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"first\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.VALUE_TRUE, jp.nextToken());\n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"Second\", getAndVerifyText(jp));\n+            \n+            if (jp.nextToken() != JsonToken.START_ARRAY) {\n+                fail(\"Expected START_ARRAY: JSON == '\"+str+\"'\");\n+            }\n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+            \n+            assertEquals(JsonToken.VALUE_FALSE, jp.nextToken());\n+            \n+            assertEquals(JsonToken.END_ARRAY, jp.nextToken());\n+            assertNull(jp.nextToken());\n+        }\n+    }\n+\n+    public void testFromMap()\n+        throws Exception\n+    {\n+        LinkedHashMap<String,Object> doc = new LinkedHashMap<String,Object>();\n+        JsonFactory f =  new JsonFactory();\n+\n+        doc.put(\"a1\", \"\\\"text\\\"\");\n+        doc.put(\"int\", Integer.valueOf(137));\n+        doc.put(\"foo bar\", Long.valueOf(1234567890L));\n+\n+        ObjectMapper mapper = new ObjectMapper();\n+        for (int i = 0; i < 3; ++i) {\n+            String str = mapper.writeValueAsString(doc);\n+            JsonParser jp = f.createJsonParser(str);\n+            \n+            assertEquals(JsonToken.START_OBJECT, jp.nextToken());\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"a1\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_STRING, jp.nextToken());\n+            assertEquals(\"\\\"text\\\"\", getAndVerifyText(jp));\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"int\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(137, jp.getIntValue());\n+            \n+            assertEquals(JsonToken.FIELD_NAME, jp.nextToken());\n+            assertEquals(\"foo bar\", getAndVerifyText(jp));\n+            assertEquals(JsonToken.VALUE_NUMBER_INT, jp.nextToken());\n+            assertEquals(1234567890L, jp.getLongValue());\n+            \n+            assertEquals(JsonToken.END_OBJECT, jp.nextToken());\n+\n+            assertNull(jp.nextToken());\n+        }\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestVersions.java\n {\n     // Not a good to do this, but has to do, for now...\n     private final static int MAJOR_VERSION = 2;\n-    private final static int MINOR_VERSION = 0;\n+    private final static int MINOR_VERSION = 1;\n \n     private final static String GROUP_ID = \"com.fasterxml.jackson.core\";\n     private final static String ARTIFACT_ID = \"jackson-databind\";\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualDeserialization.java\n             return new StringValue(\"\"+_fieldName+\"=\"+jp.getText());\n         }\n \n-        @Override\n+//      @Override\n         public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n                 BeanProperty property)\n             throws JsonMappingException\n             return new StringValue(\"\"+_fieldName+\"=\"+jp.getText());\n         }\n     \n-        @Override\n+//      @Override\n         public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n                 BeanProperty property)\n             throws JsonMappingException\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualKeyTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualKeyTypes.java\n             jgen.writeFieldName(value);\n         }\n     \n-        @Override\n+//      @Override\n         public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property)\n             throws JsonMappingException\n         {\n             return _prefix + \":\" + key;\n         }\n \n-        @Override\n+//      @Override\n         public KeyDeserializer createContextual(DeserializationContext ctxt,\n                 BeanProperty property) throws JsonMappingException\n         {\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualSerialization.java\n             jgen.writeString(_prefix + value);\n         }\n \n-        @Override\n+//      @Override\n         public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property)\n                 throws JsonMappingException\n         {\n             jgen.writeString(\"contextual=\"+isContextual+\",resolved=\"+isResolved);\n         }\n \n-        @Override\n+//      @Override\n         public JsonSerializer<?> createContextual(SerializerProvider prov, BeanProperty property)\n                 throws JsonMappingException\n         {\n             return new ContextualAndResolvable(isResolved, isContextual+1);\n         }\n \n-        @Override\n+//      @Override\n         public void resolve(SerializerProvider provider) {\n             ++isResolved;\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualWithAnnDeserializer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/contextual/TestContextualWithAnnDeserializer.java\n             return new StringValue(\"\"+_fieldName+\"=\"+jp.getText());\n         }\n \n-        @Override\n+//      @Override\n         public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n                 BeanProperty property)\n             throws JsonMappingException\n             return new StringValue(\"\"+_fieldName+\"=\"+jp.getText());\n         }\n     \n-        @Override\n+//      @Override\n         public JsonDeserializer<?> createContextual(DeserializationContext ctxt,\n                 BeanProperty property)\n             throws JsonMappingException\n--- a/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java\n \n \n import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.TreeNode;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n \n public class TestBeanConversions\n     extends com.fasterxml.jackson.databind.BaseMapTest\n {\n-    final ObjectMapper mapper = new ObjectMapper();\n+    final ObjectMapper MAPPER = new ObjectMapper();\n \n     static class Point {\n         public int x, y;\n     {\n         // should have no problems convert between compatible beans...\n         PointStrings input = new PointStrings(\"37\", \"-9\");\n-        Point point = mapper.convertValue(input, Point.class);\n+        Point point = MAPPER.convertValue(input, Point.class);\n         assertEquals(37, point.x);\n         assertEquals(-9, point.y);\n         // z not included in input, will be whatever default constructor provides\n         //String json = \"{\\\"boolProp\\\":\\\"oops\\\"}\";\n         // First: unknown property\n         try {\n-            mapper.readValue(\"{\\\"unknownProp\\\":true}\", BooleanBean.class);\n+            MAPPER.readValue(\"{\\\"unknownProp\\\":true}\", BooleanBean.class);\n         } catch (JsonProcessingException e) {\n             verifyException(e, \"unknownProp\");\n         }\n \n         // then bad conversion\n         try {\n-            mapper.readValue(\"{\\\"boolProp\\\":\\\"foobar\\\"}\", BooleanBean.class);\n+            MAPPER.readValue(\"{\\\"boolProp\\\":\\\"foobar\\\"}\", BooleanBean.class);\n         } catch (JsonProcessingException e) {\n             verifyException(e, \"boolProp\");\n         }\n     {\n         ObjectWrapper a = new ObjectWrapper(\"foo\");\n         ObjectWrapper b = new ObjectWrapper(a);\n-        ObjectWrapper b2 = mapper.convertValue(b, ObjectWrapper.class);\n-        ObjectWrapper a2 = mapper.convertValue(b2.getData(), ObjectWrapper.class);\n+        ObjectWrapper b2 = MAPPER.convertValue(b, ObjectWrapper.class);\n+        ObjectWrapper a2 = MAPPER.convertValue(b2.getData(), ObjectWrapper.class);\n         assertEquals(\"foo\", a2.getData());\n     }\n \n         _convertAndVerifyPoint(wrappingMapper);\n     }\n \n+    // [Issue-11]: simple cast, for POJOs etc\n+    public void testConvertUsingCast() throws Exception\n+    {\n+        String str = new String(\"foo\");\n+        CharSequence seq = str;\n+        String result = MAPPER.convertValue(seq, String.class);\n+        // should just cast...\n+        assertSame(str, result);\n+    }\n+    \n+    // [Issue-11]: simple cast, for Tree\n+    public void testNodeConvert() throws Exception\n+    {\n+        ObjectNode src = (ObjectNode) MAPPER.readTree(\"{}\");\n+        TreeNode node = src;\n+        ObjectNode result = MAPPER.treeToValue(node, ObjectNode.class);\n+        // should just cast...\n+        assertSame(src, result);\n+    }\n+    \n     private void _convertAndVerifyPoint(ObjectMapper m)\n     {\n         final Point input = new Point(1, 2, 3);\n--- a/src/test/java/com/fasterxml/jackson/databind/convert/TestStringConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestStringConversions.java\n public class TestStringConversions\n     extends com.fasterxml.jackson.databind.BaseMapTest\n {\n-    final ObjectMapper mapper = new ObjectMapper();\n+    final ObjectMapper MAPPER = new ObjectMapper();\n \n     public void testSimple()\n     {\n-        assertEquals(Boolean.TRUE, mapper.convertValue(\"true\", Boolean.class));\n-        assertEquals(Integer.valueOf(-3), mapper.convertValue(\"  -3 \", Integer.class));\n-        assertEquals(Long.valueOf(77), mapper.convertValue(\"77\", Long.class));\n+        assertEquals(Boolean.TRUE, MAPPER.convertValue(\"true\", Boolean.class));\n+        assertEquals(Integer.valueOf(-3), MAPPER.convertValue(\"  -3 \", Integer.class));\n+        assertEquals(Long.valueOf(77), MAPPER.convertValue(\"77\", Long.class));\n \n         int[] ints = { 1, 2, 3 };\n         List<Integer> Ints = new ArrayList<Integer>();\n         Ints.add(2);\n         Ints.add(3);\n         \n-        assertArrayEquals(ints, mapper.convertValue(Ints, int[].class));\n+        assertArrayEquals(ints, MAPPER.convertValue(Ints, int[].class));\n     }\n \n     public void testStringsToInts()\n     {\n         // let's verify our \"neat trick\" actually works...\n         assertArrayEquals(new int[] { 1, 2, 3, 4, -1, 0 },\n-                          mapper.convertValue(\"1  2 3    4  -1 0\".split(\"\\\\s+\"), int[].class));\n+                          MAPPER.convertValue(\"1  2 3    4  -1 0\".split(\"\\\\s+\"), int[].class));\n     }\n \n-    /**\n-     * @since 1.6\n-     */\n     public void testBytesToBase64AndBack() throws Exception\n     {\n         byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 };\n-        String encoded = mapper.convertValue(input, String.class);\n+        String encoded = MAPPER.convertValue(input, String.class);\n         assertNotNull(encoded);\n-        byte[] result = mapper.convertValue(encoded, byte[].class);\n+        byte[] result = MAPPER.convertValue(encoded, byte[].class);\n         assertArrayEquals(input, result);\n     }\n     \n-    /**\n-     * @since 1.7.3\n-     */\n     public void testBytestoCharArray() throws Exception\n     {\n         byte[] input = new byte[] { 1, 2, 3, 4, 5, 6, 7 };\n         // first, do baseline encoding\n-        char[] expEncoded = mapper.convertValue(input, String.class).toCharArray();\n+        char[] expEncoded = MAPPER.convertValue(input, String.class).toCharArray();\n         // then compare\n-        char[] actEncoded = mapper.convertValue(input, char[].class);\n+        char[] actEncoded = MAPPER.convertValue(input, char[].class);\n         assertArrayEquals(expEncoded, actEncoded);\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestUpdateValue.java\n+package com.fasterxml.jackson.databind.convert;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonView;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+\n+/**\n+ * Unit tests for verifying that \"updating reader\" works as\n+ * expected.\n+ */\n+public class TestUpdateValue extends BaseMapTest\n+{\n+    /*\n+    /********************************************************\n+    /* Helper types\n+    /********************************************************\n+     */\n+\n+    static class Bean {\n+        public String a = \"a\";\n+        public String b = \"b\";\n+\n+        public int[] c = new int[] { 1, 2, 3 };\n+\n+        public Bean child = null;\n+    }\n+\n+    static class XYBean {\n+        public int x, y;\n+    }\n+\n+    // [JACKSON-824]\n+    public class TextView {}\n+    public class NumView {}\n+\n+    public class Updateable {\n+        @JsonView(NumView.class)\n+        public int num;\n+\n+        @JsonView(TextView.class)\n+        public String str;\n+    }\n+        \n+    /*\n+    /********************************************************\n+    /* Unit tests\n+    /********************************************************\n+     */\n+\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n+\n+    public void testBeanUpdate() throws Exception\n+    {\n+        Bean bean = new Bean();\n+        assertEquals(\"b\", bean.b);\n+        assertEquals(3, bean.c.length);\n+        assertNull(bean.child);\n+\n+        Object ob = MAPPER.readerForUpdating(bean).readValue(\"{ \\\"b\\\":\\\"x\\\", \\\"c\\\":[4,5], \\\"child\\\":{ \\\"a\\\":\\\"y\\\"} }\");\n+        assertSame(ob, bean);\n+\n+        assertEquals(\"a\", bean.a);\n+        assertEquals(\"x\", bean.b);\n+        assertArrayEquals(new int[] { 4, 5 }, bean.c);\n+\n+        Bean child = bean.child;\n+        assertNotNull(child);\n+        assertEquals(\"y\", child.a);\n+        assertEquals(\"b\", child.b);\n+        assertArrayEquals(new int[] { 1, 2, 3 }, child.c);\n+        assertNull(child.child);\n+    }\n+\n+    public void testListUpdate() throws Exception\n+    {\n+        List<String> strs = new ArrayList<String>();\n+        strs.add(\"a\");\n+        // for lists, we will be appending entries\n+        Object ob = MAPPER.readerForUpdating(strs).readValue(\"[ \\\"b\\\", \\\"c\\\", \\\"d\\\" ]\");\n+        assertSame(strs, ob);\n+        assertEquals(4, strs.size());\n+        assertEquals(\"a\", strs.get(0));\n+        assertEquals(\"b\", strs.get(1));\n+        assertEquals(\"c\", strs.get(2));\n+        assertEquals(\"d\", strs.get(3));\n+    }\n+\n+    public void testMapUpdate() throws Exception\n+    {\n+        Map<String,String> strs = new HashMap<String,String>();\n+        strs.put(\"a\", \"a\");\n+        strs.put(\"b\", \"b\");\n+        // for maps, we will be adding and/or overwriting entries\n+        Object ob = MAPPER.readerForUpdating(strs).readValue(\"{ \\\"c\\\" : \\\"c\\\", \\\"a\\\" : \\\"z\\\" }\");\n+        assertSame(strs, ob);\n+        assertEquals(3, strs.size());\n+        assertEquals(\"z\", strs.get(\"a\"));\n+        assertEquals(\"b\", strs.get(\"b\"));\n+        assertEquals(\"c\", strs.get(\"c\"));\n+    }\n+\n+    // Test for [JACKSON-717] -- ensure 'readValues' also does update\n+    public void testUpdateSequence() throws Exception\n+    {\n+        XYBean toUpdate = new XYBean();\n+        Iterator<XYBean> it = MAPPER.readerForUpdating(toUpdate).readValues(\n+                \"{\\\"x\\\":1,\\\"y\\\":2}\\n{\\\"x\\\":16}{\\\"y\\\":37}\");\n+\n+        assertTrue(it.hasNext());\n+        XYBean value = it.next();\n+        assertSame(toUpdate, value);\n+        assertEquals(1, value.x);\n+        assertEquals(2, value.y);\n+\n+        assertTrue(it.hasNext());\n+        value = it.next();\n+        assertSame(toUpdate, value);\n+        assertEquals(16, value.x);\n+        assertEquals(2, value.y); // unchanged\n+\n+        assertTrue(it.hasNext());\n+        value = it.next();\n+        assertSame(toUpdate, value);\n+        assertEquals(16, value.x); // unchanged\n+        assertEquals(37, value.y);\n+        \n+        assertFalse(it.hasNext());\n+    }\n+\n+    // [JACKSON-824]\n+    public void testUpdatingWithViews() throws Exception\n+    {\n+        Updateable bean = new Updateable();\n+        bean.num = 100;\n+        bean.str = \"test\";\n+        Updateable result = MAPPER.readerForUpdating(bean)\n+                .withView(TextView.class)\n+                .readValue(\"{\\\"num\\\": 10, \\\"str\\\":\\\"foobar\\\"}\");    \n+        assertSame(bean, result);\n+\n+        assertEquals(100, bean.num);\n+        assertEquals(\"foobar\", bean.str);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestArrayDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestArrayDeserialization.java\n             _desc = d;\n         }\n \n-        @Override\n+//      @Override\n         public void serialize(JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n         {\n             return _desc.equals(other._desc);\n         }\n \n-        @Override\n+//      @Override\n         public void serializeWithType(JsonGenerator jgen,\n                 SerializerProvider provider, TypeSerializer typeSer)\n                 throws IOException, JsonProcessingException {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestAutoDetect.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestAutoDetect.java\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n \n public class TestAutoDetect\n     extends BaseMapTest\n \n         // then by increasing visibility requirement:\n         m = new ObjectMapper();\n-        m.setVisibilityChecker(m.getVisibilityChecker().withCreatorVisibility\n-                (JsonAutoDetect.Visibility.PUBLIC_ONLY));\n+        // note: clumsy code, but needed for Eclipse/JDK1.5 compilation (not for 1.6)\n+        VisibilityChecker<?> vc = m.getVisibilityChecker();\n+        vc = vc.withCreatorVisibility(JsonAutoDetect.Visibility.PUBLIC_ONLY);\n+        m.setVisibilityChecker(vc);\n         try {\n             m.readValue(\"\\\"abc\\\"\", PrivateBean.class);\n             fail(\"Expected exception for missing constructor\");\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n \n     static class XBean {\n         public int x;\n+    }\n+\n+    // [JACKSON-822]\n+    static interface Issue822Interface {\n+        public int getA();\n+    }\n+\n+    // If this annotation is added, things will work:\n+    //@com.fasterxml.jackson.databind.annotation.JsonSerialize(as=Issue822Interface.class)\n+    // but it should not be necessary when root type is passed\n+    static class Issue822Impl implements Issue822Interface {\n+        public int getA() { return 3; }\n+        public int getB() { return 9; }\n     }\n     \n     /*\n         List<?> result = m.readValue(quote(\"\"), List.class);\n         assertNull(result);\n     }\n+\n+    // [JACKSON-822]: ensure that type can be coerced\n+    public void testTypedLists() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        List<Issue822Interface> list = new ArrayList<Issue822Interface>();\n+        String singleJson = mapper.writerWithType(Issue822Interface.class).writeValueAsString(new Issue822Impl());\n+        // start with specific value case:\n+        assertEquals(\"{\\\"a\\\":3}\", singleJson);\n+        // then lists\n+        list.add(new Issue822Impl());\n+        String listJson = mapper.writerWithType(new TypeReference<List<Issue822Interface>>(){})\n+                .writeValueAsString(list);\n+        assertEquals(\"[{\\\"a\\\":3}]\", listJson);\n+    }\n+\n+    // [JACKSON-822]: ensure that type can be coerced\n+    public void testTypedArrays() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        assertEquals(\"[{\\\"a\\\":3}]\", mapper.writerWithType(Issue822Interface[].class).writeValueAsString(\n+                new Issue822Interface[] { new Issue822Impl() }));\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestConcurrency.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestConcurrency.java\n             return b;\n         }\n \n-        @Override\n+//      @Override\n         public void resolve(DeserializationContext ctxt) throws JsonMappingException\n         {\n             try {\n         for (int i = 0; i < 5; ++i) {\n             final ObjectMapper mapper = new ObjectMapper();\n             Runnable r = new Runnable() {\n-                @Override\n+//              @Override\n                 public void run() {\n                     try {\n                         /*Bean b =*/ mapper.readValue(JSON, Bean.class);\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCyclicTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCyclicTypes.java\n package com.fasterxml.jackson.databind.deser;\n-\n-import javax.xml.bind.annotation.*;\n \n import com.fasterxml.jackson.databind.*;\n \n         public void setNext(Bean b) { _next = b; }\n         public void setName(String n) { _name = n; }\n \n-    }\n-\n-    // Also another one to ensure JAXB annotation introspector has no problems\n-    @XmlAccessorType(XmlAccessType.FIELD)\n-    static class JaxbBean\n-    {\n-        @XmlElement(required = true)\n-        protected int id;\n-\n-        @XmlElement(required = false)\n-        protected JaxbBean circular;\n     }\n \n     static class LinkA {\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestEnumDeserialization.java\n     static class ClassWithEnumMapKey {\n     \t@JsonProperty Map<TestEnum, String> map;\n     }\n-    \n+\n+    // [JACKSON-834]\n+    protected enum TestEnumFor834\n+    {\n+        ENUM_A(1), ENUM_B(2), ENUM_C(3);\n+        \n+        private final int id;\n+        \n+        private TestEnumFor834(int id) {\n+            this.id = id;\n+        }\n+        \n+        @JsonCreator public static TestEnumFor834 fromId(int id) {\n+            for (TestEnumFor834 e: values()) {\n+                if (e.id == id) return e;\n+            }\n+            return null;\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Tests\n      */\n     public void testComplexEnum() throws Exception\n     {\n-        String json = MAPPER.writeValueAsString(TimeUnit.HOURS);\n-        assertEquals(quote(\"HOURS\"), json);\n+        String json = MAPPER.writeValueAsString(TimeUnit.SECONDS);\n+        assertEquals(quote(\"SECONDS\"), json);\n         TimeUnit result = MAPPER.readValue(json, TimeUnit.class);\n-        assertSame(TimeUnit.HOURS, result);\n+        assertSame(TimeUnit.SECONDS, result);\n     }\n     \n     /**\n          }\n     }\n \n+    // [JACKSON-834]\n+    public void testEnumsFromInts() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        TestEnumFor834 res = mapper.readValue(\"1 \", TestEnumFor834.class);\n+        assertSame(TestEnumFor834.ENUM_A, res);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericMapDeser.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestGenericMapDeser.java\n \n         public StringMap() { }\n \n-        @Override\n+//      @Override\n         public Map<String,Long> getEntries() { return entries; }\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestInjectables.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestInjectables.java\n             age = a;\n         }\n     }\n+\n+    static class CtorBean2 {\n+        protected String name;\n+        protected Integer age;\n+        \n+        public CtorBean2(@JacksonInject String n, @JacksonInject(\"number\") Integer a)\n+        {\n+            name = n;\n+            age = a;\n+        }\n+    }\n     \n     /*\n     /**********************************************************\n         assertEquals(\"xyz\", bean.otherStuff);\n         assertEquals(37L, bean.third);\n     }\n-\n+    \n     public void testWithCtors() throws Exception\n     {\n         ObjectMapper mapper = new ObjectMapper();\n         CtorBean bean = mapper.readValue(\"{\\\"age\\\":55}\", CtorBean.class);\n         assertEquals(55, bean.age);\n         assertEquals(\"Bubba\", bean.name);\n+    }\n+\n+    // [Issue-13]\n+    public void testTwoInjectablesViaCreator() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.setInjectableValues(new InjectableValues.Std()\n+            .addValue(String.class, \"Bob\")\n+            .addValue(\"number\", Integer.valueOf(13))\n+            );\n+        CtorBean2 bean = mapper.readValue(\"{ }\", CtorBean2.class);\n+        assertEquals(Integer.valueOf(13), bean.age);\n+        assertEquals(\"Bob\", bean.name);\n     }\n     \n     public void testInvalidDup() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestValueAnnotations.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestValueAnnotations.java\n \n         public RootStringImpl(String x) { _contents = x; }\n \n-        @Override\n+//      @Override\n         public String contents() { return _contents; }\n         public String contents2() { return _contents; }\n     }\n \n         public RootInterfaceImpl() { }\n \n-        @Override\n+//      @Override\n         public String getA() { return a; }\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestCglibUsage.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestCglibUsage.java\n         Enhancer enh = new Enhancer();\n         enh.setInterfaces(new Class[] { BeanInterface.class });\n         enh.setCallback(new MethodInterceptor() {\n-            @Override\n-                public Object intercept(Object obj, Method method,\n+//          @Override\n+            public Object intercept(Object obj, Method method,\n                                         Object[] args, MethodProxy proxy)\n                     throws Throwable\n                 {\n--- a/src/test/java/com/fasterxml/jackson/databind/interop/TestHibernate.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/interop/TestHibernate.java\n         Enhancer enh = new Enhancer();\n         enh.setInterfaces(new Class[] { BeanInterfaceHib.class });\n         enh.setCallback(new MethodInterceptor() {\n-            @Override\n+//          @Override\n             public Object intercept(Object obj, Method method,\n                     Object[] args, MethodProxy proxy)\n                             throws Throwable\n--- a/src/test/java/com/fasterxml/jackson/databind/introspect/TestAnnotionBundles.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/introspect/TestAnnotionBundles.java\n import java.lang.annotation.RetentionPolicy;\n \n import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n import com.fasterxml.jackson.databind.ObjectMapper;\n \n /* Tests mostly for [JACKSON-754]: ability to create \"annotation bundles\"\n         @MyRename\n         public int renamed = 13;\n     }\n+\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @JsonAutoDetect(fieldVisibility=Visibility.NONE,\n+            getterVisibility=Visibility.NONE, isGetterVisibility=Visibility.NONE)\n+    @JacksonAnnotationsInside\n+    public @interface JsonAutoDetectOff {}\n+\n+    @JsonAutoDetectOff\n+    public class NoAutoDetect {\n+      public int getA() { return 13; }\n+      \n+      @JsonProperty\n+      public int getB() { return 5; }\n+    }\n     \n     /*\n     /**********************************************************\n     /**********************************************************\n      */\n \n-    private final ObjectMapper mapper = new ObjectMapper();\n+    private final ObjectMapper MAPPER = new ObjectMapper();\n     \n     public void testBundledIgnore() throws Exception\n     {\n-        assertEquals(\"{\\\"foobar\\\":13}\", mapper.writeValueAsString(new Bean()));\n+        assertEquals(\"{\\\"foobar\\\":13}\", MAPPER.writeValueAsString(new Bean()));\n     }\n+\n+    public void testVisibilityBundle() throws Exception\n+    {\n+        assertEquals(\"{\\\"b\\\":5}\", MAPPER.writeValueAsString(new NoAutoDetect()));\n+    }\n+    \n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractTypeNames.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestAbstractTypeNames.java\n /**\n  * Unit tests for checking how combination of interfaces, implementation\n  * classes are handled, with respect to type names.\n- * \n- * @since 1.8\n  */\n public class TestAbstractTypeNames  extends BaseMapTest\n {\n             _employer = employer;\n         }\n \n-        @Override\n+//      @Override\n         public String getEmployer() {\n             return _employer;\n         }\n             _friends = friends;\n         }\n \n-        @Override public String getName() {\n+        public String getName() {\n             return _name;\n         }\n \n-        @Override public List<User> getFriends() {\n+        public List<User> getFriends() {\n             return _friends;\n         }\n     }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestCustomTypeIdResolver.java\n \n         public CustomResolver() { }\n         \n-        @Override\n+//      @Override\n         public Id getMechanism() {\n             return Id.CUSTOM;\n         }\n \n-        @Override\n+//      @Override\n         public String idFromValue(Object value)\n         {\n             if (value.getClass() == CustomBean.class) {\n             return \"unknown\";\n         }\n \n-        @Override\n+//      @Override\n         public String idFromValueAndType(Object value, Class<?> type) {\n             return idFromValue(value);\n         }\n         \n-        @Override\n+//      @Override\n         public void init(JavaType baseType) {\n             if (initTypes != null) {\n                 initTypes.add(baseType);\n             }\n         }\n \n-        @Override\n+//      @Override\n         public JavaType typeFromId(String id)\n         {\n             if (\"*\".equals(id)) {\n             return null;\n         }\n \n-        @Override\n+//      @Override\n         public String idFromBaseType() {\n             return \"xxx\";\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForEnums.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestDefaultForEnums.java\n package com.fasterxml.jackson.databind.jsontype;\n \n import java.util.concurrent.TimeUnit;\n-\n \n import com.fasterxml.jackson.databind.BaseMapTest;\n import com.fasterxml.jackson.databind.ObjectMapper;\n     public void testSimpleEnumBean() throws Exception\n     {\n         TimeUnitBean bean = new TimeUnitBean();\n-        bean.timeUnit = TimeUnit.HOURS;\n+        bean.timeUnit = TimeUnit.SECONDS;\n         \n         // First, without type info\n         ObjectMapper m = new ObjectMapper();\n         String json = m.writeValueAsString(bean);\n         TimeUnitBean result = m.readValue(json, TimeUnitBean.class);\n-        assertEquals(TimeUnit.HOURS, result.timeUnit);\n+        assertEquals(TimeUnit.SECONDS, result.timeUnit);\n         \n         // then with type info\n         m = new ObjectMapper();\n         json = m.writeValueAsString(bean);\n         result = m.readValue(json, TimeUnitBean.class);\n \n-        assertEquals(TimeUnit.HOURS, result.timeUnit);\n+        assertEquals(TimeUnit.SECONDS, result.timeUnit);\n     }\n     \n     public void testSimpleEnumsInObjectArray() throws Exception\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestExternalId.java\n             baseProperty = bp;\n         }\n \n-        @Override\n+//      @Override\n         @JsonProperty public String getBaseProperty() {\n             return baseProperty;\n         }\n             baseProperty = bp;\n         }\n \n-        @Override\n+//      @Override\n         @JsonProperty public String getBaseProperty() {\n             return baseProperty;\n         }\n         @JsonProperty\n         public Base getBase() { return base; }\n     }\n-    \n+\n+    // [JACKSON-831]: should allow a property to map id to as well\n+    \n+    interface Pet {}\n+\n+    static class Dog implements Pet {\n+        public String name;\n+    }\n+\n+    static class House831 {\n+        protected String petType;\n+\n+        @JsonTypeInfo(use = Id.NAME, include = As.EXTERNAL_PROPERTY, property = \"petType\")\n+        @JsonSubTypes({@JsonSubTypes.Type(name = \"dog\", value = Dog.class)})\n+        public Pet pet;\n+\n+        public String getPetType() {\n+            return petType;\n+        }\n+\n+        public void setPetType(String petType) {\n+            this.petType = petType;\n+        }\n+    }    \n+\n     /*\n     /**********************************************************\n     /* Unit tests, serialization\n         assertEquals(\"base prop val\", derived1.getBaseProperty());\n         assertEquals(\"derived1 prop val\", derived1.getDerived1Property());\n     }\n+\n+    // There seems to be some problems if type is also visible...\n+    public void testIssue831() throws Exception\n+    {\n+        final String JSON = \"{ \\\"petType\\\": \\\"dog\\\",\\n\"\n+                +\"\\\"pet\\\": { \\\"name\\\": \\\"Pluto\\\" }\\n}\";\n+        ObjectMapper mapper = new ObjectMapper();\n+        House831 result = mapper.readValue(JSON, House831.class);\n+        assertNotNull(result);\n+        assertNotNull(result.pet);\n+        assertSame(Dog.class, result.pet.getClass());\n+        assertEquals(\"dog\", result.petType);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestWithGenerics.java\n             beanSerializer.serializeWithType( value, jgen, provider, typeSer );\n         }\n \n-        @Override\n+//      @Override\n         public void resolve(SerializerProvider provider) throws JsonMappingException\n         {\n             if (beanSerializer instanceof ResolvableSerializer) {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinInheritance.java\n+package com.fasterxml.jackson.databind.mixins;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestMixinInheritance\n+    extends BaseMapTest\n+{\n+    // [Issue-14]\n+    static class Beano {\n+        public int ido = 42;\n+        public String nameo = \"Bob\";\n+    }\n+\n+    static class BeanoMixinSuper {\n+        @JsonProperty(\"name\")\n+        public String nameo;\n+    }\n+\n+    static class BeanoMixinSub extends BeanoMixinSuper {\n+        @JsonProperty(\"id\")\n+        public int ido;\n+    }\n+\n+    static class Beano2 {\n+        public int getIdo() { return 13; }\n+        public String getNameo() { return \"Bill\"; }\n+    }\n+\n+    static abstract class BeanoMixinSuper2 extends Beano2 {\n+        @Override\n+        @JsonProperty(\"name\")\n+        public abstract String getNameo();\n+    }\n+\n+    static abstract class BeanoMixinSub2 extends BeanoMixinSuper2 {\n+        @Override\n+        @JsonProperty(\"id\")\n+        public abstract int getIdo();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+    \n+    public void testMixinFieldInheritance() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.addMixInAnnotations(Beano.class, BeanoMixinSub.class);\n+        Map<String,Object> result;\n+        result = writeAndMap(mapper, new Beano());\n+        assertEquals(2, result.size());\n+        assertTrue(result.containsKey(\"id\"));\n+        assertTrue(result.containsKey(\"name\"));\n+    }\n+\n+    public void testMixinMethodInheritance() throws IOException\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        mapper.addMixInAnnotations(Beano2.class, BeanoMixinSub2.class);\n+        Map<String,Object> result;\n+        result = writeAndMap(mapper, new Beano2());\n+        assertEquals(2, result.size());\n+        assertTrue(result.containsKey(\"id\"));\n+        assertTrue(result.containsKey(\"name\"));\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForFields.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/mixins/TestMixinSerForFields.java\n         // also: add a dummy field that is NOT to match anything\n         @JsonProperty public String xyz;\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Unit tests\n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestAbstractTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestAbstractTypes.java\n         \n         public MyString(String s) { value = s; }\n \n-        @Override\n+//      @Override\n         public char charAt(int index) {\n             return value.charAt(index);\n         }\n \n-        @Override\n+//      @Override\n         public int length() {\n             return value.length();\n         }\n \n-        @Override\n+//      @Override\n         public CharSequence subSequence(int arg0, int arg1) { return this; }\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestSimpleModule.java\n     }\n     \n     static class Impl1 implements Base {\n-        @Override\n+//      @Override\n         public String getText() { return \"1\"; }\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestTypeModifiers.java\n             value = v;\n         }\n \n-        @Override\n+//      @Override\n         public String getKey() { return key; }\n-        @Override\n+//      @Override\n         public Integer getValue() { return value; }\n     }\n \n             value = v;\n         }\n \n-        @Override\n+//      @Override\n         public Integer getValue() { return value; }\n     }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestConversions.java\n                 try {\n                     data = n.getBinaryValue(variant);\n                 } catch (Exception e) {\n-                    throw new IOException(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage(), e);\n+                    throw new IOException(\"Failed (variant \"+variant+\", data length \"+len+\"): \"+e.getMessage());\n                 }\n                 assertNotNull(data);\n                 assertArrayEquals(data, input);\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestMissingNode.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestMissingNode.java\n     public void testMissing()\n     {\n         MissingNode n = MissingNode.getInstance();\n+        assertTrue(n.isMissingNode());\n         assertEquals(JsonToken.NOT_AVAILABLE, n.asToken());\n         // as per [JACKSON-775]\n         assertEquals(\"\", n.asText());\n          * that default values are served.\n          */\n         assertNodeNumbersForNonNumeric(n);\n+\n+        // [JACKSON-823]\n+        assertTrue(n.asBoolean(true));\n+        assertEquals(4, n.asInt(4));\n+        assertEquals(5L, n.asLong(5));\n+        assertEquals(0.25, n.asDouble(0.25));\n     }\n-\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationInheritance.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestAnnotationInheritance.java\n     {\n         // Both should be recognized as getters here\n \n-        @Override\n+//      @Override\n         public int width() { return 1; }\n-        @Override\n+//      @Override\n         public int length() { return 2; }\n \n         public int getFoobar() { return 5; }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n             }\n         }\n \n-        @Override\n+//      @Override\n         public Iterator<Integer> iterator() {\n             return _ints.iterator();\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n \n         private SerializableEnum() { }\n         \n-        @Override\n+//      @Override\n         public void serializeWithType(JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer)\n                 throws IOException, JsonProcessingException\n         {\n             serialize(jgen, provider);\n         }\n \n-        @Override\n+//      @Override\n         public void serialize(JsonGenerator jgen, SerializerProvider provider) throws IOException, JsonProcessingException\n         {\n             jgen.writeString(\"foo\");\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestFeatures.java\n \n         protected boolean wasClosed = false;\n         \n-        @Override\n+//      @Override\n         public void close() throws IOException {\n             wasClosed = true;\n         }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestFiltering.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestFiltering.java\n import com.fasterxml.jackson.databind.ser.impl.*;\n \n /**\n- * Tests for verifying that bean property filtering (new with 1.7)\n+ * Tests for verifying that bean property filtering using JsonFilter\n  * works as expected.\n- * \n- * @since 1.7\n  */\n public class TestFiltering extends BaseMapTest\n {\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJdkTypes.java\n package com.fasterxml.jackson.databind.ser;\n \n import java.io.*;\n+import java.math.BigDecimal;\n import java.net.InetAddress;\n import java.nio.charset.Charset;\n import java.util.*;\n     extends com.fasterxml.jackson.databind.BaseMapTest\n {\n     private final ObjectMapper MAPPER = new ObjectMapper();\n+    \n+    /**\n+     * Unit test to catch bug [JACKSON-8].\n+     */\n+    public void testBigDecimal()\n+        throws Exception\n+    {\n+        Map<String, Object> map = new HashMap<String, Object>();\n+        String PI_STR = \"3.14159265\";\n+        map.put(\"pi\", new BigDecimal(PI_STR));\n+        String str = MAPPER.writeValueAsString(map);\n+        assertEquals(\"{\\\"pi\\\":3.14159265}\", str);\n+    }\n     \n     /**\n      * Unit test related to [JACKSON-155]\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize.java\n     static class ValueClass\n         implements ValueInterface\n     {\n-        @Override\n+//      @Override\n         public int getX() { return 3; }\n         public int getY() { return 5; }\n     }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestJsonSerialize3.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+\n+public class TestJsonSerialize3 extends BaseMapTest\n+{\n+    // [JACKSON-829]\n+    static class FooToBarSerializer extends JsonSerializer<String> {\n+        @Override\n+        public void serialize(String value, JsonGenerator jgen, SerializerProvider provider)\n+               throws IOException {\n+            if (\"foo\".equals(value)) {\n+                jgen.writeString(\"bar\");\n+            } else {\n+                jgen.writeString(value);\n+            }\n+        }\n+    }\n+\n+    static class MyObject {\n+        @JsonSerialize(contentUsing = FooToBarSerializer.class)\n+        List<String> list;\n+    }    \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    public void testCustomContentSerializer() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        MyObject object = new MyObject();\n+        object.list = Arrays.asList(\"foo\");\n+        String json = m.writeValueAsString(object);\n+        assertEquals(\"{\\\"list\\\":[\\\"bar\\\"]}\", json);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestRootType.java\n /**\n  * Unit tests for verifying functioning of [JACKSON-195], ability to\n  * force specific root type for serialization (super type of value)\n- * \n- * @author tatu\n  */\n public class TestRootType\n     extends BaseMapTest\n     {\n         public String a = \"a\";\n \n-        @Override\n         public int getB() { return 3; }\n     }\n ", "timestamp": 1338435817, "metainfo": ""}