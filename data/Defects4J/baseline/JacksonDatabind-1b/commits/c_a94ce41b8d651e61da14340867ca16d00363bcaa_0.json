{"sha": "a94ce41b8d651e61da14340867ca16d00363bcaa", "log": "Merge branch 'master' of https://github.com/FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n     }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    protected DeserializationConfig(DeserializationConfig src, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(src, mixins);\n+        _deserFeatures = src._deserFeatures;\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java\n     @Override\n     public final ObjectMapper getCodec() { return (ObjectMapper) _objectCodec; }\n \n+    // @since 2.1\n+    @Override\n+    public JsonFactory copy()\n+    {\n+        _checkInvalidCopy(MappingJsonFactory.class);\n+        // note: as with base class, must NOT copy mapper reference\n+        return new MappingJsonFactory(null);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Format detection functionality (since 1.8)\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     }\n \n     /**\n+     * Copy-constructor, mostly used to support {@link #copy}.\n+     * \n+     * @since 2.1\n+     */\n+    protected ObjectMapper(ObjectMapper src)\n+    {\n+        _jsonFactory = src._jsonFactory.copy();\n+        _jsonFactory.setCodec(this);\n+        _subtypeResolver = src._subtypeResolver;\n+        _rootNames = new RootNameLookup();\n+        _typeFactory = src._typeFactory;\n+        _serializationConfig = src._serializationConfig;\n+        _serializationConfig = new SerializationConfig(src._serializationConfig, _mixInAnnotations);\n+        _deserializationConfig = new DeserializationConfig(src._deserializationConfig, _mixInAnnotations);\n+        _serializerProvider = src._serializerProvider;\n+        _deserializationContext = src._deserializationContext;\n+\n+        // Default serializer factory is stateless, can just assign\n+        _serializerFactory = src._serializerFactory;\n+    }\n+    \n+    /**\n      * Constructs instance that uses specified {@link JsonFactory}\n      * for constructing necessary {@link JsonParser}s and/or\n      * {@link JsonGenerator}s, and uses given providers for accessing\n \n         // Default serializer factory is stateless, can just assign\n         _serializerFactory = BeanSerializerFactory.instance;\n+    }\n+\n+    /**\n+     * Method for creating a new {@link ObjectMapper} instance that\n+     * has same initial configuration as this instance. Note that this\n+     * also requires making a copy of the underlying {@link JsonFactory}\n+     * instance.\n+     *<p>\n+     * Method is typically\n+     * used when multiple, differently configured mappers are needed.\n+     * Although configuration is shared, cached serializers and deserializers\n+     * are NOT shared, which means that the new instance may be re-configured\n+     * before use; meaning that it behaves the same way as if an instance\n+     * was constructed from scratch.\n+     * \n+     * @since 2.1\n+     */\n+    public ObjectMapper copy()\n+    {\n+        _checkInvalidCopy(ObjectMapper.class);\n+        return new ObjectMapper(this);\n+    }\n+\n+    /**\n+     * @since 2.1\n+     * @param exp\n+     */\n+    protected void _checkInvalidCopy(Class<?> exp)\n+    {\n+        if (getClass() != exp) {\n+            throw new IllegalStateException(\"Failed copy(): \"+getClass().getName()\n+                    +\" (version: \"+version()+\") does not override copy(); it has to\");\n+        }\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n         _serializationInclusion = src._serializationInclusion;\n         _filterProvider = src._filterProvider;\n     }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    protected SerializationConfig(SerializationConfig src, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(src, mixins);\n+        _serFeatures = src._serFeatures;\n+        _serializationInclusion = src._serializationInclusion;\n+        _filterProvider = src._filterProvider;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/MapperConfigBase.java\n         _rootName = src._rootName;\n         _view = view;\n     }\n+\n+    /**\n+     * @since 2.1\n+     */\n+    protected MapperConfigBase(MapperConfigBase<CFG,T> src, Map<ClassKey,Class<?>> mixins)\n+    {\n+        super(src);\n+        _mixInAnnotations = mixins;\n+        _subtypeResolver = src._subtypeResolver;\n+        _rootName = src._rootName;\n+        _view = src._view;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n import java.util.HashMap;\n import java.util.concurrent.ConcurrentHashMap;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n                         mlt, beanDesc);\n             }\n             if (type.isCollectionLikeType()) {\n-                CollectionLikeType clt = (CollectionLikeType) type;\n-                if (clt.isTrueCollectionType()) {\n-                    return (JsonDeserializer<Object>) factory.createCollectionDeserializer(ctxt,\n-                            (CollectionType) clt, beanDesc);\n-                }\n-                return (JsonDeserializer<Object>) factory.createCollectionLikeDeserializer(ctxt,\n-                        clt, beanDesc);\n+                /* 03-Aug-2012, tatu: As per [Issue#40], one exception is if shape\n+                 *   is to be Shape.OBJECT. Ideally we'd determine it bit later on\n+                 *   (to allow custom handler checks), but that won't work for other\n+                 *   reasons. So do it here.\n+                 */\n+                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n+                if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) {\n+                    CollectionLikeType clt = (CollectionLikeType) type;\n+                    if (clt.isTrueCollectionType()) {\n+                        return (JsonDeserializer<Object>) factory.createCollectionDeserializer(ctxt,\n+                                (CollectionType) clt, beanDesc);\n+                    }\n+                    return (JsonDeserializer<Object>) factory.createCollectionLikeDeserializer(ctxt,\n+                            clt, beanDesc);\n+                }\n             }\n         }\n         if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n     {\n         return new BasicBeanDescription(config, type,\n                 ac, Collections.<BeanPropertyDefinition>emptyList());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Limited modifications by core databind functionality\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to prune unwanted properties, during\n+     * construction of serializers and deserializers.\n+     * Use with utmost care, if at all...\n+     * \n+     * @since 2.1\n+     */\n+    public boolean removeProperty(String propName)\n+    {\n+        Iterator<BeanPropertyDefinition> it = _properties.iterator();\n+        while (it.hasNext()) {\n+            BeanPropertyDefinition prop = it.next();\n+            if (prop.getName().equals(propName)) {\n+                it.remove();\n+                return true;\n+            }\n+        }\n+        return false;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n import java.net.InetAddress;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n         }\n         return b.buildTypeSerializer(config, baseType, subtypes);\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Additional API for other core classes\n             return NumberSerializers.NumberSerializer.instance;\n         }\n         if (Enum.class.isAssignableFrom(raw)) {\n-            @SuppressWarnings(\"unchecked\")\n-            Class<Enum<?>> enumClass = (Class<Enum<?>>) raw;\n-            return EnumSerializer.construct(enumClass, prov.getConfig(), beanDesc);\n+            /* As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n+             * Challenge here is that EnumSerializer does not know how to produce\n+             * POJO style serialization, so we must handle that special case separately;\n+             * otherwise pass it to EnumSerializer.\n+             */\n+            JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n+            if (format != null && format.getShape() == JsonFormat.Shape.OBJECT) {\n+                // one special case: suppress serialization of \"getDeclaringClass()\"...\n+                ((BasicBeanDescription) beanDesc).removeProperty(\"declaringClass\");\n+            } else {\n+                @SuppressWarnings(\"unchecked\")\n+                Class<Enum<?>> enumClass = (Class<Enum<?>>) raw;\n+                return EnumSerializer.construct(enumClass, prov.getConfig(), beanDesc, format);\n+            }\n         }\n         if (Calendar.class.isAssignableFrom(raw)) {\n             return CalendarSerializer.instance;\n         if (type.isCollectionLikeType()) {\n             CollectionLikeType clt = (CollectionLikeType) type;\n             if (clt.isTrueCollectionType()) { // only have custom ones, if any:\n-                return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, property, staticTyping,\n-                        elementTypeSerializer, elementValueSerializer);\n-            }\n-            // Only custom variants for this:\n-            for (Serializers serializers : customSerializers()) {\n-                JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config,\n-                        (CollectionLikeType) type, beanDesc, elementTypeSerializer, elementValueSerializer);\n-                if (ser != null) {\n-                    return ser;\n-                }\n-            }\n-            return null;\n+                CollectionType trueCT = (CollectionType) clt;\n+                // Module-provided custom collection serializers?\n+                for (Serializers serializers : customSerializers()) {\n+                    JsonSerializer<?> ser = serializers.findCollectionSerializer(config,\n+                            trueCT, beanDesc, elementTypeSerializer, elementValueSerializer);\n+                    if (ser != null) {\n+                        return ser;\n+                    }\n+                }\n+\n+                // As per [Issue#24], may want to use alternate shape, serialize as JSON Object.\n+                // Challenge here is that EnumSerializer does not know how to produce\n+                // POJO style serialization, so we must handle that special case separately;\n+                // otherwise pass it to EnumSerializer.\n+                JsonFormat.Value format = beanDesc.findExpectedFormat(null);\n+\n+                if (format == null || format.getShape() != JsonFormat.Shape.OBJECT) {\n+                    return buildCollectionSerializer(config, trueCT, beanDesc, property, staticTyping,\n+                            elementTypeSerializer, elementValueSerializer);\n+                }\n+            } else {\n+                // Only custom variants for this:\n+                for (Serializers serializers : customSerializers()) {\n+                    JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config,\n+                            (CollectionLikeType) type, beanDesc, elementTypeSerializer, elementValueSerializer);\n+                    if (ser != null) {\n+                        return ser;\n+                    }\n+                }\n+                // fall through either way (whether shape dictates serialization as POJO or not)\n+                return null;\n+            }\n         }\n         if (type.isArrayType()) {\n             return buildArraySerializer(config, (ArrayType) type, beanDesc, staticTyping,\n             TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n         throws JsonMappingException\n     {\n-        // Module-provided custom collection serializers?\n-        for (Serializers serializers : customSerializers()) {\n-            JsonSerializer<?> ser = serializers.findCollectionSerializer(config,\n-                    type, beanDesc, elementTypeSerializer, elementValueSerializer);\n-            if (ser != null) {\n-                return ser;\n-            }\n-        }\n         Class<?> raw = type.getRawClass();\n         if (EnumSet.class.isAssignableFrom(raw)) {\n             // this may or may not be available (Class doesn't; type of field/method does)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n                 }\n                 */\n             }\n-            return (JsonSerializer<Object>) buildContainerSerializer(prov,\n-                    type, beanDesc, property, staticTyping);\n-        }\n-\n-        // Modules may provide serializers of POJO types:\n-        for (Serializers serializers : customSerializers()) {\n-            ser = serializers.findSerializer(config, type, beanDesc);\n+            // 03-Aug-2012, tatu: As per [Issue#40], may require POJO serializer...\n+            ser =  buildContainerSerializer(prov, type, beanDesc, property, staticTyping);\n             if (ser != null) {\n                 return (JsonSerializer<Object>) ser;\n+            }\n+        } else {\n+            // Modules may provide serializers of POJO types:\n+            for (Serializers serializers : customSerializers()) {\n+                ser = serializers.findSerializer(config, type, beanDesc);\n+                if (ser != null) {\n+                    return (JsonSerializer<Object>) ser;\n+                }\n             }\n         }\n         \n     {\n         // First things first: we know some types are not beans...\n         if (!isPotentialBeanType(type.getRawClass())) {\n-            return null;\n+            // 03-Aug-2012, tatu: Except we do need to allow serializers for Enums,\n+            //   as per [Issue#24]\n+            if (!type.isEnumType()) {\n+                return null;\n+            }\n         }\n         JsonSerializer<Object> serializer = constructBeanSerializer(prov, beanDesc, property);\n         // [JACKSON-440] Need to allow overriding actual serializer, as well...\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n import java.io.IOException;\n import java.lang.reflect.Type;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.core.io.SerializedString;\n \n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.node.ArrayNode;\n import com.fasterxml.jackson.databind.node.ObjectNode;\n+import com.fasterxml.jackson.databind.ser.ContextualSerializer;\n import com.fasterxml.jackson.databind.util.EnumValues;\n \n /**\n @JacksonStdImpl\n public class EnumSerializer\n     extends StdScalarSerializer<Enum<?>>\n+    implements ContextualSerializer\n {\n     /**\n      * This map contains pre-resolved values (since there are ways\n      */\n     protected final EnumValues _values;\n \n+    /**\n+     * Flag that is set if we statically know serialization choice\n+     * between index and textual format (null if it needs to be dynamically\n+     * checked).\n+     * \n+     * @since 2.1\n+     */\n+    protected final Boolean _serializeAsIndex;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @deprecated Since 2.1\n+     */\n+    @Deprecated\n     public EnumSerializer(EnumValues v) {\n+        this(v, null);\n+    }\n+\n+    public EnumSerializer(EnumValues v, Boolean serializeAsIndex)\n+    {\n         super(Enum.class, false);\n         _values = v;\n-    }\n-\n+        _serializeAsIndex = serializeAsIndex;\n+    }\n+    \n+    /**\n+     * Factory method used by {@link com.fasterxml.jackson.databind.ser.BasicSerializerFactory}\n+     * for constructing serializer instance of Enum types.\n+     * \n+     * @since 2.1\n+     */\n     public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config,\n-            BeanDescription beanDesc)\n+            BeanDescription beanDesc, JsonFormat.Value format)\n     {\n         // [JACKSON-212]: If toString() is to be used instead, leave EnumValues null\n         AnnotationIntrospector intr = config.getAnnotationIntrospector();\n         EnumValues v = config.isEnabled(SerializationFeature.WRITE_ENUMS_USING_TO_STRING)\n             ? EnumValues.constructFromToString(enumClass, intr) : EnumValues.constructFromName(enumClass, intr);\n-        return new EnumSerializer(v);\n-    }\n+        Boolean serializeAsIndex = _isShapeWrittenUsingIndex(enumClass, format, true);\n+        return new EnumSerializer(v, serializeAsIndex);\n+    }\n+    \n+    /**\n+     * @deprecated Since 2.1 use the variant that takes in <code>format</code> argument.\n+     */\n+    @Deprecated\n+    public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config,\n+            BeanDescription beanDesc)\n+    {\n+        return construct(enumClass, config, beanDesc, beanDesc.findExpectedFormat(null));\n+    }\n+\n+    /**\n+     * To support some level of per-property configuration, we will need\n+     * to make things contextual. We are limited to \"textual vs index\"\n+     * choice here, however.\n+     */\n+    public JsonSerializer<?> createContextual(SerializerProvider prov,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        if (property != null) {\n+            JsonFormat.Value format = prov.getAnnotationIntrospector().findFormat((Annotated) property.getMember());\n+            if (format != null) {\n+                Boolean serializeAsIndex = _isShapeWrittenUsingIndex(property.getType().getRawClass(), format, false);\n+                if (serializeAsIndex != _serializeAsIndex) {\n+                    return new EnumSerializer(_values, serializeAsIndex);\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API for Jackson databind core\n+    /**********************************************************\n+     */\n+    \n+    public EnumValues getEnumValues() { return _values; }\n+\n+    /*\n+    /**********************************************************\n+    /* Actual serialization\n+    /**********************************************************\n+     */\n     \n     @Override\n     public final void serialize(Enum<?> en, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n         // [JACKSON-684]: serialize as index?\n-        if (provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n+        if (_serializeAsIndex(provider)) {\n             jgen.writeNumber(en.ordinal());\n             return;\n         }\n     public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n     {\n         // [JACKSON-684]: serialize as index?\n-        if (provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX)) {\n+        if (_serializeAsIndex(provider)) {\n             return createSchemaNode(\"integer\", true);\n         }\n         ObjectNode objectNode = createSchemaNode(\"string\", true);\n         return objectNode;\n     }\n \n-    public EnumValues getEnumValues() { return _values; }\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected final boolean _serializeAsIndex(SerializerProvider provider)\n+    {\n+        if (_serializeAsIndex != null) {\n+            return _serializeAsIndex.booleanValue();\n+        }\n+        return provider.isEnabled(SerializationFeature.WRITE_ENUMS_USING_INDEX);\n+        \n+    }\n+\n+    /**\n+     * Helper method called to check whether \n+     */\n+    protected static Boolean _isShapeWrittenUsingIndex(Class<?> enumClass,\n+            JsonFormat.Value format, boolean fromClass)\n+    {\n+        JsonFormat.Shape shape = (format == null) ? null : format.getShape();\n+        if (shape == null) {\n+            return null;\n+        }\n+        if (shape == Shape.ANY || shape == Shape.SCALAR) { // i.e. \"default\", check dynamically\n+            return null;\n+        }\n+        if (shape == Shape.STRING) {\n+            return Boolean.FALSE;\n+        }\n+        if (shape.isNumeric()) {\n+            return Boolean.TRUE;\n+        }\n+        throw new IllegalArgumentException(\"Unsupported serialization shape (\"+shape+\") for Enum \"+enumClass.getName()\n+                    +\", not supported as \"\n+                    + (fromClass? \"class\" : \"property\")\n+                    +\" annotation\");\n+    }\n }\n \n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n         \n         public void setX(int v) { value = v; }\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n+    final static ObjectMapper MAPPER = new ObjectMapper();\n     \n     public void testProps()\n     {\n \n     public void testSupport()\n     {\n-        ObjectMapper m = new ObjectMapper();\n-        assertTrue(m.canSerialize(String.class));\n-\n-        assertTrue(m.canDeserialize(TypeFactory.defaultInstance().constructType(String.class)));\n+        assertTrue(MAPPER.canSerialize(String.class));\n+        assertTrue(MAPPER.canDeserialize(TypeFactory.defaultInstance().constructType(String.class)));\n     }\n \n     public void testTreeRead() throws Exception\n     {\n-        ObjectMapper m = new ObjectMapper();\n         String JSON = \"{ }\";\n-        JsonNode n = m.readTree(JSON);\n+        JsonNode n = MAPPER.readTree(JSON);\n         assertTrue(n instanceof ObjectNode);\n \n-        n = m.readTree(new StringReader(JSON));\n+        n = MAPPER.readTree(new StringReader(JSON));\n         assertTrue(n instanceof ObjectNode);\n \n-        n = m.readTree(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\")));\n+        n = MAPPER.readTree(new ByteArrayInputStream(JSON.getBytes(\"UTF-8\")));\n         assertTrue(n instanceof ObjectNode);\n     }\n \n     public void testJsonFactoryLinkage()\n     {\n         // first, implicit factory, giving implicit linkage\n-        ObjectMapper m = new ObjectMapper();\n-        assertSame(m, m.getJsonFactory().getCodec());\n+        assertSame(MAPPER, MAPPER.getJsonFactory().getCodec());\n \n         // and then explicit factory, which should also be implicitly linked\n         JsonFactory f = new JsonFactory();\n-        m = new ObjectMapper(f);\n+        ObjectMapper m = new ObjectMapper(f);\n         assertSame(f, m.getJsonFactory());\n         assertSame(m, f.getCodec());\n     }\n      */\n     public void testProviderConfig() throws Exception   \n     {\n-        ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(0, mapper._deserializationContext._cache.cachedDeserializersCount());\n+        ObjectMapper m = new ObjectMapper();\n+\n+        assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n         // and then should get one constructed for:\n-        Bean bean = mapper.readValue(\"{ \\\"x\\\" : 3 }\", Bean.class);\n+        Bean bean = m.readValue(\"{ \\\"x\\\" : 3 }\", Bean.class);\n         assertNotNull(bean);\n-        assertEquals(1, mapper._deserializationContext._cache.cachedDeserializersCount());\n-        mapper._deserializationContext._cache.flushCachedDeserializers();\n-        assertEquals(0, mapper._deserializationContext._cache.cachedDeserializersCount());\n+        assertEquals(1, m._deserializationContext._cache.cachedDeserializersCount());\n+        m._deserializationContext._cache.flushCachedDeserializers();\n+        assertEquals(0, m._deserializationContext._cache.cachedDeserializersCount());\n+    }\n+    \n+    // [Issue#28]: ObjectMapper.copy()\n+    public void testCopy() throws Exception\n+    {\n+        ObjectMapper m = new ObjectMapper();\n+        assertTrue(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+        m.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n+        assertFalse(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+\n+        // // First: verify that handling of features is decoupled:\n+        \n+        ObjectMapper m2 = m.copy();\n+        assertFalse(m2.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+        m2.enable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);\n+        assertTrue(m2.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+        // but should NOT change the original\n+        assertFalse(m.isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES));\n+\n+        // nor vice versa:\n+        assertFalse(m.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));\n+        assertFalse(m2.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));\n+        m.enable(DeserializationFeature.UNWRAP_ROOT_VALUE);\n+        assertTrue(m.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));\n+        assertFalse(m2.isEnabled(DeserializationFeature.UNWRAP_ROOT_VALUE));\n+\n+        // // Also, underlying JsonFactory instances should be distinct\n+        \n+        assertNotSame(m.getJsonFactory(), m2.getJsonFactory());\n+\n+        // ... anything else? (probably should do more tests, add as needed)\n     }\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/module/TestKeyDeserializers.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.BaseMapTest;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.KeyDeserializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+public class TestKeyDeserializers extends BaseMapTest\n+{\n+    static class FooKeyDeserializer extends KeyDeserializer\n+    {\n+        @Override\n+        public Foo deserializeKey(String key, DeserializationContext ctxt)\n+        {\n+            return new Foo(key);\n+        }\n+    }\n+    \n+    static class Foo {\n+        public String value;\n+        \n+        public Foo(String v) { value = v; }\n+    }\n+    \n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testKeyDeserializers() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule mod = new SimpleModule(\"test\", Version.unknownVersion());\n+        mod.addKeyDeserializer(Foo.class, new FooKeyDeserializer());\n+        mapper.registerModule(mod);\n+        Map<Foo,Integer> map = mapper.readValue(\"{\\\"a\\\":3}\",\n+                new TypeReference<Map<Foo,Integer>>() {} );\n+        assertNotNull(map);\n+        assertEquals(1, map.size());\n+        Foo foo = map.keySet().iterator().next();\n+        assertEquals(\"a\", foo.value);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestCollectionSerialization.java\n         public String[] empty = new String[0];\n     }\n \n-    // [JACKSIN-689]\n+    // [JACKSON-689]\n     static class BeanWithIterable {\n         private final ArrayList<String> values = new ArrayList<String>();\n         {\n \n         public Iterable<String> getValues() { return values; }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Test methods\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestEnumSerialization.java\n import java.io.*;\n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonFormat;\n+import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.annotation.JsonValue;\n \n         OK(String key) { this.key = key; }\n     }\n     \n+    // Types for [https://github.com/FasterXML/jackson-databind/issues/24]\n+    // (Enums as JSON Objects)\n+\n+    @JsonFormat(shape=JsonFormat.Shape.OBJECT)\n+    static enum PoNUM {\n+        A(\"a1\"), B(\"b2\");\n+\n+        @JsonProperty\n+        protected final String value;\n+        \n+        private PoNUM(String v) { value = v; }\n+\n+        public String getValue() { return value; }\n+    }\n+\n+    static class PoNUMContainer {\n+        @JsonFormat(shape=Shape.NUMBER)\n+        public OK text = OK.V1;\n+    }\n+    \n+    @JsonFormat(shape=JsonFormat.Shape.ARRAY) // not supported as of now\n+    static enum BrokenPoNum\n+    {\n+        A, B;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Tests\n         assertEquals(quote(\"V1\"), mapper.writeValueAsString(OK.V1));\n         assertEquals(quote(\"V1\"), mapper.writeValueAsString(NOT_OK.V1));\n         assertEquals(quote(\"V2\"), mapper.writeValueAsString(NOT_OK2.V2));\n+    }\n+\n+    // Tests for [issue#24]\n+\n+    public void testEnumAsObjectValid() throws Exception {\n+        assertEquals(\"{\\\"value\\\":\\\"a1\\\"}\", mapper.writeValueAsString(PoNUM.A));\n+    }\n+\n+    public void testEnumAsIndexViaAnnotations() throws Exception {\n+        assertEquals(\"{\\\"text\\\":0}\", mapper.writeValueAsString(new PoNUMContainer()));\n+    }\n+    \n+    public void testEnumAsObjectBroken() throws Exception\n+    {\n+        try {\n+            String json = mapper.writeValueAsString(BrokenPoNum.A);\n+            fail(\"Should not have succeeded, produced: \"+json);\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Unsupported serialization shape\");\n+        }\n     }\n }\n \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestFormatForCollections.java\n+package com.fasterxml.jackson.databind.struct;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonFormat.Shape;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class TestFormatForCollections extends BaseMapTest\n+{\n+    // [issue#40]: Allow serialization 'as POJO' (resulting in JSON Object) \n+    @JsonPropertyOrder({ \"size\", \"value\" })\n+    @JsonFormat(shape=Shape.OBJECT)\n+    @JsonIgnoreProperties({ \"empty\" }) // from 'isEmpty()'\n+    static class CollectionAsPOJO\n+        extends ArrayList<String>\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        @JsonProperty(\"size\")\n+        public int foo() { return size(); }\n+        \n+        public List<String> getValues() {\n+            return new ArrayList<String>(this);\n+        }\n+\n+        public void setValues(List<String> v) {\n+            addAll(v);\n+        }\n+        \n+        // bogus setter to handle \"size\" property\n+        public void setSize(int i) { }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final static ObjectMapper MAPPER = new ObjectMapper();    \n+\n+\n+    // [Issue#40]\n+    public void testListAsObject() throws Exception\n+    {\n+        // First, serialize a \"POJO-List\"\n+        CollectionAsPOJO list = new CollectionAsPOJO();\n+        list.add(\"a\");\n+        list.add(\"b\");\n+        String json = MAPPER.writeValueAsString(list);\n+        assertEquals(\"{\\\"size\\\":2,\\\"values\\\":[\\\"a\\\",\\\"b\\\"]}\", json);\n+\n+        // and then bring it back!\n+        CollectionAsPOJO result = MAPPER.readValue(json, CollectionAsPOJO.class);\n+        assertEquals(2, result.size());\n+    }\n+\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java\n \n /**\n  * Sub-class of {@link JsonFactory} that will create a proper\n- * {@link ObjectCodec} to allow seamless conversions between\n- * Json content and Java objects (POJOs).\n+ * {@link ObjectCodec} to allow seam-less conversions between\n+ * JSON content and Java objects (POJOs).\n  * The only addition to regular {@link JsonFactory} currently\n  * is that {@link ObjectMapper} is constructed and passed as\n  * the codec to use.\n     @Override\n     public MatchStrength hasFormat(InputAccessor acc) throws IOException\n     {\n-        return hasJSONFormat(acc);\n+        if (getClass() == MappingJsonFactory.class) {\n+            return hasJSONFormat(acc);\n+        }\n+        return null;\n     }\n }", "timestamp": 1344440245, "metainfo": ""}