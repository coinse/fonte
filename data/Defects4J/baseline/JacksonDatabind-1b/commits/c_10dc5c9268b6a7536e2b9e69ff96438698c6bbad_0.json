{"sha": "10dc5c9268b6a7536e2b9e69ff96438698c6bbad", "log": "Implement #199, support for deserializing Iterable", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n  * no additional introspection or customizability of these types,\n  * this factory is stateless.\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class BasicDeserializerFactory\n     extends DeserializerFactory\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 1;\n-\n+    private final static Class<?> CLASS_OBJECT = Object.class;\n+    private final static Class<?> CLASS_STRING = String.class;\n+    private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n+    private final static Class<?> CLASS_ITERABLE = Iterable.class;\n+    \n     /**\n      * Also special array deserializers for primitive array types.\n      */\n     /* JsonDeserializerFactory impl: Collection(-like) deserializers\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt,\n             CollectionType type, BeanDescription beanDesc)\n          */\n         if (deser == null) {\n             if (type.isInterface() || type.isAbstract()) {\n-                Class<?> collectionClass = type.getRawClass();\n-                @SuppressWarnings({ \"rawtypes\" })\n-                Class<? extends Collection> fallback = _collectionFallbacks.get(collectionClass.getName());\n-                if (fallback == null) {\n+                CollectionType implType = _mapAbstractCollectionType(type, config);\n+                if (implType == null) {\n                     throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n                 }\n-                collectionClass = fallback;\n-                type = (CollectionType) config.constructSpecializedType(type, collectionClass);\n+                type = implType;\n                 // But if so, also need to re-check creators...\n                 beanDesc = config.introspectForCreation(type);\n             }\n             }\n         }\n         return deser;\n+    }\n+\n+    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)\n+    {\n+        Class<?> collectionClass = type.getRawClass();\n+        collectionClass = _collectionFallbacks.get(collectionClass.getName());\n+        if (collectionClass == null) {\n+            return null;\n+        }\n+        return (CollectionType) config.constructSpecializedType(type, collectionClass);\n     }\n \n     protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n         return b.buildTypeDeserializer(config, contentType, subtypes);\n     }\n \n-    private final static Class<?> CLASS_OBJECT = Object.class;\n-    private final static Class<?> CLASS_STRING = String.class;\n-    private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n-\n     /**\n      * Helper method called to find one of default serializers for \"well-known\"\n      * platform types: JDK-provided types, and small number of public Jackson\n      * \n      * @since 2.2\n      */\n-    public JsonDeserializer<?> findDefaultSerializer(Class<?> rawType)\n-    {\n+    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n+            JavaType type, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        Class<?> rawType = type.getRawClass();\n         String clsName = rawType.getName();\n         if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n             // Object (\"untyped\"), String equivalents:\n             }\n             if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                 return StringDeserializer.instance;\n+            }\n+            if (rawType == CLASS_ITERABLE) {\n+                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n+                TypeFactory tf = ctxt.getTypeFactory();\n+                JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType();\n+                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n+                // Should we re-introspect beanDesc? For now let's not...\n+                return createCollectionDeserializer(ctxt, ct, beanDesc);\n             }\n             // Primitives/wrappers, other Numbers:\n             JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n          */\n         if (type.isAbstract()) {\n             // [JACKSON-41] (v1.6): Let's make it possible to materialize abstract types.\n-            JavaType concreteType = materializeAbstractType(config, beanDesc);\n+            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n             if (concreteType != null) {\n                 /* important: introspect actual implementation (abstract class or\n                  * interface doesn't have constructors, for one)\n         }\n \n         // Otherwise, may want to check handlers for standard types, from superclass:\n-        JsonDeserializer<Object> deser = findStdDeserializer(config, type);\n+        JsonDeserializer<Object> deser = findStdDeserializer(ctxt, type, beanDesc);\n         if (deser != null) {\n             return deser;\n         }\n      * deserializer registered for given type.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected JsonDeserializer<Object> findStdDeserializer(DeserializationConfig config,\n-            JavaType type)\n-        throws JsonMappingException\n-    {\n-        Class<?> cls = type.getRawClass();\n+    protected JsonDeserializer<Object> findStdDeserializer(DeserializationContext ctxt,\n+            JavaType type, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n         // note: we do NOT check for custom deserializers here; that's for sub-class to do\n-        JsonDeserializer<?> deser = findDefaultSerializer(cls);\n+        JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n         if (deser != null) {\n             return (JsonDeserializer<Object>) deser;\n         }\n         \n+        Class<?> cls = type.getRawClass();\n         // [JACKSON-283]: AtomicReference is a rather special type...\n         if (AtomicReference.class.isAssignableFrom(cls)) {\n             // Must find parameterization\n-            TypeFactory tf = config.getTypeFactory();\n+            TypeFactory tf = ctxt.getTypeFactory();\n             JavaType[] params = tf.findTypeParameters(type, AtomicReference.class);\n             JavaType referencedType;\n             if (params == null || params.length < 1) { // untyped (raw)\n             return (JsonDeserializer<Object>)d2;\n         }\n         // [JACKSON-386]: External/optional type handlers are handled somewhat differently\n-        JsonDeserializer<?> d = optionalHandlers.findDeserializer(type, config);\n+        JsonDeserializer<?> d = optionalHandlers.findDeserializer(type, ctxt.getConfig());\n         if (d != null) {\n             return (JsonDeserializer<Object>)d;\n         }\n         return null;\n     }\n     \n-    protected JavaType materializeAbstractType(DeserializationConfig config,\n-            BeanDescription beanDesc)\n+    protected JavaType materializeAbstractType(DeserializationContext ctxt,\n+            JavaType type, BeanDescription beanDesc)\n         throws JsonMappingException\n     {\n         final JavaType abstractType = beanDesc.getType();\n-        \n-        /* [JACKSON-502] (1.8): Now it is possible to have multiple resolvers too,\n-         *   as they are registered via module interface.\n-         */\n+        // [JACKSON-502]: Now it is possible to have multiple resolvers too,\n+        //   as they are registered via module interface.\n         for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {\n-            JavaType concrete = r.resolveAbstractType(config, abstractType);\n+            JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), abstractType);\n             if (concrete != null) {\n                 return concrete;\n             }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n \n     static class XBean {\n         public int x;\n+    }\n+\n+    // [Issue#199]\n+    static class ListAsIterable {\n+        public Iterable<String> values;\n+    }\n+\n+    static class ListAsIterableX {\n+        public Iterable<XBean> nums;\n     }\n     \n     /*\n         assertEquals(Integer.valueOf(2), q.take());\n         assertEquals(Integer.valueOf(3), q.take());\n     }\n+\n+    // [Issue#199]\n+    public void testIterableWithStrings() throws Exception\n+    {\n+        String JSON = \"{ \\\"values\\\":[\\\"a\\\",\\\"b\\\"]}\";\n+        ListAsIterable w = MAPPER.readValue(JSON, ListAsIterable.class);\n+        assertNotNull(w);\n+        assertNotNull(w.values);\n+        Iterator<String> it = w.values.iterator();\n+        assertTrue(it.hasNext());\n+        assertEquals(\"a\", it.next());\n+        assertEquals(\"b\", it.next());\n+        assertFalse(it.hasNext());\n+    }\n+\n+    public void testIterableWithBeans() throws Exception\n+    {\n+        String JSON = \"{ \\\"nums\\\":[{\\\"x\\\":1},{\\\"x\\\":2}]}\";\n+        ListAsIterableX w = MAPPER.readValue(JSON, ListAsIterableX.class);\n+        assertNotNull(w);\n+        assertNotNull(w.nums);\n+        Iterator<XBean> it = w.nums.iterator();\n+        assertTrue(it.hasNext());\n+        XBean xb = it.next();\n+        assertNotNull(xb);\n+        assertEquals(1, xb.x);\n+        xb = it.next();\n+        assertEquals(2, xb.x);\n+        assertFalse(it.hasNext());\n+    }\n }", "timestamp": 1365376270, "metainfo": ""}