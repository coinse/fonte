{"sha": "e7d0a56902774041e70be12dd8acef38f326a253", "log": "Try to refactor BeanDeserializers to share more (i.e. demote to -Base)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n         JsonToken t = jp.getCurrentToken();\n         // common case first:\n         if (t == JsonToken.START_OBJECT) {\n-            t = jp.nextToken();\n             if (_vanillaProcessing) {\n-                return vanillaDeserialize(jp, ctxt, t);\n-            }\n+                return vanillaDeserialize(jp, ctxt, jp.nextToken());\n+            }\n+            jp.nextToken();\n             if (_objectIdReader != null) {\n                 return deserializeWithObjectId(jp, ctxt);\n             }\n             return deserializeFromObject(jp, ctxt);\n         }\n+        return _deserializeOther(jp, ctxt, t);\n+    }\n+    \n+    private final Object _deserializeOther(JsonParser jp, DeserializationContext ctxt,\n+            JsonToken t)\n+        throws IOException, JsonProcessingException\n+    {\n         if (t == null) {\n             return _missingToken(jp, ctxt);\n         }\n                 return deserializeWithObjectId(jp, ctxt);\n             }\n             return deserializeFromObject(jp, ctxt);\n-\t}\n+        }\n         throw ctxt.mappingException(getBeanClass());\n     }\n \n-    private Object _missingToken(JsonParser jp, DeserializationContext ctxt)\n+    protected Object _missingToken(JsonParser jp, DeserializationContext ctxt)\n         throws JsonProcessingException\n     {\n         throw ctxt.endOfInputException(getBeanClass());\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             } else {\n-                _vanillaDeserializeHandleUnknown(jp, ctxt, bean, propName);\n+                handleUnknownVanilla(jp, ctxt, bean, propName);\n             }\n         }\n         return bean;\n-    }\n-\n-    /**\n-     * Helper method called for an unknown property, when using \"vanilla\"\n-     * processing.\n-     */\n-    private final void _vanillaDeserializeHandleUnknown(JsonParser jp, DeserializationContext ctxt,\n-            Object bean, String propName)\n-        throws IOException, JsonProcessingException\n-    {\n-        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-            jp.skipChildren();\n-        } else if (_anySetter != null) {\n-            try {\n-                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n-            } catch (Exception e) {\n-                wrapAndThrow(e, bean, propName, ctxt);\n-            }\n-        } else {\n-            // Unknown: let's call handler method\n-            handleUnknownProperty(jp, ctxt, bean, propName);         \n-        }\n     }\n \n     /**\n         mergedParser.nextToken();\n         return deserializeFromObject(mergedParser, ctxt);\n     }\n-\n-    protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {        \n-        if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-        }\n-        if (_propertyBasedCreator != null) {\n-            return _deserializeUsingPropertyBased(jp, ctxt);\n-        }\n-        // should only occur for abstract types...\n-        if (_beanType.isAbstract()) {\n-            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n-                    +\" (need to add/enable type information?)\");\n-        }\n-        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n-                +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n-    }\n     \n     public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n-    \tif (_delegateDeserializer != null) {\n-    \t    try {\n-    \t        Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-    \t        if (_injectables != null) {\n-    \t            injectValues(ctxt, bean);\n-    \t        }\n-    \t        return bean;\n+        if (_delegateDeserializer != null) {\n+            try {\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                if (_injectables != null) {\n+                    injectValues(ctxt, bean);\n+                }\n+                return bean;\n             } catch (Exception e) {\n                 wrapInstantiationProblem(e, ctxt);\n             }\n-    \t}\n-    \tthrow ctxt.mappingException(getBeanClass());\n-    }\n-\n+        }\n+        throw ctxt.mappingException(getBeanClass());\n+    }\n     /**\n      * Method called to deserialize bean using \"property-based creator\":\n      * this means that a non-default constructor or factory method is\n      * due to non-guaranteed ordering possibly some other properties\n      * as well.\n      */\n-    protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n+    protected Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     { \n         final PropertyBasedCreator creator = _propertyBasedCreator;\n                 buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n                 continue;\n             }\n-            /* As per [JACKSON-313], things marked as ignorable should not be\n-             * passed to any setter\n-             */\n+            // As per [JACKSON-313], things marked as ignorable should not be\n+            // passed to any setter\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                 jp.skipChildren();\n                 continue;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n         }\n         return pojo;\n     }\n+\n+    protected Object deserializeFromObjectUsingNonDefault(JsonParser jp,\n+            DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {        \n+        if (_delegateDeserializer != null) {\n+            return _valueInstantiator.createUsingDelegate(ctxt,\n+                    _delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        if (_propertyBasedCreator != null) {\n+            return _deserializeUsingPropertyBased(jp, ctxt);\n+        }\n+        // should only occur for abstract types...\n+        if (_beanType.isAbstract()) {\n+            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+                    +\" (need to add/enable type information?)\");\n+        }\n+        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+                +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n+    }\n+\n+    protected abstract Object _deserializeUsingPropertyBased(final JsonParser jp,\n+            final DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException;\n     \n     /*\n     /**********************************************************\n             // Unknown: let's call handler method\n             bufferParser.nextToken();\n             handleUnknownProperty(bufferParser, ctxt, bean, propName);\n+        }\n+        return bean;\n+    }\n+\n+    /**\n+     * Helper method called for an unknown property, when using \"vanilla\"\n+     * processing.\n+     */\n+    protected void handleUnknownVanilla(JsonParser jp, DeserializationContext ctxt,\n+            Object bean, String propName)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+            jp.skipChildren();\n+        } else if (_anySetter != null) {\n+            try {\n+               // should we consider return type of any setter?\n+                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+            } catch (Exception e) {\n+                wrapAndThrow(e, bean, propName, ctxt);\n+            }\n+        } else {\n+            // Unknown: let's call handler method\n+            handleUnknownProperty(jp, ctxt, bean, propName);         \n+        }\n+    }\n+\n+    /**\n+     * Method called in cases where we may have polymorphic deserialization\n+     * case: that is, type of Creator-constructed bean is not the type\n+     * of deserializer itself. It should be a sub-class or implementation\n+     * class; either way, we may have more specific deserializer to use\n+     * for handling it.\n+     *\n+     * @param jp (optional) If not null, parser that has more properties to handle\n+     *   (in addition to buffered properties); if null, all properties are passed\n+     *   in buffer\n+     */\n+    protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt,                                          \n+            Object bean, TokenBuffer unknownTokens)\n+        throws IOException, JsonProcessingException\n+    {  \n+        // First things first: maybe there is a more specific deserializer available?\n+        JsonDeserializer<Object> subDeser = _findSubclassDeserializer(ctxt, bean, unknownTokens);\n+        if (subDeser != null) {\n+            if (unknownTokens != null) {\n+                // need to add END_OBJECT marker first\n+                unknownTokens.writeEndObject();\n+                JsonParser p2 = unknownTokens.asParser();\n+                p2.nextToken(); // to get to first data field\n+                bean = subDeser.deserialize(p2, ctxt, bean);\n+            }\n+            // Original parser may also have some leftovers\n+            if (jp != null) {\n+                bean = subDeser.deserialize(jp, ctxt, bean);\n+            }\n+            return bean;\n+        }\n+        // nope; need to use this deserializer. Unknowns we've seen so far?\n+        if (unknownTokens != null) {\n+            bean = handleUnknownProperties(ctxt, bean, unknownTokens);\n+        }\n+        // and/or things left to process via main parser?\n+        if (jp != null) {\n+            bean = deserialize(jp, ctxt, bean);\n         }\n         return bean;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n                     wrapAndThrow(e, bean, propName, ctxt);\n                 }\n             } else {\n-                _vanillaDeserializeHandleUnknown(jp, ctxt, bean, propName);\n+                handleUnknownVanilla(jp, ctxt, bean, propName);\n             }\n         }\n         return bean;\n-    }\n-\n-    /**\n-     * Helper method called for an unknown property, when using \"vanilla\"\n-     * processing.\n-     */\n-    private final void _vanillaDeserializeHandleUnknown(JsonParser jp, DeserializationContext ctxt,\n-            Object bean, String propName)\n-        throws IOException, JsonProcessingException\n-    {\n-        if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n-            jp.skipChildren();\n-        } else if (_anySetter != null) {\n-            try {\n-            \t// should we consider return type of any setter?\n-                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n-            } catch (Exception e) {\n-                wrapAndThrow(e, bean, propName, ctxt);\n-            }\n-        } else {\n-            // Unknown: let's call handler method\n-            handleUnknownProperty(jp, ctxt, bean, propName);         \n-        }\n     }\n \n     /**\n             }\n         }\n         return bean;\n-    }\n-\n-    protected Object deserializeFromObjectUsingNonDefault(JsonParser jp,\n-            DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n-    {        \n-        if (_delegateDeserializer != null) {\n-            return _valueInstantiator.createUsingDelegate(ctxt,\n-                    _delegateDeserializer.deserialize(jp, ctxt));\n-        }\n-        if (_propertyBasedCreator != null) {\n-            return _deserializeUsingPropertyBased(jp, ctxt);\n-        }\n-        // should only occur for abstract types...\n-        if (_beanType.isAbstract()) {\n-            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n-                    +\" (need to add/enable type information?)\");\n-        }\n-        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n-                +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n     }\n     \n     public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt)\n     public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n     {\n-    \tif (_delegateDeserializer != null) {\n-    \t    try {\n-    \t        Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n-    \t        if (_injectables != null) {\n-    \t            injectValues(ctxt, bean);\n-    \t        }\n-    \t        return bean;\n+        if (_delegateDeserializer != null) {\n+            try {\n+                Object bean = _valueInstantiator.createUsingDelegate(ctxt, _delegateDeserializer.deserialize(jp, ctxt));\n+                if (_injectables != null) {\n+                    injectValues(ctxt, bean);\n+                }\n+                return bean;\n             } catch (Exception e) {\n                 wrapInstantiationProblem(e, ctxt);\n             }\n-    \t}\n-    \tthrow ctxt.mappingException(getBeanClass());\n+        }\n+        throw ctxt.mappingException(getBeanClass());\n     }\n \n     /**\n                 buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n                 continue;\n             }\n-            /* As per [JACKSON-313], things marked as ignorable should not be\n-             * passed to any setter\n-             */\n+            // As per [JACKSON-313], things marked as ignorable should not be\n+            // passed to any setter\n             if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n                 jp.skipChildren();\n                 continue;\n             }\n             // no, just some extra unknown properties\n             return handleUnknownProperties(ctxt, bean, unknown);\n-        }\n-        return bean;\n-    }\n-\n-    /**\n-     * Method called in cases where we may have polymorphic deserialization\n-     * case: that is, type of Creator-constructed bean is not the type\n-     * of deserializer itself. It should be a sub-class or implementation\n-     * class; either way, we may have more specific deserializer to use\n-     * for handling it.\n-     *\n-     * @param jp (optional) If not null, parser that has more properties to handle\n-     *   (in addition to buffered properties); if null, all properties are passed\n-     *   in buffer\n-     */\n-    protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt,                                          \n-            Object bean, TokenBuffer unknownTokens)\n-        throws IOException, JsonProcessingException\n-    {  \n-        // First things first: maybe there is a more specific deserializer available?\n-        JsonDeserializer<Object> subDeser = _findSubclassDeserializer(ctxt, bean, unknownTokens);\n-        if (subDeser != null) {\n-            if (unknownTokens != null) {\n-                // need to add END_OBJECT marker first\n-                unknownTokens.writeEndObject();\n-                JsonParser p2 = unknownTokens.asParser();\n-                p2.nextToken(); // to get to first data field\n-                bean = subDeser.deserialize(p2, ctxt, bean);\n-            }\n-            // Original parser may also have some leftovers\n-            if (jp != null) {\n-                bean = subDeser.deserialize(jp, ctxt, bean);\n-            }\n-            return bean;\n-        }\n-        // nope; need to use this deserializer. Unknowns we've seen so far?\n-        if (unknownTokens != null) {\n-            bean = handleUnknownProperties(ctxt, bean, unknownTokens);\n-        }\n-        // and/or things left to process via main parser?\n-        if (jp != null) {\n-            bean = deserialize(jp, ctxt, bean);\n         }\n         return bean;\n     }", "timestamp": 1353178925, "metainfo": ""}