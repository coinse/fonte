{"sha": "9bde207392ec60b57a803b53b915a1a8524d2897", "log": "improve diagnostics by making BeanPropertyMap printable", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n-\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n-        \n         for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n             String propName = jp.getCurrentName();\n             jp.nextToken();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n      */\n     public BeanPropertyMap withProperty(SettableBeanProperty newProperty)\n     {\n-    \t// first things first: can just copy hash area:\n-    \tfinal int bcount = _buckets.length;\n+        // first things first: can just copy hash area:\n+        final int bcount = _buckets.length;\n         Bucket[] newBuckets = new Bucket[bcount];\n         System.arraycopy(_buckets, 0, newBuckets, 0, bcount);\n         final String propName = newProperty.getName();\n         // and then see if it's add or replace:\n-    \tSettableBeanProperty oldProp = find(newProperty.getName());\n-    \tif (oldProp == null) { // add\n-    \t    // first things first: add or replace?\n-    \t    // can do a straight copy, since all additions are at the front\n-    \t    // and then insert the new property:\n-    \t    int index = propName.hashCode() & _hashMask;\n-    \t    newBuckets[index] = new Bucket(newBuckets[index],\n-    \t            propName, newProperty, _nextBucketIndex++);\n-    \t    return new BeanPropertyMap(newBuckets, _size+1, _nextBucketIndex);\n-    \t}\n-    \t// replace: easy, close + replace\n-    \tBeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex);\n-    \tnewMap.replace(newProperty);\n-    \treturn newMap;\n-    }\n-    \n+        SettableBeanProperty oldProp = find(newProperty.getName());\n+        if (oldProp == null) { // add\n+            // first things first: add or replace?\n+    \t        // can do a straight copy, since all additions are at the front\n+    \t        // and then insert the new property:\n+    \t        int index = propName.hashCode() & _hashMask;\n+    \t        newBuckets[index] = new Bucket(newBuckets[index],\n+    \t                propName, newProperty, _nextBucketIndex++);\n+    \t        return new BeanPropertyMap(newBuckets, _size+1, _nextBucketIndex);\n+        }\n+        // replace: easy, close + replace\n+        BeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex);\n+        newMap.replace(newProperty);\n+        return newMap;\n+    }\n+\n     /**\n      * Factory method for constructing a map where all entries use given\n      * prefix\n     /**********************************************************\n      */\n \n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"Properties=[\");\n+        int count = 0;\n+        for (SettableBeanProperty prop : getPropertiesInInsertionOrder()) {\n+            if (prop == null) {\n+                continue;\n+            }\n+            if (count++ > 0) {\n+                sb.append(\", \");\n+            }\n+            sb.append(prop.getName());\n+            sb.append('(');\n+            sb.append(prop.getType());\n+            sb.append(')');\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+    \n     /**\n      * Accessor for traversing over all contained properties.\n      */", "timestamp": 1365461697, "metainfo": ""}