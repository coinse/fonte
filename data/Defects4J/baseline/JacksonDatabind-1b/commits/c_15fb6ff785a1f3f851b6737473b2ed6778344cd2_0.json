{"sha": "15fb6ff785a1f3f851b6737473b2ed6778344cd2", "log": "Implement [JACKSON-710]: avoid wrapping/unwrapping with ObjectMapper.convertValue()", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n  * instance. This because some objects may be configured, constructed and\n  * cached first time they are needed.\n  *<p>\n- * As of version 1.9, the goal is to make this class eventually immutable.\n- * Because of this, existing methods that allow changing state of this\n- * instance are deprecated in favor of methods that create new instances\n- * with different configuration (\"fluent factories\")\n+ * Note: as of 2.0, goal is still to make config instances fully immutable.\n  */\n public class DeserializationConfig\n     extends MapperConfig.Impl<DeserializationConfig.Feature, DeserializationConfig>\n          * no annotations are considered.\n          *<P>\n          * Feature is enabled by default.\n-         *\n-         * @since 1.2\n          */\n         USE_ANNOTATIONS(true),\n \n          * configuration available.\n          *<P>\n          * Feature is enabled by default.\n-         *\n-         * @since 1.1\n          */\n         AUTO_DETECT_FIELDS(true),\n \n          *<p>\n          * Feature is disabled by default, meaning that JSON arrays are bound as\n          * {@link java.util.List}s.\n-         * \n-         * @since 1.9\n          */\n         USE_JAVA_ARRAY_FOR_JSON_ARRAY(false),\n         \n          * as {@link SerializationConfig.Feature#WRITE_ENUMS_USING_TO_STRING}.\n          *<p>\n          * For further details, check out [JACKSON-212]\n-         * \n-         * @since 1.6\n          */\n         READ_ENUMS_USING_TO_STRING(false),\n         \n          * {@link JsonMappingException} is thrown if an unknown property\n          * is encountered. This is the implicit default prior to\n          * introduction of the feature.\n-         *\n-         * @since 1.2\n          */\n         FAIL_ON_UNKNOWN_PROPERTIES(true),\n \n          * is thrown to indicate this; if not, default value is used\n          * (0 for 'int', 0.0 for double, same defaulting as what JVM uses).\n          *<p>\n-         * Feature is disabled by default (to be consistent with behavior\n-         * of Jackson 1.6),\n+         * Feature is disabled by default,\n          * i.e. to allow use of nulls for primitive properties.\n-         * \n-         * @since 1.7\n          */\n         FAIL_ON_NULL_FOR_PRIMITIVES(false),\n \n          * mapping from integer values to enums might happen (and when enums\n          * are always serialized as JSON Strings)\n          *<p>\n-         * Feature is disabled by default (to be consistent with behavior\n-         * of Jackson 1.6), \n+         * Feature is disabled by default\n          * i.e. to allow use of JSON integers for Java enums.\n-         * \n-         * @since 1.7\n          */\n         FAIL_ON_NUMBERS_FOR_ENUMS(false),\n \n          *<p>\n          * Feature is enabled by default, and is similar in behavior\n          * to default prior to 1.7.\n-         * \n-         * @since 1.7\n          */\n         WRAP_EXCEPTIONS(true),\n         \n          * This feature is meant to be used for compatibility/interoperability reasons,\n          * to work with packages (such as XML-to-JSON converters) that leave out JSON\n          * array in cases where there is just a single element in array.\n-         * \n-         * @since 1.8\n          */\n         ACCEPT_SINGLE_VALUE_AS_ARRAY(false),\n         \n          * a single property with expected root name. If not, a\n          * {@link JsonMappingException} is thrown; otherwise value of the wrapped property\n          * will be deserialized as if it was the root value.\n-         * \n-         * @since 1.9\n          */\n         UNWRAP_ROOT_VALUE(false),\n \n          * constructors are defined; both of which can add support for other\n          * kinds of JSON values); if enable, empty JSON String can be taken\n          * to be equivalent of JSON null.\n-         * \n-         * @since 1.8\n          */\n         ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false)\n         \n         _nodeFactory = JsonNodeFactory.instance;\n     }\n     \n-    /**\n-     * @since 1.8\n-     */\n     protected DeserializationConfig(DeserializationConfig src) {\n         this(src, src._base);\n     }\n     /**\n      * Copy constructor used to create a non-shared instance with given mix-in\n      * annotation definitions and subtype resolver.\n-     * \n-     * @since 1.8\n      */\n     private DeserializationConfig(DeserializationConfig src,\n             HashMap<ClassKey,Class<?>> mixins, SubtypeResolver str)\n         _mixInAnnotations = mixins;\n         _subtypeResolver = str;\n     }\n-    \n-    /**\n-     * @since 1.8\n-     */\n-    protected DeserializationConfig(DeserializationConfig src, MapperConfig.Base base)\n-    {\n-        super(src, base, src._subtypeResolver);\n+\n+    private DeserializationConfig(DeserializationConfig src,\n+            HashMap<ClassKey,Class<?>> mixins, SubtypeResolver str,\n+            int features)\n+    {\n+        super(src, src._base, str, features);\n+\n         _problemHandlers = src._problemHandlers;\n         _nodeFactory = src._nodeFactory;\n         _sortPropertiesAlphabetically = src._sortPropertiesAlphabetically;\n-    }\n-    \n-    /**\n-     * @since 1.8\n-     */\n+\n+        _mixInAnnotations = mixins;\n+    }\n+    \n+    protected DeserializationConfig(DeserializationConfig src, MapperConfig.Base base)\n+    {\n+        super(src, base, src._subtypeResolver, src._featureFlags);\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+        _sortPropertiesAlphabetically = src._sortPropertiesAlphabetically;\n+    }\n+    \n     protected DeserializationConfig(DeserializationConfig src, JsonNodeFactory f)\n     {\n         super(src);\n         _sortPropertiesAlphabetically = src._sortPropertiesAlphabetically;\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     protected DeserializationConfig(DeserializationConfig src, int featureFlags)\n     {\n         super(src, featureFlags);\n      * Helper method to be called right after creating a non-shared\n      * instance, needed to pass state of feature(s) shared with\n      * SerializationConfig.\n-     * \n-     * Since 1.9\n      */\n     protected DeserializationConfig passSerializationFeatures(int serializationFeatureFlags)\n     {\n     /**\n      * Fluent factory method that will construct a new instance with\n      * specified {@link JsonNodeFactory}\n-     * \n-     * @since 1.8\n      */\n     public DeserializationConfig withNodeFactory(JsonNodeFactory f) {\n         return new DeserializationConfig(this, f);\n     /**\n      * Fluent factory method that will construct and return a new configuration\n      * object instance with specified features enabled.\n-     * \n-     * @since 1.9\n      */\n     @Override\n     public DeserializationConfig with(DeserializationConfig.Feature... features)\n     /**\n      * Fluent factory method that will construct and return a new configuration\n      * object instance with specified features disabled.\n-     * \n-     * @since 1.9\n      */\n     @Override\n     public DeserializationConfig without(DeserializationConfig.Feature... features)\n         return new DeserializationConfig(this, mixins, subtypeResolver);\n     }\n \n+\n+    @Override\n+    public DeserializationConfig createUnshared(SubtypeResolver subtypeResolver, int features) {\n+        HashMap<ClassKey,Class<?>> mixins = _mixInAnnotations;\n+        // ensure that we assume sharing at this point:\n+        _mixInAnnotationsShared = true;\n+        return new DeserializationConfig(this, mixins, subtypeResolver, features);\n+    }\n+    \n     /**\n      * Method for getting {@link AnnotationIntrospector} configured\n      * to introspect annotation values used for configuration.\n     /**\n      * Accessor for getting bean description that only contains class\n      * annotations: useful if no getter/setter/creator information is needed.\n-     *<p>\n-     * Note: part of {@link MapperConfig} since 1.7\n      */\n     @SuppressWarnings(\"unchecked\")\n     @Override\n      * Accessor for getting bean description that only contains immediate class\n      * annotations: ones from the class, and its direct mix-in, if any, but\n      * not from super types.\n-     *<p>\n-     * Note: part of {@link MapperConfig} since 1.7\n      */\n     @Override\n     @SuppressWarnings(\"unchecked\")\n     /* MapperConfig overrides for 1.8 backwards compatibility\n     /**********************************************************\n      */\n-\n-    /* NOTE: these are overloads we MUST have, but that were missing\n-     * from 1.9.0 and 1.9.1. Type erasure can bite in the ass...\n-     *<p>\n-     * NOTE: will remove either these variants, or base class one, in 2.0.\n-     */\n     \n     /**\n      * An overload for {@link MapperConfig#isEnabled(MapperConfig.ConfigFeature)},\n      * needed for backwards-compatibility.\n-     *<p>\n-     * NOTE: will remove either this variant, or base class one, in 2.0./\n-     * \n-     * @since 1.0 However, note that version 1.9.0 and 1.9.1 accidentally missed\n-     *    this overloaded variant\n      */\n     public boolean isEnabled(DeserializationConfig.Feature f) {\n         return (_featureFlags & f.getMask()) != 0;\n     /**\n      * Method for removing all configured problem handlers; usually done to replace\n      * existing handler(s) with different one(s)\n-     *\n-     * @since 1.1\n      */\n     public void clearHandlers()\n     {\n         return Base64Variants.getDefaultVariant();\n     }\n \n-    /**\n-     * @since 1.6\n-     */\n     public final JsonNodeFactory getNodeFactory() {\n         return _nodeFactory;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/MapperConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperConfig.java\n     public abstract T createUnshared(SubtypeResolver subtypeResolver);\n \n     /**\n+     * Method to use for constructing an instance that is not shared\n+     * between multiple operations but only used for a single one\n+     * (which may be this instance, if it is immutable; if not, a copy\n+     * is constructed with same settings)\n+     */\n+    public abstract T createUnshared(SubtypeResolver subtypeResolver, int features);\n+    \n+    /**\n      * Method for constructing and returning a new instance with different\n      * {@link ClassIntrospector}\n      * to use.\n      * Accessor for object used for finding out all reachable subtypes\n      * for supertypes; needed when a logical type name is used instead\n      * of class name (or custom scheme).\n-     * \n-     * @since 1.6\n      */\n     public final SubtypeResolver getSubtypeResolver() {\n         if (_subtypeResolver == null) {\n         return _subtypeResolver;\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     public final TypeFactory getTypeFactory() {\n         return _base.getTypeFactory();\n     }\n      *<pre>\n      *    getTypeFactory().constructType(cls);\n      *</pre>\n-     * \n-     * @since 1.8\n      */\n     public final JavaType constructType(Class<?> cls) {\n         return getTypeFactory().constructType(cls, (TypeBindings) null);\n      *<pre>\n      *    getTypeFactory().constructType(valueTypeRef);\n      *</pre>\n-     * \n-     * @since 1.9\n      */\n     public final JavaType constructType(TypeReference<?> valueTypeRef) {\n         return getTypeFactory().constructType(valueTypeRef.getType(), (TypeBindings) null);\n     }\n \n-    /**\n-     * @since 1.9.1\n-     */\n     public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n         return getTypeFactory().constructSpecializedType(baseType, subclass);\n     }\n     /**\n      * Accessor for getting bean description that only contains class\n      * annotations: useful if no getter/setter/creator information is needed.\n-     * \n-     * @since 1.7\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <DESC extends BeanDescription> DESC introspectClassAnnotations(Class<?> cls) {\n     /**\n      * Accessor for getting bean description that only contains class\n      * annotations: useful if no getter/setter/creator information is needed.\n-     * \n-     * @since 1.9\n      */\n     public abstract <DESC extends BeanDescription> DESC introspectClassAnnotations(JavaType type);\n \n      * Accessor for getting bean description that only contains immediate class\n      * annotations: ones from the class, and its direct mix-in, if any, but\n      * not from super types.\n-     * \n-     * @since 1.7\n      */\n     @SuppressWarnings(\"unchecked\")\n     public <DESC extends BeanDescription> DESC introspectDirectClassAnnotations(Class<?> cls) {\n     /**\n      * Method that can be called to obtain an instance of <code>TypeIdResolver</code> of\n      * specified type.\n-     * \n-     * @since 1.8\n      */\n     public TypeResolverBuilder<?> typeResolverBuilderInstance(Annotated annotated,\n             Class<? extends TypeResolverBuilder<?>> builderClass)\n     /**\n      * Method that can be called to obtain an instance of <code>TypeIdResolver</code> of\n      * specified type.\n-     * \n-     * @since 1.8\n      */\n     public TypeIdResolver typeIdResolverInstance(Annotated annotated,\n             Class<? extends TypeIdResolver> resolverClass)\n          * that this is the global handler; individual types (classes)\n          * can further override active checker used (using\n          * {@link JsonAutoDetect} annotation)\n-         * \n-         * @since 1.5\n          */\n         protected final VisibilityChecker<?> _visibilityChecker;\n \n         /**\n          * Custom property naming strategy in use, if any.\n-         * \n-         * @since 1.8\n          */\n         protected final PropertyNamingStrategy _propertyNamingStrategy;\n \n         /**\n          * Type information handler used for \"untyped\" values (ones declared\n          * to have type <code>Object.class</code>)\n-         * \n-         * @since 1.5\n          */\n         protected final TypeResolverBuilder<?> _typeResolverBuilder;\n         \n         /* Factory methods\n         /**********************************************************\n          */\n-\n+        \n         public Base withClassIntrospector(ClassIntrospector<? extends BeanDescription> ci) {\n             return new Base(ci, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                     _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n             _featureFlags = features;\n         }\n         \n-        /**\n-         * @since 1.8\n-         */\n         protected Impl(Impl<CFG,T> src, MapperConfig.Base base, SubtypeResolver str)\n         {\n             super(src, base, str);\n             _featureFlags = src._featureFlags;\n         }\n         \n+        protected Impl(Impl<CFG,T> src, MapperConfig.Base base, SubtypeResolver str,\n+                int features)\n+        {\n+            super(src, base, str);\n+            _featureFlags = features;\n+        }\n+\n         /**\n          * Method that calculates bit set (flags) of all features that\n          * are enabled by default.\n         /**\n          * Fluent factory method that will construct and return a new configuration\n          * object instance with specified features enabled.\n-         * \n-         * @since 1.9\n          */\n         public abstract T with(CFG... features);\n \n         /**\n          * Fluent factory method that will construct and return a new configuration\n          * object instance with specified features disabled.\n-         * \n-         * @since 1.9\n          */\n         public abstract T without(CFG... features);\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n         return _serializationConfig.createUnshared(_subtypeResolver);\n     }\n \n+    public SerializationConfig copySerializationConfig(int features) {\n+        return _serializationConfig.createUnshared(_subtypeResolver, features);\n+    }\n+    \n     /**\n      * Method for replacing the shared default serialization configuration\n      * object.\n         return (T) _convert(fromValue, toValueType);\n     } \n \n+    /**\n+     * Actual conversion implementation: instead of using existing read\n+     * and write methods, much of code is inlined. Reason for this is\n+     * that we must avoid wrapping/unwrapping both for efficiency and\n+     * for correctness. If wrapping/unwrapping is actually desired,\n+     * caller must use explicit <code>writeValue</code> and\n+     * <code>readValue</code> methods.\n+     */\n     protected Object _convert(Object fromValue, JavaType toValueType)\n         throws IllegalArgumentException\n     {\n          */\n         TokenBuffer buf = new TokenBuffer(this);\n         try {\n-            writeValue(buf, fromValue);\n-            // and provide as with a JsonParser for contents as well!\n-            JsonParser jp = buf.asParser();\n-            Object result = readValue(jp, toValueType);\n+            // inlined 'writeValue' with minor changes:\n+            // first: disable wrapping when writing\n+            int serFeatures = _serializationConfig._featureFlags & ~(SerializationConfig.Feature.WRAP_ROOT_VALUE.getMask());\n+            // no need to check for closing of TokenBuffer\n+            _serializerProvider.serializeValue(copySerializationConfig(serFeatures),\n+                    buf, fromValue, _serializerFactory);\n+\n+            // then matching read, inlined 'readValue' with minor mods:\n+            final JsonParser jp = buf.asParser();\n+            Object result;\n+            // ok to pass in existing feature flags; unwrapping handled by mapper\n+            final DeserializationConfig deserConfig = copyDeserializationConfig();\n+            JsonToken t = _initForReading(jp);\n+            if (t == JsonToken.VALUE_NULL) {\n+                result = _findRootDeserializer(deserConfig, toValueType).getNullValue();\n+            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n+                result = null;\n+            } else { // pointing to event other than null\n+                DeserializationContext ctxt = _createDeserializationContext(jp, deserConfig);\n+                JsonDeserializer<Object> deser = _findRootDeserializer(deserConfig, toValueType);\n+                // note: no handling of unwarpping\n+                result = deser.deserialize(jp, ctxt);\n+            }\n             jp.close();\n             return result;\n         } catch (IOException e) { // should not occur, no real i/o...\n             throw new IllegalArgumentException(e.getMessage(), e);\n         }\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Extended Public API: JSON Schema generation\n         jp.clearCurrentToken();\n         return result;\n     }\n-\n     \n     protected Object _readMapAndClose(JsonParser jp, JavaType valueType)\n         throws IOException, JsonParseException, JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n  * instance. This because some objects may be configured, constructed and\n  * cached first time they are needed.\n  *<p>\n- * As of version 1.9, the goal is to make this class eventually immutable.\n- * Because of this, existing methods that allow changing state of this\n- * instance are deprecated in favor of methods that create new instances\n- * with different configuration (\"fluent factories\")\n+ * Note: as of 2.0, goal is still to make config instances fully immutable.\n  */\n public class SerializationConfig\n     extends MapperConfig.Impl<SerializationConfig.Feature, SerializationConfig>\n         _mixInAnnotations = mixins;\n         _subtypeResolver = str;\n     }\n+\n+    /**\n+     * Constructor used to make a private copy of specific mix-in definitions.\n+     */\n+    protected SerializationConfig(SerializationConfig src,\n+            HashMap<ClassKey,Class<?>> mixins, SubtypeResolver str,\n+            int features)\n+    {\n+        super(src, src._base, str, features);\n+        _serializationInclusion = src._serializationInclusion;\n+        _serializationView = src._serializationView;\n+        _filterProvider = src._filterProvider;\n+        _mixInAnnotations = mixins;\n+    }\n     \n     protected SerializationConfig(SerializationConfig src, MapperConfig.Base base)\n     {\n         _mixInAnnotationsShared = true;\n         return new SerializationConfig(this, mixins, subtypeResolver);\n     }\n+\n+    @Override\n+    public SerializationConfig createUnshared(SubtypeResolver subtypeResolver,\n+            int features)\n+    {\n+        HashMap<ClassKey,Class<?>> mixins = _mixInAnnotations;\n+        _mixInAnnotationsShared = true;\n+        return new SerializationConfig(this, mixins, subtypeResolver, features);\n+    }\n     \n     @Override\n     public AnnotationIntrospector getAnnotationIntrospector()\n     /**\n      * Accessor for getting bean description that only contains class\n      * annotations: useful if no getter/setter/creator information is needed.\n-     *<p>\n-     * Note: part of {@link MapperConfig} since 1.7\n      */\n     @SuppressWarnings(\"unchecked\")\n     @Override\n      * Accessor for getting bean description that only contains immediate class\n      * annotations: ones from the class, and its direct mix-in, if any, but\n      * not from super types.\n-     *<p>\n-     * Note: part of {@link MapperConfig} since 1.7\n      */\n     @SuppressWarnings(\"unchecked\")\n     @Override\n         return vchecker;\n     }\n \n-    /*\n-    /**********************************************************\n-    /* MapperConfig overrides for 1.8 backwards compatibility\n-    /**********************************************************\n-     */\n-\n-    /* NOTE: these are overloads we MUST have, but that were missing\n-     * from 1.9.0 and 1.9.1. Type erasure can bite in the ass...\n-     *<p>\n-     * NOTE: will remove either these variants, or base class one, in 2.0.\n-     */\n-    \n     /** \n      * Alias for {@link MapperConfig#isEnabled(com.fasterxml.jackson.databind.MapperConfig.ConfigFeature)}.\n      * \n--- a/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/convert/TestBeanConversions.java\n         ObjectMapper wrappingMapper = new ObjectMapper();\n         wrappingMapper.enable(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n         wrappingMapper.enable(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n-        Point input = new Point(1, 2, 3);\n+\n         // conversion is ok, even if it's bogus one\n-        Point output = wrappingMapper.convertValue(input, Point.class);\n+        _convertAndVerifyPoint(wrappingMapper);\n+\n+        // also: ok to have mismatched settings, since as per [JACKSON-710], should\n+        // not actually use wrapping internally in these cases\n+        wrappingMapper = new ObjectMapper();\n+        wrappingMapper.enable(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n+        wrappingMapper.disable(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+        _convertAndVerifyPoint(wrappingMapper);\n+\n+        wrappingMapper = new ObjectMapper();\n+        wrappingMapper.disable(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n+        wrappingMapper.enable(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+        _convertAndVerifyPoint(wrappingMapper);\n+    }\n+\n+    private void _convertAndVerifyPoint(ObjectMapper m)\n+    {\n+        final Point input = new Point(1, 2, 3);\n+        Point output = m.convertValue(input, Point.class);\n         assertEquals(1, output.x);\n         assertEquals(2, output.y);\n         assertEquals(3, output.z);", "timestamp": 1326565895, "metainfo": ""}