{"sha": "463614bbdcda0afcc680b924fd473476f862d274", "log": "javadoc cleanup", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n  * Class used for creating concrete {@link JavaType} instances,\n  * given various inputs.\n  *<p>\n- * As of Jackson 1.8, usage should be done using instance configured\n- * via {@link com.fasterxml.jackson.databind.ObjectMapper} (and exposed through\n- * {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n- * {@link com.fasterxml.jackson.databind.SerializationConfig}).\n- * However, old static-singleton access methods are supported as well; however,\n- * using those may cause issues with extension modules that register\n- * \"type enchancers\".\n- *<p>\n- * Typical usage pattern before Jackson 1.8 was to statically import factory methods\n- * of this class, to allow convenient instantiation of structured\n- * types, especially {@link Collection} and {@link Map} types\n- * to represent generic types. For example\n+ * Instances of this class are accessible using {@link com.fasterxml.jackson.databind.ObjectMapper}\n+ * as well as many objects it constructs (like\n+* {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n+ * {@link com.fasterxml.jackson.databind.SerializationConfig})),\n+ * but usually those objects also \n+ * expose convenience methods (<code>constructType</code>).\n+ * So, you can do for example:\n  *<pre>\n- * mapType(String.class, Integer.class)\n+ *   JavaType stringType = mapper.constructType(String.class);\n  *</pre>\n- * to represent\n+ * However, more advanced methods are only exposed by factory so that you\n+ * may need to use:\n  *<pre>\n- *  Map&lt;String,Integer>\n- *</pre>\n- * This is an alternative to using {@link TypeReference} that would\n- * be something like\n- *<pre>\n- *  new TypeReference&lt;Map&lt;String,Integer>>() { }\n+ *   JavaType stringCollection = mapper.getTypeFactory().constructCollectionType(List.class, String.class);\n  *</pre>\n  */\n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n      * Method for constructing a marker type that indicates missing generic\n      * type information, which is handled same as simple type for\n      * <code>java.lang.Object</code>.\n-     * \n-     * @since 1.8\n      */\n     public static JavaType unknownType() {\n         return defaultInstance()._unknownType();\n                 // one more thing: handlers to copy?\n                 Object h = baseType.getValueHandler();\n                 if (h != null) {\n-//                  subtype.setValueHandler(h);\n                     subtype = subtype.withValueHandler(h);\n                 }\n                 h = baseType.getTypeHandler();\n      * @throws IllegalArgumentException If canonical representation is malformed,\n      *   or class that type represents (including its generic parameters) is\n      *   not found\n-     * \n-     * @since 1.8\n      */\n     public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n     {\n      * key and value types for Map implementations.\n      * \n      * @param type Sub-type (leaf type) that implements <code>expType</code>\n-     * \n-     * @since 1.6\n      */\n     public JavaType[] findTypeParameters(JavaType type, Class<?> expType)\n     {\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     * \n-     * @since 1.8\n      */\n     public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n         return CollectionLikeType.construct(collectionClass, constructType(elementClass));\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     * \n-     * @since 1.8\n      */\n     public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n         return CollectionLikeType.construct(collectionClass, elementType);\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     * \n-     * @since 1.8\n      */\n     public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n         return MapType.construct(mapClass, keyType, valueType);\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     * \n-     * @since 1.8\n      */\n     public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n         return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     * \n-     * @since 1.8\n      */\n     public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n         return MapLikeType.construct(mapClass, keyType, valueType);\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     * \n-     * @since 1.8\n      */\n     public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n         return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n     \n     /**\n      * Method for constructing a type instance with specified parameterization.\n-     * \n-     * @since 1.8\n      */\n     public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes)\n     {\n      *<p> \n      * NOTE: no type modifiers are called on type either, so calling this method\n      * should only be used if caller really knows what it's doing...\n-     * \n-     * @since 1.8\n      */\n     public JavaType uncheckedSimpleType(Class<?> cls) {\n         return new SimpleType(cls);\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     *\n-     * @since 1.5\n      */\n     public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses)\n     {\n      *<p>\n      * NOTE: type modifiers are NOT called on constructed type itself; but are called\n      * for contained types.\n-     *\n-     * @since 1.5\n      */\n     public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes)\n     {\n      *<pre>\n      *<p>\n      * This method should only be used if parameterization is completely unavailable.\n-     * \n-     * @since 1.9\n      */\n     public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n         return CollectionType.construct(collectionClass, unknownType());\n      *<pre>\n      *<p>\n      * This method should only be used if parameterization is completely unavailable.\n-     * \n-     * @since 1.9\n      */\n     public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n         return CollectionLikeType.construct(collectionClass, unknownType());\n      *<pre>\n      *<p>\n      * This method should only be used if parameterization is completely unavailable.\n-     * \n-     * @since 1.9\n      */\n     public MapType constructRawMapType(Class<? extends Map> mapClass) {\n         return MapType.construct(mapClass, unknownType(), unknownType());\n      *<pre>\n      *<p>\n      * This method should only be used if parameterization is completely unavailable.\n-     * \n-     * @since 1.9\n      */\n     public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n         return MapLikeType.construct(mapClass, unknownType(), unknownType());", "timestamp": 1325062929, "metainfo": ""}