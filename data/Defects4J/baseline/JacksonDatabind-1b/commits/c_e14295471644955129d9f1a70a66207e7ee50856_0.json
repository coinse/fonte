{"sha": "e14295471644955129d9f1a70a66207e7ee50856", "log": "Minor javadoc cleanup to reduce references to SerializerCache (which should be hidden from app code)", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n /**\n  * Concrete deserializer factory class that adds full Bean deserializer\n  * construction logic using class introspection.\n+ * Note that factories specifically do not implement any form of caching:\n+ * aside from configuration they are stateless; caching is implemented\n+ * by other components.\n  *<p>\n- * Since there is no caching, this factory is stateless and a globally\n- * shared singleton instance ({@link #instance}) can be  used by\n- * {@link DeserializerCache}s).\n+ * Instances of this class are fully immutable as all configuration is\n+ * done by using \"fluent factories\" (methods that construct new factory\n+ * instances with different configuration, instead of modifying instance).\n  */\n public class BeanDeserializerFactory\n     extends BasicDeserializerFactory\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n import com.fasterxml.jackson.databind.type.*;\n \n /**\n- * Abstract class that defines API used by {@link DeserializerCache}\n- * to obtain actual\n- * {@link JsonDeserializer} instances from multiple distinct factories.\n+ * Abstract class that defines API used by {@link DeserializationContext}\n+ * to construct actual\n+ * {@link JsonDeserializer} instances (which are then cached by\n+ * context and/or dedicated cache).\n  *<p>\n  * Since there are multiple broad categories of deserializers, there are \n  * multiple factory methods:\n  * <li>For JSON \"Array\" type, we need 2 methods: one to deal with expected\n  *   Java arrays ({@link #createArrayDeserializer})\n  *   and the other for other Java containers like {@link java.util.List}s\n- *   and {@link java.util.Set}s ({@link #createCollectionDeserializer(DeserializationConfig, DeserializerCache, CollectionType, BeanProperty)})\n+ *   and {@link java.util.Set}s ({@link #createCollectionDeserializer}).\n+ *   Actually there is also a third method for \"Collection-like\" types;\n+ *   things like Scala collections that act like JDK collections but do not\n+ *   implement same interfaces.\n  *  </li>\n  * <li>For JSON \"Object\" type, we need 2 methods: one to deal with\n  *   expected Java {@link java.util.Map}s\n  *   ({@link #createMapDeserializer}), and another for POJOs\n- *   ({@link #createBeanDeserializer(DeserializationConfig, DeserializerCache, JavaType, BeanProperty)}.\n+ *   ({@link #createBeanDeserializer}.\n+ *   As an additional twist there is also a callback for \"Map-like\" types,\n+ *   mostly to make it possible to support Scala Maps (which are NOT JDK\n+ *   Map compatible).\n  *  </li>\n  * <li>For Tree Model ({@link com.fasterxml.jackson.core.JsonNode}) properties there is\n- *    {@link #createTreeDeserializer(DeserializationConfig, DeserializerCache, JavaType, BeanProperty)}\n+ *    {@link #createTreeDeserializer}\n  * <li>For enumerated types ({@link java.lang.Enum}) there is\n- *    {@link #createEnumDeserializer(DeserializationConfig, DeserializerCache, JavaType, BeanProperty)}\n+ *    {@link #createEnumDeserializer}\n  *  </li>\n- * <li>For all other types, {@link #createBeanDeserializer(DeserializationConfig, DeserializerCache, JavaType, BeanProperty)}\n- *   is used.\n+ * <li>For all other types, {@link #createBeanDeserializer} is used.\n  * </ul>\n  *<p>\n- * All above methods take 2 type arguments, except for the first one\n- * which takes just a single argument.\n  */\n public abstract class DeserializerFactory\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/Deserializers.java\n      * (annotations on declared element class; or on field or method type is associated with).\n      *<p>\n      * Similarly, a {@link KeyDeserializer} may be passed, but this is only done if there is\n-     * a specific configuration override (annotations) to indicate instance to use. Otherwise\n-     * null is passed, and key deserializer needs to be obtained using {@link DeserializerCache}\n+     * a specific configuration override (annotations) to indicate instance to use.\n+     * Otherwise null is passed, and key deserializer needs to be obtained later during\n+     * resolution (using {@link ResolvableDeserializer#resolve}).\n      * \n      * @param type Type of {@link java.util.Map} instances to deserialize\n      * @param config Configuration in effect\n      * (annotations on declared element class; or on field or method type is associated with).\n      *<p>\n      * Similarly, a {@link KeyDeserializer} may be passed, but this is only done if there is\n-     * a specific configuration override (annotations) to indicate instance to use. Otherwise\n-     * null is passed, and key deserializer needs to be obtained using {@link DeserializerCache}\n+     * a specific configuration override (annotations) to indicate instance to use.\n+     * Otherwise null is passed, and key deserializer needs to be obtained later during\n+     * resolution (using {@link ResolvableDeserializer#resolve}).\n      * \n      * @param type Type of {@link java.util.Map} instances to deserialize\n      * @param config Configuration in effect\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/ResolvableDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ResolvableDeserializer.java\n \n /**\n  * Interface used to indicate deserializers that want to do post-processing\n- * after construction and being added to {@link DeserializerCache},\n- * but before being used. This is typically used to resolve references\n- * to other contained types; for example, bean deserializers use this\n- * to eagerly find deserializers for contained field types.\n+ * after construction but before being returned to caller (and possibly cached)\n+ * and used.\n+ * This is typically used to resolve references\n+ * to other contained types; for example, bean deserializers use this callback\n+ * to locate deserializers for contained field types.\n+ * Main reason for using a callback (instead of trying to resolve dependencies\n+ * immediately) is to make it possible to cleanly handle self-references;\n+ * otherwise it would be easy to get into infinite recursion.\n  *<p>\n  * Note that {@link #resolve} method does NOT allow returning anything \n  * (specifically, a new deserializer instance): reason for this is that\n public interface ResolvableDeserializer\n {\n     /**\n-     * Method called after {@link DeserializerCache} has registered\n-     * the deserializer, but before it has returned it to the caller.\n+     * Method called after deserializer instance has been constructed\n+     * (and registered as necessary by provider objects),\n+     * but before it has returned it to the caller.\n      * Called object can then resolve its dependencies to other types,\n      * including self-references (direct or indirect).\n      *", "timestamp": 1327453305, "metainfo": ""}