{"sha": "e4f23bb6779d434d88a7c4335f92d13ea639b373", "log": "First check-in, tons of compilation errors to resolve", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/AbstractTypeResolver.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Defines interface for resolvers that can resolve abstract types into concrete\n+ * ones; either by using static mappings, or possibly by materializing\n+ * implementations dynamically.\n+ *<p>\n+ * Note that this class was changed in 1.8, to separate two parts of operation\n+ * (defaulting, which has higher precedence, and fallback, which has lowest\n+ * precedence). Existing m\n+ * \n+ * @since 1.6\n+ */\n+public abstract class AbstractTypeResolver\n+{\n+    /**\n+     * Try to locate a subtype for given abstract type, to either resolve\n+     * to a concrete type, or at least to a more-specific (and hopefully supported)\n+     * abstract type, one which may have registered deserializers.\n+     * Method is called before trying to locate registered deserializers\n+     * (as well as standard abstract type defaulting that core Jackson does),\n+     * so it is typically implemented to add custom mappings of common abstract\n+     * types (like specify which concrete implementation to use for binding\n+     * {@link java.util.List}s).\n+     *<p>\n+     * Note that this method does not necessarily have to do full resolution\n+     * of bindings; that is, it is legal to return type that could be further\n+     * resolved: caller is expected to keep calling this method on registered\n+     * resolvers, until a concrete type is located.\n+     * \n+     * @param config Configuration in use; should always be of type\n+     *    <code>DeserializationConfig</code>\n+     * \n+     * @since 1.8\n+     */\n+    public JavaType findTypeMapping(DeserializationConfig config, JavaType type) {\n+        return null;\n+    }\n+    \n+    /**\n+     * Method called to try to resolve an abstract type into\n+     * concrete type (usually for purposes of deserializing),\n+     * when no concrete implementation was found.\n+     * It will be called after checking all other possibilities,\n+     * including defaulting.\n+     * \n+     * @param config Configuration in use; should always be of type\n+     *    <code>DeserializationConfig</code>\n+     * @param type Type for which materialization maybe needed\n+     * \n+     * @return Resolved concrete type (which should retain generic\n+     *    type parameters of input type, if any), if resolution succeeds;\n+     *    null if resolver does not know how to resolve type\n+     *    \n+     * @since 1.6\n+     */\n+    public JavaType resolveAbstractType(DeserializationConfig config,\n+            JavaType type) {\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/AnnotationIntrospector.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+\n+/**\n+ * Abstract class that defines API used for introspecting annotation-based\n+ * configuration for serialization and deserialization. Separated\n+ * so that different sets of annotations can be supported, and support\n+ * plugged-in dynamically.\n+ *<p>\n+ * NOTE: due to rapid addition of new methods (and changes to existing methods),\n+ * it is <b>strongly</b> recommended that custom implementations should not directly\n+ * extend this class, but rather extend {@link NopAnnotationIntrospector}.\n+ * This way added methods will not break backwards compatibility of custom annotation\n+ * introspectors.\n+ */\n+public abstract class AnnotationIntrospector\n+{    \n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Value type used with managed and back references; contains type and\n+     * logic name, used to link related references\n+     * \n+     * @since 1.6\n+     */\n+    public static class ReferenceProperty\n+    {\n+        public enum Type {\n+            /**\n+             * Reference property that Jackson manages and that is serialized normally (by serializing\n+             * reference object), but is used for resolving back references during\n+             * deserialization.\n+             * Usually this can be defined by using\n+             * {@link org.codehaus.jackson.annotate.JsonManagedReference}\n+             */\n+            MANAGED_REFERENCE\n+    \n+            /**\n+             * Reference property that Jackson manages by suppressing it during serialization,\n+             * and reconstructing during deserialization.\n+             * Usually this can be defined by using\n+             * {@link org.codehaus.jackson.annotate.JsonBackReference}\n+             */\n+            ,BACK_REFERENCE\n+            ;\n+        }\n+\n+        private final Type _type;\n+        private final String _name;\n+\n+        public ReferenceProperty(Type t, String n) {\n+            _type = t;\n+            _name = n;\n+        }\n+\n+        public static ReferenceProperty managed(String name) { return new ReferenceProperty(Type.MANAGED_REFERENCE, name); }\n+        public static ReferenceProperty back(String name) { return new ReferenceProperty(Type.BACK_REFERENCE, name); }\n+        \n+        public Type getType() { return _type; }\n+        public String getName() { return _name; }\n+\n+        public boolean isManagedReference() { return _type == Type.MANAGED_REFERENCE; }\n+        public boolean isBackReference() { return _type == Type.BACK_REFERENCE; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Factory methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Factory method for accessing \"no operation\" implementation\n+     * of introspector: instance that will never find any annotation-based\n+     * configuration.\n+     * \n+     * @since 1.3\n+     */\n+    public static AnnotationIntrospector nopInstance() {\n+        return NopAnnotationIntrospector.instance;\n+    }\n+\n+    public static AnnotationIntrospector pair(AnnotationIntrospector a1, AnnotationIntrospector a2) {\n+        return new Pair(a1, a2);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Access to possibly chained introspectors (1.7)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to collect all \"real\" introspectors that\n+     * this introspector contains, if any; or this introspector\n+     * if it is not a container. Used to get access to all container\n+     * introspectors in their priority order.\n+     *<p>\n+     * Default implementation returns a Singleton list with this introspector\n+     * as contents.\n+     * This usually works for sub-classes, except for proxy or delegating \"container\n+     * introspectors\" which need to override implementation.\n+     */\n+    public Collection<AnnotationIntrospector> allIntrospectors() {\n+        return Collections.singletonList(this);\n+    }\n+    \n+    /**\n+     * Method that can be used to collect all \"real\" introspectors that\n+     * this introspector contains, if any; or this introspector\n+     * if it is not a container. Used to get access to all container\n+     * introspectors in their priority order.\n+     *<p>\n+     * Default implementation adds this introspector in result; this usually\n+     * works for sub-classes, except for proxy or delegating \"container\n+     * introspectors\" which need to override implementation.\n+     */\n+    public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result) {\n+        result.add(this);\n+        return result;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Generic annotation properties, lookup\n+    /**********************************************************\n+    */\n+\n+    /**\n+     * Method called by framework to determine whether given annotation\n+     * is handled by this introspector.\n+     */\n+    public abstract boolean isHandled(Annotation ann);\n+    \n+    /*\n+    /**********************************************************\n+    /* General class annotations\n+    /**********************************************************\n+    */\n+\n+    /**\n+     * Method that checks whether specified class has annotations\n+     * that indicate that it is (or is not) cachable. Exact\n+     * semantics depend on type of class annotated and using\n+     * class (factory or provider).\n+     *<p>\n+     * Currently only used\n+     * with deserializers, to determine whether provider\n+     * should cache instances, and if no annotations are found,\n+     * assumes non-cachable instances.\n+     *\n+     * @return True, if class is considered cachable within context,\n+     *   False if not, and null if introspector does not care either\n+     *   way.\n+     */\n+    public Boolean findCachability(AnnotatedClass ac) {\n+        return null;\n+    }\n+\n+    /**\n+     * Method for locating name used as \"root name\" (for use by\n+     * some serializers when outputting root-level object -- mostly\n+     * for XML compatibility purposes) for given class, if one\n+     * is defined. Returns null if no declaration found; can return\n+     * explicit empty String, which is usually ignored as well as null.\n+     *\n+     * @since 1.3\n+     */\n+    public abstract String findRootName(AnnotatedClass ac);\n+\n+    /**\n+     * Method for finding list of properties to ignore for given class\n+     * (null is returned if not specified).\n+     * List of property names is applied\n+     * after other detection mechanisms, to filter out these specific\n+     * properties from being serialized and deserialized.\n+     * \n+     * @since 1.4\n+     */\n+    public abstract String[] findPropertiesToIgnore(AnnotatedClass ac);\n+\n+    /**\n+     * Method for checking whether an annotation indicates that all unknown properties\n+     * \n+     * @since 1.4\n+     */\n+    public abstract Boolean findIgnoreUnknownProperties(AnnotatedClass ac);\n+\n+    /**\n+     * Method for checking whether properties that have specified type\n+     * (class, not generics aware) should be completely ignored for\n+     * serialization and deserialization purposes.\n+     * \n+     * @param ac Type to check\n+     * \n+     * @return Boolean.TRUE if properties of type should be ignored;\n+     *   Boolean.FALSE if they are not to be ignored, null for default\n+     *   handling (which is 'do not ignore')\n+     *   \n+     * @since 1.7\n+     */\n+    public Boolean isIgnorableType(AnnotatedClass ac) {\n+        return null;\n+    }\n+\n+    /**\n+     * Method for finding if annotated class has associated filter; and if so,\n+     * to return id that is used to locate filter.\n+     * \n+     * @return Id of the filter to use for filtering properties of annotated\n+     *    class, if any; or null if none found.\n+     */\n+    public Object findFilterId(AnnotatedClass ac) {\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Property auto-detection\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking if annotations indicate changes to minimum visibility levels\n+     * needed for auto-detecting property elements (fields, methods, constructors).\n+     * A baseline checker is given, and introspector is to either return it as is (if\n+     * no annotations are found), or build and return a derived instance (using checker's build\n+     * methods).\n+     *\n+     *  @since 1.5\n+     */\n+    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac, VisibilityChecker<?> checker) {\n+        return checker;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Class annotations for Polymorphic type handling (1.5+)\n+    /**********************************************************\n+    */\n+    \n+    /**\n+     * Method for checking if given class has annotations that indicate\n+     * that specific type resolver is to be used for handling instances.\n+     * This includes not only\n+     * instantiating resolver builder, but also configuring it based on\n+     * relevant annotations (not including ones checked with a call to\n+     * {@link #findSubtypes}\n+     * \n+     * @param config Configuration settings in effect (for serialization or deserialization)\n+     * @param ac Annotated class to check for annotations\n+     * @param baseType Base java type of value for which resolver is to be found\n+     * \n+     * @return Type resolver builder for given type, if one found; null if none\n+     * \n+     * @since 1.5 -- although changed in 1.8 to pass configuration object\n+     */\n+    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n+            AnnotatedClass ac, JavaType baseType) {\n+        return null;\n+    }\n+\n+    /**\n+     * Method for checking if given property entity (field or method) has annotations\n+     * that indicate that specific type resolver is to be used for handling instances.\n+     * This includes not only\n+     * instantiating resolver builder, but also configuring it based on\n+     * relevant annotations (not including ones checked with a call to\n+     * {@link #findSubtypes}\n+     * \n+     * @param config Configuration settings in effect (for serialization or deserialization)\n+     * @param am Annotated member (field or method) to check for annotations\n+     * @param baseType Base java type of property for which resolver is to be found\n+     * \n+     * @return Type resolver builder for properties of given entity, if one found;\n+     *    null if none\n+     * \n+     * @since 1.5 -- although changed in 1.8 to pass configuration object\n+     */\n+    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n+            AnnotatedMember am, JavaType baseType) {\n+        return null;\n+    }\n+\n+    /**\n+     * Method for checking if given structured property entity (field or method that\n+     * has nominal value of Map, Collection or array type) has annotations\n+     * that indicate that specific type resolver is to be used for handling type\n+     * information of contained values.\n+     * This includes not only\n+     * instantiating resolver builder, but also configuring it based on\n+     * relevant annotations (not including ones checked with a call to\n+     * {@link #findSubtypes}\n+     * \n+     * @param config Configuration settings in effect (for serialization or deserialization)\n+     * @param am Annotated member (field or method) to check for annotations\n+     * @param containerType Type of property for which resolver is to be found (must be a container type)\n+     * \n+     * @return Type resolver builder for values contained in properties of given entity,\n+     *    if one found; null if none\n+     * \n+     * @since 1.5 -- although changed in 1.8 to pass configuration object\n+     */    \n+    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n+            AnnotatedMember am, JavaType containerType) {\n+        return null;\n+    }\n+\n+    /**\n+     * Method for locating annotation-specified subtypes related to annotated\n+     * entity (class, method, field). Note that this is only guaranteed to be\n+     * a list of directly\n+     * declared subtypes, no recursive processing is guarantees (i.e. caller\n+     * has to do it if/as necessary)\n+     * \n+     * @param a Annotated entity (class, field/method) to check for annotations\n+     * \n+     * @since 1.5\n+     */\n+    public List<NamedType> findSubtypes(Annotated a) {\n+        return null;\n+    }\n+\n+    /**\n+     * Method for checking if specified type has explicit name.\n+     * \n+     * @param ac Class to check for type name annotations\n+     * \n+     * @since 1.5\n+     */\n+    public String findTypeName(AnnotatedClass ac) {\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* General member (field, method/constructor) annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Note: defined as non-abstract to reduce fragility between\n+     * versions.\n+     * \n+     * @since 1.6\n+     */\n+    public ReferenceProperty findReferenceType(AnnotatedMember member) {\n+        return null;\n+    }\n+\n+    /**\n+     * Method called to check whether given property is marked to be \"unwrapped\"\n+     * when being serialized (and appropriately handled in reverse direction,\n+     * i.e. expect unwrapped representation during deserialization)\n+     * \n+     * @since 1.9\n+     */\n+    public Boolean shouldUnwrapProperty(AnnotatedMember member) {\n+        return null;\n+    }\n+\n+    /**\n+     * Method called to check whether given property is marked to\n+     * be ignored; but NOT to determine if it should necessarily\n+     * be ignored, since that may depend on other factors.\n+     *<p>\n+     * Default implementation calls existing 'isIgnored' methods\n+     * such as {@link #isIgnorableField(AnnotatedField)} and\n+     * {@link #isIgnorableMethod(AnnotatedMethod)}.\n+     * \n+     * @since 1.9\n+     */\n+    public boolean hasIgnoreMarker(AnnotatedMember m)\n+    {\n+        /* For maximum backwards compatibility, we better call\n+         * existing methods.\n+         */\n+        /* TODO: For 2.0, replace with simple 'return false;'\n+         */\n+        if (m instanceof AnnotatedMethod) {\n+            return isIgnorableMethod((AnnotatedMethod) m);\n+        }\n+        if (m instanceof AnnotatedField) {\n+            return isIgnorableField((AnnotatedField) m);\n+        }\n+        if (m instanceof AnnotatedConstructor) {\n+            return isIgnorableConstructor((AnnotatedConstructor) m);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Method called to find out whether given member expectes a value\n+     * to be injected, and if so, what is the identifier of the value\n+     * to use during injection.\n+     * Type if identifier needs to be compatible with provider of\n+     * values (of type {@link InjectableValues}); often a simple String\n+     * id is used.\n+     * \n+     * @param m Member to check\n+     * \n+     * @return Identifier of value to inject, if any; null if no injection\n+     *   indicator is found\n+     */\n+    public Object findInjectableValueId(AnnotatedMember m) {\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* General method annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether there is an annotation that\n+     * indicates that given method should be ignored for all\n+     * operations (serialization, deserialization).\n+     *<p>\n+     * Note that this method should <b>ONLY</b> return true for such\n+     * explicit ignoral cases; and not if method just happens not to\n+     * be visible for annotation processor.\n+     *\n+     * @return True, if an annotation is found to indicate that the\n+     *    method should be ignored; false if not.\n+     */\n+    public abstract boolean isIgnorableMethod(AnnotatedMethod m);\n+\n+    /**\n+     * @since 1.2\n+     */\n+    public abstract boolean isIgnorableConstructor(AnnotatedConstructor c);\n+\n+    /*\n+    /**********************************************************\n+    /* General field annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether there is an annotation that\n+     * indicates that given field should be ignored for all\n+     * operations (serialization, deserialization).\n+     *\n+     * @return True, if an annotation is found to indicate that the\n+     *    field should be ignored; false if not.\n+     */\n+    public abstract boolean isIgnorableField(AnnotatedField f);\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization: general annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for getting a serializer definition on specified method\n+     * or field. Type of definition is either instance (of type\n+     * {@link JsonSerializer}) or Class (of type\n+     * <code>Class<JsonSerializer></code>); if value of different\n+     * type is returned, a runtime exception may be thrown by caller.\n+     *<p>\n+     * Note: this variant was briefly deprecated for 1.7; should not be\n+     */\n+    public abstract Object findSerializer(Annotated am);\n+\n+    /**\n+     * Method for getting a serializer definition for keys of associated <code>Map</code> property.\n+     * Type of definition is either instance (of type\n+     * {@link JsonSerializer}) or Class (of type\n+     * <code>Class<JsonSerializer></code>); if value of different\n+     * type is returned, a runtime exception may be thrown by caller.\n+     * \n+     * @since 1.8\n+     */\n+    public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated am) {\n+        return null;\n+    }\n+\n+    /**\n+     * Method for getting a serializer definition for content (values) of\n+     * associated <code>Collection</code>, <code>array</code> or <code>Map</code> property.\n+     * Type of definition is either instance (of type\n+     * {@link JsonSerializer}) or Class (of type\n+     * <code>Class<JsonSerializer></code>); if value of different\n+     * type is returned, a runtime exception may be thrown by caller.\n+     * \n+     * @since 1.8\n+     */\n+    public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated am) {\n+        return null;\n+    }\n+    \n+    /**\n+     * Method for checking whether given annotated entity (class, method,\n+     * field) defines which Bean/Map properties are to be included in\n+     * serialization.\n+     * If no annotation is found, method should return given second\n+     * argument; otherwise value indicated by the annotation\n+     *\n+     * @return Enumerated value indicating which properties to include\n+     *   in serialization\n+     */\n+    public JsonSerialize.Inclusion findSerializationInclusion(Annotated a, JsonSerialize.Inclusion defValue) {\n+        return defValue;\n+    }\n+\n+    /**\n+     * Method for accessing annotated type definition that a\n+     * method/field can have, to be used as the type for serialization\n+     * instead of the runtime type.\n+     * Type returned (if any) needs to be widening conversion (super-type).\n+     * Declared return type of the method is also considered acceptable.\n+     *\n+     * @return Class to use instead of runtime type\n+     */\n+    public abstract Class<?> findSerializationType(Annotated a);\n+\n+    /**\n+     * Method for finding possible widening type definition that a property\n+     * value can have, to define less specific key type to use for serialization.\n+     * It should be only be used with {@link java.util.Map} types.\n+     * \n+     * @return Class specifying more general type to use instead of\n+     *   declared type, if annotation found; null if not\n+     */\n+    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType) {\n+        return null;\n+    }\n+\n+    /**\n+     * Method for finding possible widening type definition that a property\n+     * value can have, to define less specific key type to use for serialization.\n+     * It should be only used with structured types (arrays, collections, maps).\n+     * \n+     * @return Class specifying more general type to use instead of\n+     *   declared type, if annotation found; null if not\n+     */\n+    public Class<?> findSerializationContentType(Annotated am, JavaType baseType) {\n+        return null;\n+    }\n+    \n+    /**\n+     * Method for accessing declared typing mode annotated (if any).\n+     * This is used for type detection, unless more granular settings\n+     * (such as actual exact type; or serializer to use which means\n+     * no type information is needed) take precedence.\n+     *\n+     * @since 1.2\n+     *\n+     * @return Typing mode to use, if annotation is found; null otherwise\n+     */\n+    public abstract JsonSerialize.Typing findSerializationTyping(Annotated a);\n+\n+    /**\n+     * Method for checking if annotated serializable property (represented by\n+     * field or getter method) has definitions for views it is to be included\n+     * in. If null is returned, no view definitions exist and property is always\n+     * included; otherwise it will only be included for views included in returned\n+     * array. View matches are checked using class inheritance rules (sub-classes\n+     * inherit inclusions of super-classes)\n+     * \n+     * @param a Annotated serializable property (field or getter method)\n+     * @return Array of views (represented by classes) that the property is included in;\n+     *    if null, always included (same as returning array containing <code>Object.class</code>)\n+     */\n+    public abstract Class<?>[] findSerializationViews(Annotated a);\n+    \n+    /*\n+    /**********************************************************\n+    /* Serialization: class annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for accessing defined property serialization order (which may be\n+     * partial). May return null if no ordering is defined.\n+     * \n+     * @since 1.4\n+     */\n+    public abstract String[] findSerializationPropertyOrder(AnnotatedClass ac);\n+\n+    /**\n+     * Method for checking whether an annotation indicates that serialized properties\n+     * for which no explicit is defined should be alphabetically (lexicograpically)\n+     * ordered\n+     * \n+     * @since 1.4\n+     */\n+    public abstract Boolean findSerializationSortAlphabetically(AnnotatedClass ac);\n+    \n+    /*\n+    /**********************************************************\n+    /* Serialization: method annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given method has an annotation\n+     * that suggests property name associated with method that\n+     * may be a \"getter\". Should return null if no annotation\n+     * is found; otherwise a non-null String.\n+     * If non-null value is returned, it is used as the property\n+     * name, except for empty String (\"\") which is taken to mean\n+     * \"use standard bean name detection if applicable;\n+     * method name if not\".\n+     */\n+    public abstract String findGettablePropertyName(AnnotatedMethod am);\n+\n+    /**\n+     * Method for checking whether given method has an annotation\n+     * that suggests that the return value of annotated method\n+     * should be used as \"the value\" of the object instance; usually\n+     * serialized as a primitive value such as String or number.\n+     *\n+     * @return True if such annotation is found (and is not disabled);\n+     *   false if no enabled annotation is found\n+     */\n+    public abstract boolean hasAsValueAnnotation(AnnotatedMethod am);\n+\n+    /**\n+     * Method for determining the String value to use for serializing\n+     * given enumeration entry; used when serializing enumerations\n+     * as Strings (the standard method).\n+     *\n+     * @return Serialized enum value.\n+     */\n+    public abstract String findEnumValue(Enum<?> value);\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization: field annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given member field represent\n+     * a serializable logical property; and if so, returns the\n+     * name of that property.\n+     * Should return null if no annotation is found (indicating it\n+     * is not a serializable field); otherwise a non-null String.\n+     * If non-null value is returned, it is used as the property\n+     * name, except for empty String (\"\") which is taken to mean\n+     * \"use the field name as is\".\n+     */\n+    public abstract String findSerializablePropertyName(AnnotatedField af);\n+\n+    /*\n+    /**********************************************************\n+    /* Deserialization: general annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for getting a deserializer definition on specified method\n+     * or field.\n+     * Type of definition is either instance (of type\n+     * {@link JsonDeserializer}) or Class (of type\n+     * <code>Class<JsonDeserializer></code>); if value of different\n+     * type is returned, a runtime exception may be thrown by caller.\n+     *<p>\n+     * Note: this variant was briefly deprecated for 1.7; but it turns out\n+     * we really should not try to push BeanProperty through at this point\n+     */\n+    public abstract Object findDeserializer(Annotated am);\n+\n+    /**\n+     * Method for getting a deserializer definition for keys of\n+     * associated <code>Map</code> property.\n+     * Type of definition is either instance (of type\n+     * {@link JsonDeserializer}) or Class (of type\n+     * <code>Class<JsonDeserializer></code>); if value of different\n+     * type is returned, a runtime exception may be thrown by caller.\n+     * \n+     * @since 1.3\n+     */\n+    public abstract Class<? extends KeyDeserializer> findKeyDeserializer(Annotated am);\n+\n+    /**\n+     * Method for getting a deserializer definition for content (values) of\n+     * associated <code>Collection</code>, <code>array</code> or\n+     * <code>Map</code> property.\n+     * Type of definition is either instance (of type\n+     * {@link JsonDeserializer}) or Class (of type\n+     * <code>Class<JsonDeserializer></code>); if value of different\n+     * type is returned, a runtime exception may be thrown by caller.\n+     * \n+     * @since 1.3\n+     */\n+    public abstract Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated am);\n+\n+    /**\n+     * Method for accessing annotated type definition that a\n+     * method can have, to be used as the type for serialization\n+     * instead of the runtime type.\n+     * Type must be a narrowing conversion\n+     * (i.e.subtype of declared type).\n+     * Declared return type of the method is also considered acceptable.\n+     *\n+     * @param baseType Assumed type before considering annotations\n+     * @param propName Logical property name of the property that uses\n+     *    type, if known; null for types not associated with property\n+     *\n+     * @return Class to use for deserialization instead of declared type\n+     */\n+    public abstract Class<?> findDeserializationType(Annotated am, JavaType baseType,\n+            String propName);\n+\n+    /**\n+     * Method for accessing additional narrowing type definition that a\n+     * method can have, to define more specific key type to use.\n+     * It should be only be used with {@link java.util.Map} types.\n+     * \n+     * @param baseKeyType Assumed key type before considering annotations\n+     * @param propName Logical property name of the property that uses\n+     *    type, if known; null for types not associated with property\n+     *\n+     * @return Class specifying more specific type to use instead of\n+     *   declared type, if annotation found; null if not\n+     */\n+    public abstract Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType,\n+            String propName);\n+\n+    /**\n+     * Method for accessing additional narrowing type definition that a\n+     * method can have, to define more specific content type to use;\n+     * content refers to Map values and Collection/array elements.\n+     * It should be only be used with Map, Collection and array types.\n+     * \n+     * @param baseContentType Assumed content (value) type before considering annotations\n+     * @param propName Logical property name of the property that uses\n+     *    type, if known; null for types not associated with property\n+     *\n+     * @return Class specifying more specific type to use instead of\n+     *   declared type, if annotation found; null if not\n+     */\n+    public abstract Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType,\n+            String propName);\n+\n+    /*\n+    /**********************************************************\n+    /* Deserialization: class annotations\n+    /**********************************************************\n+    */\n+\n+    /**\n+     * Method getting {@link ValueInstantiator} to use for given\n+     * type (class): return value can either be an instance of\n+     * instantiator, or class of instantiator to create.\n+     * \n+     * @since 1.9\n+     */\n+    public Object findValueInstantiator(AnnotatedClass ac) {\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Deserialization: method annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given method has an annotation\n+     * that suggests property name associated with method that\n+     * may be a \"setter\". Should return null if no annotation\n+     * is found; otherwise a non-null String.\n+     * If non-null value is returned, it is used as the property\n+     * name, except for empty String (\"\") which is taken to mean\n+     * \"use standard bean name detection if applicable;\n+     * method name if not\".\n+     */\n+    public abstract String findSettablePropertyName(AnnotatedMethod am);\n+\n+    /**\n+     * Method for checking whether given method has an annotation\n+     * that suggests that the method is to serve as \"any setter\";\n+     * method to be used for setting values of any properties for\n+     * which no dedicated setter method is found.\n+     *\n+     * @return True if such annotation is found (and is not disabled),\n+     *   false otherwise\n+     */\n+    public boolean hasAnySetterAnnotation(AnnotatedMethod am) {\n+        return false;\n+    }\n+\n+    /**\n+     * Method for checking whether given method has an annotation\n+     * that suggests that the method is to serve as \"any setter\";\n+     * method to be used for accessing set of miscellaneous \"extra\"\n+     * properties, often bound with matching \"any setter\" method.\n+     *\n+     * @return True if such annotation is found (and is not disabled),\n+     *   false otherwise\n+     *   \n+     * @since 1.6\n+     */\n+    public boolean hasAnyGetterAnnotation(AnnotatedMethod am) {\n+        return false;\n+    }\n+    \n+    /**\n+     * Method for checking whether given annotated item (method, constructor)\n+     * has an annotation\n+     * that suggests that the method is a \"creator\" (aka factory)\n+     * method to be used for construct new instances of deserialized\n+     * values.\n+     *\n+     * @return True if such annotation is found (and is not disabled),\n+     *   false otherwise\n+     */\n+    public boolean hasCreatorAnnotation(Annotated a) {\n+        return false;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deserialization: field annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given member field represent\n+     * a deserializable logical property; and if so, returns the\n+     * name of that property.\n+     * Should return null if no annotation is found (indicating it\n+     * is not a deserializable field); otherwise a non-null String.\n+     * If non-null value is returned, it is used as the property\n+     * name, except for empty String (\"\") which is taken to mean\n+     * \"use the field name as is\".\n+     */\n+    public abstract String findDeserializablePropertyName(AnnotatedField af);\n+\n+    /*\n+    /**********************************************************\n+    /* Deserialization: parameter annotations (for\n+    /* creator method parameters)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given set of annotations indicates\n+     * property name for associated parameter.\n+     * No actual parameter object can be passed since JDK offers no\n+     * representation; just annotations.\n+     */\n+    public abstract String findPropertyNameForParam(AnnotatedParameter param);\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper class that allows using 2 introspectors such that one\n+     * introspector acts as the primary one to use; and second one\n+     * as a fallback used if the primary does not provide conclusive\n+     * or useful result for a method.\n+     *<p>\n+     * An obvious consequence of priority is that it is easy to construct\n+     * longer chains of introspectors by linking multiple pairs.\n+     * Currently most likely combination is that of using the default\n+     * Jackson provider, along with JAXB annotation introspector (available\n+     * since version 1.1).\n+     */\n+    public static class Pair\n+        extends AnnotationIntrospector\n+    {\n+        protected final AnnotationIntrospector _primary, _secondary;\n+\n+        public Pair(AnnotationIntrospector p,\n+                    AnnotationIntrospector s)\n+        {\n+            _primary = p;\n+            _secondary = s;\n+        }\n+\n+        /**\n+         * Helper method for constructing a Pair from two given introspectors (if\n+         * neither is null); or returning non-null introspector if one is null\n+         * (and return just null if both are null)\n+         * \n+         * @since 1.7\n+         */\n+        public static AnnotationIntrospector create(AnnotationIntrospector primary,\n+                AnnotationIntrospector secondary)\n+        {\n+            if (primary == null) {\n+                return secondary;\n+            }\n+            if (secondary == null) {\n+                return primary;\n+            }\n+            return new Pair(primary, secondary);\n+        }\n+\n+        @Override\n+        public Collection<AnnotationIntrospector> allIntrospectors() {\n+            return allIntrospectors(new ArrayList<AnnotationIntrospector>());\n+        }\n+\n+        @Override\n+        public Collection<AnnotationIntrospector> allIntrospectors(Collection<AnnotationIntrospector> result)\n+        {\n+            _primary.allIntrospectors(result);\n+            _secondary.allIntrospectors(result);\n+            return result;\n+        }\n+        \n+        // // // Generic annotation properties, lookup\n+        \n+        @Override\n+        public boolean isHandled(Annotation ann)\n+        {\n+            return _primary.isHandled(ann) || _secondary.isHandled(ann);\n+        }\n+\n+        /*\n+        /******************************************************\n+        /* General class annotations\n+        /******************************************************\n+         */\n+\n+        @Override\n+        public Boolean findCachability(AnnotatedClass ac)\n+        {\n+            Boolean result = _primary.findCachability(ac);\n+            if (result == null) {\n+                result = _secondary.findCachability(ac);\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public String findRootName(AnnotatedClass ac)\n+        {\n+            String name1 = _primary.findRootName(ac);\n+            if (name1 == null) {\n+                return _secondary.findRootName(ac);\n+            } else if (name1.length() > 0) {\n+                return name1;\n+            }\n+            // name1 is empty; how about secondary?\n+            String name2 = _secondary.findRootName(ac);\n+            return (name2 == null) ? name1 : name2;\n+        }\n+\n+        @Override\n+        public String[] findPropertiesToIgnore(AnnotatedClass ac)\n+        {\n+            String[] result = _primary.findPropertiesToIgnore(ac);\n+            if (result == null) {\n+                result = _secondary.findPropertiesToIgnore(ac);\n+            }\n+            return result;            \n+        }\n+\n+        @Override\n+        public Boolean findIgnoreUnknownProperties(AnnotatedClass ac)\n+        {\n+            Boolean result = _primary.findIgnoreUnknownProperties(ac);\n+            if (result == null) {\n+                result = _secondary.findIgnoreUnknownProperties(ac);\n+            }\n+            return result;\n+        }        \n+\n+        @Override\n+        public Boolean isIgnorableType(AnnotatedClass ac)\n+        {\n+            Boolean result = _primary.isIgnorableType(ac);\n+            if (result == null) {\n+                result = _secondary.isIgnorableType(ac);\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public Object findFilterId(AnnotatedClass ac)\n+        {\n+            Object id = _primary.findFilterId(ac);\n+            if (id == null) {\n+                id = _secondary.findFilterId(ac);\n+            }\n+            return id;\n+        }\n+        \n+        /*\n+        /******************************************************\n+        /* Property auto-detection\n+        /******************************************************\n+        */\n+        \n+        @Override\n+        public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n+            VisibilityChecker<?> checker)\n+        {\n+            /* Note: to have proper priorities, we must actually call delegatees\n+             * in reverse order:\n+             */\n+            checker = _secondary.findAutoDetectVisibility(ac, checker);\n+            return _primary.findAutoDetectVisibility(ac, checker);\n+        }\n+\n+        /*\n+        /******************************************************\n+        /* Type handling\n+        /******************************************************\n+        */\n+        \n+        @Override\n+        public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n+                AnnotatedClass ac, JavaType baseType)\n+        {\n+            TypeResolverBuilder<?> b = _primary.findTypeResolver(config, ac, baseType);\n+            if (b == null) {\n+                b = _secondary.findTypeResolver(config, ac, baseType);\n+            }\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n+                AnnotatedMember am, JavaType baseType)\n+        {\n+            TypeResolverBuilder<?> b = _primary.findPropertyTypeResolver(config, am, baseType);\n+            if (b == null) {\n+                b = _secondary.findPropertyTypeResolver(config, am, baseType);\n+            }\n+            return b;\n+        }\n+\n+        @Override\n+        public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n+                AnnotatedMember am, JavaType baseType)\n+        {\n+            TypeResolverBuilder<?> b = _primary.findPropertyContentTypeResolver(config, am, baseType);\n+            if (b == null) {\n+                b = _secondary.findPropertyContentTypeResolver(config, am, baseType);\n+            }\n+            return b;\n+        }\n+        \n+        @Override\n+        public List<NamedType> findSubtypes(Annotated a)\n+        {\n+            List<NamedType> types1 = _primary.findSubtypes(a);\n+            List<NamedType> types2 = _secondary.findSubtypes(a);\n+            if (types1 == null || types1.isEmpty()) return types2;\n+            if (types2 == null || types2.isEmpty()) return types1;\n+            ArrayList<NamedType> result = new ArrayList<NamedType>(types1.size() + types2.size());\n+            result.addAll(types1);\n+            result.addAll(types2);\n+            return result;\n+        }\n+\n+        @Override\n+        public String findTypeName(AnnotatedClass ac)\n+        {\n+            String name = _primary.findTypeName(ac);\n+            if (name == null || name.length() == 0) {\n+                name = _secondary.findTypeName(ac);                \n+            }\n+            return name;\n+        }\n+        \n+        // // // General member (field, method/constructor) annotations\n+        \n+        @Override        \n+        public ReferenceProperty findReferenceType(AnnotatedMember member)\n+        {\n+            ReferenceProperty ref = _primary.findReferenceType(member);\n+            if (ref == null) {\n+                ref = _secondary.findReferenceType(member);\n+            }\n+            return ref; \n+        }\n+\n+        @Override        \n+        public Boolean shouldUnwrapProperty(AnnotatedMember member)\n+        {\n+            Boolean value = _primary.shouldUnwrapProperty(member);\n+            if (value == null) {\n+                value = _secondary.shouldUnwrapProperty(member);\n+            }\n+            return value;\n+        }\n+\n+        @Override\n+        public Object findInjectableValueId(AnnotatedMember m)\n+        {\n+            Object value = _primary.findInjectableValueId(m);\n+            if (value == null) {\n+                value = _secondary.findInjectableValueId(m);\n+            }\n+            return value;\n+        }\n+        \n+        @Override\n+        public boolean hasIgnoreMarker(AnnotatedMember m) {\n+            return _primary.hasIgnoreMarker(m) || _secondary.hasIgnoreMarker(m);\n+        }\n+        \n+        // // // General method annotations\n+\n+        @Override\n+        public boolean isIgnorableMethod(AnnotatedMethod m) {\n+            return _primary.isIgnorableMethod(m) || _secondary.isIgnorableMethod(m);\n+        }\n+        \n+        @Override\n+        public boolean isIgnorableConstructor(AnnotatedConstructor c) {\n+            return _primary.isIgnorableConstructor(c) || _secondary.isIgnorableConstructor(c);\n+        }\n+\n+        // // // General field annotations\n+\n+        @Override\n+        public boolean isIgnorableField(AnnotatedField f)\n+        {\n+            return _primary.isIgnorableField(f) || _secondary.isIgnorableField(f);\n+        }\n+\n+        // // // Serialization: general annotations\n+\n+        @Override\n+        public Object findSerializer(Annotated am)\n+        {\n+            Object result = _primary.findSerializer(am);\n+            if (result == null) {\n+                result = _secondary.findSerializer(am);\n+            }\n+            return result;\n+        }\n+        \n+        @Override\n+        public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a)\n+        {\n+            Class<? extends JsonSerializer<?>> result = _primary.findKeySerializer(a);\n+            if (result == null || result == JsonSerializer.None.class) {\n+                result = _secondary.findKeySerializer(a);\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a)\n+        {\n+            Class<? extends JsonSerializer<?>> result = _primary.findContentSerializer(a);\n+            if (result == null || result == JsonSerializer.None.class) {\n+                result = _secondary.findContentSerializer(a);\n+            }\n+            return result;\n+        }\n+        \n+        @Override\n+        public JsonSerialize.Inclusion findSerializationInclusion(Annotated a,\n+                JsonSerialize.Inclusion defValue)\n+        {\n+            /* This is bit trickier: need to combine results in a meaningful\n+             * way. Seems like it should be a disjoint; that is, most\n+             * restrictive value should be returned.\n+             * For enumerations, comparison is done by indexes, which\n+             * works: largest value is the last one, which is the most\n+             * restrictive value as well.\n+             */\n+            /* 09-Mar-2010, tatu: Actually, as per [JACKSON-256], it is probably better to just\n+             *    use strict overriding. Simpler, easier to understand.\n+             */\n+            // note: call secondary first, to give lower priority\n+            defValue = _secondary.findSerializationInclusion(a, defValue);\n+            defValue = _primary.findSerializationInclusion(a, defValue);\n+            return defValue;\n+        }\n+        \n+        @Override\n+        public Class<?> findSerializationType(Annotated a)\n+        {\n+            Class<?> result = _primary.findSerializationType(a);\n+            if (result == null) {\n+                result = _secondary.findSerializationType(a);\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n+        {\n+            Class<?> result = _primary.findSerializationKeyType(am, baseType);\n+            if (result == null) {\n+                result = _secondary.findSerializationKeyType(am, baseType);\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n+        {\n+            Class<?> result = _primary.findSerializationContentType(am, baseType);\n+            if (result == null) {\n+                result = _secondary.findSerializationContentType(am, baseType);\n+            }\n+            return result;\n+        }\n+        \n+        @Override\n+        public JsonSerialize.Typing findSerializationTyping(Annotated a)\n+        {\n+            JsonSerialize.Typing result = _primary.findSerializationTyping(a);\n+            if (result == null) {\n+                result = _secondary.findSerializationTyping(a);\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public Class<?>[] findSerializationViews(Annotated a)\n+        {\n+            /* Theoretically this could be trickier, if multiple introspectors\n+             * return non-null entries. For now, though, we'll just consider\n+             * first one to return non-null to win.\n+             */\n+            Class<?>[] result = _primary.findSerializationViews(a);\n+            if (result == null) {\n+                result = _secondary.findSerializationViews(a);\n+            }\n+            return result;\n+        }\n+        \n+        // // // Serialization: class annotations\n+\n+        @Override\n+        public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n+            String[] result = _primary.findSerializationPropertyOrder(ac);\n+            if (result == null) {\n+                result = _secondary.findSerializationPropertyOrder(ac);\n+            }\n+            return result;            \n+        }\n+\n+        /**\n+         * Method for checking whether an annotation indicates that serialized properties\n+         * for which no explicit is defined should be alphabetically (lexicograpically)\n+         * ordered\n+         */\n+        @Override\n+        public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n+            Boolean result = _primary.findSerializationSortAlphabetically(ac);\n+            if (result == null) {\n+                result = _secondary.findSerializationSortAlphabetically(ac);\n+            }\n+            return result;            \n+        }\n+\n+        // // // Serialization: method annotations\n+        \n+        @Override\n+        public String findGettablePropertyName(AnnotatedMethod am)\n+        {\n+            String result = _primary.findGettablePropertyName(am);\n+            if (result == null) {\n+                result = _secondary.findGettablePropertyName(am);\n+            } else if (result.length() == 0) {\n+                /* Empty String is a default; can be overridden by\n+                 * more explicit answer from secondary entry\n+                 */\n+                String str2 = _secondary.findGettablePropertyName(am);\n+                if (str2 != null) {\n+                    result = str2;\n+                }\n+            }\n+            return result;\n+        }\n+        \n+        @Override\n+        public boolean hasAsValueAnnotation(AnnotatedMethod am)\n+        {\n+            return _primary.hasAsValueAnnotation(am) || _secondary.hasAsValueAnnotation(am);\n+        }\n+        \n+        @Override\n+        public String findEnumValue(Enum<?> value)\n+        {\n+            String result = _primary.findEnumValue(value);\n+            if (result == null) {\n+                result = _secondary.findEnumValue(value);\n+            }\n+            return result;\n+        }        \n+\n+        // // // Serialization: field annotations\n+\n+        @Override\n+        public String findSerializablePropertyName(AnnotatedField af)\n+        {\n+            String result = _primary.findSerializablePropertyName(af);\n+            if (result == null) {\n+                result = _secondary.findSerializablePropertyName(af);\n+            } else if (result.length() == 0) {\n+                /* Empty String is a default; can be overridden by\n+                 * more explicit answer from secondary entry\n+                 */\n+                String str2 = _secondary.findSerializablePropertyName(af);\n+                if (str2 != null) {\n+                    result = str2;\n+                }\n+            }\n+            return result;\n+        }\n+\n+        // // // Deserialization: general annotations\n+\n+        @Override\n+        public Object findDeserializer(Annotated am)\n+        {\n+            Object result = _primary.findDeserializer(am);\n+            if (result == null) {\n+                result = _secondary.findDeserializer(am);\n+            }\n+            return result;\n+        }\n+        \n+        @Override\n+        public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated am)\n+        {\n+            Class<? extends KeyDeserializer> result = _primary.findKeyDeserializer(am);\n+            if (result == null || result == KeyDeserializer.None.class) {\n+                result = _secondary.findKeyDeserializer(am);\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated am)\n+        {\n+            Class<? extends JsonDeserializer<?>> result = _primary.findContentDeserializer(am);\n+            if (result == null || result == JsonDeserializer.None.class) {\n+                result = _secondary.findContentDeserializer(am);\n+            }\n+            return result;\n+        }\n+        \n+        @Override\n+        public Class<?> findDeserializationType(Annotated am, JavaType baseType,\n+                String propName)\n+        {\n+            Class<?> result = _primary.findDeserializationType(am, baseType, propName);\n+            if (result == null) {\n+                result = _secondary.findDeserializationType(am, baseType, propName);\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType,\n+                String propName)\n+        {\n+            Class<?> result = _primary.findDeserializationKeyType(am, baseKeyType, propName);\n+            if (result == null) {\n+                result = _secondary.findDeserializationKeyType(am, baseKeyType, propName);\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType,\n+                String propName)\n+        {\n+            Class<?> result = _primary.findDeserializationContentType(am, baseContentType, propName);\n+            if (result == null) {\n+                result = _secondary.findDeserializationContentType(am, baseContentType, propName);\n+            }\n+            return result;\n+        }\n+\n+        // // // Deserialization: class annotations\n+\n+        @Override\n+        public Object findValueInstantiator(AnnotatedClass ac)\n+        {\n+            Object result = _primary.findValueInstantiator(ac);\n+            if (result == null) {\n+                result = _secondary.findValueInstantiator(ac);\n+            }\n+            return result;\n+        }\n+\n+        // // // Deserialization: method annotations\n+\n+        @Override\n+        public String findSettablePropertyName(AnnotatedMethod am)\n+        {\n+            String result = _primary.findSettablePropertyName(am);\n+            if (result == null) {\n+                result = _secondary.findSettablePropertyName(am);\n+            } else if (result.length() == 0) {\n+                /* Empty String is a default; can be overridden by\n+                 * more explicit answer from secondary entry\n+                 */\n+                String str2 = _secondary.findSettablePropertyName(am);\n+                if (str2 != null) {\n+                    result = str2;\n+                }\n+            }\n+            return result;\n+        }\n+        \n+        @Override\n+        public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n+        {\n+            return _primary.hasAnySetterAnnotation(am) || _secondary.hasAnySetterAnnotation(am);\n+        }\n+\n+        @Override\n+        public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n+        {\n+            return _primary.hasAnyGetterAnnotation(am) || _secondary.hasAnyGetterAnnotation(am);\n+        }\n+        \n+        @Override\n+        public boolean hasCreatorAnnotation(Annotated a)\n+        {\n+            return _primary.hasCreatorAnnotation(a) || _secondary.hasCreatorAnnotation(a);\n+        }\n+        \n+        // // // Deserialization: field annotations\n+\n+        @Override\n+        public String findDeserializablePropertyName(AnnotatedField af)\n+        {\n+            String result = _primary.findDeserializablePropertyName(af);\n+            if (result == null) {\n+                result = _secondary.findDeserializablePropertyName(af);\n+            } else if (result.length() == 0) {\n+                /* Empty String is a default; can be overridden by\n+                 * more explicit answer from secondary entry\n+                 */\n+                String str2 = _secondary.findDeserializablePropertyName(af);\n+                if (str2 != null) {\n+                    result = str2;\n+                }\n+            }\n+            return result;\n+        }\n+\n+        // // // Deserialization: parameter annotations (for creators)\n+\n+        @Override\n+        public String findPropertyNameForParam(AnnotatedParameter param)\n+        {\n+            String result = _primary.findPropertyNameForParam(param);\n+            if (result == null) {\n+                result = _secondary.findPropertyNameForParam(param);\n+            }\n+            return result;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanDescription.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedConstructor;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.type.TypeBindings;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+\n+/**\n+ * Basic container for information gathered by {@link ClassIntrospector} to\n+ * help in constructing serializers and deserializers.\n+ * Note that the main implementation type is\n+ * {@link com.fasterxml.jackson.databind.introspect.BasicBeanDescription},\n+ * meaning that it is safe to upcast to this type.\n+ * \n+ * @author tatu\n+ */\n+public abstract class BeanDescription\n+{\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Bean type information, including raw class and possible\n+     * * generics information\n+     */\n+    protected final JavaType _type;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected BeanDescription(JavaType type)\n+    {\n+    \t_type = type;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Simple accesors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for accessing declared type of bean being introspected,\n+     * including full generic type information (from declaration)\n+     */\n+    public JavaType getType() { return _type; }\n+\n+    public Class<?> getBeanClass() { return _type.getRawClass(); }\n+\n+    public abstract AnnotatedClass getClassInfo();\n+    \n+    public abstract boolean hasKnownClassAnnotations();\n+\n+    /**\n+     * Accessor for type bindings that may be needed to fully resolve\n+     * types of member object, such as return and argument types of\n+     * methods and constructors, and types of fields.\n+     */\n+    public abstract TypeBindings bindingsForBeanType();\n+\n+    /**\n+     * Method for resolving given JDK type, using this bean as the\n+     * generic type resolution context.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract JavaType resolveType(java.lang.reflect.Type jdkType);\n+    \n+    /**\n+     * Method for accessing collection of annotations the bean\n+     * class has.\n+     * \n+     * @since 1.7\n+     */\n+    public abstract Annotations getClassAnnotations();\n+    \n+    /*\n+    /**********************************************************\n+    /* Basic API for finding properties, related\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @return Ordered Map with logical property name as key, and\n+     *    matching getter method as value.\n+     *    \n+     * @since 1.9\n+     */\n+    public abstract List<BeanPropertyDefinition> findProperties();\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public abstract Map<Object, AnnotatedMember> findInjectables();\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    public abstract AnnotatedMethod findAnyGetter();\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public abstract AnnotatedMethod findAnySetter();\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public abstract AnnotatedMethod findJsonValueMethod();\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public abstract AnnotatedConstructor findDefaultConstructor();\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    public abstract Set<String> getIgnoredPropertyNames();\n+\n+    /*\n+    /**********************************************************\n+    /* Deprecated methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @deprecated Since 1.9 use {@link #findProperties}\n+     */\n+    @Deprecated\n+    public abstract LinkedHashMap<String,AnnotatedMethod> findGetters(VisibilityChecker<?> visibilityChecker,\n+            Collection<String> ignoredProperties);\n+\n+    /**\n+     * @deprecated Since 1.9 use {@link #findProperties}\n+     */\n+    @Deprecated\n+    public abstract LinkedHashMap<String,AnnotatedMethod> findSetters(VisibilityChecker<?> visibilityChecker);\n+\n+    /**\n+     * @deprecated Since 1.9 use {@link #findProperties}\n+     */\n+    @Deprecated\n+    public abstract LinkedHashMap<String,AnnotatedField> findDeserializableFields(VisibilityChecker<?> visibilityChecker,\n+            Collection<String> ignoredProperties);\n+\n+    /**\n+     * @deprecated Since 1.9 use the non-deprecated version\n+     */\n+    @Deprecated\n+    public abstract Map<String,AnnotatedField> findSerializableFields(VisibilityChecker<?> visibilityChecker,\n+            Collection<String> ignoredProperties);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanProperty.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.lang.annotation.Annotation;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+import com.fasterxml.jackson.databind.util.Named;\n+\n+\n+/**\n+ * Bean properties are logical entities that represent data\n+ * Java objects (\"beans\", although more accurately POJOs)\n+ * contain; and that are accessed using some combination\n+ * of methods (getter, setter), field and constructor\n+ * parameter.\n+ * Instances allow access to annotations directly associated\n+ * to property (via field or method), as well as contextual\n+ * annotations (annotations for class that contains properties).\n+ *<p>\n+ * Instances are passed during construction of serializers and\n+ * deserializers, and references can be stored by serializers\n+ * and deserializers for futher use; mostly to retain access\n+ * to annotations when dynamically locating handlers for\n+ * sub-properties or dynamic types.\n+ *\n+ * @since 1.7\n+ */\n+public interface BeanProperty extends Named\n+{\n+    /**\n+     * Method to get logical name of the property\n+     */\n+    @Override\n+    public String getName();\n+    \n+    /**\n+     * Method to get declared type of the property.\n+     */\n+    public JavaType getType();\n+\n+    /**\n+     * Method for finding annotation associated with this property;\n+     * meaning annotation associated with one of entities used to\n+     * access property.\n+     */\n+    public <A extends Annotation> A getAnnotation(Class<A> acls);\n+\n+    /**\n+     * Method for finding annotation associated with context of\n+     * this property; usually class in which member is declared\n+     * (or its subtype if processing subtype).\n+     */\n+    public <A extends Annotation> A getContextAnnotation(Class<A> acls);\n+\n+    /**\n+     * Method for accessing primary physical entity that represents the property;\n+     * annotated field, method or constructor property.\n+     */\n+    public AnnotatedMember getMember();\n+    \n+    /*\n+    /**********************************************************\n+    /* Simple stand-alone implementation, useful as a placeholder\n+    /* or base class.\n+    /**********************************************************\n+     */\n+\n+    public static class Std implements BeanProperty\n+    {\n+        protected final String _name;\n+        protected final JavaType _type;\n+\n+        /**\n+         * Physical entity (field, method or constructor argument) that\n+         * is used to access value of property (or in case of constructor\n+         * property, just placeholder)\n+         */\n+        protected final AnnotatedMember _member;\n+\n+        /**\n+         * Annotations defined in the context class (if any); may be null\n+         * if no annotations were found\n+         */\n+        protected final Annotations _contextAnnotations;\n+        \n+        public Std(String name, JavaType type, Annotations contextAnnotations, AnnotatedMember member)\n+        {\n+            _name = name;\n+            _type = type;\n+            _member = member;\n+            _contextAnnotations = contextAnnotations;\n+        }\n+\n+        public Std withType(JavaType type) {\n+            return new Std(_name, type, _contextAnnotations, _member);\n+        }\n+        \n+        @Override\n+        public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+            return _member.getAnnotation(acls);\n+        }\n+\n+        @Override\n+        public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n+            return (_contextAnnotations == null) ? null : _contextAnnotations.get(acls);\n+        }\n+        \n+        @Override\n+        public String getName() {\n+            return _name;\n+        }\n+\n+        @Override\n+        public JavaType getType() {\n+            return _type;\n+        }\n+\n+        @Override\n+        public AnnotatedMember getMember() {\n+            return _member;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/BeanPropertyDefinition.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n+import com.fasterxml.jackson.databind.util.Named;\n+\n+/**\n+ * Simple value classes that contain definitions of properties,\n+ * used during introspection of properties to use for\n+ * serialization and deserialization purposes.\n+ * These instances are created before actual {@link BeanProperty}\n+ * instances are created, i.e. they are used earlier in the process\n+ * flow.\n+ *\n+ * @since 1.9\n+ */\n+public abstract class BeanPropertyDefinition\n+    implements Named\n+{\n+    /**\n+     * Accessor for name used for external representation (in JSON).\n+     */\n+    @Override // from Named\n+    public abstract String getName();\n+\n+    /**\n+     * Accessor that can be used to determine implicit name from underlying\n+     * element(s) before possible renaming. This is the \"internal\"\n+     * name derived from accessor (\"x\" from \"getX\"), and is not based on\n+     * annotations or naming strategy.\n+     */\n+    public abstract String getInternalName();\n+    \n+    public abstract boolean hasGetter();\n+    public abstract boolean hasSetter();\n+    public abstract boolean hasField();\n+    public abstract boolean hasConstructorParameter();\n+\n+    public boolean couldDeserialize() {\n+        return getMutator() != null;\n+    }\n+    public boolean couldSerialize() {\n+        return getAccessor() != null;\n+    }\n+\n+    public abstract AnnotatedMethod getGetter();\n+    public abstract AnnotatedMethod getSetter();\n+    public abstract AnnotatedField getField();\n+    public abstract AnnotatedParameter getConstructorParameter();\n+\n+    /**\n+     * Method used to find accessor (getter, field to access) to use for accessing\n+     * value of the property.\n+     * Null if no such member exists.\n+     */\n+    public abstract AnnotatedMember getAccessor();\n+\n+    /**\n+     * Method used to find mutator (constructor parameter, setter, field) to use for\n+     * changing value of the property.\n+     * Null if no such member exists.\n+     */\n+    public abstract AnnotatedMember getMutator();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ClassIntrospector.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Helper class used to introspect features of POJO value classes\n+ * used with Jackson. The main use is for finding out\n+ * POJO construction (creator) and value access (getters, setters)\n+ * methods and annotations that define configuration of using\n+ * those methods.\n+ */\n+public abstract class ClassIntrospector<T extends BeanDescription>\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper interfaces\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Interface used for decoupling details of how mix-in annotation\n+     * definitions are accessed (via this interface), and how\n+     * they are stored (defined by classes that implement the interface)\n+     */\n+    public interface MixInResolver\n+    {\n+        /**\n+         * Method that will check if there are \"mix-in\" classes (with mix-in\n+         * annotations) for given class\n+         */\n+        public Class<?> findMixInClassFor(Class<?> cls);\n+    }\n+\n+    protected ClassIntrospector() { }\n+\t\n+    /*\n+    /**********************************************************\n+    /* Public API: factory methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Factory method that constructs an introspector that has all\n+     * information needed for serialization purposes.\n+     */\n+    public abstract T forSerialization(SerializationConfig cfg, JavaType type,\n+            MixInResolver r);\n+\n+    /**\n+     * Factory method that constructs an introspector that has all\n+     * information needed for deserialization purposes.\n+     */\n+    public abstract T forDeserialization(DeserializationConfig cfg, JavaType type,\n+            MixInResolver r);\n+    \n+    /**\n+     * Factory method that constructs an introspector that has\n+     * information necessary for creating instances of given\n+     * class (\"creator\"), as well as class annotations, but\n+     * no information on member methods\n+     */\n+    public abstract T forCreation(DeserializationConfig cfg, JavaType type,\n+            MixInResolver r);\n+\n+    /**\n+     * Factory method that constructs an introspector that only has\n+     * information regarding annotations class itself (or its supertypes) has,\n+     * but nothing on methods or constructors.\n+     */\n+    public abstract T forClassAnnotations(MapperConfig<?> cfg, JavaType type,\n+            MixInResolver r);\n+\n+    /**\n+     * Factory method that constructs an introspector that only has\n+     * information regarding annotations class itself has (but NOT including\n+     * its supertypes), but nothing on methods or constructors.\n+     * \n+     * @since 1.5\n+     */\n+    public abstract T forDirectClassAnnotations(MapperConfig<?> cfg, JavaType type,\n+            MixInResolver r);\n+    \n+    /*\n+    /**********************************************************\n+    /* Deprecated methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Factory method that constructs an introspector that only has\n+     * information regarding annotations class itself (or its supertypes) has,\n+     * but nothing on methods or constructors.\n+     * \n+     * @deprecated since 1.9, use variant that takes JavaType\n+     */\n+    @Deprecated\n+    public T forClassAnnotations(MapperConfig<?> cfg, Class<?> cls,\n+            MixInResolver r) {\n+        return forClassAnnotations(cfg, cfg.constructType(cls), r);\n+    }\n+\n+    /**\n+     * Factory method that constructs an introspector that only has\n+     * information regarding annotations class itself has (but NOT including\n+     * its supertypes), but nothing on methods or constructors.\n+     * \n+     * @since 1.5\n+     * \n+     * @deprecated since 1.9, use variant that takes JavaType\n+     */\n+    @Deprecated\n+    public T forDirectClassAnnotations(MapperConfig<?> cfg, Class<?> cls,\n+            MixInResolver r) {\n+        return forDirectClassAnnotations(cfg, cfg.constructType(cls), r);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ContextualDeserializer.java\n+package com.fasterxml.jackson.databind;\n+\n+/**\n+ * Add-on interface that {@link JsonDeserializer}s can implement to get a callback\n+ * that can be used to create contextual instances of deserializer to use for\n+ * handling properties of supported type. This can be useful\n+ * for deserializers that can be configured by annotations, or should otherwise\n+ * have differing behavior depending on what kind of property is being deserialized.\n+ *\n+ * @param <T> Type of deserializer to contextualize\n+ * \n+ * @since 1.7\n+ */\n+public interface ContextualDeserializer<T>\n+{\n+    /**\n+     * Method called to see if a different (or differently configured) deserializer\n+     * is needed to deserialize values of specified property.\n+     * Note that instance that this method is called on is typically shared one and\n+     * as a result method should <b>NOT</b> modify this instance but rather construct\n+     * and return a new instance. This instance should only be returned as-is, in case\n+     * it is already suitable for use.\n+     * \n+     * @param config Current deserialization configuration\n+     * @param property Method, field or constructor parameter that represents the property\n+     *   (and is used to assign deserialized value).\n+     *   Should be available; but there may be cases where caller can not provide it and\n+     *   null is passed instead (in which case impls usually pass 'this' deserializer as is)\n+     * \n+     * @return Deserializer to use for deserializing values of specified property;\n+     *   may be this instance or a new instance.\n+     * \n+     * @throws JsonMappingException\n+     */\n+    public JsonDeserializer<T> createContextual(DeserializationConfig config,\n+            BeanProperty property)\n+        throws JsonMappingException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ContextualKeyDeserializer.java\n+package com.fasterxml.jackson.databind;\n+\n+/**\n+ * Add-on interface that {@link KeyDeserializer}s can implement to get a callback\n+ * that can be used to create contextual instances of key deserializer to use for\n+ * handling Map keys of supported type. This can be useful\n+ * for key deserializers that can be configured by annotations, or should otherwise\n+ * have differing behavior depending on what kind of Map property keys are being deserialized.\n+ * \n+ * @since 1.8\n+ */\n+public interface ContextualKeyDeserializer\n+{\n+    /**\n+     * Method called to see if a different (or differently configured) key deserializer\n+     * is needed to deserialize keys of specified Map property.\n+     * Note that instance that this method is called on is typically shared one and\n+     * as a result method should <b>NOT</b> modify this instance but rather construct\n+     * and return a new instance. This instance should only be returned as-is, in case\n+     * it is already suitable for use.\n+     * \n+     * @param config Current deserialization configuration\n+     * @param property Method, field or constructor parameter that declared Map for which\n+     *   contextual instance will be used. Will not be available when deserializing root-level\n+     *   Map value; otherwise should not be null.\n+     * \n+     * @return Key deserializer to use for deserializing keys specified Map property,\n+     *   may be this instance or a new instance.\n+     */\n+    public KeyDeserializer createContextual(DeserializationConfig config,\n+            BeanProperty property)\n+        throws JsonMappingException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ContextualSerializer.java\n+package com.fasterxml.jackson.databind;\n+\n+/**\n+ * Add-on interface that {@link JsonSerializer}s can implement to get a callback\n+ * that can be used to create contextual instances of serializer to use for\n+ * handling properties of supported type. This can be useful\n+ * for serializers that can be configured by annotations, or should otherwise\n+ * have differing behavior depending on what kind of property is being serialized.\n+ *\n+ * @param <T> Type of serializer to contextualize\n+ * \n+ * @since 1.7\n+ */\n+public interface ContextualSerializer<T>\n+{\n+    /**\n+     * Method called to see if a different (or differently configured) serializer\n+     * is needed to serialize values of specified property.\n+     * Note that instance that this method is called on is typically shared one and\n+     * as a result method should <b>NOT</b> modify this instance but rather construct\n+     * and return a new instance. This instance should only be returned as-is, in case\n+     * it is already suitable for use.\n+     * \n+     * @param config Current serialization configuration\n+     * @param property Method or field that represents the property\n+     *   (and is used to access value to serialize).\n+     *   Should be available; but there may be cases where caller can not provide it and\n+     *   null is passed instead (in which case impls usually pass 'this' serializer as is)\n+     * \n+     * @return Serializer to use for serializing values of specified property;\n+     *   may be this instance or a new instance.\n+     * \n+     * @throws JsonMappingException\n+     */\n+    public JsonSerializer<T> createContextual(SerializationConfig config,\n+            BeanProperty property)\n+        throws JsonMappingException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationConfig.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.text.DateFormat;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.NopAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.LinkedNode;\n+\n+import org.codehaus.jackson.node.JsonNodeFactory;\n+\n+/**\n+ * Object that contains baseline configuration for deserialization\n+ * process. An instance is owned by {@link ObjectMapper}, which makes\n+ * a copy that is passed during serialization process to\n+ * {@link DeserializerProvider} and {@link DeserializerFactory}.\n+ *<p>\n+ * Note: although configuration settings can be changed at any time\n+ * (for factories and instances), they are not guaranteed to have\n+ * effect if called after constructing relevant mapper or deserializer\n+ * instance. This because some objects may be configured, constructed and\n+ * cached first time they are needed.\n+ *<p>\n+ * As of version 1.9, the goal is to make this class eventually immutable.\n+ * Because of this, existing methods that allow changing state of this\n+ * instance are deprecated in favor of methods that create new instances\n+ * with different configuration (\"fluent factories\")\n+ */\n+public class DeserializationConfig\n+    extends MapperConfig.Impl<DeserializationConfig.Feature, DeserializationConfig>\n+{\n+    /**\n+     * Enumeration that defines togglable features that guide\n+     * the serialization feature.\n+     */\n+    public enum Feature implements MapperConfig.ConfigFeature\n+    {\n+        /*\n+        /******************************************************\n+         *  Introspection features\n+        /******************************************************\n+         */\n+\n+        /**\n+         * Feature that determines whether annotation introspection\n+         * is used for configuration; if enabled, configured\n+         * {@link AnnotationIntrospector} will be used: if disabled,\n+         * no annotations are considered.\n+         *<P>\n+         * Feature is enabled by default.\n+         *\n+         * @since 1.2\n+         */\n+        USE_ANNOTATIONS(true),\n+\n+        /**\n+         * Feature that determines whether \"setter\" methods are\n+         * automatically detected based on standard Bean naming convention\n+         * or not. If yes, then all public one-argument methods that\n+         * start with prefix \"set\"\n+         * are considered setters. If disabled, only methods explicitly\n+         * annotated are considered setters.\n+         *<p>\n+         * Note that this feature has lower precedence than per-class\n+         * annotations, and is only used if there isn't more granular\n+         * configuration available.\n+         *<P>\n+         * Feature is enabled by default.\n+         */\n+        AUTO_DETECT_SETTERS(true),\n+\n+        /**\n+         * Feature that determines whether \"creator\" methods are\n+         * automatically detected by consider public constructors,\n+         * and static single argument methods with name \"valueOf\".\n+         * If disabled, only methods explicitly annotated are considered\n+         * creator methods (except for the no-arg default constructor which\n+         * is always considered a factory method).\n+         *<p>\n+         * Note that this feature has lower precedence than per-class\n+         * annotations, and is only used if there isn't more granular\n+         * configuration available.\n+         *<P>\n+         * Feature is enabled by default.\n+         */\n+        AUTO_DETECT_CREATORS(true),\n+\n+        /**\n+         * Feature that determines whether non-static fields are recognized as\n+         * properties.\n+         * If yes, then all public member fields\n+         * are considered as properties. If disabled, only fields explicitly\n+         * annotated are considered property fields.\n+         *<p>\n+         * Note that this feature has lower precedence than per-class\n+         * annotations, and is only used if there isn't more granular\n+         * configuration available.\n+         *<P>\n+         * Feature is enabled by default.\n+         *\n+         * @since 1.1\n+         */\n+        AUTO_DETECT_FIELDS(true),\n+\n+        /**\n+         * Feature that determines whether otherwise regular \"getter\"\n+         * methods (but only ones that handle Collections and Maps,\n+         * not getters of other type)\n+         * can be used for purpose of getting a reference to a Collection\n+         * and Map to modify the property, without requiring a setter\n+         * method.\n+         * This is similar to how JAXB framework sets Collections and\n+         * Maps: no setter is involved, just setter.\n+         *<p>\n+         * Note that such getters-as-setters methods have lower\n+         * precedence than setters, so they are only used if no\n+         * setter is found for the Map/Collection property.\n+         *<p>\n+         * Feature is enabled by default.\n+         */\n+        USE_GETTERS_AS_SETTERS(true),\n+\n+        /**\n+         * Feature that determines whether method and field access\n+         * modifier settings can be overridden when accessing\n+         * properties. If enabled, method\n+         * {@link java.lang.reflect.AccessibleObject#setAccessible}\n+         * may be called to enable access to otherwise unaccessible\n+         * objects.\n+         */\n+        CAN_OVERRIDE_ACCESS_MODIFIERS(true),\n+\n+        /*\n+        /******************************************************\n+        /* Type conversion features\n+        /******************************************************\n+         */\n+\n+        /**\n+         * Feature that determines whether Json floating point numbers\n+         * are to be deserialized into {@link java.math.BigDecimal}s\n+         * if only generic type description (either {@link Object} or\n+         * {@link Number}, or within untyped {@link java.util.Map}\n+         * or {@link java.util.Collection} context) is available.\n+         * If enabled such values will be deserialized as {@link java.math.BigDecimal}s;\n+         * if disabled, will be deserialized as {@link Double}s.\n+         * <p>\n+         * Feature is disabled by default, meaning that \"untyped\" floating\n+         * point numbers will by default be deserialized as {@link Double}s\n+         * (choice is for performance reason -- BigDecimals are slower than\n+         * Doubles)\n+         */\n+        USE_BIG_DECIMAL_FOR_FLOATS(false),\n+\n+        /**\n+         * Feature that determines whether Json integral (non-floating-point)\n+         * numbers are to be deserialized into {@link java.math.BigInteger}s\n+         * if only generic type description (either {@link Object} or\n+         * {@link Number}, or within untyped {@link java.util.Map}\n+         * or {@link java.util.Collection} context) is available.\n+         * If enabled such values will be deserialized as\n+         * {@link java.math.BigInteger}s;\n+         * if disabled, will be deserialized as \"smallest\" available type,\n+         * which is either {@link Integer}, {@link Long} or\n+         * {@link java.math.BigInteger}, depending on number of digits.\n+         * <p>\n+         * Feature is disabled by default, meaning that \"untyped\" floating\n+         * point numbers will by default be deserialized using whatever\n+         * is the most compact integral type, to optimize efficiency.\n+         */\n+        USE_BIG_INTEGER_FOR_INTS(false),\n+\n+        // [JACKSON-652]\n+        /**\n+         * Feature that determines whether JSON Array is mapped to\n+         * <code>Object[]</code> or <code>List&lt;Object></code> when binding\n+         * \"untyped\" objects (ones with nominal type of <code>java.lang.Object</code>).\n+         * If true, binds as <code>Object[]</code>; if false, as <code>List&lt;Object></code>.\n+         *<p>\n+         * Feature is disabled by default, meaning that JSON arrays are bound as\n+         * {@link java.util.List}s.\n+         * \n+         * @since 1.9\n+         */\n+        USE_JAVA_ARRAY_FOR_JSON_ARRAY(false),\n+        \n+        /**\n+         * Feature that determines standard deserialization mechanism used for\n+         * Enum values: if enabled, Enums are assumed to have been serialized  using\n+         * return value of <code>Enum.toString()</code>;\n+         * if disabled, return value of <code>Enum.name()</code> is assumed to have been used.\n+         * Since pre-1.6 method was to use Enum name, this is the default.\n+         *<p>\n+         * Note: this feature should usually have same value\n+         * as {@link SerializationConfig.Feature#WRITE_ENUMS_USING_TO_STRING}.\n+         *<p>\n+         * For further details, check out [JACKSON-212]\n+         * \n+         * @since 1.6\n+         */\n+        READ_ENUMS_USING_TO_STRING(false),\n+        \n+        /*\n+        /******************************************************\n+         *  Error handling features\n+        /******************************************************\n+         */\n+\n+        /**\n+         * Feature that determines whether encountering of unknown\n+         * properties (ones that do not map to a property, and there is\n+         * no \"any setter\" or handler that can handle it)\n+         * should result in a failure (by throwing a\n+         * {@link JsonMappingException}) or not.\n+         * This setting only takes effect after all other handling\n+         * methods for unknown properties have been tried, and\n+         * property remains unhandled.\n+         *<p>\n+         * Feature is enabled by default, meaning that \n+         * {@link JsonMappingException} is thrown if an unknown property\n+         * is encountered. This is the implicit default prior to\n+         * introduction of the feature.\n+         *\n+         * @since 1.2\n+         */\n+        FAIL_ON_UNKNOWN_PROPERTIES(true),\n+\n+        /**\n+         * Feature that determines whether encountering of JSON null\n+         * is an error when deserializing into Java primitive types\n+         * (like 'int' or 'double'). If it is, a JsonProcessingException\n+         * is thrown to indicate this; if not, default value is used\n+         * (0 for 'int', 0.0 for double, same defaulting as what JVM uses).\n+         *<p>\n+         * Feature is disabled by default (to be consistent with behavior\n+         * of Jackson 1.6),\n+         * i.e. to allow use of nulls for primitive properties.\n+         * \n+         * @since 1.7\n+         */\n+        FAIL_ON_NULL_FOR_PRIMITIVES(false),\n+\n+        /**\n+         * Feature that determines whether JSON integer numbers are valid\n+         * values to be used for deserializing Java enum values.\n+         * If set to 'false' numbers are acceptable and are used to map to\n+         * ordinal() of matching enumeration value; if 'true', numbers are\n+         * not allowed and a {@link JsonMappingException} will be thrown.\n+         * Latter behavior makes sense if there is concern that accidental\n+         * mapping from integer values to enums might happen (and when enums\n+         * are always serialized as JSON Strings)\n+         *<p>\n+         * Feature is disabled by default (to be consistent with behavior\n+         * of Jackson 1.6), \n+         * i.e. to allow use of JSON integers for Java enums.\n+         * \n+         * @since 1.7\n+         */\n+        FAIL_ON_NUMBERS_FOR_ENUMS(false),\n+\n+        /**\n+         * Feature that determines whether Jackson code should catch\n+         * and wrap {@link Exception}s (but never {@link Error}s!)\n+         * to add additional information about\n+         * location (within input) of problem or not. If enabled,\n+         * most exceptions will be caught and re-thrown (exception\n+         * specifically being that {@link java.io.IOException}s may be passed\n+         * as is, since they are declared as throwable); this can be\n+         * convenient both in that all exceptions will be checked and\n+         * declared, and so there is more contextual information.\n+         * However, sometimes calling application may just want \"raw\"\n+         * unchecked exceptions passed as is.\n+         *<p>\n+         * Feature is enabled by default, and is similar in behavior\n+         * to default prior to 1.7.\n+         * \n+         * @since 1.7\n+         */\n+        WRAP_EXCEPTIONS(true),\n+        \n+        /*\n+        /******************************************************\n+         *  Structural conversion features\n+        /******************************************************\n+         */\n+\n+        /**\n+         * Feature that determines whether it is acceptable to coerce non-array\n+         * (in JSON) values to work with Java collection (arrays, java.util.Collection)\n+         * types. If enabled, collection deserializers will try to handle non-array\n+         * values as if they had \"implicit\" surrounding JSON array.\n+         * This feature is meant to be used for compatibility/interoperability reasons,\n+         * to work with packages (such as XML-to-JSON converters) that leave out JSON\n+         * array in cases where there is just a single element in array.\n+         * \n+         * @since 1.8\n+         */\n+        ACCEPT_SINGLE_VALUE_AS_ARRAY(false),\n+        \n+        /**\n+         * Feature to allow \"unwrapping\" root-level JSON value, to match setting of\n+         * {@link SerializationConfig.Feature#WRAP_ROOT_VALUE} used for serialization.\n+         * Will verify that the root JSON value is a JSON Object, and that it has\n+         * a single property with expected root name. If not, a\n+         * {@link JsonMappingException} is thrown; otherwise value of the wrapped property\n+         * will be deserialized as if it was the root value.\n+         * \n+         * @since 1.9\n+         */\n+        UNWRAP_ROOT_VALUE(false),\n+\n+        /*\n+        /******************************************************\n+         *  Value conversion features\n+        /******************************************************\n+         */\n+        \n+        /**\n+         * Feature that can be enabled to allow JSON empty String\n+         * value (\"\") to be bound to POJOs as null.\n+         * If disabled, standard POJOs can only be bound from JSON null or\n+         * JSON Object (standard meaning that no custom deserializers or\n+         * constructors are defined; both of which can add support for other\n+         * kinds of JSON values); if enable, empty JSON String can be taken\n+         * to be equivalent of JSON null.\n+         * \n+         * @since 1.8\n+         */\n+        ACCEPT_EMPTY_STRING_AS_NULL_OBJECT(false)\n+        \n+        ;\n+\n+        final boolean _defaultState;\n+\t        \n+        private Feature(boolean defaultState) {\n+            _defaultState = defaultState;\n+        }\n+\n+        @Override\n+        public boolean enabledByDefault() { return _defaultState; }\n+    \n+        @Override\n+        public int getMask() { return (1 << ordinal()); }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration settings for deserialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Linked list that contains all registered problem handlers.\n+     * Implementation as front-added linked list allows for sharing\n+     * of the list (tail) without copying the list.\n+     */\n+    protected LinkedNode<DeserializationProblemHandler> _problemHandlers;\n+    \n+    /**\n+     * Factory used for constructing {@link org.codehaus.jackson.JsonNode} instances.\n+     *\n+     * @since 1.6\n+     */\n+    protected final JsonNodeFactory _nodeFactory;\n+\n+    /**\n+     * Feature flag from {@link SerializationConfig} which is needed to\n+     * know if serializer will by default sort properties in\n+     * alphabetic order.\n+     *<p>\n+     * Note that although this property is not marked as final,\n+     * it is handled like it was, except for the fact that it is\n+     * assigned with a call to {@link #passSerializationFeatures}\n+     * instead of constructor.\n+     * \n+     * @since 1.9\n+     */\n+    protected boolean _sortPropertiesAlphabetically;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used by ObjectMapper to create default configuration object instance.\n+     */\n+    public DeserializationConfig(ClassIntrospector<? extends BeanDescription> intr,\n+            AnnotationIntrospector annIntr, VisibilityChecker<?> vc,\n+            SubtypeResolver subtypeResolver, PropertyNamingStrategy propertyNamingStrategy,\n+            TypeFactory typeFactory, HandlerInstantiator handlerInstantiator)\n+    {\n+        super(intr, annIntr, vc, subtypeResolver, propertyNamingStrategy, typeFactory, handlerInstantiator,\n+                collectFeatureDefaults(DeserializationConfig.Feature.class));\n+        _nodeFactory = JsonNodeFactory.instance;\n+    }\n+    \n+    /**\n+     * @since 1.8\n+     */\n+    protected DeserializationConfig(DeserializationConfig src) {\n+        this(src, src._base);\n+    }\n+\n+    /**\n+     * Copy constructor used to create a non-shared instance with given mix-in\n+     * annotation definitions and subtype resolver.\n+     * \n+     * @since 1.8\n+     */\n+    private DeserializationConfig(DeserializationConfig src,\n+            HashMap<ClassKey,Class<?>> mixins, SubtypeResolver str)\n+    {\n+        this(src, src._base);\n+        _mixInAnnotations = mixins;\n+        _subtypeResolver = str;\n+    }\n+    \n+    /**\n+     * @since 1.8\n+     */\n+    protected DeserializationConfig(DeserializationConfig src, MapperConfig.Base base)\n+    {\n+        super(src, base, src._subtypeResolver);\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+        _sortPropertiesAlphabetically = src._sortPropertiesAlphabetically;\n+    }\n+    \n+    /**\n+     * @since 1.8\n+     */\n+    protected DeserializationConfig(DeserializationConfig src, JsonNodeFactory f)\n+    {\n+        super(src);\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = f;\n+        _sortPropertiesAlphabetically = src._sortPropertiesAlphabetically;\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    protected DeserializationConfig(DeserializationConfig src, int featureFlags)\n+    {\n+        super(src, featureFlags);\n+        _problemHandlers = src._problemHandlers;\n+        _nodeFactory = src._nodeFactory;\n+        _sortPropertiesAlphabetically = src._sortPropertiesAlphabetically;\n+    }\n+    \n+    /**\n+     * Helper method to be called right after creating a non-shared\n+     * instance, needed to pass state of feature(s) shared with\n+     * SerializationConfig.\n+     * \n+     * Since 1.9\n+     */\n+    protected DeserializationConfig passSerializationFeatures(int serializationFeatureFlags)\n+    {\n+        _sortPropertiesAlphabetically = (serializationFeatureFlags\n+                & SerializationConfig.Feature.SORT_PROPERTIES_ALPHABETICALLY.getMask()) != 0;\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, factory methods from MapperConfig\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public DeserializationConfig withClassIntrospector(ClassIntrospector<? extends BeanDescription> ci) {\n+        return new DeserializationConfig(this, _base.withClassIntrospector(ci));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return new DeserializationConfig(this, _base.withAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withVisibilityChecker(VisibilityChecker<?> vc) {\n+        return new DeserializationConfig(this, _base.withVisibilityChecker(vc));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withVisibility(JsonMethod forMethod, JsonAutoDetect.Visibility visibility) {\n+        return new DeserializationConfig(this, _base.withVisibility(forMethod, visibility));\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withTypeResolverBuilder(TypeResolverBuilder<?> trb) {\n+        return new DeserializationConfig(this, _base.withTypeResolverBuilder(trb));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withSubtypeResolver(SubtypeResolver str)\n+    {\n+        DeserializationConfig cfg = new DeserializationConfig(this);\n+        cfg._subtypeResolver = str;\n+        return cfg;\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n+        return new DeserializationConfig(this, _base.withPropertyNamingStrategy(pns));\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withTypeFactory(TypeFactory tf) {\n+        return (tf == _base.getTypeFactory()) ? this : new DeserializationConfig(this, _base.withTypeFactory(tf));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withDateFormat(DateFormat df) {\n+        return (df == _base.getDateFormat()) ? this : new DeserializationConfig(this, _base.withDateFormat(df));\n+    }\n+    \n+    @Override\n+    public DeserializationConfig withHandlerInstantiator(HandlerInstantiator hi) {\n+        return (hi == _base.getHandlerInstantiator()) ? this : new DeserializationConfig(this, _base.withHandlerInstantiator(hi));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return new DeserializationConfig(this, _base.withInsertedAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public DeserializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return new DeserializationConfig(this, _base.withAppendedAnnotationIntrospector(ai));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, deserialization-specific factory methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Fluent factory method that will construct a new instance with\n+     * specified {@link JsonNodeFactory}\n+     * \n+     * @since 1.8\n+     */\n+    public DeserializationConfig withNodeFactory(JsonNodeFactory f) {\n+        return new DeserializationConfig(this, f);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     * \n+     * @since 1.9\n+     */\n+    @Override\n+    public DeserializationConfig with(DeserializationConfig.Feature... features)\n+    {\n+        int flags = _featureFlags;\n+        for (Feature f : features) {\n+            flags |= f.getMask();\n+        }\n+        return new DeserializationConfig(this, flags);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     * \n+     * @since 1.9\n+     */\n+    @Override\n+    public DeserializationConfig without(DeserializationConfig.Feature... features)\n+    {\n+        int flags = _featureFlags;\n+        for (Feature f : features) {\n+            flags &= ~f.getMask();\n+        }\n+        return new DeserializationConfig(this, flags);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* MapperConfig implementation\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that checks class annotations that the argument Object has,\n+     * and modifies settings of this configuration object accordingly,\n+     * similar to how those annotations would affect actual value classes\n+     * annotated with them, but with global scope. Note that not all\n+     * annotations have global significance, and thus only subset of\n+     * Jackson annotations will have any effect.\n+     *<p>\n+     * Ones that are known to have effect are:\n+     *<ul>\n+     * <li>{@link JsonAutoDetect}</li>\n+     *</ul>\n+     * \n+     * @param cls Class of which class annotations to use\n+     *   for changing configuration settings\n+     *   \n+     * @deprecated Since 1.9, it is preferably to explicitly configure\n+     *   instances; this method also modifies existing instance which is\n+     *   against immutable design goals of this class.\n+     */\n+    @Deprecated\n+    @Override\n+    public void fromAnnotations(Class<?> cls)\n+    {\n+    \t/* no class annotation for:\n+         *\n+         * - CAN_OVERRIDE_ACCESS_MODIFIERS\n+         * - USE_BIG_DECIMAL_FOR_FLOATS\n+         * - USE_BIG_INTEGER_FOR_INTS\n+         * - USE_GETTERS_AS_SETTERS\n+         */\n+\n+        /* 10-Jul-2009, tatu: Should be able to just pass null as\n+         *    'MixInResolver'; no mix-ins set at this point\n+         */\n+        AnnotationIntrospector ai = getAnnotationIntrospector();\n+        AnnotatedClass ac = AnnotatedClass.construct(cls, ai, null);\n+        // visibility checks handled via separate checker object...\n+        VisibilityChecker<?> prevVc = getDefaultVisibilityChecker();\n+        _base = _base.withVisibilityChecker(ai.findAutoDetectVisibility(ac, prevVc));\n+    }\n+\n+    /**\n+     * Method that is called to create a non-shared copy of the configuration\n+     * to be used for a deserialization operation.\n+     * Note that if sub-classing\n+     * and sub-class has additional instance methods,\n+     * this method <b>must</b> be overridden to produce proper sub-class\n+     * instance.\n+     */\n+    @Override\n+    public DeserializationConfig createUnshared(SubtypeResolver subtypeResolver)\n+    {\n+        HashMap<ClassKey,Class<?>> mixins = _mixInAnnotations;\n+        // ensure that we assume sharing at this point:\n+        _mixInAnnotationsShared = true;\n+        return new DeserializationConfig(this, mixins, subtypeResolver);\n+    }\n+\n+    /**\n+     * Method for getting {@link AnnotationIntrospector} configured\n+     * to introspect annotation values used for configuration.\n+     */\n+    @Override\n+    public AnnotationIntrospector getAnnotationIntrospector()\n+    {\n+        /* 29-Jul-2009, tatu: it's now possible to disable use of\n+         *   annotations; can be done using \"no-op\" introspector\n+         */\n+        if (isEnabled(Feature.USE_ANNOTATIONS)) {\n+            return super.getAnnotationIntrospector();\n+        }\n+        return NopAnnotationIntrospector.instance;\n+    }\n+    \n+    /**\n+     * Accessor for getting bean description that only contains class\n+     * annotations: useful if no getter/setter/creator information is needed.\n+     *<p>\n+     * Note: part of {@link MapperConfig} since 1.7\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends BeanDescription> T introspectClassAnnotations(JavaType type) {\n+        return (T) getClassIntrospector().forClassAnnotations(this, type, this);\n+    }\n+\n+    /**\n+     * Accessor for getting bean description that only contains immediate class\n+     * annotations: ones from the class, and its direct mix-in, if any, but\n+     * not from super types.\n+     *<p>\n+     * Note: part of {@link MapperConfig} since 1.7\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends BeanDescription> T introspectDirectClassAnnotations(JavaType type) {\n+        return (T) getClassIntrospector().forDirectClassAnnotations(this, type, this);\n+    }\n+    \n+    @Override\n+    public boolean isAnnotationProcessingEnabled() {\n+        return isEnabled(Feature.USE_ANNOTATIONS);\n+    }\n+\n+    @Override\n+    public boolean canOverrideAccessModifiers() {\n+        return isEnabled(Feature.CAN_OVERRIDE_ACCESS_MODIFIERS);\n+    }\n+\n+    @Override\n+    public boolean shouldSortPropertiesAlphabetically() {\n+        return _sortPropertiesAlphabetically;\n+    }\n+\n+    @Override\n+    public VisibilityChecker<?> getDefaultVisibilityChecker()\n+    {\n+        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n+        if (!isEnabled(DeserializationConfig.Feature.AUTO_DETECT_SETTERS)) {\n+            vchecker = vchecker.withSetterVisibility(Visibility.NONE);\n+        }\n+        if (!isEnabled(DeserializationConfig.Feature.AUTO_DETECT_CREATORS)) {\n+            vchecker = vchecker.withCreatorVisibility(Visibility.NONE);\n+        }\n+        if (!isEnabled(DeserializationConfig.Feature.AUTO_DETECT_FIELDS)) {\n+            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n+        }\n+        return vchecker;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* MapperConfig overrides for 1.8 backwards compatibility\n+    /**********************************************************\n+     */\n+\n+    /* NOTE: these are overloads we MUST have, but that were missing\n+     * from 1.9.0 and 1.9.1. Type erasure can bite in the ass...\n+     *<p>\n+     * NOTE: will remove either these variants, or base class one, in 2.0.\n+     */\n+    \n+    /**\n+     * An overload for {@link MapperConfig#isEnabled(MapperConfig.ConfigFeature)},\n+     * needed for backwards-compatibility.\n+     *<p>\n+     * NOTE: will remove either this variant, or base class one, in 2.0./\n+     * \n+     * @since 1.0 However, note that version 1.9.0 and 1.9.1 accidentally missed\n+     *    this overloaded variant\n+     */\n+    public boolean isEnabled(DeserializationConfig.Feature f) {\n+        return (_featureFlags & f.getMask()) != 0;\n+    }\n+\n+    /**\n+     * @deprecated Since 1.9, it is preferable to use {@link #with} instead;\n+     *    this method is deprecated as it modifies current instance instead of\n+     *    creating a new one (as the goal is to make this class immutable)\n+     */\n+    @Deprecated\n+    @Override\n+    public void enable(DeserializationConfig.Feature f) {\n+        super.enable(f);\n+    }\n+\n+    /** \n+     * @deprecated Since 1.9, it is preferable to use {@link #without} instead;\n+     *    this method is deprecated as it modifies current instance instead of\n+     *    creating a new one (as the goal is to make this class immutable)\n+     */\n+    @Deprecated\n+    @Override\n+    public void disable(DeserializationConfig.Feature f) {\n+        super.disable(f);\n+    }\n+\n+    /** \n+     * @deprecated Since 1.9, it is preferable to use {@link #without} and {@link #with} instead;\n+     *    this method is deprecated as it modifies current instance instead of\n+     *    creating a new one (as the goal is to make this class immutable)\n+     */\n+    @Deprecated\n+    @Override\n+    public void set(DeserializationConfig.Feature f, boolean state) {\n+        super.set(f, state);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Problem handlers\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for getting head of the problem handler chain. May be null,\n+     * if no handlers have been added.\n+     */\n+    public LinkedNode<DeserializationProblemHandler> getProblemHandlers()\n+    {\n+        return _problemHandlers;\n+    }\n+    \n+    /**\n+     * Method that can be used to add a handler that can (try to)\n+     * resolve non-fatal deserialization problems.\n+     */\n+    public void addHandler(DeserializationProblemHandler h)\n+    {\n+        /* Sanity check: let's prevent adding same handler multiple\n+         * times\n+         */\n+        if (!LinkedNode.contains(_problemHandlers, h)) {\n+            _problemHandlers = new LinkedNode<DeserializationProblemHandler>(h, _problemHandlers);\n+        }\n+    }\n+\n+    /**\n+     * Method for removing all configured problem handlers; usually done to replace\n+     * existing handler(s) with different one(s)\n+     *\n+     * @since 1.1\n+     */\n+    public void clearHandlers()\n+    {\n+        _problemHandlers = null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Other configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called during deserialization if Base64 encoded content\n+     * needs to be decoded. Default version just returns default Jackson\n+     * uses, which is modified-mime which does not add linefeeds (because\n+     * those would have to be escaped in JSON strings).\n+     */\n+    public Base64Variant getBase64Variant() {\n+        return Base64Variants.getDefaultVariant();\n+    }\n+\n+    /**\n+     * @since 1.6\n+     */\n+    public final JsonNodeFactory getNodeFactory() {\n+        return _nodeFactory;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Introspection methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will introspect full bean properties for the purpose\n+     * of building a bean deserializer\n+     *\n+     * @param type Type of class to be introspected\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends BeanDescription> T introspect(JavaType type) {\n+        return (T) getClassIntrospector().forDeserialization(this, type, this);\n+    }\n+\n+    /**\n+     * Method that will introspect subset of bean properties needed to\n+     * construct bean instance.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends BeanDescription> T introspectForCreation(JavaType type) {\n+        return (T) getClassIntrospector().forCreation(this, type, this);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API: handler instantiation\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonDeserializer<Object> deserializerInstance(Annotated annotated,\n+            Class<? extends JsonDeserializer<?>> deserClass)\n+    {\n+        HandlerInstantiator hi = getHandlerInstantiator();\n+        if (hi != null) {\n+            JsonDeserializer<?> deser = hi.deserializerInstance(this, annotated, deserClass);\n+            if (deser != null) {\n+                return (JsonDeserializer<Object>) deser;\n+            }\n+        }\n+        return (JsonDeserializer<Object>) ClassUtil.createInstance(deserClass, canOverrideAccessModifiers());\n+    }\n+\n+    public KeyDeserializer keyDeserializerInstance(Annotated annotated,\n+            Class<? extends KeyDeserializer> keyDeserClass)\n+    {\n+        HandlerInstantiator hi = getHandlerInstantiator();\n+        if (hi != null) {\n+            KeyDeserializer keyDeser = hi.keyDeserializerInstance(this, annotated, keyDeserClass);\n+            if (keyDeser != null) {\n+                return (KeyDeserializer) keyDeser;\n+            }\n+        }\n+        return (KeyDeserializer) ClassUtil.createInstance(keyDeserClass, canOverrideAccessModifiers());\n+    }\n+\n+    public ValueInstantiator valueInstantiatorInstance(Annotated annotated,\n+            Class<? extends ValueInstantiator> instClass)\n+    {\n+        HandlerInstantiator hi = getHandlerInstantiator();\n+        if (hi != null) {\n+            ValueInstantiator inst = hi.valueInstantiatorInstance(this, annotated, instClass);\n+            if (inst != null) {\n+                return (ValueInstantiator) inst;\n+            }\n+        }\n+        return (ValueInstantiator) ClassUtil.createInstance(instClass, canOverrideAccessModifiers());\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.ArrayBuilders;\n+import com.fasterxml.jackson.databind.util.ObjectBuffer;\n+\n+import org.codehaus.jackson.node.JsonNodeFactory;\n+\n+/**\n+ * Context for deserialization process. Used to allow passing in configuration\n+ * settings and reusable temporary objects (scrap arrays, containers).\n+ */\n+public abstract class DeserializationContext\n+{\n+    protected final DeserializationConfig _config;\n+\n+    /**\n+     * @since 1.7\n+     */\n+    protected final int _featureFlags;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    protected DeserializationContext(DeserializationConfig config)\n+    {\n+        _config = config;\n+        _featureFlags = config._featureFlags;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for accessing configuration setting object for\n+     * currently active deserialization.\n+     */\n+    public DeserializationConfig getConfig() { return _config; }\n+\n+    /**\n+     * Returns provider that can be used for dynamically locating\n+     * other deserializers during runtime.\n+     * \n+     * @since 1.5\n+     */\n+    public DeserializerProvider getDeserializerProvider() {\n+        // will be overridden by impl class\n+        return null;\n+    }\n+    \n+    /**\n+     * Convenience method for checking whether specified on/off\n+     * feature is enabled\n+     */\n+    public boolean isEnabled(DeserializationConfig.Feature feat) {\n+        /* 03-Dec-2010, tatu: minor shortcut; since this is called quite often,\n+         *   let's use a local copy of feature settings:\n+         */\n+        return (_featureFlags & feat.getMask()) != 0;\n+    }\n+\n+    /**\n+     * Convenience method for accessing the default Base64 encoding\n+     * used for decoding base64 encoded binary content.\n+     * Same as calling:\n+     *<pre>\n+     *  getConfig().getBase64Variant();\n+     *</pre>\n+     */\n+    public Base64Variant getBase64Variant() {\n+        return _config.getBase64Variant();\n+    }\n+\n+    /**\n+     * Accessor for getting access to the underlying JSON parser used\n+     * for deserialization.\n+     */\n+    public abstract JsonParser getParser();\n+\n+    public final JsonNodeFactory getNodeFactory() {\n+        return _config.getNodeFactory();\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    public JavaType constructType(Class<?> cls) {\n+        return _config.constructType(cls);\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public TypeFactory getTypeFactory() {\n+        return _config.getTypeFactory();\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public abstract Object findInjectableValue(Object valueId,\n+            BeanProperty forProperty, Object beanInstance);\n+    \n+    /*\n+    /**********************************************************\n+    /* Methods for accessing reusable/recyclable helper objects\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to get access to a reusable ObjectBuffer,\n+     * useful for efficiently constructing Object arrays and Lists.\n+     * Note that leased buffers should be returned once deserializer\n+     * is done, to allow for reuse during same round of deserialization.\n+     */\n+    public abstract ObjectBuffer leaseObjectBuffer();\n+\n+    /**\n+     * Method to call to return object buffer previously leased with\n+     * {@link #leaseObjectBuffer}.\n+     * \n+     * @param buf Returned object buffer\n+     */\n+    public abstract void returnObjectBuffer(ObjectBuffer buf);\n+\n+    /**\n+     * Method for accessing object useful for building arrays of\n+     * primitive types (such as int[]).\n+     */\n+    public abstract ArrayBuilders getArrayBuilders();\n+\n+    /*\n+    /**********************************************************\n+    /* Parsing methods that may use reusable/-cyclable objects\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Convenience method for parsing a Date from given String, using\n+     * currently configured date format (accessed using\n+     * {@link DeserializationConfig#getDateFormat()}).\n+     *<p>\n+     * Implementation will handle thread-safety issues related to\n+     * date formats such that first time this method is called,\n+     * date format is cloned, and cloned instance will be retained\n+     * for use during this deserialization round.\n+     */\n+    public abstract java.util.Date parseDate(String dateStr)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Convenience method for constructing Calendar instance set\n+     * to specified time, to be modified and used by caller.\n+     */\n+    public abstract Calendar constructCalendar(Date d);\n+\n+    /*\n+    /**********************************************************\n+    /* Methods for problem handling, reporting\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method deserializers can call to inform configured {@link DeserializationProblemHandler}s\n+     * of an unrecognized property.\n+     * \n+     * @return True if there was a configured problem handler that was able to handle the\n+     *   proble\n+     * \n+     * @since 1.5\n+     */\n+    public abstract boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser, Object instanceOrClass, String propName)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Helper method for constructing generic mapping exception for specified type\n+     */\n+    public abstract JsonMappingException mappingException(Class<?> targetClass);\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public abstract JsonMappingException mappingException(Class<?> targetClass, JsonToken t);\n+    \n+    /**\n+     * Helper method for constructing generic mapping exception with specified\n+     * message and current location information\n+     * \n+     * @since 1.7\n+     */\n+    public JsonMappingException mappingException(String message)\n+    {\n+        return JsonMappingException.from(getParser(), message);\n+    }\n+    \n+    /**\n+     * Helper method for constructing instantiation exception for specified type,\n+     * to indicate problem with physically constructing instance of\n+     * specified class (missing constructor, exception from constructor)\n+     */\n+    public abstract JsonMappingException instantiationException(Class<?> instClass, Throwable t);\n+\n+    public abstract JsonMappingException instantiationException(Class<?> instClass, String msg);\n+    \n+    /**\n+     * Helper method for constructing exception to indicate that input JSON\n+     * String was not in recognized format for deserializing into given type.\n+     */\n+    public abstract JsonMappingException weirdStringException(Class<?> instClass, String msg);\n+\n+    /**\n+     * Helper method for constructing exception to indicate that input JSON\n+     * Number was not suitable for deserializing into given type.\n+     */\n+    public abstract JsonMappingException weirdNumberException(Class<?> instClass, String msg);\n+\n+    /**\n+     * Helper method for constructing exception to indicate that given JSON\n+     * Object field name was not in format to be able to deserialize specified\n+     * key type.\n+     */\n+    public abstract JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg);\n+\n+    /**\n+     * Helper method for indicating that the current token was expected to be another\n+     * token.\n+     */\n+    public abstract JsonMappingException wrongTokenException(JsonParser jp, JsonToken expToken, String msg);\n+    \n+    /**\n+     * Helper method for constructing exception to indicate that JSON Object\n+     * field name did not map to a known property of type being\n+     * deserialized.\n+     * \n+     * @param instanceOrClass Either value being populated (if one has been\n+     *   instantiated), or Class that indicates type that would be (or\n+     *   have been) instantiated\n+     */\n+    public abstract JsonMappingException unknownFieldException(Object instanceOrClass, String fieldName);\n+\n+    /**\n+     * Helper method for constructing exception to indicate that given\n+     * type id (parsed from JSON) could not be converted to a Java type.\n+     * \n+     * @since 1.5\n+     */\n+    public abstract JsonMappingException unknownTypeException(JavaType baseType, String id);\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationProblemHandler.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+\n+/**\n+ * This is the class that can be registered (via\n+ * {@link DeserializationConfig} object owner by\n+ * {@link ObjectMapper}) to get calledn when a potentially\n+ * recoverable problem is encountered during deserialization\n+ * process. Handlers can try to resolve the problem, throw\n+ * an exception or do nothing.\n+ *<p>\n+ * Default implementations for all methods implemented minimal\n+ * \"do nothing\" functionality, which is roughly equivalent to\n+ * not having a registered listener at all. This allows for\n+ * only implemented handler methods one is interested in, without\n+ * handling other cases.\n+ * \n+ * @author tatu\n+ */\n+public abstract class DeserializationProblemHandler\n+{\n+    /**\n+     * Method called when a Json Map (\"Object\") entry with an unrecognized\n+     * name is encountered.\n+     * Content (supposedly) matching the property are accessible via\n+     * parser that can be obtained from passed deserialization context.\n+     * Handler can also choose to skip the content; if so, it MUST return\n+     * true to indicate it did handle property succesfully.\n+     * Skipping is usually done like so:\n+     *<pre>\n+     *  ctxt.getParser().skipChildren();\n+     *</pre>\n+     *<p>\n+     * Note: version 1.2 added new deserialization feature\n+     * (<code>DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES</code>).\n+     * It will only have effect <b>after</b> handler is called, and only\n+     * if handler did <b>not</b> handle the problem.\n+     *\n+     * @param beanOrClass Either bean instance being deserialized (if one\n+     *   has been instantiated so far); or Class that indicates type that\n+     *   will be instantiated (if no instantiation done yet: for example\n+     *   when bean uses non-default constructors)\n+     * \n+     * @return True if the problem was succesfully resolved (and content available\n+     *    used or skipped); false if listen\n+     */\n+    public boolean handleUnknownProperty(DeserializationContext ctxt, JsonDeserializer<?> deserializer,\n+                                         Object beanOrClass, String propertyName)\n+        throws IOException, JsonProcessingException\n+    {\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializerFactory.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiators;\n+import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n+import com.fasterxml.jackson.databind.type.*;\n+\n+\n+/**\n+ * Abstract class that defines API used by {@link DeserializerProvider}\n+ * to obtain actual\n+ * {@link JsonDeserializer} instances from multiple distinct factories.\n+ *<p>\n+ * Since there are multiple broad categories of deserializers, there are \n+ * multiple factory methods:\n+ *<ul>\n+ * <li>For JSON \"Array\" type, we need 2 methods: one to deal with expected\n+ *   Java arrays ({@link #createArrayDeserializer})\n+ *   and the other for other Java containers like {@link java.util.List}s\n+ *   and {@link java.util.Set}s ({@link #createCollectionDeserializer(DeserializationConfig, DeserializerProvider, CollectionType, BeanProperty)})\n+ *  </li>\n+ * <li>For JSON \"Object\" type, we need 2 methods: one to deal with\n+ *   expected Java {@link java.util.Map}s\n+ *   ({@link #createMapDeserializer}), and another for POJOs\n+ *   ({@link #createBeanDeserializer(DeserializationConfig, DeserializerProvider, JavaType, BeanProperty)}.\n+ *  </li>\n+ * <li>For Tree Model ({@link org.codehaus.jackson.JsonNode}) properties there is\n+ *    {@link #createTreeDeserializer(DeserializationConfig, DeserializerProvider, JavaType, BeanProperty)}\n+ * <li>For enumerated types ({@link java.lang.Enum}) there is\n+ *    {@link #createEnumDeserializer(DeserializationConfig, DeserializerProvider, JavaType, BeanProperty)}\n+ *  </li>\n+ * <li>For all other types, {@link #createBeanDeserializer(DeserializationConfig, DeserializerProvider, JavaType, BeanProperty)}\n+ *   is used.\n+ * </ul>\n+ *<p>\n+ * All above methods take 2 type arguments, except for the first one\n+ * which takes just a single argument.\n+ */\n+public abstract class DeserializerFactory\n+{\n+    protected final static Deserializers[] NO_DESERIALIZERS = new Deserializers[0];\n+\n+    /*\n+    /**********************************************************\n+    /* Helper class to contain configuration settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Configuration settings container class for bean deserializer factory\n+     * \n+     * @since 1.7\n+     */\n+    public abstract static class Config\n+    {\n+        /**\n+         * Fluent/factory method used to construct a configuration object that\n+         * has same deserializer providers as this instance, plus one specified\n+         * as argument. Additional provider will be added before existing ones,\n+         * meaning it has priority over existing definitions.\n+         */\n+        public abstract Config withAdditionalDeserializers(Deserializers additional);\n+\n+        /**\n+         * Fluent/factory method used to construct a configuration object that\n+         * has same key deserializer providers as this instance, plus one specified\n+         * as argument. Additional provider will be added before existing ones,\n+         * meaning it has priority over existing definitions.\n+         */\n+        public abstract Config withAdditionalKeyDeserializers(KeyDeserializers additional);\n+        \n+        /**\n+         * Fluent/factory method used to construct a configuration object that\n+         * has same configuration as this instance plus one additional\n+         * deserialiazer modifier. Added modifier has the highest priority (that is, it\n+         * gets called before any already registered modifier).\n+         */\n+        public abstract Config withDeserializerModifier(BeanDeserializerModifier modifier);\n+\n+        /**\n+         * Fluent/factory method used to construct a configuration object that\n+         * has same configuration as this instance plus one additional\n+         * abstract type resolver.\n+         * Added resolver has the highest priority (that is, it\n+         * gets called before any already registered resolver).\n+         * \n+         * @since 1.8\n+         */\n+        public abstract Config withAbstractTypeResolver(AbstractTypeResolver resolver);\n+\n+        /**\n+         * Fluent/factory method used to construct a configuration object that\n+         * has same configuration as this instance plus specified additional\n+         * value instantiator provider object.\n+         * Added instantiator provider has the highest priority (that is, it\n+         * gets called before any already registered resolver).\n+         * \n+         * @param instantiators Object that can provide {@link com.fasterxml.jackson.databind.deser.ValueInstantiator}s for\n+         *    constructing POJO values during deserialization\n+         * \n+         * @since 1.9\n+         */\n+        public abstract Config withValueInstantiators(ValueInstantiators instantiators);\n+        \n+        public abstract Iterable<Deserializers> deserializers();\n+\n+        /**\n+         * @since 1.8\n+         */\n+        public abstract Iterable<KeyDeserializers> keyDeserializers();\n+        \n+        public abstract Iterable<BeanDeserializerModifier> deserializerModifiers();\n+\n+        /**\n+         * @since 1.8\n+         */\n+        public abstract Iterable<AbstractTypeResolver> abstractTypeResolvers();\n+\n+        /**\n+         * @since 1.9\n+         */\n+        public abstract Iterable<ValueInstantiators> valueInstantiators();\n+        \n+        public abstract boolean hasDeserializers();\n+\n+        /**\n+         * @since 1.8\n+         */\n+        public abstract boolean hasKeyDeserializers();\n+        \n+        public abstract boolean hasDeserializerModifiers();\n+\n+        /**\n+         * @since 1.8\n+         */\n+        public abstract boolean hasAbstractTypeResolvers();\n+\n+        /**\n+         * @since 1.9\n+         */\n+        public abstract boolean hasValueInstantiators();\n+    }\n+\n+    /*\n+    /********************************************************\n+    /* Configuration handling\n+    /********************************************************\n+     */\n+\n+    /**\n+     * @since 1.7\n+     */\n+    public abstract Config getConfig();\n+    \n+    /**\n+     * Method used for creating a new instance of this factory, but with different\n+     * configuration. Reason for specifying factory method (instead of plain constructor)\n+     * is to allow proper sub-classing of factories.\n+     *<p>\n+     * Note that custom sub-classes <b>must override</b> implementation\n+     * of this method, as it usually requires instantiating a new instance of\n+     * factory type. Check out javadocs for\n+     * {@link com.fasterxml.jackson.databind.deser.BeanDeserializerFactory} for more details.\n+     * \n+     * @since 1.7\n+     */\n+    public abstract DeserializerFactory withConfig(Config config);\n+\n+    /**\n+     * Convenience method for creating a new factory instance with additional deserializer\n+     * provider.\n+     * \n+     * @since 1.7\n+     */\n+    public final DeserializerFactory withAdditionalDeserializers(Deserializers additional) {\n+        return withConfig(getConfig().withAdditionalDeserializers(additional));\n+    }\n+\n+    /**\n+     * Convenience method for creating a new factory instance with additional\n+     * {@link KeyDeserializers}.\n+     * \n+     * @since 1.8\n+     */\n+    public final DeserializerFactory withAdditionalKeyDeserializers(KeyDeserializers additional) {\n+        return withConfig(getConfig().withAdditionalKeyDeserializers(additional));\n+    }\n+    \n+    /**\n+     * Convenience method for creating a new factory instance with additional\n+     * {@link BeanDeserializerModifier}.\n+     * \n+     * @since 1.7\n+     */\n+    public final DeserializerFactory withDeserializerModifier(BeanDeserializerModifier modifier) {\n+        return withConfig(getConfig().withDeserializerModifier(modifier));\n+    }\n+\n+    /**\n+     * Convenience method for creating a new factory instance with additional\n+     * {@link AbstractTypeResolver}.\n+     * \n+     * @since 1.7\n+     */\n+    public final DeserializerFactory withAbstractTypeResolver(AbstractTypeResolver resolver) {\n+        return withConfig(getConfig().withAbstractTypeResolver(resolver));\n+    }\n+\n+    /**\n+     * Convenience method for creating a new factory instance with additional\n+     * {@link ValueInstantiators}.\n+     * \n+     * @since 1.9\n+     */\n+    public final DeserializerFactory withValueInstantiators(ValueInstantiators instantiators) {\n+        return withConfig(getConfig().withValueInstantiators(instantiators));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Basic DeserializerFactory API:\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be called to try to resolve an abstract type\n+     * (interface, abstract class) into a concrete type, or at least\n+     * something \"more concrete\" (abstract class instead of interface).\n+     * Will either return passed type, or a more specific type.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract JavaType mapAbstractType(DeserializationConfig config, JavaType type)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method that is to find all creators (constructors, factory methods)\n+     * for the bean type to deserialize.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract ValueInstantiator findValueInstantiator(DeserializationConfig config,\n+            BasicBeanDescription beanDesc)\n+        throws JsonMappingException;\n+    \n+    /**\n+     * Method called to create (or, for completely immutable deserializers,\n+     * reuse) a deserializer that can convert JSON content into values of\n+     * specified Java \"bean\" (POJO) type.\n+     * At this point it is known that the type is not otherwise recognized\n+     * as one of structured types (array, Collection, Map) or a well-known\n+     * JDK type (enum, primitives/wrappers, String); this method only\n+     * gets called if other options are exhausted. This also means that\n+     * this method can be overridden to add support for custom types.\n+     *\n+     * @param type Type to be deserialized\n+     * @param p Provider that can be called to create deserializers for\n+     *   contained member types\n+     */\n+    public abstract JsonDeserializer<Object> createBeanDeserializer(DeserializationConfig config, DeserializerProvider p,\n+            JavaType type, BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method called to create (or, for completely immutable deserializers,\n+     * reuse) a deserializer that can convert JSON content into values of\n+     * specified Java type.\n+     *\n+     * @param type Type to be deserialized\n+     * @param p Provider that can be called to create deserializers for\n+     *   contained member types\n+     */\n+    public abstract JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config, DeserializerProvider p,\n+            ArrayType type, BeanProperty property)\n+        throws JsonMappingException;\n+\n+    public abstract JsonDeserializer<?> createCollectionDeserializer(DeserializationConfig config,\n+            DeserializerProvider p, CollectionType type, BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /**\n+     * @since 1.8\n+     */\n+    public abstract JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationConfig config,\n+            DeserializerProvider p, CollectionLikeType type, BeanProperty property)\n+        throws JsonMappingException;\n+    \n+    public abstract JsonDeserializer<?> createEnumDeserializer(DeserializationConfig config,\n+            DeserializerProvider p, JavaType type, BeanProperty property)\n+        throws JsonMappingException;\n+\n+    public abstract JsonDeserializer<?> createMapDeserializer(DeserializationConfig config,\n+            DeserializerProvider p, MapType type, BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /**\n+     * @since 1.8\n+     */\n+    public abstract JsonDeserializer<?> createMapLikeDeserializer(DeserializationConfig config,\n+            DeserializerProvider p, MapLikeType type, BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method called to create and return a deserializer that can construct\n+     * JsonNode(s) from JSON content.\n+     */\n+    public abstract JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, DeserializerProvider p,\n+            JavaType type, BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method called to find if factory knows how to create a key deserializer\n+     * for specified type; currently this means checking if a module has registered\n+     * possible deserializers.\n+     * \n+     * @return Key deserializer to use for specified type, if one found; null if not\n+     *   (and default key deserializer should be used)\n+     * \n+     * @since 1.8\n+     */\n+    public KeyDeserializer createKeyDeserializer(DeserializationConfig config, JavaType type,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // Default implementation returns null for backwards compatibility reasons\n+        return null;\n+    }\n+    \n+    /**\n+     * Method called to find and create a type information deserializer for given base type,\n+     * if one is needed. If not needed (no polymorphic handling configured for type),\n+     * should return null.\n+     *<p>\n+     * Note that this method is usually only directly called for values of container (Collection,\n+     * array, Map) types and root values, but not for bean property values.\n+     *\n+     * @param baseType Declared base type of the value to deserializer (actual\n+     *    deserializer type will be this type or its subtype)\n+     * \n+     * @return Type deserializer to use for given base type, if one is needed; null if not.\n+     * \n+     * @since 1.5\n+     */\n+    public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // Default implementation returns null for backwards compatibility reasons\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializerProvider.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.core.io.SerializedString;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiators;\n+\n+\n+/**\n+ * Abstract class that defines API used by {@link ObjectMapper} and\n+ * {@link JsonDeserializer}s to obtain deserializers capable of\n+ * re-constructing instances of handled type from JSON content.\n+ */\n+public abstract class DeserializerProvider\n+{\n+    protected DeserializerProvider() { }\n+\n+    /*\n+    /**********************************************************\n+    /* Fluent factory methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that sub-classes need to override, to ensure that fluent-factory\n+     * methods will produce proper sub-type.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract DeserializerProvider withFactory(DeserializerFactory factory);\n+    \n+    /**\n+     * Method that is to configure {@link DeserializerFactory} that provider has\n+     * to use specified deserializer provider, with highest precedence (that is,\n+     * additional providers have higher precedence than default one or previously\n+     * added ones)\n+     * \n+     * @since 1.7\n+     */\n+    public abstract DeserializerProvider withAdditionalDeserializers(Deserializers d);\n+\n+    /**\n+     * @since 1.8\n+     */\n+    public abstract DeserializerProvider withAdditionalKeyDeserializers(KeyDeserializers d);\n+    \n+    /**\n+     * @since 1.7\n+     */\n+    public abstract DeserializerProvider withDeserializerModifier(BeanDeserializerModifier modifier);\n+\n+    /**\n+     * @since 1.8\n+     */\n+    public abstract DeserializerProvider withAbstractTypeResolver(AbstractTypeResolver resolver);\n+\n+    /**\n+     * Method that will construct a new instance with specified additional value instantiators\n+     * (i.e. does NOT replace existing ones)\n+     * \n+     * @since 1.9\n+     */\n+    public abstract DeserializerProvider withValueInstantiators(ValueInstantiators instantiators);\n+    \n+    /*\n+    /**********************************************************\n+    /* General deserializer locating method\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to get hold of a deserializer for a value of given type;\n+     * or if no such deserializer can be found, a default handler (which\n+     * may do a best-effort generic serialization or just simply\n+     * throw an exception when invoked).\n+     *<p>\n+     * Note: this method is only called for value types; not for keys.\n+     * Key deserializers can be accessed using {@link #findKeyDeserializer}.\n+     *\n+     * @param config Deserialization configuration\n+     * @param propertyType Declared type of the value to deserializer (obtained using\n+     *   'setter' method signature and/or type annotations\n+     * @param property Object that represents accessor for property value; field,\n+     *    setter method or constructor parameter.\n+     *\n+     * @throws JsonMappingException if there are fatal problems with\n+     *   accessing suitable deserializer; including that of not\n+     *   finding any serializer\n+     */\n+    public abstract JsonDeserializer<Object> findValueDeserializer(DeserializationConfig config,\n+            JavaType propertyType, BeanProperty property)\n+        throws JsonMappingException;\n+    \n+    /**\n+     * Method called to locate deserializer for given type, as well as matching\n+     * type deserializer (if one is needed); and if type deserializer is needed,\n+     * construct a \"wrapped\" deserializer that can extract and use type information\n+     * for calling actual deserializer.\n+     *<p>\n+     * Since this method is only called for root elements, no referral information\n+     * is taken.\n+     *    \n+     * @since 1.5\n+     */\n+    public abstract JsonDeserializer<Object> findTypedValueDeserializer(DeserializationConfig config,\n+            JavaType type, BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method called to get hold of a deserializer to use for deserializing\n+     * keys for {@link java.util.Map}.\n+     *\n+     * @throws JsonMappingException if there are fatal problems with\n+     *   accessing suitable key deserializer; including that of not\n+     *   finding any serializer\n+     */\n+    public abstract KeyDeserializer findKeyDeserializer(DeserializationConfig config,\n+            JavaType keyType, BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method called to find out whether provider would be able to find\n+     * a deserializer for given type, using a root reference (i.e. not\n+     * through fields or membership in an array or collection)\n+     */\n+    public abstract boolean hasValueDeserializerFor(DeserializationConfig config, JavaType type);\n+\n+    /*\n+    /**********************************************************\n+    /* Additional type handling methods, related\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be called to try to resolve an abstract type\n+     * (interface, abstract class) into a concrete type, or at least\n+     * something \"more concrete\" (abstract class instead of interface).\n+     * Will either return passed type, or a more specific type.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract JavaType mapAbstractType(DeserializationConfig config, JavaType type)\n+        throws JsonMappingException;\n+\n+\n+    /**\n+     * Method that can be used to try find expected root name for given type\n+     * \n+     * @since 1.9\n+     */\n+    public abstract SerializedString findExpectedRootName(DeserializationConfig config, JavaType type)\n+        throws JsonMappingException;\n+    \n+    /*\n+    /**********************************************************\n+    /* Access to caching aspects\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to determine how many deserializers this\n+     * provider is caching currently \n+     * (if it does caching: default implementation does)\n+     * Exact count depends on what kind of deserializers get cached;\n+     * default implementation caches only dynamically constructed deserializers,\n+     * but not eagerly constructed standard deserializers (which is different\n+     * from how serializer provider works).\n+     *<p>\n+     * The main use case for this method is to allow conditional flushing of\n+     * deserializer cache, if certain number of entries is reached.\n+     * \n+     * @since 1.4\n+     */\n+    public abstract int cachedDeserializersCount();\n+\n+    /**\n+     * Method that will drop all dynamically constructed deserializers (ones that\n+     * are counted as result value for {@link #cachedDeserializersCount}).\n+     * This can be used to remove memory usage (in case some deserializers are\n+     * only used once or so), or to force re-construction of deserializers after\n+     * configuration changes for mapper than owns the provider.\n+     * \n+     * @since 1.4\n+     */\n+    public abstract void flushCachedDeserializers();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/Deserializers.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.type.*;\n+\n+\n+/**\n+ * Interface that defines API for simple extensions that can provide additional deserializers\n+ * for various types. Access is by a single callback method; instance is to either return\n+ * a configured {@link JsonDeserializer} for specified type, or null to indicate that it\n+ * does not support handling of the type. In latter case, further calls can be made\n+ * for other providers; in former case returned deserializer is used for handling of\n+ * instances of specified type.\n+ *<p>\n+ * Unlike with {@link Serializers}, multiple different methods are used since different\n+ * kinds of types typically require different kinds of inputs.\n+ * \n+ * @since 1.7\n+ */\n+public interface Deserializers\n+{\n+    /**\n+     * Method called to locate serializer for specified array type.\n+     *<p>\n+     * Deserializer for element type may be passed, if configured explicitly at higher level (by\n+     * annotations, typically), but usually are not.\n+     * Type deserializer for element is passed if one is needed based on contextual information\n+     * (annotations on declared element class; or on field or method type is associated with).\n+     * \n+     * @param type Type of array instances to deserialize\n+     * @param config Configuration in effect\n+     * @param provider Provider that can be used to locate deserializer for component type (if\n+     *    one not provided, or needs to be overridden)\n+     * @param property Property that contains array value  (null for root values)\n+     * @param elementTypeDeserializer If element type needs polymorphic type handling, this is\n+     *    the type information deserializer to use; should usually be used as is when constructing\n+     *    array deserializer.\n+     * @param elementDeserializer Deserializer to use for elements, if explicitly defined (by using\n+     *    annotations, for exmple). May be null, in which case it should be resolved here (or using\n+     *    {@link ResolvableDeserializer} callback)\n+     * \n+     * @return Deserializer to use for the type; or null if this provider does not know how to construct it\n+     */\n+    public JsonDeserializer<?> findArrayDeserializer(ArrayType type, DeserializationConfig config,\n+            DeserializerProvider provider,\n+            BeanProperty property,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method called to locate serializer for specified {@link java.util.Collection} (List, Set etc) type.\n+     *<p>\n+     * Deserializer for element type may be passed, if configured explicitly at higher level (by\n+     * annotations, typically), but usually are not.\n+     * Type deserializer for element is passed if one is needed based on contextual information\n+     * (annotations on declared element class; or on field or method type is associated with).\n+     * \n+     * @param type Type of collection instances to deserialize\n+     * @param config Configuration in effect\n+     * @param provider Provider that can be used to locate dependant deserializers if and as necessary\n+     *   (but note that in many cases resolution must be deferred by using {@link ResolvableDeserializer} callback)\n+     * @param property Property that contains array value  (null for root values)\n+     * @param beanDesc Definition of the enumeration type that contains class annotations and\n+     *    other information typically needed for building deserializers (note: always instance\n+     *    of {@link com.fasterxml.jackson.databind.introspect.BasicBeanDescription})\n+     * @param elementTypeDeserializer If element type needs polymorphic type handling, this is\n+     *    the type information deserializer to use; should usually be used as is when constructing\n+     *    array deserializer.\n+     * @param elementDeserializer Deserializer to use for elements, if explicitly defined (by using\n+     *    annotations, for exmple). May be null, in which case it should be resolved here (or using\n+     *    {@link ResolvableDeserializer} callback)\n+     * \n+     * @return Deserializer to use for the type; or null if this provider does not know how to construct it\n+     */\n+    public JsonDeserializer<?> findCollectionDeserializer(CollectionType type, DeserializationConfig config,\n+            DeserializerProvider provider, BeanDescription beanDesc, BeanProperty property,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method called to locate serializer for specified\n+     * \"Collection-like\" type (one that acts\n+     * like {@link java.util.Collection} but does not implement it).\n+     *<p>\n+     * Deserializer for element type may be passed, if configured explicitly at higher level (by\n+     * annotations, typically), but usually are not.\n+     * Type deserializer for element is passed if one is needed based on contextual information\n+     * (annotations on declared element class; or on field or method type is associated with).\n+     * \n+     * @param type Type of instances to deserialize\n+     * @param config Configuration in effect\n+     * @param provider Provider that can be used to locate dependant deserializers if and as necessary\n+     *   (but note that in many cases resolution must be deferred by using {@link ResolvableDeserializer} callback)\n+     * @param property Property that contains array value  (null for root values)\n+     * @param beanDesc Definition of the enumeration type that contains class annotations and\n+     *    other information typically needed for building deserializers (note: always instance\n+     *    of {@link com.fasterxml.jackson.databind.introspect.BasicBeanDescription})\n+     * @param elementTypeDeserializer If element type needs polymorphic type handling, this is\n+     *    the type information deserializer to use; should usually be used as is when constructing\n+     *    array deserializer.\n+     * @param elementDeserializer Deserializer to use for elements, if explicitly defined (by using\n+     *    annotations, for exmple). May be null, in which case it should be resolved here (or using\n+     *    {@link ResolvableDeserializer} callback)\n+     * \n+     * @return Deserializer to use for the type; or null if this provider does not know how to construct it\n+     * \n+     * @since 1.8\n+     */\n+    public JsonDeserializer<?> findCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config,\n+            DeserializerProvider provider, BeanDescription beanDesc, BeanProperty property,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException;\n+    \n+    /**\n+     * Method called to locate deserializer for specified {@link java.lang.Enum} type.\n+     * \n+     * @param type Type of {@link java.lang.Enum} instances to deserialize\n+     * @param config Configuration in effect\n+     * @param beanDesc Definition of the enumeration type that contains class annotations and\n+     *    other information typically needed for building deserializers (note: always instance\n+     *    of {@link com.fasterxml.jackson.databind.introspect.BasicBeanDescription})\n+     * \n+     * @return Deserializer to use for the type; or null if this provider does not know how to construct it\n+     */\n+    public JsonDeserializer<?> findEnumDeserializer(Class<?> type, DeserializationConfig config,\n+            BeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method called to locate deserializer for specified {@link java.util.Map} type.\n+     *<p>\n+     * Deserializer for element type may be passed, if configured explicitly at higher level (by\n+     * annotations, typically), but usually are not.\n+     * Type deserializer for element is passed if one is needed based on contextual information\n+     * (annotations on declared element class; or on field or method type is associated with).\n+     *<p>\n+     * Similarly, a {@link KeyDeserializer} may be passed, but this is only done if there is\n+     * a specific configuration override (annotations) to indicate instance to use. Otherwise\n+     * null is passed, and key deserializer needs to be obtained using {@link DeserializerProvider}\n+     * \n+     * @param type Type of {@link java.util.Map} instances to deserialize\n+     * @param config Configuration in effect\n+     * @param provider Provider that can be used to locate dependant deserializers if and as necessary\n+     *   (but note that in many cases resolution must be deferred by using {@link ResolvableDeserializer} callback)\n+     * @param beanDesc Definition of the enumeration type that contains class annotations and\n+     *    other information typically needed for building deserializers (note: always instance\n+     *    of {@link com.fasterxml.jackson.databind.introspect.BasicBeanDescription})\n+     * @param keyDeserializer Key deserializer use, if it is defined via annotations or other configuration;\n+     *    null if default key deserializer for key type can be used.\n+     * @param elementTypeDeserializer If element type needs polymorphic type handling, this is\n+     *    the type information deserializer to use; should usually be used as is when constructing\n+     *    array deserializer.\n+     * @param elementDeserializer Deserializer to use for elements, if explicitly defined (by using\n+     *    annotations, for exmple). May be null, in which case it should be resolved here (or using\n+     *    {@link ResolvableDeserializer} callback)\n+     * \n+     * @return Deserializer to use for the type; or null if this provider does not know how to construct it\n+     */\n+    public JsonDeserializer<?> findMapDeserializer(MapType type, DeserializationConfig config,\n+            DeserializerProvider provider, BeanDescription beanDesc, BeanProperty property,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method called to locate serializer for specified\n+     * \"Map-like\" type (one that acts\n+     * like {@link java.util.Map} but does not implement it).\n+     *<p>\n+     * Deserializer for element type may be passed, if configured explicitly at higher level (by\n+     * annotations, typically), but usually are not.\n+     * Type deserializer for element is passed if one is needed based on contextual information\n+     * (annotations on declared element class; or on field or method type is associated with).\n+     *<p>\n+     * Similarly, a {@link KeyDeserializer} may be passed, but this is only done if there is\n+     * a specific configuration override (annotations) to indicate instance to use. Otherwise\n+     * null is passed, and key deserializer needs to be obtained using {@link DeserializerProvider}\n+     * \n+     * @param type Type of {@link java.util.Map} instances to deserialize\n+     * @param config Configuration in effect\n+     * @param provider Provider that can be used to locate dependant deserializers if and as necessary\n+     *   (but note that in many cases resolution must be deferred by using {@link ResolvableDeserializer} callback)\n+     * @param beanDesc Definition of the enumeration type that contains class annotations and\n+     *    other information typically needed for building deserializers (note: always instance\n+     *    of {@link com.fasterxml.jackson.databind.introspect.BasicBeanDescription})\n+     * @param keyDeserializer Key deserializer use, if it is defined via annotations or other configuration;\n+     *    null if default key deserializer for key type can be used.\n+     * @param elementTypeDeserializer If element type needs polymorphic type handling, this is\n+     *    the type information deserializer to use; should usually be used as is when constructing\n+     *    array deserializer.\n+     * @param elementDeserializer Deserializer to use for elements, if explicitly defined (by using\n+     *    annotations, for exmple). May be null, in which case it should be resolved here (or using\n+     *    {@link ResolvableDeserializer} callback)\n+     * \n+     * @return Deserializer to use for the type; or null if this provider does not know how to construct it\n+     * \n+     * @since 1.8\n+     */\n+    public JsonDeserializer<?> findMapLikeDeserializer(MapLikeType type, DeserializationConfig config,\n+            DeserializerProvider provider, BeanDescription beanDesc, BeanProperty property,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException;\n+    \n+    /**\n+     * Method called to locate deserializer for specified JSON tree node type.\n+     * \n+     * @param nodeType Specific type of JSON tree nodes to deserialize (subtype of {@link org.codehaus.jackson.JsonNode})\n+     * @param config Configuration in effect\n+     * \n+     * @return Deserializer to use for the type; or null if this provider does not know how to construct it\n+     */\n+    public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType, DeserializationConfig config,\n+            BeanProperty property)\n+        throws JsonMappingException;\n+    \n+    /**\n+     * Method called to locate deserializer for specified value type which does not belong to any other\n+     * category (not an Enum, Collection, Map, Array or tree node)\n+     * \n+     * @param type Bean type to deserialize\n+     * @param config Configuration in effect\n+     * @param provider Provider that can be used to locate dependant deserializers if and as necessary\n+     *   (but note that in many cases resolution must be deferred by using {@link ResolvableDeserializer} callback)\n+     * @param beanDesc Definition of the enumeration type that contains class annotations and\n+     *    other information typically needed for building deserializers (note: always instance\n+     *    of {@link com.fasterxml.jackson.databind.introspect.BasicBeanDescription})\n+     * \n+     * @return Deserializer to use for the type; or null if this provider does not know how to construct it\n+     */\n+    public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config,\n+            DeserializerProvider provider, BeanDescription beanDesc,\n+            BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Basic {@link Deserializers} implementation that implements all methods but provides\n+     * no deserializers. Its main purpose is to serve as a base class so that\n+     * sub-classes only need to override methods they need, as most of the time some\n+     * of methods are not needed (especially enumeration and array deserializers are\n+     * very rarely overridden).\n+     * \n+     * @since 1.9\n+     */\n+    public static class Base implements Deserializers\n+    {\n+        @Override\n+        public JsonDeserializer<?> findArrayDeserializer(ArrayType type, DeserializationConfig config,\n+                DeserializerProvider provider, BeanProperty property,\n+                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+            throws JsonMappingException\n+        {\n+            return null;\n+        }\n+\n+        @Override\n+        public JsonDeserializer<?> findCollectionDeserializer(CollectionType type, DeserializationConfig config,\n+                DeserializerProvider provider, BeanDescription beanDesc, BeanProperty property,\n+                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+            throws JsonMappingException\n+        {\n+            return null;\n+        }\n+\n+        @Override\n+        public JsonDeserializer<?> findCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config,\n+                DeserializerProvider provider, BeanDescription beanDesc, BeanProperty property,\n+                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+            throws JsonMappingException\n+        {\n+            return null;\n+        }\n+\n+        @Override\n+        public JsonDeserializer<?> findMapDeserializer(MapType type, DeserializationConfig config,\n+                DeserializerProvider provider, BeanDescription beanDesc, BeanProperty property,\n+                KeyDeserializer keyDeserializer,\n+                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+            throws JsonMappingException\n+        {\n+            return null;\n+        }\n+\n+        @Override\n+        public JsonDeserializer<?> findMapLikeDeserializer(MapLikeType type, DeserializationConfig config,\n+                DeserializerProvider provider, BeanDescription beanDesc, BeanProperty property,\n+                KeyDeserializer keyDeserializer,\n+                TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+            throws JsonMappingException\n+        {\n+            return null;\n+        }\n+\n+        @Override\n+        public JsonDeserializer<?> findEnumDeserializer(Class<?> type, DeserializationConfig config,\n+                BeanDescription beanDesc,\n+                BeanProperty property)\n+            throws JsonMappingException\n+        {\n+            return null;\n+        }\n+        \n+        @Override\n+        public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType,\n+                DeserializationConfig config,\n+                BeanProperty property)\n+            throws JsonMappingException\n+        {\n+            return null;\n+        }\n+\n+        @Override\n+        public JsonDeserializer<?> findBeanDeserializer(JavaType type, DeserializationConfig config,\n+                DeserializerProvider provider,\n+                BeanDescription beanDesc,\n+                BeanProperty property)\n+            throws JsonMappingException\n+        {\n+            return null;\n+        }\n+    }\n+\n+\n+    /**\n+     * @deprecated As of 1.9, use {@link Base} instead\n+     */\n+    @Deprecated\n+    public static class None extends Base { }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/HandlerInstantiator.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+\n+/**\n+ * Helper class used for handling details of creating handler instances (things\n+ * like {@link JsonSerializer}s, {@link JsonDeserializer}s, various type\n+ * handlers) of specific types. Actual handler type has been resolved at this\n+ * point, so instantiator is strictly responsible for providing a configured\n+ * instance by constructing and configuring a new instance, or possibly by\n+ * recycling a shared instance. One use case is that of allowing\n+ * dependency injection, which would otherwise be difficult to do.\n+ *<p>\n+ * Custom instances are allowed to return null to indicate that caller should\n+ * use the default instantiation handling (which just means calling no-argument\n+ * constructor via reflection).\n+ *<p>\n+ * Care has to be taken to ensure that if instance returned is shared, it will\n+ * be thread-safe; caller will not synchronize access to returned instances.\n+ * \n+ * @since 1.8\n+ */\n+public abstract class HandlerInstantiator\n+{\n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to get an instance of deserializer of specified type.\n+     * \n+     * @param config Deserialization configuration in effect\n+     * @param annotated Element (Class, Method, Field, constructor parameter) that\n+     *    had annotation defining class of deserializer to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param deserClass Class of deserializer instance to return\n+     * \n+     * @return Deserializer instance to use\n+     */\n+    public abstract JsonDeserializer<?> deserializerInstance(DeserializationConfig config,\n+            Annotated annotated, Class<? extends JsonDeserializer<?>> deserClass);\n+\n+    /**\n+     * Method called to get an instance of key deserializer of specified type.\n+     * \n+     * @param config Deserialization configuration in effect\n+     * @param annotated Element (Class, Method, Field, constructor parameter) that\n+     *    had annotation defining class of key deserializer to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param keyDeserClass Class of key deserializer instance to return\n+     * \n+     * @return Key deserializer instance to use\n+     */\n+    public abstract KeyDeserializer keyDeserializerInstance(DeserializationConfig config,\n+            Annotated annotated, Class<? extends KeyDeserializer> keyDeserClass);\n+    \n+    /**\n+     * Method called to get an instance of serializer of specified type.\n+     * \n+     * @param config Serialization configuration in effect\n+     * @param annotated Element (Class, Method, Field) that\n+     *    had annotation defining class of serializer to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param serClass Class of serializer instance to return\n+     * \n+     * @return Serializer instance to use\n+     */\n+    public abstract JsonSerializer<?> serializerInstance(SerializationConfig config,\n+            Annotated annotated, Class<? extends JsonSerializer<?>> serClass);\n+\n+    /**\n+     * Method called to get an instance of TypeResolverBuilder of specified type.\n+     * \n+     * @param config Mapper configuration in effect (either SerializationConfig or\n+     *   DeserializationConfig, depending on when instance is being constructed)\n+     * @param annotated annotated Element (Class, Method, Field) that\n+     *    had annotation defining class of builder to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param builderClass Class of builder instance to return\n+     * \n+     * @return TypeResolverBuilder instance to use\n+     */\n+    public abstract TypeResolverBuilder<?> typeResolverBuilderInstance(MapperConfig<?> config,\n+            Annotated annotated, Class<? extends TypeResolverBuilder<?>> builderClass);\n+\n+    /**\n+     * Method called to get an instance of TypeIdResolver of specified type.\n+     * \n+     * @param config Mapper configuration in effect (either SerializationConfig or\n+     *   DeserializationConfig, depending on when instance is being constructed)\n+     * @param annotated annotated Element (Class, Method, Field) that\n+     *    had annotation defining class of resolver to construct (to allow\n+     *    implementation use information from other annotations)\n+     * @param resolverClass Class of resolver instance to return\n+     * \n+     * @return TypeResolverBuilder instance to use\n+     */\n+    public abstract TypeIdResolver typeIdResolverInstance(MapperConfig<?> config,\n+            Annotated annotated, Class<? extends TypeIdResolver> resolverClass);\n+\n+    /**\n+     * Method called to construct an instance of ValueInstantiator of specified type.\n+     * \n+     * @since 1.9\n+     */\n+    public ValueInstantiator valueInstantiatorInstance(MapperConfig<?> config,\n+            Annotated annotated, Class<? extends ValueInstantiator> resolverClass) {\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/InjectableValues.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.util.*;\n+\n+/**\n+ * Abstract class that defines API for objects that provide value to\n+ * \"inject\" during deserialization. An instance of this object\n+ * \n+ * @since 1.9\n+ */\n+public abstract class InjectableValues\n+{\n+    /**\n+     * Method called to find value identified by id <code>valueId</code> to\n+     * inject as value of specified property during deserialization, passing\n+     * POJO instance in which value will be injected if it is available\n+     * (will be available when injected via field or setter; not available\n+     * when injected via constructor or factory method argument).\n+     * \n+     * @param valueId Object that identifies value to inject; may be a simple\n+     *   name or more complex identifier object, whatever provider needs\n+     * @param ctxt Deserialization context\n+     * @param forProperty Bean property in which value is to be injected\n+     * @param beanInstance Bean instance that contains property to inject,\n+     *    if available; null if bean has not yet been constructed.\n+     */\n+    public abstract Object findInjectableValue(Object valueId,\n+            DeserializationContext ctxt, BeanProperty forProperty,\n+            Object beanInstance);\n+\n+    /*\n+    /**********************************************************\n+    /* Standard implementation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Simple standard implementation which uses a simple Map to\n+     * store values to inject, identified by simple String keys.\n+     */\n+    public static class Std\n+        extends InjectableValues\n+    {\n+        protected final Map<String,Object> _values;\n+        \n+        public Std() {\n+            this(new HashMap<String,Object>());\n+        }\n+\n+        public Std(Map<String,Object> values) {\n+            _values = values;\n+        }\n+\n+        public Std addValue(String key, Object value)\n+        {\n+            _values.put(key, value);\n+            return this;\n+        }\n+\n+        public Std addValue(Class<?> classKey, Object value)\n+        {\n+            _values.put(classKey.getName(), value);\n+            return this;\n+        }\n+        \n+        @Override\n+        public Object findInjectableValue(Object valueId,\n+                DeserializationContext ctxt, BeanProperty forProperty,\n+                Object beanInstance)\n+        {\n+            if (!(valueId instanceof String)) {\n+                String type = (valueId == null) ? \"[null]\" : valueId.getClass().getName();\n+                throw new IllegalArgumentException(\"Unrecognized inject value id type (\"+type+\"), expecting String\");\n+            }\n+            String key = (String) valueId;\n+            Object ob = _values.get(key);\n+            if (ob == null && !_values.containsKey(key)) {\n+                throw new IllegalArgumentException(\"No injectable id with value '\"+key+\"' found (for property '\"\n+                        +forProperty.getName()+\"')\");\n+            }\n+            return ob;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Abstract class that defines API used by {@link ObjectMapper} (and\n+ * other chained {@link JsonDeserializer}s too) to deserialize Objects of\n+ * arbitrary types from JSON, using provided {@link JsonParser}.\n+ */\n+public abstract class JsonDeserializer<T>\n+{\n+    /*\n+    /**********************************************************\n+    /* Main deserialization methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that can be called to ask implementation to deserialize\n+     * JSON content into the value type this serializer handles.\n+     * Returned instance is to be constructed by method itself.\n+     *<p>\n+     * Pre-condition for this method is that the parser points to the\n+     * first event that is part of value to deserializer (and which \n+     * is never JSON 'null' literal, more on this below): for simple\n+     * types it may be the only value; and for structured types the\n+     * Object start marker.\n+     * Post-condition is that the parser will point to the last\n+     * event that is part of deserialized value (or in case deserialization\n+     * fails, event that was not recognized or usable, which may be\n+     * the same event as the one it pointed to upon call).\n+     *<p>\n+     * Note that this method is never called for JSON null literal,\n+     * and thus deserializers need (and should) not check for it.\n+     *\n+     * @param jp Parsed used for reading JSON content\n+     * @param ctxt Context that can be used to access information about\n+     *   this deserialization activity.\n+     *\n+     * @return Deserializer value\n+     */\n+    public abstract T deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Alternate deserialization method (compared to the most commonly\n+     * used, {@link #deserialize(JsonParser, DeserializationContext)}),\n+     * which takes in initialized value instance, to be\n+     * configured and/or populated by deserializer.\n+     * Method is not necessarily used for all supported types; most commonly\n+     * it is used\n+     * for Collections and Maps.\n+     *<p>\n+     * Default implementation just throws\n+     * {@link UnsupportedOperationException}, to indicate that types\n+     * that do not explicitly add support do not expect to get the call.\n+     */\n+    public T deserialize(JsonParser jp, DeserializationContext ctxt,\n+                         T intoValue)\n+        throws IOException, JsonProcessingException\n+    {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /**\n+     * Deserialization called when type being deserialized is defined to\n+     * contain additional type identifier, to allow for correctly\n+     * instantiating correct subtype. This can be due to annotation on\n+     * type (or its supertype), or due to global settings without\n+     * annotations.\n+     *<p>\n+     * Default implementation may work for some types, but ideally subclasses\n+     * should not rely on current default implementation.\n+     * Implementation is mostly provided to avoid compilation errors with older\n+     * code.\n+     * \n+     * @param typeDeserializer Deserializer to use for handling type information\n+     * \n+     * @since 1.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        // We could try calling \n+        return (T) typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Fluent factory methods for constructing decorated versions\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will return deserializer instance that is able\n+     * to handle \"unwrapped\" value instances\n+     * If no unwrapped instance can be constructed, will simply\n+     * return this object as-is.\n+     *<p>\n+     * Default implementation just returns 'this'\n+     * indicating that no unwrapped variant exists\n+     * \n+     * @since 1.9\n+     */\n+    public JsonDeserializer<T> unwrappingDeserializer() {\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other accessors\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that can be called to determine value to be used for\n+     * representing null values (values deserialized when JSON token\n+     * is {@link JsonToken#VALUE_NULL}). Usually this is simply\n+     * Java null, but for some types (especially primitives) it may be\n+     * necessary to use non-null values.\n+     *<p>\n+     * Note that deserializers are allowed to call this just once and\n+     * then reuse returned value; that is, method is not guaranteed to\n+     * be called once for each conversion.\n+     *<p>\n+     * Default implementation simply returns null.\n+     */\n+    public T getNullValue() { return null; }\n+\n+    /**\n+     * Method called to determine value to be used for \"empty\" values\n+     * (most commonly when deserializing from empty JSON Strings).\n+     * Usually this is same as {@link #getNullValue} (which in turn\n+     * is usually simply Java null), but it can be overridden\n+     * for types. Or, if type should never be converted from empty\n+     * String, method can also throw an exception.\n+     *<p>\n+     * Default implementation simple calls {@link #getNullValue} and\n+     * returns value.\n+     * \n+     * @since 1.9\n+     */\n+    public T getEmptyValue() { return getNullValue(); }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This marker class is only to be used with annotations, to\n+     * indicate that <b>no deserializer is configured</b>.\n+     *<p>\n+     * Specifically, this class is to be used as the marker for\n+     * annotation {@link com.fasterxml.jackson.databind.annotate.JsonDeserialize}\n+     */\n+    public abstract static class None\n+        extends JsonDeserializer<Object> { }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.Serializable;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Checked exception used to signal fatal problems with mapping of\n+ * content.\n+ *<p>\n+ * One additional feature is the ability to denote relevant path\n+ * of references (during serialization/deserialization) to help in\n+ * troubleshooting.\n+ */\n+public class JsonMappingException\n+    extends JsonProcessingException\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Let's limit length of reference chain, to limit damage in cases\n+     * of infinite recursion.\n+     */\n+    final static int MAX_REFS_TO_LIST = 1000;\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Simple bean class used to contain references. References\n+     * can be added to indicate execution/reference path that\n+     * lead to the problem that caused this exception to be\n+     * thrown.\n+     */\n+    public static class Reference implements Serializable\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        /**\n+         * Object through which reference was resolved. Can be either\n+         * actual instance (usually the case for serialization), or\n+         * Class (usually the case for deserialization).\n+         */\n+        protected Object _from;\n+\n+        /**\n+         * Name of field (for beans) or key (for Maps) that is part\n+         * of the reference. May be null for Collection types (which\n+         * generally have {@link #_index} defined), or when resolving\n+         * Map classes without (yet) having an instance to operate on.\n+         */\n+        protected String _fieldName;\n+\n+        /**\n+         * Index within a {@link Collection} instance that contained\n+         * the reference; used if index is relevant and available.\n+         * If either not applicable, or not available, -1 is used to\n+         * denote \"not known\".\n+         */\n+        protected int _index = -1;\n+\n+        /**\n+         * Default constructor for deserialization/sub-classing purposes\n+         */\n+        protected Reference() { }\n+\n+        public Reference(Object from) { _from = from; }\n+\n+        public Reference(Object from, String fieldName) {\n+            _from = from;\n+            if (fieldName == null) {\n+                throw new NullPointerException(\"Can not pass null fieldName\");\n+            }\n+            _fieldName = fieldName;\n+        }\n+\n+        public Reference(Object from, int index) {\n+            _from = from;\n+            _index = index;\n+        }\n+\n+        public void setFrom(Object o) { _from = o; }\n+        public void setFieldName(String n) { _fieldName = n; }\n+        public void setIndex(int ix) { _index = ix; }\n+\n+        public Object getFrom() { return _from; }\n+        public String getFieldName() { return _fieldName; }\n+        public int getIndex() { return _index; }\n+\n+        @Override public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            Class<?> cls = (_from instanceof Class<?>) ?\n+                ((Class<?>)_from) : _from.getClass();\n+            /* Hmmh. Although Class.getName() is mostly ok, it does look\n+             * butt-ugly for arrays. So let's use getSimpleName() instead;\n+             * but have to prepend package name too.\n+             */\n+            Package pkg = cls.getPackage();\n+            if (pkg != null) {\n+                sb.append(pkg.getName());\n+                sb.append('.');\n+            }\n+            sb.append(cls.getSimpleName());\n+            sb.append('[');\n+            if (_fieldName != null) {\n+                sb.append('\"');\n+                sb.append(_fieldName);\n+                sb.append('\"');\n+            } else if (_index >= 0) {\n+                sb.append(_index);\n+            } else {\n+                sb.append('?');\n+            }\n+            sb.append(']');\n+            return sb.toString();\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* State/configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Path through which problem that triggering throwing of\n+     * this exception was reached.\n+     */\n+    protected LinkedList<Reference> _path;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public JsonMappingException(String msg)\n+    {\n+        super(msg);\n+    }\n+\n+    public JsonMappingException(String msg, Throwable rootCause)\n+    {\n+        super(msg, rootCause);\n+    }\n+\n+    public JsonMappingException(String msg, JsonLocation loc)\n+    {\n+        super(msg, loc);\n+    }\n+\n+    public JsonMappingException(String msg, JsonLocation loc, Throwable rootCause)\n+    {\n+        super(msg, loc, rootCause);\n+    }\n+\n+    public static JsonMappingException from(JsonParser jp, String msg)\n+    {\n+        return new JsonMappingException(msg, jp.getTokenLocation());\n+    }\n+\n+    public static JsonMappingException from(JsonParser jp, String msg,\n+                                            Throwable problem)\n+    {\n+        return new JsonMappingException(msg, jp.getTokenLocation(), problem);\n+    }\n+\n+    /**\n+     * Method that can be called to either create a new JsonMappingException\n+     * (if underlying exception is not a JsonMappingException), or augment\n+     * given exception with given path/reference information.\n+     *\n+     * This version of method is called when the reference is through a\n+     * non-indexed object, such as a Map or POJO/bean.\n+     */\n+    public static JsonMappingException wrapWithPath(Throwable src, Object refFrom,\n+                                                    String refFieldName)\n+    {\n+        return wrapWithPath(src, new Reference(refFrom, refFieldName));\n+    }\n+\n+    /**\n+     * Method that can be called to either create a new JsonMappingException\n+     * (if underlying exception is not a JsonMappingException), or augment\n+     * given exception with given path/reference information.\n+     *\n+     * This version of method is called when the reference is through an\n+     * index, which happens with arrays and Collections.\n+     */\n+    public static JsonMappingException wrapWithPath(Throwable src, Object refFrom,\n+                                                    int index)\n+    {\n+        return wrapWithPath(src, new Reference(refFrom, index));\n+    }\n+\n+    /**\n+     * Method that can be called to either create a new JsonMappingException\n+     * (if underlying exception is not a JsonMappingException), or augment\n+     * given exception with given path/reference information.\n+     */\n+    public static JsonMappingException wrapWithPath(Throwable src, Reference ref)\n+    {\n+        JsonMappingException jme;\n+        if (src instanceof JsonMappingException) {\n+            jme = (JsonMappingException) src;\n+        } else {\n+            String msg = src.getMessage();\n+            /* Related to [JACKSON-62], let's use a more meaningful placeholder\n+             * if all we have is null\n+             */\n+            if (msg == null || msg.length() == 0) {\n+                msg = \"(was \"+src.getClass().getName()+\")\";\n+            }\n+            jme = new JsonMappingException(msg, null, src);\n+        }\n+        jme.prependPath(ref);\n+        return jme;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Accessors/mutators\n+    /**********************************************************\n+     */\n+\n+    public List<Reference> getPath()\n+    {\n+        if (_path == null) {\n+            return Collections.emptyList();\n+        }\n+        return Collections.unmodifiableList(_path);\n+    }\n+\n+    /**\n+     * Method called to prepend a reference information in front of\n+     * current path\n+     */\n+    public void prependPath(Object referrer, String fieldName)\n+    {\n+        Reference ref = new Reference(referrer, fieldName);\n+        prependPath(ref);\n+    }\n+    /**\n+     * Method called to prepend a reference information in front of\n+     * current path\n+     */\n+    public void prependPath(Object referrer, int index)\n+    {\n+        Reference ref = new Reference(referrer, index);\n+        prependPath(ref);\n+    }\n+\n+    public void prependPath(Reference r)\n+    {\n+        if (_path == null) {\n+            _path = new LinkedList<Reference>();\n+        }\n+        /* Also: let's not increase without bounds. Could choose either\n+         * head or tail; tail is easier (no need to ever remove), as\n+         * well as potentially more useful so let's use it:\n+         */\n+        if (_path.size() < MAX_REFS_TO_LIST) {\n+            _path.addFirst(r);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method is overridden so that we can properly inject description\n+     * of problem path, if such is defined.\n+     */\n+    @Override\n+    public String getMessage()\n+    {\n+        /* First: if we have no path info, let's just use parent's\n+         * definition as is\n+         */\n+        String msg = super.getMessage();\n+        if (_path == null) {\n+            return msg;\n+        }\n+        /* 19-Feb-2009, tatu: Null and empty messages are not very\n+         *   useful (plus nulls would lead to NPEs), so let's\n+         *   use something else\n+         */\n+        StringBuilder sb = (msg == null) ? new StringBuilder() : new StringBuilder(msg);\n+        /* 18-Feb-2009, tatu: initially there was a linefeed between\n+         *    message and path reference; but unfortunately many systems\n+         *   (loggers, junit) seem to assume linefeeds are only added to\n+         *   separate stack trace.\n+         */\n+        sb.append(\" (through reference chain: \");\n+        _appendPathDesc(sb);\n+        sb.append(')');\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return getClass().getName()+\": \"+getMessage();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    protected void _appendPathDesc(StringBuilder sb)\n+    {\n+        Iterator<Reference> it = _path.iterator();\n+        while (it.hasNext()) {\n+            sb.append(it.next().toString());\n+            if (it.hasNext()) {\n+                sb.append(\"->\");\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializable.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Interface that can be implemented by objects that know how to\n+ * serialize themselves to JSON, using {@link JsonGenerator}\n+ * (and {@link SerializerProvider} if necessary).\n+ *<p>\n+ * Note that implementing this interface binds implementing object\n+ * closely to Jackson API, and that it is often not necessary to do\n+ * so -- if class is a bean, it can be serialized without\n+ * implementing this interface.\n+ *<p>\n+ * NOTE: as of version 1.5, this interface is missing one crucial\n+ * aspect, that of dealing with type information embedding.\n+ * Because of this, this interface is deprecated, although will be\n+ * fully supported for all 1.x releases, and will work except for\n+ * cases where polymorphic type information handling is needed for\n+ * type (in which case implementing if {@link JsonSerializableWithType} is crucial).\n+ *\n+ * @see com.fasterxml.jackson.databind.JsonSerializableWithType\n+ *\n+ * @since 1.5\n+ */\n+@Deprecated\n+public interface JsonSerializable\n+{\n+    public void serialize(JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonProcessingException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializableWithType.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+\n+/**\n+ * Interface that is to replace {@link JsonSerializable} to\n+ * allow for dynamic type information embedding.\n+ * \n+ * @author tatu\n+ */\n+@SuppressWarnings(\"deprecation\")\n+public interface JsonSerializableWithType\n+    extends JsonSerializable\n+{\n+    public void serializeWithType(JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Abstract class that defines API used by {@link ObjectMapper} (and\n+ * other chained {@link JsonSerializer}s too) to serialize Objects of\n+ * arbitrary types into JSON, using provided {@link JsonGenerator}.\n+ *<p>\n+ * NOTE: it is recommended that custom serializers extend\n+ * {@link com.fasterxml.jackson.databind.ser.std.SerializerBase} instead\n+ * of this class, since it will implement many of optional\n+ * methods of this class.\n+ */\n+public abstract class JsonSerializer<T>\n+{\n+    /*\n+    /**********************************************************\n+    /* Fluent factory methods for constructing decorated versions\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will return serializer instance that produces\n+     * \"unwrapped\" serialization, if applicable for type being\n+     * serialized (which is the case for some serializers\n+     * that produce JSON Objects as output).\n+     * If no unwrapped serializer can be constructed, will simply\n+     * return serializer as-is.\n+     *<p>\n+     * Default implementation just returns serializer as-is,\n+     * indicating that no unwrapped variant exists\n+     * \n+     * @since 1.9\n+     */\n+    public JsonSerializer<T> unwrappingSerializer() {\n+        return this;\n+    }\n+\n+    /**\n+     * Accessor for checking whether this serializer is an\n+     * \"unwrapping\" serializer; this is necessary to know since\n+     * it may also require caller to suppress writing of the\n+     * leading property name.\n+     * \n+     * @since 1.9\n+     */\n+    public boolean isUnwrappingSerializer() {\n+        return false;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Serialization methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be called to ask implementation to serialize\n+     * values of type this serializer handles.\n+     *\n+     * @param value Value to serialize; can <b>not</b> be null.\n+     * @param jgen Generator used to output resulting Json content\n+     * @param provider Provider that can be used to get serializers for\n+     *   serializing Objects value contains, if any.\n+     */\n+    public abstract void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method that can be called to ask implementation to serialize\n+     * values of type this serializer handles, using specified type serializer\n+     * for embedding necessary type information.\n+     *<p>\n+     * Default implementation will ignore serialization of type information,\n+     * and just calls {@link #serialize}: serializers that can embed\n+     * type information should override this to implement actual handling.\n+     * Most common such handling is done by something like:\n+     *<pre>\n+     *  // note: method to call depends on whether this type is serialized as JSON scalar, object or Array!\n+     *  typeSer.writeTypePrefixForScalar(value, jgen);\n+     *  serialize(value, jgen, provider);\n+     *  typeSer.writeTypeSuffixForScalar(value, jgen);\n+     *</pre>\n+     *\n+     * @param value Value to serialize; can <b>not</b> be null.\n+     * @param jgen Generator used to output resulting Json content\n+     * @param provider Provider that can be used to get serializers for\n+     *   serializing Objects value contains, if any.\n+     * @param typeSer Type serializer to use for including type information\n+     *\n+     * @since 1.5\n+     */\n+    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException\n+    {\n+        serialize(value, jgen, provider);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Introspection methods needed for type handling \n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for accessing type of Objects this serializer can handle.\n+     * Note that this information is not guaranteed to be exact -- it\n+     * may be a more generic (super-type) -- but it should not be\n+     * incorrect (return a non-related type).\n+     *<p>\n+     * Default implementation will return null, which essentially means\n+     * same as returning <code>Object.class</code> would; that is, that\n+     * nothing is known about handled type.\n+     *<p>\n+     */\n+    public Class<T> handledType() { return null; }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper class(es)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This marker class is only to be used with annotations, to\n+     * indicate that <b>no serializer is configured</b>.\n+     *<p>\n+     * Specifically, this class is to be used as the marker for\n+     * annotation {@link com.fasterxml.jackson.databind.annotate.JsonSerialize}.\n+     */\n+    public abstract static class None\n+        extends JsonSerializer<Object> { }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/KeyDeserializer.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Abstract class that defines API used for deserializing JSON content\n+ * field names into Java Map keys. These deserializers are only used\n+ * if the Map key class is not <code>String</code> or <code>Object</code>.\n+ */\n+public abstract class KeyDeserializer\n+{\n+    /**\n+     * Method called to deserialize a {@link java.util.Map} key from JSON property name.\n+     */\n+    public abstract Object deserializeKey(String key, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * This marker class is only to be used with annotations, to\n+     * indicate that <b>no deserializer is configured</b>.\n+     *<p>\n+     * Specifically, this class is to be used as the marker for\n+     * annotation {@link com.fasterxml.jackson.databind.annotate.JsonDeserialize}.\n+     *\n+     * @since 1.3\n+     */\n+    public abstract static class None\n+        extends KeyDeserializer { }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/KeyDeserializers.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Interface that defines API for simple extensions that can provide additional deserializers\n+ * for deserializer Map keys of various types, from JSON property names.\n+ * Access is by a single callback method; instance is to either return\n+ * a configured {@link KeyDeserializer} for specified type, or null to indicate that it\n+ * does not support handling of the type. In latter case, further calls can be made\n+ * for other providers; in former case returned key deserializer is used for handling of\n+ * key instances of specified type.\n+ * \n+ * @since 1.8\n+ */\n+public interface KeyDeserializers\n+{\n+    public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config,\n+            BeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/MapperConfig.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.text.DateFormat;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+import com.fasterxml.jackson.databind.type.TypeBindings;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.StdDateFormat;\n+\n+\n+/**\n+ * Interface that defines functionality accessible through both\n+ * serialization and deserialization configuration objects;\n+ * accessors to mode-independent configuration settings\n+ * and such.\n+ *<p>\n+ * As of version 1.9, the goal is to make this class eventually immutable.\n+ * Because of this, existing methods that allow changing state of this\n+ * instance are deprecated in favor of methods that create new instances\n+ * with different configuration (\"fluent factories\").\n+ * One major remaining issue is that of handling mix-in annotations, which\n+ * still represent a bit of mutable state; may need to implement a\n+ * functional-style immutable map for storing those.\n+ *\n+ * @since 1.2 -- major change in 1.8, changed from interface to\n+ *   abstract class\n+ */\n+public abstract class MapperConfig<T extends MapperConfig<T>>\n+    implements ClassIntrospector.MixInResolver\n+{\n+    /*\n+    /**********************************************************\n+    /* Constants, default values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This is the default {@link DateFormat} used unless overridden by\n+     * custom implementation.\n+     */\n+    protected final static DateFormat DEFAULT_DATE_FORMAT = StdDateFormat.instance;\n+\n+    /*\n+    /**********************************************************\n+    /* Simple immutable basic settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Immutable container object for simple configuration settings.\n+     *<p>\n+     * Note: ideally this would be final, but until we can eliminate\n+     * mutators, must keep it mutable.\n+     */\n+    protected Base _base;\n+    \n+    /*\n+    /**********************************************************\n+    /* Mix-in annotations\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Mapping that defines how to apply mix-in annotations: key is\n+     * the type to received additional annotations, and value is the\n+     * type that has annotations to \"mix in\".\n+     *<p>\n+     * Annotations associated with the value classes will be used to\n+     * override annotations of the key class, associated with the\n+     * same field or method. They can be further masked by sub-classes:\n+     * you can think of it as injecting annotations between the target\n+     * class and its sub-classes (or interfaces)\n+     *\n+     * @since 1.2\n+     */\n+    protected HashMap<ClassKey,Class<?>> _mixInAnnotations;\n+\n+    /**\n+     * Flag used to detect when a copy if mix-in annotations is\n+     * needed: set when current copy is shared, cleared when a\n+     * fresh copy is made\n+     *\n+     * @since 1.2\n+     */\n+    protected boolean _mixInAnnotationsShared;\n+\n+    /*\n+    /**********************************************************\n+    /* \"Late bound\" settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Registered concrete subtypes that can be used instead of (or\n+     * in addition to) ones declared using annotations.\n+     * Unlike most other settings, it is not configured as early\n+     * as it is set, but rather only when a non-shared instance\n+     * is constructed by <code>ObjectMapper</code> (or -Reader\n+     * or -Writer)\n+     *<p>\n+     * Note: this is the only property left as non-final, to allow\n+     * lazy construction of the instance as necessary.\n+     * \n+     * @since 1.6\n+     */\n+    protected SubtypeResolver _subtypeResolver;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructors\n+    /**********************************************************\n+     */\n+\n+    protected MapperConfig(ClassIntrospector<? extends BeanDescription> ci, AnnotationIntrospector ai,\n+            VisibilityChecker<?> vc, SubtypeResolver str, PropertyNamingStrategy pns, TypeFactory tf,\n+            HandlerInstantiator hi)\n+    {\n+        _base = new Base(ci, ai, vc, pns, tf, null, DEFAULT_DATE_FORMAT, hi);\n+        _subtypeResolver = str;\n+        // by default, assumed to be shared; only cleared when explicit copy is made\n+        _mixInAnnotationsShared = true;\n+    }\n+\n+    /**\n+     * Simple copy constructor\n+     * \n+     * @since 1.8\n+     */\n+    protected MapperConfig(MapperConfig<T> src) {\n+        this(src, src._base, src._subtypeResolver);\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    protected MapperConfig(MapperConfig<T> src, MapperConfig.Base base, SubtypeResolver str)\n+    {\n+        _base = base;\n+        _subtypeResolver = str;\n+        // by default, assumed to be shared; only cleared when explicit copy is made\n+        _mixInAnnotationsShared = true;\n+        _mixInAnnotations = src._mixInAnnotations;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: factory methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that checks class annotations that the argument Object has,\n+     * and modifies settings of this configuration object accordingly,\n+     * similar to how those annotations would affect actual value classes\n+     * annotated with them, but with global scope. Note that not all\n+     * annotations have global significance, and thus only subset of\n+     * Jackson annotations will have any effect.\n+     * \n+     * @deprecated Since 1.9, it is preferably to explicitly configure\n+     *   instances; this method also modifies existing instance which is\n+     *   against immutable design goals of this class.\n+     */\n+    @Deprecated\n+    public abstract void fromAnnotations(Class<?> cls);\n+\n+    /**\n+     * Method to use for constructing an instance that is not shared\n+     * between multiple operations but only used for a single one\n+     * (which may be this instance, if it is immutable; if not, a copy\n+     * is constructed with same settings)\n+     * \n+     * @since 1.8\n+     */\n+    public abstract T createUnshared(SubtypeResolver subtypeResolver);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link ClassIntrospector}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     * \n+     * @since 1.8\n+     */\n+    public abstract T withClassIntrospector(ClassIntrospector<? extends BeanDescription> ci);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link AnnotationIntrospector} to use (replacing old one).\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     * \n+     * @since 1.8\n+     */\n+    public abstract T withAnnotationIntrospector(AnnotationIntrospector ai);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link VisibilityChecker}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     * \n+     * @since 1.8\n+     */\n+    public abstract T withVisibilityChecker(VisibilityChecker<?> vc);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * minimal visibility level for specified property type\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract T withVisibility(JsonMethod forMethod, JsonAutoDetect.Visibility visibility);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link TypeResolverBuilder}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     * \n+     * @since 1.8\n+     */\n+    public abstract T withTypeResolverBuilder(TypeResolverBuilder<?> trb);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link SubtypeResolver}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     * \n+     * @since 1.8\n+     */\n+    public abstract T withSubtypeResolver(SubtypeResolver str);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link PropertyNamingStrategy}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     * \n+     * @since 1.8\n+     */\n+    public abstract T withPropertyNamingStrategy(PropertyNamingStrategy strategy);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link TypeFactory}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     * \n+     * @since 1.8\n+     */\n+    public abstract T withTypeFactory(TypeFactory typeFactory);\n+    \n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link DateFormat}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     * \n+     * @since 1.8\n+     */\n+    public abstract T withDateFormat(DateFormat df);\n+\n+    /**\n+     * Method for constructing and returning a new instance with different\n+     * {@link HandlerInstantiator}\n+     * to use.\n+     *<p>\n+     * NOTE: make sure to register new instance with <code>ObjectMapper</code>\n+     * if directly calling this method.\n+     * \n+     * @since 1.8\n+     */\n+    public abstract T withHandlerInstantiator(HandlerInstantiator hi);\n+\n+    /**\n+     * Method for constructing and returning a new instance with additional\n+     * {@link AnnotationIntrospector} inserted (as the highest priority one)\n+     * \n+     * @since 1.9\n+     */\n+    public abstract T withInsertedAnnotationIntrospector(AnnotationIntrospector introspector);\n+\n+    /**\n+     * Method for constructing and returning a new instance with additional\n+     * {@link AnnotationIntrospector} appended (as the lowest priority one)\n+     * \n+     * @since 1.9\n+     */\n+    public abstract T withAppendedAnnotationIntrospector(AnnotationIntrospector introspector);\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: simple features\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking whether given feature is enabled or not\n+     */\n+    public abstract boolean isEnabled(ConfigFeature f);\n+    \n+    /**\n+     * Method for determining whether annotation processing is enabled or not\n+     * (default settings are typically that it is enabled; must explicitly disable).\n+     * \n+     * @return True if annotation processing is enabled; false if not\n+     * \n+     * @since 1.8\n+     */\n+    public abstract boolean isAnnotationProcessingEnabled();\n+\n+    /**\n+     * Accessor for determining whether it is ok to try to force override of access\n+     * modifiers to be able to get or set values of non-public Methods, Fields;\n+     * to invoke non-public Constructors, Methods; or to instantiate non-public\n+     * Classes. By default this is enabled, but on some platforms it needs to be\n+     * prevented since if this would violate security constraints and cause failures.\n+     * \n+     * @return True if access modifier overriding is allowed (and may be done for\n+     *   any Field, Method, Constructor or Class); false to prevent any attempts\n+     *   to override.\n+     * \n+     * @since 1.8\n+     */\n+    public abstract boolean canOverrideAccessModifiers();\n+\n+    /**\n+     * Accessor for checking whether default settings for property handling\n+     * indicate that properties should be alphabetically ordered or not.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract boolean shouldSortPropertiesAlphabetically();\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: introspectors, mix-ins\n+    /**********************************************************\n+     */\n+    \n+    public ClassIntrospector<? extends BeanDescription> getClassIntrospector() {\n+        return _base.getClassIntrospector();\n+    }\n+\n+    /**\n+     * Method for getting {@link AnnotationIntrospector} configured\n+     * to introspect annotation values used for configuration.\n+     *<p>\n+     * Non-final since it is actually overridden by sub-classes (for now?)\n+     */\n+    public AnnotationIntrospector getAnnotationIntrospector() {\n+        return _base.getAnnotationIntrospector();\n+    }\n+\n+    /**\n+     * Method for registering specified {@link AnnotationIntrospector} as the highest\n+     * priority introspector (will be chained with existing introspector(s) which\n+     * will be used as fallbacks for cases this introspector does not handle)\n+     * \n+     * @param introspector Annotation introspector to register.\n+     * \n+     * @since 1.7\n+     * \n+     * @deprecated Since 1.9 use {@link #withInsertedAnnotationIntrospector(AnnotationIntrospector)} instead;\n+     *   this method is deprecated as it changes state, preventing immutability of instances\n+     */\n+    @Deprecated\n+    public final void insertAnnotationIntrospector(AnnotationIntrospector introspector) {\n+        _base = _base.withAnnotationIntrospector(AnnotationIntrospector.Pair.create(introspector,\n+                getAnnotationIntrospector()));\n+    }\n+\n+    /**\n+     * Method for registering specified {@link AnnotationIntrospector} as the lowest\n+     * priority introspector, chained with existing introspector(s) and called\n+     * as fallback for cases not otherwise handled.\n+     * \n+     * @param introspector Annotation introspector to register.\n+     * \n+     * @since 1.7\n+     * \n+     * @deprecated Since 1.9 use {@link #withAppendedAnnotationIntrospector(AnnotationIntrospector)} instead;\n+     *   this method is deprecated as it changes state, preventing immutability of instances\n+     */\n+    @Deprecated\n+    public final void appendAnnotationIntrospector(AnnotationIntrospector introspector) {\n+        _base = _base.withAnnotationIntrospector(AnnotationIntrospector.Pair.create(getAnnotationIntrospector(),\n+                introspector));\n+    }\n+\n+    /**\n+     * Accessor for object used for determining whether specific property elements\n+     * (method, constructors, fields) can be auto-detected based on\n+     * their visibility (access modifiers). Can be changed to allow\n+     * different minimum visibility levels for auto-detection. Note\n+     * that this is the global handler; individual types (classes)\n+     * can further override active checker used (using\n+     * {@link JsonAutoDetect} annotation)\n+     * \n+     * @since 1.5\n+     */\n+    public VisibilityChecker<?> getDefaultVisibilityChecker() {\n+        return _base.getVisibilityChecker();\n+    }\n+    \n+    /**\n+     * @since 1.8\n+     */\n+    public final PropertyNamingStrategy getPropertyNamingStrategy() {\n+        return _base.getPropertyNamingStrategy();\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    public final HandlerInstantiator getHandlerInstantiator() {\n+        return _base.getHandlerInstantiator();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: mix-in annotations\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method to use for defining mix-in annotations to use for augmenting\n+     * annotations that processable (serializable / deserializable)\n+     * classes have.\n+     * Mixing in is done when introspecting class annotations and properties.\n+     * Map passed contains keys that are target classes (ones to augment\n+     * with new annotation overrides), and values that are source classes\n+     * (have annotations to use for augmentation).\n+     * Annotations from source classes (and their supertypes)\n+     * will <b>override</b>\n+     * annotations that target classes (and their super-types) have.\n+     *\n+     * @since 1.2\n+     */\n+    public final void setMixInAnnotations(Map<Class<?>, Class<?>> sourceMixins)\n+    {\n+        HashMap<ClassKey,Class<?>> mixins = null;\n+        if (sourceMixins != null && sourceMixins.size() > 0) {\n+            mixins = new HashMap<ClassKey,Class<?>>(sourceMixins.size());\n+            for (Map.Entry<Class<?>,Class<?>> en : sourceMixins.entrySet()) {\n+                mixins.put(new ClassKey(en.getKey()), en.getValue());\n+            }\n+        }\n+        _mixInAnnotationsShared = false;\n+        _mixInAnnotations = mixins;\n+    }\n+\n+    /**\n+     * Method to use for adding mix-in annotations to use for augmenting\n+     * specified class or interface. All annotations from\n+     * <code>mixinSource</code> are taken to override annotations\n+     * that <code>target</code> (or its supertypes) has.\n+     *\n+     * @since 1.2\n+     *\n+     * @param target Class (or interface) whose annotations to effectively override\n+     * @param mixinSource Class (or interface) whose annotations are to\n+     *   be \"added\" to target's annotations, overriding as necessary\n+     */\n+    public final void addMixInAnnotations(Class<?> target, Class<?> mixinSource)\n+    {\n+        if (_mixInAnnotations == null) {\n+            _mixInAnnotationsShared = false;\n+            _mixInAnnotations = new HashMap<ClassKey,Class<?>>();\n+        } else if (_mixInAnnotationsShared) {\n+            _mixInAnnotationsShared = false;\n+            _mixInAnnotations = new HashMap<ClassKey,Class<?>>(_mixInAnnotations);\n+        }\n+        _mixInAnnotations.put(new ClassKey(target), mixinSource);\n+    }\n+\n+    // ClassIntrospector.MixInResolver impl:\n+\n+    /**\n+     * Method that will check if there are \"mix-in\" classes (with mix-in\n+     * annotations) for given class\n+     * \n+     * @since 1.2\n+     */\n+    @Override\n+    public final Class<?> findMixInClassFor(Class<?> cls) {\n+        return (_mixInAnnotations == null) ? null : _mixInAnnotations.get(new ClassKey(cls));\n+    }\n+\n+    /**\n+     * @since 1.8.1\n+     */\n+    public final int mixInCount() {\n+        return (_mixInAnnotations == null) ? 0 : _mixInAnnotations.size();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: type and subtype handling\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to locate a type info handler for types that do not have\n+     * one explicitly declared via annotations (or other configuration).\n+     * If such default handler is configured, it is returned; otherwise\n+     * null is returned.\n+     * \n+     * @since 1.5\n+     */\n+    public final TypeResolverBuilder<?> getDefaultTyper(JavaType baseType) {\n+        return _base.getTypeResolverBuilder();\n+    }\n+    \n+    /**\n+     * Accessor for object used for finding out all reachable subtypes\n+     * for supertypes; needed when a logical type name is used instead\n+     * of class name (or custom scheme).\n+     * \n+     * @since 1.6\n+     */\n+    public final SubtypeResolver getSubtypeResolver() {\n+        if (_subtypeResolver == null) {\n+            _subtypeResolver = new StdSubtypeResolver();\n+        }\n+        return _subtypeResolver;\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    public final TypeFactory getTypeFactory() {\n+        return _base.getTypeFactory();\n+    }\n+\n+    /**\n+     * Helper method that will construct {@link JavaType} for given\n+     * raw class.\n+     * This is a simple short-cut for:\n+     *<pre>\n+     *    getTypeFactory().constructType(cls);\n+     *</pre>\n+     * \n+     * @since 1.8\n+     */\n+    public final JavaType constructType(Class<?> cls) {\n+        return getTypeFactory().constructType(cls, (TypeBindings) null);\n+    }\n+\n+    /**\n+     * Helper method that will construct {@link JavaType} for given\n+     * type reference\n+     * This is a simple short-cut for:\n+     *<pre>\n+     *    getTypeFactory().constructType(valueTypeRef);\n+     *</pre>\n+     * \n+     * @since 1.9\n+     */\n+    public final JavaType constructType(TypeReference<?> valueTypeRef) {\n+        return getTypeFactory().constructType(valueTypeRef.getType(), (TypeBindings) null);\n+    }\n+\n+    /**\n+     * @since 1.9.1\n+     */\n+    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n+        return getTypeFactory().constructSpecializedType(baseType, subclass);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: other\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for accessing currently configured (textual) date format\n+     * that will be used for reading or writing date values (in case\n+     * of writing, only if textual output is configured; not if dates\n+     * are to be serialized as time stamps).\n+     *<p>\n+     * Note that typically {@link DateFormat} instances are <b>not thread-safe</b>\n+     * (at least ones provided by JDK):\n+     * this means that calling code should clone format instance before\n+     * using it.\n+     *<p>\n+     * This method is usually only called by framework itself, since there\n+     * are convenience methods available via\n+     * {@link DeserializationContext} and {@link SerializerProvider} that\n+     * take care of cloning and thread-safe reuse.\n+     */\n+    public final DateFormat getDateFormat() { return _base.getDateFormat(); }\n+\n+    /**\n+     * Accessor for getting bean description that only contains class\n+     * annotations: useful if no getter/setter/creator information is needed.\n+     * \n+     * @since 1.7\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <DESC extends BeanDescription> DESC introspectClassAnnotations(Class<?> cls) {\n+        return (DESC) introspectClassAnnotations(constructType(cls));\n+    }\n+    \n+    /**\n+     * Accessor for getting bean description that only contains class\n+     * annotations: useful if no getter/setter/creator information is needed.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract <DESC extends BeanDescription> DESC introspectClassAnnotations(JavaType type);\n+\n+    /**\n+     * Accessor for getting bean description that only contains immediate class\n+     * annotations: ones from the class, and its direct mix-in, if any, but\n+     * not from super types.\n+     * \n+     * @since 1.7\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <DESC extends BeanDescription> DESC introspectDirectClassAnnotations(Class<?> cls) {\n+        return (DESC) introspectDirectClassAnnotations(constructType(cls));\n+    }\n+    /**\n+     * Accessor for getting bean description that only contains immediate class\n+     * annotations: ones from the class, and its direct mix-in, if any, but\n+     * not from super types.\n+     */\n+    public abstract <DESC extends BeanDescription> DESC introspectDirectClassAnnotations(JavaType type);\n+        \n+    /*\n+    /**********************************************************\n+    /* Methods for instantiating handlers\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be called to obtain an instance of <code>TypeIdResolver</code> of\n+     * specified type.\n+     * \n+     * @since 1.8\n+     */\n+    public TypeResolverBuilder<?> typeResolverBuilderInstance(Annotated annotated,\n+            Class<? extends TypeResolverBuilder<?>> builderClass)\n+    {\n+        HandlerInstantiator hi = getHandlerInstantiator();\n+        if (hi != null) {\n+            TypeResolverBuilder<?> builder = hi.typeResolverBuilderInstance(this, annotated, builderClass);\n+            if (builder != null) {\n+                return builder;\n+            }\n+        }\n+        return (TypeResolverBuilder<?>) ClassUtil.createInstance(builderClass, canOverrideAccessModifiers());\n+    }\n+\n+    /**\n+     * Method that can be called to obtain an instance of <code>TypeIdResolver</code> of\n+     * specified type.\n+     * \n+     * @since 1.8\n+     */\n+    public TypeIdResolver typeIdResolverInstance(Annotated annotated,\n+            Class<? extends TypeIdResolver> resolverClass)\n+    {\n+        HandlerInstantiator hi = getHandlerInstantiator();\n+        if (hi != null) {\n+            TypeIdResolver builder = hi.typeIdResolverInstance(this, annotated, resolverClass);\n+            if (builder != null) {\n+                return builder;\n+            }\n+        }\n+        return (TypeIdResolver) ClassUtil.createInstance(resolverClass, canOverrideAccessModifiers());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Deprecated methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for replacing existing annotation introspector(s) with specified\n+     * introspector.\n+     * Since this method modifies state of configuration object directly, its use\n+     * is not recommended.\n+     * \n+     * @deprecated Since 1.8, use either\n+     *  {@link #withAnnotationIntrospector(AnnotationIntrospector)} or\n+     *  Module API instead\n+     */\n+    @Deprecated\n+    public final void setAnnotationIntrospector(AnnotationIntrospector ai) {\n+        _base = _base.withAnnotationIntrospector(ai);\n+    }\n+    \n+    /**\n+     * Method that will define specific date format to use for reading/writing\n+     * Date and Calendar values.\n+     * If null is passed, will use {@link StdDateFormat}.\n+     * Instance is used as is, without creating a clone.\n+     * Format object in use can be accessed using {@link #getDateFormat}.\n+     * \n+     * @param df Date format to use, if not null; if null, the default format\n+     *   will be used\n+     * \n+     * @deprecated As of version 1.8, it is preferable to call method in\n+     *   {@link ObjectMapper} instead; or construct new instance with\n+     *   {@link #withDateFormat(DateFormat)}\n+     */\n+    @Deprecated\n+    public void setDateFormat(DateFormat df) {\n+        if (df == null) {\n+            df = DEFAULT_DATE_FORMAT;\n+        }\n+        _base = _base.withDateFormat(df);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper interface used with simple on/off features\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Interface that actual Feature enumerations used by\n+     * {@link MapperConfig} implementations must implement.\n+     * Necessary since enums can not be extended using normal\n+     * inheritance, but can implement interfaces\n+     * \n+     * @since 1.9\n+     */\n+    public interface ConfigFeature\n+    {\n+        /**\n+         * Accessor for checking whether this feature is enabled by default.\n+         */\n+        public boolean enabledByDefault();\n+\n+        /**\n+         * Returns bit mask for this feature instance\n+         */\n+        public int getMask();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper class to contain basic state needed to implement\n+    /* MapperConfig.\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Immutable container class used to store simple configuration\n+     * settings. Since instances are fully immutable, instances can\n+     * be freely shared and used without synchronization.\n+     */\n+    public static class Base\n+    {\n+        /*\n+        /**********************************************************\n+        /* Configuration settings; introspection, related\n+        /**********************************************************\n+         */\n+        \n+        /**\n+         * Introspector used to figure out Bean properties needed for bean serialization\n+         * and deserialization. Overridable so that it is possible to change low-level\n+         * details of introspection, like adding new annotation types.\n+         */\n+        protected final ClassIntrospector<? extends BeanDescription> _classIntrospector;\n+\n+        /**\n+         * Introspector used for accessing annotation value based configuration.\n+         */\n+        protected final AnnotationIntrospector _annotationIntrospector;\n+\n+        /**\n+         * Object used for determining whether specific property elements\n+         * (method, constructors, fields) can be auto-detected based on\n+         * their visibility (access modifiers). Can be changed to allow\n+         * different minimum visibility levels for auto-detection. Note\n+         * that this is the global handler; individual types (classes)\n+         * can further override active checker used (using\n+         * {@link JsonAutoDetect} annotation)\n+         * \n+         * @since 1.5\n+         */\n+        protected final VisibilityChecker<?> _visibilityChecker;\n+\n+        /**\n+         * Custom property naming strategy in use, if any.\n+         * \n+         * @since 1.8\n+         */\n+        protected final PropertyNamingStrategy _propertyNamingStrategy;\n+\n+        /**\n+         * Specific factory used for creating {@link JavaType} instances;\n+         * needed to allow modules to add more custom type handling\n+         * (mostly to support types of non-Java JVM languages)\n+         */\n+        protected final TypeFactory _typeFactory;\n+\n+        /*\n+        /**********************************************************\n+        /* Configuration settings; type resolution\n+        /**********************************************************\n+         */\n+\n+        /**\n+         * Type information handler used for \"untyped\" values (ones declared\n+         * to have type <code>Object.class</code>)\n+         * \n+         * @since 1.5\n+         */\n+        protected final TypeResolverBuilder<?> _typeResolverBuilder;\n+        \n+        /*\n+        /**********************************************************\n+        /* Configuration settings; other\n+        /**********************************************************\n+         */\n+        \n+        /**\n+         * Custom date format to use for de-serialization. If specified, will be\n+         * used instead of {@link com.fasterxml.jackson.databind.util.StdDateFormat}.\n+         *<p>\n+         * Note that the configured format object will be cloned once per\n+         * deserialization process (first time it is needed)\n+         */\n+        protected final DateFormat _dateFormat;\n+\n+        /**\n+         * Object used for creating instances of handlers (serializers, deserializers,\n+         * type and type id resolvers), given class to instantiate. This is typically\n+         * used to do additional configuration (with dependency injection, for example)\n+         * beyond simply construction of instances; or to use alternative constructors.\n+         */\n+        protected final HandlerInstantiator _handlerInstantiator;\n+        \n+        /*\n+        /**********************************************************\n+        /* Construction\n+        /**********************************************************\n+         */\n+\n+        public Base(ClassIntrospector<? extends BeanDescription> ci, AnnotationIntrospector ai,\n+                VisibilityChecker<?> vc, PropertyNamingStrategy pns, TypeFactory tf,\n+                TypeResolverBuilder<?> typer, DateFormat dateFormat, HandlerInstantiator hi)\n+        {\n+            _classIntrospector = ci;\n+            _annotationIntrospector = ai;\n+            _visibilityChecker = vc;\n+            _propertyNamingStrategy = pns;\n+            _typeFactory = tf;\n+            _typeResolverBuilder = typer;\n+            _dateFormat = dateFormat;\n+            _handlerInstantiator = hi;\n+        }\n+\n+        /*\n+        /**********************************************************\n+        /* Factory methods\n+        /**********************************************************\n+         */\n+\n+        public Base withClassIntrospector(ClassIntrospector<? extends BeanDescription> ci) {\n+            return new Base(ci, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                    _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+        }\n+        \n+        public Base withAnnotationIntrospector(AnnotationIntrospector ai) {\n+            return new Base(_classIntrospector, ai, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                    _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+        }\n+\n+        public Base withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n+            return withAnnotationIntrospector(AnnotationIntrospector.Pair.create(ai, _annotationIntrospector));\n+        }\n+\n+        public Base withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n+            return withAnnotationIntrospector(AnnotationIntrospector.Pair.create(_annotationIntrospector, ai));\n+        }\n+        \n+        public Base withVisibilityChecker(VisibilityChecker<?> vc) {\n+            return new Base(_classIntrospector, _annotationIntrospector, vc, _propertyNamingStrategy, _typeFactory,\n+                    _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+        }\n+\n+        public Base withVisibility(JsonMethod forMethod, JsonAutoDetect.Visibility visibility) {\n+            return new Base(_classIntrospector, _annotationIntrospector,\n+                    _visibilityChecker.withVisibility(forMethod, visibility),\n+                    _propertyNamingStrategy, _typeFactory,\n+                    _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+        }\n+        \n+        public Base withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n+            return new Base(_classIntrospector, _annotationIntrospector, _visibilityChecker, pns, _typeFactory,\n+                    _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+        }\n+\n+        public Base withTypeFactory(TypeFactory tf) {\n+            return new Base(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, tf,\n+                    _typeResolverBuilder, _dateFormat, _handlerInstantiator);\n+        }\n+\n+        public Base withTypeResolverBuilder(TypeResolverBuilder<?> typer) {\n+            return new Base(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                    typer, _dateFormat, _handlerInstantiator);\n+        }\n+        \n+        public Base withDateFormat(DateFormat df) {\n+            return new Base(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                    _typeResolverBuilder, df, _handlerInstantiator);\n+        }\n+\n+        public Base withHandlerInstantiator(HandlerInstantiator hi) {\n+            return new Base(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+                    _typeResolverBuilder, _dateFormat, hi);\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* API\n+        /**********************************************************\n+         */\n+\n+        public ClassIntrospector<? extends BeanDescription> getClassIntrospector() {\n+            return _classIntrospector;\n+        }\n+        \n+        public AnnotationIntrospector getAnnotationIntrospector() {\n+            return _annotationIntrospector;\n+        }\n+\n+\n+        public VisibilityChecker<?> getVisibilityChecker() {\n+            return _visibilityChecker;\n+        }\n+\n+        public PropertyNamingStrategy getPropertyNamingStrategy() {\n+            return _propertyNamingStrategy;\n+        }\n+\n+        public TypeFactory getTypeFactory() {\n+            return _typeFactory;\n+        }\n+\n+        public TypeResolverBuilder<?> getTypeResolverBuilder() {\n+            return _typeResolverBuilder;\n+        }\n+        \n+        public DateFormat getDateFormat() {\n+            return _dateFormat;\n+        }\n+\n+        public HandlerInstantiator getHandlerInstantiator() {\n+            return _handlerInstantiator;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Basic extension; added to avoid having to change generic\n+    /* signature of MapperConfig\n+    /* \n+    /* NOTE: May be merge in MapperConfig for 2.0, depending\n+    /* on how much we value backwards compatibility\n+    /**********************************************************\n+     */\n+\n+    static abstract class Impl<CFG extends MapperConfig.ConfigFeature,\n+        T extends Impl<CFG,T>>\n+        extends MapperConfig<T>\n+    {\n+        /**\n+         *<p>\n+         * Note: moved to base class in 1.9; was stored by sub-class earlier\n+         */\n+        protected int _featureFlags;\n+        \n+        /*\n+        /**********************************************************\n+        /* Construction\n+        /**********************************************************\n+         */\n+        \n+        protected Impl(ClassIntrospector<? extends BeanDescription> ci, AnnotationIntrospector ai,\n+                VisibilityChecker<?> vc, SubtypeResolver str, PropertyNamingStrategy pns, TypeFactory tf,\n+                HandlerInstantiator hi,\n+                int defaultFeatures)\n+        {\n+            super(ci, ai, vc, str, pns, tf, hi);\n+            _featureFlags = defaultFeatures;\n+        }\n+\n+        protected Impl(Impl<CFG,T> src) {\n+            super(src);\n+            _featureFlags = src._featureFlags;\n+        }\n+\n+        protected Impl(Impl<CFG,T> src, int features) {\n+            super(src);\n+            _featureFlags = features;\n+        }\n+        \n+        /**\n+         * @since 1.8\n+         */\n+        protected Impl(Impl<CFG,T> src, MapperConfig.Base base, SubtypeResolver str)\n+        {\n+            super(src, base, str);\n+            _featureFlags = src._featureFlags;\n+        }\n+        \n+        /**\n+         * Method that calculates bit set (flags) of all features that\n+         * are enabled by default.\n+         */\n+        static <F extends Enum<F> & MapperConfig.ConfigFeature> int collectFeatureDefaults(Class<F> enumClass)\n+        {\n+            int flags = 0;\n+            for (F value : enumClass.getEnumConstants()) {\n+                if (value.enabledByDefault()) {\n+                    flags |= value.getMask();\n+                }\n+            }\n+            return flags;\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* Additional fluent-factory methods\n+        /**********************************************************\n+         */\n+        \n+        /**\n+         * Fluent factory method that will construct and return a new configuration\n+         * object instance with specified features enabled.\n+         * \n+         * @since 1.9\n+         */\n+        public abstract T with(CFG... features);\n+\n+        /**\n+         * Fluent factory method that will construct and return a new configuration\n+         * object instance with specified features disabled.\n+         * \n+         * @since 1.9\n+         */\n+        public abstract T without(CFG... features);\n+        \n+        /*\n+        /**********************************************************\n+        /* Configuration: simple features\n+        /**********************************************************\n+         */\n+        \n+        /* NOTE: this method was added in 1.9, but should be\n+         * removed from 2.0 -- overloads do not work nicely with\n+         * enums, so we better not try \n+         *<p>\n+         * Also note that we can NOT use type variable CFG here, because\n+         * non-generic base class had to use base type.\n+         * \n+         * @Deprecated \n+         */\n+        @Override\n+        public boolean isEnabled(MapperConfig.ConfigFeature f) {\n+            return (_featureFlags & f.getMask()) != 0;\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* Configuration: deprecated methods\n+        /**********************************************************\n+         */\n+        \n+        /**\n+         * Method for enabling specified feature.\n+         * \n+         * @deprecated Since 1.9, it is preferable to use {@link #with} instead;\n+         *    this method is deprecated as it modifies current instance instead of\n+         *    creating a new one (as the goal is to make this class immutable)\n+         */\n+        @Deprecated\n+        public void enable(CFG f) {\n+            _featureFlags |= f.getMask();\n+        }\n+\n+        /**\n+         * Method for disabling specified feature.\n+         * \n+         * @deprecated Since 1.9, it is preferable to use {@link #without} instead;\n+         *    this method is deprecated as it modifies current instance instead of\n+         *    creating a new one (as the goal is to make this class immutable)\n+         */\n+        @Deprecated\n+        public void disable(CFG f) {\n+            _featureFlags &= ~f.getMask();\n+        }\n+\n+        /**\n+         * Method for enabling or disabling specified feature.\n+         * \n+         * @deprecated Since 1.9, it is preferable to use {@link #with} and\n+         * {@link #without} methods instead;\n+         *    this method is deprecated as it modifies current instance instead of\n+         *    creating a new one (as the goal is to make this class immutable)\n+         */\n+        @SuppressWarnings(\"deprecation\")\n+        @Deprecated\n+        public void set(CFG f, boolean state)\n+        {\n+            if (state) {\n+                enable(f);\n+            } else {\n+                disable(f);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingIterator.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Iterator exposed by {@link ObjectMapper} when binding sequence of\n+ * objects. Extension is done to allow more convenient exposing of\n+ * {@link IOException} (which basic {@link Iterator} does not expose)\n+ * \n+ * @since 1.8\n+ */\n+public class MappingIterator<T> implements Iterator<T>\n+{\n+    protected final static MappingIterator<?> EMPTY_ITERATOR =\n+        new MappingIterator<Object>(null, null, null, null, false, null);\n+    \n+    protected final JavaType _type;\n+\n+    protected final DeserializationContext _context;\n+    \n+    protected final JsonDeserializer<T> _deserializer;\n+\n+    protected JsonParser _parser;\n+    \n+    /**\n+     * Flag that indicates whether input {@link JsonParser} should be closed\n+     * when we are done or not; generally only called when caller did not\n+     * pass JsonParser.\n+     */\n+    protected final boolean _closeParser;\n+\n+    /**\n+     * Flag that is set when we have determined what {@link #hasNextValue()}\n+     * should value; reset when {@link #nextValue} is called\n+     */\n+    protected boolean _hasNextChecked;\n+    \n+    /**\n+     * If not null, \"value to update\" instead of creating a new instance\n+     * for each call.\n+     */\n+    protected final T _updatedValue;\n+\n+    protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt,\n+            JsonDeserializer<?> deser)\n+    {\n+        this(type, jp, ctxt, deser, true, null);\n+    }\n+    \n+    /**\n+     * @since 1.9.3\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected MappingIterator(JavaType type, JsonParser jp, DeserializationContext ctxt, JsonDeserializer<?> deser,\n+            boolean closeParser, Object valueToUpdate)\n+    {\n+        _type = type;\n+        _parser = jp;\n+        _context = ctxt;\n+        _deserializer = (JsonDeserializer<T>) deser;\n+\n+        /* One more thing: if we are at START_ARRAY (but NOT root-level\n+         * one!), advance to next token (to allow matching END_ARRAY)\n+         */\n+        if (jp != null && jp.getCurrentToken() == JsonToken.START_ARRAY) {\n+            JsonStreamContext sc = jp.getParsingContext();\n+            // safest way to skip current token is to clear it (so we'll advance soon)\n+            if (!sc.inRoot()) {\n+                jp.clearCurrentToken();\n+            }\n+        }\n+        _closeParser = closeParser;\n+        if (valueToUpdate == null) {\n+            _updatedValue = null;\n+        } else {\n+            _updatedValue = (T) valueToUpdate;\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected static <T> MappingIterator<T> emptyIterator() {\n+        return (MappingIterator<T>) EMPTY_ITERATOR;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Basic iterator impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean hasNext()\n+    {\n+        try {\n+            return hasNextValue();\n+        } catch (JsonMappingException e) {\n+            throw new RuntimeJsonMappingException(e.getMessage(), e);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    public T next()\n+    {\n+        try {\n+            return nextValue();\n+        } catch (JsonMappingException e) {\n+            throw new RuntimeJsonMappingException(e.getMessage(), e);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override public void remove() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Equivalent of {@link #next} but one that may throw checked\n+     * exceptions from Jackson due to invalid input.\n+     */\n+    public boolean hasNextValue() throws IOException\n+    {\n+        if (_parser == null) {\n+            return false;\n+        }\n+        if (!_hasNextChecked) {\n+            JsonToken t = _parser.getCurrentToken();\n+            _hasNextChecked = true;\n+            if (t == null) { // un-initialized or cleared; find next\n+                t = _parser.nextToken();\n+                // If EOF, no more\n+                if (t == null) {\n+                    JsonParser jp = _parser;\n+                    _parser = null;\n+                    if (_closeParser) {\n+                        jp.close();\n+                    }\n+                    return false;\n+                }\n+                /* And similarly if we hit END_ARRAY; except that we won't close parser\n+                 * (because it's not a root-level iterator)\n+                 */\n+                if (t == JsonToken.END_ARRAY) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    public T nextValue() throws IOException\n+    {\n+        // caller should always call 'hasNext[Value]' first; but let's ensure:\n+        if (!_hasNextChecked) {\n+            if (!hasNextValue()) {\n+                throw new NoSuchElementException();\n+            }\n+        }\n+        if (_parser == null) {\n+            throw new NoSuchElementException();\n+        }\n+        _hasNextChecked = false;\n+        T result;\n+        \n+        if (_updatedValue == null) {\n+            result = _deserializer.deserialize(_parser, _context);\n+        } else{\n+            _deserializer.deserialize(_parser, _context, _updatedValue);\n+            result = _updatedValue;\n+        }\n+        // Need to consume the token too\n+        _parser.clearCurrentToken();\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/MappingJsonFactory.java\n+/* Jackson JSON-processor.\n+ *\n+ * Copyright (c) 2007- Tatu Saloranta, tatu.saloranta@iki.fi\n+ *\n+ * Licensed under the License specified in file LICENSE, included with\n+ * the source code and binary code bundles.\n+ * You may not use this file except in compliance with the License.\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.format.InputAccessor;\n+import com.fasterxml.jackson.core.format.MatchStrength;\n+\n+/**\n+ * Sub-class of {@link JsonFactory} that will create a proper\n+ * {@link ObjectCodec} to allow seamless conversions between\n+ * Json content and Java objects (POJOs).\n+ * The only addition to regular {@link JsonFactory} currently\n+ * is that {@link ObjectMapper} is constructed and passed as\n+ * the codec to use.\n+ */\n+public class MappingJsonFactory\n+    extends JsonFactory\n+{\n+    public MappingJsonFactory()\n+    {\n+        this(null);\n+    }\n+\n+    public MappingJsonFactory(ObjectMapper mapper)\n+    {\n+        super(mapper);\n+        if (mapper == null) {\n+            setCodec(new ObjectMapper(this));\n+        }\n+    }\n+\n+    /**\n+     * We'll override the method to return more specific type; co-variance\n+     * helps here\n+     */\n+    @Override\n+    public final ObjectMapper getCodec() { return (ObjectMapper) _objectCodec; }\n+\n+    /*\n+    /**********************************************************\n+    /* Format detection functionality (since 1.8)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Sub-classes need to override this method (as of 1.8)\n+     */\n+    @Override\n+    public String getFormatName()\n+    {\n+        /* since non-JSON factories typically should not extend this class,\n+         * let's just always return JSON as name.\n+         */\n+        return FORMAT_NAME_JSON;\n+    }\n+\n+    /**\n+     * Sub-classes need to override this method (as of 1.8)\n+     */\n+    @Override\n+    public MatchStrength hasFormat(InputAccessor acc) throws IOException\n+    {\n+        return hasJSONFormat(acc);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/Module.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiators;\n+import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;\n+import com.fasterxml.jackson.databind.type.TypeModifier;\n+\n+/**\n+ * Simple interface for extensions that can be registered with {@link ObjectMapper}\n+ * to provide a well-defined set of extensions to default functionality; such as\n+ * support for new data types.\n+ */\n+public abstract class Module\n+    implements Versioned\n+{\n+    /*\n+    /**********************************************************\n+    /* Simple accessors\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that returns identifier for module; this can be used by Jackson\n+     * for informational purposes, as well as in associating extensions with\n+     * module that provides them.\n+     */\n+    public abstract String getModuleName();\n+\n+    /**\n+     * Method that returns version of this module. Can be used by Jackson for\n+     * informational purposes.\n+     */\n+    @Override\n+    public abstract Version version();\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: registration\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called by {@link ObjectMapper} when module is registered.\n+     * It is called to let module register functionality it provides,\n+     * using callback methods passed-in context object exposes.\n+     */\n+    public abstract void setupModule(SetupContext context);\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Interface Jackson exposes to modules for purpose of registering\n+     * extended functionality.\n+     */\n+    public interface SetupContext\n+    {\n+        /*\n+        /**********************************************************\n+        /* Simple accessors\n+        /**********************************************************\n+         */\n+        \n+        /**\n+         * Method that returns version information about {@link ObjectMapper} \n+         * that implements this context. Modules can use this to choose\n+         * different settings or initialization order; or even decide to fail\n+         * set up completely if version is compatible with module.\n+         */\n+        public Version getMapperVersion();\n+\n+        /**\n+         * Method that returns current deserialization configuration\n+         * settings. Since modules may be interested in these settings,\n+         * caller should make sure to make changes to settings before\n+         * module registrations.\n+         */\n+        public DeserializationConfig getDeserializationConfig();\n+\n+        /**\n+         * Method that returns current serialization configuration\n+         * settings. Since modules may be interested in these settings,\n+         * caller should make sure to make changes to settings before\n+         * module registrations.\n+         * \n+         * @since 1.7.1 (1.7.0 unfortunately had a typo in method name!)\n+         */\n+        public SerializationConfig getSerializationConfig();\n+\n+        /**\n+         * @since 1.9.0\n+         */\n+        public boolean isEnabled(DeserializationConfig.Feature f);\n+\n+        /**\n+         * @since 1.9.0\n+         */\n+        public boolean isEnabled(SerializationConfig.Feature f);\n+\n+        /**\n+         * @since 1.9.0\n+         */\n+        public boolean isEnabled(JsonParser.Feature f);\n+\n+        /**\n+         * @since 1.9.0\n+         */\n+        public boolean isEnabled(JsonGenerator.Feature f);\n+        \n+        /*\n+        /**********************************************************\n+        /* Handler registration; serializers/deserializers\n+        /**********************************************************\n+         */\n+        \n+        /**\n+         * Method that module can use to register additional deserializers to use for\n+         * handling types.\n+         * \n+         * @param d Object that can be called to find deserializer for types supported\n+         *   by module (null returned for non-supported types)\n+         */\n+        public void addDeserializers(Deserializers d);\n+\n+        /**\n+         * Method that module can use to register additional deserializers to use for\n+         * handling Map key values (which are separate from value deserializers because\n+         * they are always serialized from String values)\n+         *\n+         * @since 1.8\n+         */\n+        public void addKeyDeserializers(KeyDeserializers s);\n+        \n+        /**\n+         * Method that module can use to register additional serializers to use for\n+         * handling types.\n+         * \n+         * @param s Object that can be called to find serializer for types supported\n+         *   by module (null returned for non-supported types)\n+         */\n+        public void addSerializers(Serializers s);\n+\n+        /**\n+         * Method that module can use to register additional serializers to use for\n+         * handling Map key values (which are separate from value serializers because\n+         * they must write <code>JsonToken.FIELD_NAME</code> instead of String value).\n+         *\n+         * @since 1.8\n+         */\n+        public void addKeySerializers(Serializers s);\n+\n+        /*\n+        /**********************************************************\n+        /* Handler registration; other\n+        /**********************************************************\n+         */\n+        \n+        /**\n+         * Method that module can use to register additional modifier objects to\n+         * customize configuration and construction of bean deserializers.\n+         * \n+         * @param mod Modifier to register\n+         */\n+        public void addBeanDeserializerModifier(BeanDeserializerModifier mod);\n+\n+        /**\n+         * Method that module can use to register additional modifier objects to\n+         * customize configuration and construction of bean serializers.\n+         * \n+         * @param mod Modifier to register\n+         */\n+        public void addBeanSerializerModifier(BeanSerializerModifier mod);\n+\n+        /**\n+         * Method that module can use to register additional\n+         * {@link AbstractTypeResolver} instance, to handle resolution of\n+         * abstract to concrete types (either by defaulting, or by materializing).\n+         * \n+         * @param resolver Resolver to add.\n+         * \n+         * @since 1.8\n+         */\n+        public void addAbstractTypeResolver(AbstractTypeResolver resolver);\n+\n+        /**\n+         * Method that module can use to register additional\n+         * {@link TypeModifier} instance, which can augment {@link org.codehaus.jackson.type.JavaType}\n+         * instances constructed by {@link com.fasterxml.jackson.databind.type.TypeFactory}.\n+         * \n+         * @param modifier to add\n+         * \n+         * @since 1.8\n+         */\n+        public void addTypeModifier(TypeModifier modifier);\n+\n+        /**\n+         * Method that module can use to register additional {@link com.fasterxml.jackson.databind.deser.ValueInstantiator}s,\n+         * by adding {@link ValueInstantiators} object that gets called when \n+         * instantatiator is needed by a deserializer.\n+         * \n+         * @param instantiators Object that can provide {@link com.fasterxml.jackson.databind.deser.ValueInstantiator}s for\n+         *    constructing POJO values during deserialization\n+         * \n+         * @since 1.9\n+         */\n+        public void addValueInstantiators(ValueInstantiators instantiators);\n+        \n+        /**\n+         * Method for registering specified {@link AnnotationIntrospector} as the highest\n+         * priority introspector (will be chained with existing introspector(s) which\n+         * will be used as fallbacks for cases this introspector does not handle)\n+         * \n+         * @param ai Annotation introspector to register.\n+         */\n+        public void insertAnnotationIntrospector(AnnotationIntrospector ai);\n+\n+        /**\n+         * Method for registering specified {@link AnnotationIntrospector} as the lowest\n+         * priority introspector, chained with existing introspector(s) and called\n+         * as fallback for cases not otherwise handled.\n+         * \n+         * @param ai Annotation introspector to register.\n+         */\n+        public void appendAnnotationIntrospector(AnnotationIntrospector ai);\n+\n+        /**\n+         * Method used for defining mix-in annotations to use for augmenting\n+         * specified class or interface.\n+         * All annotations from\n+         * <code>mixinSource</code> are taken to override annotations\n+         * that <code>target</code> (or its supertypes) has.\n+         *<p>\n+         * Note: mix-ins are registered both for serialization and deserialization\n+         * (which can be different internally).\n+         *<p>\n+         * Note: currently only one set of mix-in annotations can be defined for\n+         * a single class; so if multiple modules register mix-ins, highest\n+         * priority one (last one registered) will have priority over other modules.\n+         *\n+         * @param target Class (or interface) whose annotations to effectively override\n+         * @param mixinSource Class (or interface) whose annotations are to\n+         *   be \"added\" to target's annotations, overriding as necessary\n+         */\n+        public void setMixInAnnotations(Class<?> target, Class<?> mixinSource);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+import java.lang.reflect.Type;\n+import java.net.URL;\n+import java.text.DateFormat;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.core.util.*;\n+import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n+import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.introspect.BasicClassIntrospector;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.jsontype.impl.StdSubtypeResolver;\n+import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.databind.type.SimpleType;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.type.TypeModifier;\n+\n+import org.codehaus.jackson.*;\n+import org.codehaus.jackson.node.*;\n+import org.codehaus.jackson.schema.JsonSchema;\n+\n+/**\n+ * This mapper (or, data binder, or codec) provides functionality for\n+ * converting between Java objects (instances of JDK provided core classes,\n+ * beans), and matching JSON constructs.\n+ * It will use instances of {@link JsonParser} and {@link JsonGenerator}\n+ * for implementing actual reading/writing of JSON.\n+ *<p>\n+ * The main conversion API is defined in {@link ObjectCodec}, so that\n+ * implementation details of this class need not be exposed to\n+ * streaming parser and generator classes.\n+ *<p>\n+ * Note on caching: root-level deserializers are always cached, and accessed\n+ * using full (generics-aware) type information. This is different from\n+ * caching of referenced types, which is more limited and is done only\n+ * for a subset of all deserializer types. The main reason for difference\n+ * is that at root-level there is no incoming reference (and hence no\n+ * referencing property, no referral information or annotations to\n+ * produce differing deserializers), and that the performance impact\n+ * greatest at root level (since it'll essentially cache the full\n+ * graph of deserializers involved).\n+ */\n+public class ObjectMapper\n+    extends ObjectCodec\n+    implements Versioned\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper classes, enums\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Enumeration used with {@link ObjectMapper#enableDefaultTyping()}\n+     * to specify what kind of types (classes) default typing should\n+     * be used for. It will only be used if no explicit type information\n+     * is found, but this enumeration further limits subset of those\n+     * types.\n+     * \n+     * @since 1.5\n+     */\n+    public enum DefaultTyping {\n+        /**\n+         * This value means that only properties that have\n+         * {@link java.lang.Object} as declared type (including\n+         * generic types without explicit type) will use default\n+         * typing.\n+         */\n+        JAVA_LANG_OBJECT,\n+        \n+        /**\n+         * Value that means that default typing will be used for\n+         * properties with declared type of {@link java.lang.Object}\n+         * or an abstract type (abstract class or interface).\n+         * Note that this does <b>not</b> include array types.\n+         */\n+        OBJECT_AND_NON_CONCRETE,\n+\n+        /**\n+         * Value that means that default typing will be used for\n+         * all types covered by {@link #OBJECT_AND_NON_CONCRETE}\n+         * plus all array types for them.\n+         */\n+        NON_CONCRETE_AND_ARRAYS,\n+        \n+        /**\n+         * Value that means that default typing will be used for\n+         * all non-final types, with exception of small number of\n+         * \"natural\" types (String, Boolean, Integer, Double), which\n+         * can be correctly inferred from JSON; as well as for\n+         * all arrays of non-final types.\n+         */\n+        NON_FINAL\n+    }\n+\n+    /**\n+     * Customized {@link TypeResolverBuilder} that provides type resolver builders\n+     * used with so-called \"default typing\"\n+     * (see {@link ObjectMapper#enableDefaultTyping()} for details).\n+     *<p>\n+     * Type resolver construction is based on configuration: implementation takes care\n+     * of only providing builders in cases where type information should be applied.\n+     * This is important since build calls may be sent for any and all types, and\n+     * type information should NOT be applied to all of them.\n+     */\n+    public static class DefaultTypeResolverBuilder\n+        extends StdTypeResolverBuilder\n+    {\n+        /**\n+         * Definition of what types is this default typer valid for.\n+         */\n+        protected final DefaultTyping _appliesFor;\n+\n+        public DefaultTypeResolverBuilder(DefaultTyping t) {\n+            _appliesFor = t;\n+        }\n+\n+        @Override\n+        public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n+                JavaType baseType, Collection<NamedType> subtypes, BeanProperty property)\n+        {\n+            return useForType(baseType) ? super.buildTypeDeserializer(config, baseType, subtypes, property) : null;\n+        }\n+\n+        @Override\n+        public TypeSerializer buildTypeSerializer(SerializationConfig config,\n+                JavaType baseType, Collection<NamedType> subtypes, BeanProperty property)\n+        {\n+            return useForType(baseType) ? super.buildTypeSerializer(config, baseType, subtypes, property) : null;            \n+        }\n+\n+        /**\n+         * Method called to check if the default type handler should be\n+         * used for given type.\n+         * Note: \"natural types\" (String, Boolean, Integer, Double) will never\n+         * use typing; that is both due to them being concrete and final,\n+         * and since actual serializers and deserializers will also ignore any\n+         * attempts to enforce typing.\n+         */\n+        public boolean useForType(JavaType t)\n+        {\n+            switch (_appliesFor) {\n+            case NON_CONCRETE_AND_ARRAYS:\n+                if (t.isArrayType()) {\n+                    t = t.getContentType();\n+                }\n+                // fall through\n+            case OBJECT_AND_NON_CONCRETE:\n+                return (t.getRawClass() == Object.class) || !t.isConcrete();\n+            case NON_FINAL:\n+                if (t.isArrayType()) {\n+                    t = t.getContentType();\n+                }\n+                return !t.isFinal(); // includes Object.class\n+            default:\n+            //case JAVA_LANG_OBJECT:\n+                return (t.getRawClass() == Object.class);\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal constants, singletons\n+    /**********************************************************\n+     */\n+    \n+    // Quick little shortcut, to avoid having to use global TypeFactory instance...\n+    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n+\n+    /* !!! 03-Apr-2009, tatu: Should try to avoid direct reference... but not\n+     *   sure what'd be simple and elegant way. So until then:\n+     */\n+    protected final static ClassIntrospector<? extends BeanDescription> DEFAULT_INTROSPECTOR = BasicClassIntrospector.instance;\n+\n+    // 16-May-2009, tatu: Ditto ^^^\n+    protected final static AnnotationIntrospector DEFAULT_ANNOTATION_INTROSPECTOR = new JacksonAnnotationIntrospector();\n+\n+    /**\n+     * @since 1.5\n+     */\n+    protected final static VisibilityChecker<?> STD_VISIBILITY_CHECKER = VisibilityChecker.Std.defaultInstance();\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration settings, shared\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory used to create {@link JsonParser} and {@link JsonGenerator}\n+     * instances as necessary.\n+     */\n+    protected final JsonFactory _jsonFactory;\n+\n+    /**\n+     * Registered concrete subtypes that can be used instead of (or\n+     * in addition to) ones declared using annotations.\n+     * \n+     * @since 1.6\n+     */\n+    protected SubtypeResolver _subtypeResolver;\n+\n+    /**\n+     * Specific factory used for creating {@link JavaType} instances;\n+     * needed to allow modules to add more custom type handling\n+     * (mostly to support types of non-Java JVM languages)\n+     */\n+    protected TypeFactory _typeFactory;\n+\n+    /**\n+     * Provider for values to inject in deserialized POJOs.\n+     * \n+     * @since 1.9\n+     */\n+    protected InjectableValues _injectableValues;\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration settings, serialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Configuration object that defines basic global\n+     * settings for the serialization process\n+     */\n+    protected SerializationConfig _serializationConfig;\n+\n+    /**\n+     * Object that manages access to serializers used for serialization,\n+     * including caching.\n+     * It is configured with {@link #_serializerFactory} to allow\n+     * for constructing custom serializers.\n+     */\n+    protected SerializerProvider _serializerProvider;\n+\n+    /**\n+     * Serializer factory used for constructing serializers.\n+     */\n+    protected SerializerFactory _serializerFactory;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration settings, deserialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Configuration object that defines basic global\n+     * settings for the serialization process\n+     */\n+    protected DeserializationConfig _deserializationConfig;\n+\n+    /**\n+     * Object that manages access to deserializers used for deserializing\n+     * JSON content into Java objects, including possible caching\n+     * of the deserializers. It contains a reference to\n+     * {@link DeserializerFactory} to use for constructing acutal deserializers.\n+     */\n+    protected DeserializerProvider _deserializerProvider;\n+\n+    /*\n+    /**********************************************************\n+    /* Caching\n+    /**********************************************************\n+     */\n+\n+    /* Note: handling of serializers and deserializers is not symmetric;\n+     * and as a result, only root-level deserializers can be cached here.\n+     * This is mostly because typing and resolution for deserializers is\n+     * fully static; whereas it is quite dynamic for serialization.\n+     */\n+\n+    /**\n+     * We will use a separate main-level Map for keeping track\n+     * of root-level deserializers. This is where most succesful\n+     * cache lookups get resolved.\n+     * Map will contain resolvers for all kinds of types, including\n+     * container types: this is different from the component cache\n+     * which will only cache bean deserializers.\n+     *<p>\n+     * Given that we don't expect much concurrency for additions\n+     * (should very quickly converge to zero after startup), let's\n+     * explicitly define a low concurrency setting.\n+     *<p>\n+     * Since version 1.5, these may are either \"raw\" deserializers (when\n+     * no type information is needed for base type), or type-wrapped\n+     * deserializers (if it is needed)\n+     */\n+    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers\n+        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.6f, 2);\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructing instance\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Default constructor, which will construct the default\n+     * {@link JsonFactory} as necessary, use\n+     * {@link StdSerializerProvider} as its\n+     * {@link SerializerProvider}, and\n+     * {@link BeanSerializerFactory} as its\n+     * {@link SerializerFactory}.\n+     * This means that it\n+     * can serialize all standard JDK types, as well as regular\n+     * Java Beans (based on method names and Jackson-specific annotations),\n+     * but does not support JAXB annotations.\n+     */\n+    public ObjectMapper()\n+    {\n+        this(null, null, null);\n+    }\n+\n+    /**\n+     * Construct mapper that uses specified {@link JsonFactory}\n+     * for constructing necessary {@link JsonParser}s and/or\n+     * {@link JsonGenerator}s.\n+     */\n+    public ObjectMapper(JsonFactory jf)\n+    {\n+        this(jf, null, null);\n+    }\n+\n+    /**\n+     * Construct mapper that uses specified {@link SerializerFactory}\n+     * for constructing necessary serializers.\n+     *\n+     * @deprecated Use other constructors instead; note that\n+     *   you can just set serializer factory with {@link #setSerializerFactory}\n+     */\n+    @Deprecated\n+    public ObjectMapper(SerializerFactory sf)\n+    {\n+        this(null, null, null);\n+        setSerializerFactory(sf);\n+    }\n+\n+    public ObjectMapper(JsonFactory jf,\n+                        SerializerProvider sp, DeserializerProvider dp)\n+    {\n+    \tthis(jf, sp, dp, null, null);\n+    }\n+\n+    /**\n+     * \n+     * @param jf JsonFactory to use: if null, a new {@link MappingJsonFactory} will be constructed\n+     * @param sp SerializerProvider to use: if null, a {@link StdSerializerProvider} will be constructed\n+     * @param dp DeserializerProvider to use: if null, a {@link StdDeserializerProvider} will be constructed\n+     * @param sconfig Serialization configuration to use; if null, basic {@link SerializationConfig}\n+     * \twill be constructed\n+     * @param dconfig Deserialization configuration to use; if null, basic {@link DeserializationConfig}\n+     * \twill be constructed\n+     */\n+    public ObjectMapper(JsonFactory jf,\n+            SerializerProvider sp, DeserializerProvider dp,\n+            SerializationConfig sconfig, DeserializationConfig dconfig)\n+    {\n+        /* 02-Mar-2009, tatu: Important: we MUST default to using\n+         *   the mapping factory, otherwise tree serialization will\n+         *   have problems with POJONodes.\n+         * 03-Jan-2010, tatu: and obviously we also must pass 'this',\n+         *    to create actual linking.\n+         */\n+        if (jf == null) {\n+            _jsonFactory = new MappingJsonFactory(this);\n+        } else {\n+            _jsonFactory = jf;\n+            if (jf.getCodec() == null) { // as per [JACKSON-741]\n+                _jsonFactory.setCodec(this);\n+            }\n+        }\n+        // and default type factory is shared one\n+        _typeFactory = TypeFactory.defaultInstance();\n+        _serializationConfig = (sconfig != null) ? sconfig :\n+            new SerializationConfig(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER,\n+                    null, null, _typeFactory, null);\n+        _deserializationConfig = (dconfig != null) ? dconfig :\n+            new DeserializationConfig(DEFAULT_INTROSPECTOR, DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER,\n+                    null, null, _typeFactory, null);\n+        _serializerProvider = (sp == null) ? new StdSerializerProvider() : sp;\n+        _deserializerProvider = (dp == null) ? new StdDeserializerProvider() : dp;\n+\n+        // Default serializer factory is stateless, can just assign\n+        _serializerFactory = BeanSerializerFactory.instance;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Versioned impl\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that will return version information stored in and read from jar\n+     * that contains this class.\n+     * \n+     * @since 1.6\n+     */\n+    @Override\n+    public Version version() {\n+        return VersionUtil.versionFor(getClass());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Module registration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for registering a module that can extend functionality\n+     * provided by this mapper; for example, by adding providers for\n+     * custom serializers and deserializers.\n+     * \n+     * @param module Module to register\n+     * \n+     * @since 1.7\n+     */\n+    public void registerModule(Module module)\n+    {\n+        /* Let's ensure we have access to name and version information, \n+         * even if we do not have immediate use for either. This way we know\n+         * that they will be available from beginning\n+         */\n+        String name = module.getModuleName();\n+        if (name == null) {\n+            throw new IllegalArgumentException(\"Module without defined name\");\n+        }\n+        Version version = module.version();\n+        if (version == null) {\n+            throw new IllegalArgumentException(\"Module without defined version\");\n+        }\n+\n+        final ObjectMapper mapper = this;\n+        \n+        // And then call registration\n+        module.setupModule(new Module.SetupContext()\n+        {\n+            // // // Accessors\n+\n+            @Override\n+            public Version getMapperVersion() {\n+                return version();\n+            }\n+\n+            @Override\n+            public DeserializationConfig getDeserializationConfig() {\n+                return mapper.getDeserializationConfig();\n+            }\n+\n+            @Override\n+            public SerializationConfig getSerializationConfig() {\n+                return mapper.getSerializationConfig();\n+            }\n+\n+            @Override\n+            public boolean isEnabled(DeserializationConfig.Feature f) {\n+                return mapper.isEnabled(f);\n+            }\n+\n+            @Override\n+            public boolean isEnabled(SerializationConfig.Feature f) {\n+                return mapper.isEnabled(f);\n+            }\n+\n+            @Override\n+            public boolean isEnabled(JsonParser.Feature f) {\n+                return mapper.isEnabled(f);\n+            }\n+\n+            @Override\n+            public boolean isEnabled(JsonGenerator.Feature f) {\n+                return mapper.isEnabled(f);\n+            }\n+            \n+            // // // Methods for registering handlers: deserializers, serializers\n+            \n+            @Override\n+            public void addDeserializers(Deserializers d) {\n+                mapper._deserializerProvider = mapper._deserializerProvider.withAdditionalDeserializers(d);\n+            }\n+\n+            @Override\n+            public void addKeyDeserializers(KeyDeserializers d) {\n+                mapper._deserializerProvider = mapper._deserializerProvider.withAdditionalKeyDeserializers(d);\n+            }\n+            \n+            @Override\n+            public void addSerializers(Serializers s) {\n+                mapper._serializerFactory = mapper._serializerFactory.withAdditionalSerializers(s);\n+            }\n+\n+            @Override\n+            public void addKeySerializers(Serializers s) {\n+                mapper._serializerFactory = mapper._serializerFactory.withAdditionalKeySerializers(s);\n+            }\n+            \n+            @Override\n+            public void addBeanSerializerModifier(BeanSerializerModifier modifier) {\n+                mapper._serializerFactory = mapper._serializerFactory.withSerializerModifier(modifier);\n+            }\n+\n+            @Override\n+            public void addBeanDeserializerModifier(BeanDeserializerModifier modifier) {\n+                mapper._deserializerProvider = mapper._deserializerProvider.withDeserializerModifier(modifier);\n+            }\n+\n+            // // // Methods for registering handlers: other\n+            \n+            @Override\n+            public void addAbstractTypeResolver(AbstractTypeResolver resolver) {\n+                mapper._deserializerProvider = mapper._deserializerProvider.withAbstractTypeResolver(resolver);\n+            }\n+\n+            @Override\n+            public void addTypeModifier(TypeModifier modifier) {\n+                TypeFactory f = mapper._typeFactory;\n+                f = f.withModifier(modifier);\n+                mapper.setTypeFactory(f);\n+            }\n+\n+            @Override\n+            public void addValueInstantiators(ValueInstantiators instantiators) {\n+                mapper._deserializerProvider = mapper._deserializerProvider.withValueInstantiators(instantiators);\n+            }\n+            \n+            @Override\n+            public void insertAnnotationIntrospector(AnnotationIntrospector ai) {\n+                mapper._deserializationConfig = mapper._deserializationConfig.withInsertedAnnotationIntrospector(ai);\n+                mapper._serializationConfig = mapper._serializationConfig.withInsertedAnnotationIntrospector(ai);\n+            }\n+            \n+            @Override\n+            public void appendAnnotationIntrospector(AnnotationIntrospector ai) {\n+                mapper._deserializationConfig = mapper._deserializationConfig.withAppendedAnnotationIntrospector(ai);\n+                mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n+            }\n+\n+            @Override\n+            public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n+                mapper._deserializationConfig.addMixInAnnotations(target, mixinSource);\n+                mapper._serializationConfig.addMixInAnnotations(target, mixinSource);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Fluent-style alternative to {@link #registerModule}; functionally equivalent to:\n+     *<pre>\n+     *  mapper.registerModule(module);\n+     *  return mapper;\n+     *</pre>\n+     * NOTE: name is unfortunately misleading in suggesting that a new instance\n+     * might be created (as is the case with most other 'withXxx()' methods\n+     * for Jackson core objects) -- this is not the case; rather, this is just\n+     * a variant of {@link #registerModule} but one that returns 'this'\n+     * (like it should return, but does not for historical reasons).\n+     * \n+     * @since 1.8\n+     */\n+    public ObjectMapper withModule(Module module)\n+    {\n+        registerModule(module);\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration: main config object access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that returns the shared default {@link SerializationConfig}\n+     * object that defines configuration settings for serialization.\n+     * Returned object is \"live\" meaning that changes will be used\n+     * for future serialization operations for this mapper when using\n+     * mapper's default configuration\n+     */\n+    public SerializationConfig getSerializationConfig() {\n+        return _serializationConfig;\n+    }\n+\n+    /**\n+     * Method that creates a copy of\n+     * the shared default {@link SerializationConfig} object\n+     * that defines configuration settings for serialization.\n+     * Since it is a copy, any changes made to the configuration\n+     * object will NOT directly affect serialization done using\n+     * basic serialization methods that use the shared object (that is,\n+     * ones that do not take separate {@link SerializationConfig}\n+     * argument.\n+     *<p>\n+     * The use case is that of changing object settings of the configuration\n+     * (like date format being used, see {@link SerializationConfig#setDateFormat}).\n+     */\n+    public SerializationConfig copySerializationConfig() {\n+        return _serializationConfig.createUnshared(_subtypeResolver);\n+    }\n+\n+    /**\n+     * Method for replacing the shared default serialization configuration\n+     * object.\n+     */\n+    public ObjectMapper setSerializationConfig(SerializationConfig cfg) {\n+        _serializationConfig = cfg;\n+        return this;\n+    }\n+\n+    /**\n+     * Method that returns\n+     * the shared default {@link DeserializationConfig} object\n+     * that defines configuration settings for deserialization.\n+     * Returned object is \"live\" meaning that changes will be used\n+     * for future deserialization operations for this mapper when using\n+     * mapper's default configuration\n+     */\n+    public DeserializationConfig getDeserializationConfig() {\n+        return _deserializationConfig;\n+    }\n+\n+    /**\n+     * Method that creates a copy of\n+     * the shared default {@link DeserializationConfig} object\n+     * that defines configuration settings for deserialization.\n+     * Since it is a copy, any changes made to the configuration\n+     * object will NOT directly affect deserialization done using\n+     * basic deserialization methods that use the shared object (that is,\n+     * ones that do not take separate {@link DeserializationConfig}\n+     * argument.\n+     *<p>\n+     * The use case is that of changing object settings of the configuration\n+     * (like deserialization problem handler,\n+     * see {@link DeserializationConfig#addHandler})\n+     */\n+    public DeserializationConfig copyDeserializationConfig() {\n+        return _deserializationConfig.createUnshared(_subtypeResolver)\n+                .passSerializationFeatures(_serializationConfig._featureFlags);\n+    }\n+\n+    /**\n+     * Method for replacing the shared default deserialization configuration\n+     * object.\n+     */\n+    public ObjectMapper setDeserializationConfig(DeserializationConfig cfg) {\n+        _deserializationConfig = cfg;\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration: ser/deser factory, provider access\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for setting specific {@link SerializerFactory} to use\n+     * for constructing (bean) serializers.\n+     */\n+    public ObjectMapper setSerializerFactory(SerializerFactory f) {\n+        _serializerFactory = f;\n+        return this;\n+    }\n+\n+    /**\n+     * Method for setting specific {@link SerializerProvider} to use\n+     * for handling caching of {@link JsonSerializer} instances.\n+     */\n+    public ObjectMapper setSerializerProvider(SerializerProvider p) {\n+        _serializerProvider = p;\n+        return this;\n+    }\n+\n+    /**\n+     * @since 1.4\n+     */   \n+    public SerializerProvider getSerializerProvider() {\n+        return _serializerProvider;\n+    }\n+    \n+    /**\n+     * Method for setting specific {@link DeserializerProvider} to use\n+     * for handling caching of {@link JsonDeserializer} instances.\n+     */\n+    public ObjectMapper setDeserializerProvider(DeserializerProvider p) {\n+        _deserializerProvider = p;\n+        return this;\n+    }\n+\n+    /**\n+     * @since 1.4\n+     */   \n+    public DeserializerProvider getDeserializerProvider() {\n+        return _deserializerProvider;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, introspection\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for accessing currently configured visibility checker;\n+     * object used for determining whether given property element\n+     * (method, field, constructor) can be auto-detected or not.\n+     * \n+     * @since 1.5\n+     */\n+    public VisibilityChecker<?> getVisibilityChecker() {\n+        return _serializationConfig.getDefaultVisibilityChecker();\n+    }\n+\n+    /**\n+     * Method for setting currently configured visibility checker;\n+     * object used for determining whether given property element\n+     * (method, field, constructor) can be auto-detected or not.\n+     * This default checker is used if no per-class overrides\n+     * are defined.\n+     * \n+     * @since 1.5\n+     */    \n+    public void setVisibilityChecker(VisibilityChecker<?> vc) {\n+        _deserializationConfig = _deserializationConfig.withVisibilityChecker(vc);\n+        _serializationConfig = _serializationConfig.withVisibilityChecker(vc);\n+    }\n+\n+    /**\n+     * Convenience method that allows changing configuration for\n+     * underlying {@link VisibilityChecker}s, to change details of what kinds of\n+     * properties are auto-detected.\n+     * Basically short cut for doing:\n+     *<pre>\n+     *  mapper.setVisibilityChecker(\n+     *     mapper.getVisibilityChecker().withVisibility(forMethod, visibility)\n+     *  );\n+     *</pre>\n+     * one common use case would be to do:\n+     *<pre>\n+     *  mapper.setVisibility(JsonMethod.FIELD, Visibility.ANY);\n+     *</pre>\n+     * which would make all member fields serializable without further annotations,\n+     * instead of just public fields (default setting).\n+     * \n+     * @param forMethod Type of property descriptor affected (field, getter/isGetter,\n+     *     setter, creator)\n+     * @param visibility Minimum visibility to require for the property descriptors of type\n+     * \n+     * @return Modified mapper instance (that is, \"this\"), to allow chaining\n+     *    of configuration calls\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectMapper setVisibility(JsonMethod forMethod, JsonAutoDetect.Visibility visibility)\n+    {\n+        _deserializationConfig = _deserializationConfig.withVisibility(forMethod, visibility);\n+        _serializationConfig = _serializationConfig.withVisibility(forMethod, visibility);\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for accessing subtype resolver in use.\n+     * \n+     * @since 1.6\n+     */\n+    public SubtypeResolver getSubtypeResolver() {\n+        if (_subtypeResolver == null) {\n+            _subtypeResolver = new StdSubtypeResolver();\n+        }\n+        return _subtypeResolver;\n+    }\n+\n+    /**\n+     * Method for setting custom subtype resolver to use.\n+     * \n+     * @since 1.6\n+     */\n+    public void setSubtypeResolver(SubtypeResolver r) {\n+        _subtypeResolver = r;\n+    }\n+\n+    /**\n+     * Method for changing {@link AnnotationIntrospector} used by this\n+     * mapper instance for both serialization and deserialization\n+     * \n+     * @since 1.8\n+     */\n+    public ObjectMapper setAnnotationIntrospector(AnnotationIntrospector ai) {\n+        _serializationConfig = _serializationConfig.withAnnotationIntrospector(ai);\n+        _deserializationConfig = _deserializationConfig.withAnnotationIntrospector(ai);\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for setting custom property naming strategy to use.\n+     * \n+     * @since 1.8\n+     */\n+    public ObjectMapper setPropertyNamingStrategy(PropertyNamingStrategy s) {\n+        _serializationConfig = _serializationConfig.withPropertyNamingStrategy(s);\n+        _deserializationConfig = _deserializationConfig.withPropertyNamingStrategy(s);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for setting defalt POJO property inclusion strategy for serialization.\n+     * Equivalent to:\n+     *<pre>\n+     *  mapper.setSerializationConfig(mapper.getSerializationConfig().withSerializationInclusion(incl));\n+     *</pre>\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectMapper setSerializationInclusion(JsonSerialize.Inclusion incl) {\n+        _serializationConfig = _serializationConfig.withSerializationInclusion(incl);\n+        return this;\n+    }\n+   \n+    /*\n+    /**********************************************************\n+    /* Type information configuration (1.5+)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Convenience method that is equivalent to calling\n+     *<pre>\n+     *  enableObjectTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n+     *</pre>\n+     */\n+    public ObjectMapper enableDefaultTyping() {\n+        return enableDefaultTyping(DefaultTyping.OBJECT_AND_NON_CONCRETE);\n+    }\n+\n+    /**\n+     * Convenience method that is equivalent to calling\n+     *<pre>\n+     *  enableObjectTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n+     *</pre>\n+     */\n+    public ObjectMapper enableDefaultTyping(DefaultTyping dti) {\n+        return enableDefaultTyping(dti, JsonTypeInfo.As.WRAPPER_ARRAY);\n+    }\n+\n+    /**\n+     * Method for enabling automatic inclusion of type information, needed\n+     * for proper deserialization of polymorphic types (unless types\n+     * have been annotated with {@link org.codehaus.jackson.annotate.JsonTypeInfo}).\n+     * \n+     * @param applicability Defines kinds of types for which additional type information\n+     *    is added; see {@link DefaultTyping} for more information.\n+     */\n+    public ObjectMapper enableDefaultTyping(DefaultTyping applicability, JsonTypeInfo.As includeAs)\n+    {\n+        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n+        // we'll always use full class name, when using defaulting\n+        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n+        typer = typer.inclusion(includeAs);\n+        return setDefaultTyping(typer);\n+    }\n+\n+    /**\n+     * Method for enabling automatic inclusion of type information -- needed\n+     * for proper deserialization of polymorphic types (unless types\n+     * have been annotated with {@link org.codehaus.jackson.annotate.JsonTypeInfo}) --\n+     * using \"As.PROPERTY\" inclusion mechanism and specified property name\n+     * to use for inclusion (default being \"@class\" since default type information\n+     * always uses class name as type identifier)\n+     * \n+     * @since 1.7\n+     */\n+    public ObjectMapper enableDefaultTypingAsProperty(DefaultTyping applicability, String propertyName)\n+    {\n+        TypeResolverBuilder<?> typer = new DefaultTypeResolverBuilder(applicability);\n+        // we'll always use full class name, when using defaulting\n+        typer = typer.init(JsonTypeInfo.Id.CLASS, null);\n+        typer = typer.inclusion(JsonTypeInfo.As.PROPERTY);\n+        typer = typer.typeProperty(propertyName);\n+        return setDefaultTyping(typer);\n+    }\n+    \n+    /**\n+     * Method for disabling automatic inclusion of type information; if so, only\n+     * explicitly annotated types (ones with\n+     * {@link org.codehaus.jackson.annotate.JsonTypeInfo}) will have\n+     * additional embedded type information.\n+     */\n+    public ObjectMapper disableDefaultTyping() {\n+        return setDefaultTyping(null);\n+    }\n+\n+    /**\n+     * Method for enabling automatic inclusion of type information, using\n+     * specified handler object for determining which types this affects,\n+     * as well as details of how information is embedded.\n+     * \n+     * @param typer Type information inclusion handler\n+     * \n+     * \n+     */\n+    public ObjectMapper setDefaultTyping(TypeResolverBuilder<?> typer) {\n+        _deserializationConfig = _deserializationConfig.withTypeResolverBuilder(typer);\n+        _serializationConfig = _serializationConfig.withTypeResolverBuilder(typer);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for registering specified class as a subtype, so that\n+     * typename-based resolution can link supertypes to subtypes\n+     * (as an alternative to using annotations).\n+     * Type for given class is determined from appropriate annotation;\n+     * or if missing, default name (unqualified class name)\n+     * \n+     * @since 1.6\n+     */\n+    public void registerSubtypes(Class<?>... classes) {\n+        getSubtypeResolver().registerSubtypes(classes);\n+    }\n+\n+    /**\n+     * Method for registering specified class as a subtype, so that\n+     * typename-based resolution can link supertypes to subtypes\n+     * (as an alternative to using annotations).\n+     * Name may be provided as part of argument, but if not will\n+     * be based on annotations or use default name (unqualified\n+     * class name).\n+     * \n+     * @since 1.6\n+     */\n+    public void registerSubtypes(NamedType... types) {\n+        getSubtypeResolver().registerSubtypes(types);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, basic type handling\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Accessor for getting currently configured {@link TypeFactory} instance.\n+     * \n+     * @since 1.8\n+     */\n+    public TypeFactory getTypeFactory() {\n+        return _typeFactory;\n+    }\n+\n+    /**\n+     * Method that can be used to override {@link TypeFactory} instance\n+     * used by this mapper.\n+     *<p>\n+     * Note: will also set {@link TypeFactory} that deserialization and\n+     * serialization config objects use.\n+     */\n+    public ObjectMapper setTypeFactory(TypeFactory f)\n+    {\n+        _typeFactory = f;\n+        _deserializationConfig = _deserializationConfig.withTypeFactory(f);\n+        _serializationConfig = _serializationConfig.withTypeFactory(f);\n+        return this;\n+    }\n+    \n+    /**\n+     * Convenience method for constructing {@link JavaType} out of given\n+     * type (typically <code>java.lang.Class</code>), but without explicit\n+     * context.\n+     * \n+     * @since 1.8\n+     */\n+    public JavaType constructType(Type t) {\n+        return _typeFactory.constructType(t);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, deserialization\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for specifying {@link JsonNodeFactory} to use for\n+     * constructing root level tree nodes (via method\n+     * {@link #createObjectNode}\n+     *\n+     * @since 1.2\n+     */\n+    public ObjectMapper setNodeFactory(JsonNodeFactory f) {\n+        _deserializationConfig = _deserializationConfig.withNodeFactory(f);\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, serialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Convenience method that is equivalent to:\n+     *<pre>\n+     *  mapper.setFilters(mapper.getSerializationConfig().withFilters(filterProvider));\n+     *</pre>\n+     *<p>\n+     * Note that usually it is better to use method {@link #filteredWriter}; however, sometimes\n+     * this method is more convenient. For example, some frameworks only allow configuring\n+     * of ObjectMapper instances and not ObjectWriters.\n+     * \n+     * @since 1.8\n+     */\n+    public void setFilters(FilterProvider filterProvider) {\n+        _serializationConfig = _serializationConfig.withFilters(filterProvider);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to get hold of {@link JsonFactory} that this\n+     * mapper uses if it needs to construct {@link JsonParser}s\n+     * and/or {@link JsonGenerator}s.\n+     *\n+     * @return {@link JsonFactory} that this mapper uses when it needs to\n+     *   construct Json parser and generators\n+     */\n+    public JsonFactory getJsonFactory() { return _jsonFactory; }\n+    \n+    /**\n+     * Method for configuring the default {@link DateFormat} to use when serializing time\n+     * values as Strings, and deserializing from JSON Strings.\n+     * This is preferably to directly modifying {@link SerializationConfig} and\n+     * {@link DeserializationConfig} instances.\n+     * If you need per-request configuration, use {@link #writer(DateFormat)} to\n+     * create properly configured {@link ObjectWriter} and use that; this because\n+     * {@link ObjectWriter}s are thread-safe whereas ObjectMapper itself is only\n+     * thread-safe when configuring methods (such as this one) are NOT called.\n+     * \n+     * @since 1.8\n+     */\n+    public void setDateFormat(DateFormat dateFormat)\n+    {\n+        _deserializationConfig = _deserializationConfig.withDateFormat(dateFormat);\n+        _serializationConfig = _serializationConfig.withDateFormat(dateFormat);\n+    }\n+\n+    /**\n+     * Method for configuring {@link HandlerInstantiator} to use for creating\n+     * instances of handlers (such as serializers, deserializers, type and type\n+     * id resolvers), given a class.\n+     *\n+     * @param hi Instantiator to use; if null, use the default implementation\n+     */\n+    public void setHandlerInstantiator(HandlerInstantiator hi)\n+    {\n+        _deserializationConfig = _deserializationConfig.withHandlerInstantiator(hi);\n+        _serializationConfig = _serializationConfig.withHandlerInstantiator(hi);\n+    }\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    public ObjectMapper setInjectableValues(InjectableValues injectableValues) {\n+        _injectableValues = injectableValues;\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, simple features\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for changing state of an on/off serialization feature for\n+     * this object mapper.\n+     *<p>\n+     * This is method is basically a shortcut method for calling\n+     * {@link SerializationConfig#set} on the shared {@link SerializationConfig}\n+     * object with given arguments.\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    public ObjectMapper configure(SerializationConfig.Feature f, boolean state) {\n+        _serializationConfig.set(f, state);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for changing state of an on/off deserialization feature for\n+     * this object mapper.\n+     *<p>\n+     * This is method is basically a shortcut method for calling\n+     * {@link DeserializationConfig#set} on the shared {@link DeserializationConfig}\n+     * object with given arguments.\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    public ObjectMapper configure(DeserializationConfig.Feature f, boolean state) {\n+        _deserializationConfig.set(f, state);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for changing state of an on/off {@link JsonParser} feature for\n+     * {@link JsonFactory} instance this object mapper uses.\n+     *<p>\n+     * This is method is basically a shortcut method for calling\n+     * {@link JsonFactory#setParserFeature} on the shared\n+     * {@link JsonFactory} this mapper uses (which is accessible\n+     * using {@link #getJsonFactory}).\n+     *\n+     * @since 1.2\n+     */\n+    public ObjectMapper configure(JsonParser.Feature f, boolean state) {\n+        _jsonFactory.configure(f, state);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for changing state of an on/off {@link JsonGenerator} feature for\n+     * {@link JsonFactory} instance this object mapper uses.\n+     *<p>\n+     * This is method is basically a shortcut method for calling\n+     * {@link JsonFactory#setGeneratorFeature} on the shared\n+     * {@link JsonFactory} this mapper uses (which is accessible\n+     * using {@link #getJsonFactory}).\n+     *\n+     * @since 1.2\n+     */\n+    public ObjectMapper configure(JsonGenerator.Feature f, boolean state) {\n+        _jsonFactory.configure(f, state);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectMapper enable(DeserializationConfig.Feature... f) {\n+        _deserializationConfig = _deserializationConfig.with(f);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectMapper disable(DeserializationConfig.Feature... f) {\n+        _deserializationConfig = _deserializationConfig.without(f);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectMapper enable(SerializationConfig.Feature... f) {\n+        _serializationConfig = _serializationConfig.with(f);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for enabling specified {@link DeserializationConfig} features.\n+     * Modifies and returns this instance; no new object is created.\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectMapper disable(SerializationConfig.Feature... f) {\n+        _serializationConfig = _serializationConfig.without(f);\n+        return this;\n+    }\n+    \n+    /**\n+     * Convenience method, equivalent to:\n+     *<pre>\n+     *  getSerializationConfig().isEnabled(f);\n+     *</pre>\n+     * \n+     * @since 1.9\n+     */\n+    public boolean isEnabled(SerializationConfig.Feature f) {\n+        return _serializationConfig.isEnabled(f);\n+    }\n+\n+    /**\n+     * Convenience method, equivalent to:\n+     *<pre>\n+     *  getDeserializationConfig().isEnabled(f);\n+     *</pre>\n+     * \n+     * @since 1.9\n+     */\n+    public boolean isEnabled(DeserializationConfig.Feature f) {\n+        return _deserializationConfig.isEnabled(f);\n+    }\n+\n+    /**\n+     * Convenience method, equivalent to:\n+     *<pre>\n+     *  getJsonFactory().isEnabled(f);\n+     *</pre>\n+     * \n+     * @since 1.9\n+     */\n+    public boolean isEnabled(JsonParser.Feature f) {\n+        return _jsonFactory.isEnabled(f);\n+    }\n+\n+    /**\n+     * Convenience method, equivalent to:\n+     *<pre>\n+     *  getJsonFactory().isEnabled(f);\n+     *</pre>\n+     * \n+     * @since 1.9\n+     */\n+    public boolean isEnabled(JsonGenerator.Feature f) {\n+        return _jsonFactory.isEnabled(f);\n+    }\n+    \n+    /**\n+     * Method that can be used to get hold of {@link JsonNodeFactory}\n+     * that this mapper will use when directly constructing\n+     * root {@link JsonNode} instances for Trees.\n+     *<p>\n+     * Note: this is just a shortcut for calling\n+     *<pre>\n+     *   getDeserializationConfig().getNodeFactory()\n+     *</pre>\n+     *\n+     * @since 1.2\n+     */\n+    public JsonNodeFactory getNodeFactory() {\n+        return _deserializationConfig.getNodeFactory();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API (from ObjectCodec): deserialization\n+    /* (mapping from JSON to Java types);\n+    /* main methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method to deserialize JSON content into a non-container\n+     * type (it can be an array type, however): typically a bean, array\n+     * or a wrapper type (like {@link java.lang.Boolean}).\n+     *<p>\n+     * Note: this method should NOT be used if the result type is a\n+     * container ({@link java.util.Collection} or {@link java.util.Map}.\n+     * The reason is that due to type erasure, key and value types\n+     * can not be introspected when using this method.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(JsonParser jp, Class<T> valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+// !!! TODO\n+//    \t_setupClassLoaderForDeserialization(valueType);\n+        return (T) _readValue(copyDeserializationConfig(), jp, _typeFactory.constructType(valueType));\n+    } \n+\n+    /**\n+     * Method to deserialize JSON content into a Java type, reference\n+     * to which is passed as argument. Type is passed using so-called\n+     * \"super type token\" (see )\n+     * and specifically needs to be used if the root type is a \n+     * parameterized (generic) container type.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readValue(copyDeserializationConfig(), jp, _typeFactory.constructType(valueTypeRef));\n+    }\n+\n+    /**\n+     * Method to deserialize JSON content into a Java type, reference\n+     * to which is passed as argument. Type is passed using \n+     * Jackson specific type; instance of which can be constructed using\n+     * {@link TypeFactory}.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(JsonParser jp, JavaType valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readValue(copyDeserializationConfig(), jp, valueType);\n+    } \n+\n+    /**\n+     * Method to deserialize JSON content as tree expressed\n+     * using set of {@link JsonNode} instances. Returns\n+     * root of the resulting tree (where root can consist\n+     * of just a single node if the current event is a\n+     * value event, not container).\n+     */\n+    @Override\n+    public JsonNode readTree(JsonParser jp)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* 02-Mar-2009, tatu: One twist; deserialization provider\n+         *   will map JSON null straight into Java null. But what\n+         *   we want to return is the \"null node\" instead.\n+         */\n+        /* 05-Aug-2011, tatu: Also, must check for EOF here before\n+         *   calling readValue(), since that'll choke on it otherwise\n+         */\n+        DeserializationConfig cfg = copyDeserializationConfig();\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == null) {\n+            t = jp.nextToken();\n+            if (t == null) {\n+                return null;\n+            }\n+        }\n+        JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n+        return (n == null) ? getNodeFactory().nullNode() : n;\n+    }\n+\n+    /**\n+     * Method for reading sequence of Objects from parser stream.\n+     *<p>\n+     * Note that {@link ObjectReader} has more complete set of variants.\n+     * \n+     * @since 1.8\n+     */\n+    @Override\n+    public <T> MappingIterator<T> readValues(JsonParser jp, JavaType valueType)\n+        throws IOException, JsonProcessingException\n+    {\n+        DeserializationConfig config = copyDeserializationConfig();\n+        DeserializationContext ctxt = _createDeserializationContext(jp, config);\n+        JsonDeserializer<?> deser = _findRootDeserializer(config, valueType);\n+        // false -> do NOT close JsonParser (since caller passed it)\n+        return new MappingIterator<T>(valueType, jp, ctxt, deser,\n+                false, null);\n+    }\n+\n+    /**\n+     * Method for reading sequence of Objects from parser stream.\n+     * \n+     * @since 1.8\n+     */\n+    @Override\n+    public <T> MappingIterator<T> readValues(JsonParser jp, Class<T> valueType)\n+        throws IOException, JsonProcessingException\n+    {\n+        return readValues(jp, _typeFactory.constructType(valueType));\n+    }\n+\n+    /**\n+     * Method for reading sequence of Objects from parser stream.\n+     * \n+     * @since 1.8\n+     */\n+    @Override\n+    public <T> MappingIterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n+        throws IOException, JsonProcessingException\n+    {\n+        return readValues(jp, _typeFactory.constructType(valueTypeRef));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API not included in ObjectCodec: deserialization\n+    /* (mapping from JSON to Java types)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method to deserialize JSON content into a non-container\n+     * type (it can be an array type, however): typically a bean, array\n+     * or a wrapper type (like {@link java.lang.Boolean}).\n+     *<p>\n+     * Note: this method should NOT be used if the result type is a\n+     * container ({@link java.util.Collection} or {@link java.util.Map}.\n+     * The reason is that due to type erasure, key and value types\n+     * can not be introspected when using this method.\n+     * @since 1.1\n+     *\n+     * @param cfg Specific deserialization configuration to use for\n+     *   this operation. Note that not all config settings can\n+     *   be changed on per-operation basis: some changeds only take effect\n+     *   before calling the operation for the first time (for the mapper\n+     *   instance)\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(JsonParser jp, Class<T> valueType, \n+                           DeserializationConfig cfg)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+     // !!! TODO\n+//    \t_setupClassLoaderForDeserialization(valueType);\n+        return (T) _readValue(cfg, jp, _typeFactory.constructType(valueType));\n+    } \n+\n+    /**\n+     * Method to deserialize JSON content into a Java type, reference\n+     * to which is passed as argument. Type is passed using so-called\n+     * \"super type token\" (see )\n+     * and specifically needs to be used if the root type is a \n+     * parameterized (generic) container type.\n+     *\n+     * @param cfg Specific deserialization configuration to use for\n+     *   this operation. Note that not all config settings can\n+     *   be changed on per-operation basis: some changeds only take effect\n+     *   before calling the operation for the first time (for the mapper\n+     *   instance)\n+     *\n+     * @since 1.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef,\n+                           DeserializationConfig cfg)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readValue(cfg, jp, _typeFactory.constructType(valueTypeRef));\n+    } \n+\n+    /**\n+     * Method to deserialize JSON content into a Java type, reference\n+     * to which is passed as argument. Type is passed using \n+     * Jackson specific type; instance of which can be constructed using\n+     * {@link TypeFactory}.\n+     *\n+     * @param cfg Specific deserialization configuration to use for\n+     *   this operation. Note that not all config settings can\n+     *   be changed on per-operation basis: some changeds only take effect\n+     *   before calling the operation for the first time (for the mapper\n+     *   instance)\n+     *\n+     * @since 1.1\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(JsonParser jp, JavaType valueType,\n+                           DeserializationConfig cfg)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readValue(cfg, jp, valueType);\n+    } \n+\n+    /**\n+     * Method to deserialize JSON content as tree expressed\n+     * using set of {@link JsonNode} instances. Returns\n+     * root of the resulting tree (where root can consist\n+     * of just a single node if the current event is a\n+     * value event, not container).\n+     *\n+     * @param cfg Specific deserialization configuration to use for\n+     *   this operation. Note that not all config settings can\n+     *   be changed on per-operation basis: some changeds only take effect\n+     *   before calling the operation for the first time (for the mapper\n+     *   instance)\n+     *\n+     * @since 1.1\n+     */\n+    public JsonNode readTree(JsonParser jp, DeserializationConfig cfg)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonNode n = (JsonNode) _readValue(cfg, jp, JSON_NODE_TYPE);\n+        return (n == null) ? NullNode.instance : n;\n+    }\n+\n+    /**\n+     * Method to deserialize JSON content as tree expressed\n+     * using set of {@link JsonNode} instances.\n+     * Returns root of the resulting tree (where root can consist\n+     * of just a single node if the current event is a\n+     * value event, not container).\n+     *\n+     * @param in Input stream used to read JSON content\n+     *   for building the JSON tree.\n+     *\n+     * @since 1.3\n+     */\n+    public JsonNode readTree(InputStream in)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createJsonParser(in), JSON_NODE_TYPE);\n+        return (n == null) ? NullNode.instance : n;\n+    }\n+\n+    /**\n+     * Method to deserialize JSON content as tree expressed\n+     * using set of {@link JsonNode} instances.\n+     * Returns root of the resulting tree (where root can consist\n+     * of just a single node if the current event is a\n+     * value event, not container).\n+     *\n+     * @param r Reader used to read JSON content\n+     *   for building the JSON tree.\n+     *\n+     * @since 1.3\n+     */\n+    public JsonNode readTree(Reader r)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createJsonParser(r), JSON_NODE_TYPE);\n+        return (n == null) ? NullNode.instance : n;\n+    }\n+\n+    /**\n+     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n+     * Returns root of the resulting tree (where root can consist of just a single node if the current\n+     * event is a value event, not container).\n+     *\n+     * @param content JSON content to parse to build the JSON tree.\n+     *\n+     * @since 1.3\n+     */\n+    public JsonNode readTree(String content)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createJsonParser(content), JSON_NODE_TYPE);\n+        return (n == null) ? NullNode.instance : n;\n+    }\n+\n+    /**\n+     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n+     * Returns root of the resulting tree (where root can consist of just a single node if the current\n+     * event is a value event, not container).\n+     *\n+     * @param content JSON content to parse to build the JSON tree.\n+     *\n+     * @since 1.9\n+     */\n+    public JsonNode readTree(byte[] content)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createJsonParser(content), JSON_NODE_TYPE);\n+        return (n == null) ? NullNode.instance : n;\n+    }\n+    \n+    /**\n+     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n+     * Returns root of the resulting tree (where root can consist of just a single node if the current\n+     * event is a value event, not container).\n+     *\n+     * @param file File of which contents to parse as JSON for building a tree instance\n+     *\n+     * @since 1.9\n+     */\n+    public JsonNode readTree(File file)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createJsonParser(file), JSON_NODE_TYPE);\n+        return (n == null) ? NullNode.instance : n;\n+    }\n+\n+    /**\n+     * Method to deserialize JSON content as tree expressed using set of {@link JsonNode} instances.\n+     * Returns root of the resulting tree (where root can consist of just a single node if the current\n+     * event is a value event, not container).\n+     *\n+     * @param source URL to use for fetching contents to parse as JSON for building a tree instance\n+     *\n+     * @since 1.9\n+     */\n+    public JsonNode readTree(URL source)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonNode n = (JsonNode) _readMapAndClose(_jsonFactory.createJsonParser(source), JSON_NODE_TYPE);\n+        return (n == null) ? NullNode.instance : n;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API (from ObjectCodec): serialization\n+    /* (mapping from Java types to Json)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to serialize any Java value as\n+     * JSON output, using provided {@link JsonGenerator}.\n+     */\n+    @Override\n+    public void writeValue(JsonGenerator jgen, Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        SerializationConfig config = copySerializationConfig();\n+        if (config.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+            _writeCloseableValue(jgen, value, config);\n+        } else {\n+            _serializerProvider.serializeValue(config, jgen, value, _serializerFactory);\n+            if (config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+                jgen.flush();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that can be used to serialize any Java value as\n+     * JSON output, using provided {@link JsonGenerator},\n+     * configured as per passed configuration object.\n+     *\n+     * @since 1.1\n+     */\n+    public void writeValue(JsonGenerator jgen, Object value, SerializationConfig config)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        // [JACKSON-282] Consider java.util.Closeable\n+        if (config.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+            _writeCloseableValue(jgen, value, config);\n+        } else {\n+            _serializerProvider.serializeValue(config, jgen, value, _serializerFactory);\n+            if (config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+                jgen.flush();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method to serialize given JSON Tree, using generator\n+     * provided.\n+     */\n+    @Override\n+    public void writeTree(JsonGenerator jgen, JsonNode rootNode)\n+        throws IOException, JsonProcessingException\n+    {\n+        SerializationConfig config = copySerializationConfig();\n+        _serializerProvider.serializeValue(config, jgen, rootNode, _serializerFactory);\n+        if (config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+            jgen.flush();\n+        }\n+    }\n+\n+    /**\n+     * Method to serialize given Json Tree, using generator\n+     * provided.\n+     *\n+     * @since 1.1\n+     */\n+    public void writeTree(JsonGenerator jgen, JsonNode rootNode,\n+                          SerializationConfig cfg)\n+        throws IOException, JsonProcessingException\n+    {\n+        _serializerProvider.serializeValue(cfg, jgen, rootNode, _serializerFactory);\n+        if (cfg.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+            jgen.flush();\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API (from ObjectCodec): Tree Model support\n+    /**********************************************************\n+     */\n+\n+    /**\n+     *<p>\n+     * Note: return type is co-variant, as basic ObjectCodec\n+     * abstraction can not refer to concrete node types (as it's\n+     * part of core package, whereas impls are part of mapper\n+     * package)\n+     *\n+     * @since 1.2\n+     */\n+    @Override    \n+    public ObjectNode createObjectNode() {\n+        return _deserializationConfig.getNodeFactory().objectNode();\n+    }\n+\n+    /**\n+     *<p>\n+     * Note: return type is co-variant, as basic ObjectCodec\n+     * abstraction can not refer to concrete node types (as it's\n+     * part of core package, whereas impls are part of mapper\n+     * package)\n+     *\n+     * @since 1.2\n+     */\n+    @Override\n+    public ArrayNode createArrayNode() {\n+        return _deserializationConfig.getNodeFactory().arrayNode();\n+    }\n+\n+    /**\n+     * Method for constructing a {@link JsonParser} out of JSON tree\n+     * representation.\n+     * \n+     * @param n Root node of the tree that resulting parser will read from\n+     * \n+     * @since 1.3\n+     */\n+    @Override\n+    public JsonParser treeAsTokens(JsonNode n)\n+    {\n+        return new TreeTraversingParser(n, this);\n+    }\n+\n+    /**\n+     * Convenience conversion method that will bind data given JSON tree\n+     * contains into specific value (usually bean) type.\n+     *<p>\n+     * Equivalent to:\n+     *<pre>\n+     *   objectMapper.convertValue(n, valueClass);\n+     *</pre>\n+     */\n+    @Override\n+    public <T> T treeToValue(JsonNode n, Class<T> valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return readValue(treeAsTokens(n), valueType);\n+    }\n+\n+    /**\n+     * Reverse of {@link #treeToValue}; given a value (usually bean), will\n+     * construct equivalent JSON Tree representation. Functionally same\n+     * as if serializing value into JSON and parsing JSON as tree, but\n+     * more efficient.\n+     * \n+     * @param <T> Actual node type; usually either basic {@link JsonNode} or\n+     *  {@link org.codehaus.jackson.node.ObjectNode}\n+     * @param fromValue Bean value to convert\n+     * @return Root node of the resulting JSON tree\n+     * \n+     * @since 1.6\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends JsonNode> T valueToTree(Object fromValue)\n+        throws IllegalArgumentException\n+    {\n+        if (fromValue == null) return null;\n+        TokenBuffer buf = new TokenBuffer(this);\n+        JsonNode result;\n+        try {\n+            writeValue(buf, fromValue);\n+            JsonParser jp = buf.asParser();\n+            result = readTree(jp);\n+            jp.close();\n+        } catch (IOException e) { // should not occur, no real i/o...\n+            throw new IllegalArgumentException(e.getMessage(), e);\n+        }\n+        return (T) result;\n+    } \n+    \n+    /*\n+    /**********************************************************\n+    /* Extended Public API, accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be called to check whether mapper thinks\n+     * it could serialize an instance of given Class.\n+     * Check is done\n+     * by checking whether a serializer can be found for the type.\n+     *\n+     * @return True if mapper can find a serializer for instances of\n+     *  given class (potentially serializable), false otherwise (not\n+     *  serializable)\n+     */\n+    public boolean canSerialize(Class<?> type)\n+    {\n+        return _serializerProvider.hasSerializerFor(copySerializationConfig(),\n+                type, _serializerFactory);\n+    }\n+\n+    /**\n+     * Method that can be called to check whether mapper thinks\n+     * it could deserialize an Object of given type.\n+     * Check is done\n+     * by checking whether a deserializer can be found for the type.\n+     *\n+     * @return True if mapper can find a serializer for instances of\n+     *  given class (potentially serializable), false otherwise (not\n+     *  serializable)\n+     */\n+    public boolean canDeserialize(JavaType type)\n+    {\n+        return _deserializerProvider.hasValueDeserializerFor(copyDeserializationConfig(), type);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended Public API, deserialization,\n+    /* convenience methods\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(File src, Class<T> valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+     // !!! TODO\n+//    \t_setupClassLoaderForDeserialization(valueType);\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), _typeFactory.constructType(valueType));\n+    } \n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T> T readValue(File src, TypeReference valueTypeRef)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), _typeFactory.constructType(valueTypeRef));\n+    } \n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(File src, JavaType valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), valueType);\n+    } \n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(URL src, Class<T> valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+     // !!! TODO\n+//    \t_setupClassLoaderForDeserialization(valueType);\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), _typeFactory.constructType(valueType));\n+    } \n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T> T readValue(URL src, TypeReference valueTypeRef)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), _typeFactory.constructType(valueTypeRef));\n+    } \n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(URL src, JavaType valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), valueType);\n+    } \n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(String content, Class<T> valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+     // !!! TODO\n+//    \t_setupClassLoaderForDeserialization(valueType);\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(content), _typeFactory.constructType(valueType));\n+    } \n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T> T readValue(String content, TypeReference valueTypeRef)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(content), _typeFactory.constructType(valueTypeRef));\n+    } \n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(String content, JavaType valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(content), valueType);\n+    } \n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(Reader src, Class<T> valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+     // !!! TODO\n+//    \t_setupClassLoaderForDeserialization(valueType);\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), _typeFactory.constructType(valueType));\n+    } \n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T> T readValue(Reader src, TypeReference valueTypeRef)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), _typeFactory.constructType(valueTypeRef));\n+    } \n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(Reader src, JavaType valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), valueType);\n+    } \n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(InputStream src, Class<T> valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+     // !!! TODO\n+//    \t_setupClassLoaderForDeserialization(valueType);\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), _typeFactory.constructType(valueType));\n+    } \n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T> T readValue(InputStream src, TypeReference valueTypeRef)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), _typeFactory.constructType(valueTypeRef));\n+    } \n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(InputStream src, JavaType valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), valueType);\n+    } \n+\n+    /**\n+     * @since 1.8\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(byte[] src, Class<T> valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+     // !!! TODO\n+//      _setupClassLoaderForDeserialization(valueType);\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), _typeFactory.constructType(valueType));\n+    } \n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(byte[] src, int offset, int len, \n+                               Class<T> valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+     // !!! TODO\n+//    \t_setupClassLoaderForDeserialization(valueType);\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src, offset, len), _typeFactory.constructType(valueType));\n+    } \n+\n+    /**\n+     * @since 1.8\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T> T readValue(byte[] src, TypeReference valueTypeRef)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), _typeFactory.constructType(valueTypeRef));\n+    } \n+    \n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T> T readValue(byte[] src, int offset, int len,\n+                           TypeReference valueTypeRef)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src, offset, len), _typeFactory.constructType(valueTypeRef));\n+    } \n+\n+    /**\n+     * @since 1.8\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(byte[] src, JavaType valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src), valueType);\n+    } \n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(byte[] src, int offset, int len,\n+                           JavaType valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readMapAndClose(_jsonFactory.createJsonParser(src, offset, len), valueType);\n+    } \n+    \n+    /**\n+     * Convenience method for converting results from given JSON tree into given\n+     * value type. Basically short-cut for:\n+     *<pre>\n+     *   mapper.readValue(mapper.treeAsTokens(root), valueType);\n+     *</pre>\n+     *\n+     * @since 1.6\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(JsonNode root, Class<T> valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+     // !!! TODO\n+//    \t_setupClassLoaderForDeserialization(valueType);\n+        return (T) _readValue(copyDeserializationConfig(), treeAsTokens(root), _typeFactory.constructType(valueType));\n+    } \n+\n+    /**\n+     * Convenience method for converting results from given JSON tree into given\n+     * value type. Basically short-cut for:\n+     *<pre>\n+     *   mapper.readValue(mapper.treeAsTokens(root), valueType);\n+     *</pre>\n+     *\n+     * @since 1.6\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T> T readValue(JsonNode root, TypeReference valueTypeRef)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readValue(copyDeserializationConfig(), treeAsTokens(root), _typeFactory.constructType(valueTypeRef));\n+    } \n+    \n+    /**\n+     * Convenience method for converting results from given JSON tree into given\n+     * value type. Basically short-cut for:\n+     *<pre>\n+     *   mapper.readValue(mapper.treeAsTokens(root), valueType);\n+     *</pre>\n+     *\n+     * @since 1.6\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(JsonNode root, JavaType valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        return (T) _readValue(copyDeserializationConfig(), treeAsTokens(root), valueType);\n+    } \n+    \n+    /*\n+    /**********************************************************\n+    /* Extended Public API: serialization\n+    /* (mapping from Java types to Json)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to serialize any Java value as\n+     * JSON output, written to File provided.\n+     */\n+    public void writeValue(File resultFile, Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        _configAndWriteValue(_jsonFactory.createJsonGenerator(resultFile, JsonEncoding.UTF8), value);\n+    }\n+\n+    /**\n+     * Method that can be used to serialize any Java value as\n+     * JSON output, using output stream provided (using encoding\n+     * {@link JsonEncoding#UTF8}).\n+     *<p>\n+     * Note: method does not close the underlying stream explicitly\n+     * here; however, {@link JsonFactory} this mapper uses may choose\n+     * to close the stream depending on its settings (by default,\n+     * it will try to close it when {@link JsonGenerator} we construct\n+     * is closed).\n+     */\n+    public void writeValue(OutputStream out, Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        _configAndWriteValue(_jsonFactory.createJsonGenerator(out, JsonEncoding.UTF8), value);\n+    }\n+\n+    /**\n+     * Method that can be used to serialize any Java value as\n+     * JSON output, using Writer provided.\n+     *<p>\n+     * Note: method does not close the underlying stream explicitly\n+     * here; however, {@link JsonFactory} this mapper uses may choose\n+     * to close the stream depending on its settings (by default,\n+     * it will try to close it when {@link JsonGenerator} we construct\n+     * is closed).\n+     */\n+    public void writeValue(Writer w, Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        _configAndWriteValue(_jsonFactory.createJsonGenerator(w), value);\n+    }\n+\n+    /**\n+     * Method that can be used to serialize any Java value as\n+     * a String. Functionally equivalent to calling\n+     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n+     * and constructing String, but more efficient.\n+     *\n+     * @since 1.3\n+     */\n+    public String writeValueAsString(Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {        \n+        // alas, we have to pull the recycler directly here...\n+        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n+        _configAndWriteValue(_jsonFactory.createJsonGenerator(sw), value);\n+        return sw.getAndClear();\n+    }\n+    \n+    /**\n+     * Method that can be used to serialize any Java value as\n+     * a byte array. Functionally equivalent to calling\n+     * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}\n+     * and getting bytes, but more efficient.\n+     * Encoding used will be UTF-8.\n+     *\n+     * @since 1.5\n+     */\n+    public byte[] writeValueAsBytes(Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {        \n+        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n+        _configAndWriteValue(_jsonFactory.createJsonGenerator(bb, JsonEncoding.UTF8), value);\n+        byte[] result = bb.toByteArray();\n+        bb.release();\n+        return result;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended Public API: constructing ObjectWriters\n+    /* for more advanced configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Convenience method for constructing {@link ObjectWriter}\n+     * with default settings.\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectWriter writer() {\n+        return new ObjectWriter(this, copySerializationConfig());\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified {@link DateFormat}; or, if\n+     * null passed, using timestamp (64-bit number.\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectWriter writer(DateFormat df) {\n+        return new ObjectWriter(this,\n+                copySerializationConfig().withDateFormat(df));\n+    }\n+    \n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified JSON View (filter).\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectWriter writerWithView(Class<?> serializationView) {\n+        return new ObjectWriter(this, copySerializationConfig().withView(serializationView));\n+    }\n+    \n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified root type, instead of actual\n+     * runtime type of value. Type must be a super-type of runtime\n+     * type.\n+     *\n+     * @since 1.9\n+     */\n+    public ObjectWriter writerWithType(Class<?> rootType) {\n+        JavaType t = (rootType == null) ? null : _typeFactory.constructType(rootType);\n+        return new ObjectWriter(this, copySerializationConfig(), t, /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified root type, instead of actual\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectWriter writerWithType(JavaType rootType) {\n+        return new ObjectWriter(this, copySerializationConfig(), rootType, /*PrettyPrinter*/null);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified root type, instead of actual\n+     * runtime type of value. Type must be a super-type of runtime type.\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectWriter writerWithType(TypeReference<?> rootType) {\n+        JavaType t = (rootType == null) ? null : _typeFactory.constructType(rootType);\n+        return new ObjectWriter(this, copySerializationConfig(), t, /*PrettyPrinter*/null);\n+    }\n+    \n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified pretty printer for indentation\n+     * (or if null, no pretty printer)\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectWriter writer(PrettyPrinter pp) {\n+        if (pp == null) { // need to use a marker to indicate explicit disabling of pp\n+            pp = ObjectWriter.NULL_PRETTY_PRINTER;\n+        }\n+        return new ObjectWriter(this, copySerializationConfig(), /*root type*/ null, pp);\n+    }\n+    \n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using the default pretty printer for indentation\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectWriter writerWithDefaultPrettyPrinter() {\n+        return new ObjectWriter(this, copySerializationConfig(),\n+                /*root type*/ null, _defaultPrettyPrinter());\n+    }\n+    \n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * serialize objects using specified filter provider.\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectWriter writer(FilterProvider filterProvider) {\n+        return new ObjectWriter(this,\n+                copySerializationConfig().withFilters(filterProvider));\n+    }\n+    \n+    /**\n+     * Factory method for constructing {@link ObjectWriter} that will\n+     * pass specific schema object to {@link JsonGenerator} used for\n+     * writing content.\n+     * \n+     * @param schema Schema to pass to generator\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectWriter writer(FormatSchema schema) {\n+        return new ObjectWriter(this, copySerializationConfig(), schema);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Deprecated ObjectWriter creator methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @deprecated Since 1.9, use {@link #writerWithType(Class)} instead.\n+     */\n+    @Deprecated\n+    public ObjectWriter typedWriter(Class<?> rootType) {\n+        return writerWithType(rootType);\n+    }\n+\n+    /**\n+     * @deprecated Since 1.9, use {@link #writerWithType(JavaType)} instead.\n+     */\n+    @Deprecated\n+    public ObjectWriter typedWriter(JavaType rootType) {\n+        return writerWithType(rootType);\n+    }\n+\n+    /**\n+     * @deprecated Since 1.9, use {@link #writerWithType(TypeReference)} instead.\n+     */\n+    @Deprecated\n+    public ObjectWriter typedWriter(TypeReference<?> rootType) {\n+        return writerWithType(rootType);\n+    }\n+    \n+    /**\n+     * @deprecated Since 1.9, use {@link #writerWithView(Class)} instead.\n+     */\n+    @Deprecated\n+    public ObjectWriter viewWriter(Class<?> serializationView) {\n+        return writerWithView(serializationView);\n+    }\n+    \n+    /**\n+     * @deprecated Since 1.9, use {@link #writer(FilterProvider)} instead.\n+     */\n+    @Deprecated\n+    public ObjectWriter prettyPrintingWriter(PrettyPrinter pp) {\n+        return writer(pp);\n+    }\n+\n+    /**\n+     * @deprecated Since 1.9, use {@link #writerWithDefaultPrettyPrinter} instead.\n+     */\n+    @Deprecated\n+    public ObjectWriter defaultPrettyPrintingWriter() {\n+        return writerWithDefaultPrettyPrinter();\n+    }\n+    \n+    /**\n+     * @deprecated Since 1.9, use {@link #writer(FilterProvider)} instead.\n+     */\n+    @Deprecated\n+    public ObjectWriter filteredWriter(FilterProvider filterProvider) {\n+        return writer(filterProvider);\n+    }\n+    \n+    /**\n+     * @deprecated Since 1.9, use {@link #writer(FilterProvider)} instead.\n+     */\n+    @Deprecated\n+    public ObjectWriter schemaBasedWriter(FormatSchema schema) {\n+        return writer(schema);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended Public API: constructing ObjectReaders\n+    /* for more advanced configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory method for constructing {@link ObjectReader} with\n+     * default settings. Note that the resulting instance is NOT usable as is,\n+     * without defining expected value type.\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectReader reader() {\n+        return new ObjectReader(this, copyDeserializationConfig())\n+            .withInjectableValues(_injectableValues);\n+    }\n+    \n+    /**\n+     * Factory method for constructing {@link ObjectReader} that will\n+     * update given Object (usually Bean, but can be a Collection or Map\n+     * as well, but NOT an array) with JSON data. Deserialization occurs\n+     * normally except that the root-level value in JSON is not used for\n+     * instantiating a new object; instead give updateable object is used\n+     * as root.\n+     * Runtime type of value object is used for locating deserializer,\n+     * unless overridden by other factory methods of {@link ObjectReader}\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectReader readerForUpdating(Object valueToUpdate)\n+    {\n+        JavaType t = _typeFactory.constructType(valueToUpdate.getClass());\n+        return new ObjectReader(this, copyDeserializationConfig(), t, valueToUpdate,\n+                null, _injectableValues);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectReader} that will\n+     * read or update instances of specified type\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectReader reader(JavaType type)\n+    {\n+        return new ObjectReader(this, copyDeserializationConfig(), type, null,\n+                null, _injectableValues);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectReader} that will\n+     * read or update instances of specified type\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectReader reader(Class<?> type)\n+    {\n+        return reader(_typeFactory.constructType(type));\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectReader} that will\n+     * read or update instances of specified type\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectReader reader(TypeReference<?> type)\n+    {\n+        return reader(_typeFactory.constructType(type));\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectReader} that will\n+     * use specified {@link JsonNodeFactory} for constructing JSON trees.\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectReader reader(JsonNodeFactory f)\n+    {\n+        return new ObjectReader(this, copyDeserializationConfig()).withNodeFactory(f);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectReader} that will\n+     * pass specific schema object to {@link JsonParser} used for\n+     * reading content.\n+     * \n+     * @param schema Schema to pass to parser\n+     * \n+     * @since 1.8\n+     */\n+    public ObjectReader reader(FormatSchema schema) {\n+        return new ObjectReader(this, copyDeserializationConfig(), null, null,\n+                schema, _injectableValues);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectReader} that will\n+     * use specified injectable values.\n+     * \n+     * @param injectableValues Injectable values to use\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectReader reader(InjectableValues injectableValues) {\n+        return new ObjectReader(this, copyDeserializationConfig(), null, null,\n+                null, injectableValues);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Deprecated ObjectReader creator methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @deprecated Since 1.9, use {@link #readerForUpdating} instead.\n+     */\n+    @Deprecated\n+    public ObjectReader updatingReader(Object valueToUpdate) {\n+        return readerForUpdating(valueToUpdate);\n+    }\n+    \n+    /**\n+     * @deprecated Since 1.9, use {@link #reader(FormatSchema)} instead.\n+     */\n+    @Deprecated\n+    public ObjectReader schemaBasedReader(FormatSchema schema) {\n+        return reader(schema);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended Public API: convenience type conversion\n+    /**********************************************************\n+     */\n+   \n+    /**\n+     * Convenience method for doing two-step conversion from given value, into\n+     * instance of given value type. This is functionality equivalent to first\n+     * serializing given value into JSON, then binding JSON data into value\n+     * of given type, but may be executed without fully serializing into\n+     * JSON. Same converters (serializers, deserializers) will be used as for\n+     * data binding, meaning same object mapper configuration works.\n+     *      \n+     * @throws IllegalArgumentException If conversion fails due to incompatible type;\n+     *    if so, root cause will contain underlying checked exception data binding\n+     *    functionality threw\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T convertValue(Object fromValue, Class<T> toValueType)\n+        throws IllegalArgumentException\n+    {\n+        return (T) _convert(fromValue, _typeFactory.constructType(toValueType));\n+    } \n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public <T> T convertValue(Object fromValue, TypeReference toValueTypeRef)\n+        throws IllegalArgumentException\n+    {\n+        return (T) _convert(fromValue, _typeFactory.constructType(toValueTypeRef));\n+    } \n+\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T convertValue(Object fromValue, JavaType toValueType)\n+        throws IllegalArgumentException\n+    {\n+        return (T) _convert(fromValue, toValueType);\n+    } \n+\n+    protected Object _convert(Object fromValue, JavaType toValueType)\n+        throws IllegalArgumentException\n+    {\n+        // sanity check for null first:\n+        if (fromValue == null) return null;\n+        /* Then use TokenBuffer, which is a JsonGenerator:\n+         * (see [JACKSON-175])\n+         */\n+        TokenBuffer buf = new TokenBuffer(this);\n+        try {\n+            writeValue(buf, fromValue);\n+            // and provide as with a JsonParser for contents as well!\n+            JsonParser jp = buf.asParser();\n+            Object result = readValue(jp, toValueType);\n+            jp.close();\n+            return result;\n+        } catch (IOException e) { // should not occur, no real i/o...\n+            throw new IllegalArgumentException(e.getMessage(), e);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended Public API: JSON Schema generation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Generate <a href=\"http://json-schema.org/\">Json-schema</a>\n+     * instance for specified class.\n+     *\n+     * @param t The class to generate schema for\n+     * @return Constructed JSON schema.\n+     */\n+    public JsonSchema generateJsonSchema(Class<?> t)\n+            throws JsonMappingException\n+    {\n+        return generateJsonSchema(t, copySerializationConfig());\n+    }\n+\n+    /**\n+     * Generate <a href=\"http://json-schema.org/\">Json-schema</a>\n+     * instance for specified class, using specific\n+     * serialization configuration\n+     *\n+     * @param t The class to generate schema for\n+     * @return Constructed JSON schema.\n+     */\n+    public JsonSchema generateJsonSchema(Class<?> t, SerializationConfig cfg)\n+            throws JsonMappingException\n+    {\n+        return _serializerProvider.generateJsonSchema(t, cfg, _serializerFactory);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods for serialization, overridable\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method that should return default pretty-printer to\n+     * use for generators constructed by this mapper, when instructed\n+     * to use default pretty printer.\n+     * \n+     * @since 1.7\n+     */\n+    protected PrettyPrinter _defaultPrettyPrinter() {\n+        return new DefaultPrettyPrinter();\n+    }\n+    \n+    /**\n+     * Method called to configure the generator as necessary and then\n+     * call write functionality\n+     */\n+    protected final void _configAndWriteValue(JsonGenerator jgen, Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        SerializationConfig cfg = copySerializationConfig();\n+        // [JACKSON-96]: allow enabling pretty printing for ObjectMapper directly\n+        if (cfg.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT)) {\n+            jgen.useDefaultPrettyPrinter();\n+        }\n+        // [JACKSON-282]: consider Closeable\n+        if (cfg.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+            _configAndWriteCloseable(jgen, value, cfg);\n+            return;\n+        }\n+        boolean closed = false;\n+        try {\n+            _serializerProvider.serializeValue(cfg, jgen, value, _serializerFactory);\n+            closed = true;\n+            jgen.close();\n+        } finally {\n+            /* won't try to close twice; also, must catch exception (so it \n+             * will not mask exception that is pending)\n+             */\n+            if (!closed) {\n+                try {\n+                    jgen.close();\n+                } catch (IOException ioe) { }\n+            }\n+        }\n+    }\n+\n+    protected final void _configAndWriteValue(JsonGenerator jgen, Object value, Class<?> viewClass)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        SerializationConfig cfg = copySerializationConfig().withView(viewClass);\n+        if (cfg.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT)) {\n+            jgen.useDefaultPrettyPrinter();\n+        }\n+        // [JACKSON-282]: consider Closeable\n+        if (cfg.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+            _configAndWriteCloseable(jgen, value, cfg);\n+            return;\n+        }\n+        boolean closed = false;\n+        try {\n+            _serializerProvider.serializeValue(cfg, jgen, value, _serializerFactory);\n+            closed = true;\n+            jgen.close();\n+        } finally {\n+            if (!closed) {\n+                try {\n+                    jgen.close();\n+                } catch (IOException ioe) { }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n+     * method is to be called right after serialization has been called\n+     */\n+    private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        Closeable toClose = (Closeable) value;\n+        try {\n+            _serializerProvider.serializeValue(cfg, jgen, value, _serializerFactory);\n+            JsonGenerator tmpJgen = jgen;\n+            jgen = null;\n+            tmpJgen.close();\n+            Closeable tmpToClose = toClose;\n+            toClose = null;\n+            tmpToClose.close();\n+        } finally {\n+            /* Need to close both generator and value, as long as they haven't yet\n+             * been closed\n+             */\n+            if (jgen != null) {\n+                try {\n+                    jgen.close();\n+                } catch (IOException ioe) { }\n+            }\n+            if (toClose != null) {\n+                try {\n+                    toClose.close();\n+                } catch (IOException ioe) { }\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n+     * method is to be called right after serialization has been called\n+     */\n+    private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        Closeable toClose = (Closeable) value;\n+        try {\n+            _serializerProvider.serializeValue(cfg, jgen, value, _serializerFactory);\n+            if (cfg.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+                jgen.flush();\n+            }\n+            Closeable tmpToClose = toClose;\n+            toClose = null;\n+            tmpToClose.close();\n+        } finally {\n+            if (toClose != null) {\n+                try {\n+                    toClose.close();\n+                } catch (IOException ioe) { }\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods for deserialization, overridable\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Actual implementation of value reading+binding operation.\n+     */\n+    protected Object _readValue(DeserializationConfig cfg, JsonParser jp, JavaType valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        /* First: may need to read the next token, to initialize\n+         * state (either before first read from parser, or after\n+         * previous token has been cleared)\n+         */\n+        Object result;\n+        JsonToken t = _initForReading(jp);\n+        if (t == JsonToken.VALUE_NULL) {\n+            // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n+            result = _findRootDeserializer(cfg, valueType).getNullValue();\n+        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n+            result = null;\n+        } else { // pointing to event other than null\n+            DeserializationContext ctxt = _createDeserializationContext(jp, cfg);\n+            JsonDeserializer<Object> deser = _findRootDeserializer(cfg, valueType);\n+            // ok, let's get the value\n+            if (cfg.isEnabled(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE)) {\n+                result = _unwrapAndDeserialize(jp, valueType, ctxt, deser);\n+            } else {\n+                result = deser.deserialize(jp, ctxt);\n+            }\n+        }\n+        // Need to consume the token too\n+        jp.clearCurrentToken();\n+        return result;\n+    }\n+\n+    \n+    protected Object _readMapAndClose(JsonParser jp, JavaType valueType)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        try {\n+            Object result;\n+            JsonToken t = _initForReading(jp);\n+            if (t == JsonToken.VALUE_NULL) {\n+                // [JACKSON-643]: Ask JsonDeserializer what 'null value' to use:\n+                // (note: probably no need to make a copy of config for just this access)\n+                result = _findRootDeserializer(this._deserializationConfig, valueType).getNullValue();\n+            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n+                result = null;\n+            } else {\n+                DeserializationConfig cfg = copyDeserializationConfig();\n+                DeserializationContext ctxt = _createDeserializationContext(jp, cfg);\n+                JsonDeserializer<Object> deser = _findRootDeserializer(cfg, valueType);\n+                if (cfg.isEnabled(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE)) {\n+                    result = _unwrapAndDeserialize(jp, valueType, ctxt, deser);\n+                } else {\n+                    result = deser.deserialize(jp, ctxt);\n+                }\n+            }\n+            // Need to consume the token too\n+            jp.clearCurrentToken();\n+            return result;\n+        } finally {\n+            try {\n+                jp.close();\n+            } catch (IOException ioe) { }\n+        }\n+    }\n+    \n+    /**\n+     * Method called to ensure that given parser is ready for reading\n+     * content for data binding.\n+     *\n+     * @return First token to be used for data binding after this call:\n+     *  can never be null as exception will be thrown if parser can not\n+     *  provide more tokens.\n+     *\n+     * @throws IOException if the underlying input source has problems during\n+     *   parsing\n+     * @throws JsonParseException if parser has problems parsing content\n+     * @throws JsonMappingException if the parser does not have any more\n+     *   content to map (note: Json \"null\" value is considered content;\n+     *   enf-of-stream not)\n+     */\n+    protected JsonToken _initForReading(JsonParser jp)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        /* First: must point to a token; if not pointing to one, advance.\n+         * This occurs before first read from JsonParser, as well as\n+         * after clearing of current token.\n+         */\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == null) {\n+            // and then we must get something...\n+            t = jp.nextToken();\n+            if (t == null) {\n+                /* [JACKSON-99] Should throw EOFException, closest thing\n+                 *   semantically\n+                 */\n+                throw new EOFException(\"No content to map to Object due to end of input\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    protected Object _unwrapAndDeserialize(JsonParser jp, JavaType rootType,\n+            DeserializationContext ctxt, JsonDeserializer<Object> deser)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        SerializedString rootName = _deserializerProvider.findExpectedRootName(ctxt.getConfig(), rootType);\n+        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n+            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n+                    +rootName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n+            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n+                    +rootName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        String actualName = jp.getCurrentName();\n+        if (!rootName.getValue().equals(actualName)) {\n+            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"+rootName\n+                    +\"') for type \"+rootType);\n+        }\n+        // ok, then move to value itself....\n+        jp.nextToken();\n+        \n+        Object result = deser.deserialize(jp, ctxt);\n+        // and last, verify that we now get matching END_OBJECT\n+        if (jp.nextToken() != JsonToken.END_OBJECT) {\n+            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n+                    +rootName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        return result;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to locate deserializer for the passed root-level value.\n+     */\n+    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationConfig cfg, JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        // First: have we already seen it?\n+        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n+        if (deser != null) {\n+            return deser;\n+        }\n+        // Nope: need to ask provider to resolve it\n+        deser = _deserializerProvider.findTypedValueDeserializer(cfg, valueType, null);\n+        if (deser == null) { // can this happen?\n+            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n+        }\n+        _rootDeserializers.put(valueType, deser);\n+        return deser;\n+    }\n+    \n+    protected DeserializationContext _createDeserializationContext(JsonParser jp, DeserializationConfig cfg)\n+    {\n+        return new StdDeserializationContext(cfg, jp, _deserializerProvider,\n+                _injectableValues);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+import java.net.URL;\n+import java.util.Iterator;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.core.util.VersionUtil;\n+import com.fasterxml.jackson.databind.deser.StdDeserializationContext;\n+import com.fasterxml.jackson.databind.type.SimpleType;\n+\n+import org.codehaus.jackson.node.JsonNodeFactory;\n+import org.codehaus.jackson.node.NullNode;\n+import org.codehaus.jackson.node.TreeTraversingParser;\n+\n+/**\n+ * Builder object that can be used for per-serialization configuration of\n+ * deserialization parameters, such as root type to use or object\n+ * to update (instead of constructing new instance).\n+ * Uses \"fluid\" (aka builder) pattern so that instances are immutable\n+ * (and thus fully thread-safe with no external synchronization);\n+ * new instances are constructed for different configurations.\n+ * Instances are initially constructed by {@link ObjectMapper} and can be\n+ * reused.\n+ * \n+ * @author tatu\n+ * @since 1.6\n+ */\n+public class ObjectReader\n+    extends ObjectCodec\n+    implements Versioned\n+{\n+    private final static JavaType JSON_NODE_TYPE = SimpleType.constructUnsafe(JsonNode.class);\n+\n+    /*\n+    /**********************************************************\n+    /* Immutable configuration from ObjectMapper\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * General serialization configuration settings; while immutable,\n+     * can use copy-constructor to create modified instances as necessary.\n+     */\n+    protected final DeserializationConfig _config;\n+\n+    /**\n+     * Flag that indicates whether root values are expected to be unwrapped\n+     * or not\n+     * \n+     * @since 1.9\n+     */\n+    protected final boolean _unwrapRoot;\n+    \n+    /**\n+     * Root-level cached deserializers\n+     */\n+    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _rootDeserializers;\n+   \n+    protected final DeserializerProvider _provider;\n+\n+    /**\n+     * Factory used for constructing {@link JsonGenerator}s\n+     */\n+    protected final JsonFactory _jsonFactory;\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration that can be changed during building\n+    /**********************************************************\n+     */   \n+\n+    /**\n+     * Declared type of value to instantiate during deserialization.\n+     * Defines which deserializer to use; as well as base type of instance\n+     * to construct if an updatable value is not configured to be used\n+     * (subject to changes by embedded type information, for polymorphic\n+     * types). If {@link #_valueToUpdate} is non-null, only used for\n+     * locating deserializer.\n+     */\n+    protected final JavaType _valueType;\n+\n+    /**\n+     * Instance to update with data binding; if any. If null,\n+     * a new instance is created, if non-null, properties of\n+     * this value object will be updated instead.\n+     * Note that value can be of almost any type, except not\n+     * {@link com.fasterxml.jackson.databind.type.ArrayType}; array\n+     * types can not be modified because array size is immutable.\n+     */\n+    protected final Object _valueToUpdate;\n+\n+    /**\n+     * When using data format that uses a schema, schema is passed\n+     * to parser.\n+     * \n+     * @since 1.8\n+     */\n+    protected final FormatSchema _schema;\n+\n+    /**\n+     * Values that can be injected during deserialization, if any.\n+     * \n+     * @since 1.9\n+     */\n+    protected final InjectableValues _injectableValues;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used by {@link ObjectMapper} for initial instantiation\n+     * \n+     * @since 1.8\n+     */\n+    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config)\n+    {\n+        this(mapper, config, null, null, null, null);\n+    }\n+\n+    protected ObjectReader(ObjectMapper mapper, DeserializationConfig config,\n+            JavaType valueType, Object valueToUpdate, FormatSchema schema,\n+            InjectableValues injectableValues)\n+    {\n+        _config = config;\n+        _rootDeserializers = mapper._rootDeserializers;\n+        _provider = mapper._deserializerProvider;\n+        _jsonFactory = mapper._jsonFactory;\n+        _valueType = valueType;\n+        _valueToUpdate = valueToUpdate;\n+        if (valueToUpdate != null && valueType.isArrayType()) {\n+            throw new IllegalArgumentException(\"Can not update an array value\");\n+        }\n+        _schema = schema;\n+        _injectableValues = injectableValues;\n+        _unwrapRoot = config.isEnabled(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n+    }\n+    \n+    /**\n+     * Copy constructor used for building variations.\n+     */\n+    protected ObjectReader(ObjectReader base, DeserializationConfig config,\n+            JavaType valueType, Object valueToUpdate, FormatSchema schema,\n+            InjectableValues injectableValues)\n+    {\n+        _config = config;\n+\n+        _rootDeserializers = base._rootDeserializers;\n+        _provider = base._provider;\n+        _jsonFactory = base._jsonFactory;\n+\n+        _valueType = valueType;\n+        _valueToUpdate = valueToUpdate;\n+        if (valueToUpdate != null && valueType.isArrayType()) {\n+            throw new IllegalArgumentException(\"Can not update an array value\");\n+        }\n+        _schema = schema;\n+        _injectableValues = injectableValues;\n+        _unwrapRoot = config.isEnabled(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE);\n+    }\n+\n+    /**\n+     * Method that will return version information stored in and read from jar\n+     * that contains this class.\n+     * \n+     * @since 1.6\n+     */\n+    @Override\n+    public Version version() {\n+        return VersionUtil.versionFor(getClass());\n+    }\n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * to data bind into specified type.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    public ObjectReader withType(JavaType valueType)\n+    {\n+        if (valueType == _valueType) return this;\n+        // type is stored here, no need to make a copy of config\n+        return new ObjectReader(this, _config, valueType, _valueToUpdate,\n+                _schema, _injectableValues);\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * to data bind into specified type.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    public ObjectReader withType(Class<?> valueType)\n+    {\n+        return withType(_config.constructType(valueType));\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * to data bind into specified type.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    public ObjectReader withType(java.lang.reflect.Type valueType)\n+    {\n+        return withType(_config.getTypeFactory().constructType(valueType));\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * to data bind into specified type.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     * \n+     * @since 1.8\n+     */\n+    public ObjectReader withType(TypeReference<?> valueTypeRef)\n+    {\n+        return withType(_config.getTypeFactory().constructType(valueTypeRef.getType()));\n+    }    \n+    \n+    /**\n+     * Method for constructing a new reader instance with configuration that uses\n+     * passed {@link JsonNodeFactory} for constructing {@link JsonNode}\n+     * instances.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    public ObjectReader withNodeFactory(JsonNodeFactory f)\n+    {\n+        // node factory is stored within config, so need to copy that first\n+        if (f == _config.getNodeFactory()) return this;\n+        return new ObjectReader(this, _config.withNodeFactory(f), _valueType, _valueToUpdate,\n+                _schema, _injectableValues);\n+    }\n+\n+    /**\n+     * Method for constructing a new instance with configuration that\n+     * updates passed Object (as root value), instead of constructing \n+     * a new value.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     */\n+    public ObjectReader withValueToUpdate(Object value)\n+    {\n+        if (value == _valueToUpdate) return this;\n+        if (value == null) {\n+            throw new IllegalArgumentException(\"cat not update null value\");\n+        }\n+        JavaType t = (_valueType == null) ? _config.constructType(value.getClass()) : _valueType;\n+        return new ObjectReader(this, _config, t, value,\n+                _schema, _injectableValues);\n+    }    \n+\n+    /**\n+     * Method for constructing a new instance with configuration that\n+     * passes specified {@link FormatSchema} to {@link JsonParser} that\n+     * is constructed for parsing content.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     * \n+     * @since 1.8\n+     */\n+    public ObjectReader withSchema(FormatSchema schema)\n+    {\n+        if (_schema == schema) {\n+            return this;\n+        }\n+        return new ObjectReader(this, _config, _valueType, _valueToUpdate,\n+                schema, _injectableValues);\n+    }\n+\n+    /**\n+     * Method for constructing a new instance with configuration that uses\n+     * passed {@link InjectableValues} to provide injectable values.\n+     *<p>\n+     * Note that the method does NOT change state of this reader, but\n+     * rather construct and returns a newly configured instance.\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectReader withInjectableValues(InjectableValues injectableValues)\n+    {\n+        if (_injectableValues == injectableValues) {\n+            return this;\n+        }\n+        return new ObjectReader(this, _config, _valueType, _valueToUpdate,\n+                _schema, injectableValues);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Deserialization methods; basic ones to support ObjectCodec first\n+    /* (ones that take JsonParser)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that binds content read using given parser, using\n+     * configuration of this reader, including expected result type.\n+     * Value return is either newly constructed, or root value that\n+     * was specified with {@link #withValueToUpdate(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(JsonParser jp)\n+        throws IOException, JsonProcessingException\n+    {\n+        return (T) _bind(jp);\n+    }\n+\n+    /**\n+     * Convenience method that binds content read using given parser, using\n+     * configuration of this reader, except that expected value type\n+     * is specified with the call (instead of currently configured root type).\n+     * Value return is either newly constructed, or root value that\n+     * was specified with {@link #withValueToUpdate(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> T readValue(JsonParser jp, Class<T> valueType)\n+        throws IOException, JsonProcessingException\n+    {\n+        return (T) withType(valueType).readValue(jp);\n+    }\n+\n+    /**\n+     * Convenience method that binds content read using given parser, using\n+     * configuration of this reader, except that expected value type\n+     * is specified with the call (instead of currently configured root type).\n+     * Value return is either newly constructed, or root value that\n+     * was specified with {@link #withValueToUpdate(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> T readValue(JsonParser jp, TypeReference<?> valueTypeRef)\n+        throws IOException, JsonProcessingException\n+    {\n+        return (T) withType(valueTypeRef).readValue(jp);\n+    }\n+\n+    /**\n+     * Convenience method that binds content read using given parser, using\n+     * configuration of this reader, except that expected value type\n+     * is specified with the call (instead of currently configured root type).\n+     * Value return is either newly constructed, or root value that\n+     * was specified with {@link #withValueToUpdate(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> T readValue(JsonParser jp, JavaType valueType) throws IOException, JsonProcessingException {\n+        return (T) withType(valueType).readValue(jp);\n+    }\n+    \n+    /**\n+     * Convenience method that binds content read using given parser, using\n+     * configuration of this reader, except that content is bound as\n+     * JSON tree instead of configured root value type.\n+     *<p>\n+     * Note: if an object was specified with {@link #withValueToUpdate}, it\n+     * will be ignored.\n+     */\n+    @Override\n+    public JsonNode readTree(JsonParser jp)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _bindAsTree(jp);\n+    }\n+\n+    /**\n+     * Convenience method that is equivalent to:\n+     *<pre>\n+     *   withType(valueType).readValues(jp);\n+     *</pre>\n+     */\n+    @Override\n+    public <T> Iterator<T> readValues(JsonParser jp, Class<T> valueType)\n+        throws IOException, JsonProcessingException {\n+        return withType(valueType).readValues(jp);\n+    }\n+\n+    /**\n+     * Convenience method that is equivalent to:\n+     *<pre>\n+     *   withType(valueTypeRef).readValues(jp);\n+     *</pre>\n+     */\n+    @Override\n+    public <T> Iterator<T> readValues(JsonParser jp, TypeReference<?> valueTypeRef)\n+        throws IOException, JsonProcessingException {\n+        return withType(valueTypeRef).readValues(jp);\n+    }\n+    \n+    /**\n+     * Convenience method that is equivalent to:\n+     *<pre>\n+     *   withType(valueType).readValues(jp);\n+     *</pre>\n+     */\n+    @Override\n+    public <T> Iterator<T> readValues(JsonParser jp, JavaType valueType)\n+        throws IOException, JsonProcessingException {\n+        return withType(valueType).readValues(jp);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Deserialization methods; others similar to what ObjectMapper has\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that binds content read from given input source,\n+     * using configuration of this reader.\n+     * Value return is either newly constructed, or root value that\n+     * was specified with {@link #withValueToUpdate(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(InputStream src)\n+        throws IOException, JsonProcessingException\n+    {\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n+    }\n+\n+    /**\n+     * Method that binds content read from given input source,\n+     * using configuration of this reader.\n+     * Value return is either newly constructed, or root value that\n+     * was specified with {@link #withValueToUpdate(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(Reader src)\n+        throws IOException, JsonProcessingException\n+    {\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n+    }\n+\n+    /**\n+     * Method that binds content read from given JSON string,\n+     * using configuration of this reader.\n+     * Value return is either newly constructed, or root value that\n+     * was specified with {@link #withValueToUpdate(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(String src)\n+        throws IOException, JsonProcessingException\n+    {\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n+    }\n+\n+    /**\n+     * Method that binds content read from given byte array,\n+     * using configuration of this reader.\n+     * Value return is either newly constructed, or root value that\n+     * was specified with {@link #withValueToUpdate(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(byte[] src)\n+        throws IOException, JsonProcessingException\n+    {\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n+    }\n+\n+    /**\n+     * Method that binds content read from given byte array,\n+     * using configuration of this reader.\n+     * Value return is either newly constructed, or root value that\n+     * was specified with {@link #withValueToUpdate(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(byte[] src, int offset, int length)\n+        throws IOException, JsonProcessingException\n+    {\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src, offset, length));\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(File src)\n+        throws IOException, JsonProcessingException\n+    {\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n+    }\n+\n+    /**\n+     * Method that binds content read from given input source,\n+     * using configuration of this reader.\n+     * Value return is either newly constructed, or root value that\n+     * was specified with {@link #withValueToUpdate(Object)}.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(URL src)\n+        throws IOException, JsonProcessingException\n+    {\n+        return (T) _bindAndClose(_jsonFactory.createJsonParser(src));\n+    }\n+\n+    /**\n+     * Convenience method for converting results from given JSON tree into given\n+     * value type. Basically short-cut for:\n+     *<pre>\n+     *   objectReader.readValue(src.traverse())\n+     *</pre>\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T readValue(JsonNode src)\n+        throws IOException, JsonProcessingException\n+    {\n+        return (T) _bindAndClose(treeAsTokens(src));\n+    }\n+    \n+    /**\n+     * Method that reads content from given input source,\n+     * using configuration of this reader, and binds it as JSON Tree.\n+     *<p>\n+     * Note that if an object was specified with a call to\n+     * {@link #withValueToUpdate(Object)}\n+     * it will just be ignored; result is always a newly constructed\n+     * {@link JsonNode} instance.\n+     */\n+    public JsonNode readTree(InputStream in)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _bindAndCloseAsTree(_jsonFactory.createJsonParser(in));\n+    }\n+    \n+    /**\n+     * Method that reads content from given input source,\n+     * using configuration of this reader, and binds it as JSON Tree.\n+     *<p>\n+     * Note that if an object was specified with a call to\n+     * {@link #withValueToUpdate(Object)}\n+     * it will just be ignored; result is always a newly constructed\n+     * {@link JsonNode} instance.\n+     */\n+    public JsonNode readTree(Reader r)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _bindAndCloseAsTree(_jsonFactory.createJsonParser(r));\n+    }\n+\n+    /**\n+     * Method that reads content from given JSON input String,\n+     * using configuration of this reader, and binds it as JSON Tree.\n+     *<p>\n+     * Note that if an object was specified with a call to\n+     * {@link #withValueToUpdate(Object)}\n+     * it will just be ignored; result is always a newly constructed\n+     * {@link JsonNode} instance.\n+     */\n+    public JsonNode readTree(String content)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _bindAndCloseAsTree(_jsonFactory.createJsonParser(content));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deserialization methods; reading sequence of values\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for reading sequence of Objects from parser stream.\n+     * \n+     * @since 1.8\n+     */\n+    public <T> MappingIterator<T> readValues(JsonParser jp)\n+        throws IOException, JsonProcessingException\n+    {\n+        DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n+        // false -> do not close as caller gave parser instance\n+        return new MappingIterator<T>(_valueType, jp, ctxt,\n+                _findRootDeserializer(_config, _valueType),\n+                false, _valueToUpdate);\n+    }\n+    \n+    /**\n+     * Method for reading sequence of Objects from parser stream.\n+     * \n+     * @since 1.8\n+     */\n+    public <T> MappingIterator<T> readValues(InputStream src)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonParser jp = _jsonFactory.createJsonParser(src);\n+        if (_schema != null) {\n+            jp.setSchema(_schema);\n+        }\n+        DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n+        return new MappingIterator<T>(_valueType, jp, ctxt, \n+                _findRootDeserializer(_config, _valueType),\n+                true, _valueToUpdate);\n+    }\n+\n+    /**\n+     * Method for reading sequence of Objects from parser stream.\n+     * \n+     * @since 1.8\n+     */\n+    public <T> MappingIterator<T> readValues(Reader src)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonParser jp = _jsonFactory.createJsonParser(src);\n+        if (_schema != null) {\n+            jp.setSchema(_schema);\n+        }\n+        DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n+        return new MappingIterator<T>(_valueType, jp, ctxt,\n+                _findRootDeserializer(_config, _valueType), true, _valueToUpdate);\n+    }\n+    \n+    /**\n+     * Method for reading sequence of Objects from parser stream.\n+     * \n+     * @since 1.8\n+     */\n+    public <T> MappingIterator<T> readValues(String json)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonParser jp = _jsonFactory.createJsonParser(json);\n+        if (_schema != null) {\n+            jp.setSchema(_schema);\n+        }\n+        DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n+        return new MappingIterator<T>(_valueType, jp, ctxt,\n+                _findRootDeserializer(_config, _valueType), true, _valueToUpdate);\n+    }\n+\n+    /**\n+     * Method for reading sequence of Objects from parser stream.\n+     * \n+     * @since 1.8\n+     */\n+    public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonParser jp = _jsonFactory.createJsonParser(src, offset, length);\n+        if (_schema != null) {\n+            jp.setSchema(_schema);\n+        }\n+        DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n+        return new MappingIterator<T>(_valueType, jp, ctxt,\n+                _findRootDeserializer(_config, _valueType), true, _valueToUpdate);\n+    }\n+\n+    /**\n+     * Since 1.9.3\n+     */\n+    public final <T> MappingIterator<T> readValues(byte[] src)\n+            throws IOException, JsonProcessingException {\n+        return readValues(src, 0, src.length);\n+    }\n+    \n+    /**\n+     * Method for reading sequence of Objects from parser stream.\n+     * \n+     * @since 1.8\n+     */\n+    public <T> MappingIterator<T> readValues(File src)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonParser jp = _jsonFactory.createJsonParser(src);\n+        if (_schema != null) {\n+            jp.setSchema(_schema);\n+        }\n+        DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n+        return new MappingIterator<T>(_valueType, jp, ctxt,\n+                _findRootDeserializer(_config, _valueType), true, _valueToUpdate);\n+    }\n+\n+    /**\n+     * Method for reading sequence of Objects from parser stream.\n+     * \n+     * @since 1.8\n+     */\n+    public <T> MappingIterator<T> readValues(URL src)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonParser jp = _jsonFactory.createJsonParser(src);\n+        if (_schema != null) {\n+            jp.setSchema(_schema);\n+        }\n+        DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n+        return new MappingIterator<T>(_valueType, jp, ctxt,\n+                _findRootDeserializer(_config, _valueType), true, _valueToUpdate);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Actual implementation of value reading+binding operation.\n+     */\n+    protected Object _bind(JsonParser jp)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        /* First: may need to read the next token, to initialize state (either\n+         * before first read from parser, or after previous token has been cleared)\n+         */\n+        Object result;\n+        JsonToken t = _initForReading(jp);\n+        if (t == JsonToken.VALUE_NULL) {\n+            if (_valueToUpdate == null) {\n+                result = _findRootDeserializer(_config, _valueType).getNullValue();\n+            } else {\n+                result = _valueToUpdate;\n+            }\n+        } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n+            result = _valueToUpdate;\n+        } else { // pointing to event other than null\n+            DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n+            JsonDeserializer<Object> deser = _findRootDeserializer(_config, _valueType);\n+            if (_unwrapRoot) {\n+                result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n+            } else {\n+                if (_valueToUpdate == null) {\n+                    result = deser.deserialize(jp, ctxt);\n+                } else {\n+                    deser.deserialize(jp, ctxt, _valueToUpdate);\n+                    result = _valueToUpdate;\n+                }\n+            }\n+        }\n+        // Need to consume the token too\n+        jp.clearCurrentToken();\n+        return result;\n+    }\n+    \n+    protected Object _bindAndClose(JsonParser jp)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        if (_schema != null) {\n+            jp.setSchema(_schema);\n+        }\n+        try {\n+            Object result;\n+            JsonToken t = _initForReading(jp);\n+            if (t == JsonToken.VALUE_NULL) {\n+                if (_valueToUpdate == null) {\n+                    result = _findRootDeserializer(_config, _valueType).getNullValue();\n+                } else {\n+                    result = _valueToUpdate;\n+                }\n+            } else if (t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n+                result = _valueToUpdate;\n+            } else {\n+                DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n+                JsonDeserializer<Object> deser = _findRootDeserializer(_config, _valueType);\n+                if (_unwrapRoot) {\n+                    result = _unwrapAndDeserialize(jp, ctxt, _valueType, deser);\n+                } else {\n+                    if (_valueToUpdate == null) {\n+                        result = deser.deserialize(jp, ctxt);\n+                    } else {\n+                        deser.deserialize(jp, ctxt, _valueToUpdate);\n+                        result = _valueToUpdate;                    \n+                    }\n+                }\n+            }\n+            return result;\n+        } finally {\n+            try {\n+                jp.close();\n+            } catch (IOException ioe) { }\n+        }\n+    }\n+\n+    protected JsonNode _bindAsTree(JsonParser jp)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        JsonNode result;\n+        JsonToken t = _initForReading(jp);\n+        if (t == JsonToken.VALUE_NULL || t == JsonToken.END_ARRAY || t == JsonToken.END_OBJECT) {\n+            result = NullNode.instance;\n+        } else {\n+            DeserializationContext ctxt = _createDeserializationContext(jp, _config);\n+            JsonDeserializer<Object> deser = _findRootDeserializer(_config, JSON_NODE_TYPE);\n+            if (_unwrapRoot) {\n+                result = (JsonNode) _unwrapAndDeserialize(jp, ctxt, JSON_NODE_TYPE, deser);\n+            } else {\n+                result = (JsonNode) deser.deserialize(jp, ctxt);\n+            }\n+        }\n+        // Need to consume the token too\n+        jp.clearCurrentToken();\n+        return result;\n+    }\n+    \n+    protected JsonNode _bindAndCloseAsTree(JsonParser jp)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        if (_schema != null) {\n+            jp.setSchema(_schema);\n+        }\n+        try {\n+            return _bindAsTree(jp);\n+        } finally {\n+            try {\n+                jp.close();\n+            } catch (IOException ioe) { }\n+        }\n+    }\n+    \n+    protected static JsonToken _initForReading(JsonParser jp)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        /* First: must point to a token; if not pointing to one, advance.\n+         * This occurs before first read from JsonParser, as well as\n+         * after clearing of current token.\n+         */\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == null) { // and then we must get something...\n+            t = jp.nextToken();\n+            if (t == null) { // [JACKSON-99] Should throw EOFException?\n+                throw new EOFException(\"No content to map to Object due to end of input\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    /**\n+     * Method called to locate deserializer for the passed root-level value.\n+     */\n+    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationConfig cfg, JavaType valueType)\n+        throws JsonMappingException\n+    {\n+        // Sanity check: must have actual type...\n+        if (valueType == null) {\n+            throw new JsonMappingException(\"No value type configured for ObjectReader\");\n+        }\n+        \n+        // First: have we already seen it?\n+        JsonDeserializer<Object> deser = _rootDeserializers.get(valueType);\n+        if (deser != null) {\n+            return deser;\n+        }\n+\n+        // Nope: need to ask provider to resolve it\n+        deser = _provider.findTypedValueDeserializer(cfg, valueType, null);\n+        if (deser == null) { // can this happen?\n+            throw new JsonMappingException(\"Can not find a deserializer for type \"+valueType);\n+        }\n+        _rootDeserializers.put(valueType, deser);\n+        return deser;\n+    }\n+    \n+    protected DeserializationContext _createDeserializationContext(JsonParser jp, DeserializationConfig cfg) {\n+        // 04-Jan-2010, tatu: we do actually need the provider too... (for polymorphic deser)\n+        return new StdDeserializationContext(cfg, jp, _provider, _injectableValues);\n+    }\n+\n+    protected Object _unwrapAndDeserialize(JsonParser jp, DeserializationContext ctxt,\n+            JavaType rootType, JsonDeserializer<Object> deser)\n+        throws IOException, JsonParseException, JsonMappingException\n+    {\n+        SerializedString rootName = _provider.findExpectedRootName(ctxt.getConfig(), rootType);\n+        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n+            throw JsonMappingException.from(jp, \"Current token not START_OBJECT (needed to unwrap root name '\"\n+                    +rootName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n+            throw JsonMappingException.from(jp, \"Current token not FIELD_NAME (to contain expected root name '\"\n+                    +rootName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        String actualName = jp.getCurrentName();\n+        if (!rootName.getValue().equals(actualName)) {\n+            throw JsonMappingException.from(jp, \"Root name '\"+actualName+\"' does not match expected ('\"+rootName\n+                    +\"') for type \"+rootType);\n+        }\n+        // ok, then move to value itself....\n+        jp.nextToken();\n+        Object result;\n+        if (_valueToUpdate == null) {\n+            result = deser.deserialize(jp, ctxt);\n+        } else {\n+            deser.deserialize(jp, ctxt, _valueToUpdate);\n+            result = _valueToUpdate;                    \n+        }\n+        // and last, verify that we now get matching END_OBJECT\n+        if (jp.nextToken() != JsonToken.END_OBJECT) {\n+            throw JsonMappingException.from(jp, \"Current token not END_OBJECT (to match wrapper object with root name '\"\n+                    +rootName+\"'), but \"+jp.getCurrentToken());\n+        }\n+        return result;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Implementation of rest of ObjectCodec methods\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonNode createArrayNode() {\n+        return _config.getNodeFactory().arrayNode();\n+    }\n+\n+    @Override\n+    public JsonNode createObjectNode() {\n+        return _config.getNodeFactory().objectNode();\n+    }\n+\n+    @Override\n+    public JsonParser treeAsTokens(JsonNode n) {\n+        return new TreeTraversingParser(n, this);\n+    }\n+\n+    @Override\n+    public <T> T treeToValue(JsonNode n, Class<T> valueType)\n+            throws IOException, JsonProcessingException\n+    {\n+        return readValue(treeAsTokens(n), valueType);\n+    }\n+\n+    /**\n+     * NOTE: NOT implemented for {@link ObjectReader}.\n+     */\n+    @Override\n+    public void writeTree(JsonGenerator jgen, JsonNode rootNode) throws IOException, JsonProcessingException\n+    {\n+        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n+    }\n+\n+    @Override\n+    public void writeValue(JsonGenerator jgen, Object value) throws IOException, JsonProcessingException\n+    {\n+        throw new UnsupportedOperationException(\"Not implemented for ObjectReader\");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.*;\n+import java.text.DateFormat;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.SegmentedStringWriter;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n+import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n+import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n+import com.fasterxml.jackson.core.util.VersionUtil;\n+import com.fasterxml.jackson.databind.ser.FilterProvider;\n+\n+\n+/**\n+ * Builder object that can be used for per-serialization configuration of\n+ * serialization parameters, such as JSON View and root type to use.\n+ * (and thus fully thread-safe with no external synchronization);\n+ * new instances are constructed for different configurations.\n+ * Instances are initially constructed by {@link ObjectMapper} and can be\n+ * reused in completely thread-safe manner with no explicit synchronization\n+ * \n+ * @author tatu\n+ * @since 1.5\n+ */\n+public class ObjectWriter\n+    implements Versioned // since 1.6\n+{\n+    /**\n+     * We need to keep track of explicit disabling of pretty printing;\n+     * easiest to do by a token value.\n+     */\n+    protected final static PrettyPrinter NULL_PRETTY_PRINTER = new MinimalPrettyPrinter();\n+    \n+    /*\n+    /**********************************************************\n+    /* Immutable configuration from ObjectMapper\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * General serialization configuration settings\n+     */\n+    protected final SerializationConfig _config;\n+   \n+    protected final SerializerProvider _provider;\n+\n+    protected final SerializerFactory _serializerFactory;\n+\n+    /**\n+     * Factory used for constructing {@link JsonGenerator}s\n+     */\n+    protected final JsonFactory _jsonFactory;\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration that can be changed during building\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Specified root serialization type to use; can be same\n+     * as runtime type, but usually one of its super types\n+     */\n+    protected final JavaType _rootType;\n+\n+    /**\n+     * To allow for dynamic enabling/disabling of pretty printing,\n+     * pretty printer can be optionally configured for writer\n+     * as well\n+     */\n+    protected final PrettyPrinter _prettyPrinter;\n+\n+    /**\n+     * When using data format that uses a schema, schema is passed\n+     * to generator.\n+     * \n+     * @since 1.8\n+     */\n+    protected final FormatSchema _schema;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used by {@link ObjectMapper} for initial instantiation\n+     */\n+    protected ObjectWriter(ObjectMapper mapper, SerializationConfig config,\n+            JavaType rootType, PrettyPrinter pp)\n+    {\n+        _config = config;\n+\n+        _provider = mapper._serializerProvider;\n+        _serializerFactory = mapper._serializerFactory;\n+        _jsonFactory = mapper._jsonFactory;\n+\n+        _rootType = rootType;\n+        _prettyPrinter = pp;\n+        _schema = null;\n+    }\n+\n+    /**\n+     * Alternative constructor for initial instantiation.\n+     * \n+     * @since 1.7\n+     */\n+    protected ObjectWriter(ObjectMapper mapper, SerializationConfig config)\n+    {\n+        _config = config;\n+\n+        _provider = mapper._serializerProvider;\n+        _serializerFactory = mapper._serializerFactory;\n+        _jsonFactory = mapper._jsonFactory;\n+\n+        _rootType = null;\n+        _prettyPrinter = null;\n+        _schema = null;\n+    }\n+\n+    /**\n+     * Alternative constructor for initial instantiation.\n+     * \n+     * @since 1.7\n+     */\n+    protected ObjectWriter(ObjectMapper mapper, SerializationConfig config,\n+            FormatSchema s)\n+    {\n+        _config = config;\n+\n+        _provider = mapper._serializerProvider;\n+        _serializerFactory = mapper._serializerFactory;\n+        _jsonFactory = mapper._jsonFactory;\n+\n+        _rootType = null;\n+        _prettyPrinter = null;\n+        _schema = s;\n+    }\n+    \n+    /**\n+     * Copy constructor used for building variations.\n+     */\n+    protected ObjectWriter(ObjectWriter base, SerializationConfig config,\n+            JavaType rootType, PrettyPrinter pp, FormatSchema s)\n+    {\n+        _config = config;\n+\n+        _provider = base._provider;\n+        _serializerFactory = base._serializerFactory;\n+        _jsonFactory = base._jsonFactory;\n+        \n+        _rootType = rootType;\n+        _prettyPrinter = pp;\n+        _schema = s;\n+    }\n+\n+    /**\n+     * Copy constructor used for building variations.\n+     * \n+     * @since 1.7\n+     */\n+    protected ObjectWriter(ObjectWriter base, SerializationConfig config)\n+    {\n+        _config = config;\n+\n+        _provider = base._provider;\n+        _serializerFactory = base._serializerFactory;\n+        _jsonFactory = base._jsonFactory;\n+        _schema = base._schema;\n+        \n+        _rootType = base._rootType;\n+        _prettyPrinter = base._prettyPrinter;\n+    }\n+    \n+    /**\n+     * Method that will return version information stored in and read from jar\n+     * that contains this class.\n+     * \n+     * @since 1.6\n+     */\n+    @Override\n+    public Version version() {\n+        return VersionUtil.versionFor(getClass());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, fluent factories\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that will construct a new instance that uses specified\n+     * serialization view for serialization (with null basically disables\n+     * view processing)\n+     */\n+    public ObjectWriter withView(Class<?> view)\n+    {\n+        if (view == _config.getSerializationView()) return this;\n+        return new ObjectWriter(this, _config.withView(view));\n+    }    \n+    \n+    /**\n+     * Method that will construct a new instance that uses specific type\n+     * as the root type for serialization, instead of runtime dynamic\n+     * type of the root object itself.\n+     */\n+    public ObjectWriter withType(JavaType rootType)\n+    {\n+        if (rootType == _rootType) return this;\n+        // type is stored here, no need to make a copy of config\n+        return new ObjectWriter(this, _config, rootType, _prettyPrinter, _schema);\n+    }    \n+\n+    /**\n+     * Method that will construct a new instance that uses specific type\n+     * as the root type for serialization, instead of runtime dynamic\n+     * type of the root object itself.\n+     */\n+    public ObjectWriter withType(Class<?> rootType)\n+    {\n+        return withType(_config.constructType(rootType));\n+    }\n+\n+    /**\n+     * @since 1.7\n+     */\n+    public ObjectWriter withType(TypeReference<?> rootType)\n+    {\n+        return withType(_config.getTypeFactory().constructType(rootType.getType()));\n+    }\n+    \n+    /**\n+     * Method that will construct a new instance that will use specified pretty\n+     * printer (or, if null, will not do any pretty-printing)\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectWriter withPrettyPrinter(PrettyPrinter pp)\n+    {\n+        if (pp == _prettyPrinter) {\n+            return this;\n+        }\n+        // since null would mean \"don't care\", need to use placeholder to indicate \"disable\"\n+        if (pp == null) {\n+            pp = NULL_PRETTY_PRINTER;\n+        }\n+        return new ObjectWriter(this, _config, _rootType, pp, _schema);\n+    }\n+\n+    /**\n+     * Method that will construct a new instance that will use the default\n+     * pretty printer for serialization.\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectWriter withDefaultPrettyPrinter()\n+    {\n+        return withPrettyPrinter(new DefaultPrettyPrinter());\n+    }\n+\n+    /**\n+     * Method that will construct a new instance that uses specified\n+     * provider for resolving filter instances by id.\n+     * \n+     * @since 1.7\n+     */\n+    public ObjectWriter withFilters(FilterProvider filterProvider)\n+    {\n+        if (filterProvider == _config.getFilterProvider()) { // no change?\n+            return this;\n+        }\n+        return new ObjectWriter(this, _config.withFilters(filterProvider));\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    public ObjectWriter withSchema(FormatSchema schema)\n+    {\n+        if (_schema == schema) {\n+            return this;\n+        }\n+        return new ObjectWriter(this, _config, _rootType, _prettyPrinter, schema);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct a new writer instance that will\n+     * use specified date format for serializing dates; or if null passed, one\n+     * that will serialize dates as numeric timestamps.\n+     * \n+     * @since 1.9\n+     */\n+    public ObjectWriter withDateFormat(DateFormat df)\n+    {\n+        SerializationConfig newConfig = _config.withDateFormat(df);\n+        if (newConfig == _config) {\n+            return this;\n+        }\n+        return new ObjectWriter(this, newConfig);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Serialization methods; ones from ObjectCodec first\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to serialize any Java value as\n+     * JSON output, using provided {@link JsonGenerator}.\n+     */\n+    public void writeValue(JsonGenerator jgen, Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        if (_config.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+            _writeCloseableValue(jgen, value, _config);\n+        } else {\n+            if (_rootType == null) {\n+                _provider.serializeValue(_config, jgen, value, _serializerFactory);\n+            } else {\n+                _provider.serializeValue(_config, jgen, value, _rootType, _serializerFactory);\n+            }\n+            if (_config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+                jgen.flush();\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization methods, others\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to serialize any Java value as\n+     * JSON output, written to File provided.\n+     */\n+    public void writeValue(File resultFile, Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        _configAndWriteValue(_jsonFactory.createJsonGenerator(resultFile, JsonEncoding.UTF8), value);\n+    }\n+\n+    /**\n+     * Method that can be used to serialize any Java value as\n+     * JSON output, using output stream provided (using encoding\n+     * {@link JsonEncoding#UTF8}).\n+     *<p>\n+     * Note: method does not close the underlying stream explicitly\n+     * here; however, {@link JsonFactory} this mapper uses may choose\n+     * to close the stream depending on its settings (by default,\n+     * it will try to close it when {@link JsonGenerator} we construct\n+     * is closed).\n+     */\n+    public void writeValue(OutputStream out, Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        _configAndWriteValue(_jsonFactory.createJsonGenerator(out, JsonEncoding.UTF8), value);\n+    }\n+\n+    /**\n+     * Method that can be used to serialize any Java value as\n+     * JSON output, using Writer provided.\n+     *<p>\n+     * Note: method does not close the underlying stream explicitly\n+     * here; however, {@link JsonFactory} this mapper uses may choose\n+     * to close the stream depending on its settings (by default,\n+     * it will try to close it when {@link JsonGenerator} we construct\n+     * is closed).\n+     */\n+    public void writeValue(Writer w, Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        _configAndWriteValue(_jsonFactory.createJsonGenerator(w), value);\n+    }\n+\n+    /**\n+     * Method that can be used to serialize any Java value as\n+     * a String. Functionally equivalent to calling\n+     * {@link #writeValue(Writer,Object)} with {@link java.io.StringWriter}\n+     * and constructing String, but more efficient.\n+     */\n+    public String writeValueAsString(Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {        \n+        // alas, we have to pull the recycler directly here...\n+        SegmentedStringWriter sw = new SegmentedStringWriter(_jsonFactory._getBufferRecycler());\n+        _configAndWriteValue(_jsonFactory.createJsonGenerator(sw), value);\n+        return sw.getAndClear();\n+    }\n+    \n+    /**\n+     * Method that can be used to serialize any Java value as\n+     * a byte array. Functionally equivalent to calling\n+     * {@link #writeValue(Writer,Object)} with {@link java.io.ByteArrayOutputStream}\n+     * and getting bytes, but more efficient.\n+     * Encoding used will be UTF-8.\n+     */\n+    public byte[] writeValueAsBytes(Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {        \n+        ByteArrayBuilder bb = new ByteArrayBuilder(_jsonFactory._getBufferRecycler());\n+        _configAndWriteValue(_jsonFactory.createJsonGenerator(bb, JsonEncoding.UTF8), value);\n+        byte[] result = bb.toByteArray();\n+        bb.release();\n+        return result;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Other public methods\n+    /**********************************************************\n+     */\n+\n+    public boolean canSerialize(Class<?> type)\n+    {\n+        return _provider.hasSerializerFor(_config, type, _serializerFactory);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called to configure the generator as necessary and then\n+     * call write functionality\n+     */\n+    protected final void _configAndWriteValue(JsonGenerator jgen, Object value)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        if (_prettyPrinter != null) {\n+            PrettyPrinter pp = _prettyPrinter;\n+            jgen.setPrettyPrinter((pp == NULL_PRETTY_PRINTER) ? null : pp);\n+        } else if (_config.isEnabled(SerializationConfig.Feature.INDENT_OUTPUT)) {\n+            jgen.useDefaultPrettyPrinter();\n+        }\n+        // [JACKSON-520]: add support for pass-through schema:\n+        if (_schema != null) {\n+            jgen.setSchema(_schema);\n+        }\n+        // [JACKSON-282]: consider Closeable\n+        if (_config.isEnabled(SerializationConfig.Feature.CLOSE_CLOSEABLE) && (value instanceof Closeable)) {\n+            _configAndWriteCloseable(jgen, value, _config);\n+            return;\n+        }\n+        boolean closed = false;\n+        try {\n+            if (_rootType == null) {\n+                _provider.serializeValue(_config, jgen, value, _serializerFactory);\n+            } else {\n+                _provider.serializeValue(_config, jgen, value, _rootType, _serializerFactory);                \n+            }\n+            closed = true;\n+            jgen.close();\n+        } finally {\n+            /* won't try to close twice; also, must catch exception (so it \n+             * will not mask exception that is pending)\n+             */\n+            if (!closed) {\n+                try {\n+                    jgen.close();\n+                } catch (IOException ioe) { }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n+     * method is to be called right after serialization has been called\n+     */\n+    private final void _configAndWriteCloseable(JsonGenerator jgen, Object value, SerializationConfig cfg)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        Closeable toClose = (Closeable) value;\n+        try {\n+            if (_rootType == null) {\n+                _provider.serializeValue(cfg, jgen, value, _serializerFactory);\n+            } else {\n+                _provider.serializeValue(cfg, jgen, value, _rootType, _serializerFactory);\n+            }\n+            // [JACKSON-520]: add support for pass-through schema:\n+            if (_schema != null) {\n+                jgen.setSchema(_schema);\n+            }\n+            JsonGenerator tmpJgen = jgen;\n+            jgen = null;\n+            tmpJgen.close();\n+            Closeable tmpToClose = toClose;\n+            toClose = null;\n+            tmpToClose.close();\n+        } finally {\n+            /* Need to close both generator and value, as long as they haven't yet\n+             * been closed\n+             */\n+            if (jgen != null) {\n+                try {\n+                    jgen.close();\n+                } catch (IOException ioe) { }\n+            }\n+            if (toClose != null) {\n+                try {\n+                    toClose.close();\n+                } catch (IOException ioe) { }\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Helper method used when value to serialize is {@link Closeable} and its <code>close()</code>\n+     * method is to be called right after serialization has been called\n+     */\n+    private final void _writeCloseableValue(JsonGenerator jgen, Object value, SerializationConfig cfg)\n+        throws IOException, JsonGenerationException, JsonMappingException\n+    {\n+        Closeable toClose = (Closeable) value;\n+        try {\n+            if (_rootType == null) {\n+                _provider.serializeValue(cfg, jgen, value, _serializerFactory);\n+            } else {\n+                _provider.serializeValue(cfg, jgen, value, _rootType, _serializerFactory);\n+            }\n+            if (_config.isEnabled(SerializationConfig.Feature.FLUSH_AFTER_WRITE_VALUE)) {\n+                jgen.flush();\n+            }\n+            Closeable tmpToClose = toClose;\n+            toClose = null;\n+            tmpToClose.close();\n+        } finally {\n+            if (toClose != null) {\n+                try {\n+                    toClose.close();\n+                } catch (IOException ioe) { }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/PropertyNamingStrategy.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n+\n+/**\n+ * Class that defines how names of JSON properties (\"external names\")\n+ * are derived from names of POJO methods and fields (\"internal names\"),\n+ * in cases where they are not\n+ * auto-detected and no explicit annotations exist for naming.\n+ * Methods are passed information about POJO member for which name is needed,\n+ * as well as default name that would be used if no custom strategy was used.\n+ *<p>\n+ * Default implementation returns suggested (\"default\") name unmodified.\n+ *<p>\n+ * Note that the strategy is guaranteed to be called once per logical property\n+ * (which may be represented by multiple members; such as pair of a getter and\n+ * a setter), but may be called for each: implementations should not count on\n+ * exact number of times, and should work for any member that represent a\n+ * property.\n+ *<p>\n+ * In absence of a registered custom strategy, default Java property naming strategy\n+ * is used, which leaves field names as is, and removes set/get/is prefix\n+ * from methods (as well as lower-cases initial sequence of capitalized\n+ * characters).\n+ * \n+ * @since 1.8\n+ */\n+public abstract class PropertyNamingStrategy\n+{\n+    /*\n+    /**********************************************************\n+    /* API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to find external name (name used in JSON) for given logical\n+     * POJO property,\n+     * as defined by given field.\n+     * \n+     * @param config Configuration in used: either <code>SerializationConfig</code>\n+     *   or <code>DeserializationConfig</code>, depending on whether method is called\n+     *   during serialization or deserialization\n+     * @param field Field used to access property\n+     * @param defaultName Default name that would be used for property in absence of custom strategy\n+     * \n+     * @return Logical name to use for property that the field represents\n+     */\n+    public String nameForField(MapperConfig<?> config, AnnotatedField field,\n+            String defaultName)\n+    {\n+        return defaultName;\n+    }\n+\n+    /**\n+     * Method called to find external name (name used in JSON) for given logical\n+     * POJO property,\n+     * as defined by given getter method; typically called when building a serializer.\n+     * (but not always -- when using \"getter-as-setter\", may be called during\n+     * deserialization)\n+     * \n+     * @param config Configuration in used: either <code>SerializationConfig</code>\n+     *   or <code>DeserializationConfig</code>, depending on whether method is called\n+     *   during serialization or deserialization\n+     * @param method Method used to access property.\n+     * @param defaultName Default name that would be used for property in absence of custom strategy\n+     * \n+     * @return Logical name to use for property that the method represents\n+     */\n+    public String nameForGetterMethod(MapperConfig<?> config, AnnotatedMethod method,\n+            String defaultName)\n+    {\n+        return defaultName;\n+    }\n+\n+    /**\n+     * Method called to find external name (name used in JSON) for given logical\n+     * POJO property,\n+     * as defined by given setter method; typically called when building a deserializer\n+     * (but not necessarily only then).\n+     * \n+     * @param config Configuration in used: either <code>SerializationConfig</code>\n+     *   or <code>DeserializationConfig</code>, depending on whether method is called\n+     *   during serialization or deserialization\n+     * @param method Method used to access property.\n+     * @param defaultName Default name that would be used for property in absence of custom strategy\n+     * \n+     * @return Logical name to use for property that the method represents\n+     */\n+    public String nameForSetterMethod(MapperConfig<?> config, AnnotatedMethod method,\n+            String defaultName)\n+    {\n+        return defaultName;\n+    }\n+\n+    /**\n+     * Method called to find external name (name used in JSON) for given logical\n+     * POJO property,\n+     * as defined by given constructor parameter; typically called when building a deserializer\n+     * (but not necessarily only then).\n+     * \n+     * @param config Configuration in used: either <code>SerializationConfig</code>\n+     *   or <code>DeserializationConfig</code>, depending on whether method is called\n+     *   during serialization or deserialization\n+     * @param ctorParam Constructor parameter used to pass property.\n+     * @param defaultName Default name that would be used for property in absence of custom strategy\n+     * @since 1.9\n+     */\n+    public String nameForConstructorParameter(MapperConfig<?> config, AnnotatedParameter ctorParam,\n+            String defaultName)\n+    {\n+        return defaultName;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard implementations \n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    public static abstract class PropertyNamingStrategyBase extends PropertyNamingStrategy\n+    {\n+        @Override\n+        public String nameForField(MapperConfig<?> config, AnnotatedField field, String defaultName)\n+        {\n+            return translate(defaultName);\n+        }\n+\n+        @Override\n+        public String nameForGetterMethod(MapperConfig<?> config, AnnotatedMethod method, String defaultName)\n+        {\n+            return translate(defaultName);\n+        }\n+\n+        @Override\n+        public String nameForSetterMethod(MapperConfig<?> config, AnnotatedMethod method, String defaultName)\n+        {\n+            return translate(defaultName);\n+        }\n+\n+        @Override\n+        public String nameForConstructorParameter(MapperConfig<?> config, AnnotatedParameter ctorParam,\n+                String defaultName)\n+        {\n+            return translate(defaultName);\n+        }\n+        \n+        public abstract String translate(String propertyName);\n+    }\n+        \n+    \n+    /*\n+    /**********************************************************\n+    /* Standard implementations \n+    /**********************************************************\n+     */\n+\n+    /**\n+     * See {@link LowerCaseWithUnderscoresStrategy} for details.\n+     * \n+     * @since 1.9\n+     */\n+    public static final PropertyNamingStrategy CAMEL_CASE_TO_LOWER_CASE_WITH_UNDERSCORES =\n+        new LowerCaseWithUnderscoresStrategy();\n+    \n+    /**\n+     * A {@link PropertyNamingStrategy} that translates typical camel case Java \n+     * property names to lower case JSON element names, separated by \n+     * underscores.  This implementation is somewhat lenient, in that it \n+     * provides some additional translations beyond strictly translating from \n+     * camel case only.  In particular, the following translations are applied \n+     * by this PropertyNamingStrategy.\n+     * \n+     * <ul><li>Every upper case letter in the Java property name is translated \n+     * into two characters, an underscore and the lower case equivalent of the \n+     * target character, with three exceptions.\n+     * <ol><li>For contiguous sequences of upper case letters, characters after\n+     * the first character are replaced only by their lower case equivalent, \n+     * and are not preceded by an underscore.\n+     * <ul><li>This provides for reasonable translations of upper case acronyms, \n+     * e.g., &quot;theWWW&quot; is translated to &quot;the_www&quot;.</li></ul></li>\n+     * <li>An upper case character in the first position of the Java property \n+     * name is not preceded by an underscore character, and is translated only \n+     * to its lower case equivalent.\n+     * <ul><li>For example, &quot;Results&quot; is translated to &quot;results&quot;, \n+     * and not to &quot;_results&quot;.</li></ul></li>\n+     * <li>An upper case character in the Java property name that is already \n+     * preceded by an underscore character is translated only to its lower case \n+     * equivalent, and is not preceded by an additional underscore.\n+     * <ul><li>For example, &quot;user_Name&quot; is translated to \n+     * &quot;user_name&quot;, and not to &quot;user__name&quot; (with two \n+     * underscore characters).</li></ul></li></ol></li>\n+     * <li>If the Java property name starts with an underscore, then that \n+     * underscore is not included in the translated name, unless the Java \n+     * property name is just one character in length, i.e., it is the \n+     * underscore character.  This applies only to the first character of the \n+     * Java property name.</li></ul>\n+     * \n+     * These rules result in the following additional example translations from \n+     * Java property names to JSON element names.\n+     * <ul><li>&quot;userName&quot; is translated to &quot;user_name&quot;</li>\n+     * <li>&quot;UserName&quot; is translated to &quot;user_name&quot;</li>\n+     * <li>&quot;USER_NAME&quot; is translated to &quot;user_name&quot;</li>\n+     * <li>&quot;user_name&quot; is translated to &quot;user_name&quot; (unchanged)</li>\n+     * <li>&quot;user&quot; is translated to &quot;user&quot; (unchanged)</li>\n+     * <li>&quot;User&quot; is translated to &quot;user&quot;</li>\n+     * <li>&quot;USER&quot; is translated to &quot;user&quot;</li>\n+     * <li>&quot;_user&quot; is translated to &quot;user&quot;</li>\n+     * <li>&quot;_User&quot; is translated to &quot;user&quot;</li>\n+     * <li>&quot;__user&quot; is translated to &quot;_user&quot; \n+     * (the first of two underscores was removed)</li>\n+     * <li>&quot;user__name&quot; is translated to &quot;user__name&quot;\n+     * (unchanged, with two underscores)</li></ul>\n+     * \n+     * @since 1.9\n+     */\n+    public static class LowerCaseWithUnderscoresStrategy extends PropertyNamingStrategyBase\n+    {\n+        @Override\n+        public String translate(String input)\n+        {\n+            if (input == null) return input; // garbage in, garbage out\n+            int length = input.length();\n+            StringBuilder result = new StringBuilder(length * 2);\n+            int resultLength = 0;\n+            boolean wasPrevTranslated = false;\n+            for (int i = 0; i < length; i++)\n+            {\n+                char c = input.charAt(i);\n+                if (i > 0 || c != '_') // skip first starting underscore\n+                {\n+                    if (Character.isUpperCase(c))\n+                    {\n+                        if (!wasPrevTranslated && resultLength > 0 && result.charAt(resultLength - 1) != '_')\n+                        {\n+                            result.append('_');\n+                            resultLength++;\n+                        }\n+                        c = Character.toLowerCase(c);\n+                        wasPrevTranslated = true;\n+                    }\n+                    else\n+                    {\n+                        wasPrevTranslated = false;\n+                    }\n+                    result.append(c);\n+                    resultLength++;\n+                }\n+            }\n+            return resultLength > 0 ? result.toString() : input;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ResolvableDeserializer.java\n+package com.fasterxml.jackson.databind;\n+\n+/**\n+ * Interface used to indicate deserializers that want to do post-processing\n+ * after construction and being added to {@link DeserializerProvider},\n+ * but before being used. This is typically used to resolve references\n+ * to other contained types; for example, bean deserializers use this\n+ * to eagerly find deserializers for contained field types.\n+ */\n+public interface ResolvableDeserializer\n+{\n+    /**\n+     * Method called after {@link DeserializerProvider} has registered\n+     * the deserializer, but before it has returned it to the caller.\n+     * Called object can then resolve its dependencies to other types,\n+     * including self-references (direct or indirect).\n+     *\n+     * @param provider Provider that has constructed deserializer this method\n+     *   is called on.\n+     */\n+    public abstract void resolve(DeserializationConfig config, DeserializerProvider provider)\n+        throws JsonMappingException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ResolvableSerializer.java\n+package com.fasterxml.jackson.databind;\n+\n+/**\n+ * Interface used to indicate serializers that want to do post-processing\n+ * after construction and being added to {@link SerializerProvider},\n+ * but before being used. This is typically used to resolve references\n+ * to other contained types; for example, bean serializers use this\n+ * to eagerly find serializers for contained field types.\n+ */\n+public interface ResolvableSerializer\n+{\n+    /**\n+     * Method called after {@link SerializerProvider} has registered\n+     * the serializer, but before it has returned it to the caller.\n+     * Called object can then resolve its dependencies to other types,\n+     * including self-references (direct or indirect).\n+     *\n+     * @param provider Provider that has constructed serializer this method\n+     *   is called on.\n+     */\n+    public abstract void resolve(SerializerProvider provider)\n+        throws JsonMappingException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/RuntimeJsonMappingException.java\n+package com.fasterxml.jackson.databind;\n+\n+/**\n+ * Wrapper used when interface does not allow throwing a checked\n+ * {@link JsonMappingException}\n+ */\n+@SuppressWarnings(\"serial\")\n+public class RuntimeJsonMappingException extends RuntimeException\n+{\n+    public RuntimeJsonMappingException(JsonMappingException cause) {\n+        super(cause);\n+    }\n+\n+    public RuntimeJsonMappingException(String message) {\n+        super(message);\n+    }\n+\n+    public RuntimeJsonMappingException(String message, JsonMappingException cause) {\n+        super(message, cause);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationConfig.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.text.DateFormat;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n+import com.fasterxml.jackson.databind.annotate.JsonSerialize.Inclusion;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.VisibilityChecker;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+\n+/**\n+ * Object that contains baseline configuration for serialization\n+ * process. An instance is owned by {@link ObjectMapper}, which makes\n+ * a copy that is passed during serialization process to\n+ * {@link SerializerProvider} and {@link SerializerFactory}.\n+ *<p>\n+ * Note: although configuration settings can be changed at any time\n+ * (for factories and instances), they are not guaranteed to have\n+ * effect if called after constructing relevant mapper or serializer\n+ * instance. This because some objects may be configured, constructed and\n+ * cached first time they are needed.\n+ *<p>\n+ * As of version 1.9, the goal is to make this class eventually immutable.\n+ * Because of this, existing methods that allow changing state of this\n+ * instance are deprecated in favor of methods that create new instances\n+ * with different configuration (\"fluent factories\")\n+ */\n+public class SerializationConfig\n+    extends MapperConfig.Impl<SerializationConfig.Feature, SerializationConfig>\n+{\n+    /**\n+     * Enumeration that defines togglable features that guide\n+     * the serialization feature.\n+     */\n+    public enum Feature implements MapperConfig.ConfigFeature\n+    {\n+        /*\n+        /******************************************************\n+        /*  Introspection features\n+        /******************************************************\n+         */\n+        \n+        /**\n+         * Feature that determines whether annotation introspection\n+         * is used for configuration; if enabled, configured\n+         * {@link AnnotationIntrospector} will be used: if disabled,\n+         * no annotations are considered.\n+         *<P>\n+         * Feature is enabled by default.\n+         *\n+         * @since 1.2\n+         */\n+        USE_ANNOTATIONS(true),\n+\n+        /**\n+         * Feature that determines whether regualr \"getter\" methods are\n+         * automatically detected based on standard Bean naming convention\n+         * or not. If yes, then all public zero-argument methods that\n+         * start with prefix \"get\" \n+         * are considered as getters.\n+         * If disabled, only methods explicitly  annotated are considered getters.\n+         *<p>\n+         * Note that since version 1.3, this does <b>NOT</b> include\n+         * \"is getters\" (see {@link #AUTO_DETECT_IS_GETTERS} for details)\n+         *<p>\n+         * Note that this feature has lower precedence than per-class\n+         * annotations, and is only used if there isn't more granular\n+         * configuration available.\n+         *<P>\n+         * Feature is enabled by default.\n+         */\n+        AUTO_DETECT_GETTERS(true),\n+\n+        /**\n+         * Feature that determines whether \"is getter\" methods are\n+         * automatically detected based on standard Bean naming convention\n+         * or not. If yes, then all public zero-argument methods that\n+         * start with prefix \"is\", and whose return type is boolean\n+         * are considered as \"is getters\".\n+         * If disabled, only methods explicitly annotated are considered getters.\n+         *<p>\n+         * Note that this feature has lower precedence than per-class\n+         * annotations, and is only used if there isn't more granular\n+         * configuration available.\n+         *<P>\n+         * Feature is enabled by default.\n+         */\n+        AUTO_DETECT_IS_GETTERS(true),\n+\n+        /**\n+         * Feature that determines whether non-static fields are recognized as\n+         * properties.\n+         * If yes, then all public member fields\n+         * are considered as properties. If disabled, only fields explicitly\n+         * annotated are considered property fields.\n+         *<p>\n+         * Note that this feature has lower precedence than per-class\n+         * annotations, and is only used if there isn't more granular\n+         * configuration available.\n+         *<p>\n+         * Feature is enabled by default.\n+         *\n+         * @since 1.1\n+         */\n+         AUTO_DETECT_FIELDS(true),\n+\n+        /**\n+         * Feature that determines whether method and field access\n+         * modifier settings can be overridden when accessing\n+         * properties. If enabled, method\n+         * {@link java.lang.reflect.AccessibleObject#setAccessible}\n+         * may be called to enable access to otherwise unaccessible\n+         * objects.\n+         *<p>\n+         * Feature is enabled by default.\n+         */\n+        CAN_OVERRIDE_ACCESS_MODIFIERS(true),\n+\n+        /**\n+         * Feature that determines whether getters (getter methods)\n+         * can be auto-detected if there is no matching mutator (setter,\n+         * constructor parameter or field) or not: if set to true,\n+         * only getters that match a mutator are auto-discovered; if\n+         * false, all auto-detectable getters can be discovered.\n+         *<p>\n+         * Feature is disabled by default for backwards compatibility\n+         * reasons.\n+         * \n+         * @since 1.9\n+         */\n+        REQUIRE_SETTERS_FOR_GETTERS(false),\n+        \n+        /*\n+        /******************************************************\n+        /* Generic output features\n+        /******************************************************\n+         */\n+\n+        /**\n+         * Feature that determines the default settings of whether Bean\n+         * properties with null values are to be written out.\n+         *<p>\n+         * Feature is enabled by default (null properties written).\n+         *<p>\n+         * Note too that there is annotation\n+         * {@link org.codehaus.jackson.annotate.JsonWriteNullProperties}\n+         * that can be used for more granular control (annotates bean\n+         * classes or individual property access methods).\n+         *\n+         * @deprecated As of 1.1, use {@link SerializationConfig#setSerializationInclusion}\n+         *    instead\n+         */\n+        @Deprecated\n+        WRITE_NULL_PROPERTIES(true),\n+\n+        /**\n+         * Feature that determines whether the type detection for\n+         * serialization should be using actual dynamic runtime type,\n+         * or declared static type.\n+         * Default value is false, to use dynamic runtime type.\n+         *<p>\n+         * This global default value can be overridden at class, method\n+         * or field level by using {@link JsonSerialize#typing} annotation\n+         * property\n+         */\n+        USE_STATIC_TYPING(false),\n+\n+        /**\n+         * Feature that determines whether properties that have no view\n+         * annotations are included in JSON serialization views (see\n+         * {@link org.codehaus.jackson.map.annotate.JsonView} for more\n+         * details on JSON Views).\n+         * If enabled, non-annotated properties will be included;\n+         * when disabled, they will be excluded. So this feature\n+         * changes between \"opt-in\" (feature disabled) and\n+         * \"opt-out\" (feature enabled) modes.\n+         *<p>\n+         * Default value is enabled, meaning that non-annotated\n+         * properties are included in all views if there is no\n+         * {@link org.codehaus.jackson.map.annotate.JsonView} annotation.\n+         * \n+         * @since 1.5\n+         */\n+        DEFAULT_VIEW_INCLUSION(true),\n+        \n+        /**\n+         * Feature that can be enabled to make root value (usually JSON\n+         * Object but can be any type) wrapped within a single property\n+         * JSON object, where key as the \"root name\", as determined by\n+         * annotation introspector (esp. for JAXB that uses\n+         * <code>@XmlRootElement.name</code>) or fallback (non-qualified\n+         * class name).\n+         * Feature is mostly intended for JAXB compatibility.\n+         *<p>\n+         * Default setting is false, meaning root value is not wrapped.\n+         *\n+         * @since 1.7\n+         */\n+        WRAP_ROOT_VALUE(false),\n+\n+        /**\n+         * Feature that allows enabling (or disabling) indentation\n+         * for the underlying generator, using the default pretty\n+         * printer (see\n+         * {@link org.codehaus.jackson.JsonGenerator#useDefaultPrettyPrinter}\n+         * for details).\n+         *<p>\n+         * Note that this only affects cases where\n+         * {@link org.codehaus.jackson.JsonGenerator}\n+         * is constructed implicitly by ObjectMapper: if explicit\n+         * generator is passed, its configuration is not changed.\n+         *<p>\n+         * Also note that if you want to configure details of indentation,\n+         * you need to directly configure the generator: there is a\n+         * method to use any <code>PrettyPrinter</code> instance.\n+         * This feature will only allow using the default implementation.\n+         */\n+        INDENT_OUTPUT(false),\n+\n+        /**\n+         * Feature that defines default property serialization order used\n+         * for POJO fields (note: does <b>not</b> apply to {@link java.util.Map}\n+         * serialization!):\n+         * if enabled, default ordering is alphabetic (similar to\n+         * how {@link org.codehaus.jackson.annotate.JsonPropertyOrder#alphabetic()}\n+         * works); if disabled, order is unspecified (based on what JDK gives\n+         * us, which may be declaration order, but not guaranteed).\n+         *<p>\n+         * Note that this is just the default behavior, and can be overridden by\n+         * explicit overrides in classes.\n+         *\n+         * @since 1.8\n+         */\n+        SORT_PROPERTIES_ALPHABETICALLY(false),\n+        \n+        /*\n+        /******************************************************\n+        /*  Error handling features\n+        /******************************************************\n+         */\n+        \n+        /**\n+         * Feature that determines what happens when no accessors are\n+         * found for a type (and there are no annotations to indicate\n+         * it is meant to be serialized). If enabled (default), an\n+         * exception is thrown to indicate these as non-serializable\n+         * types; if disabled, they are serialized as empty Objects,\n+         * i.e. without any properties.\n+         *<p>\n+         * Note that empty types that this feature has only effect on\n+         * those \"empty\" beans that do not have any recognized annotations\n+         * (like <code>@JsonSerialize</code>): ones that do have annotations\n+         * do not result in an exception being thrown.\n+         *\n+         * @since 1.4\n+         */\n+        FAIL_ON_EMPTY_BEANS(true),\n+\n+        /**\n+         * Feature that determines whether Jackson code should catch\n+         * and wrap {@link Exception}s (but never {@link Error}s!)\n+         * to add additional information about\n+         * location (within input) of problem or not. If enabled,\n+         * most exceptions will be caught and re-thrown (exception\n+         * specifically being that {@link java.io.IOException}s may be passed\n+         * as is, since they are declared as throwable); this can be\n+         * convenient both in that all exceptions will be checked and\n+         * declared, and so there is more contextual information.\n+         * However, sometimes calling application may just want \"raw\"\n+         * unchecked exceptions passed as is.\n+         *<p>\n+         * Feature is enabled by default, and is similar in behavior\n+         * to default prior to 1.7.\n+         * \n+         * @since 1.7\n+         */\n+        WRAP_EXCEPTIONS(true),\n+\n+        /*\n+        /******************************************************\n+        /* Output life cycle features\n+        /******************************************************\n+         */\n+        \n+         /**\n+          * Feature that determines whether <code>close</code> method of\n+          * serialized <b>root level</b> objects (ones for which <code>ObjectMapper</code>'s\n+          * writeValue() (or equivalent) method is called)\n+          * that implement {@link java.io.Closeable} \n+          * is called after serialization or not. If enabled, <b>close()</b> will\n+          * be called after serialization completes (whether succesfully, or\n+          * due to an error manifested by an exception being thrown). You can\n+          * think of this as sort of \"finally\" processing.\n+          *<p>\n+          * NOTE: only affects behavior with <b>root</b> objects, and not other\n+          * objects reachable from the root object. Put another way, only one\n+          * call will be made for each 'writeValue' call.\n+          * \n+          * @since 1.6 (see [JACKSON-282 for details])\n+          */\n+        CLOSE_CLOSEABLE(false),\n+\n+        /**\n+         * Feature that determines whether <code>JsonGenerator.flush()</code> is\n+         * called after <code>writeValue()</code> method <b>that takes JsonGenerator\n+         * as an argument</b> completes (i.e. does NOT affect methods\n+         * that use other destinations); same for methods in {@link ObjectWriter}.\n+         * This usually makes sense; but there are cases where flushing\n+         * should not be forced: for example when underlying stream is\n+         * compressing and flush() causes compression state to be flushed\n+         * (which occurs with some compression codecs).\n+          * \n+          * @since 1.6 (see [JACKSON-401 for details])\n+         */\n+        FLUSH_AFTER_WRITE_VALUE(true),\n+         \n+        /*\n+        /******************************************************\n+        /* Data type - specific serialization configuration\n+        /******************************************************\n+         */\n+\n+        /**\n+         * Feature that determines whether {@link java.util.Date} values\n+         * (and Date-based things like {@link java.util.Calendar}s) are to be\n+         * serialized as numeric timestamps (true; the default),\n+         * or as something else (usually textual representation).\n+         * If textual representation is used, the actual format is\n+         * one returned by a call to {@link #getDateFormat}.\n+         *<p>\n+         * Note: whether this feature affects handling of other date-related\n+         * types depend on handlers of those types, although ideally they\n+         * should use this feature\n+         *<p>\n+         * Note: whether {@link java.util.Map} keys are serialized as Strings\n+         * or not is controlled using {@link #WRITE_DATE_KEYS_AS_TIMESTAMPS}.\n+         */\n+        WRITE_DATES_AS_TIMESTAMPS(true),\n+\n+        /**\n+         * Feature that determines whether {@link java.util.Date}s\n+         * (and sub-types) used as {@link java.util.Map} keys are serialized\n+         * as timestamps or not (if not, will be serialized as textual\n+         * values).\n+         *<p>\n+         * Default value is 'false', meaning that Date-valued Map keys are serialized\n+         * as textual (ISO-8601) values.\n+         * \n+         * @since 1.9\n+         */\n+        WRITE_DATE_KEYS_AS_TIMESTAMPS(false),\n+\n+        /**\n+         * Feature that determines how type <code>char[]</code> is serialized:\n+         * when enabled, will be serialized as an explict JSON array (with\n+         * single-character Strings as values); when disabled, defaults to\n+         * serializing them as Strings (which is more compact).\n+         * \n+         * @since 1.6 (see [JACKSON-289 for details])\n+         */\n+        WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS(false),\n+\n+        /**\n+         * Feature that determines standard serialization mechanism used for\n+         * Enum values: if enabled, return value of <code>Enum.toString()</code>\n+         * is used; if disabled, return value of <code>Enum.name()</code> is used.\n+         * Since pre-1.6 method was to use Enum name, this is the default.\n+         *<p>\n+         * Note: this feature should usually have same value\n+         * as {@link DeserializationConfig.Feature#READ_ENUMS_USING_TO_STRING}.\n+         *<p>\n+         * For further details, check out [JACKSON-212]\n+         * \n+         * @since 1.6\n+         */\n+        WRITE_ENUMS_USING_TO_STRING(false),\n+\n+        /**\n+         * Feature that determines whethere Java Enum values are serialized\n+         * as numbers (true), or textual values (false). If textual values are\n+         * used, other settings are also considered.\n+         * If this feature is enabled,\n+         *  return value of <code>Enum.ordinal()</code>\n+         * (an integer) will be used as the serialization.\n+         *<p>\n+         * Note that this feature has precedence over {@link #WRITE_ENUMS_USING_TO_STRING},\n+         * which is only considered if this feature is set to false.\n+         * \n+         * @since 1.9\n+         */\n+        WRITE_ENUMS_USING_INDEX(false),\n+        \n+        /**\n+         * Feature that determines whether Map entries with null values are\n+         * to be serialized (true) or not (false).\n+         *<p>\n+         * For further details, check out [JACKSON-314]\n+         * \n+         * @since 1.6\n+         */\n+        WRITE_NULL_MAP_VALUES(true),\n+\n+        /**\n+         * Feature that determines whether Container properties (POJO properties\n+         * with declared value of Collection or array; i.e. things that produce JSON\n+         * arrays) that are empty (have no elements)\n+         * will be serialized as empty JSON arrays (true), or suppressed from output (false).\n+         *<p>\n+         * Note that this does not change behavior of {@link java.util.Map}s, or\n+         * \"Collection-like\" types.\n+         * \n+         * @since 1.9\n+         */\n+        WRITE_EMPTY_JSON_ARRAYS(true)\n+        \n+            ;\n+\n+        final boolean _defaultState;\n+        \n+        private Feature(boolean defaultState) {\n+            _defaultState = defaultState;\n+        }\n+\n+        @Override\n+        public boolean enabledByDefault() { return _defaultState; }\n+    \n+        @Override\n+        public int getMask() { return (1 << ordinal()); }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Which Bean/Map properties are to be included in serialization?\n+     * Default settings is to include all regardless of value; can be\n+     * changed to only include non-null properties, or properties\n+     * with non-default values.\n+     *<p>\n+     * Defaults to null for backwards compatibility; if left as null,\n+     * will check\n+     * deprecated {@link Feature#WRITE_NULL_PROPERTIES}\n+     * to choose between {@link Inclusion#ALWAYS}\n+     * and {@link Inclusion#NON_NULL}.\n+     */\n+    protected JsonSerialize.Inclusion _serializationInclusion = null;\n+\n+    /**\n+     * View to use for filtering out properties to serialize.\n+     * Null if none (will also be assigned null if <code>Object.class</code>\n+     * is defined), meaning that all properties are to be included.\n+     */\n+    protected Class<?> _serializationView;\n+    \n+    /**\n+     * Object used for resolving filter ids to filter instances.\n+     * Non-null if explicitly defined; null by default.\n+     * \n+     * @since 1.7\n+     */\n+    protected FilterProvider _filterProvider;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used by ObjectMapper to create default configuration object instance.\n+     */\n+    public SerializationConfig(ClassIntrospector<? extends BeanDescription> intr,\n+            AnnotationIntrospector annIntr, VisibilityChecker<?> vc,\n+            SubtypeResolver subtypeResolver, PropertyNamingStrategy propertyNamingStrategy,\n+            TypeFactory typeFactory, HandlerInstantiator handlerInstantiator)\n+    {\n+        super(intr, annIntr, vc, subtypeResolver, propertyNamingStrategy, typeFactory, handlerInstantiator,\n+                collectFeatureDefaults(SerializationConfig.Feature.class));\n+        _filterProvider = null;\n+    }\n+    \n+    /**\n+     * @since 1.8\n+     */\n+    protected SerializationConfig(SerializationConfig src) {\n+        this(src, src._base);\n+    }\n+\n+    /**\n+     * Constructor used to make a private copy of specific mix-in definitions.\n+     * \n+     * @since 1.8\n+     */\n+    protected SerializationConfig(SerializationConfig src,\n+            HashMap<ClassKey,Class<?>> mixins, SubtypeResolver str)\n+    {\n+        this(src, src._base);\n+        _mixInAnnotations = mixins;\n+        _subtypeResolver = str;\n+    }\n+    \n+    /**\n+     * @since 1.8\n+     */\n+    protected SerializationConfig(SerializationConfig src, MapperConfig.Base base)\n+    {\n+        super(src, base, src._subtypeResolver);\n+        _serializationInclusion = src._serializationInclusion;\n+        _serializationView = src._serializationView;\n+        _filterProvider = src._filterProvider;\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    protected SerializationConfig(SerializationConfig src, FilterProvider filters)\n+    {\n+        super(src);\n+        _serializationInclusion = src._serializationInclusion;\n+        _serializationView = src._serializationView;\n+        _filterProvider = filters;\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    protected SerializationConfig(SerializationConfig src, Class<?> view)\n+    {\n+        super(src);\n+        _serializationInclusion = src._serializationInclusion;\n+        _serializationView = view;\n+        _filterProvider = src._filterProvider;\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    protected SerializationConfig(SerializationConfig src, JsonSerialize.Inclusion incl)\n+    {\n+        super(src);\n+        _serializationInclusion = incl;\n+        // And for some level of backwards compatibility, also...\n+        if (incl == JsonSerialize.Inclusion.NON_NULL) {\n+            _featureFlags &= ~Feature.WRITE_NULL_PROPERTIES.getMask();\n+        } else {\n+            _featureFlags |= Feature.WRITE_NULL_PROPERTIES.getMask();\n+        }\n+        _serializationView = src._serializationView;\n+        _filterProvider = src._filterProvider;\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    protected SerializationConfig(SerializationConfig src, int features)\n+    {\n+        super(src, features);\n+        _serializationInclusion = src._serializationInclusion;\n+        _serializationView = src._serializationView;\n+        _filterProvider = src._filterProvider;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, factory methods from MapperConfig\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public SerializationConfig withClassIntrospector(ClassIntrospector<? extends BeanDescription> ci) {\n+        return new SerializationConfig(this, _base.withClassIntrospector(ci));\n+    }\n+\n+    @Override\n+    public SerializationConfig withAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return new SerializationConfig(this, _base.withAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public SerializationConfig withInsertedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return new SerializationConfig(this, _base.withInsertedAnnotationIntrospector(ai));\n+    }\n+\n+    @Override\n+    public SerializationConfig withAppendedAnnotationIntrospector(AnnotationIntrospector ai) {\n+        return new SerializationConfig(this, _base.withAppendedAnnotationIntrospector(ai));\n+    }\n+    \n+    @Override\n+    public SerializationConfig withVisibilityChecker(VisibilityChecker<?> vc) {\n+        return new SerializationConfig(this, _base.withVisibilityChecker(vc));\n+    }\n+\n+    @Override\n+    public SerializationConfig withVisibility(JsonMethod forMethod, JsonAutoDetect.Visibility visibility) {\n+        return new SerializationConfig(this, _base.withVisibility(forMethod, visibility));\n+    }\n+    \n+    @Override\n+    public SerializationConfig withTypeResolverBuilder(TypeResolverBuilder<?> trb) {\n+        return new SerializationConfig(this, _base.withTypeResolverBuilder(trb));\n+    }\n+\n+    @Override\n+    public SerializationConfig withSubtypeResolver(SubtypeResolver str) {\n+        SerializationConfig cfg =  new SerializationConfig(this);\n+        cfg._subtypeResolver = str;\n+        return cfg;\n+    }\n+    \n+    @Override\n+    public SerializationConfig withPropertyNamingStrategy(PropertyNamingStrategy pns) {\n+        return new SerializationConfig(this, _base.withPropertyNamingStrategy(pns));\n+    }\n+    \n+    @Override\n+    public SerializationConfig withTypeFactory(TypeFactory tf) {\n+        return new SerializationConfig(this, _base.withTypeFactory(tf));\n+    }\n+\n+    /**\n+     * In addition to constructing instance with specified date format,\n+     * will enable or disable <code>Feature.WRITE_DATES_AS_TIMESTAMPS</code>\n+     * (enable if format set as null; disable if non-null)\n+     */\n+    @Override\n+    public SerializationConfig withDateFormat(DateFormat df) {\n+        SerializationConfig cfg =  new SerializationConfig(this, _base.withDateFormat(df));\n+        // Also need to toggle this feature based on existence of date format:\n+        if (df == null) {\n+            cfg = cfg.with(Feature.WRITE_DATES_AS_TIMESTAMPS);\n+        } else {\n+            cfg = cfg.without(Feature.WRITE_DATES_AS_TIMESTAMPS);\n+        }\n+        return cfg;\n+    }\n+    \n+    @Override\n+    public SerializationConfig withHandlerInstantiator(HandlerInstantiator hi) {\n+        return new SerializationConfig(this, _base.withHandlerInstantiator(hi));\n+    }\n+        \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, SerializationConfig specific factory methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @since 1.7\n+     */\n+    public SerializationConfig withFilters(FilterProvider filterProvider) {\n+        return new SerializationConfig(this, filterProvider);\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    public SerializationConfig withView(Class<?> view) {\n+        return new SerializationConfig(this, view);\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public SerializationConfig withSerializationInclusion(JsonSerialize.Inclusion incl) {\n+        return new SerializationConfig(this, incl);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features enabled.\n+     * \n+     * @since 1.9\n+     */\n+    @Override\n+    public SerializationConfig with(Feature... features)\n+    {\n+        int flags = _featureFlags;\n+        for (Feature f : features) {\n+            flags |= f.getMask();\n+        }\n+        return new SerializationConfig(this, flags);\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct and return a new configuration\n+     * object instance with specified features disabled.\n+     * \n+     * @since 1.9\n+     */\n+    @Override\n+    public SerializationConfig without(Feature... features)\n+    {\n+        int flags = _featureFlags;\n+        for (Feature f : features) {\n+            flags &= ~f.getMask();\n+        }\n+        return new SerializationConfig(this, flags);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* MapperConfig implementation/overrides\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that checks class annotations that the argument Object has,\n+     * and modifies settings of this configuration object accordingly,\n+     * similar to how those annotations would affect actual value classes\n+     * annotated with them, but with global scope. Note that not all\n+     * annotations have global significance, and thus only subset of\n+     * Jackson annotations will have any effect.\n+     *<p>\n+     * Serialization annotations that are known to have effect are:\n+     *<ul>\n+     * <li>{@link JsonWriteNullProperties}</li>\n+     * <li>{@link JsonAutoDetect}</li>\n+     * <li>{@link JsonSerialize#typing}</li>\n+     *</ul>\n+     * \n+     * @param cls Class of which class annotations to use\n+     *   for changing configuration settings\n+     *   \n+     * @deprecated Since 1.9, it is preferably to explicitly configure\n+     *   instances; this method also modifies existing instance which is\n+     *   against immutable design goals of this class.\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    @Deprecated\n+    @Override\n+    public void fromAnnotations(Class<?> cls)\n+    {\n+        /* 10-Jul-2009, tatu: Should be able to just pass null as\n+         *    'MixInResolver'; no mix-ins set at this point\n+         * 29-Jul-2009, tatu: Also, we do NOT ignore annotations here, even\n+         *    if Feature.USE_ANNOTATIONS was disabled, since caller\n+         *    specifically requested annotations to be added with this call\n+         */\n+        AnnotationIntrospector ai = getAnnotationIntrospector();\n+        AnnotatedClass ac = AnnotatedClass.construct(cls, ai, null);\n+        _base = _base.withVisibilityChecker(ai.findAutoDetectVisibility(ac,\n+                getDefaultVisibilityChecker()));\n+\n+        // How about writing null property values?\n+        JsonSerialize.Inclusion incl = ai.findSerializationInclusion(ac, null);\n+        if (incl != _serializationInclusion) {\n+            setSerializationInclusion(incl);\n+    \t}\n+\n+        JsonSerialize.Typing typing = ai.findSerializationTyping(ac);\n+        if (typing != null) {\n+            set(Feature.USE_STATIC_TYPING, (typing == JsonSerialize.Typing.STATIC));\n+        }\n+    }\n+\n+    @Override\n+    public SerializationConfig createUnshared(SubtypeResolver subtypeResolver)\n+    {\n+        HashMap<ClassKey,Class<?>> mixins = _mixInAnnotations;\n+        _mixInAnnotationsShared = true;\n+        return new SerializationConfig(this, mixins, subtypeResolver);\n+    }\n+    \n+    @Override\n+    public AnnotationIntrospector getAnnotationIntrospector()\n+    {\n+        /* 29-Jul-2009, tatu: it's now possible to disable use of\n+         *   annotations; can be done using \"no-op\" introspector\n+         */\n+        if (isEnabled(Feature.USE_ANNOTATIONS)) {\n+            return super.getAnnotationIntrospector();\n+        }\n+        return AnnotationIntrospector.nopInstance();\n+    }\n+\n+    /**\n+     * Accessor for getting bean description that only contains class\n+     * annotations: useful if no getter/setter/creator information is needed.\n+     *<p>\n+     * Note: part of {@link MapperConfig} since 1.7\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends BeanDescription> T introspectClassAnnotations(JavaType type) {\n+        return (T) getClassIntrospector().forClassAnnotations(this, type, this);\n+    }\n+\n+    /**\n+     * Accessor for getting bean description that only contains immediate class\n+     * annotations: ones from the class, and its direct mix-in, if any, but\n+     * not from super types.\n+     *<p>\n+     * Note: part of {@link MapperConfig} since 1.7\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends BeanDescription> T introspectDirectClassAnnotations(JavaType type) {\n+        return (T) getClassIntrospector().forDirectClassAnnotations(this, type, this);\n+    }\n+\n+    @Override\n+    public boolean isAnnotationProcessingEnabled() {\n+        return isEnabled(SerializationConfig.Feature.USE_ANNOTATIONS);\n+    }\n+    \n+    @Override\n+    public boolean canOverrideAccessModifiers() {\n+        return isEnabled(Feature.CAN_OVERRIDE_ACCESS_MODIFIERS);\n+    }\n+\n+    @Override\n+    public boolean shouldSortPropertiesAlphabetically() {\n+        return isEnabled(Feature.SORT_PROPERTIES_ALPHABETICALLY);\n+    }\n+    \n+    @Override\n+    public VisibilityChecker<?> getDefaultVisibilityChecker()\n+    {\n+        VisibilityChecker<?> vchecker = super.getDefaultVisibilityChecker();\n+        if (!isEnabled(SerializationConfig.Feature.AUTO_DETECT_GETTERS)) {\n+            vchecker = vchecker.withGetterVisibility(Visibility.NONE);\n+        }\n+        // then global overrides (disabling)\n+        if (!isEnabled(SerializationConfig.Feature.AUTO_DETECT_IS_GETTERS)) {\n+            vchecker = vchecker.withIsGetterVisibility(Visibility.NONE);\n+        }\n+        if (!isEnabled(SerializationConfig.Feature.AUTO_DETECT_FIELDS)) {\n+            vchecker = vchecker.withFieldVisibility(Visibility.NONE);\n+        }\n+        return vchecker;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* MapperConfig overrides for 1.8 backwards compatibility\n+    /**********************************************************\n+     */\n+\n+    /* NOTE: these are overloads we MUST have, but that were missing\n+     * from 1.9.0 and 1.9.1. Type erasure can bite in the ass...\n+     *<p>\n+     * NOTE: will remove either these variants, or base class one, in 2.0.\n+     */\n+    \n+    /** \n+     * Alias for {@link MapperConfig#isEnabled(com.fasterxml.jackson.databind.MapperConfig.ConfigFeature)}.\n+     * \n+     * @since 1.0 However, note that version 1.9.0 and 1.9.1 accidentally missed\n+     *    this overloaded variant\n+     */\n+    public boolean isEnabled(SerializationConfig.Feature f) {\n+        return (_featureFlags & f.getMask()) != 0;\n+    }\n+    \n+    /**\n+     * @deprecated Since 1.9, it is preferable to use {@link #with} instead;\n+     *    this method is deprecated as it modifies current instance instead of\n+     *    creating a new one (as the goal is to make this class immutable)\n+     */\n+    @Deprecated\n+    @Override\n+    public void enable(SerializationConfig.Feature f) {\n+        super.enable(f);\n+    }\n+\n+    /** \n+     * @deprecated Since 1.9, it is preferable to use {@link #without} instead;\n+     *    this method is deprecated as it modifies current instance instead of\n+     *    creating a new one (as the goal is to make this class immutable)\n+     */\n+    @Deprecated\n+    @Override\n+    public void disable(SerializationConfig.Feature f) {\n+        super.disable(f);\n+    }\n+\n+    /** \n+     * @deprecated Since 1.9, it is preferable to use {@link #without} and {@link #with} instead;\n+     *    this method is deprecated as it modifies current instance instead of\n+     *    creating a new one (as the goal is to make this class immutable)\n+     */\n+    @Deprecated\n+    @Override\n+    public void set(SerializationConfig.Feature f, boolean state) {\n+        super.set(f, state);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for checking which serialization view is being used,\n+     * if any; null if none.\n+     *\n+     * @since 1.4\n+     */\n+    public Class<?> getSerializationView() { return _serializationView; }\n+\n+    public JsonSerialize.Inclusion getSerializationInclusion()\n+    {\n+        if (_serializationInclusion != null) {\n+            return _serializationInclusion;\n+        }\n+        return isEnabled(Feature.WRITE_NULL_PROPERTIES) ?\n+            JsonSerialize.Inclusion.ALWAYS : JsonSerialize.Inclusion.NON_NULL;\n+    }\n+    \n+    /**\n+     * Method that will define global setting of which\n+     * bean/map properties are to be included in serialization.\n+     * Can be overridden by class annotations (overriding\n+     * settings to use for instances of that class) and\n+     * method/field annotations (overriding settings for the value\n+     * bean for that getter method or field)\n+     * \n+     * @deprecated since 1.9 should either use {@link #withSerializationInclusion}\n+     *    to construct new instance, or configure through {@link ObjectMapper}\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    @Deprecated\n+    public void setSerializationInclusion(JsonSerialize.Inclusion props)\n+    {\n+        _serializationInclusion = props;\n+        // And for some level of backwards compatibility, also...\n+        if (props == JsonSerialize.Inclusion.NON_NULL) {\n+            disable(Feature.WRITE_NULL_PROPERTIES);\n+        } else {\n+            enable(Feature.WRITE_NULL_PROPERTIES);\n+        }\n+    }\n+    \n+    /**\n+     * Method for getting provider used for locating filters given\n+     * id (which is usually provided with filter annotations).\n+     * Will be null if no provided was set for {@link ObjectWriter}\n+     * (or if serialization directly called from {@link ObjectMapper})\n+     * \n+     * @since 1.7\n+     */\n+    public FilterProvider getFilterProvider() {\n+        return _filterProvider;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Introspection methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will introspect full bean properties for the purpose\n+     * of building a bean serializer\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends BeanDescription> T introspect(JavaType type) {\n+        return (T) getClassIntrospector().forSerialization(this, type, this);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API: serializer instantiation\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonSerializer<Object> serializerInstance(Annotated annotated, Class<? extends JsonSerializer<?>> serClass)\n+    {\n+        HandlerInstantiator hi = getHandlerInstantiator();\n+        if (hi != null) {\n+            JsonSerializer<?> ser = hi.serializerInstance(this, annotated, serClass);\n+            if (ser != null) {\n+                return (JsonSerializer<Object>) ser;\n+            }\n+        }\n+        return (JsonSerializer<Object>) ClassUtil.createInstance(serClass, canOverrideAccessModifiers());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Deprecated methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * One thing to note is that this will set {@link Feature#WRITE_DATES_AS_TIMESTAMPS}\n+     * to false (if null format set), or true (if non-null format)\n+     * \n+     * @deprecated Since 1.8, use {@link #withDateFormat} instead.\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    @Override\n+    @Deprecated\n+    public final void setDateFormat(DateFormat df) {\n+        super.setDateFormat(df);\n+        set(Feature.WRITE_DATES_AS_TIMESTAMPS, (df == null));\n+    }\n+    \n+    /**\n+     * Method for checking which serialization view is being used,\n+     * if any; null if none.\n+     *\n+     * @since 1.4\n+     * \n+     * @deprecated Since 1.8, use {@link #withView} instead\n+     */\n+    @Deprecated\n+    public void setSerializationView(Class<?> view)\n+    {\n+        _serializationView = view;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Debug support\n+    /**********************************************************\n+     */\n+    \n+    @Override public String toString()\n+    {\n+        return \"[SerializationConfig: flags=0x\"+Integer.toHexString(_featureFlags)+\"]\";\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerFactory.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;\n+\n+\n+/**\n+ * Abstract class that defines API used by {@link SerializerProvider}\n+ * to obtain actual\n+ * {@link JsonSerializer} instances from multiple distinct factories.\n+ */\n+public abstract class SerializerFactory\n+{\n+\n+    /*\n+    /**********************************************************\n+    /* Helper class to contain configuration settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Configuration settings container class for bean serializer factory.\n+     * \n+     * @since 1.7\n+     */\n+    public abstract static class Config\n+    {\n+        /**\n+         * Method for creating a new instance with additional serializer provider.\n+         */\n+        public abstract Config withAdditionalSerializers(Serializers additional);\n+\n+        /**\n+         * @since 1.8\n+         */\n+        public abstract Config withAdditionalKeySerializers(Serializers additional);\n+        \n+        /**\n+         * Method for creating a new instance with additional bean serializer modifier.\n+         */\n+        public abstract Config withSerializerModifier(BeanSerializerModifier modifier);\n+        \n+        public abstract boolean hasSerializers();\n+\n+        public abstract boolean hasKeySerializers();\n+\n+        public abstract boolean hasSerializerModifiers();\n+        \n+        public abstract Iterable<Serializers> serializers();\n+\n+        public abstract Iterable<Serializers> keySerializers();\n+        \n+        public abstract Iterable<BeanSerializerModifier> serializerModifiers();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Additional configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 1.7\n+     */\n+    public abstract Config getConfig();\n+    \n+    /**\n+     * Method used for creating a new instance of this factory, but with different\n+     * configuration. Reason for specifying factory method (instead of plain constructor)\n+     * is to allow proper sub-classing of factories.\n+     *<p>\n+     * Note that custom sub-classes generally <b>must override</b> implementation\n+     * of this method, as it usually requires instantiating a new instance of\n+     * factory type. Check out javadocs for\n+     * {@link com.fasterxml.jackson.databind.ser.BeanSerializerFactory} for more details.\n+     * \n+     * @since 1.7\n+     */\n+    public abstract SerializerFactory withConfig(Config config);\n+\n+    /**\n+     * Convenience method for creating a new factory instance with additional serializer\n+     * provider; equivalent to calling\n+     *<pre>\n+     *   withConfig(getConfig().withAdditionalSerializers(additional));\n+     *<pre>\n+     * \n+     * @since 1.7\n+     */\n+    public final SerializerFactory withAdditionalSerializers(Serializers additional) {\n+        return withConfig(getConfig().withAdditionalSerializers(additional));\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    public final SerializerFactory withAdditionalKeySerializers(Serializers additional) {\n+        return withConfig(getConfig().withAdditionalKeySerializers(additional));\n+    }\n+    \n+    /**\n+     * Convenience method for creating a new factory instance with additional bean\n+     * serializer modifier; equivalent to calling\n+     *<pre>\n+     *   withConfig(getConfig().withSerializerModifier(modifier));\n+     *<pre>\n+     * \n+     * @since 1.7\n+     */\n+    public final SerializerFactory withSerializerModifier(BeanSerializerModifier modifier) {\n+        return withConfig(getConfig().withSerializerModifier(modifier));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Basic SerializerFactory API:\n+    /**********************************************************\n+     */\n+\n+    /**\n+      * Method called to create (or, for immutable serializers, reuse) a serializer for given type. \n+      */\n+    public abstract JsonSerializer<Object> createSerializer(SerializationConfig config, JavaType baseType,\n+            BeanProperty property)\n+        throws JsonMappingException;\n+    \n+    /**\n+     * Method called to create a type information serializer for given base type,\n+     * if one is needed. If not needed (no polymorphic handling configured), should\n+     * return null.\n+     *\n+     * @param baseType Declared type to use as the base type for type information serializer\n+     * \n+     * @return Type serializer to use for the base type, if one is needed; null if not.\n+     * \n+     * @since 1.7\n+     */\n+    public abstract TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType,\n+            BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method called to create serializer to use for serializing JSON property names (which must\n+     * be output as <code>JsonToken.FIELD_NAME</code>) for Map that has specified declared\n+     * key type, and is for specified property (or, if property is null, as root value)\n+     * \n+     * @param config Serialization configuration in use\n+     * @param baseType Declared type for Map keys\n+     * @param property Property that contains Map being serialized; null when serializing root Map value.\n+     * \n+     * @return Serializer to use, if factory knows it; null if not (in which case default serializer\n+     *   is to be used)\n+     *   \n+     * @since 1.8\n+     */\n+    public abstract JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType baseType,\n+            BeanProperty property)\n+        throws JsonMappingException;\n+    \n+    /*\n+    /**********************************************************\n+    /* Deprecated (as of 1.7) SerializerFactory API:\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Deprecated version of accessor for type id serializer: as of 1.7 one needs\n+     * to instead call version that passes property information through.\n+     * \n+     * @since 1.5\n+     * \n+     * @deprecated Since 1.7, call variant with more arguments\n+     */\n+    @Deprecated\n+    public final JsonSerializer<Object> createSerializer(JavaType type, SerializationConfig config) {\n+        try {\n+            return createSerializer(config, type, null);\n+        } catch (JsonMappingException e) { // not optimal but:\n+            throw new RuntimeJsonMappingException(e);\n+        }\n+    }\n+    \n+    /**\n+     * Deprecated version of accessor for type id serializer: as of 1.7 one needs\n+     * to instead call version that passes property information through.\n+     * \n+     * @since 1.5\n+     * \n+     * @deprecated Since 1.7, call variant with more arguments\n+     */\n+    @Deprecated\n+    public final TypeSerializer createTypeSerializer(JavaType baseType, SerializationConfig config) {\n+        try {\n+            return createTypeSerializer(config, baseType, null);\n+        } catch (JsonMappingException e) { // not optimal but:\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.Date;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.ser.FilterProvider;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+import org.codehaus.jackson.schema.JsonSchema;\n+\n+/**\n+ * Abstract class that defines API used by {@link ObjectMapper} and\n+ * {@link JsonSerializer}s to obtain serializers capable of serializing\n+ * instances of specific types.\n+ *<p>\n+ * Note about usage: for {@link JsonSerializer} instances, only accessors\n+ * for locating other (sub-)serializers are to be used. {@link ObjectMapper},\n+ * on the other hand, is to initialize recursive serialization process by\n+ * calling {@link #serializeValue}.\n+ */\n+public abstract class SerializerProvider\n+{\n+    protected final static JavaType TYPE_OBJECT = TypeFactory.defaultInstance().uncheckedSimpleType(Object.class);\n+    \n+    /**\n+     * Serialization configuration to use for serialization processing.\n+     */\n+    protected final SerializationConfig _config;\n+\n+    /**\n+     * View used for currently active serialization\n+     */\n+    protected final Class<?> _serializationView;\n+\n+    protected SerializerProvider(SerializationConfig config)\n+    {\n+        _config = config;\n+        _serializationView = (config == null) ? null : _config.getSerializationView();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Methods for configuring default settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to specify serializer that will be\n+     * used to write JSON property names matching null keys for Java\n+     * Maps (which will throw an exception if try write such property\n+     * name)\n+     * \n+     * @since 1.8\n+     */\n+    public abstract void setNullKeySerializer(JsonSerializer<Object> nks);\n+\n+    /**\n+     * Method that can be used to specify serializer that will be\n+     * used to write JSON values matching Java null values\n+     * instead of default one (which simply writes JSON null)\n+     * \n+     * @since 1.8\n+     */\n+    public abstract void setNullValueSerializer(JsonSerializer<Object> nvs);\n+    \n+    /**\n+     * Method that can be used to specify serializer to use for serializing\n+     * all non-null JSON property names, unless more specific key serializer\n+     * is found (i.e. if not custom key serializer has been registered for\n+     * Java type).\n+     *<p>\n+     * Note that key serializer registration are different from value serializer\n+     * registrations.\n+     * \n+     * @since 1.8\n+     */\n+    public abstract void setDefaultKeySerializer(JsonSerializer<Object> ks);\n+    \n+    /*\n+    /**********************************************************\n+    /* Methods that ObjectMapper will call\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * The method to be called by {@link ObjectMapper} to\n+     * execute recursive serialization, using serializers that\n+     * this provider has access to.\n+     *\n+     * @param jsf Underlying factory object used for creating serializers\n+     *    as needed\n+     */\n+    public abstract void serializeValue(SerializationConfig cfg, JsonGenerator jgen,\n+            Object value, SerializerFactory jsf)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * The method to be called by {@link ObjectMapper} to\n+     * execute recursive serialization, using serializers that\n+     * this provider has access to; and using specified root type\n+     * for locating first-level serializer.\n+     * \n+     * @param rootType Type to use for locating serializer to use, instead of actual\n+     *    runtime type. Must be actual type, or one of its super types\n+     *    \n+     * @since 1.5\n+     */\n+    public abstract void serializeValue(SerializationConfig cfg, JsonGenerator jgen,\n+            Object value, JavaType rootType, SerializerFactory jsf)\n+        throws IOException, JsonGenerationException;\n+    \n+    /**\n+     * Generate <a href=\"http://json-schema.org/\">Json-schema</a> for\n+     * given type.\n+     *\n+     * @param type The type for which to generate schema\n+     */\n+    public abstract JsonSchema generateJsonSchema(Class<?> type, SerializationConfig config, SerializerFactory jsf)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method that can be called to see if this serializer provider\n+     * can find a serializer for an instance of given class.\n+     *<p>\n+     * Note that no Exceptions are thrown, including unchecked ones:\n+     * implementations are to swallow exceptions if necessary.\n+     */\n+    public abstract boolean hasSerializerFor(SerializationConfig cfg,\n+            Class<?> cls, SerializerFactory jsf);\n+\n+    /*\n+    /**********************************************************\n+    /* Access to configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for accessing configuration for the serialization processing.\n+     */\n+    public final SerializationConfig getConfig() { return _config; }\n+\n+    /**\n+     * Convenience method for checking whether specified serialization\n+     * feature is enabled or not.\n+     * Shortcut for:\n+     *<pre>\n+     *  getConfig().isEnabled(feature);\n+     *</pre>\n+     */\n+    public final boolean isEnabled(SerializationConfig.Feature feature) {\n+        return _config.isEnabled(feature);\n+    }\n+\n+    /**\n+     * Convenience method for accessing serialization view in use (if any); equivalent to:\n+     *<pre>\n+     *   getConfig().getSerializationView();\n+     *</pre>\n+     *\n+     * @since 1.4\n+     */\n+    public final Class<?> getSerializationView() { return _serializationView; }\n+\n+    /**\n+     * Convenience method for accessing provider to find serialization filters used,\n+     * equivalent to calling:\n+     *<pre>\n+     *   getConfig().getFilterProvider();\n+     *</pre>\n+     *\n+     * @since 1.4\n+     */\n+    public final FilterProvider getFilterProvider() {\n+        return _config.getFilterProvider();\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    public JavaType constructType(Type type) {\n+         return _config.getTypeFactory().constructType(type);\n+    }\n+\n+    /**\n+     * @since 1.9.1\n+     */\n+    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass) {\n+        return _config.constructSpecializedType(baseType, subclass);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* General serializer locating functionality\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to get hold of a serializer for a value of given type;\n+     * or if no such serializer can be found, a default handler (which\n+     * may do a best-effort generic serialization or just simply\n+     * throw an exception when invoked).\n+     *<p>\n+     * Note: this method is only called for non-null values; not for keys\n+     * or null values. For these, check out other accessor methods.\n+     *<p>\n+     * Note that starting with version 1.5, serializers should also be type-aware\n+     * if they handle polymorphic types. That means that it may be necessary\n+     * to also use a {@link TypeSerializer} based on declared (static) type\n+     * being serializer (whereas actual data may be serialized using dynamic\n+     * type)\n+     *\n+     * @throws JsonMappingException if there are fatal problems with\n+     *   accessing suitable serializer; including that of not\n+     *   finding any serializer\n+     */\n+    public abstract JsonSerializer<Object> findValueSerializer(Class<?> runtimeType,\n+            BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Similar to {@link #findValueSerializer(Class)}, but takes full generics-aware\n+     * type instead of raw class.\n+     * \n+     * @since 1.5\n+     */\n+    public abstract JsonSerializer<Object> findValueSerializer(JavaType serializationType,\n+            BeanProperty property)\n+        throws JsonMappingException;\n+    \n+    /**\n+     * Method called to locate regular serializer, matching type serializer,\n+     * and if both found, wrap them in a serializer that calls both in correct\n+     * sequence. This method is currently only used for root-level serializer\n+     * handling to allow for simpler caching. A call can always be replaced\n+     * by equivalent calls to access serializer and type serializer separately.\n+     * \n+     * @param valueType Type for purpose of locating a serializer; usually dynamic\n+     *   runtime type, but can also be static declared type, depending on configuration\n+     * \n+     * @param cache Whether resulting value serializer should be cached or not; this is just\n+     *    a hint \n+     *    \n+     * @since 1.5\n+     */\n+    public abstract JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType,\n+            boolean cache, BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method called to locate regular serializer, matching type serializer,\n+     * and if both found, wrap them in a serializer that calls both in correct\n+     * sequence. This method is currently only used for root-level serializer\n+     * handling to allow for simpler caching. A call can always be replaced\n+     * by equivalent calls to access serializer and type serializer separately.\n+     * \n+     * @param valueType Declared type of value being serialized (which may not\n+     *    be actual runtime type); used for finding both value serializer and\n+     *    type serializer to use for adding polymorphic type (if any)\n+     * \n+     * @param cache Whether resulting value serializer should be cached or not; this is just\n+     *    a hint \n+     *    \n+     * @since 1.5\n+     */\n+    public abstract JsonSerializer<Object> findTypedValueSerializer(JavaType valueType,\n+            boolean cache, BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method called to get the serializer to use for serializing\n+     * non-null Map keys. Separation from regular\n+     * {@link #findValueSerializer} method is because actual write\n+     * method must be different (@link JsonGenerator#writeFieldName};\n+     * but also since behavior for some key types may differ.\n+     *<p>\n+     * Note that the serializer itself can be called with instances\n+     * of any Java object, but not nulls.\n+     * \n+     * @since 1.8\n+     */\n+    public abstract JsonSerializer<Object> findKeySerializer(JavaType keyType,\n+            BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /*\n+    /**********************************************************\n+    /* Deprecated serializer locating functionality\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Deprecated version of accessor method that was used before version 1.7.\n+     * Implemented as final to ensure that existing code does not accidentally\n+     * try to redefine it (given that it is not called by core mapper code)\n+     *   \n+     * @deprecated As of version 1.7, use version that exposes property object\n+     *    instead of just its type (needed for contextual serializers)\n+     */\n+    @Deprecated\n+    public final JsonSerializer<Object> findValueSerializer(Class<?> runtimeType)\n+        throws JsonMappingException\n+    {\n+        return findValueSerializer(runtimeType, null);\n+    }\n+\n+    /**\n+     * Deprecated version of accessor method that was used before version 1.7.\n+     * Implemented as final to ensure that existing code does not accidentally\n+     * try to redefine it (given that it is not called by core mapper code)\n+     *   \n+     * @deprecated As of version 1.7, use version that exposes property object\n+     *    instead of just its type (needed for contextual serializers)\n+     */\n+    @Deprecated\n+    public final JsonSerializer<Object> findValueSerializer(JavaType serializationType)\n+        throws JsonMappingException\n+    {\n+        return findValueSerializer(serializationType, null);\n+    }\n+\n+    /**\n+     * Deprecated version of accessor method that was used before version 1.7.\n+     * Implemented as final to ensure that existing code does not accidentally\n+     * try to redefine it (given that it is not called by core mapper code)\n+     *   \n+     * @deprecated As of version 1.7, use version that exposes property object\n+     *    instead of just its type (needed for contextual serializers)\n+     */\n+    @Deprecated\n+    public final JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType,\n+            boolean cache)\n+        throws JsonMappingException\n+    {\n+        return findTypedValueSerializer(valueType, cache, null);\n+    }\n+\n+    /**\n+     * Deprecated version of accessor method that was used before version 1.7.\n+     * Implemented as final to ensure that existing code does not accidentally\n+     * try to redefine it (given that it is not called by core mapper code)\n+     *   \n+     * @deprecated As of version 1.7, use version that exposes property object\n+     *    instead of just its type (needed for contextual serializers)\n+     */\n+    @Deprecated\n+    public final JsonSerializer<Object> findTypedValueSerializer(JavaType valueType,\n+            boolean cache)\n+        throws JsonMappingException\n+    {\n+        return findTypedValueSerializer(valueType, cache, null);\n+    }\n+\n+    /**\n+     * Deprecated version of accessor method that was used before version 1.7.\n+     * Implemented as final to ensure that existing code does not accidentally\n+     * try to redefine it (given that it is not called by core mapper code)\n+     *   \n+     * @deprecated As of version 1.7, use version that exposes property object\n+     *    instead of just its type (needed for contextual serializers)\n+     */\n+    @Deprecated\n+    public final JsonSerializer<Object> getKeySerializer()\n+        throws JsonMappingException\n+    {\n+        return findKeySerializer(TYPE_OBJECT, null);\n+    }\n+\n+    /**\n+     * Deprecated version of accessor method that was used before version 1.8;\n+     * renamed as {@link #findKeySerializer}, since process is now\n+     * more complicated than simple lookup.\n+     *\n+     * @deprecated As of version 1.8\n+     */\n+    @Deprecated\n+    public final JsonSerializer<Object> getKeySerializer(JavaType valueType, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        return findKeySerializer(valueType, property);\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Accessors for specialized serializers\n+    /********************************************************\n+     */\n+\n+    /**\n+     * Method called to get the serializer to use for serializing\n+     * Map keys that are nulls: this is needed since JSON does not allow\n+     * any non-String value as key, including null.\n+     *<p>\n+     * Typically, returned serializer\n+     * will either throw an exception, or use an empty String; but\n+     * other behaviors are possible.\n+     */\n+    public abstract JsonSerializer<Object> getNullKeySerializer();\n+\n+    /**\n+     * Method called to get the serializer to use for serializing\n+     * values (root level, Array members or List field values)\n+     * that are nulls. Specific accessor is needed because nulls\n+     * in Java do not contain type information.\n+     *<p>\n+     * Typically returned serializer just writes out Json literal\n+     * null value.\n+     */\n+    public abstract JsonSerializer<Object> getNullValueSerializer();\n+\n+    /**\n+     * Method called to get the serializer to use if provider\n+     * can not determine an actual type-specific serializer\n+     * to use; typically when none of {@link SerializerFactory}\n+     * instances are able to construct a serializer.\n+     *<p>\n+     * Typically, returned serializer will throw an exception,\n+     * although alternatively {@link com.fasterxml.jackson.databind.ser.ToStringSerializer} could\n+     * be returned as well.\n+     *\n+     * @param unknownType Type for which no serializer is found\n+     */\n+    public abstract JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType);\n+\n+    /*\n+    /********************************************************\n+    /* Convenience methods\n+    /********************************************************\n+     */\n+\n+    /**\n+     * Convenience method that will serialize given value (which can be\n+     * null) using standard serializer locating functionality. It can\n+     * be called for all values including field and Map values, but usually\n+     * field values are best handled calling\n+     * {@link #defaultSerializeField} instead.\n+     */\n+    public final void defaultSerializeValue(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (value == null) {\n+            getNullValueSerializer().serialize(null, jgen, this);\n+        } else {\n+            Class<?> cls = value.getClass();\n+            findTypedValueSerializer(cls, true, null).serialize(value, jgen, this);\n+        }\n+    }\n+    \n+    /**\n+     * Convenience method that will serialize given field with specified\n+     * value. Value may be null. Serializer is done using the usual\n+     * null) using standard serializer locating functionality.\n+     */\n+    public final void defaultSerializeField(String fieldName, Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        jgen.writeFieldName(fieldName);\n+        if (value == null) {\n+            /* Note: can't easily check for suppression at this point\n+             * any more; caller must check it.\n+             */\n+            getNullValueSerializer().serialize(null, jgen, this);\n+        } else {\n+            Class<?> cls = value.getClass();\n+            findTypedValueSerializer(cls, true, null).serialize(value, jgen, this);\n+        }\n+    }\n+\n+    /**\n+     * Method that will handle serialization of Date(-like) values, using\n+     * {@link SerializationConfig} settings to determine expected serialization\n+     * behavior.\n+     * Note: date here means \"full\" date, that is, date AND time, as per\n+     * Java convention (and not date-only values like in SQL)\n+     */\n+    public abstract void defaultSerializeDateValue(long timestamp, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method that will handle serialization of Date(-like) values, using\n+     * {@link SerializationConfig} settings to determine expected serialization\n+     * behavior.\n+     * Note: date here means \"full\" date, that is, date AND time, as per\n+     * Java convention (and not date-only values like in SQL)\n+     */\n+    public abstract void defaultSerializeDateValue(Date date, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException;\n+\n+\n+    /**\n+     * Method that will handle serialization of Dates used as {@link java.util.Map} keys,\n+     * based on {@link SerializationConfig.Feature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n+     * value (and if using textual representation, configured date format)\n+     * \n+     * @since 1.9\n+     */\n+    public abstract void defaultSerializeDateKey(long timestamp, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method that will handle serialization of Dates used as {@link java.util.Map} keys,\n+     * based on {@link SerializationConfig.Feature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n+     * value (and if using textual representation, configured date format)\n+     * \n+     * @since 1.9\n+     */\n+    public abstract void defaultSerializeDateKey(Date date, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException;\n+    \n+    /**\n+     * @since 1.7\n+     */\n+    public final void defaultSerializeNull(JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        getNullValueSerializer().serialize(null, jgen, this);\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Access to caching details\n+    /********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to determine how many serializers this\n+     * provider is caching currently\n+     * (if it does caching: default implementation does)\n+     * Exact count depends on what kind of serializers get cached;\n+     * default implementation caches all serializers, including ones that\n+     * are eagerly constructed (for optimal access speed)\n+     *<p> \n+     * The main use case for this method is to allow conditional flushing of\n+     * serializer cache, if certain number of entries is reached.\n+     * \n+     * @since 1.4\n+     */\n+    public abstract int cachedSerializersCount();\n+\n+    /**\n+     * Method that will drop all serializers currently cached by this provider.\n+     * This can be used to remove memory usage (in case some serializers are\n+     * only used once or so), or to force re-construction of serializers after\n+     * configuration changes for mapper than owns the provider.\n+     * \n+     * @since 1.4\n+     */\n+    public abstract void flushCachedSerializers();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/Serializers.java\n+package com.fasterxml.jackson.databind;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.type.*;\n+\n+\n+/**\n+ * Interface that defines API for simple extensions that can provide additional serializers\n+ * for various types. Access is by a single callback method; instance is to either return\n+ * a configured {@link JsonSerializer} for specified type, or null to indicate that it\n+ * does not support handling of the type. In latter case, further calls can be made\n+ * for other providers; in former case returned serializer is used for handling of\n+ * instances of specified type.\n+ * \n+ * @since 1.7\n+ */\n+public interface Serializers\n+{\n+    /**\n+     * Method called by serialization framework first time a serializer is needed for\n+     * specified type, which is not of a container type (for which other methods are\n+     * called).\n+     *<p>\n+     * Note: in version 1.7, this method was called to find serializers for all\n+     * type, including container types.\n+     * \n+     * @param type Fully resolved type of instances to serialize\n+     * @param config Serialization configuration in use\n+     * @param beanDesc Additional information about type; will always be of type\n+     *    {@link com.fasterxml.jackson.databind.introspect.BasicBeanDescription} (that is,\n+     *    safe to cast to this more specific type)\n+     * @param property Property that contains values to serialize\n+     *    \n+     * @return Configured serializer to use for the type; or null if implementation\n+     *    does not recognize or support type\n+     */\n+    public JsonSerializer<?> findSerializer(SerializationConfig config,\n+            JavaType type, BeanDescription beanDesc, BeanProperty property);\n+\n+    /**\n+     * Method called by serialization framework first time a serializer is needed for\n+     * specified array type.\n+     * Implementation should return a serializer instance if it supports\n+     * specified type; or null if it does not.\n+     * \n+     * @since 1.8\n+     */\n+    public JsonSerializer<?> findArraySerializer(SerializationConfig config,\n+            ArrayType type, BeanDescription beanDesc, BeanProperty property,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer);\n+\n+    public JsonSerializer<?> findCollectionSerializer(SerializationConfig config,\n+            CollectionType type, BeanDescription beanDesc, BeanProperty property,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer);\n+\n+    public JsonSerializer<?> findCollectionLikeSerializer(SerializationConfig config,\n+            CollectionLikeType type, BeanDescription beanDesc, BeanProperty property,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer);\n+    \n+    public JsonSerializer<?> findMapSerializer(SerializationConfig config,\n+            MapType type, BeanDescription beanDesc, BeanProperty property,\n+            JsonSerializer<Object> keySerializer,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer);\n+\n+    public JsonSerializer<?> findMapLikeSerializer(SerializationConfig config,\n+            MapLikeType type, BeanDescription beanDesc, BeanProperty property,\n+            JsonSerializer<Object> keySerializer,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer);\n+\n+    /**\n+     * Basic {@link Serializers} implementation that implements all methods but provides\n+     * no serializers. Its main purpose is to serve as a base class so that\n+     * sub-classes only need to override methods they need.\n+     * \n+     * @since 1.9\n+     */\n+    public static class Base implements Serializers\n+    {\n+        @Override\n+        public JsonSerializer<?> findSerializer(SerializationConfig config,\n+                JavaType type, BeanDescription beanDesc, BeanProperty property)\n+        {\n+            return null;\n+        }\n+        \n+        @Override\n+        public JsonSerializer<?> findArraySerializer(SerializationConfig config,\n+                ArrayType type, BeanDescription beanDesc, BeanProperty property,\n+                TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n+        {\n+            return null;\n+        }\n+\n+        @Override\n+        public JsonSerializer<?> findCollectionSerializer(SerializationConfig config,\n+                CollectionType type, BeanDescription beanDesc, BeanProperty property,\n+                TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n+        {\n+            return null;\n+        }\n+\n+        @Override\n+        public JsonSerializer<?> findCollectionLikeSerializer(SerializationConfig config,\n+                CollectionLikeType type, BeanDescription beanDesc, BeanProperty property,\n+                TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n+        {\n+            return null;\n+        }\n+            \n+        @Override\n+        public JsonSerializer<?> findMapSerializer(SerializationConfig config,\n+                MapType type, BeanDescription beanDesc, BeanProperty property,\n+                JsonSerializer<Object> keySerializer,\n+                TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n+        {\n+            return null;\n+        }\n+\n+        @Override\n+        public JsonSerializer<?> findMapLikeSerializer(SerializationConfig config,\n+                MapLikeType type, BeanDescription beanDesc, BeanProperty property,\n+                JsonSerializer<Object> keySerializer,\n+                TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n+        {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * @deprecated As of 1.9, use {@link Base} instead\n+     */\n+    @Deprecated\n+    public static class None extends Base { }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/TypeDeserializer.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+\n+\n+/**\n+ * Interface for deserializing type information from JSON content, to\n+ * type-safely deserialize data into correct polymorphic instance\n+ * (when type inclusion has been enabled for type handled).\n+ *<p>\n+ * Separate deserialization methods are needed because serialized\n+ * form for inclusion mechanism {@link As#PROPERTY}\n+ * is slighty different if value is not expressed as JSON Object:\n+ * and as such both type deserializer and serializer need to\n+ * JSON Object form (array, object or other (== scalar)) being\n+ * used.\n+ * \n+ * @since 1.5\n+ * @author tatus\n+ */\n+public abstract class TypeDeserializer\n+{\n+    /*\n+    /**********************************************************\n+    /* Introspection\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Accessor for type information inclusion method\n+     * that deserializer uses; indicates how type information\n+     * is (expected to be) embedded in JSON input.\n+     */\n+    public abstract As getTypeInclusion();\n+\n+    /**\n+     * Name of property that contains type information, if\n+     * property-based inclusion is used.\n+     */\n+    public abstract String getPropertyName();\n+\n+    /**\n+     * Accessor for object that handles conversions between\n+     * types and matching type ids.\n+     */\n+    public abstract TypeIdResolver getTypeIdResolver();\n+\n+    /**\n+     * Accessor for \"default implementation\" type; optionally defined\n+     * class to use in cases where type id is not\n+     * accessible for some reason (either missing, or can not be\n+     * resolved)\n+     * \n+     * @since 1.9\n+     */\n+    public abstract Class<?> getDefaultImpl();\n+    \n+    /*\n+    /*********************************************************\n+    /* Type deserialization methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to let this type deserializer handle \n+     * deserialization of \"typed\" object, when value itself\n+     * is serialized as JSON Object (regardless of Java type).\n+     * Method needs to figure out intended\n+     * polymorphic type, locate {@link JsonDeserializer} to use, and\n+     * call it with JSON data to deserializer (which does not contain\n+     * type information).\n+     */\n+    public abstract Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method called to let this type deserializer handle \n+     * deserialization of \"typed\" object, when value itself\n+     * is serialized as JSON Array (regardless of Java type).\n+     * Method needs to figure out intended\n+     * polymorphic type, locate {@link JsonDeserializer} to use, and\n+     * call it with JSON data to deserializer (which does not contain\n+     * type information).\n+     */\n+    public abstract Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method called to let this type deserializer handle \n+     * deserialization of \"typed\" object, when value itself\n+     * is serialized as a scalar JSON value (something other\n+     * than Array or Object), regardless of Java type.\n+     * Method needs to figure out intended\n+     * polymorphic type, locate {@link JsonDeserializer} to use, and\n+     * call it with JSON data to deserializer (which does not contain\n+     * type information).\n+     */\n+    public abstract Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method called to let this type deserializer handle \n+     * deserialization of \"typed\" object, when value itself\n+     * may have been serialized using any kind of JSON value\n+     * (Array, Object, scalar). Should only be called if JSON\n+     * serialization is polymorphic (not Java type); for example when\n+     * using JSON node representation, or \"untyped\" Java object\n+     * (which may be Map, Collection, wrapper/primitive etc).\n+     */\n+    public abstract Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException;\n+\n+}\n+    \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/TypeSerializer.java\n+package com.fasterxml.jackson.databind;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+\n+\n+/**\n+ * Interface for serializing type information regarding instances of specified\n+ * base type (super class), so that exact subtype can be properly deserialized\n+ * later on. These instances are to be called by regular\n+ * {@link com.fasterxml.jackson.databind.JsonSerializer}s using proper contextual\n+ * calls, to add type information using mechanism type serializer was\n+ * configured with.\n+ * \n+ * @since 1.5\n+ * @author tatus\n+ */\n+public abstract class TypeSerializer\n+{\n+    /*\n+    /**********************************************************\n+    /* Introspection\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Accessor for type information inclusion method\n+     * that serializer uses; indicates how type information\n+     * is embedded in resulting JSON.\n+     */\n+    public abstract JsonTypeInfo.As getTypeInclusion();\n+\n+    /**\n+     * Name of property that contains type information, if\n+     * property-based inclusion is used.\n+     */\n+    public abstract String getPropertyName();\n+    \n+    /**\n+     * Accessor for object that handles conversions between\n+     * types and matching type ids.\n+     */\n+    public abstract TypeIdResolver getTypeIdResolver();\n+    \n+    /*\n+    /**********************************************************\n+    /* Type serialization methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called to write initial part of type information for given\n+     * value, when it will be output as scalar JSON value (not as JSON\n+     * Object or Array).\n+     * This means that the context after call can not be that of JSON Object;\n+     * it may be Array or root context.\n+     * \n+     * @param value Value that will be serialized, for which type information is\n+     *   to be written\n+     * @param jgen Generator to use for writing type information\n+     */\n+    public abstract void writeTypePrefixForScalar(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method called to write initial part of type information for given\n+     * value, when it will be output as JSON Object value (not as JSON\n+     * Array or scalar).\n+     * This means that context after call must be JSON Object, meaning that\n+     * caller can then proceed to output field entries.\n+     * \n+     * @param value Value that will be serialized, for which type information is\n+     *   to be written\n+     * @param jgen Generator to use for writing type information\n+     */\n+    public abstract void writeTypePrefixForObject(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method called to write initial part of type information for given\n+     * value, when it will be output as JSON Array value (not as JSON\n+     * Object or scalar).\n+     * This means that context after call must be JSON Array, that is, there\n+     * must be an open START_ARRAY to write contents in.\n+     * \n+     * @param value Value that will be serialized, for which type information is\n+     *   to be written\n+     * @param jgen Generator to use for writing type information\n+     */\n+    public abstract void writeTypePrefixForArray(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException;\n+    \n+    /**\n+     * Method called after value has been serialized, to close any scopes opened\n+     * by earlier matching call to {@link #writeTypePrefixForScalar}.\n+     * Actual action to take may depend on various factors, but has to match with\n+     * action {@link #writeTypePrefixForScalar} did (close array or object; or do nothing).\n+     */\n+    public abstract void writeTypeSuffixForScalar(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method called after value has been serialized, to close any scopes opened\n+     * by earlier matching call to {@link #writeTypePrefixForObject}.\n+     * It needs to write closing END_OBJECT marker, and any other decoration\n+     * that needs to be matched.\n+     */\n+    public abstract void writeTypeSuffixForObject(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Method called after value has been serialized, to close any scopes opened\n+     * by earlier matching call to {@link #writeTypeSuffixForScalar}.\n+     * It needs to write closing END_ARRAY marker, and any other decoration\n+     * that needs to be matched.\n+     */\n+    public abstract void writeTypeSuffixForArray(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Alternative version of the prefix-for-scalar method, which is given\n+     * actual type to use (instead of using exact type of the value); typically\n+     * a super type of actual value type\n+     * \n+     * @since 1.8\n+     */\n+    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen,\n+            Class<?> type)\n+        throws IOException, JsonProcessingException\n+    {\n+        writeTypePrefixForScalar(value, jgen);\n+    }\n+\n+    /**\n+     * Alternative version of the prefix-for-object method, which is given\n+     * actual type to use (instead of using exact type of the value); typically\n+     * a super type of actual value type\n+     * \n+     * @since 1.8\n+     */\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen,\n+            Class<?> type)\n+        throws IOException, JsonProcessingException\n+    {\n+        writeTypePrefixForObject(value, jgen);\n+    }\n+\n+    /**\n+     * Alternative version of the prefix-for-array method, which is given\n+     * actual type to use (instead of using exact type of the value); typically\n+     * a super type of actual value type\n+     * \n+     * @since 1.8\n+     */\n+    public void writeTypePrefixForArray(Object value, JsonGenerator jgen,\n+            Class<?> type)\n+        throws IOException, JsonProcessingException\n+    {\n+        writeTypePrefixForArray(value, jgen);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/JacksonInject.java\n+package com.fasterxml.jackson.databind.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+\n+/**\n+ * Jackson-specific annotation used for indicating that value of\n+ * annotated property will be \"injected\", i.e. set based on value\n+ * configured by <code>ObjectMapper</code> (usually on per-call basis).\n+ * Usually property is not deserialized from JSON, although it possible\n+ * to have injected value as default and still allow optional override\n+ * from JSON.\n+ * \n+ * @since 1.9\n+ */\n+@Target({ElementType.METHOD, ElementType.FIELD, ElementType.PARAMETER})\n+@Retention(RetentionPolicy.RUNTIME)\n+@JacksonAnnotation\n+public @interface JacksonInject\n+{\n+    /**\n+     * Logical id of the value to inject; if not specified (or specified\n+     * as empty String), will use id based on declared type of property.\n+     */\n+    public String value() default \"\";\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/JacksonStdImpl.java\n+package com.fasterxml.jackson.databind.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+\n+/**\n+ * Marker interface used to indicate implementation classes\n+ * (serializers, deserializers etc) that are standard ones Jackson\n+ * uses; not custom ones that application has added. It can be\n+ * added in cases where certain optimizations can be made if\n+ * default instances are uses; for example when handling conversions\n+ * of \"natural\" JSON types like Strings, booleans and numbers.\n+ * \n+ * @since 1.6\n+ */\n+@Target({ElementType.TYPE})\n+@Retention(RetentionPolicy.RUNTIME)\n+@JacksonAnnotation\n+public @interface JacksonStdImpl {\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/JsonCachable.java\n+package com.fasterxml.jackson.databind.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+\n+/**\n+ * Marker annotation used to denote whether given instance\n+ * (currently only used with {@link com.fasterxml.jackson.databind.JsonDeserializer})\n+ * can be cached.\n+ *<p>\n+ * Default action to take in absence of annotation depends\n+ * on object using annotation; with deserializers default is\n+ * to assume instances are not cachable.\n+ *\n+ * @since 1.1\n+ */\n+@Target({ElementType.TYPE})\n+@Retention(RetentionPolicy.RUNTIME)\n+@JacksonAnnotation\n+public @interface JsonCachable\n+{\n+    /**\n+     * Default value is true, giving semantics for parameterless tag instance\n+     * such that empty instance indicates that instances of annotated class\n+     * are indeed cachable.\n+     */\n+    boolean value() default true;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/JsonDeserialize.java\n+package com.fasterxml.jackson.databind.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.KeyDeserializer;\n+\n+/**\n+ * Annotation use for configuring deserialization aspects, by attaching\n+ * to \"setter\" methods or fields, or to value classes.\n+ * When annotating value classes, configuration is used for instances\n+ * of the value class but can be overridden by more specific annotations\n+ * (ones that attach to methods or fields).\n+ *<p>\n+ * An example annotation would be:\n+ *<pre>\n+ *  &#64;JsonDeserialize(using=MySerializer.class,\n+ *    as=MyHashMap.class,\n+ *    keyAs=MyHashKey.class,\n+ *    contentAs=MyHashValue.class\n+ *  )\n+ *</pre>\n+ *<p>\n+ * NOTE: since version 1.2, annotation has also been applicable\n+ * to (constructor) parameters\n+ *\n+ * @since 1.1\n+ */\n+@Target({ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonDeserialize\n+{\n+    // // // Annotations for explicitly specifying deserializer\n+\n+    /**\n+     * Deserializer class to use for deserializing associated value.\n+     * Depending on what is annotated,\n+     * value is either an instance of annotated class (used globablly\n+     * anywhere where class deserializer is needed); or only used for\n+     * deserializing property access via a setter method.\n+     */\n+    public Class<? extends JsonDeserializer<?>> using()\n+        default JsonDeserializer.None.class;\n+\n+    /**\n+     * Deserializer class to use for deserializing contents (elements\n+     * of a Collection/array, values of Maps) of annotated property.\n+     * Can only be used on instances (methods, fields, constructors),\n+     * and not value classes themselves.\n+     *\n+     * @since 1.3\n+     */\n+    public Class<? extends JsonDeserializer<?>> contentUsing()\n+        default JsonDeserializer.None.class;\n+\n+    /**\n+     * Deserializer class to use for deserializing Map keys\n+     * of annotated property.\n+     * Can only be used on instances (methods, fields, constructors),\n+     * and not value classes themselves.\n+     *\n+     * @since 1.3\n+     */\n+    public Class<? extends KeyDeserializer> keyUsing()\n+        default KeyDeserializer.None.class;\n+\n+    // // // Annotations for explicitly specifying deserialization type\n+    // // // (which is used for choosing deserializer, if not explicitly\n+    // // // specified\n+\n+    /**\n+     * Concrete type to deserialize values as, instead of type otherwise\n+     * declared. Must be a subtype of declared type; otherwise an\n+     * exception may be thrown by deserializer.\n+     *<p>\n+     * Bogus type {@link NoClass} can be used to indicate that declared\n+     * type is used as is (i.e. this annotation property has no setting);\n+     * this since annotation properties are not allowed to have null value.\n+     *<p>\n+     * Note: if {@link #using} is also used it has precedence\n+     * (since it directly specified\n+     * deserializer, whereas this would only be used to locate the\n+     * deserializer)\n+     * and value of this annotation property is ignored.\n+     */\n+    public Class<?> as() default NoClass.class;\n+\n+    /**\n+     * Concrete type to deserialize keys of {@link java.util.Map} as,\n+     * instead of type otherwise declared.\n+     * Must be a subtype of declared type; otherwise an exception may be\n+     * thrown by deserializer.\n+     */\n+    public Class<?> keyAs() default NoClass.class;\n+\n+    /**\n+     * Concrete type to deserialize content (elements\n+     * of a Collection/array, values of Maps) values as,\n+     * instead of type otherwise declared.\n+     * Must be a subtype of declared type; otherwise an exception may be\n+     * thrown by deserializer.\n+     */\n+    public Class<?> contentAs() default NoClass.class;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/JsonFilter.java\n+package com.fasterxml.jackson.databind.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Annotation used to indicate which logical filter is to be used\n+ * for filtering out properties of type (class) annotated;\n+ * association made by this annotation declaring ids of filters,\n+ * and  {@link com.fasterxml.jackson.databind.ObjectMapper} (or objects\n+ * it delegates to) providing matching filters by id.\n+ * Filters to use are of type\n+ * {@link com.fasterxml.jackson.databind.ser.BeanPropertyFilter} and\n+ * are registered through {@link com.fasterxml.jackson.databind.ObjectMapper}\n+ * \n+ * @since 1.7\n+ */\n+@Target(ElementType.TYPE)\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonFilter\n+{\n+    /**\n+     * Id of filter to use; if empty String (\"\"), no filter is to be used.\n+     */\n+    public String value();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/JsonRootName.java\n+package com.fasterxml.jackson.databind.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Annotation similar to {@link javax.xml.bind.annotation.XmlRootElement},\n+ * used to indicate name to use for root-level wrapping, if wrapping is\n+ * enabled. Annotation itself does not indicate that wrapping should\n+ * be used; but if it is, name used for serialization should be name\n+ * specified here, and deserializer will expect the name as well.\n+ * \n+ * @since 1.9.0\n+ */\n+@Target(ElementType.TYPE)\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonRootName\n+{\n+    /**\n+     * Root name to use if root-level wrapping is enabled.\n+     */\n+    public String value();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/JsonSerialize.java\n+package com.fasterxml.jackson.databind.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Annotation used for configuring serialization aspects, by attaching\n+ * to \"getter\" methods or fields, or to value classes.\n+ * When annotating value classes, configuration is used for instances\n+ * of the value class but can be overridden by more specific annotations\n+ * (ones that attach to methods or fields).\n+ *<p>\n+ * An example annotation would be:\n+ *<pre>\n+ *  &#64;JsonSerialize(using=MySerializer.class,\n+ *    as=MySubClass.class,\n+ *    include=JsonSerialize.Inclusion.NON_NULL,\n+ *    typing=JsonSerialize.Typing.STATIC\n+ *  )\n+ *</pre>\n+ * (which would be redundant, since some properties block others:\n+ * specifically, 'using' has precedence over 'as', which has precedence\n+ * over 'typing' setting)\n+ *<p>\n+ * NOTE: since version 1.2, annotation has also been applicable\n+ * to (constructor) parameters\n+ *\n+ * @since 1.1\n+ */\n+@Target({ElementType.METHOD, ElementType.FIELD, ElementType.TYPE, ElementType.PARAMETER})\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonSerialize\n+{\n+    // // // Annotations for explicitly specifying deserializer\n+\n+    /**\n+     * Serializer class to use for\n+     * serializing associated value. Depending on what is annotated,\n+     * value is either an instance of annotated class (used globablly\n+     * anywhere where class serializer is needed); or only used for\n+     * serializing property access via a getter method.\n+     */\n+    public Class<? extends JsonSerializer<?>> using() default JsonSerializer.None.class;\n+\n+    /**\n+     * Serializer class to use for serializing contents (elements\n+     * of a Collection/array, values of Maps) of annotated property.\n+     * Can only be used on properties (methods, fields, constructors),\n+     * and not value classes themselves (as they are typically generic)\n+     *\n+     * @since 1.8\n+     */\n+    public Class<? extends JsonSerializer<?>> contentUsing()\n+        default JsonSerializer.None.class;\n+\n+    /**\n+     * Serializer class to use for serializing Map keys\n+     * of annotated property.\n+     * Can only be used on properties (methods, fields, constructors),\n+     * and not value classes themselves.\n+     *\n+     * @since 1.8\n+     */\n+    public Class<? extends JsonSerializer<?>> keyUsing()\n+        default JsonSerializer.None.class;\n+    \n+    // // // Annotations for type handling, explicit declaration\n+    // // // (type used for choosing deserializer, if not explicitly\n+    // // // specified)\n+\n+    /**\n+     * Supertype (of declared type, which itself is supertype of runtime type)\n+     * to use as type when locating serializer to use.\n+     *<p>\n+     * Bogus type {@link NoClass} can be used to indicate that declared\n+     * type is used as is (i.e. this annotation property has no setting);\n+     * this since annotation properties are not allowed to have null value.\n+     *<p>\n+     * Note: if {@link #using} is also used it has precedence\n+     * (since it directly specifies\n+     * serializer, whereas this would only be used to locate the\n+     * serializer)\n+     * and value of this annotation property is ignored.\n+     */\n+    public Class<?> as() default NoClass.class;\n+\n+    /**\n+     * Concrete type to serialize keys of {@link java.util.Map} as,\n+     * instead of type otherwise declared.\n+     * Must be a supertype of declared type; otherwise an exception may be\n+     * thrown by serializer.\n+     */\n+    public Class<?> keyAs() default NoClass.class;\n+\n+    /**\n+     * Concrete type to serialize content value (elements\n+     * of a Collection/array, values of Maps) as,\n+     * instead of type otherwise declared.\n+     * Must be a supertype of declared type; otherwise an exception may be\n+     * thrown by serializer.\n+     */\n+    public Class<?> contentAs() default NoClass.class;\n+    \n+    /**\n+     * Whether type detection used is dynamic or static: that is,\n+     * whether actual runtime type is used (dynamic), or just the\n+     * declared type (static).\n+     *\n+     * @since 1.2\n+     */\n+    public Typing typing() default Typing.DYNAMIC;\n+\n+    // // // Annotation(s) for inclusion criteria\n+\n+    /**\n+     * Which properties of annotated Bean are\n+     * to be included in serialization (has no effect on other types\n+     * like enums, primitives or collections).\n+     * Choices are \"all\", \"properties that have value other than null\"\n+     * and \"properties that have non-default value\" (i.e. default value\n+     * being property setting for a Bean constructed with default no-arg\n+     * constructor, often null).\n+     *\n+     */\n+    public Inclusion include() default Inclusion.ALWAYS;\n+    \n+    /*\n+    /**********************************************************\n+    /* Value enumerations needed\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Enumeration used with {@link JsonSerialize#include} property\n+     * to define which properties\n+     * of Java Beans are to be included in serialization\n+     *\n+     * @since 1.1\n+     */\n+    public enum Inclusion\n+    {\n+        /**\n+         * Value that indicates that properties are to be always included,\n+         * independent of value\n+         */\n+        ALWAYS,\n+\n+        /**\n+         * Value that indicates that only properties with non-null\n+         * values are to be included.\n+         */\n+        NON_NULL,\n+\n+        /**\n+         * Value that indicates that only properties that have values\n+         * that differ from default settings (meaning values they have\n+         * when Bean is constructed with its no-arguments constructor)\n+         * are to be included. Value is generally not useful with\n+         * {@link java.util.Map}s, since they have no default values;\n+         * and if used, works same as {@link #ALWAYS}.\n+         */\n+        NON_DEFAULT,\n+\n+        /**\n+         * Value that indicates that only properties that have values\n+         * that values that are null or what is considered empty are\n+         * not to be included.\n+         * Emptiness is defined for following type:\n+         *<ul>\n+         * <li>For {@link java.util.Collection}s and {@link java.util.Map}s,\n+         *    method <code>isEmpty()</code> is called;\n+         *   </li>\n+         * <li>For Java arrays, empty arrays are ones with length of 0\n+         *   </li>\n+         * <li>For Java {@link java.lang.String}s, <code>length()</code> is called,\n+         *   and return value of 0 indicates empty String (note that <code>String.isEmpty()</code>\n+         *   was added in Java 1.6 and as such can not be used by Jackson\n+         *   </li>\n+         * <ul>\n+         *  For other types, non-null values are to be included.\n+         * \n+         * @since 1.9\n+         */\n+        NON_EMPTY\n+        ;\n+    }\n+\n+    /**\n+     * Enumeration used with {@link JsonSerialize#typing} property\n+     * to define whether type detection is based on dynamic runtime\n+     * type (DYNAMIC) or declared type (STATIC).\n+     * \n+     * @since 1.1\n+     */\n+    public enum Typing\n+    {\n+        /**\n+         * Value that indicates that the actual dynamic runtime type is to\n+         * be used.\n+         */\n+        DYNAMIC,\n+\n+        /**\n+         * Value that indicates that the static declared type is to\n+         * be used.\n+         */\n+        STATIC\n+        ;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/JsonTypeIdResolver.java\n+package com.fasterxml.jackson.databind.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Annotation that can be used to plug a custom type identifier handler\n+ * ({@link TypeIdResolver})\n+ * to be used by\n+ * {@link com.fasterxml.jackson.databind.TypeSerializer}s\n+ * and {@link com.fasterxml.jackson.databind.TypeDeserializer}s\n+ * for converting between java types and type id included in JSON content.\n+ * In simplest cases this can be a simple class with static mapping between\n+ * type names and matching classes.\n+ * \n+ * @author tatu\n+ * @since 1.5\n+ */\n+@Target({ElementType.TYPE})\n+@Retention(RetentionPolicy.RUNTIME)\n+@JacksonAnnotation\n+public @interface JsonTypeIdResolver\n+{\n+    /**\n+     * Defines implementation class of {@link TypeIdResolver} to use for\n+     * converting between external type id (type name) and actual\n+     * type of object.\n+     */\n+    public Class<? extends TypeIdResolver> value();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/JsonTypeResolver.java\n+package com.fasterxml.jackson.databind.annotate;\n+\n+import java.lang.annotation.*;\n+\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+\n+/**\n+ * Annotation that can be used to explicitly define custom resolver\n+ * used for handling serialization and deserialization of type information,\n+ * needed for handling of polymorphic types (or sometimes just for linking\n+ * abstract types to concrete types)\n+ */\n+@Target({ElementType.TYPE})\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonTypeResolver\n+{\n+    /**\n+     * Defines implementation class of {@link TypeResolverBuilder} which is used to construct\n+     * actual {@link com.fasterxml.jackson.databind.TypeDeserializer} and {@link com.fasterxml.jackson.databind.TypeDeserializer}\n+     * instances that handle reading and writing addition type information needed to support polymorphic\n+     * deserialization.\n+     */\n+    public Class<? extends TypeResolverBuilder<?>> value();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/JsonValueInstantiator.java\n+package com.fasterxml.jackson.databind.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+\n+/**\n+ * Annotation that can be used to indicate a {@link ValueInstantiator} to use\n+ * for creating instances of specified type.\n+ * \n+ * @since 1.9\n+ */\n+@Target(ElementType.TYPE)\n+@Retention(RetentionPolicy.RUNTIME)\n+@com.fasterxml.jackson.annotation.JacksonAnnotation\n+public @interface JsonValueInstantiator\n+{\n+    /**\n+     * @return  {@link ValueInstantiator} to use for annotated type\n+     */\n+    public Class<? extends ValueInstantiator> value();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/JsonView.java\n+package com.fasterxml.jackson.databind.annotate;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+\n+/**\n+ * Annotation used for indicating view(s) that the property\n+ * that is defined by method or field annotated is part of.\n+ *<p>\n+ * An example annotation would be:\n+ *<pre>\n+ *  \\@JsonView(BasicView.class)\n+ *</pre>\n+ * which would specify that property annotated would be included\n+ * when processing (serializing, deserializing) View identified\n+ * by <code>BasicView.class</code> (or its sub-class).\n+ * If multiple View class identifiers are included, property will\n+ * be part of all of them.\n+ *\n+ * @since 1.4\n+ */\n+\n+@Target({ElementType.METHOD, ElementType.FIELD})\n+@Retention(RetentionPolicy.RUNTIME)\n+@JacksonAnnotation\n+public @interface JsonView {\n+    /**\n+     * View or views that annotated element is part of. Views are identified\n+     * by classes, and use expected class inheritance relationship: child\n+     * views contain all elements parent views have, for example.\n+     */\n+    public Class<?>[] value() default { };\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/NoClass.java\n+package com.fasterxml.jackson.databind.annotate;\n+\n+/**\n+ * Marker class used with annotations to indicate \"no class\". This is\n+ * a silly but necessary work-around -- annotations can not take nulls\n+ * as either default or explicit values. Hence for class values we must\n+ * explicitly use a bogus placeholder to denote equivalent of\n+ * \"no class\" (for which 'null' is usually the natural choice).\n+ *<p>\n+ * Note before version 1.4, this marker class was under\n+ * \"org.codehaus.jackson.annotate\". However, since it is only used\n+ * by annotations in \"org.codehaus.jackson.map.annotate\" (and not externally\n+ * exposed), it was moved to that package as of version 1.5.\n+ */\n+public final class NoClass\n+{\n+    private NoClass() { }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/package-info.java\n+/**\n+ * Annotations that directly depend on Mapper classes (not just\n+ * Jackson core) and are used for configuring Data Mapping functionality.\n+ */\n+package com.fasterxml.jackson.databind.annotate;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+\n+\n+/**\n+ * Deserializer only used for abstract types used as placeholders during polymorphic\n+ * type handling deserialization. If so, there is no real deserializer associated\n+ * with nominal type, just {@link TypeDeserializer}; and any calls that do not\n+ * pass such resolver will result in an error.\n+ * \n+ * @author tatu\n+ * \n+ * @since 1.6\n+ */\n+public class AbstractDeserializer\n+    extends JsonDeserializer<Object>\n+{\n+    protected final JavaType _baseType;\n+    \n+    public AbstractDeserializer(JavaType bt)\n+    {\n+        _baseType = bt;\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* As per [JACKSON-417], there is a chance we might be \"native\" types (String, Boolean,\n+         * Integer), which do not include any type information...\n+         */\n+        switch (jp.getCurrentToken()) {\n+        /* First, so-called \"native\" types (ones that map\n+         * naturally and thus do not need or use type ids)\n+         */\n+        case VALUE_STRING:\n+            return jp.getText();\n+\n+        case VALUE_NUMBER_INT:\n+            // For [JACKSON-100], see above:\n+            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                return jp.getBigIntegerValue();\n+            }\n+            return jp.getIntValue();\n+\n+        case VALUE_NUMBER_FLOAT:\n+            // For [JACKSON-72], see above\n+            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                return jp.getDecimalValue();\n+            }\n+            return Double.valueOf(jp.getDoubleValue());\n+\n+        case VALUE_TRUE:\n+            return Boolean.TRUE;\n+        case VALUE_FALSE:\n+            return Boolean.FALSE;\n+        case VALUE_EMBEDDED_OBJECT:\n+            return jp.getEmbeddedObject();\n+\n+        case VALUE_NULL: // should not get this far really but...\n+            return null;\n+\n+        case START_ARRAY:\n+            /* 11-Feb-2011, tatu: Uh. Given that we know very little about the type\n+             *   here, we can't be sure but it sure looks like we must have used\n+             *   \"As.WRAPPER_ARRAY\" here. This will NOT work properly if someone\n+             *   tries to use \"As.WRAPPER_OBJECT\"; but let's tackle one issue\n+             *   at a time. See [JACKSON-485] for an example of where this fix\n+             *   is needed.\n+             */\n+            return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n+\n+            /*\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+             */\n+        }\n+\n+        // should we call 'fromAny' or 'fromObject'? We should get an object, for abstract types, right?\n+        // 11-Feb-2011: not necessarily; for example, when serialize Enums that implement an interface... *sigh*\n+        //return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n+\n+        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+    }\n+\n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        // no can do:\n+        throw ctxt.instantiationException(_baseType.getRawClass(), \"abstract types can only be instantiated with additional type information\");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.std.AtomicReferenceDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.CollectionDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.EnumDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.EnumMapDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.EnumSetDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.JsonNodeDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.MapDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.ObjectArrayDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.PrimitiveArrayDeserializers;\n+import com.fasterxml.jackson.databind.deser.std.StringCollectionDeserializer;\n+import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.type.*;\n+import com.fasterxml.jackson.databind.util.EnumResolver;\n+\n+\n+/**\n+ * Abstract factory base class that can provide deserializers for standard\n+ * JDK classes, including collection classes and simple heuristics for\n+ * \"upcasting\" commmon collection interface types\n+ * (such as {@link java.util.Collection}).\n+ *<p>\n+ * Since all simple deserializers are eagerly instantiated, and there is\n+ * no additional introspection or customizability of these types,\n+ * this factory is stateless.\n+ */\n+public abstract class BasicDeserializerFactory\n+    extends DeserializerFactory\n+{\n+    /**\n+     * We will pre-create serializers for common non-structured\n+     * (that is things other than Collection, Map or array)\n+     * types. These need not go through factory.\n+     */\n+    final static HashMap<ClassKey, JsonDeserializer<Object>> _simpleDeserializers = StdDeserializers.constructAll();\n+    \n+    /* We do some defaulting for abstract Map classes and\n+     * interfaces, to avoid having to use exact types or annotations in\n+     * cases where the most common concrete Maps will do.\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    final static HashMap<String, Class<? extends Map>> _mapFallbacks =\n+        new HashMap<String, Class<? extends Map>>();\n+    static {\n+        _mapFallbacks.put(Map.class.getName(), LinkedHashMap.class);\n+        _mapFallbacks.put(ConcurrentMap.class.getName(), ConcurrentHashMap.class);\n+        _mapFallbacks.put(SortedMap.class.getName(), TreeMap.class);\n+\n+        /* 11-Jan-2009, tatu: Let's see if we can still add support for\n+         *    JDK 1.6 interfaces, even if we run on 1.5. Just need to be\n+         *    more careful with typos, since compiler won't notice any\n+         *    problems...\n+         */\n+        _mapFallbacks.put(\"java.util.NavigableMap\", TreeMap.class);\n+        try {\n+            Class<?> key = Class.forName(\"java.util.ConcurrentNavigableMap\");\n+            Class<?> value = Class.forName(\"java.util.ConcurrentSkipListMap\");\n+            @SuppressWarnings(\"unchecked\")\n+                Class<? extends Map<?,?>> mapValue = (Class<? extends Map<?,?>>) value;\n+            _mapFallbacks.put(key.getName(), mapValue);\n+        } catch (ClassNotFoundException cnfe) { // occurs on 1.5\n+        }\n+    }\n+\n+    /* We do some defaulting for abstract Collection classes and\n+     * interfaces, to avoid having to use exact types or annotations in\n+     * cases where the most common concrete Collection will do.\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    final static HashMap<String, Class<? extends Collection>> _collectionFallbacks =\n+        new HashMap<String, Class<? extends Collection>>();\n+    static {\n+        _collectionFallbacks.put(Collection.class.getName(), ArrayList.class);\n+        _collectionFallbacks.put(List.class.getName(), ArrayList.class);\n+        _collectionFallbacks.put(Set.class.getName(), HashSet.class);\n+        _collectionFallbacks.put(SortedSet.class.getName(), TreeSet.class);\n+        _collectionFallbacks.put(Queue.class.getName(), LinkedList.class);\n+\n+        /* 11-Jan-2009, tatu: Let's see if we can still add support for\n+         *    JDK 1.6 interfaces, even if we run on 1.5. Just need to be\n+         *    more careful with typos, since compiler won't notice any\n+         *    problems...\n+         */\n+        _collectionFallbacks.put(\"java.util.Deque\", LinkedList.class);\n+        _collectionFallbacks.put(\"java.util.NavigableSet\", TreeSet.class);\n+    }\n+\n+    /**\n+     * And finally, we have special array deserializers for primitive\n+     * array types\n+     */\n+    protected final static HashMap<JavaType,JsonDeserializer<Object>> _arrayDeserializers\n+        = PrimitiveArrayDeserializers.getAll();\n+\n+    /**\n+     * To support external/optional deserializers, we'll use this helper class\n+     * (as per [JACKSON-386])\n+     */\n+    protected OptionalHandlerFactory optionalHandlers = OptionalHandlerFactory.instance;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life cycle\n+    /**********************************************************\n+     */\n+\n+    protected BasicDeserializerFactory() { }\n+\n+    // can't be implemented quite here\n+    @Override\n+    public abstract DeserializerFactory withConfig(DeserializerFactory.Config config);\n+    \n+    /*\n+    /**********************************************************\n+    /* Methods for sub-classes to override to provide\n+    /* custom deserializers (since 1.7)\n+    /**********************************************************\n+     */\n+    \n+    protected abstract JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config,\n+            DeserializerProvider p, BeanProperty property,\n+            TypeDeserializer elementTypeDeser, JsonDeserializer<?> elementDeser)\n+        throws JsonMappingException;\n+    \n+    protected abstract JsonDeserializer<?> _findCustomCollectionDeserializer(\n+            CollectionType type, DeserializationConfig config,\n+            DeserializerProvider p, BasicBeanDescription beanDesc, BeanProperty property,\n+            TypeDeserializer elementTypeDeser, JsonDeserializer<?> elementDeser)\n+        throws JsonMappingException;\n+\n+    protected abstract JsonDeserializer<?> _findCustomCollectionLikeDeserializer(\n+            CollectionLikeType type, DeserializationConfig config,\n+            DeserializerProvider p, BasicBeanDescription beanDesc, BeanProperty property,\n+            TypeDeserializer elementTypeDeser, JsonDeserializer<?> elementDeser)\n+        throws JsonMappingException;\n+    \n+    protected abstract JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type,\n+            DeserializationConfig config, BasicBeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException;\n+\n+    protected abstract JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n+            DeserializationConfig config,\n+            DeserializerProvider p, BasicBeanDescription beanDesc, BeanProperty property,\n+            KeyDeserializer keyDeser,\n+            TypeDeserializer elementTypeDeser, JsonDeserializer<?> elementDeser)\n+        throws JsonMappingException;\n+\n+    protected abstract JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n+            DeserializationConfig config,\n+            DeserializerProvider p, BasicBeanDescription beanDesc, BeanProperty property,\n+            KeyDeserializer keyDeser,\n+            TypeDeserializer elementTypeDeser, JsonDeserializer<?> elementDeser)\n+        throws JsonMappingException;\n+    \n+    protected abstract JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n+            DeserializationConfig config, BeanProperty property)\n+        throws JsonMappingException;\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonDeserializerFactory impl (partial)\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public abstract ValueInstantiator findValueInstantiator(DeserializationConfig config,\n+            BasicBeanDescription beanDesc)\n+        throws JsonMappingException;\n+\n+    @Override\n+    public abstract JavaType mapAbstractType(DeserializationConfig config, JavaType type)\n+            throws JsonMappingException;\n+    \n+    @Override\n+    public JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config, DeserializerProvider p,\n+            ArrayType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JavaType elemType = type.getContentType();\n+        \n+        // Very first thing: is deserializer hard-coded for elements?\n+        JsonDeserializer<Object> contentDeser = elemType.getValueHandler();\n+        if (contentDeser == null) {\n+            // Maybe special array type, such as \"primitive\" arrays (int[] etc)\n+            JsonDeserializer<?> deser = _arrayDeserializers.get(elemType);\n+            if (deser != null) {\n+                /* 23-Nov-2010, tatu: Although not commonly needed, ability to override\n+                 *   deserializers for all types (including primitive arrays) is useful\n+                 *   so let's allow this\n+                 */\n+                JsonDeserializer<?> custom = _findCustomArrayDeserializer(type, config, p, property, null, null);\n+                if (custom != null) {\n+                    return custom;\n+                }\n+                return deser;\n+            }\n+            // If not, generic one:\n+            if (elemType.isPrimitive()) { // sanity check\n+                throw new IllegalArgumentException(\"Internal error: primitive type (\"+type+\") passed, no array deserializer found\");\n+            }\n+        }\n+        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n+        TypeDeserializer elemTypeDeser = elemType.getTypeHandler();\n+        // but if not, may still be possible to find:\n+        if (elemTypeDeser == null) {\n+            elemTypeDeser = findTypeDeserializer(config, elemType, property);\n+        }\n+        // 23-Nov-2010, tatu: Custom array deserializer?\n+        JsonDeserializer<?> custom = _findCustomArrayDeserializer(type, config, p, property, elemTypeDeser, contentDeser);\n+        if (custom != null) {\n+            return custom;\n+        }\n+        \n+        if (contentDeser == null) {\n+            // 'null' -> arrays have no referring fields\n+            contentDeser = p.findValueDeserializer(config, elemType, property);\n+        }\n+        return new ObjectArrayDeserializer(type, contentDeser, elemTypeDeser);\n+    }\n+    \n+    @Override\n+    public JsonDeserializer<?> createCollectionDeserializer(DeserializationConfig config, DeserializerProvider p,\n+            CollectionType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // First: global defaulting:\n+        type = (CollectionType) mapAbstractType(config, type);\n+\n+        Class<?> collectionClass = type.getRawClass();\n+        BasicBeanDescription beanDesc = config.introspectForCreation(type);\n+        // Explicit deserializer to use? (@JsonDeserialize.using)\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n+        if (deser != null) {\n+            return deser;\n+        }\n+        // If not, any type modifiers? (@JsonDeserialize.as)\n+        type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), type, null);\n+\n+        JavaType contentType = type.getContentType();\n+        // Very first thing: is deserializer hard-coded for elements?\n+        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n+\n+        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n+        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n+        // but if not, may still be possible to find:\n+        if (contentTypeDeser == null) {\n+            contentTypeDeser = findTypeDeserializer(config, contentType, property);\n+        }\n+\n+        // 23-Nov-2010, tatu: Custom deserializer?\n+        JsonDeserializer<?> custom = _findCustomCollectionDeserializer(type, config, p, beanDesc, property,\n+                contentTypeDeser, contentDeser);\n+        if (custom != null) {\n+            return custom;\n+        }\n+        \n+        if (contentDeser == null) { // not defined by annotation\n+            // One special type: EnumSet:\n+            if (EnumSet.class.isAssignableFrom(collectionClass)) {\n+                return new EnumSetDeserializer(constructEnumResolver(contentType.getRawClass(), config));\n+            }\n+            // But otherwise we can just use a generic value deserializer:\n+            // 'null' -> collections have no referring fields\n+            contentDeser = p.findValueDeserializer(config, contentType, property);            \n+        }\n+        \n+        /* One twist: if we are being asked to instantiate an interface or\n+         * abstract Collection, we need to either find something that implements\n+         * the thing, or give up.\n+         *\n+         * Note that we do NOT try to guess based on secondary interfaces\n+         * here; that would probably not work correctly since casts would\n+         * fail later on (as the primary type is not the interface we'd\n+         * be implementing)\n+         */\n+        if (type.isInterface() || type.isAbstract()) {\n+            @SuppressWarnings({ \"rawtypes\" })\n+            Class<? extends Collection> fallback = _collectionFallbacks.get(collectionClass.getName());\n+            if (fallback == null) {\n+                throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n+            }\n+            collectionClass = fallback;\n+            type = (CollectionType) config.constructSpecializedType(type, collectionClass);\n+            // But if so, also need to re-check creators...\n+            beanDesc = config.introspectForCreation(type);\n+        }\n+        ValueInstantiator inst = findValueInstantiator(config, beanDesc);\n+        // 13-Dec-2010, tatu: Can use more optimal deserializer if content type is String, so:\n+        if (contentType.getRawClass() == String.class) {\n+            // no value type deserializer because Strings are one of natural/native types:\n+            return new StringCollectionDeserializer(type, contentDeser, inst);\n+        }\n+        return new CollectionDeserializer(type, contentDeser, contentTypeDeser, inst);\n+    }\n+\n+    // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n+    @Override\n+    public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationConfig config,\n+            DeserializerProvider p, CollectionLikeType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // First: global defaulting:\n+        type = (CollectionLikeType) mapAbstractType(config, type);\n+\n+        Class<?> collectionClass = type.getRawClass();\n+        BasicBeanDescription beanDesc = config.introspectClassAnnotations(collectionClass);\n+        // Explicit deserializer to use? (@JsonDeserialize.using)\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n+        if (deser != null) {\n+            return deser;\n+        }\n+        // If not, any type modifiers? (@JsonDeserialize.as)\n+        type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), type, null);\n+\n+        JavaType contentType = type.getContentType();\n+        // Very first thing: is deserializer hard-coded for elements?\n+        JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n+\n+        // Then optional type info (1.5): if type has been resolved, we may already know type deserializer:\n+        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n+        // but if not, may still be possible to find:\n+        if (contentTypeDeser == null) {\n+            contentTypeDeser = findTypeDeserializer(config, contentType, property);\n+        }\n+        return _findCustomCollectionLikeDeserializer(type, config, p, beanDesc, property,\n+                contentTypeDeser, contentDeser);\n+    }\n+    \n+    @Override\n+    public JsonDeserializer<?> createMapDeserializer(DeserializationConfig config, DeserializerProvider p,\n+            MapType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // First: global defaulting:\n+        type = (MapType) mapAbstractType(config, type);\n+\n+        BasicBeanDescription beanDesc = config.introspectForCreation(type);\n+        // Explicit deserializer to use? (@JsonDeserialize.using)\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n+        if (deser != null) {\n+            return deser;\n+        }\n+        // If not, any type modifiers? (@JsonDeserialize.as)\n+        type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), type, null);        \n+        JavaType keyType = type.getKeyType();\n+        JavaType contentType = type.getContentType();\n+        \n+        // First: is there annotation-specified deserializer for values?\n+        @SuppressWarnings(\"unchecked\")\n+        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n+        \n+        // Ok: need a key deserializer (null indicates 'default' here)\n+        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n+        if (keyDes == null) {\n+            keyDes = p.findKeyDeserializer(config, keyType, property);\n+        }\n+        // Then optional type info (1.5); either attached to type, or resolve separately:\n+        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n+        // but if not, may still be possible to find:\n+        if (contentTypeDeser == null) {\n+            contentTypeDeser = findTypeDeserializer(config, contentType, property);\n+        }\n+\n+        // 23-Nov-2010, tatu: Custom deserializer?\n+        JsonDeserializer<?> custom = _findCustomMapDeserializer(type, config, p, beanDesc, property,\n+                keyDes, contentTypeDeser, contentDeser);\n+\n+        if (custom != null) {\n+            return custom;\n+        }\n+\n+        if (contentDeser == null) { // nope...\n+            // 'null' -> maps have no referring fields\n+            contentDeser = p.findValueDeserializer(config, contentType, property);\n+        }\n+        /* Value handling is identical for all,\n+         * but EnumMap requires special handling for keys\n+         */\n+        Class<?> mapClass = type.getRawClass();\n+        if (EnumMap.class.isAssignableFrom(mapClass)) {\n+            Class<?> kt = keyType.getRawClass();\n+            if (kt == null || !kt.isEnum()) {\n+                throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n+            }\n+            return new EnumMapDeserializer(constructEnumResolver(kt, config), contentDeser);\n+        }\n+\n+        // Otherwise, generic handler works ok.\n+\n+        /* But there is one more twist: if we are being asked to instantiate\n+         * an interface or abstract Map, we need to either find something\n+         * that implements the thing, or give up.\n+         *\n+         * Note that we do NOT try to guess based on secondary interfaces\n+         * here; that would probably not work correctly since casts would\n+         * fail later on (as the primary type is not the interface we'd\n+         * be implementing)\n+         */\n+        if (type.isInterface() || type.isAbstract()) {\n+            @SuppressWarnings(\"rawtypes\")\n+            Class<? extends Map> fallback = _mapFallbacks.get(mapClass.getName());\n+            if (fallback == null) {\n+                throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Map type \"+type);\n+            }\n+            mapClass = fallback;\n+            type = (MapType) config.constructSpecializedType(type, mapClass);\n+            // But if so, also need to re-check creators...\n+            beanDesc = config.introspectForCreation(type);\n+        }\n+        ValueInstantiator inst = findValueInstantiator(config, beanDesc);\n+        MapDeserializer md = new MapDeserializer(type, inst, keyDes, contentDeser, contentTypeDeser);\n+        md.setIgnorableProperties(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()));\n+        return md;\n+    }\n+\n+    // Copied almost verbatim from \"createMapDeserializer\" -- should try to share more code\n+    @Override\n+    public JsonDeserializer<?> createMapLikeDeserializer(DeserializationConfig config,\n+            DeserializerProvider p, MapLikeType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // First: global defaulting:\n+        type = (MapLikeType) mapAbstractType(config, type);\n+        BasicBeanDescription beanDesc = config.introspectForCreation(type);\n+        // Explicit deserializer to use? (@JsonDeserialize.using)\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n+        if (deser != null) {\n+            return deser;\n+        }\n+        // If not, any type modifiers? (@JsonDeserialize.as)\n+        type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), type, null);        \n+        JavaType keyType = type.getKeyType();\n+        JavaType contentType = type.getContentType();\n+        \n+        // First: is there annotation-specified deserializer for values?\n+        @SuppressWarnings(\"unchecked\")\n+        JsonDeserializer<Object> contentDeser = (JsonDeserializer<Object>) contentType.getValueHandler();\n+        \n+        // Ok: need a key deserializer (null indicates 'default' here)\n+        KeyDeserializer keyDes = (KeyDeserializer) keyType.getValueHandler();\n+        if (keyDes == null) {\n+            keyDes = p.findKeyDeserializer(config, keyType, property);\n+        }\n+        // Then optional type info (1.5); either attached to type, or resolve separately:\n+        TypeDeserializer contentTypeDeser = contentType.getTypeHandler();\n+        // but if not, may still be possible to find:\n+        if (contentTypeDeser == null) {\n+            contentTypeDeser = findTypeDeserializer(config, contentType, property);\n+        }\n+        return _findCustomMapLikeDeserializer(type, config, p, beanDesc, property,\n+                keyDes, contentTypeDeser, contentDeser);\n+    }\n+    \n+    /**\n+     * Factory method for constructing serializers of {@link Enum} types.\n+     */\n+    @Override\n+    public JsonDeserializer<?> createEnumDeserializer(DeserializationConfig config, DeserializerProvider p,\n+            JavaType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        /* 18-Feb-2009, tatu: Must first check if we have a class annotation\n+         *    that should override default deserializer\n+         */\n+        BasicBeanDescription beanDesc = config.introspectForCreation(type);\n+        JsonDeserializer<?> des = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n+        if (des != null) {\n+            return des;\n+        }\n+        Class<?> enumClass = type.getRawClass();\n+        // 23-Nov-2010, tatu: Custom deserializer?\n+        JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc, property);\n+        if (custom != null) {\n+            return custom;\n+        }\n+\n+        // [JACKSON-193] May have @JsonCreator for static factory method:\n+        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n+            if (config.getAnnotationIntrospector().hasCreatorAnnotation(factory)) {\n+                int argCount = factory.getParameterCount();\n+                if (argCount == 1) {\n+                    Class<?> returnType = factory.getRawType();\n+                    // usually should be class, but may be just plain Enum<?> (for Enum.valueOf()?)\n+                    if (returnType.isAssignableFrom(enumClass)) {\n+                        return EnumDeserializer.deserializerForCreator(config, enumClass, factory);\n+                    }\n+                }\n+                throw new IllegalArgumentException(\"Unsuitable method (\"+factory+\") decorated with @JsonCreator (for Enum type \"\n+                        +enumClass.getName()+\")\");\n+            }\n+        }\n+        return new EnumDeserializer(constructEnumResolver(enumClass, config));\n+    }\n+\n+    @Override\n+    public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config, DeserializerProvider p,\n+            JavaType nodeType, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends JsonNode> nodeClass = (Class<? extends JsonNode>) nodeType.getRawClass();\n+        // 23-Nov-2010, tatu: Custom deserializer?\n+        JsonDeserializer<?> custom = _findCustomTreeNodeDeserializer(nodeClass, config, property);\n+        if (custom != null) {\n+            return custom;\n+        }\n+        return JsonNodeDeserializer.getDeserializer(nodeClass);\n+    }\n+\n+    /**\n+     * Method called by {@link BeanDeserializerFactory} to see if there might be a standard\n+     * deserializer registered for given type.\n+     * \n+     * @since 1.8\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonDeserializer<Object> findStdBeanDeserializer(DeserializationConfig config,\n+            DeserializerProvider p, JavaType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        Class<?> cls = type.getRawClass();\n+        // note: we do NOT check for custom deserializers here; that's for sub-class to do\n+        JsonDeserializer<Object> deser = _simpleDeserializers.get(new ClassKey(cls));\n+        if (deser != null) {\n+            return deser;\n+        }\n+        \n+        // [JACKSON-283]: AtomicReference is a rather special type...\n+        if (AtomicReference.class.isAssignableFrom(cls)) {\n+            // Must find parameterization\n+            TypeFactory tf = config.getTypeFactory();\n+            JavaType[] params = tf.findTypeParameters(type, AtomicReference.class);\n+            JavaType referencedType;\n+            if (params == null || params.length < 1) { // untyped (raw)\n+                referencedType = TypeFactory.unknownType();\n+            } else {\n+                referencedType = params[0];\n+            }\n+            \n+            JsonDeserializer<?> d2 = new AtomicReferenceDeserializer(referencedType, property);\n+            return (JsonDeserializer<Object>)d2;\n+        }\n+        // [JACKSON-386]: External/optional type handlers are handled somewhat differently\n+        JsonDeserializer<?> d = optionalHandlers.findDeserializer(type, config, p);\n+        if (d != null) {\n+            return (JsonDeserializer<Object>)d;\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n+    public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        Class<?> cls = baseType.getRawClass();\n+        BasicBeanDescription bean = config.introspectClassAnnotations(cls);\n+        AnnotatedClass ac = bean.getClassInfo();\n+        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+\n+        /* Ok: if there is no explicit type info handler, we may want to\n+         * use a default. If so, config object knows what to use.\n+         */\n+        Collection<NamedType> subtypes = null;\n+        if (b == null) {\n+            b = config.getDefaultTyper(baseType);\n+            if (b == null) {\n+                return null;\n+            }\n+        } else {\n+            subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai);\n+        }\n+        // [JACKSON-505]: May need to figure out default implementation, if none found yet\n+        // (note: check for abstract type is not 100% mandatory, more of an optimization)\n+        if ((b.getDefaultImpl() == null) && baseType.isAbstract()) {\n+            JavaType defaultType = mapAbstractType(config, baseType);\n+            if (defaultType != null && defaultType.getRawClass() != baseType.getRawClass()) {\n+                b = b.defaultImpl(defaultType.getRawClass());\n+            }\n+        }\n+        return b.buildTypeDeserializer(config, baseType, subtypes, property);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to create a type information deserializer for values of\n+     * given non-container property, if one is needed.\n+     * If not needed (no polymorphic handling configured for property), should return null.\n+     *<p>\n+     * Note that this method is only called for non-container bean properties,\n+     * and not for values in container types or root values (or container properties)\n+     *\n+     * @param baseType Declared base type of the value to deserializer (actual\n+     *    deserializer type will be this type or its subtype)\n+     * \n+     * @return Type deserializer to use for given base type, if one is needed; null if not.\n+     * \n+     * @since 1.5\n+     */\n+    public TypeDeserializer findPropertyTypeDeserializer(DeserializationConfig config, JavaType baseType,\n+           AnnotatedMember annotated, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, annotated, baseType);        \n+        // Defaulting: if no annotations on member, check value class\n+        if (b == null) {\n+            return findTypeDeserializer(config, baseType, property);\n+        }\n+        // but if annotations found, may need to resolve subtypes:\n+        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(annotated, config, ai);\n+        return b.buildTypeDeserializer(config, baseType, subtypes, property);\n+    }\n+    \n+    /**\n+     * Method called to find and create a type information deserializer for values of\n+     * given container (list, array, map) property, if one is needed.\n+     * If not needed (no polymorphic handling configured for property), should return null.\n+     *<p>\n+     * Note that this method is only called for container bean properties,\n+     * and not for values in container types or root values (or non-container properties)\n+     * \n+     * @param containerType Type of property; must be a container type\n+     * @param propertyEntity Field or method that contains container property\n+     * \n+     * @since 1.5\n+     */    \n+    public TypeDeserializer findPropertyContentTypeDeserializer(DeserializationConfig config, JavaType containerType,\n+            AnnotatedMember propertyEntity, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, propertyEntity, containerType);        \n+        JavaType contentType = containerType.getContentType();\n+        // Defaulting: if no annotations on member, check class\n+        if (b == null) {\n+            return findTypeDeserializer(config, contentType, property);\n+        }\n+        // but if annotations found, may need to resolve subtypes:\n+        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(propertyEntity, config, ai);\n+        return b.buildTypeDeserializer(config, contentType, subtypes, property);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods, value/content/key type introspection\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method called to check if a class or method\n+     * has annotation that tells which class to use for deserialization.\n+     * Returns null if no such annotation found.\n+     */\n+    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationConfig config,\n+            Annotated ann, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        Object deserDef = config.getAnnotationIntrospector().findDeserializer(ann);\n+        if (deserDef != null) {\n+            return _constructDeserializer(config, ann, property, deserDef);\n+        }\n+        return null;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    JsonDeserializer<Object> _constructDeserializer(DeserializationConfig config, Annotated ann, BeanProperty property,\n+            Object deserDef)\n+        throws JsonMappingException\n+    {\n+        if (deserDef instanceof JsonDeserializer) {\n+            JsonDeserializer<Object> deser = (JsonDeserializer<Object>) deserDef;\n+            // related to [JACKSON-569], need contextualization:\n+            if (deser instanceof ContextualDeserializer<?>) {\n+                deser = (JsonDeserializer<Object>)((ContextualDeserializer<?>) deser).createContextual(config, property);\n+            }\n+            return deser;\n+        }\n+        /* Alas, there's no way to force return type of \"either class\n+         * X or Y\" -- need to throw an exception after the fact\n+         */\n+        if (!(deserDef instanceof Class)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector returned deserializer definition of type \"+deserDef.getClass().getName()+\"; expected type JsonDeserializer or Class<JsonDeserializer> instead\");\n+        }\n+        Class<? extends JsonDeserializer<?>> deserClass = (Class<? extends JsonDeserializer<?>>) deserDef;\n+        if (!JsonDeserializer.class.isAssignableFrom(deserClass)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()+\"; expected Class<JsonDeserializer>\");\n+        }\n+        JsonDeserializer<Object> deser = config.deserializerInstance(ann, deserClass);\n+        // related to [JACKSON-569], need contextualization:\n+        if (deser instanceof ContextualDeserializer<?>) {\n+            deser = (JsonDeserializer<Object>)((ContextualDeserializer<?>) deser).createContextual(config, property);\n+        }\n+        return deser;\n+    }\n+\n+    /**\n+     * Method called to see if given method has annotations that indicate\n+     * a more specific type than what the argument specifies.\n+     * If annotations are present, they must specify compatible Class;\n+     * instance of which can be assigned using the method. This means\n+     * that the Class has to be raw class of type, or its sub-class\n+     * (or, implementing class if original Class instance is an interface).\n+     *\n+     * @param a Method or field that the type is associated with\n+     * @param type Type derived from the setter argument\n+     * @param propName Name of property that refers to type, if any; null\n+     *   if no property information available (when modify type declaration\n+     *   of a class, for example)\n+     *\n+     * @return Original type if no annotations are present; or a more\n+     *   specific type derived from it if type annotation(s) was found\n+     *\n+     * @throws JsonMappingException if invalid annotation is found\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"deprecation\" })\n+    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationConfig config,\n+            Annotated a, T type, String propName)\n+        throws JsonMappingException\n+    {\n+        // first: let's check class for the instance itself:\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        Class<?> subclass = intr.findDeserializationType(a, type, propName);\n+        if (subclass != null) {\n+            try {\n+                type = (T) type.narrowBy(subclass);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n+            }\n+        }\n+\n+        // then key class\n+        if (type.isContainerType()) {\n+            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n+            if (keyClass != null) {\n+                // illegal to use on non-Maps\n+                if (!(type instanceof MapLikeType)) {\n+                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n+                }\n+                try {\n+                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n+                }\n+            }\n+            JavaType keyType = type.getKeyType();\n+            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n+             *   (not 100% why or how, but this does seem to get called more than once, which\n+             *   is not good: for now, let's just avoid errors)\n+             */\n+            if (keyType != null && keyType.getValueHandler() == null) {\n+                Class<? extends KeyDeserializer> kdClass = intr.findKeyDeserializer(a);\n+                if (kdClass != null && kdClass != KeyDeserializer.None.class) {\n+                    KeyDeserializer kd = config.keyDeserializerInstance(a, kdClass);\n+                    // !!! TODO: For 2.0, change to use this instead:\n+                    /*\n+                    type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                    keyType = type.getKeyType(); // just in case it's used below\n+                    */\n+                    keyType.setValueHandler(kd);\n+                }\n+            }            \n+            \n+            // and finally content class; only applicable to structured types\n+            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType(), propName);\n+            if (cc != null) {\n+                try {\n+                    type = (T) type.narrowContentsBy(cc);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n+                }\n+            }\n+            // ... as well as deserializer for contents:\n+            JavaType contentType = type.getContentType();\n+            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n+                Class<? extends JsonDeserializer<?>> cdClass = intr.findContentDeserializer(a);\n+                if (cdClass != null && cdClass != JsonDeserializer.None.class) {\n+                    JsonDeserializer<Object> cd = config.deserializerInstance(a, cdClass);\n+                    // !!! TODO: For 2.0, change to use this instead:\n+                    /*\n+                    type = (T) type.withContentValueHandler(cd);\n+                    */\n+                    type.getContentType().setValueHandler(cd);\n+                }\n+            }\n+        }\n+        return type;\n+    }\n+\n+    /**\n+     * Helper method used to resolve method return types and field\n+     * types. The main trick here is that the containing bean may\n+     * have type variable binding information (when deserializing\n+     * using generic type passed as type reference), which is\n+     * needed in some cases.\n+     *<p>\n+     * Starting with version 1.3, this method will also resolve instances\n+     * of key and content deserializers if defined by annotations.\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    protected JavaType resolveType(DeserializationConfig config,\n+            BasicBeanDescription beanDesc, JavaType type, AnnotatedMember member,\n+            BeanProperty property)                    \n+        throws JsonMappingException\n+    {\n+        // [JACKSON-154]: Also need to handle keyUsing, contentUsing\n+        if (type.isContainerType()) {\n+            AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+            JavaType keyType = type.getKeyType();\n+            if (keyType != null) {\n+                Class<? extends KeyDeserializer> kdClass = intr.findKeyDeserializer(member);\n+                if (kdClass != null && kdClass != KeyDeserializer.None.class) {\n+                    KeyDeserializer kd = config.keyDeserializerInstance(member, kdClass);\n+                    // !!! TODO: For 2.0, change to use this instead:\n+                    /*\n+                    type = ((MapLikeType) type).withKeyValueHandler(kd);\n+                    keyType = type.getKeyType(); // just in case it's used below\n+                    */\n+                    keyType.setValueHandler(kd);\n+                }\n+            }\n+            // and all container types have content types...\n+            Class<? extends JsonDeserializer<?>> cdClass = intr.findContentDeserializer(member);\n+            if (cdClass != null && cdClass != JsonDeserializer.None.class) {\n+                JsonDeserializer<Object> cd = config.deserializerInstance(member, cdClass);\n+                // !!! TODO: For 2.0, change to use this instead:\n+                /*\n+                type = type.withContentValueHandler(cd);\n+                */\n+                type.getContentType().setValueHandler(cd);\n+            }\n+            /* 04-Feb-2010, tatu: Need to figure out JAXB annotations that indicate type\n+             *    information to use for polymorphic members; and specifically types for\n+             *    collection values (contents).\n+             *    ... but only applies to members (fields, methods), not classes\n+             */\n+            if (member instanceof AnnotatedMember) {\n+            \tTypeDeserializer contentTypeDeser = findPropertyContentTypeDeserializer(config, type,\n+            \t       (AnnotatedMember) member, property);            \t\n+            \tif (contentTypeDeser != null) {\n+            \t    type = type.withContentTypeHandler(contentTypeDeser);\n+            \t}\n+            }\n+        }\n+    \tTypeDeserializer valueTypeDeser;\n+\n+        if (member instanceof AnnotatedMember) { // JAXB allows per-property annotations\n+            valueTypeDeser = findPropertyTypeDeserializer(config, type, (AnnotatedMember) member, property);\n+        } else { // classes just have Jackson annotations\n+            // probably only occurs if 'property' is null anyway\n+            valueTypeDeser = findTypeDeserializer(config, type, null);\n+        }\n+    \tif (valueTypeDeser != null) {\n+            type = type.withTypeHandler(valueTypeDeser);\n+    \t}\n+    \treturn type;\n+    }\n+    \n+    protected EnumResolver<?> constructEnumResolver(Class<?> enumClass, DeserializationConfig config)\n+    {\n+        // [JACKSON-212]: may need to use Enum.toString()\n+        if (config.isEnabled(DeserializationConfig.Feature.READ_ENUMS_USING_TO_STRING)) {\n+            return EnumResolver.constructUnsafeUsingToString(enumClass);\n+        }\n+        return EnumResolver.constructUnsafe(enumClass, config.getAnnotationIntrospector());\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.core.util.TokenBuffer;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JsonCachable;\n+import com.fasterxml.jackson.databind.deser.impl.*;\n+import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+\n+/**\n+ * Deserializer class that can deserialize instances of\n+ * arbitrary bean objects, usually from JSON Object structs,\n+ * but possibly also from simple types like String values.\n+ */\n+@JsonCachable\n+/* Because of costs associated with constructing bean deserializers,\n+ * they usually should be cached unlike other deserializer types.\n+ * But more importantly, it is important to be able to cache\n+ * bean serializers to handle cyclic references.\n+ */\n+public class BeanDeserializer\n+    extends StdDeserializer<Object>\n+    implements ResolvableDeserializer\n+{\n+    /*\n+    /**********************************************************\n+    /* Information regarding type being deserialized\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Class for which deserializer is built; used for accessing\n+     * annotations during resolution phase (see {@link #resolve}).\n+     */\n+    final protected AnnotatedClass _forClass;\n+    \n+    /**\n+     * Declared type of the bean this deserializer handles.\n+     */\n+    final protected JavaType _beanType;\n+\n+    /**\n+     * Property that contains value to be deserialized using\n+     * deserializer; mostly needed to find contextual annotations\n+     * for subtypes.\n+     * \n+     * @since 1.7\n+     */\n+    final protected BeanProperty _property;\n+    \n+    /*\n+    /**********************************************************\n+    /* Construction configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Object that handles details of constructing initial \n+     * bean value (to which bind data to), unless instance\n+     * is passed (via updateValue())\n+     */\n+    protected final ValueInstantiator _valueInstantiator;\n+    \n+    /**\n+     * Deserializer that is used iff delegate-based creator is\n+     * to be used for deserializing from JSON Object.\n+     */\n+    protected JsonDeserializer<Object> _delegateDeserializer;\n+    \n+    /**\n+     * If the bean needs to be instantiated using constructor\n+     * or factory method\n+     * that takes one or more named properties as argument(s),\n+     * this creator is used for instantiation.\n+     */\n+    protected final PropertyBasedCreator _propertyBasedCreator;\n+\n+    /**\n+     * Flag that is set to mark \"non-standard\" cases; where either\n+     * we use one of non-default creators, or there are unwrapped\n+     * values to consider.\n+     */\n+    protected boolean _nonStandardCreation;\n+    \n+    /*\n+    /**********************************************************\n+    /* Property information, setters\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Mapping of property names to properties, built when all properties\n+     * to use have been successfully resolved.\n+     * \n+     * @since 1.7\n+     */\n+    final protected BeanPropertyMap _beanProperties;\n+\n+    /**\n+     * List of {@link ValueInjector}s, if any injectable values are\n+     * expected by the bean; otherwise null.\n+     * This includes injectors used for injecting values via setters\n+     * and fields, but not ones passed through constructor parameters.\n+     * \n+     * @since 1.9\n+     */\n+    final protected ValueInjector[] _injectables;\n+    \n+    /**\n+     * Fallback setter used for handling any properties that are not\n+     * mapped to regular setters. If setter is not null, it will be\n+     * called once for each such property.\n+     */\n+    protected SettableAnyProperty _anySetter;\n+\n+    /**\n+     * In addition to properties that are set, we will also keep\n+     * track of recognized but ignorable properties: these will\n+     * be skipped without errors or warnings.\n+     */\n+    final protected HashSet<String> _ignorableProps;\n+\n+    /**\n+     * Flag that can be set to ignore and skip unknown properties.\n+     * If set, will not throw an exception for unknown properties.\n+     */\n+    final protected boolean _ignoreAllUnknown;\n+\n+    /**\n+     * We may also have one or more back reference fields (usually\n+     * zero or one).\n+     */\n+    final protected Map<String, SettableBeanProperty> _backRefs;\n+    \n+    /*\n+    /**********************************************************\n+    /* Related handlers\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Lazily constructed map used to contain deserializers needed\n+     * for polymorphic subtypes.\n+     */\n+    protected HashMap<ClassKey, JsonDeserializer<Object>> _subDeserializers;\n+\n+    /**\n+     * If one of properties has \"unwrapped\" value, we need separate\n+     * helper object\n+     * \n+     * @since 1.9\n+     */\n+    protected UnwrappedPropertyHandler _unwrappedPropertyHandler;\n+\n+    /**\n+     * Handler that we need iff any of properties uses external\n+     * type id.\n+     */\n+    protected ExternalTypeHandler _externalTypeIdHandler;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle, construction, initialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @deprecated (since 1.9) Use the constructor that takes {@link ValueInstantiator} instead\n+     */\n+    @Deprecated\n+    public BeanDeserializer(AnnotatedClass forClass, JavaType type, BeanProperty property,\n+            CreatorCollector creators,\n+            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n+            HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n+            SettableAnyProperty anySetter)\n+    {\n+        this(forClass, type, property,\n+                creators.constructValueInstantiator(null),\n+                properties, backRefs,\n+                ignorableProps, ignoreAllUnknown,\n+                anySetter, null);\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public BeanDeserializer(BeanDescription beanDesc, BeanProperty property,\n+            ValueInstantiator valueInstantiator,\n+            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n+            HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n+            SettableAnyProperty anySetter, List<ValueInjector> injectables)\n+    {\n+        this(beanDesc.getClassInfo(), beanDesc.getType(), property,\n+                valueInstantiator,\n+                properties, backRefs,\n+                ignorableProps, ignoreAllUnknown,\n+                anySetter, injectables);\n+    }\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    protected BeanDeserializer(AnnotatedClass forClass, JavaType type, BeanProperty property,\n+            ValueInstantiator valueInstantiator,\n+            BeanPropertyMap properties, Map<String, SettableBeanProperty> backRefs,\n+            HashSet<String> ignorableProps, boolean ignoreAllUnknown,\n+            SettableAnyProperty anySetter, List<ValueInjector> injectables)\n+    {\n+        super(type);\n+        _forClass = forClass;\n+        _beanType = type;\n+        _property = property;\n+\n+        _valueInstantiator = valueInstantiator;\n+        if (valueInstantiator.canCreateFromObjectWith()) {\n+            _propertyBasedCreator = new PropertyBasedCreator(valueInstantiator);\n+        } else {\n+            _propertyBasedCreator = null;\n+        }\n+        \n+        _beanProperties = properties;\n+        _backRefs = backRefs;\n+        _ignorableProps = ignorableProps;\n+        _ignoreAllUnknown = ignoreAllUnknown;\n+        _anySetter = anySetter;\n+        _injectables = (injectables == null || injectables.isEmpty()) ? null\n+                : injectables.toArray(new ValueInjector[injectables.size()]);\n+\n+        _nonStandardCreation = valueInstantiator.canCreateUsingDelegate()\n+            || (_propertyBasedCreator != null)\n+            || !valueInstantiator.canCreateUsingDefault()\n+            || (_unwrappedPropertyHandler != null);\n+    }\n+\n+    /**\n+     * Copy-constructor that can be used by sub-classes to allow\n+     * copy-on-write styling copying of settings of an existing instance.\n+     * \n+     * @since 1.7\n+     */\n+    protected BeanDeserializer(BeanDeserializer src)\n+    {\n+        this(src, src._ignoreAllUnknown);\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    protected BeanDeserializer(BeanDeserializer src, boolean ignoreAllUnknown)\n+    {\n+        super(src._beanType);\n+    \n+        _forClass = src._forClass;\n+        _beanType = src._beanType;\n+        _property = src._property;\n+        \n+        _valueInstantiator = src._valueInstantiator;\n+        _delegateDeserializer = src._delegateDeserializer;\n+        _propertyBasedCreator = src._propertyBasedCreator;\n+\n+        _beanProperties = src._beanProperties;\n+        _backRefs = src._backRefs;\n+        _ignorableProps = src._ignorableProps;\n+        _ignoreAllUnknown = ignoreAllUnknown;\n+        _anySetter = src._anySetter;\n+        _injectables = src._injectables;\n+\n+        _nonStandardCreation = src._nonStandardCreation;\n+        _unwrappedPropertyHandler = src._unwrappedPropertyHandler;\n+    }\n+\n+    @Override\n+    public JsonDeserializer<Object> unwrappingDeserializer()\n+    {\n+        /* bit kludgy but we don't want to accidentally change type;\n+         * sub-classes MUST override this method to support unwrapped\n+         * properties...\n+         */\n+        if (getClass() != BeanDeserializer.class) {\n+            return this;\n+        }\n+        /* main thing really is to just enforce ignoring of unknown\n+         * properties; since there may be multiple unwrapped values\n+         * and properties for all may be interleaved...\n+         */\n+        return new BeanDeserializer(this, true);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public accessors\n+    /**********************************************************\n+     */\n+\n+    public boolean hasProperty(String propertyName) {\n+        return _beanProperties.find(propertyName) != null;\n+    }\n+\n+    /**\n+     * Accessor for checking number of deserialized properties.\n+     * \n+     * @since 1.7\n+     */\n+    public int getPropertyCount() { \n+        return _beanProperties.size();\n+    }\n+\n+    public final Class<?> getBeanClass() { return _beanType.getRawClass(); }\n+\n+    @Override public JavaType getValueType() { return _beanType; }\n+\n+    /**\n+     * \n+     * @since 1.6\n+     */\n+    public Iterator<SettableBeanProperty> properties()\n+    {\n+        if (_beanProperties == null) { // since 1.7\n+            throw new IllegalStateException(\"Can only call before BeanDeserializer has been resolved\");\n+        }\n+        return _beanProperties.allProperties();\n+    }\n+\n+    /**\n+     * Method needed by {@link BeanDeserializerFactory} to properly link\n+     * managed- and back-reference pairs.\n+     */\n+    public SettableBeanProperty findBackReference(String logicalName)\n+    {\n+        if (_backRefs == null) {\n+            return null;\n+        }\n+        return _backRefs.get(logicalName);\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public ValueInstantiator getValueInstantiator() {\n+        return _valueInstantiator;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Validation, post-processing\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to finalize setup of this deserializer,\n+     * after deserializer itself has been registered.\n+     * This is needed to handle recursive and transitive dependencies.\n+     */\n+    @Override\n+    public void resolve(DeserializationConfig config, DeserializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        Iterator<SettableBeanProperty> it = _beanProperties.allProperties();\n+        UnwrappedPropertyHandler unwrapped = null;\n+        ExternalTypeHandler.Builder extTypes = null;\n+        \n+        while (it.hasNext()) {\n+            SettableBeanProperty origProp = it.next();\n+            SettableBeanProperty prop = origProp;\n+            // May already have deserializer from annotations, if so, skip:\n+            if (!prop.hasValueDeserializer()) {\n+                prop = prop.withValueDeserializer(findDeserializer(config, provider, prop.getType(), prop));\n+            }\n+            // [JACKSON-235]: need to link managed references with matching back references\n+            prop = _resolveManagedReferenceProperty(config, prop);\n+            // [JACKSON-132]: support unwrapped values (via @JsonUnwrapped)\n+            SettableBeanProperty u = _resolveUnwrappedProperty(config, prop);\n+            if (u != null) {\n+                prop = u;\n+                if (unwrapped == null) {\n+                    unwrapped = new UnwrappedPropertyHandler();\n+                }\n+                unwrapped.addProperty(prop);\n+            }\n+            // [JACKSON-594]: non-static inner classes too:\n+            prop = _resolveInnerClassValuedProperty(config, prop);\n+            if (prop != origProp) {\n+                _beanProperties.replace(prop);\n+            }\n+            \n+            /* one more thing: if this property uses \"external property\" type inclusion\n+             * (see [JACKSON-453]), it needs different handling altogether\n+             */\n+            if (prop.hasValueTypeDeserializer()) {\n+                TypeDeserializer typeDeser = prop.getValueTypeDeserializer();\n+                if (typeDeser.getTypeInclusion() == JsonTypeInfo.As.EXTERNAL_PROPERTY) {\n+                    if (extTypes == null) {\n+                        extTypes = new ExternalTypeHandler.Builder();\n+                    }\n+                    extTypes.addExternal(prop, typeDeser.getPropertyName());\n+                    // In fact, remove from list of known properties to simplify later handling\n+                    _beanProperties.remove(prop);\n+                }\n+            }\n+        }\n+\n+        // Finally, \"any setter\" may also need to be resolved now\n+        if (_anySetter != null && !_anySetter.hasValueDeserializer()) {\n+            _anySetter = _anySetter.withValueDeserializer(findDeserializer(config, provider, _anySetter.getType(), _anySetter.getProperty()));\n+        }\n+\n+        // as well as delegate-based constructor:\n+        if (_valueInstantiator.canCreateUsingDelegate()) {\n+            JavaType delegateType = _valueInstantiator.getDelegateType();\n+            if (delegateType == null) {\n+                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_beanType\n+                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n+                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n+            }\n+            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+            // Need to create a temporary property to allow contextual deserializers:\n+            BeanProperty.Std property = new BeanProperty.Std(null,\n+                    delegateType, _forClass.getAnnotations(), delegateCreator);\n+            _delegateDeserializer = findDeserializer(config, provider, delegateType, property);\n+        }\n+        // or property-based one\n+        // IMPORTANT: must access properties that _propertyBasedCreator has\n+        if (_propertyBasedCreator != null) {\n+            for (SettableBeanProperty prop : _propertyBasedCreator.getCreatorProperties()) {\n+                if (!prop.hasValueDeserializer()) {\n+                    _propertyBasedCreator.assignDeserializer(prop,\n+                           findDeserializer(config, provider, prop.getType(), prop));\n+                }\n+            }\n+        }\n+        if (extTypes != null) {\n+            _externalTypeIdHandler = extTypes.build();\n+            // we consider this non-standard, to offline handling\n+            _nonStandardCreation = true;\n+        }\n+        \n+        _unwrappedPropertyHandler = unwrapped;\n+        if (unwrapped != null) { // we consider this non-standard, to offline handling\n+            _nonStandardCreation = true;\n+        }\n+    }\n+\n+    /**\n+     * Helper method called to see if given property is part of 'managed' property\n+     * pair (managed + back reference), and if so, handle resolution details.\n+     * \n+     * @since 1.9\n+     */\n+    protected SettableBeanProperty _resolveManagedReferenceProperty(DeserializationConfig config,\n+            SettableBeanProperty prop)\n+    {\n+        String refName = prop.getManagedReferenceName();\n+        if (refName == null) {\n+            return prop;\n+        }\n+        JsonDeserializer<?> valueDeser = prop.getValueDeserializer();\n+        SettableBeanProperty backProp = null;\n+        boolean isContainer = false;\n+        if (valueDeser instanceof BeanDeserializer) {\n+            backProp = ((BeanDeserializer) valueDeser).findBackReference(refName);\n+        } else if (valueDeser instanceof ContainerDeserializerBase<?>) {\n+            JsonDeserializer<?> contentDeser = ((ContainerDeserializerBase<?>) valueDeser).getContentDeserializer();\n+            if (!(contentDeser instanceof BeanDeserializer)) {\n+                throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName\n+                        +\"': value deserializer is of type ContainerDeserializerBase, but content type is not handled by a BeanDeserializer \"\n+                        +\" (instead it's of type \"+contentDeser.getClass().getName()+\")\");\n+            }\n+            backProp = ((BeanDeserializer) contentDeser).findBackReference(refName);\n+            isContainer = true;\n+        } else if (valueDeser instanceof AbstractDeserializer) { // [JACKSON-368]: not easy to fix, alas  \n+            throw new IllegalArgumentException(\"Can not handle managed/back reference for abstract types (property \"+_beanType.getRawClass().getName()+\".\"+prop.getName()+\")\");\n+        } else {\n+            throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName\n+                    +\"': type for value deserializer is not BeanDeserializer or ContainerDeserializerBase, but \"\n+                    +valueDeser.getClass().getName());\n+        }\n+        if (backProp == null) {\n+            throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName+\"': no back reference property found from type \"\n+                    +prop.getType());\n+        }\n+        // also: verify that type is compatible\n+        JavaType referredType = _beanType;\n+        JavaType backRefType = backProp.getType();\n+        if (!backRefType.getRawClass().isAssignableFrom(referredType.getRawClass())) {\n+            throw new IllegalArgumentException(\"Can not handle managed/back reference '\"+refName+\"': back reference type (\"\n+                    +backRefType.getRawClass().getName()+\") not compatible with managed type (\"\n+                    +referredType.getRawClass().getName()+\")\");\n+        }\n+        return new SettableBeanProperty.ManagedReferenceProperty(refName, prop, backProp,\n+                _forClass.getAnnotations(), isContainer);\n+    }\n+\n+    /**\n+     * Helper method called to see if given property might be so-called unwrapped\n+     * property: these require special handling.\n+     * \n+     * @since 1.9\n+     */\n+    protected SettableBeanProperty _resolveUnwrappedProperty(DeserializationConfig config,\n+            SettableBeanProperty prop)\n+    {\n+        AnnotatedMember am = prop.getMember();\n+        if (am != null && config.getAnnotationIntrospector().shouldUnwrapProperty(am) == Boolean.TRUE) {\n+            JsonDeserializer<Object> orig = prop.getValueDeserializer();\n+            JsonDeserializer<Object> unwrapping = orig.unwrappingDeserializer();\n+            if (unwrapping != orig && unwrapping != null) {\n+                // might be cleaner to create new instance; but difficult to do reliably, so:\n+                return prop.withValueDeserializer(unwrapping);\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Helper method that will handle gruesome details of dealing with properties\n+     * that have non-static inner class as value...\n+     * \n+     * @since 1.9\n+     */\n+    protected SettableBeanProperty _resolveInnerClassValuedProperty(DeserializationConfig config,\n+            SettableBeanProperty prop)\n+    {            \n+        /* Should we encounter a property that has non-static inner-class\n+         * as value, we need to add some more magic to find the \"hidden\" constructor...\n+         */\n+        JsonDeserializer<Object> deser = prop.getValueDeserializer();\n+        // ideally wouldn't rely on it being BeanDeserializer; but for now it'll have to do\n+        if (deser instanceof BeanDeserializer) {\n+            BeanDeserializer bd = (BeanDeserializer) deser;\n+            ValueInstantiator vi = bd.getValueInstantiator();\n+            if (!vi.canCreateUsingDefault()) { // no default constructor\n+                Class<?> valueClass = prop.getType().getRawClass();\n+                Class<?> enclosing = ClassUtil.getOuterClass(valueClass);\n+                // and is inner class of the bean class...\n+                if (enclosing != null && enclosing == _beanType.getRawClass()) {\n+                    for (Constructor<?> ctor : valueClass.getConstructors()) {\n+                        Class<?>[] paramTypes = ctor.getParameterTypes();\n+                        if (paramTypes.length == 1 && paramTypes[0] == enclosing) {\n+                            if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+                                ClassUtil.checkAndFixAccess(ctor);\n+                            }\n+                            return new SettableBeanProperty.InnerClassProperty(prop, ctor);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return prop;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer implementation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Main deserialization method for bean-based objects (POJOs).\n+     */\n+    @Override\n+    public final Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        // common case first:\n+        if (t == JsonToken.START_OBJECT) {\n+            jp.nextToken();\n+            return deserializeFromObject(jp, ctxt);\n+        }\n+        // and then others, generally requiring use of @JsonCreator\n+        switch (t) {\n+        case VALUE_STRING:\n+            return deserializeFromString(jp, ctxt);\n+        case VALUE_NUMBER_INT:\n+            return deserializeFromNumber(jp, ctxt);\n+        case VALUE_NUMBER_FLOAT:\n+\t    return deserializeFromDouble(jp, ctxt);\n+        case VALUE_EMBEDDED_OBJECT:\n+            return jp.getEmbeddedObject();\n+        case VALUE_TRUE:\n+        case VALUE_FALSE:\n+            return deserializeFromBoolean(jp, ctxt);\n+        case START_ARRAY:\n+            // these only work if there's a (delegating) creator...\n+            return deserializeFromArray(jp, ctxt);\n+        case FIELD_NAME:\n+        case END_OBJECT: // added to resolve [JACKSON-319], possible related issues\n+            return deserializeFromObject(jp, ctxt);\n+\t}\n+        throw ctxt.mappingException(getBeanClass());\n+    }\n+\n+    /**\n+     * Secondary deserialization method, called in cases where POJO\n+     * instance is created as part of deserialization, potentially\n+     * after collecting some or all of the properties to set.\n+     */\n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt, Object bean)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_injectables != null) {\n+            injectValues(ctxt, bean);\n+        }\n+        if (_unwrappedPropertyHandler != null) {\n+            return deserializeWithUnwrapped(jp, ctxt, bean);\n+        }\n+        if (_externalTypeIdHandler != null) {\n+            return deserializeWithExternalTypeId(jp, ctxt, bean);\n+        }\n+        JsonToken t = jp.getCurrentToken();\n+        // 23-Mar-2010, tatu: In some cases, we start with full JSON object too...\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        }\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            // Skip field name:\n+            jp.nextToken();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            \n+            if (prop != null) { // normal case\n+                try {\n+                    prop.deserializeAndSet(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            }\n+            /* As per [JACKSON-313], things marked as ignorable should not be\n+             * passed to any setter\n+             */\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+            } else if (_anySetter != null) {\n+                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                continue;\n+            } else {\n+                // Unknown: let's call handler method\n+                handleUnknownProperty(jp, ctxt, bean, propName);\n+            }\n+        }\n+        return bean;\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        // In future could check current token... for now this should be enough:\n+        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Concrete deserialization methods\n+    /**********************************************************\n+     */\n+    \n+    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_nonStandardCreation) {\n+            if (_unwrappedPropertyHandler != null) {\n+                return deserializeWithUnwrapped(jp, ctxt);\n+            }\n+            if (_externalTypeIdHandler != null) {\n+                return deserializeWithExternalTypeId(jp, ctxt);\n+            }\n+            return deserializeFromObjectUsingNonDefault(jp, ctxt);\n+        }\n+\n+        final Object bean = _valueInstantiator.createUsingDefault();\n+        if (_injectables != null) {\n+            injectValues(ctxt, bean);\n+        }\n+        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            // Skip field name:\n+            jp.nextToken();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) { // normal case\n+                try {\n+                    prop.deserializeAndSet(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            }\n+            /* As per [JACKSON-313], things marked as ignorable should not be\n+             * passed to any setter\n+             */\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+            } else if (_anySetter != null) {\n+                try {\n+                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            } else {\n+                // Unknown: let's call handler method\n+                handleUnknownProperty(jp, ctxt, bean, propName);         \n+            }\n+        }\n+        return bean;\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    protected Object deserializeFromObjectUsingNonDefault(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {        \n+        if (_delegateDeserializer != null) {\n+            return _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        if (_propertyBasedCreator != null) {\n+            return _deserializeUsingPropertyBased(jp, ctxt);\n+        }\n+        // should only occur for abstract types...\n+        if (_beanType.isAbstract()) {\n+            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+                    +\" (need to add/enable type information?)\");\n+        }\n+        throw JsonMappingException.from(jp, \"No suitable constructor found for type \"\n+                +_beanType+\": can not instantiate from JSON object (need to add/enable type information?)\");\n+    }\n+    \n+    public Object deserializeFromString(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* Bit complicated if we have delegating creator; may need to use it,\n+         * or might not...\n+         */\n+        if (_delegateDeserializer != null) {\n+            if (!_valueInstantiator.canCreateFromString()) {\n+                Object bean = _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+                if (_injectables != null) {\n+                    injectValues(ctxt, bean);\n+                }\n+                return bean;\n+            }\n+        }\n+        return _valueInstantiator.createFromString(jp.getText());\n+    }\n+\n+    public Object deserializeFromNumber(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        switch (jp.getNumberType()) {\n+        case INT:\n+            if (_delegateDeserializer != null) {\n+                if (!_valueInstantiator.canCreateFromInt()) {\n+                    Object bean = _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+                    if (_injectables != null) {\n+                        injectValues(ctxt, bean);\n+                    }\n+                    return bean;\n+                }\n+            }\n+            return _valueInstantiator.createFromInt(jp.getIntValue());\n+        case LONG:\n+            if (_delegateDeserializer != null) {\n+                if (!_valueInstantiator.canCreateFromInt()) {\n+                    Object bean = _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+                    if (_injectables != null) {\n+                        injectValues(ctxt, bean);\n+                    }\n+                    return bean;\n+                }\n+            }\n+            return _valueInstantiator.createFromLong(jp.getLongValue());\n+    \t}\n+        // actually, could also be BigInteger, so:\n+        if (_delegateDeserializer != null) {\n+            Object bean = _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+            if (_injectables != null) {\n+                injectValues(ctxt, bean);\n+            }\n+            return bean;\n+        }\n+        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON integer number\");\n+    }\n+\n+    /**\n+     * Method called to deserialize POJO value from a JSON floating-point\n+     * number.\n+     * \n+     * @since 1.9\n+     */\n+    public Object deserializeFromDouble(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        switch (jp.getNumberType()) {\n+        case FLOAT: // no separate methods for taking float...\n+        case DOUBLE:\n+            if (_delegateDeserializer != null) {\n+                if (!_valueInstantiator.canCreateFromDouble()) {\n+                    Object bean = _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+                    if (_injectables != null) {\n+                        injectValues(ctxt, bean);\n+                    }\n+                    return bean;\n+                }\n+            }\n+            return _valueInstantiator.createFromDouble(jp.getDoubleValue());\n+        }\n+        // actually, could also be BigDecimal, so:\n+        if (_delegateDeserializer != null) {\n+            return _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        throw ctxt.instantiationException(getBeanClass(), \"no suitable creator method found to deserialize from JSON floating-point number\");\n+    }\n+\n+    /**\n+     * Method called to deserialize POJO value from a JSON boolean\n+     * value (true, false)\n+     * \n+     * @since 1.9\n+     */\n+    public Object deserializeFromBoolean(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_delegateDeserializer != null) {\n+            if (!_valueInstantiator.canCreateFromBoolean()) {\n+                Object bean = _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+                if (_injectables != null) {\n+                    injectValues(ctxt, bean);\n+                }\n+                return bean;\n+            }\n+        }\n+        boolean value = (jp.getCurrentToken() == JsonToken.VALUE_TRUE);\n+        return _valueInstantiator.createFromBoolean(value);\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public Object deserializeFromArray(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+    \tif (_delegateDeserializer != null) {\n+    \t    try {\n+    \t        Object bean = _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+    \t        if (_injectables != null) {\n+    \t            injectValues(ctxt, bean);\n+    \t        }\n+    \t        return bean;\n+            } catch (Exception e) {\n+                wrapInstantiationProblem(e, ctxt);\n+            }\n+    \t}\n+    \tthrow ctxt.mappingException(getBeanClass());\n+    }\n+\n+    /**\n+     * Method called to deserialize bean using \"property-based creator\":\n+     * this means that a non-default constructor or factory method is\n+     * called, and then possibly other setters. The trick is that\n+     * values for creator method need to be buffered, first; and \n+     * due to non-guaranteed ordering possibly some other properties\n+     * as well.\n+     *\n+     * @since 1.2\n+     */\n+    protected final Object _deserializeUsingPropertyBased(final JsonParser jp, final DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    { \n+        final PropertyBasedCreator creator = _propertyBasedCreator;\n+        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt);\n+\n+        // 04-Jan-2010, tatu: May need to collect unknown properties for polymorphic cases\n+        TokenBuffer unknown = null;\n+\n+        JsonToken t = jp.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            jp.nextToken(); // to point to value\n+            // creator property?\n+            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n+            if (creatorProp != null) {\n+                // Last creator property to set?\n+                Object value = creatorProp.deserialize(jp, ctxt);\n+                if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n+                    jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    Object bean;\n+                    try {\n+                        bean = creator.build(buffer);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n+                        continue; // never gets here\n+                    }\n+                    //  polymorphic?\n+\t\t    if (bean.getClass() != _beanType.getRawClass()) {\n+\t\t\treturn handlePolymorphic(jp, ctxt, bean, unknown);\n+\t\t    }\n+                    if (unknown != null) { // nope, just extra unknown stuff...\n+                        bean = handleUnknownProperties(ctxt, bean, unknown);\n+\t\t    }\n+\t\t    // or just clean?\n+                    return deserialize(jp, ctxt, bean);\n+                }\n+                continue;\n+            }\n+            // regular property? needs buffering\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) {\n+                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                continue;\n+            }\n+            /* As per [JACKSON-313], things marked as ignorable should not be\n+             * passed to any setter\n+             */\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // \"any property\"?\n+            if (_anySetter != null) {\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+                continue;\n+            }\n+            // Ok then, let's collect the whole field; name and value\n+            if (unknown == null) {\n+                unknown = new TokenBuffer(jp.getCodec());\n+            }\n+            unknown.writeFieldName(propName);\n+            unknown.copyCurrentStructure(jp);\n+        }\n+\n+        // We hit END_OBJECT, so:\n+        Object bean;\n+        try {\n+            bean =  creator.build(buffer);\n+        } catch (Exception e) {\n+            wrapInstantiationProblem(e, ctxt);\n+            return null; // never gets here\n+        }\n+        if (unknown != null) {\n+            // polymorphic?\n+            if (bean.getClass() != _beanType.getRawClass()) {\n+                return handlePolymorphic(null, ctxt, bean, unknown);\n+            }\n+            // no, just some extra unknown properties\n+            return handleUnknownProperties(ctxt, bean, unknown);\n+        }\n+        return bean;\n+    }\n+\n+    /**\n+     * Method called in cases where we may have polymorphic deserialization\n+     * case: that is, type of Creator-constructed bean is not the type\n+     * of deserializer itself. It should be a sub-class or implementation\n+     * class; either way, we may have more specific deserializer to use\n+     * for handling it.\n+     *\n+     * @param jp (optional) If not null, parser that has more properties to handle\n+     *   (in addition to buffered properties); if null, all properties are passed\n+     *   in buffer\n+     */\n+    protected Object handlePolymorphic(JsonParser jp, DeserializationContext ctxt,                                          \n+            Object bean, TokenBuffer unknownTokens)\n+        throws IOException, JsonProcessingException\n+    {  \n+        // First things first: maybe there is a more specific deserializer available?\n+        JsonDeserializer<Object> subDeser = _findSubclassDeserializer(ctxt, bean, unknownTokens);\n+        if (subDeser != null) {\n+            if (unknownTokens != null) {\n+                // need to add END_OBJECT marker first\n+                unknownTokens.writeEndObject();\n+                JsonParser p2 = unknownTokens.asParser();\n+                p2.nextToken(); // to get to first data field\n+                bean = subDeser.deserialize(p2, ctxt, bean);\n+            }\n+            // Original parser may also have some leftovers\n+            if (jp != null) {\n+                bean = subDeser.deserialize(jp, ctxt, bean);\n+            }\n+            return bean;\n+        }\n+        // nope; need to use this deserializer. Unknowns we've seen so far?\n+        if (unknownTokens != null) {\n+            bean = handleUnknownProperties(ctxt, bean, unknownTokens);\n+        }\n+        // and/or things left to process via main parser?\n+        if (jp != null) {\n+            bean = deserialize(jp, ctxt, bean);\n+        }\n+        return bean;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Handling for cases where we have \"unwrapped\" values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called when there are declared \"unwrapped\" properties\n+     * which need special handling\n+     */\n+    protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_delegateDeserializer != null) {\n+            return _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        if (_propertyBasedCreator != null) {\n+            return deserializeUsingPropertyBasedWithUnwrapped(jp, ctxt);\n+        }\n+        \n+        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        tokens.writeStartObject();\n+        final Object bean = _valueInstantiator.createUsingDefault();\n+\n+        if (_injectables != null) {\n+            injectValues(ctxt, bean);\n+        }\n+        \n+        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            jp.nextToken();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) { // normal case\n+                try {\n+                    prop.deserializeAndSet(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            }\n+            // ignorable things should be ignored\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // but... others should be passed to unwrapped property deserializers\n+            tokens.writeFieldName(propName);\n+            tokens.copyCurrentStructure(jp);\n+            // how about any setter? We'll get copies but...\n+            if (_anySetter != null) {\n+                try {\n+                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            }\n+        }\n+        tokens.writeEndObject();\n+        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        return bean;\n+    }    \n+\n+    protected Object deserializeWithUnwrapped(JsonParser jp, DeserializationContext ctxt, Object bean)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        }\n+        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        tokens.writeStartObject();\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            jp.nextToken();\n+            if (prop != null) { // normal case\n+                try {\n+                    prop.deserializeAndSet(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            }\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // but... others should be passed to unwrapped property deserializers\n+            tokens.writeFieldName(propName);\n+            tokens.copyCurrentStructure(jp);\n+            // how about any setter? We'll get copies but...\n+            if (_anySetter != null) {\n+                _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+            }\n+        }\n+        tokens.writeEndObject();\n+        _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+        return bean;\n+    }\n+\n+    protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        final PropertyBasedCreator creator = _propertyBasedCreator;\n+        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt);\n+\n+        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        tokens.writeStartObject();\n+\n+        JsonToken t = jp.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            jp.nextToken(); // to point to value\n+            // creator property?\n+            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n+            if (creatorProp != null) {\n+                // Last creator property to set?\n+                Object value = creatorProp.deserialize(jp, ctxt);\n+                if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n+                    t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    Object bean;\n+                    try {\n+                        bean = creator.build(buffer);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n+                        continue; // never gets here\n+                    }\n+                    // if so, need to copy all remaining tokens into buffer\n+                    while (t == JsonToken.FIELD_NAME) {\n+                        jp.nextToken(); // to skip name\n+                        tokens.copyCurrentStructure(jp);\n+                        t = jp.nextToken();\n+                    }\n+                    tokens.writeEndObject();\n+                    if (bean.getClass() != _beanType.getRawClass()) {\n+                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n+                        //   it's too complicated, so bail out\n+                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n+                    }\n+                    return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+                }\n+                continue;\n+            }\n+            // regular property? needs buffering\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) {\n+                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                continue;\n+            }\n+            /* As per [JACKSON-313], things marked as ignorable should not be\n+             * passed to any setter\n+             */\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            tokens.writeFieldName(propName);\n+            tokens.copyCurrentStructure(jp);\n+            // \"any property\"?\n+            if (_anySetter != null) {\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+            }\n+        }\n+\n+        // We hit END_OBJECT, so:\n+        Object bean;\n+        try {\n+            bean =  creator.build(buffer);\n+        } catch (Exception e) {\n+            wrapInstantiationProblem(e, ctxt);\n+            return null; // never gets here\n+        }\n+        return _unwrappedPropertyHandler.processUnwrapped(jp, ctxt, bean, tokens);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Handling for cases where we have property/-ies wth\n+    /* external type id\n+    /**********************************************************\n+     */\n+    \n+    protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_propertyBasedCreator != null) {\n+            return deserializeUsingPropertyBasedWithExternalTypeId(jp, ctxt);\n+        }\n+        return deserializeWithExternalTypeId(jp, ctxt, _valueInstantiator.createUsingDefault());\n+    }\n+\n+    protected Object deserializeWithExternalTypeId(JsonParser jp, DeserializationContext ctxt,\n+            Object bean)\n+        throws IOException, JsonProcessingException\n+    {\n+        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n+        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            jp.nextToken();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) { // normal case\n+                try {\n+                    prop.deserializeAndSet(jp, ctxt, bean);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            }\n+            // ignorable things should be ignored\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // but others are likely to be part of external type id thingy...\n+            if (ext.handleToken(jp, ctxt, propName, bean)) {\n+                continue;\n+            }\n+            // if not, the usual fallback handling:\n+            if (_anySetter != null) {\n+                try {\n+                    _anySetter.deserializeAndSet(jp, ctxt, bean, propName);\n+                } catch (Exception e) {\n+                    wrapAndThrow(e, bean, propName, ctxt);\n+                }\n+                continue;\n+            } else {\n+                // Unknown: let's call handler method\n+                handleUnknownProperty(jp, ctxt, bean, propName);         \n+            }\n+        }\n+        // and when we get this far, let's try finalizing the deal:\n+        return ext.complete(jp, ctxt, bean);\n+    }        \n+\n+    protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n+        final PropertyBasedCreator creator = _propertyBasedCreator;\n+        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt);\n+\n+        TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+        tokens.writeStartObject();\n+\n+        JsonToken t = jp.getCurrentToken();\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            jp.nextToken(); // to point to value\n+            // creator property?\n+            SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n+            if (creatorProp != null) {\n+                // Last creator property to set?\n+                Object value = creatorProp.deserialize(jp, ctxt);\n+                if (buffer.assignParameter(creatorProp.getPropertyIndex(), value)) {\n+                    t = jp.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n+                    Object bean;\n+                    try {\n+                        bean = creator.build(buffer);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n+                        continue; // never gets here\n+                    }\n+                    // if so, need to copy all remaining tokens into buffer\n+                    while (t == JsonToken.FIELD_NAME) {\n+                        jp.nextToken(); // to skip name\n+                        tokens.copyCurrentStructure(jp);\n+                        t = jp.nextToken();\n+                    }\n+                    if (bean.getClass() != _beanType.getRawClass()) {\n+                        // !!! 08-Jul-2011, tatu: Could probably support; but for now\n+                        //   it's too complicated, so bail out\n+                        throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\");\n+                    }\n+                    return ext.complete(jp, ctxt, bean);\n+                }\n+                continue;\n+            }\n+            // regular property? needs buffering\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            if (prop != null) {\n+                buffer.bufferProperty(prop, prop.deserialize(jp, ctxt));\n+                continue;\n+            }\n+            // external type id (or property that depends on it)?\n+            if (ext.handleToken(jp, ctxt, propName, null)) {\n+                continue;\n+            }\n+            /* As per [JACKSON-313], things marked as ignorable should not be\n+             * passed to any setter\n+             */\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // \"any property\"?\n+            if (_anySetter != null) {\n+                buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(jp, ctxt));\n+            }\n+        }\n+\n+        // We hit END_OBJECT, so:\n+        Object bean;\n+        try {\n+            bean = creator.build(buffer);\n+        } catch (Exception e) {\n+            wrapInstantiationProblem(e, ctxt);\n+            return null; // never gets here\n+        }\n+        return ext.complete(jp, ctxt, bean);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridable helper methods\n+    /**********************************************************\n+     */\n+\n+    protected void injectValues(DeserializationContext ctxt, Object bean)\n+            throws IOException, JsonProcessingException\n+    {\n+        for (ValueInjector injector : _injectables) {\n+            injector.inject(ctxt, bean);\n+        }\n+    }\n+    \n+    /**\n+     * Method called when a JSON property is encountered that has not matching\n+     * setter, any-setter or field, and thus can not be assigned.\n+     */\n+    @Override\n+    protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object beanOrClass, String propName)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* 22-Aug-2010, tatu: Caller now mostly checks for ignorable properties, so\n+         *    following should not be necessary. However, \"handleUnknownProperties()\" seems\n+         *    to still possibly need it so it is left for now.\n+         */\n+        // If registered as ignorable, skip\n+        if (_ignoreAllUnknown ||\n+            (_ignorableProps != null && _ignorableProps.contains(propName))) {\n+            jp.skipChildren();\n+            return;\n+        }\n+        /* Otherwise use default handling (call handler(s); if not\n+         * handled, throw exception or skip depending on settings)\n+         */\n+        super.handleUnknownProperty(jp, ctxt, beanOrClass, propName);\n+    }\n+\n+    /**\n+     * Method called to handle set of one or more unknown properties,\n+     * stored in their entirety in given {@link TokenBuffer}\n+     * (as field entries, name and value).\n+     */\n+    protected Object handleUnknownProperties(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens)\n+        throws IOException, JsonProcessingException\n+    {\n+        // First: add closing END_OBJECT as marker\n+        unknownTokens.writeEndObject();\n+        \n+        // note: buffer does NOT have starting START_OBJECT\n+        JsonParser bufferParser = unknownTokens.asParser();\n+        while (bufferParser.nextToken() != JsonToken.END_OBJECT) {\n+            String propName = bufferParser.getCurrentName();\n+            // Unknown: let's call handler method\n+            bufferParser.nextToken();\n+            handleUnknownProperty(bufferParser, ctxt, bean, propName);\n+        }\n+        return bean;\n+    }\n+    \n+    /**\n+     * Helper method called to (try to) locate deserializer for given sub-type of\n+     * type that this deserializer handles.\n+     */\n+    protected JsonDeserializer<Object> _findSubclassDeserializer(DeserializationContext ctxt, Object bean, TokenBuffer unknownTokens)\n+        throws IOException, JsonProcessingException\n+    {  \n+        JsonDeserializer<Object> subDeser;\n+\n+        // First: maybe we have already created sub-type deserializer?\n+        synchronized (this) {\n+            subDeser = (_subDeserializers == null) ? null : _subDeserializers.get(new ClassKey(bean.getClass()));\n+        }\n+        if (subDeser != null) {\n+            return subDeser;\n+        }\n+        // If not, maybe we can locate one. First, need provider\n+        DeserializerProvider deserProv = ctxt.getDeserializerProvider();\n+        if (deserProv != null) {\n+            JavaType type = ctxt.constructType(bean.getClass());\n+            /* 09-Dec-2010, tatu: Would be nice to know which property pointed to this\n+             *    bean... but, alas, no such information is retained, so:\n+             */\n+            subDeser = deserProv.findValueDeserializer(ctxt.getConfig(), type, _property);\n+            // Also, need to cache it\n+            if (subDeser != null) {\n+                synchronized (this) {\n+                    if (_subDeserializers == null) {\n+                        _subDeserializers = new HashMap<ClassKey,JsonDeserializer<Object>>();;\n+                    }\n+                    _subDeserializers.put(new ClassKey(bean.getClass()), subDeser);\n+                }            \n+            }\n+        }\n+        return subDeser;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for error reporting\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will modify caught exception (passed in as argument)\n+     * as necessary to include reference information, and to ensure it\n+     * is a subtype of {@link IOException}, or an unchecked exception.\n+     *<p>\n+     * Rules for wrapping and unwrapping are bit complicated; essentially:\n+     *<ul>\n+     * <li>Errors are to be passed as is (if uncovered via unwrapping)\n+     * <li>\"Plain\" IOExceptions (ones that are not of type\n+     *   {@link JsonMappingException} are to be passed as is\n+     *</ul>\n+     */\n+    public void wrapAndThrow(Throwable t, Object bean, String fieldName,\n+            DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n+         *   StackOverflow: usually due to infinite loop. But that\n+         *   usually gets hidden within an InvocationTargetException...\n+         */\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors and \"plain\" IOExceptions to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationConfig.Feature.WRAP_EXCEPTIONS);\n+        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n+        if (t instanceof IOException) {\n+            if (!wrap || !(t instanceof JsonMappingException)) {\n+                throw (IOException) t;\n+            }\n+        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n+            if (t instanceof RuntimeException) {\n+                throw (RuntimeException) t;\n+            }\n+        }\n+        // [JACKSON-55] Need to add reference information\n+        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n+    }\n+\n+    public void wrapAndThrow(Throwable t, Object bean, int index, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors and \"plain\" IOExceptions to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationConfig.Feature.WRAP_EXCEPTIONS);\n+        // Ditto for IOExceptions; except we may want to wrap mapping exceptions\n+        if (t instanceof IOException) {\n+            if (!wrap || !(t instanceof JsonMappingException)) {\n+                throw (IOException) t;\n+            }\n+        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n+            if (t instanceof RuntimeException) {\n+                throw (RuntimeException) t;\n+            }\n+        }\n+        // [JACKSON-55] Need to add reference information\n+        throw JsonMappingException.wrapWithPath(t, bean, index);\n+    }\n+\n+    protected void wrapInstantiationProblem(Throwable t, DeserializationContext ctxt)\n+        throws IOException\n+    {\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors and \"plain\" IOExceptions to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        boolean wrap = (ctxt == null) || ctxt.isEnabled(DeserializationConfig.Feature.WRAP_EXCEPTIONS);\n+        if (t instanceof IOException) {\n+            // Since we have no more information to add, let's not actually wrap..\n+            throw (IOException) t;\n+        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n+            if (t instanceof RuntimeException) {\n+                throw (RuntimeException) t;\n+            }\n+        }\n+        throw ctxt.instantiationException(_beanType.getRawClass(), t);\n+    }\n+    \n+    /**\n+     * @deprecated Since 1.7 use variant that takes {@link DeserializationContext}\n+     */\n+    @Deprecated\n+    public void wrapAndThrow(Throwable t, Object bean, String fieldName)\n+        throws IOException\n+    {\n+        wrapAndThrow(t, bean, fieldName, null);\n+    }\n+    \n+    /**\n+     * @deprecated Since 1.7 use variant that takes {@link DeserializationContext}\n+     */\n+    @Deprecated\n+    public void wrapAndThrow(Throwable t, Object bean, int index)\n+        throws IOException\n+    {\n+        wrapAndThrow(t, bean, index, null);\n+    }    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBuilder.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.*;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.impl.BeanPropertyMap;\n+import com.fasterxml.jackson.databind.deser.impl.ValueInjector;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * Builder class used for aggregating deserialization information about\n+ * a POJO, in order to build a {@link JsonDeserializer} for deserializing\n+ * intances.\n+ * \n+ * @since 1.7\n+ */\n+public class BeanDeserializerBuilder\n+{\n+    /*\n+    /**********************************************************\n+    /* General information about POJO\n+    /**********************************************************\n+     */\n+\n+    final protected BasicBeanDescription _beanDesc;\n+    \n+    /*\n+    /**********************************************************\n+    /* Accumulated information about properties\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Properties to deserialize collected so far.\n+     *<p>\n+     * Note: since 1.9.1, LinkedHashMap has been used, since preservation\n+     * of order is actually important for some use cases.\n+     */\n+    final protected HashMap<String, SettableBeanProperty> _properties = new LinkedHashMap<String, SettableBeanProperty>();\n+\n+    /**\n+     * Value injectors for deserialization\n+     * \n+     * @since 1.9\n+     */\n+    protected List<ValueInjector> _injectables;\n+    \n+    /**\n+     * Back-reference properties this bean contains (if any)\n+     */\n+    protected HashMap<String, SettableBeanProperty> _backRefProperties;\n+\n+    /**\n+     * Set of names of properties that are recognized but are to be ignored for deserialization\n+     * purposes (meaning no exception is thrown, value is just skipped).\n+     */\n+    protected HashSet<String> _ignorableProps;\n+    \n+    /**\n+     * Object that will handle value instantiation for the bean type.\n+     * \n+     * @since 1.9\n+     */\n+    protected ValueInstantiator _valueInstantiator;\n+\n+    /**\n+     * Fallback setter used for handling any properties that are not\n+     * mapped to regular setters. If setter is not null, it will be\n+     * called once for each such property.\n+     */\n+    protected SettableAnyProperty _anySetter;\n+\n+    /**\n+     * Flag that can be set to ignore and skip unknown properties.\n+     * If set, will not throw an exception for unknown properties.\n+     */\n+    protected boolean _ignoreAllUnknown;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: construction\n+    /**********************************************************\n+     */\n+    \n+    public BeanDeserializerBuilder(BasicBeanDescription beanDesc)\n+    { \n+        _beanDesc = beanDesc;\n+    }\n+\n+    /**\n+     * Copy constructor for sub-classes to use, when constructing\n+     * custom builder instances\n+     * \n+     * @since 1.9\n+     */\n+    protected BeanDeserializerBuilder(BeanDeserializerBuilder src)\n+    {\n+        _beanDesc = src._beanDesc;\n+        _anySetter = src._anySetter;\n+        _ignoreAllUnknown = src._ignoreAllUnknown;\n+\n+        // let's make copy of properties\n+        _properties.putAll(src._properties);\n+        _backRefProperties = _copy(src._backRefProperties);\n+        // Hmmh. Should we create defensive copies here? For now, not yet\n+        _ignorableProps = src._ignorableProps;\n+        _valueInstantiator = src._valueInstantiator;\n+    }\n+\n+    private static HashMap<String, SettableBeanProperty> _copy(HashMap<String, SettableBeanProperty> src)\n+    {\n+        if (src == null) {\n+            return null;\n+        }\n+        return new HashMap<String, SettableBeanProperty>(src);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: state modification (adders, setters)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for adding a new property or replacing a property.\n+     */\n+    public void addOrReplaceProperty(SettableBeanProperty prop, boolean allowOverride)\n+    {\n+        _properties.put(prop.getName(), prop);\n+    }\n+\n+    /**\n+     * Method to add a property setter. Will ensure that there is no\n+     * unexpected override; if one is found will throw a\n+     * {@link IllegalArgumentException}.\n+     */\n+    public void addProperty(SettableBeanProperty prop)\n+    {\n+        SettableBeanProperty old =  _properties.put(prop.getName(), prop);\n+        if (old != null && old != prop) { // should never occur...\n+            throw new IllegalArgumentException(\"Duplicate property '\"+prop.getName()+\"' for \"+_beanDesc.getType());\n+        }\n+    }\n+\n+    /**\n+     * Method called to add a property that represents so-called back reference;\n+     * reference that \"points back\" to object that has forward reference to\n+     * currently built bean.\n+     */\n+    public void  addBackReferenceProperty(String referenceName, SettableBeanProperty prop)\n+    {\n+        if (_backRefProperties == null) {\n+            _backRefProperties = new HashMap<String, SettableBeanProperty>(4);\n+        }\n+        _backRefProperties.put(referenceName, prop);\n+        // also: if we had property with same name, actually remove it\n+        if (_properties != null) {\n+            _properties.remove(prop.getName());\n+        }\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public void addInjectable(String propertyName, JavaType propertyType,\n+            Annotations contextAnnotations, AnnotatedMember member,\n+            Object valueId)\n+    {\n+        if (_injectables == null) {\n+            _injectables = new ArrayList<ValueInjector>();\n+        }\n+        _injectables.add(new ValueInjector(propertyName, propertyType,\n+                contextAnnotations, member, valueId));\n+    }\n+    \n+    /**\n+     * Method that will add property name as one of properties that can\n+     * be ignored if not recognized.\n+     */\n+    public void addIgnorable(String propName)\n+    {\n+        if (_ignorableProps == null) {\n+            _ignorableProps = new HashSet<String>();\n+        }\n+        _ignorableProps.add(propName);\n+    }\n+\n+    /**\n+     * Method called by deserializer factory, when a \"creator property\"\n+     * (something that is passed via constructor- or factory method argument;\n+     * instead of setter or field).\n+     *<p>\n+     * Default implementation does not do anything; we may need to revisit this\n+     * decision if these properties need to be available through accessors.\n+     * For now, however, we just have to ensure that we don't try to resolve\n+     * types that masked setter/field has (see [JACKSON-700] for details).\n+     * \n+     * @since 1.9.2\n+     */\n+    public void addCreatorProperty(BeanPropertyDefinition propDef)\n+    {\n+        // do nothing\n+    }\n+    \n+    public void setAnySetter(SettableAnyProperty s)\n+    {\n+        if (_anySetter != null && s != null) {\n+            throw new IllegalStateException(\"_anySetter already set to non-null\");\n+        }\n+        _anySetter = s;\n+    }\n+\n+    public void setIgnoreUnknownProperties(boolean ignore) {\n+        _ignoreAllUnknown = ignore;\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public void setValueInstantiator(ValueInstantiator inst) {\n+        _valueInstantiator = inst;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public accessors\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that allows accessing all properties that this\n+     * builder currently contains.\n+     *<p>\n+     * Note that properties are returned in order that properties\n+     * are ordered (explictly, or by rule), which is the serialization\n+     * order.\n+     * \n+     * @since 1.8.3\n+     */\n+    public Iterator<SettableBeanProperty> getProperties() {\n+        return _properties.values().iterator();\n+    }\n+    \n+    public boolean hasProperty(String propertyName) {\n+        return _properties.containsKey(propertyName);\n+    }\n+    \n+    public SettableBeanProperty removeProperty(String name)\n+    {\n+        return _properties.remove(name);\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public ValueInstantiator getValueInstantiator() {\n+        return _valueInstantiator;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Build method(s)\n+    /**********************************************************\n+     */\n+\n+    public JsonDeserializer<?> build(BeanProperty forProperty)\n+    {\n+        BeanPropertyMap propertyMap = new BeanPropertyMap(_properties.values());\n+        propertyMap.assignIndexes();\n+        return new BeanDeserializer(_beanDesc, forProperty,\n+                _valueInstantiator, propertyMap, _backRefProperties, _ignorableProps, _ignoreAllUnknown,\n+                _anySetter, _injectables);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.JsonNode;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n+import com.fasterxml.jackson.databind.deser.impl.CreatorProperty;\n+import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.type.*;\n+import com.fasterxml.jackson.databind.util.ArrayBuilders;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+\n+/**\n+ * Concrete deserializer factory class that adds full Bean deserializer\n+ * construction logic using class introspection.\n+ *<p>\n+ * Since there is no caching, this factory is stateless and a globally\n+ * shared singleton instance ({@link #instance}) can be  used by\n+ * {@link DeserializerProvider}s).\n+ */\n+public class BeanDeserializerFactory\n+    extends BasicDeserializerFactory\n+{\n+    /**\n+     * Signature of <b>Throwable.initCause</b> method.\n+     */\n+    private final static Class<?>[] INIT_CAUSE_PARAMS = new Class<?>[] { Throwable.class };\n+\n+    /*\n+    /**********************************************************\n+    /* Config class implementation\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Standard configuration settings container class implementation.\n+     * \n+     * @since 1.7\n+     */\n+    public static class ConfigImpl extends Config\n+    {\n+        protected final static KeyDeserializers[] NO_KEY_DESERIALIZERS = new KeyDeserializers[0];\n+        protected final static BeanDeserializerModifier[] NO_MODIFIERS = new BeanDeserializerModifier[0];\n+        protected final static AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS = new AbstractTypeResolver[0];\n+        protected final static ValueInstantiators[] NO_VALUE_INSTANTIATORS = new ValueInstantiators[0];\n+        \n+        /**\n+         * List of providers for additional deserializers, checked before considering default\n+         * basic or bean deserializers.\n+         * \n+         * @since 1.7\n+         */\n+        protected final Deserializers[] _additionalDeserializers;\n+\n+        /**\n+         * List of providers for additional key deserializers, checked before considering\n+         * standard key deserializers.\n+         * \n+         * @since 1.7\n+         */\n+        protected final KeyDeserializers[] _additionalKeyDeserializers;\n+        \n+        /**\n+         * List of modifiers that can change the way {@link BeanDeserializer} instances\n+         * are configured and constructed.\n+         */\n+        protected final BeanDeserializerModifier[] _modifiers;\n+\n+        /**\n+         * List of objects that may be able to resolve abstract types to\n+         * concrete types. Used by functionality like \"mr Bean\" to materialize\n+         * types as needed.\n+         * \n+         * @since 1.8\n+         */\n+        protected final AbstractTypeResolver[] _abstractTypeResolvers;\n+\n+        /**\n+         * List of objects that know how to create instances of POJO types;\n+         * possibly using custom construction (non-annoted constructors; factory\n+         * methods external to value type etc).\n+         * Used to support objects that are created using non-standard methods;\n+         * or to support post-constructor functionality.\n+         * \n+         * @since 1.9\n+         */\n+        protected final ValueInstantiators[] _valueInstantiators;\n+        \n+        /**\n+         * Constructor for creating basic configuration with no additional\n+         * handlers.\n+         */\n+        public ConfigImpl() {\n+            this(null, null, null, null, null);\n+        }\n+\n+        /**\n+         * Copy-constructor that will create an instance that contains defined\n+         * set of additional deserializer providers.\n+         */\n+        protected ConfigImpl(Deserializers[] allAdditionalDeserializers,\n+                KeyDeserializers[] allAdditionalKeyDeserializers,\n+                BeanDeserializerModifier[] modifiers,\n+                AbstractTypeResolver[] atr,\n+                ValueInstantiators[] vi)\n+        {\n+            _additionalDeserializers = (allAdditionalDeserializers == null) ?\n+                    NO_DESERIALIZERS : allAdditionalDeserializers;\n+            _additionalKeyDeserializers = (allAdditionalKeyDeserializers == null) ?\n+                    NO_KEY_DESERIALIZERS : allAdditionalKeyDeserializers;\n+            _modifiers = (modifiers == null) ? NO_MODIFIERS : modifiers;\n+            _abstractTypeResolvers = (atr == null) ? NO_ABSTRACT_TYPE_RESOLVERS : atr;\n+            _valueInstantiators = (vi == null) ? NO_VALUE_INSTANTIATORS : vi;\n+        }\n+\n+        @Override\n+        public Config withAdditionalDeserializers(Deserializers additional)\n+        {\n+            if (additional == null) {\n+                throw new IllegalArgumentException(\"Can not pass null Deserializers\");\n+            }\n+            Deserializers[] all = ArrayBuilders.insertInListNoDup(_additionalDeserializers, additional);\n+            return new ConfigImpl(all, _additionalKeyDeserializers, _modifiers,\n+                    _abstractTypeResolvers, _valueInstantiators);\n+        }\n+\n+        @Override\n+        public Config withAdditionalKeyDeserializers(KeyDeserializers additional)\n+        {\n+            if (additional == null) {\n+                throw new IllegalArgumentException(\"Can not pass null KeyDeserializers\");\n+            }\n+            KeyDeserializers[] all = ArrayBuilders.insertInListNoDup(_additionalKeyDeserializers, additional);\n+            return new ConfigImpl(_additionalDeserializers, all, _modifiers,\n+                    _abstractTypeResolvers, _valueInstantiators);\n+        }\n+        \n+        @Override\n+        public Config withDeserializerModifier(BeanDeserializerModifier modifier)\n+        {\n+            if (modifier == null) {\n+                throw new IllegalArgumentException(\"Can not pass null modifier\");\n+            }\n+            BeanDeserializerModifier[] all = ArrayBuilders.insertInListNoDup(_modifiers, modifier);\n+            return new ConfigImpl(_additionalDeserializers, _additionalKeyDeserializers, all,\n+                    _abstractTypeResolvers, _valueInstantiators);\n+        }\n+\n+        @Override\n+        public Config withAbstractTypeResolver(AbstractTypeResolver resolver)\n+        {\n+            if (resolver == null) {\n+                throw new IllegalArgumentException(\"Can not pass null resolver\");\n+            }\n+            AbstractTypeResolver[] all = ArrayBuilders.insertInListNoDup(_abstractTypeResolvers, resolver);\n+            return new ConfigImpl(_additionalDeserializers, _additionalKeyDeserializers, _modifiers,\n+                    all, _valueInstantiators);\n+        }\n+\n+        @Override\n+        public Config withValueInstantiators(ValueInstantiators instantiators) \n+        {\n+            if (instantiators == null) {\n+                throw new IllegalArgumentException(\"Can not pass null resolver\");\n+            }\n+            ValueInstantiators[] all = ArrayBuilders.insertInListNoDup(_valueInstantiators, instantiators);\n+            return new ConfigImpl(_additionalDeserializers, _additionalKeyDeserializers, _modifiers,\n+                    _abstractTypeResolvers, all);\n+        }\n+        \n+        @Override\n+        public boolean hasDeserializers() { return _additionalDeserializers.length > 0; }\n+\n+        @Override\n+        public boolean hasKeyDeserializers() { return _additionalKeyDeserializers.length > 0; }\n+        \n+        @Override\n+        public boolean hasDeserializerModifiers() { return _modifiers.length > 0; }\n+\n+        @Override\n+        public boolean hasAbstractTypeResolvers() { return _abstractTypeResolvers.length > 0; }\n+\n+        @Override\n+        public boolean hasValueInstantiators() { return _valueInstantiators.length > 0; }\n+        \n+        @Override\n+        public Iterable<Deserializers> deserializers() {\n+            return ArrayBuilders.arrayAsIterable(_additionalDeserializers);\n+        }\n+\n+        @Override\n+        public Iterable<KeyDeserializers> keyDeserializers() {\n+            return ArrayBuilders.arrayAsIterable(_additionalKeyDeserializers);\n+        }\n+        \n+        @Override\n+        public Iterable<BeanDeserializerModifier> deserializerModifiers() {\n+            return ArrayBuilders.arrayAsIterable(_modifiers);\n+        }\n+\n+        @Override\n+        public Iterable<AbstractTypeResolver> abstractTypeResolvers() {\n+            return ArrayBuilders.arrayAsIterable(_abstractTypeResolvers);\n+        }\n+\n+        @Override\n+        public Iterable<ValueInstantiators> valueInstantiators() {\n+            return ArrayBuilders.arrayAsIterable(_valueInstantiators);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Globally shareable thread-safe instance which has no additional custom deserializers\n+     * registered\n+     */\n+    public final static BeanDeserializerFactory instance = new BeanDeserializerFactory(null);\n+\n+    /**\n+     * Configuration settings for this factory; immutable instance (just like this\n+     * factory), new version created via copy-constructor (fluent-style)\n+     * \n+     * @since 1.7\n+     */\n+    protected final Config _factoryConfig;\n+\n+    @Deprecated\n+    public BeanDeserializerFactory() {\n+        this(null);\n+    }\n+\n+    /**\n+     * @since 1.7\n+     */\n+    public BeanDeserializerFactory(DeserializerFactory.Config config) {\n+        if (config == null) {\n+            config = new ConfigImpl();\n+        }\n+        _factoryConfig = config;\n+    }\n+\n+    @Override\n+    public final Config getConfig() {\n+        return _factoryConfig;\n+    }\n+    \n+    /**\n+     * Method used by module registration functionality, to construct a new bean\n+     * deserializer factory\n+     * with different configuration settings.\n+     * \n+     * @since 1.7\n+     */\n+    @Override\n+    public DeserializerFactory withConfig(DeserializerFactory.Config config)\n+    {\n+        if (_factoryConfig == config) {\n+            return this;\n+        }\n+\n+        /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;\n+         *    and we pretty much have to here either choose between losing subtype instance\n+         *    when registering additional deserializers, or losing deserializers.\n+         *    Instead, let's actually just throw an error if this method is called when subtype\n+         *    has not properly overridden this method; this to indicate problem as soon as possible.\n+         */\n+        if (getClass() != BeanDeserializerFactory.class) {\n+            throw new IllegalStateException(\"Subtype of BeanDeserializerFactory (\"+getClass().getName()\n+                    +\") has not properly overridden method 'withAdditionalDeserializers': can not instantiate subtype with \"\n+                    +\"additional deserializer definitions\");\n+        }\n+        return new BeanDeserializerFactory(config);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overrides for super-class methods used for finding\n+    /* custom deserializers\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public KeyDeserializer createKeyDeserializer(DeserializationConfig config, JavaType type,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        if (_factoryConfig.hasKeyDeserializers()) {\n+            BasicBeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n+            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n+                KeyDeserializer deser = d.findKeyDeserializer(type, config, beanDesc, property);\n+                if (deser != null) {\n+                    return deser;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n+    protected JsonDeserializer<?> _findCustomArrayDeserializer(ArrayType type, DeserializationConfig config,\n+            DeserializerProvider provider,\n+            BeanProperty property,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findArrayDeserializer(type, config, provider, property,\n+                        elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type, DeserializationConfig config,\n+            DeserializerProvider provider, BasicBeanDescription beanDesc,\n+            BeanProperty property,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findCollectionDeserializer(type, config, provider, beanDesc, property,\n+                    elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    protected JsonDeserializer<?> _findCustomCollectionLikeDeserializer(CollectionLikeType type, DeserializationConfig config,\n+            DeserializerProvider provider, BasicBeanDescription beanDesc,\n+            BeanProperty property,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findCollectionLikeDeserializer(type, config, provider, beanDesc, property,\n+                    elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n+    protected JsonDeserializer<?> _findCustomEnumDeserializer(Class<?> type, DeserializationConfig config,\n+            BasicBeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findEnumDeserializer(type, config, beanDesc, property);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    protected JsonDeserializer<?> _findCustomMapDeserializer(MapType type,\n+            DeserializationConfig config,\n+            DeserializerProvider provider, BasicBeanDescription beanDesc, BeanProperty property,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findMapDeserializer(type, config, provider, beanDesc, property,\n+                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    protected JsonDeserializer<?> _findCustomMapLikeDeserializer(MapLikeType type,\n+            DeserializationConfig config,\n+            DeserializerProvider provider, BasicBeanDescription beanDesc, BeanProperty property,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer, JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findMapLikeDeserializer(type, config, provider, beanDesc, property,\n+                    keyDeserializer, elementTypeDeserializer, elementDeserializer);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n+    protected JsonDeserializer<?> _findCustomTreeNodeDeserializer(Class<? extends JsonNode> type,\n+            DeserializationConfig config, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findTreeNodeDeserializer(type, config, property);\n+            if (deser != null) {\n+                return deser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    // Note: NOT overriding, superclass has no matching method\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonDeserializer<Object> _findCustomBeanDeserializer(JavaType type, DeserializationConfig config,\n+            DeserializerProvider provider, BasicBeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        for (Deserializers d  : _factoryConfig.deserializers()) {\n+            JsonDeserializer<?> deser = d.findBeanDeserializer(type, config, provider, beanDesc, property);\n+            if (deser != null) {\n+                return (JsonDeserializer<Object>) deser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* DeserializerFactory API implementation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will find complete abstract type mapping for specified type, doing as\n+     * many resolution steps as necessary.\n+     */\n+    @Override\n+    public JavaType mapAbstractType(DeserializationConfig config, JavaType type)\n+        throws JsonMappingException\n+    {\n+        while (true) {\n+            JavaType next = _mapAbstractType2(config, type);\n+            if (next == null) {\n+                return type;\n+            }\n+            /* Should not have to worry about cycles; but better verify since they will invariably\n+             * occur... :-)\n+             * (also: guard against invalid resolution to a non-related type)\n+             */\n+            Class<?> prevCls = type.getRawClass();\n+            Class<?> nextCls = next.getRawClass();\n+            if ((prevCls == nextCls) || !prevCls.isAssignableFrom(nextCls)) {\n+                throw new IllegalArgumentException(\"Invalid abstract type resolution from \"+type+\" to \"+next+\": latter is not a subtype of former\");\n+            }\n+            type = next;\n+        }\n+    }\n+    \n+    /**\n+     * Value instantiator is created both based on creator annotations,\n+     * and on optional externally provided instantiators (registered through\n+     * module interface).\n+     */\n+    @Override\n+    public ValueInstantiator findValueInstantiator(DeserializationConfig config,\n+            BasicBeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        ValueInstantiator instantiator;\n+        // [JACKSON-633] Check @JsonValueInstantiator before anything else\n+        AnnotatedClass ac = beanDesc.getClassInfo();\n+        Object instDef = config.getAnnotationIntrospector().findValueInstantiator(ac);\n+        if (instDef != null) {\n+            if (instDef instanceof ValueInstantiator) {\n+                instantiator = (ValueInstantiator) instDef;\n+            } else {\n+                if (!(instDef instanceof Class<?>)) { // sanity check\n+                    throw new IllegalStateException(\"Invalid value instantiator returned for type \"+beanDesc+\": neither a Class nor ValueInstantiator\");\n+                }\n+                Class<?> cls = (Class<?>) instDef;\n+                if (!ValueInstantiator.class.isAssignableFrom(cls)) {\n+                    throw new IllegalStateException(\"Invalid instantiator Class<?> returned for type \"+beanDesc+\": \"\n+                            +cls.getName()+\" not a ValueInstantiator\");\n+                }\n+                @SuppressWarnings(\"unchecked\")\n+                Class<? extends ValueInstantiator> instClass = (Class<? extends ValueInstantiator>) cls;\n+                instantiator = config.valueInstantiatorInstance(ac, (Class<? extends ValueInstantiator>)instClass);\n+            }\n+        } else {\n+            instantiator = constructDefaultValueInstantiator(config, beanDesc);\n+        }\n+        \n+        // finally: anyone want to modify ValueInstantiator?\n+        if (_factoryConfig.hasValueInstantiators()) {\n+            for (ValueInstantiators insts : _factoryConfig.valueInstantiators()) {\n+                instantiator = insts.findValueInstantiator(config, beanDesc, instantiator);\n+                // let's do sanity check; easier to spot buggy handlers\n+                if (instantiator == null) {\n+                    throw new JsonMappingException(\"Broken registered ValueInstantiators (of type \"\n+                            +insts.getClass().getName()+\"): returned null ValueInstantiator\");\n+                }\n+            }\n+        }\n+        \n+        return instantiator;\n+    }\n+\n+    /**\n+     * Method that {@link DeserializerProvider}s call to create a new\n+     * deserializer for types other than Collections, Maps, arrays and\n+     * enums.\n+     */\n+    @Override\n+    public JsonDeserializer<Object> createBeanDeserializer(DeserializationConfig config,\n+            DeserializerProvider p, JavaType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // First things first: abstract types may use defaulting:\n+        if (type.isAbstract()) {\n+            type = mapAbstractType(config, type);\n+        }\n+        \n+        // First things first: maybe explicit definition via annotations?\n+        BasicBeanDescription beanDesc = config.introspect(type);\n+        JsonDeserializer<Object> ad = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n+        if (ad != null) {\n+            return ad;\n+        }\n+        // Or value annotation that indicates more specific type to use:\n+        JavaType newType =  modifyTypeByAnnotation(config, beanDesc.getClassInfo(), type, null);\n+        if (newType.getRawClass() != type.getRawClass()) {\n+            type = newType;\n+            beanDesc = config.introspect(type);\n+        }\n+        // We may also have custom overrides:\n+        JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, p, beanDesc, property);\n+        if (custom != null) {\n+            return custom;\n+        }\n+        /* One more thing to check: do we have an exception type\n+         * (Throwable or its sub-classes)? If so, need slightly\n+         * different handling.\n+         */\n+        if (type.isThrowable()) {\n+            return buildThrowableDeserializer(config, type, beanDesc, property);\n+        }\n+        /* Or, for abstract types, may have alternate means for resolution\n+         * (defaulting, materialization)\n+         */\n+        if (type.isAbstract()) {\n+            // [JACKSON-41] (v1.6): Let's make it possible to materialize abstract types.\n+            JavaType concreteType = materializeAbstractType(config, beanDesc);\n+            if (concreteType != null) {\n+                /* important: introspect actual implementation (abstract class or\n+                 * interface doesn't have constructors, for one)\n+                 */\n+                beanDesc = config.introspect(concreteType);\n+                return buildBeanDeserializer(config, concreteType, beanDesc, property);\n+            }\n+        }\n+\n+        // Otherwise, may want to check handlers for standard types, from superclass:\n+        JsonDeserializer<Object> deser = findStdBeanDeserializer(config, p, type, property);\n+        if (deser != null) {\n+            return deser;\n+        }\n+\n+        // Otherwise: could the class be a Bean class? If not, bail out\n+        if (!isPotentialBeanType(type.getRawClass())) {\n+            return null;\n+        }\n+        // Use generic bean introspection to build deserializer\n+        return buildBeanDeserializer(config, type, beanDesc, property);\n+    }\n+\n+    /**\n+     * Method that will find abstract type mapping for specified type, doing a single\n+     * lookup through registered abstract type resolvers; will not do recursive lookups.\n+     */\n+    protected JavaType _mapAbstractType2(DeserializationConfig config, JavaType type)\n+        throws JsonMappingException\n+    {\n+        Class<?> currClass = type.getRawClass();\n+        if (_factoryConfig.hasAbstractTypeResolvers()) {\n+            for (AbstractTypeResolver resolver : _factoryConfig.abstractTypeResolvers()) {\n+                JavaType concrete = resolver.findTypeMapping(config, type);\n+                if (concrete != null && concrete.getRawClass() != currClass) {\n+                    return concrete;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    protected JavaType materializeAbstractType(DeserializationConfig config,\n+            BasicBeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        final JavaType abstractType = beanDesc.getType();\n+        \n+        /* [JACKSON-502] (1.8): Now it is possible to have multiple resolvers too,\n+         *   as they are registered via module interface.\n+         */\n+        for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {\n+            JavaType concrete = r.resolveAbstractType(config, abstractType);\n+            if (concrete != null) {\n+                return concrete;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public construction method beyond DeserializerFactory API:\n+    /* can be called from outside as well as overridden by\n+    /* sub-classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that is to actually build a bean deserializer instance.\n+     * All basic sanity checks have been done to know that what we have\n+     * may be a valid bean type, and that there are no default simple\n+     * deserializers.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonDeserializer<Object> buildBeanDeserializer(DeserializationConfig config,\n+            JavaType type, BasicBeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // First: check what creators we can use, if any\n+        ValueInstantiator valueInstantiator = findValueInstantiator(config, beanDesc);\n+        // ... since often we have nothing to go on, if we have abstract type:\n+        if (type.isAbstract()) {\n+            if (!valueInstantiator.canInstantiate()) {\n+                // and if so, need placeholder deserializer\n+                return new AbstractDeserializer(type);\n+            }\n+        }\n+        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(beanDesc);\n+        builder.setValueInstantiator(valueInstantiator);\n+         // And then setters for deserializing from JSON Object\n+        addBeanProps(config, beanDesc, builder);\n+        // managed/back reference fields/setters need special handling... first part\n+        addReferenceProperties(config, beanDesc, builder);\n+        addInjectables(config, beanDesc, builder);\n+\n+        // [JACKSON-440]: update builder now that all information is in?\n+        if (_factoryConfig.hasDeserializerModifiers()) {\n+            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                builder = mod.updateBuilder(config, beanDesc, builder);\n+            }\n+        }\n+        JsonDeserializer<?> deserializer = builder.build(property);\n+\n+        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n+        if (_factoryConfig.hasDeserializerModifiers()) {\n+            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            }\n+        }\n+        return (JsonDeserializer<Object>) deserializer;\n+        \n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonDeserializer<Object> buildThrowableDeserializer(DeserializationConfig config,\n+            JavaType type, BasicBeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // first: construct like a regular bean deserializer...\n+        BeanDeserializerBuilder builder = constructBeanDeserializerBuilder(beanDesc);\n+        builder.setValueInstantiator(findValueInstantiator(config, beanDesc));\n+\n+        addBeanProps(config, beanDesc, builder);\n+        // (and assume there won't be any back references)\n+\n+        // But then let's decorate things a bit\n+        /* To resolve [JACKSON-95], need to add \"initCause\" as setter\n+         * for exceptions (sub-classes of Throwable).\n+         */\n+        AnnotatedMethod am = beanDesc.findMethod(\"initCause\", INIT_CAUSE_PARAMS);\n+        if (am != null) { // should never be null\n+            SettableBeanProperty prop = constructSettableProperty(config, beanDesc, \"cause\", am);\n+            if (prop != null) {\n+                /* 21-Aug-2011, tatus: We may actually have found 'cause' property\n+                 *   to set (with new 1.9 code)... but let's replace it just in case,\n+                 *   otherwise can end up with odd errors.\n+                 */\n+                builder.addOrReplaceProperty(prop, true);\n+            }\n+        }\n+\n+        // And also need to ignore \"localizedMessage\"\n+        builder.addIgnorable(\"localizedMessage\");\n+        /* As well as \"message\": it will be passed via constructor,\n+         * as there's no 'setMessage()' method\n+        */\n+        builder.addIgnorable(\"message\");\n+\n+        // [JACKSON-440]: update builder now that all information is in?\n+        if (_factoryConfig.hasDeserializerModifiers()) {\n+            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                builder = mod.updateBuilder(config, beanDesc, builder);\n+            }\n+        }\n+        JsonDeserializer<?> deserializer = builder.build(property);\n+        \n+        /* At this point it ought to be a BeanDeserializer; if not, must assume\n+         * it's some other thing that can handle deserialization ok...\n+         */\n+        if (deserializer instanceof BeanDeserializer) {\n+            deserializer = new ThrowableDeserializer((BeanDeserializer) deserializer);\n+        }\n+\n+        // [JACKSON-440]: may have modifier(s) that wants to modify or replace serializer we just built:\n+        if (_factoryConfig.hasDeserializerModifiers()) {\n+            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                deserializer = mod.modifyDeserializer(config, beanDesc, deserializer);\n+            }\n+        }\n+        return (JsonDeserializer<Object>) deserializer;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for Bean deserializer construction,\n+    /* overridable by sub-classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridable method that constructs a {@link BeanDeserializerBuilder}\n+     * which is used to accumulate information needed to create deserializer\n+     * instance.\n+     * \n+     * @since 1.7\n+     */\n+    protected BeanDeserializerBuilder constructBeanDeserializerBuilder(BasicBeanDescription beanDesc) {\n+        return new BeanDeserializerBuilder(beanDesc);\n+    }\n+\n+    /**\n+     * Method that will construct standard default {@link ValueInstantiator}\n+     * using annotations (like @JsonCreator) and visibility rules\n+     * \n+     * @since 1.9\n+     */\n+    protected ValueInstantiator constructDefaultValueInstantiator(DeserializationConfig config,\n+            BasicBeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        boolean fixAccess = config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS);\n+        CreatorCollector creators =  new CreatorCollector(beanDesc, fixAccess);\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        \n+        // First, let's figure out constructor/factory-based instantiation\n+        // 23-Jan-2010, tatus: but only for concrete types\n+        if (beanDesc.getType().isConcrete()) {\n+            AnnotatedConstructor defaultCtor = beanDesc.findDefaultConstructor();\n+            if (defaultCtor != null) {\n+                if (fixAccess) {\n+                    ClassUtil.checkAndFixAccess(defaultCtor.getAnnotated());\n+                }\n+                creators.setDefaultConstructor(defaultCtor);\n+            }\n+        }\n+\n+        // need to construct suitable visibility checker:\n+        VisibilityChecker<?> vchecker = config.getDefaultVisibilityChecker();\n+        vchecker = config.getAnnotationIntrospector().findAutoDetectVisibility(beanDesc.getClassInfo(), vchecker);\n+\n+        /* Important: first add factory methods; then constructors, so\n+         * latter can override former!\n+         */\n+        _addDeserializerFactoryMethods(config, beanDesc, vchecker, intr, creators);\n+        _addDeserializerConstructors(config, beanDesc, vchecker, intr, creators);\n+\n+        return creators.constructValueInstantiator(config);\n+    }\n+\n+    protected void _addDeserializerConstructors\n+        (DeserializationConfig config, BasicBeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+         AnnotationIntrospector intr, CreatorCollector creators)\n+        throws JsonMappingException\n+    {\n+        for (AnnotatedConstructor ctor : beanDesc.getConstructors()) {\n+            int argCount = ctor.getParameterCount();\n+            if (argCount < 1) {\n+                continue;\n+            }\n+            boolean isCreator = intr.hasCreatorAnnotation(ctor);\n+            boolean isVisible =  vchecker.isCreatorVisible(ctor);\n+            // some single-arg constructors (String, number) are auto-detected\n+            if (argCount == 1) {\n+                _handleSingleArgumentConstructor(config, beanDesc, vchecker, intr, creators,\n+                        ctor, isCreator, isVisible);\n+                continue;\n+            }\n+            if (!isCreator && !isVisible) {\n+            \tcontinue;\n+            }\n+            // [JACKSON-541] improved handling a bit so:\n+            // 2 or more args; all params must have name annotations\n+            // ... or @JacksonInject (or equivalent)\n+            // But if it was auto-detected and there's no annotations, keep silent (was not meant to be a creator?)\n+            boolean annotationFound = false;\n+            /* [JACKSON-712] One more possibility; can have 1 or more injectables, and\n+             * exactly one non-annotated parameter: if so, it's still delegating.\n+             */\n+            AnnotatedParameter nonAnnotatedParam = null;\n+            int namedCount = 0;\n+            int injectCount = 0;\n+            CreatorProperty[] properties = new CreatorProperty[argCount];\n+            for (int i = 0; i < argCount; ++i) {\n+                AnnotatedParameter param = ctor.getParameter(i);\n+                String name = (param == null) ? null : intr.findPropertyNameForParam(param);\n+                Object injectId = intr.findInjectableValueId(param);\n+                if (name != null && name.length() > 0) {\n+                    ++namedCount;\n+                    properties[i] = constructCreatorProperty(config, beanDesc, name, i, param, injectId);\n+                } else if (injectId != null) {\n+                    ++injectCount;\n+                    properties[i] = constructCreatorProperty(config, beanDesc, name, i, param, injectId);\n+                } else if (nonAnnotatedParam == null) {\n+                    nonAnnotatedParam = param;\n+                }\n+            }\n+\n+            // Ok: if named or injectable, we have more work to do\n+            if (isCreator || namedCount > 0 || injectCount > 0) {\n+                // simple case; everything covered:\n+                if ((namedCount + injectCount) == argCount) {\n+                    creators.addPropertyCreator(ctor, properties);\n+                } else if ((namedCount == 0) && ((injectCount + 1) == argCount)) {\n+                    // secondary: all but one injectable, one un-annotated (un-named)\n+                    // [JACKSON-712] SHOULD support; but we won't yet (tricky to do, not impossible)\n+                    throw new IllegalArgumentException(\"Delegated constructor with Injectables not yet supported (see [JACKSON-712]) for \"\n+                            +ctor);\n+                } else { // otherwise, epic fail\n+                    throw new IllegalArgumentException(\"Argument #\"+nonAnnotatedParam.getIndex()+\" of constructor \"+ctor+\" has no property name annotation; must have name when multiple-paramater constructor annotated as Creator\");\n+                }\n+            }\n+            if (annotationFound) {\n+            \tcreators.addPropertyCreator(ctor, properties);\n+            }\n+        }\n+    }\n+\n+    protected boolean _handleSingleArgumentConstructor(DeserializationConfig config,\n+            BasicBeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+            AnnotationIntrospector intr, CreatorCollector creators,\n+            AnnotatedConstructor ctor, boolean isCreator, boolean isVisible)\n+        throws JsonMappingException\n+    {\n+        // note: if we do have parameter name, it'll be \"property constructor\":\n+        AnnotatedParameter param = ctor.getParameter(0);\n+        String name = intr.findPropertyNameForParam(param);\n+        Object injectId = intr.findInjectableValueId(param);\n+    \n+        if ((injectId != null) || (name != null && name.length() > 0)) { // property-based\n+            // We know there's a name and it's only 1 parameter.\n+            CreatorProperty[] properties = new CreatorProperty[1];\n+            properties[0] = constructCreatorProperty(config, beanDesc, name, 0, param, injectId);\n+            creators.addPropertyCreator(ctor, properties);\n+            return true;\n+        }\n+    \n+        // otherwise either 'simple' number, String, or general delegate:\n+        Class<?> type = ctor.getParameterClass(0);\n+        if (type == String.class) {\n+            if (isCreator || isVisible) {\n+                creators.addStringCreator(ctor);\n+            }\n+            return true;\n+        }\n+        if (type == int.class || type == Integer.class) {\n+            if (isCreator || isVisible) {\n+                creators.addIntCreator(ctor);\n+            }\n+            return true;\n+        }\n+        if (type == long.class || type == Long.class) {\n+            if (isCreator || isVisible) {\n+                creators.addLongCreator(ctor);\n+            }\n+            return true;\n+        }\n+        if (type == double.class || type == Double.class) {\n+            if (isCreator || isVisible) {\n+                creators.addDoubleCreator(ctor);\n+            }\n+            return true;\n+        }\n+    \n+        // Delegating Creator ok iff it has @JsonCreator (etc)\n+        if (isCreator) {\n+            creators.addDelegatingCreator(ctor);\n+            return true;\n+        }\n+        return false;\n+    }\n+    \n+    protected void _addDeserializerFactoryMethods\n+        (DeserializationConfig config, BasicBeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+         AnnotationIntrospector intr, CreatorCollector creators)\n+        throws JsonMappingException\n+    {\n+\n+        for (AnnotatedMethod factory : beanDesc.getFactoryMethods()) {\n+            int argCount = factory.getParameterCount();\n+            if (argCount < 1) {\n+                continue;\n+            }\n+            boolean isCreator = intr.hasCreatorAnnotation(factory);\n+            // some single-arg factory methods (String, number) are auto-detected\n+            if (argCount == 1) {\n+                AnnotatedParameter param = factory.getParameter(0);\n+                String name = intr.findPropertyNameForParam(param);\n+                Object injectId = intr.findInjectableValueId(param);\n+\n+                if ((injectId == null) && (name == null || name.length() == 0)) { // not property based\n+                    _handleSingleArgumentFactory(config, beanDesc, vchecker, intr, creators,\n+                            factory, isCreator);\n+                    // otherwise just ignored\n+                    continue;\n+                }\n+                // fall through if there's name\n+            } else {\n+                // more than 2 args, must be @JsonCreator\n+                if (!intr.hasCreatorAnnotation(factory)) {\n+                    continue;\n+                }\n+            }\n+            // 1 or more args; all params must have name annotations\n+            CreatorProperty[] properties = new CreatorProperty[argCount];\n+            for (int i = 0; i < argCount; ++i) {\n+                AnnotatedParameter param = factory.getParameter(i);\n+                String name = intr.findPropertyNameForParam(param);\n+                Object injectableId = intr.findInjectableValueId(param);\n+                // At this point, name annotation is NOT optional\n+                if ((name == null || name.length() == 0) && (injectableId == null)) {\n+                    throw new IllegalArgumentException(\"Argument #\"+i+\" of factory method \"+factory+\" has no property name annotation; must have when multiple-paramater static method annotated as Creator\");\n+                }\n+                properties[i] = constructCreatorProperty(config, beanDesc, name, i, param, injectableId);\n+            }\n+            creators.addPropertyCreator(factory, properties);\n+        }\n+    }\n+\n+    protected boolean _handleSingleArgumentFactory(DeserializationConfig config,\n+            BasicBeanDescription beanDesc, VisibilityChecker<?> vchecker,\n+            AnnotationIntrospector intr, CreatorCollector creators,\n+            AnnotatedMethod factory, boolean isCreator)\n+        throws JsonMappingException\n+    {\n+        Class<?> type = factory.getParameterClass(0);\n+        \n+        if (type == String.class) {\n+            if (isCreator || vchecker.isCreatorVisible(factory)) {\n+                creators.addStringCreator(factory);\n+            }\n+            return true;\n+        }\n+        if (type == int.class || type == Integer.class) {\n+            if (isCreator || vchecker.isCreatorVisible(factory)) {\n+                creators.addIntCreator(factory);\n+            }\n+            return true;\n+        }\n+        if (type == long.class || type == Long.class) {\n+            if (isCreator || vchecker.isCreatorVisible(factory)) {\n+                creators.addLongCreator(factory);\n+            }\n+            return true;\n+        }\n+        if (type == double.class || type == Double.class) {\n+            if (isCreator || vchecker.isCreatorVisible(factory)) {\n+                creators.addDoubleCreator(factory);\n+            }\n+            return true;\n+        }\n+        if (type == boolean.class || type == Boolean.class) {\n+            if (isCreator || vchecker.isCreatorVisible(factory)) {\n+                creators.addBooleanCreator(factory);\n+            }\n+            return true;\n+        }\n+        if (intr.hasCreatorAnnotation(factory)) {\n+            creators.addDelegatingCreator(factory);\n+            return true;\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Method that will construct a property object that represents\n+     * a logical property passed via Creator (constructor or static\n+     * factory method)\n+     */\n+    protected CreatorProperty constructCreatorProperty(DeserializationConfig config,\n+            BasicBeanDescription beanDesc, String name, int index,\n+            AnnotatedParameter param,\n+            Object injectableValueId)\n+        throws JsonMappingException\n+    {\n+        JavaType t0 = config.getTypeFactory().constructType(param.getParameterType(), beanDesc.bindingsForBeanType());\n+        BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), param);\n+        JavaType type = resolveType(config, beanDesc, t0, param, property);\n+        if (type != t0) {\n+            property = property.withType(type);\n+        }\n+        // Is there an annotation that specifies exact deserializer?\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(config, param, property);\n+        // If yes, we are mostly done:\n+        type = modifyTypeByAnnotation(config, param, type, name);\n+\n+        // Type deserializer: either comes from property (and already resolved)\n+        TypeDeserializer typeDeser = (TypeDeserializer) type.getTypeHandler();\n+        // or if not, based on type being referenced:\n+        if (typeDeser == null) {\n+            typeDeser = findTypeDeserializer(config, type, property);\n+        }\n+        CreatorProperty prop = new CreatorProperty(name, type, typeDeser,\n+                beanDesc.getClassAnnotations(), param, index, injectableValueId);\n+        if (deser != null) {\n+            prop = prop.withValueDeserializer(deser);\n+        }\n+        return prop;\n+    }\n+    \n+    /**\n+     * Method called to figure out settable properties for the\n+     * bean deserializer to use.\n+     *<p>\n+     * Note: designed to be overridable, and effort is made to keep interface\n+     * similar between versions.\n+     */\n+    protected void addBeanProps(DeserializationConfig config,\n+            BasicBeanDescription beanDesc, BeanDeserializerBuilder builder)\n+        throws JsonMappingException\n+    {\n+        List<BeanPropertyDefinition> props = beanDesc.findProperties();\n+        // Things specified as \"ok to ignore\"? [JACKSON-77]\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        boolean ignoreAny = false;\n+        {\n+            Boolean B = intr.findIgnoreUnknownProperties(beanDesc.getClassInfo());\n+            if (B != null) {\n+                ignoreAny = B.booleanValue();\n+                builder.setIgnoreUnknownProperties(ignoreAny);\n+            }\n+        }\n+        // Or explicit/implicit definitions?\n+        Set<String> ignored = ArrayBuilders.arrayToSet(intr.findPropertiesToIgnore(beanDesc.getClassInfo()));        \n+        for (String propName : ignored) {\n+            builder.addIgnorable(propName);\n+        }\n+        // Implicit ones via @JsonIgnore and equivalent?\n+        {\n+            Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames();\n+            if (ignored2 != null) {\n+                for (String propName : ignored2) {\n+                    // allow ignoral of similarly named JSON property, but do not force;\n+                    // latter means NOT adding this to 'ignored':\n+                    builder.addIgnorable(propName);\n+                }\n+            }\n+        }\n+        HashMap<Class<?>,Boolean> ignoredTypes = new HashMap<Class<?>,Boolean>();\n+        \n+        // These are all valid setters, but we do need to introspect bit more\n+        for (BeanPropertyDefinition property : props) {\n+            String name = property.getName();\n+            if (ignored.contains(name)) { // explicit ignoral using @JsonIgnoreProperties needs to block entries\n+                continue;\n+            }\n+            /* [JACKSON-700] If property as passed via constructor parameter, we must\n+             *   handle things in special way. Not sure what is the most optimal way...\n+             *   for now, let's just call a (new) method in builder, which does nothing.\n+             */\n+            if (property.hasConstructorParameter()) {\n+                // but let's call a method just to allow custom builders to be aware...\n+                builder.addCreatorProperty(property);\n+                continue;\n+            }\n+            // primary: have a setter?\n+            if (property.hasSetter()) {\n+                AnnotatedMethod setter = property.getSetter();\n+                // [JACKSON-429] Some types are declared as ignorable as well\n+                Class<?> type = setter.getParameterClass(0);\n+                if (isIgnorableType(config, beanDesc, type, ignoredTypes)) {\n+                    // important: make ignorable, to avoid errors if value is actually seen\n+                    builder.addIgnorable(name);\n+                    continue;\n+                }\n+                SettableBeanProperty prop = constructSettableProperty(config, beanDesc, name, setter);\n+                if (prop != null) {\n+                    builder.addProperty(prop);\n+                }\n+                continue;\n+            }\n+            if (property.hasField()) {\n+                AnnotatedField field = property.getField();\n+                // [JACKSON-429] Some types are declared as ignorable as well\n+                Class<?> type = field.getRawType();\n+                if (isIgnorableType(config, beanDesc, type, ignoredTypes)) {\n+                    // important: make ignorable, to avoid errors if value is actually seen\n+                    builder.addIgnorable(name);\n+                    continue;\n+                }\n+                SettableBeanProperty prop = constructSettableProperty(config, beanDesc, name, field);\n+                if (prop != null) {\n+                    builder.addProperty(prop);\n+                }\n+            }\n+        }\n+        // Also, do we have a fallback \"any\" setter?\n+        AnnotatedMethod anySetter = beanDesc.findAnySetter();\n+        if (anySetter != null) {\n+            builder.setAnySetter(constructAnySetter(config, beanDesc, anySetter));\n+        }\n+\n+        /* As per [JACKSON-88], may also need to consider getters\n+         * for Map/Collection properties\n+         */\n+        /* also, as per [JACKSON-328], should not override fields (or actual setters),\n+         * thus these are added AFTER adding fields\n+         */\n+        if (config.isEnabled(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS)) {\n+            /* Hmmh. We have to assume that 'use getters as setters' also\n+             * implies 'yes, do auto-detect these getters'? (if not, we'd\n+             * need to add AUTO_DETECT_GETTERS to deser config too, not\n+             * just ser config)\n+             */\n+            for (BeanPropertyDefinition property : props) {\n+                if (property.hasGetter()) {\n+                    String name = property.getName();\n+                    if (builder.hasProperty(name) || ignored.contains(name)) {\n+                        continue;\n+                    }\n+                    AnnotatedMethod getter = property.getGetter();\n+                    // should only consider Collections and Maps, for now?\n+                    Class<?> rt = getter.getRawType();\n+                    if (Collection.class.isAssignableFrom(rt) || Map.class.isAssignableFrom(rt)) {\n+                        if (!ignored.contains(name) && !builder.hasProperty(name)) {\n+                            builder.addProperty(constructSetterlessProperty(config, beanDesc, name, getter));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that will find if bean has any managed- or back-reference properties,\n+     * and if so add them to bean, to be linked during resolution phase.\n+     * \n+     * @since 1.6\n+     */\n+    protected void addReferenceProperties(DeserializationConfig config,\n+            BasicBeanDescription beanDesc, BeanDeserializerBuilder builder)\n+        throws JsonMappingException\n+    {\n+        // and then back references, not necessarily found as regular properties\n+        Map<String,AnnotatedMember> refs = beanDesc.findBackReferenceProperties();\n+        if (refs != null) {\n+            for (Map.Entry<String, AnnotatedMember> en : refs.entrySet()) {\n+                String name = en.getKey();\n+                AnnotatedMember m = en.getValue();\n+                if (m instanceof AnnotatedMethod) {\n+                    builder.addBackReferenceProperty(name, constructSettableProperty(\n+                            config, beanDesc, m.getName(), (AnnotatedMethod) m));\n+                } else {\n+                    builder.addBackReferenceProperty(name, constructSettableProperty(\n+                            config, beanDesc, m.getName(), (AnnotatedField) m));\n+                }\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Method called locate all members used for value injection (if any),\n+     * constructor {@link com.fasterxml.jackson.databind.deser.impl.ValueInjector} instances, and add them to builder.\n+     * \n+     * @since 1.9\n+     */\n+    protected void addInjectables(DeserializationConfig config,\n+            BasicBeanDescription beanDesc, BeanDeserializerBuilder builder)\n+        throws JsonMappingException\n+    {\n+        Map<Object, AnnotatedMember> raw = beanDesc.findInjectables();\n+        if (raw != null) {\n+            boolean fixAccess = config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS);\n+            for (Map.Entry<Object, AnnotatedMember> entry : raw.entrySet()) {\n+                AnnotatedMember m = entry.getValue();\n+                if (fixAccess) {\n+                    m.fixAccess(); // to ensure we can call it\n+                }\n+                builder.addInjectable(m.getName(), beanDesc.resolveType(m.getGenericType()),\n+                        beanDesc.getClassAnnotations(), m, entry.getKey());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method called to construct fallback {@link SettableAnyProperty}\n+     * for handling unknown bean properties, given a method that\n+     * has been designated as such setter.\n+     */\n+    protected SettableAnyProperty constructAnySetter(DeserializationConfig config,\n+            BasicBeanDescription beanDesc, AnnotatedMethod setter)\n+        throws JsonMappingException\n+    {\n+        if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+            setter.fixAccess(); // to ensure we can call it\n+        }\n+        // we know it's a 2-arg method, second arg is the value\n+        JavaType type = beanDesc.bindingsForBeanType().resolveType(setter.getParameterType(1));\n+        BeanProperty.Std property = new BeanProperty.Std(setter.getName(), type, beanDesc.getClassAnnotations(), setter);\n+        type = resolveType(config, beanDesc, type, setter, property);\n+\n+        /* AnySetter can be annotated with @JsonClass (etc) just like a\n+         * regular setter... so let's see if those are used.\n+         * Returns null if no annotations, in which case binding will\n+         * be done at a later point.\n+         */\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(config, setter, property);\n+        if (deser != null) {\n+            return new SettableAnyProperty(property, setter, type, deser);\n+        }\n+        /* Otherwise, method may specify more specific (sub-)class for\n+         * value (no need to check if explicit deser was specified):\n+         */\n+        type = modifyTypeByAnnotation(config, setter, type, property.getName());\n+        return new SettableAnyProperty(property, setter, type, null);\n+    }\n+\n+    /**\n+     * Method that will construct a regular bean property setter using\n+     * the given setter method.\n+     *\n+     * @param setter Method to use to set property value; or null if none.\n+     *    Null only for \"setterless\" properties\n+     *\n+     * @return Property constructed, if any; or null to indicate that\n+     *   there should be no property based on given definitions.\n+     */\n+    protected SettableBeanProperty constructSettableProperty(DeserializationConfig config,\n+            BasicBeanDescription beanDesc, String name,\n+            AnnotatedMethod setter)\n+        throws JsonMappingException\n+    {\n+        // need to ensure method is callable (for non-public)\n+        if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+            setter.fixAccess();\n+        }\n+\n+        // note: this works since we know there's exactly one argument for methods\n+        JavaType t0 = beanDesc.bindingsForBeanType().resolveType(setter.getParameterType(0));\n+        BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), setter);\n+        JavaType type = resolveType(config, beanDesc, t0, setter, property);\n+        // did type change?\n+        if (type != t0) {\n+            property = property.withType(type);\n+        }\n+        \n+        /* First: does the Method specify the deserializer to use?\n+         * If so, let's use it.\n+         */\n+        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(config, setter, property);\n+        type = modifyTypeByAnnotation(config, setter, type, name);\n+        TypeDeserializer typeDeser = type.getTypeHandler();\n+        SettableBeanProperty prop = new SettableBeanProperty.MethodProperty(name, type, typeDeser,\n+                beanDesc.getClassAnnotations(), setter);\n+        if (propDeser != null) {\n+            prop = prop.withValueDeserializer(propDeser);\n+        }\n+        // [JACKSON-235]: need to retain name of managed forward references:\n+        AnnotationIntrospector.ReferenceProperty ref = config.getAnnotationIntrospector().findReferenceType(setter);\n+        if (ref != null && ref.isManagedReference()) {\n+            prop.setManagedReferenceName(ref.getName());\n+        }\n+        return prop;\n+    }\n+\n+    protected SettableBeanProperty constructSettableProperty(DeserializationConfig config,\n+            BasicBeanDescription beanDesc, String name, AnnotatedField field)\n+        throws JsonMappingException\n+    {\n+        // need to ensure method is callable (for non-public)\n+        if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+            field.fixAccess();\n+        }\n+        JavaType t0 = beanDesc.bindingsForBeanType().resolveType(field.getGenericType());\n+        BeanProperty.Std property = new BeanProperty.Std(name, t0, beanDesc.getClassAnnotations(), field);\n+        JavaType type = resolveType(config, beanDesc, t0, field, property);\n+        // did type change?\n+        if (type != t0) {\n+            property = property.withType(type);\n+        }\n+        /* First: does the Method specify the deserializer to use?\n+         * If so, let's use it.\n+         */\n+        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(config, field, property);\n+        type = modifyTypeByAnnotation(config, field, type, name);\n+        TypeDeserializer typeDeser = type.getTypeHandler();\n+        SettableBeanProperty prop = new SettableBeanProperty.FieldProperty(name, type, typeDeser,\n+                beanDesc.getClassAnnotations(), field);\n+        if (propDeser != null) {\n+            prop = prop.withValueDeserializer(propDeser);\n+        }\n+        // [JACKSON-235]: need to retain name of managed forward references:\n+        AnnotationIntrospector.ReferenceProperty ref = config.getAnnotationIntrospector().findReferenceType(field);\n+        if (ref != null && ref.isManagedReference()) {\n+            prop.setManagedReferenceName(ref.getName());\n+        }\n+        return prop;\n+    }\n+\n+    /**\n+     * Method that will construct a regular bean property setter using\n+     * the given setter method.\n+     *\n+     * @param getter Method to use to get property value to modify, null if\n+     *    none. Non-null for \"setterless\" properties.\n+     */\n+    protected SettableBeanProperty constructSetterlessProperty(DeserializationConfig config,\n+            BasicBeanDescription beanDesc, String name, AnnotatedMethod getter)\n+        throws JsonMappingException\n+    {\n+        // need to ensure it is callable now:\n+        if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+            getter.fixAccess();\n+        }\n+\n+        JavaType type = getter.getType(beanDesc.bindingsForBeanType());\n+        /* First: does the Method specify the deserializer to use?\n+         * If so, let's use it.\n+         */\n+        BeanProperty.Std property = new BeanProperty.Std(name, type, beanDesc.getClassAnnotations(), getter);\n+        // @TODO: create BeanProperty to pass?\n+        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(config, getter, property);\n+        type = modifyTypeByAnnotation(config, getter, type, name);\n+        TypeDeserializer typeDeser = type.getTypeHandler();\n+        SettableBeanProperty prop = new SettableBeanProperty.SetterlessProperty(name, type, typeDeser,\n+                beanDesc.getClassAnnotations(), getter);\n+        if (propDeser != null) {\n+            prop = prop.withValueDeserializer(propDeser);\n+        }\n+        return prop;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for Bean deserializer, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method used to skip processing for types that we know\n+     * can not be (i.e. are never consider to be) beans: \n+     * things like primitives, Arrays, Enums, and proxy types.\n+     *<p>\n+     * Note that usually we shouldn't really be getting these sort of\n+     * types anyway; but better safe than sorry.\n+     */\n+    protected boolean isPotentialBeanType(Class<?> type)\n+    {\n+        String typeStr = ClassUtil.canBeABeanType(type);\n+        if (typeStr != null) {\n+            throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n+        }\n+        if (ClassUtil.isProxyType(type)) {\n+            throw new IllegalArgumentException(\"Can not deserialize Proxy class \"+type.getName()+\" as a Bean\");\n+        }\n+        /* also: can't deserialize some local classes: static are ok; in-method not;\n+         * and with [JACKSON-594], other non-static inner classes are ok\n+         */\n+        typeStr = ClassUtil.isLocalType(type, true);\n+        if (typeStr != null) {\n+            throw new IllegalArgumentException(\"Can not deserialize Class \"+type.getName()+\" (of type \"+typeStr+\") as a Bean\");\n+        }\n+    \treturn true;\n+    }\n+\n+    /**\n+     * Helper method that will check whether given raw type is marked as always ignorable\n+     * (for purpose of ignoring properties with type)\n+     */\n+    protected boolean isIgnorableType(DeserializationConfig config, BasicBeanDescription beanDesc,\n+            Class<?> type, Map<Class<?>,Boolean> ignoredTypes)\n+    {\n+        Boolean status = ignoredTypes.get(type);\n+        if (status == null) {\n+            BasicBeanDescription desc = config.introspectClassAnnotations(type);\n+            status = config.getAnnotationIntrospector().isIgnorableType(desc.getClassInfo());\n+            // We default to 'false', ie. not ignorable\n+            if (status == null) {\n+                status = Boolean.FALSE;\n+            }\n+        }\n+        return status;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerModifier.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.deser.BeanDeserializer;\n+import com.fasterxml.jackson.databind.deser.BeanDeserializerFactory;\n+import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n+\n+/**\n+ * Abstract class that defines API for objects that can be registered (for {@link BeanDeserializerFactory}\n+ * to participate in constructing {@link BeanDeserializer} instances.\n+ * This is typically done by modules that want alter some aspects of deserialization\n+ * process; and is preferable to sub-classing of {@link BeanDeserializerFactory}.\n+ *<p>\n+ * Sequence in which callback methods are called is as follows:\n+ *  <li>updateBuilder is called once all initial pieces for building deserializer\n+ *    have been collected\n+ *   </li>\n+ *  <li><code>modifyDeserializer</code> is called after deserializer has been built\n+ *    by {@link BeanDeserializerBuilder}\n+ *    but before it is returned to be used\n+ *   </li>\n+ * </ol>\n+ *<p>\n+ * Default method implementations are \"no-op\"s, meaning that methods are implemented\n+ * but have no effect; this is mostly so that new methods can be added in later\n+ * versions.\n+ * \n+ * @since 1.7\n+ */\n+public abstract class BeanDeserializerModifier\n+{\n+    /**\n+     * Method called by {@link BeanDeserializerFactory} when it has collected\n+     * basic information such as tentative list of properties to deserialize.\n+     *\n+     * Implementations may choose to modify state of builder (to affect deserializer being\n+     * built), or even completely replace it (if they want to build different kind of\n+     * deserializer). Typically changes mostly concern set of properties to deserialize.\n+     */\n+    public BeanDeserializerBuilder updateBuilder(DeserializationConfig config,\n+            BasicBeanDescription beanDesc, BeanDeserializerBuilder builder) {\n+        return builder;\n+    }\n+\n+    /**\n+     * Method called by {@link BeanDeserializerFactory} after constructing default\n+     * bean deserializer instance with properties collected and ordered earlier.\n+     * Implementations can modify or replace given deserializer and return deserializer\n+     * to use. Note that although initial deserializer being passed is of type\n+     * {@link BeanDeserializer}, modifiers may return deserializers of other types;\n+     * and this is why implementations must check for type before casting.\n+     */\n+    public JsonDeserializer<?> modifyDeserializer(DeserializationConfig config,\n+            BasicBeanDescription beanDesc, JsonDeserializer<?> deserializer) {\n+        return deserializer;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableAnyProperty.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.lang.reflect.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+\n+\n+/**\n+ * Class that represents a \"wildcard\" set method which can be used\n+ * to generically set values of otherwise unmapped (aka \"unknown\")\n+ * properties read from Json content.\n+ *<p>\n+ * !!! Note: might make sense to refactor to share some code\n+ * with {@link SettableBeanProperty}?\n+ */\n+public final class SettableAnyProperty\n+{\n+    /**\n+     * Method used for setting \"any\" properties, along with annotation\n+     * information. Retained to allow contextualization of any properties.\n+     * \n+     * @since 1.7\n+     */\n+    final protected BeanProperty _property;\n+    \n+    /**\n+     * Physical JDK object used for assigning properties.\n+     */\n+    final protected Method _setter;\n+\n+    final protected JavaType _type;\n+\n+    protected JsonDeserializer<Object> _valueDeserializer;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @deprecated Since 1.9 - use variant that takes deserializer\n+     */\n+    @Deprecated\n+    public SettableAnyProperty(BeanProperty property, AnnotatedMethod setter, JavaType type) {\n+        this(property, setter, type, null);\n+    }\n+\n+    public SettableAnyProperty(BeanProperty property, AnnotatedMethod setter, JavaType type,\n+            JsonDeserializer<Object> valueDeser) {\n+        this(property, setter.getAnnotated(), type, valueDeser);\n+    }\n+\n+    public SettableAnyProperty(BeanProperty property, Method rawSetter, JavaType type,\n+            JsonDeserializer<Object> valueDeser) {\n+        _property = property;\n+        _type = type;\n+        _setter = rawSetter;\n+        _valueDeserializer = valueDeser;\n+    }\n+\n+    public SettableAnyProperty withValueDeserializer(JsonDeserializer<Object> deser) {\n+        return new SettableAnyProperty(_property, _setter, _type, deser);\n+    }\n+    \n+    /**\n+     * @deprecated Since 1.9 - construct with deserializer\n+     */\n+    @Deprecated\n+    public void setValueDeserializer(JsonDeserializer<Object> deser)\n+    {\n+        if (_valueDeserializer != null) { // sanity check\n+            throw new IllegalStateException(\"Already had assigned deserializer for SettableAnyProperty\");\n+        }\n+        _valueDeserializer = deser;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, accessors\n+    /**********************************************************\n+     */\n+\n+    public BeanProperty getProperty() { return _property; }\n+    \n+    public boolean hasValueDeserializer() { return (_valueDeserializer != null); }\n+\n+    public JavaType getType() { return _type; }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, deserialization\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called to deserialize appropriate value, given parser (and\n+     * context), and set it using appropriate method (a setter method).\n+     */\n+    public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n+                                        Object instance, String propName)\n+        throws IOException, JsonProcessingException\n+    {\n+        set(instance, propName, deserialize(jp, ctxt));\n+    }\n+\n+    public final Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.VALUE_NULL) {\n+            return null;\n+        }\n+        return _valueDeserializer.deserialize(jp, ctxt);\n+    }\n+\n+    public final void set(Object instance, String propName, Object value)\n+        throws IOException\n+    {\n+        try {\n+            _setter.invoke(instance, propName, value);\n+        } catch (Exception e) {\n+            _throwAsIOE(e, propName, value);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @param e Exception to re-throw or wrap\n+     * @param propName Name of property (from Json input) to set\n+     * @param value Value of the property\n+     */\n+    protected void _throwAsIOE(Exception e, String propName, Object value)\n+        throws IOException\n+    {\n+        if (e instanceof IllegalArgumentException) {\n+            String actType = (value == null) ? \"[NULL]\" : value.getClass().getName();\n+            StringBuilder msg = new StringBuilder(\"Problem deserializing \\\"any\\\" property '\").append(propName);\n+            msg.append(\"' of class \"+getClassName()+\" (expected type: \").append(_type);\n+            msg.append(\"; actual type: \").append(actType).append(\")\");\n+            String origMsg = e.getMessage();\n+            if (origMsg != null) {\n+                msg.append(\", problem: \").append(origMsg);\n+            } else {\n+                msg.append(\" (no error message provided)\");\n+            }\n+            throw new JsonMappingException(msg.toString(), null, e);\n+        }\n+        if (e instanceof IOException) {\n+            throw (IOException) e;\n+        }\n+        if (e instanceof RuntimeException) {\n+            throw (RuntimeException) e;\n+        }\n+        // let's wrap the innermost problem\n+        Throwable t = e;\n+        while (t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        throw new JsonMappingException(t.getMessage(), null, t);\n+    }\n+\n+    private String getClassName() { return _setter.getDeclaringClass().getName(); }\n+\n+    @Override public String toString() { return \"[any property on class \"+getClassName()+\"]\"; }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.core.util.InternCache;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedField;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+\n+/**\n+ * Base class for settable properties of a bean: contains\n+ * both type and name definitions, and reflection-based set functionality.\n+ * Concrete sub-classes implement details, so that both field- and\n+ * setter-backed properties can be handled\n+ */\n+public abstract class SettableBeanProperty\n+    implements BeanProperty // since 1.7\n+{\n+    /**\n+     * Logical name of the property (often but not always derived\n+     * from the setter method name)\n+     */\n+    protected final String _propName;\n+\n+    /**\n+     * Base type for property; may be a supertype of actual value.\n+     */\n+    protected final JavaType _type;\n+    \n+    /**\n+     * Class that contains this property (either class that declares\n+     * the property or one of its subclasses), class that is\n+     * deserialized using deserializer that contains this property.\n+     */\n+    protected final Annotations _contextAnnotations;\n+    \n+    /**\n+     * Deserializer used for handling property value.\n+     */\n+    protected JsonDeserializer<Object> _valueDeserializer;\n+\n+    /**\n+     * If value will contain type information (to support\n+     * polymorphic handling), this is the type deserializer\n+     * used to handle type resolution.\n+     */\n+    protected TypeDeserializer _valueTypeDeserializer;\n+    \n+    /**\n+     * Object used to figure out value to be used when 'null' literal is encountered in JSON.\n+     * For most types simply Java null, but for primitive types must\n+     * be a non-null value (like Integer.valueOf(0) for int).\n+     * \n+     * @since 1.7\n+     */\n+    protected NullProvider _nullProvider;\n+\n+    /**\n+     * If property represents a managed (forward) reference\n+     * (see [JACKSON-235]), we will need name of reference for\n+     * later linking.\n+     */\n+    protected String _managedReferenceName;\n+\n+    /**\n+     * Index of property (within all property of a bean); assigned\n+     * when all properties have been collected. Order of entries\n+     * is arbitrary, but once indexes are assigned they are not\n+     * changed.\n+     * \n+     * @since 1.7\n+     */\n+    protected int _propertyIndex = -1;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle (construct & configure)\n+    /**********************************************************\n+     */\n+\n+    protected SettableBeanProperty(String propName, JavaType type, TypeDeserializer typeDeser,\n+            Annotations contextAnnotations)\n+    {\n+        /* 09-Jan-2009, tatu: Intern()ing makes sense since Jackson parsed\n+         *   field names are (usually) interned too, hence lookups will be faster.\n+         */\n+        // 23-Oct-2009, tatu: should this be disabled wrt [JACKSON-180]?\n+        if (propName == null || propName.length() == 0) {\n+            _propName = \"\";\n+        } else {\n+            _propName = InternCache.instance.intern(propName);\n+        }\n+        _type = type;\n+        _contextAnnotations = contextAnnotations;\n+        _valueTypeDeserializer = typeDeser;\n+    }\n+\n+    /**\n+     * Basic copy-constructor for sub-classes to use.\n+     * \n+     * @since 1.9\n+     */\n+    protected SettableBeanProperty(SettableBeanProperty src)\n+    {\n+        _propName = src._propName;\n+        _type = src._type;\n+        _contextAnnotations = src._contextAnnotations;\n+        _valueDeserializer = src._valueDeserializer;\n+        _valueTypeDeserializer = src._valueTypeDeserializer;\n+        _nullProvider = src._nullProvider;\n+        _managedReferenceName = src._managedReferenceName;\n+        _propertyIndex = src._propertyIndex;\n+    }\n+\n+    /**\n+     * Copy-with-deserializer-change constructor for sub-classes to use.\n+     * \n+     * @since 1.9\n+     */\n+    protected SettableBeanProperty(SettableBeanProperty src, JsonDeserializer<Object> deser)\n+    {\n+        _propName = src._propName;\n+        _type = src._type;\n+        _contextAnnotations = src._contextAnnotations;\n+        _valueTypeDeserializer = src._valueTypeDeserializer;\n+        _managedReferenceName = src._managedReferenceName;\n+        _propertyIndex = src._propertyIndex;\n+\n+        _valueDeserializer = deser;\n+        if (deser == null) {\n+            _nullProvider = null;\n+        } else {\n+            Object nvl = deser.getNullValue();\n+            _nullProvider = (nvl == null) ? null : new NullProvider(_type, nvl);\n+        }\n+    }\n+    \n+    @Deprecated\n+    public void setValueDeserializer(JsonDeserializer<Object> deser)\n+    {\n+        if (_valueDeserializer != null) { // sanity check\n+            throw new IllegalStateException(\"Already had assigned deserializer for property '\"+getName()+\"' (class \"+getDeclaringClass().getName()+\")\");\n+        }\n+        _valueDeserializer = deser;\n+        Object nvl = _valueDeserializer.getNullValue();\n+        _nullProvider = (nvl == null) ? null : new NullProvider(_type, nvl);\n+    }\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    public abstract SettableBeanProperty withValueDeserializer(JsonDeserializer<Object> deser);\n+    \n+    public void setManagedReferenceName(String n) {\n+        _managedReferenceName = n;\n+    }\n+    \n+    /**\n+     * Method used to assign index for property.\n+     * \n+     * @since 1.7\n+     */\n+    public void assignIndex(int index) {\n+        if (_propertyIndex != -1) {\n+            throw new IllegalStateException(\"Property '\"+getName()+\"' already had index (\"+_propertyIndex+\"), trying to assign \"+index);\n+        }\n+        _propertyIndex = index;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* BeanProperty impl\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public final String getName() { return _propName; }\n+\n+    @Override\n+    public JavaType getType() { return _type; }\n+\n+    @Override\n+    public abstract <A extends Annotation> A getAnnotation(Class<A> acls);\n+\n+    @Override\n+    public abstract AnnotatedMember getMember();\n+\n+    @Override\n+    public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n+        return _contextAnnotations.get(acls);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+\n+    protected final Class<?> getDeclaringClass() {\n+        return getMember().getDeclaringClass();\n+    }\n+    \n+    /**\n+     * @deprecated Since 1.7, use {@link #getName} instead.\n+     */\n+    @Deprecated\n+    public String getPropertyName() { return _propName; }\n+\n+    public String getManagedReferenceName() { return _managedReferenceName; }\n+\n+    public boolean hasValueDeserializer() { return (_valueDeserializer != null); }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public boolean hasValueTypeDeserializer() { return (_valueTypeDeserializer != null); }\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    public JsonDeserializer<Object> getValueDeserializer() { return _valueDeserializer; }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public TypeDeserializer getValueTypeDeserializer() { return _valueTypeDeserializer; }\n+    \n+    /**\n+     * Method for accessing unique index of this property; indexes are\n+     * assigned once all properties of a {@link BeanDeserializer} have\n+     * been collected.\n+     * \n+     * @return Index of this property\n+     * \n+     * @since 1.7 Although note that it was misspelled as \"getProperytIndex\"; fixed in 1.9\n+     */\n+    public int getPropertyIndex() { return _propertyIndex; }\n+\n+    /**\n+     * @deprecated Since 1.9: use {@link #getPropertyIndex} instead\n+     */\n+    @Deprecated\n+    public int getProperytIndex() { return getPropertyIndex(); }\n+\n+    /**\n+     * Accessor for id of injectable value, if this bean property supports\n+     * value injection.\n+     * \n+     * @since 1.9\n+     */\n+    public Object getInjectableValueId() { return null; }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to deserialize appropriate value, given parser (and\n+     * context), and set it using appropriate mechanism.\n+     * Pre-condition is that passed parser must point to the first token\n+     * that should be consumed to produce the value (the only value for\n+     * scalars, multiple for Objects and Arrays).\n+     */\n+    public abstract void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n+                                           Object instance)\n+        throws IOException, JsonProcessingException;\n+\n+    public abstract void set(Object instance, Object value)\n+        throws IOException;\n+\n+    /**\n+     * This method is needed by some specialized bean deserializers,\n+     * and also called by some {@link #deserializeAndSet} implementations.\n+     *<p>\n+     * Pre-condition is that passed parser must point to the first token\n+     * that should be consumed to produce the value (the only value for\n+     * scalars, multiple for Objects and Arrays).\n+     */\n+    public final Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.VALUE_NULL) {\n+            return (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt);\n+        }\n+        if (_valueTypeDeserializer != null) {\n+            return _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer);\n+        }\n+        return _valueDeserializer.deserialize(jp, ctxt);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that takes in exception of any type, and casts or wraps it\n+     * to an IOException or its subclass.\n+     */\n+    protected void _throwAsIOE(Exception e, Object value)\n+        throws IOException\n+    {\n+        if (e instanceof IllegalArgumentException) {\n+            String actType = (value == null) ? \"[NULL]\" : value.getClass().getName();\n+            StringBuilder msg = new StringBuilder(\"Problem deserializing property '\").append(getPropertyName());\n+            msg.append(\"' (expected type: \").append(getType());\n+            msg.append(\"; actual type: \").append(actType).append(\")\");\n+            String origMsg = e.getMessage();\n+            if (origMsg != null) {\n+                msg.append(\", problem: \").append(origMsg);\n+            } else {\n+                msg.append(\" (no error message provided)\");\n+            }\n+            throw new JsonMappingException(msg.toString(), null, e);\n+        }\n+        _throwAsIOE(e);\n+    }\n+\n+    protected IOException _throwAsIOE(Exception e)\n+        throws IOException\n+    {\n+        if (e instanceof IOException) {\n+            throw (IOException) e;\n+        }\n+        if (e instanceof RuntimeException) {\n+            throw (RuntimeException) e;\n+        }\n+        // let's wrap the innermost problem\n+        Throwable th = e;\n+        while (th.getCause() != null) {\n+            th = th.getCause();\n+        }\n+        throw new JsonMappingException(th.getMessage(), null, th);\n+    }\n+    \n+    @Override public String toString() { return \"[property '\"+getName()+\"']\"; }\n+\n+    /*\n+    /**********************************************************\n+    /* Implementation classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This concrete sub-class implements property that is set\n+     * using regular \"setter\" method.\n+     */\n+    public final static class MethodProperty\n+        extends SettableBeanProperty\n+    {\n+        protected final AnnotatedMethod _annotated;\n+        \n+        /**\n+         * Setter method for modifying property value; used for\n+         * \"regular\" method-accessible properties.\n+         */\n+        protected final Method _setter;\n+\n+        public MethodProperty(String name, JavaType type, TypeDeserializer typeDeser,\n+                Annotations contextAnnotations, AnnotatedMethod method)\n+        {\n+            super(name, type, typeDeser, contextAnnotations);\n+            _annotated = method;\n+            _setter = method.getAnnotated();\n+        }\n+\n+        protected MethodProperty(MethodProperty src, JsonDeserializer<Object> deser) {\n+            super(src, deser);\n+            _annotated = src._annotated;\n+            _setter = src._setter;\n+        }\n+        \n+        @Override\n+        public MethodProperty withValueDeserializer(JsonDeserializer<Object> deser) {\n+            return new MethodProperty(this, deser);\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* BeanProperty impl\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+            return _annotated.getAnnotation(acls);\n+        }\n+\n+        @Override public AnnotatedMember getMember() {  return _annotated; }\n+\n+        /*\n+        /**********************************************************\n+        /* Overridden methods\n+        /**********************************************************\n+         */\n+\n+        @Override\n+        public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n+                Object instance)\n+            throws IOException, JsonProcessingException\n+        {\n+            set(instance, deserialize(jp, ctxt));\n+        }\n+\n+        @Override\n+        public final void set(Object instance, Object value)\n+            throws IOException\n+        {\n+            try {\n+                _setter.invoke(instance, value);\n+            } catch (Exception e) {\n+                _throwAsIOE(e, value);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This concrete sub-class implements Collection or Map property that is\n+     * indirectly by getting the property value and directly modifying it.\n+     */\n+    public final static class SetterlessProperty\n+        extends SettableBeanProperty\n+    {\n+        protected final AnnotatedMethod _annotated;\n+\n+        /**\n+         * Get method for accessing property value used to access property\n+         * (of Collection or Map type) to modify.\n+         */\n+        protected final Method _getter;\n+\n+        public SetterlessProperty(String name, JavaType type, TypeDeserializer typeDeser,\n+                Annotations contextAnnotations, AnnotatedMethod method)\n+            {\n+            super(name, type, typeDeser, contextAnnotations);\n+            _annotated = method;\n+            _getter = method.getAnnotated();\n+        }\n+\n+        protected SetterlessProperty(SetterlessProperty src, JsonDeserializer<Object> deser) {\n+            super(src, deser);\n+            _annotated = src._annotated;\n+            _getter = src._getter;\n+        }\n+        \n+        @Override\n+        public SetterlessProperty withValueDeserializer(JsonDeserializer<Object> deser) {\n+            return new SetterlessProperty(this, deser);\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* BeanProperty impl\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+            return _annotated.getAnnotation(acls);\n+        }\n+\n+        @Override public AnnotatedMember getMember() {  return _annotated; }\n+\n+        /*\n+        /**********************************************************\n+        /* Overridden methods\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public final void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n+                Object instance)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken t = jp.getCurrentToken();\n+            if (t == JsonToken.VALUE_NULL) {\n+                /* Hmmh. Is this a problem? We won't be setting anything, so it's\n+                 * equivalent of empty Collection/Map in this case\n+                 */\n+                return;\n+            }\n+\n+            // Ok: then, need to fetch Collection/Map to modify:\n+            Object toModify;\n+            try {\n+                toModify = _getter.invoke(instance);\n+            } catch (Exception e) {\n+                _throwAsIOE(e);\n+                return; // never gets here\n+            }\n+            /* Note: null won't work, since we can't then inject anything\n+             * in. At least that's not good in common case. However,\n+             * theoretically the case where we get JSON null might\n+             * be compatible. If so, implementation could be changed.\n+             */\n+            if (toModify == null) {\n+                throw new JsonMappingException(\"Problem deserializing 'setterless' property '\"+getName()+\"': get method returned null\");\n+            }\n+            _valueDeserializer.deserialize(jp, ctxt, toModify);\n+        }\n+\n+        @Override\n+        public final void set(Object instance, Object value)\n+            throws IOException\n+        {\n+            throw new UnsupportedOperationException(\"Should never call 'set' on setterless property\");\n+        }\n+    }\n+\n+    /**\n+     * This concrete sub-class implements property that is set\n+     * directly assigning to a Field.\n+     */\n+    public final static class FieldProperty\n+        extends SettableBeanProperty\n+    {\n+        protected final AnnotatedField _annotated;\n+\n+        /**\n+         * Actual field to set when deserializing this property.\n+         */\n+        protected final Field _field;\n+\n+        public FieldProperty(String name, JavaType type, TypeDeserializer typeDeser,\n+                Annotations contextAnnotations, AnnotatedField field)\n+        {\n+            super(name, type, typeDeser, contextAnnotations);\n+            _annotated = field;\n+            _field = field.getAnnotated();\n+        }\n+\n+        protected FieldProperty(FieldProperty src, JsonDeserializer<Object> deser) {\n+            super(src, deser);\n+            _annotated = src._annotated;\n+            _field = src._field;\n+        }\n+        \n+        @Override\n+        public FieldProperty withValueDeserializer(JsonDeserializer<Object> deser) {\n+            return new FieldProperty(this, deser);\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* BeanProperty impl\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+            return _annotated.getAnnotation(acls);\n+        }\n+\n+        @Override public AnnotatedMember getMember() {  return _annotated; }\n+\n+        /*\n+        /**********************************************************\n+        /* Overridden methods\n+        /**********************************************************\n+         */\n+\n+        @Override\n+        public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n+                                      Object instance)\n+            throws IOException, JsonProcessingException\n+        {\n+            set(instance, deserialize(jp, ctxt));\n+        }\n+\n+        @Override\n+        public final void set(Object instance, Object value)\n+            throws IOException\n+        {\n+            try {\n+                _field.set(instance, value);\n+            } catch (Exception e) {\n+                _throwAsIOE(e, value);\n+            }\n+        }\n+    }\n+\n+     /**\n+     * Wrapper property that is used to handle managed (forward) properties\n+     * (see [JACKSON-235] for more information). Basically just need to\n+     * delegate first to actual forward property, and \n+     * \n+     * @author tatu\n+     */\n+    public final static class ManagedReferenceProperty\n+        extends SettableBeanProperty\n+    {\n+        protected final String _referenceName;\n+        \n+        /**\n+         * Flag that indicates whether property to handle is a container type\n+         * (array, Collection, Map) or not.\n+         */\n+        protected final boolean _isContainer;\n+        \n+        protected final SettableBeanProperty _managedProperty;\n+\n+        protected final SettableBeanProperty _backProperty;\n+        \n+        public ManagedReferenceProperty(String refName,\n+                SettableBeanProperty forward, SettableBeanProperty backward,\n+                Annotations contextAnnotations,\n+                boolean isContainer)\n+        {\n+            super(forward.getName(), forward.getType(), forward._valueTypeDeserializer,\n+                    contextAnnotations);\n+            _referenceName = refName;\n+            _managedProperty = forward;\n+            _backProperty = backward;\n+            _isContainer = isContainer;\n+        }\n+\n+        protected ManagedReferenceProperty(ManagedReferenceProperty src, JsonDeserializer<Object> deser)\n+        {\n+            super(src, deser);\n+            _referenceName = src._referenceName;\n+            _isContainer = src._isContainer;\n+            _managedProperty = src._managedProperty;\n+            _backProperty = src._backProperty;\n+        }\n+        \n+        @Override\n+        public ManagedReferenceProperty withValueDeserializer(JsonDeserializer<Object> deser) {\n+            return new ManagedReferenceProperty(this, deser);\n+        }\n+        \n+        /*\n+        /**********************************************************\n+        /* BeanProperty impl\n+        /**********************************************************\n+         */\n+        \n+        @Override\n+        public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+            return _managedProperty.getAnnotation(acls);\n+        }\n+\n+        @Override public AnnotatedMember getMember() {  return _managedProperty.getMember(); }\n+\n+        /*\n+        /**********************************************************\n+        /* Overridden methods\n+        /**********************************************************\n+         */\n+    \n+        @Override\n+        public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n+                                      Object instance)\n+            throws IOException, JsonProcessingException\n+        {\n+            set(instance, _managedProperty.deserialize(jp, ctxt));\n+        }\n+    \n+        @Override\n+        public final void set(Object instance, Object value)\n+            throws IOException\n+        {\n+            _managedProperty.set(instance, value);\n+            /* And then back reference, if (and only if!) we actually have a non-null\n+             * reference\n+             */\n+            if (value != null) {\n+                if (_isContainer) { // ok, this gets ugly... but has to do for now\n+                    if (value instanceof Object[]) {\n+                        for (Object ob : (Object[]) value) {\n+                            if (ob != null) {\n+                                _backProperty.set(ob, instance);                            \n+                            }\n+                        }\n+                    } else if (value instanceof Collection<?>) {\n+                        for (Object ob : (Collection<?>) value) {\n+                            if (ob != null) {\n+                                _backProperty.set(ob, instance);                            \n+                            }\n+                        }\n+                    } else if (value instanceof Map<?,?>) {\n+                        for (Object ob : ((Map<?,?>) value).values()) {\n+                            if (ob != null) {\n+                                _backProperty.set(ob, instance);                            \n+                            }\n+                        }\n+                    } else {\n+                        throw new IllegalStateException(\"Unsupported container type (\"+value.getClass().getName()\n+                                +\") when resolving reference '\"+_referenceName+\"'\");\n+                    }\n+                } else {\n+                    _backProperty.set(value, instance);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This sub-class is used to handle special case of value being a\n+     * non-static inner class. If so, we will have to use a special\n+     * alternative for default constructor; but otherwise can delegate\n+     * to regular implementation.\n+     * \n+     * @since 1.9\n+     */\n+    public final static class InnerClassProperty\n+        extends SettableBeanProperty\n+    {\n+        /**\n+         * Actual property that we use after value construction.\n+         */\n+        protected final SettableBeanProperty _delegate;\n+\n+        /**\n+         * Single-arg constructor we use for value instantiation.\n+         */\n+        protected final Constructor<?> _creator;\n+        \n+        public InnerClassProperty(SettableBeanProperty delegate,\n+                Constructor<?> ctor)\n+        {\n+            super(delegate);\n+            _delegate = delegate;\n+            _creator = ctor;\n+        }\n+\n+        protected InnerClassProperty(InnerClassProperty src, JsonDeserializer<Object> deser)\n+        {\n+            super(src, deser);\n+            _delegate = src._delegate.withValueDeserializer(deser);\n+            _creator = src._creator;\n+        }\n+        \n+        @Override\n+        public InnerClassProperty withValueDeserializer(JsonDeserializer<Object> deser) {\n+            return new InnerClassProperty(this, deser);\n+        }\n+        \n+        // // // BeanProperty impl\n+        \n+        @Override\n+        public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+            return _delegate.getAnnotation(acls);\n+        }\n+\n+        @Override public AnnotatedMember getMember() {  return _delegate.getMember(); }\n+\n+        // // //  Overridden methods\n+\n+        @Override\n+        public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n+                Object bean)\n+            throws IOException, JsonProcessingException\n+        {\n+            // mostly copied from super class impl:\n+            JsonToken t = jp.getCurrentToken();\n+            Object value;\n+            if (t == JsonToken.VALUE_NULL) {\n+                value = (_nullProvider == null) ? null : _nullProvider.nullValue(ctxt);\n+            } else if (_valueTypeDeserializer != null) {\n+                value = _valueDeserializer.deserializeWithType(jp, ctxt, _valueTypeDeserializer);\n+            } else  { // the usual case\n+                try {\n+                    value = _creator.newInstance(bean);\n+                } catch (Exception e) {\n+                    ClassUtil.unwrapAndThrowAsIAE(e, \"Failed to instantiate class \"+_creator.getDeclaringClass().getName()+\", problem: \"+e.getMessage());\n+                    value = null;\n+                }\n+                _valueDeserializer.deserialize(jp, ctxt, value);\n+            }\n+            set(bean, value);\n+        }\n+\n+        @Override\n+        public final void set(Object instance, Object value) throws IOException\n+        {\n+            _delegate.set(instance, value);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other helper classes\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * To support [JACKSON-420] we need bit more indirection; this is used to produce\n+     * artificial failure for primitives that don't accept JSON null as value.\n+     */\n+    protected final static class NullProvider\n+    {\n+        private final Object _nullValue;\n+\n+        private final boolean _isPrimitive;\n+        \n+        private final Class<?> _rawType;\n+        \n+        protected NullProvider(JavaType type, Object nullValue)\n+        {\n+            _nullValue = nullValue;\n+            // [JACKSON-420]\n+            _isPrimitive = type.isPrimitive();\n+            _rawType = type.getRawClass();\n+        }\n+\n+        public Object nullValue(DeserializationContext ctxt) throws JsonProcessingException\n+        {\n+            if (_isPrimitive && ctxt.isEnabled(DeserializationConfig.Feature.FAIL_ON_NULL_FOR_PRIMITIVES)) {\n+                throw ctxt.mappingException(\"Can not map JSON null into type \"+_rawType.getName()\n+                        +\" (set DeserializationConfig.Feature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\");\n+            }\n+            return _nullValue;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializationContext.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n+import com.fasterxml.jackson.databind.util.ArrayBuilders;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.LinkedNode;\n+import com.fasterxml.jackson.databind.util.ObjectBuffer;\n+\n+\n+/**\n+ * Default implementation of {@link DeserializationContext}.\n+ */\n+public class StdDeserializationContext\n+    extends DeserializationContext\n+{\n+    /**\n+     * Let's limit length of error messages, for cases where underlying data\n+     * may be very large -- no point in spamming logs with megs of meaningless\n+     * data.\n+     */\n+    final static int MAX_ERROR_STR_LEN = 500;\n+\n+    // // // Configuration\n+\n+    /**\n+     * Currently active parser used for deserialization.\n+     * May be different from the outermost parser\n+     * when content is buffered.\n+     */\n+    protected JsonParser _parser;\n+\n+    /**\n+     * @since 1.5\n+     */\n+    protected final DeserializerProvider _deserProvider;\n+\n+    /**\n+     * @since 1.9\n+     */\n+    protected final InjectableValues _injectableValues;\n+    \n+    // // // Helper object recycling\n+\n+    protected ArrayBuilders _arrayBuilders;\n+\n+    protected ObjectBuffer _objectBuffer;\n+\n+    protected DateFormat _dateFormat;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public StdDeserializationContext(DeserializationConfig config, JsonParser jp,\n+            DeserializerProvider prov, InjectableValues injectableValues)\n+    {\n+    \tsuper(config);\n+        _parser = jp;\n+        _deserProvider = prov;\n+        _injectableValues = injectableValues;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public DeserializerProvider getDeserializerProvider() {\n+        return _deserProvider;\n+    }\n+\n+    /**\n+     * Method for accessing the currently active parser.\n+     * May be different from the outermost parser\n+     * when content is buffered.\n+     *<p>\n+     * Use of this method is discouraged: if code has direct access\n+     * to the active parser, that should be used instead.\n+     */\n+    @Override\n+    public JsonParser getParser() { return _parser; }\n+\n+    @Override\n+    public Object findInjectableValue(Object valueId,\n+            BeanProperty forProperty, Object beanInstance)\n+    {\n+        if (_injectableValues == null) {\n+            throw new IllegalStateException(\"No 'injectableValues' configured, can not inject value with id [\"+valueId+\"]\");\n+        }\n+        return _injectableValues.findInjectableValue(valueId, this, forProperty, beanInstance);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, helper object recycling\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final ObjectBuffer leaseObjectBuffer()\n+    {\n+        ObjectBuffer buf = _objectBuffer;\n+        if (buf == null) {\n+            buf = new ObjectBuffer();\n+        } else {\n+            _objectBuffer = null;\n+        }\n+        return buf;\n+    }\n+\n+    @Override\n+    public final void returnObjectBuffer(ObjectBuffer buf)\n+    {\n+        /* Already have a reusable buffer? Let's retain bigger one\n+         * (or if equal, favor newer one, shorter life-cycle)\n+         */\n+        if (_objectBuffer == null\n+            || buf.initialCapacity() >= _objectBuffer.initialCapacity()) {\n+            _objectBuffer = buf;\n+        }\n+    }\n+\n+    @Override\n+    public final ArrayBuilders getArrayBuilders()\n+    {\n+        if (_arrayBuilders == null) {\n+            _arrayBuilders = new ArrayBuilders();\n+        }\n+        return _arrayBuilders;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Parsing methods that may use reusable/recyclable objects\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Date parseDate(String dateStr)\n+        throws IllegalArgumentException\n+    {\n+        try {\n+            return getDateFormat().parse(dateStr);\n+        } catch (ParseException pex) {\n+            throw new IllegalArgumentException(pex.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public Calendar constructCalendar(Date d)\n+    {\n+        /* 08-Jan-2008, tatu: not optimal, but should work for the\n+         *   most part; let's revise as needed.\n+         */\n+        Calendar c = Calendar.getInstance();\n+        c.setTime(d);\n+        return c;\n+    }\n+    /*\n+    /**********************************************************\n+    /* Public API, problem handling, reporting\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method deserializers can call to inform configured {@link DeserializationProblemHandler}s\n+     * of an unrecognized property.\n+     * \n+     * @since 1.5\n+     */\n+    @Override\n+    public boolean handleUnknownProperty(JsonParser jp, JsonDeserializer<?> deser, Object instanceOrClass, String propName)\n+        throws IOException, JsonProcessingException\n+    {\n+        LinkedNode<DeserializationProblemHandler> h = _config.getProblemHandlers();\n+        if (h != null) {\n+            /* 04-Jan-2009, tatu: Ugh. Need to mess with currently active parser\n+             *   since parser is not explicitly passed to handler... that was a mistake\n+             */\n+            JsonParser oldParser = _parser;\n+            _parser = jp;\n+            try {\n+                while (h != null) {\n+                    // Can bail out if it's handled\n+                    if (h.value().handleUnknownProperty(this, deser, instanceOrClass, propName)) {\n+                        return true;\n+                    }\n+                    h = h.next();\n+                }\n+            } finally {\n+                _parser = oldParser;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public JsonMappingException mappingException(Class<?> targetClass) {\n+        return mappingException(targetClass, _parser.getCurrentToken());\n+    }\n+\n+    @Override\n+    public JsonMappingException mappingException(Class<?> targetClass, JsonToken token)\n+    {\n+        String clsName = _calcName(targetClass);\n+        return JsonMappingException.from(_parser, \"Can not deserialize instance of \"+clsName+\" out of \"+token+\" token\");\n+    }\n+    \n+    @Override\n+    public JsonMappingException instantiationException(Class<?> instClass, Throwable t)\n+    {\n+        return JsonMappingException.from(_parser,\n+                \"Can not construct instance of \"+instClass.getName()+\", problem: \"+t.getMessage(),\n+                t);\n+    }\n+\n+    @Override\n+    public JsonMappingException instantiationException(Class<?> instClass, String msg)\n+    {\n+        return JsonMappingException.from(_parser, \"Can not construct instance of \"+instClass.getName()+\", problem: \"+msg);\n+    }\n+    \n+    /**\n+     * Method that will construct an exception suitable for throwing when\n+     * some String values are acceptable, but the one encountered is not\n+     */\n+    @Override\n+    public JsonMappingException weirdStringException(Class<?> instClass, String msg)\n+    {\n+        return JsonMappingException.from(_parser, \"Can not construct instance of \"+instClass.getName()+\" from String value '\"+_valueDesc()+\"': \"+msg);\n+    }\n+    \n+    @Override\n+    public JsonMappingException weirdNumberException(Class<?> instClass, String msg)\n+    {\n+        return JsonMappingException.from(_parser, \"Can not construct instance of \"+instClass.getName()+\" from number value (\"+_valueDesc()+\"): \"+msg);\n+    }\n+\n+    @Override\n+    public JsonMappingException weirdKeyException(Class<?> keyClass, String keyValue, String msg)\n+    {\n+        return JsonMappingException.from(_parser, \"Can not construct Map key of type \"+keyClass.getName()+\" from String \\\"\"+_desc(keyValue)+\"\\\": \"+msg);\n+    }\n+\n+    @Override\n+    public JsonMappingException wrongTokenException(JsonParser jp, JsonToken expToken, String msg)\n+    {\n+        return JsonMappingException.from(jp, \"Unexpected token (\"+jp.getCurrentToken()+\"), expected \"+expToken+\": \"+msg);\n+    }\n+    \n+    @Override\n+    public JsonMappingException unknownFieldException(Object instanceOrClass, String fieldName)\n+    {\n+        return UnrecognizedPropertyException.from(_parser, instanceOrClass, fieldName);\n+    }\n+\n+    @Override\n+    public JsonMappingException unknownTypeException(JavaType type, String id)\n+    {\n+        return JsonMappingException.from(_parser, \"Could not resolve type id '\"+id+\"' into a subtype of \"+type);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable internal methods\n+    /**********************************************************\n+     */\n+\n+    protected DateFormat getDateFormat()\n+    {\n+        if (_dateFormat == null) {\n+            // must create a clone since Formats are not thread-safe:\n+            _dateFormat = (DateFormat)_config.getDateFormat().clone();\n+        }\n+        return _dateFormat;\n+    }\n+\n+    protected String determineClassName(Object instance)\n+    {\n+        return ClassUtil.getClassDescription(instance);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other internal methods\n+    /**********************************************************\n+     */\n+\n+    protected String _calcName(Class<?> cls)\n+    {\n+        if (cls.isArray()) {\n+            return _calcName(cls.getComponentType())+\"[]\";\n+        }\n+        return cls.getName();\n+    }\n+    \n+    protected String _valueDesc()\n+    {\n+        try {\n+            return _desc(_parser.getText());\n+        } catch (Exception e) {\n+            return \"[N/A]\";\n+        }\n+    }\n+    protected String _desc(String desc)\n+    {\n+        // !!! should we quote it? (in case there are control chars, linefeeds)\n+        if (desc.length() > MAX_ERROR_STR_LEN) {\n+            desc = desc.substring(0, MAX_ERROR_STR_LEN) + \"]...[\" + desc.substring(desc.length() - MAX_ERROR_STR_LEN);\n+        }\n+        return desc;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializer.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.TypeDeserializer;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;\n+\n+\n+/**\n+ * @deprecated Since 1.9, use {@link com.fasterxml.jackson.databind.deser.std.StdDeserializer} instead.\n+ */\n+@Deprecated\n+public abstract class StdDeserializer<T>\n+    extends com.fasterxml.jackson.databind.deser.std.StdDeserializer<T>\n+{\n+    protected StdDeserializer(Class<?> vc) {\n+        super(vc);\n+    }\n+\n+    protected StdDeserializer(JavaType valueType) {\n+        super(valueType);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deprecated inner classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @deprecated Since 1.9 use {@link com.fasterxml.jackson.databind.deser.std.ClassDeserializer} instead.\n+     */\n+    @Deprecated\n+    @JacksonStdImpl\n+    public class ClassDeserializer extends com.fasterxml.jackson.databind.deser.std.ClassDeserializer { }\n+\n+    /**\n+     * @deprecated Since 1.9 use {@link com.fasterxml.jackson.databind.deser.std.CalendarDeserializer} instead.\n+     */\n+    @Deprecated\n+    @JacksonStdImpl\n+    public class CalendarDeserializer extends com.fasterxml.jackson.databind.deser.std.CalendarDeserializer { }\n+    \n+    /**\n+     * @deprecated Since 1.9 use {@link com.fasterxml.jackson.databind.deser.std.StringDeserializer} instead.\n+     */\n+    @Deprecated\n+    @JacksonStdImpl\n+    public final static class StringDeserializer\n+        extends StdScalarDeserializer<String>\n+    {\n+        public StringDeserializer() { super(String.class); }\n+\n+        @Override\n+        public String deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken curr = jp.getCurrentToken();\n+            if (curr == JsonToken.VALUE_STRING) {\n+                return jp.getText();\n+            }\n+            if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+                Object ob = jp.getEmbeddedObject();\n+                if (ob == null) {\n+                    return null;\n+                }\n+                if (ob instanceof byte[]) {\n+                    return Base64Variants.getDefaultVariant().encode((byte[]) ob, false);\n+                }\n+                return ob.toString();\n+            }\n+            if (curr.isScalarValue()) {\n+                return jp.getText();\n+            }\n+            throw ctxt.mappingException(_valueClass, curr);\n+        }\n+\n+        @SuppressWarnings(\"deprecation\")\n+        @Override\n+        public String deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+                TypeDeserializer typeDeserializer)\n+            throws IOException, JsonProcessingException\n+        {\n+            return deserialize(jp, ctxt);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializerProvider.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.BeanDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.StdKeyDeserializers;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.type.*;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.RootNameLookup;\n+\n+\n+/**\n+ * Default {@link DeserializerProvider} implementation.\n+ * Handles low-level caching (non-root) aspects of deserializer\n+ * handling; all construction details are delegated to configured\n+ *  {@link DeserializerFactory} instance that the provider owns.\n+ */\n+public class StdDeserializerProvider\n+    extends DeserializerProvider\n+{\n+    /*\n+    /**********************************************************\n+    /* Caching\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Set of available key deserializers is currently limited\n+     * to standard types; and all known instances are storing\n+     * in this map.\n+     */\n+    final static HashMap<JavaType, KeyDeserializer> _keyDeserializers = StdKeyDeserializers.constructAll();\n+\n+    /**\n+     * We will also cache some dynamically constructed deserializers;\n+     * specifically, ones that are expensive to construct.\n+     * This currently means bean and Enum deserializers; array, List and Map\n+     * deserializers will not be cached.\n+     *<p>\n+     * Given that we don't expect much concurrency for additions\n+     * (should very quickly converge to zero after startup), let's\n+     * explicitly define a low concurrency setting.\n+     */\n+    final protected ConcurrentHashMap<JavaType, JsonDeserializer<Object>> _cachedDeserializers\n+        = new ConcurrentHashMap<JavaType, JsonDeserializer<Object>>(64, 0.75f, 2);\n+\n+    /**\n+     * During deserializer construction process we may need to keep track of partially\n+     * completed deserializers, to resolve cyclic dependencies. This is the\n+     * map used for storing deserializers before they are fully complete.\n+     */\n+    final protected HashMap<JavaType, JsonDeserializer<Object>> _incompleteDeserializers\n+        = new HashMap<JavaType, JsonDeserializer<Object>>(8);\n+\n+    final protected RootNameLookup _rootNames;\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory responsible for constructing actual deserializers, if not\n+     * one of pre-configured types.\n+     */\n+    protected DeserializerFactory _factory;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Default constructor. Equivalent to calling\n+     *<pre>\n+     *   new StdDeserializerProvider(BeanDeserializerFactory.instance);\n+     *</pre>\n+     */\n+    public StdDeserializerProvider() { this(BeanDeserializerFactory.instance); }\n+\n+    public StdDeserializerProvider(DeserializerFactory f) {\n+        _factory = f;\n+        _rootNames = new RootNameLookup();\n+    }\n+\n+    @Override\n+    public DeserializerProvider withAdditionalDeserializers(Deserializers d) {\n+        return withFactory(_factory.withAdditionalDeserializers(d));\n+    }\n+\n+    @Override\n+    public DeserializerProvider withAdditionalKeyDeserializers(KeyDeserializers d) {\n+        return withFactory(_factory.withAdditionalKeyDeserializers(d));\n+    }\n+    \n+    @Override\n+    public DeserializerProvider withDeserializerModifier(BeanDeserializerModifier modifier) {\n+        return withFactory(_factory.withDeserializerModifier(modifier));\n+    }\n+\n+    @Override\n+    public DeserializerProvider withAbstractTypeResolver(AbstractTypeResolver resolver) {\n+        return withFactory(_factory.withAbstractTypeResolver(resolver));\n+    }\n+\n+    @Override\n+    public DeserializerProvider withValueInstantiators(ValueInstantiators instantiators) {\n+        return withFactory(_factory.withValueInstantiators(instantiators));\n+    }\n+\n+    @Override\n+    public StdDeserializerProvider withFactory(DeserializerFactory factory) {\n+        // sanity-check to try to prevent hard-to-debug problems; sub-classes MUST override this method\n+        if (this.getClass() != StdDeserializerProvider.class) {\n+            throw new IllegalStateException(\"DeserializerProvider of type \"\n+                    +this.getClass().getName()+\" does not override 'withFactory()' method\");\n+        }\n+        return new StdDeserializerProvider(factory);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Abstract methods impls\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType mapAbstractType(DeserializationConfig config, JavaType type)\n+            throws JsonMappingException\n+    {\n+        return _factory.mapAbstractType(config, type);\n+    }\n+\n+    @Override\n+    public SerializedString findExpectedRootName(DeserializationConfig config, JavaType type)\n+         throws JsonMappingException\n+    {\n+        return _rootNames.findRootName(type, config);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public JsonDeserializer<Object> findValueDeserializer(DeserializationConfig config,\n+            JavaType propertyType, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n+        if (deser != null) {\n+            // [JACKSON-385]: need to support contextualization:\n+            if (deser instanceof ContextualDeserializer<?>) {\n+                JsonDeserializer<?> d = ((ContextualDeserializer<?>) deser).createContextual(config, property);\n+                deser = (JsonDeserializer<Object>) d;\n+            }\n+            return deser;\n+        }\n+        // If not, need to request factory to construct (or recycle)\n+        deser = _createAndCacheValueDeserializer(config, propertyType, property);\n+        if (deser == null) {\n+            /* Should we let caller handle it? Let's have a helper method\n+             * decide it; can throw an exception, or return a valid\n+             * deserializer\n+             */\n+            deser = _handleUnknownValueDeserializer(propertyType);\n+        }\n+        // [JACKSON-385]: need to support contextualization:\n+        if (deser instanceof ContextualDeserializer<?>) {\n+            JsonDeserializer<?> d = ((ContextualDeserializer<?>) deser).createContextual(config, property);\n+            deser = (JsonDeserializer<Object>) d;\n+        }\n+        return deser;\n+    }\n+    \n+    @Override\n+    public JsonDeserializer<Object> findTypedValueDeserializer(DeserializationConfig config,\n+            JavaType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser = findValueDeserializer(config, type, property);\n+        TypeDeserializer typeDeser = _factory.findTypeDeserializer(config, type, property);\n+        if (typeDeser != null) {\n+            return new WrappedDeserializer(typeDeser, deser);\n+        }\n+        return deser;\n+    }\n+\n+    @Override\n+    public KeyDeserializer findKeyDeserializer(DeserializationConfig config,\n+            JavaType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // 1.8: check if there are custom key deserializers...\n+        KeyDeserializer kd = _factory.createKeyDeserializer(config, type, property);\n+        if (kd == null) {\n+            // No serializer needed if it's plain old String, or Object/untyped\n+            Class<?> raw = type.getRawClass();\n+            if (raw == String.class || raw == Object.class) {\n+                return null;\n+            }\n+            // Most other keys are of limited number of static types\n+            KeyDeserializer kdes = _keyDeserializers.get(type);\n+            if (kdes != null) {\n+                return kdes;\n+            }\n+            // And then other one-offs; first, Enum:\n+            if (type.isEnumType()) {\n+                return StdKeyDeserializers.constructEnumKeyDeserializer(config, type);\n+            }\n+            // One more thing: can we find ctor(String) or valueOf(String)?\n+            kdes = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+            if (kdes != null) {\n+                return kdes;\n+            }\n+            if (kd == null) {\n+                // otherwise, will probably fail:\n+                return _handleUnknownKeyDeserializer(type);\n+            }\n+        }\n+        // One more thing: contextuality:\n+        if (kd instanceof ContextualKeyDeserializer) {\n+            kd = ((ContextualKeyDeserializer) kd).createContextual(config, property);\n+        }\n+        return kd;\n+    }\n+\n+    /**\n+     * Method that can be called to find out whether a deserializer can\n+     * be found for given type\n+     */\n+    @Override\n+    public boolean hasValueDeserializerFor(DeserializationConfig config, JavaType type)\n+    {\n+        /* Note: mostly copied from findValueDeserializer, except for\n+         * handling of unknown types\n+         */\n+        JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n+        if (deser == null) {\n+            try {\n+                deser = _createAndCacheValueDeserializer(config, type, null);\n+            } catch (Exception e) {\n+                return false;\n+            }\n+        }\n+        return (deser != null);\n+    }\n+\n+    @Override\n+    public int cachedDeserializersCount() {\n+        return _cachedDeserializers.size();\n+    }\n+\n+    /**\n+     * Method that will drop all dynamically constructed deserializers (ones that\n+     * are counted as result value for {@link #cachedDeserializersCount}).\n+     * This can be used to remove memory usage (in case some deserializers are\n+     * only used once or so), or to force re-construction of deserializers after\n+     * configuration changes for mapper than owns the provider.\n+     * \n+     * @since 1.4\n+     */\n+    @Override\n+    public void flushCachedDeserializers() {\n+        _cachedDeserializers.clear();       \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable helper methods\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<Object> _findCachedDeserializer(JavaType type)\n+    {\n+        if (type == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        return _cachedDeserializers.get(type);\n+    }\n+\n+    /**\n+     * Method that will try to create a deserializer for given type,\n+     * and resolve and cache it if necessary\n+     * \n+     * @param config Configuration\n+     * @param type Type of property to deserializer\n+     * @param property Property (field, setter, ctor arg) to use deserializer for\n+     */\n+    protected JsonDeserializer<Object>_createAndCacheValueDeserializer(DeserializationConfig config,\n+            JavaType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        /* Only one thread to construct deserializers at any given point in time;\n+         * limitations necessary to ensure that only completely initialized ones\n+         * are visible and used.\n+         */\n+        synchronized (_incompleteDeserializers) {\n+            // Ok, then: could it be that due to a race condition, deserializer can now be found?\n+            JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n+            if (deser != null) {\n+                return deser;\n+            }\n+            int count = _incompleteDeserializers.size();\n+            // Or perhaps being resolved right now?\n+            if (count > 0) {\n+                deser = _incompleteDeserializers.get(type);\n+                if (deser != null) {\n+                    return deser;\n+                }\n+            }\n+            // Nope: need to create and possibly cache\n+            try {\n+                return _createAndCache2(config, type, property);\n+            } finally {\n+                // also: any deserializers that have been created are complete by now\n+                if (count == 0 && _incompleteDeserializers.size() > 0) {\n+                    _incompleteDeserializers.clear();\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that handles actual construction (via factory) and caching (both\n+     * intermediate and eventual)\n+     */\n+    protected JsonDeserializer<Object> _createAndCache2(DeserializationConfig config, JavaType type,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser;\n+        try {\n+            deser = _createDeserializer(config, type, property);\n+        } catch (IllegalArgumentException iae) {\n+            /* We better only expose checked exceptions, since those\n+             * are what caller is expected to handle\n+             */\n+            throw new JsonMappingException(iae.getMessage(), null, iae);\n+        }\n+        if (deser == null) {\n+            return null;\n+        }\n+        /* cache resulting deserializer? always true for \"plain\" BeanDeserializer\n+         * (but can be re-defined for sub-classes by using @JsonCachable!)\n+         */\n+        // 08-Jun-2010, tatu: Related to [JACKSON-296], need to avoid caching MapSerializers... so:\n+        boolean isResolvable = (deser instanceof ResolvableDeserializer);\n+        boolean addToCache = (deser.getClass() == BeanDeserializer.class);\n+        if (!addToCache) {\n+            // 14-Feb-2011, tatu: As per [JACKSON-487], try fully blocking annotation access:\n+            if (config.isEnabled(DeserializationConfig.Feature.USE_ANNOTATIONS)) {\n+                AnnotationIntrospector aintr = config.getAnnotationIntrospector();\n+                // note: pass 'null' to prevent mix-ins from being used\n+                AnnotatedClass ac = AnnotatedClass.construct(deser.getClass(), aintr, null);\n+                Boolean cacheAnn = aintr.findCachability(ac);\n+                if (cacheAnn != null) {\n+                    addToCache = cacheAnn.booleanValue();\n+                }\n+            }\n+        }\n+        /* we will temporarily hold on to all created deserializers (to\n+         * handle cyclic references, and possibly reuse non-cached\n+         * deserializers (list, map))\n+         */\n+        /* 07-Jun-2010, tatu: Danger: [JACKSON-296] was caused by accidental\n+         *   resolution of a reference -- couple of ways to prevent this;\n+         *   either not add Lists or Maps, or clear references eagerly.\n+         *   Let's actually do both; since both seem reasonable.\n+         */\n+        /* Need to resolve? Mostly done for bean deserializers; required for\n+         * resolving cyclic references.\n+         */\n+        if (isResolvable) {\n+            _incompleteDeserializers.put(type, deser);\n+            _resolveDeserializer(config, (ResolvableDeserializer)deser);\n+            _incompleteDeserializers.remove(type);\n+        }\n+        if (addToCache) {\n+            _cachedDeserializers.put(type, deser);\n+        }\n+        return deser;\n+    }\n+\n+    /* Refactored so we can isolate the casts that require suppression\n+     * of type-safety warnings.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonDeserializer<Object> _createDeserializer(DeserializationConfig config, \n+            JavaType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        if (type.isEnumType()) {\n+            return (JsonDeserializer<Object>) _factory.createEnumDeserializer(config, this, type, property);\n+        }\n+        if (type.isContainerType()) {\n+            if (type.isArrayType()) {\n+                return (JsonDeserializer<Object>)_factory.createArrayDeserializer(config, this,\n+                        (ArrayType) type, property);\n+            }\n+            if (type.isMapLikeType()) {\n+                MapLikeType mlt = (MapLikeType) type;\n+                if (mlt.isTrueMapType()) {\n+                    return (JsonDeserializer<Object>)_factory.createMapDeserializer(config, this,\n+                            (MapType) mlt, property);\n+                }\n+                return (JsonDeserializer<Object>)_factory.createMapLikeDeserializer(config, this,\n+                        mlt, property);\n+            }\n+            if (type.isCollectionLikeType()) {\n+                CollectionLikeType clt = (CollectionLikeType) type;\n+                if (clt.isTrueCollectionType()) {\n+                    return (JsonDeserializer<Object>)_factory.createCollectionDeserializer(config, this,\n+                            (CollectionType) clt, property);\n+                }\n+                return (JsonDeserializer<Object>)_factory.createCollectionLikeDeserializer(config, this,\n+                        clt, property);\n+            }\n+        }\n+\n+        // 02-Mar-2009, tatu: Let's consider JsonNode to be a type of its own\n+        if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n+            return (JsonDeserializer<Object>)_factory.createTreeDeserializer(config, this, type, property);\n+        }\n+        return (JsonDeserializer<Object>)_factory.createBeanDeserializer(config, this, type, property);\n+    }\n+\n+    protected void _resolveDeserializer(DeserializationConfig config, ResolvableDeserializer ser)\n+        throws JsonMappingException\n+    {\n+        ser.resolve(config, this);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable error reporting methods\n+    /**********************************************************\n+     */\n+\n+    protected JsonDeserializer<Object> _handleUnknownValueDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        /* Let's try to figure out the reason, to give better error\n+         * messages\n+         */\n+        Class<?> rawClass = type.getRawClass();\n+        if (!ClassUtil.isConcrete(rawClass)) {\n+            throw new JsonMappingException(\"Can not find a Value deserializer for abstract type \"+type);\n+        }\n+        throw new JsonMappingException(\"Can not find a Value deserializer for type \"+type);\n+    }\n+\n+    protected KeyDeserializer _handleUnknownKeyDeserializer(JavaType type)\n+        throws JsonMappingException\n+    {\n+        throw new JsonMappingException(\"Can not find a (Map) Key deserializer for type \"+type);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /*  Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Simple deserializer that will call configured type deserializer, passing\n+     * in configured data deserializer, and exposing it all as a simple\n+     * deserializer.\n+     */\n+    protected final static class WrappedDeserializer\n+        extends JsonDeserializer<Object>\n+    {\n+        final TypeDeserializer _typeDeserializer;\n+        final JsonDeserializer<Object> _deserializer;\n+\n+        public WrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<Object> deser)\n+        {\n+            super();\n+            _typeDeserializer = typeDeser;\n+            _deserializer = deser;\n+        }\n+\n+        @Override\n+        public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+                throws IOException, JsonProcessingException\n+        {\n+            return _deserializer.deserializeWithType(jp, ctxt, _typeDeserializer);\n+        }\n+\n+        @Override\n+        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+                throws IOException, JsonProcessingException\n+        {\n+            // should never happen? (if it can, could call on that object)\n+            throw new IllegalStateException(\"Type-wrapped deserializer's deserializeWithType should never get called\");\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/StdDeserializers.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.AtomicBooleanDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.CalendarDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.ClassDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.DateDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.FromStringDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.JavaTypeDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.StringDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.TimestampDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.TokenBufferDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.UntypedObjectDeserializer;\n+import com.fasterxml.jackson.databind.type.*;\n+\n+/**\n+ * Helper class used to contain simple/well-known deserializers for core JDK types.\n+ *<p>\n+ * Note: as of Jackson 1.9, we use type-erased class for registering, since\n+ * some types may come either as type-erased or typed (for example,\n+ * <code>java.lang.Class</code>).\n+ */\n+class StdDeserializers\n+{\n+    final HashMap<ClassKey, JsonDeserializer<Object>> _deserializers\n+        = new HashMap<ClassKey, JsonDeserializer<Object>>();\n+\n+    private StdDeserializers()\n+    {\n+        // First, add the fall-back \"untyped\" deserializer:\n+        add(new UntypedObjectDeserializer());\n+\n+        // Then String and String-like converters:\n+        StdDeserializer<?> strDeser = new StringDeserializer();\n+        add(strDeser, String.class);\n+        add(strDeser, CharSequence.class);\n+        add(new ClassDeserializer());\n+\n+        // Then primitive-wrappers (simple):\n+        add(new StdDeserializer.BooleanDeserializer(Boolean.class, null));\n+        add(new StdDeserializer.ByteDeserializer(Byte.class, null));\n+        add(new StdDeserializer.ShortDeserializer(Short.class, null));\n+        add(new StdDeserializer.CharacterDeserializer(Character.class, null));\n+        add(new StdDeserializer.IntegerDeserializer(Integer.class, null));\n+        add(new StdDeserializer.LongDeserializer(Long.class, null));\n+        add(new StdDeserializer.FloatDeserializer(Float.class, null));\n+        add(new StdDeserializer.DoubleDeserializer(Double.class, null));\n+        \n+        /* And actual primitives: difference is the way nulls are to be\n+         * handled...\n+         */\n+        add(new StdDeserializer.BooleanDeserializer(Boolean.TYPE, Boolean.FALSE));\n+        add(new StdDeserializer.ByteDeserializer(Byte.TYPE, Byte.valueOf((byte)(0))));\n+        add(new StdDeserializer.ShortDeserializer(Short.TYPE, Short.valueOf((short)0)));\n+        add(new StdDeserializer.CharacterDeserializer(Character.TYPE, Character.valueOf('\\0')));\n+        add(new StdDeserializer.IntegerDeserializer(Integer.TYPE, Integer.valueOf(0)));\n+        add(new StdDeserializer.LongDeserializer(Long.TYPE, Long.valueOf(0L)));\n+        add(new StdDeserializer.FloatDeserializer(Float.TYPE, Float.valueOf(0.0f)));\n+        add(new StdDeserializer.DoubleDeserializer(Double.TYPE, Double.valueOf(0.0)));\n+        \n+        // and related\n+        add(new StdDeserializer.NumberDeserializer());\n+        add(new StdDeserializer.BigDecimalDeserializer());\n+        add(new StdDeserializer.BigIntegerDeserializer());\n+        \n+        add(new CalendarDeserializer());\n+        add(new DateDeserializer());\n+        /* 24-Jan-2010, tatu: When including type information, we may\n+         *    know that we specifically need GregorianCalendar...\n+         */\n+        add(new CalendarDeserializer(GregorianCalendar.class),\n+                GregorianCalendar.class);\n+        add(new StdDeserializer.SqlDateDeserializer());\n+        add(new TimestampDeserializer());\n+\n+        // From-string deserializers:\n+        for (StdDeserializer<?> deser : FromStringDeserializer.all()) {\n+            add(deser);\n+        }\n+\n+        // And finally some odds and ends\n+\n+        // to deserialize Throwable, need stack trace elements:\n+        add(new StdDeserializer.StackTraceElementDeserializer());\n+\n+        // [JACKSON-283] need to support atomic types, too\n+        // (note: AtomicInteger/Long work due to single-arg constructor)\n+        add(new AtomicBooleanDeserializer());\n+\n+        // including some core Jackson types:\n+        add(new TokenBufferDeserializer());\n+        add(new JavaTypeDeserializer());\n+    }\n+\n+    /**\n+     * Public accessor to deserializers for core types.\n+     */\n+    public static HashMap<ClassKey, JsonDeserializer<Object>> constructAll()\n+    {\n+        return new StdDeserializers()._deserializers;\n+    }\n+\n+    private void add(StdDeserializer<?> stdDeser)\n+    {\n+        add(stdDeser, stdDeser.getValueClass());\n+    }\n+\n+    private void add(StdDeserializer<?> stdDeser, Class<?> valueClass)\n+    {\n+        // must do some unfortunate casting here...\n+        @SuppressWarnings(\"unchecked\")\n+        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) stdDeser;\n+        // Not super clean, but default TypeFactory does work here:\n+        _deserializers.put(new ClassKey(valueClass), deser);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/StdKeyDeserializer.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+/**\n+ * @deprecated Since 1.9, use {@link com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer} instead.\n+ */\n+@Deprecated\n+public abstract class StdKeyDeserializer\n+    extends com.fasterxml.jackson.databind.deser.std.StdKeyDeserializer\n+{\n+    protected StdKeyDeserializer(Class<?> cls) { super(cls); }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/StdKeyDeserializers.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+/**\n+ * @deprecated Since 1.9, use {@link com.fasterxml.jackson.databind.deser.std.StdKeyDeserializers} instead.\n+ */\n+@Deprecated\n+class StdKeyDeserializers\n+    extends com.fasterxml.jackson.databind.deser.std.StdKeyDeserializers\n+{\n+    protected StdKeyDeserializers() { super(); }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/StdScalarDeserializer.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+/**\n+ * @deprecated Since 1.9, use {@link com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer} instead.\n+ */\n+@Deprecated\n+public abstract class StdScalarDeserializer<T>\n+    extends com.fasterxml.jackson.databind.deser.std.StdDeserializer<T>\n+{\n+    protected StdScalarDeserializer(Class<?> vc) {\n+        super(vc);\n+    } \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiator.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n+\n+\n+/**\n+ * Class that defines simple API implemented by objects that create value\n+ * instances.  Some or all of properties of value instances may \n+ * be initialized by instantiator, rest being populated by deserializer,\n+ * to which value instance is passed.\n+ * Since different kinds of JSON values (structured and scalar)\n+ * may be bound to Java values, in some cases instantiator\n+ * fully defines resulting value; this is the case when JSON value\n+ * is a scalar value (String, number, boolean).\n+ *<p>\n+ * Note that this type is not parameterized (even though it would seemingly\n+ * make sense), because such type information can not be use effectively\n+ * during runtime: access is always using either wildcard type, or just\n+ * basic {@link java.lang.Object}; and so adding type parameter seems\n+ * like unnecessary extra work.\n+ *<p>\n+ * Actual implementations are strongly recommended to be based on\n+ * {@link com.fasterxml.jackson.databind.deser.std.StdValueInstantiator}\n+ * which implements all methods, and as such will be compatible\n+ * across versions even if new methods were added to this interface.\n+ */\n+public abstract class ValueInstantiator\n+{\n+    /*\n+    /**********************************************************\n+    /* Metadata accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that returns description of the value type this instantiator\n+     * handles. Used for error messages, diagnostics.\n+     */\n+    public abstract String getValueTypeDesc();\n+\n+    /**\n+     * Method that will return true if any of <code>canCreateXxx</code> method\n+     * returns true: that is, if there is any way that an instance could\n+     * be created.\n+     */\n+    public boolean canInstantiate() {\n+        return\n+             canCreateUsingDefault()\n+             || canCreateUsingDelegate()\n+             || canCreateFromObjectWith()\n+             || canCreateFromString()\n+             || canCreateFromInt()\n+             || canCreateFromLong()\n+             || canCreateFromDouble()\n+             || canCreateFromBoolean()\n+             ;\n+    }    \n+    \n+    /**\n+     * Method that can be called to check whether a String-based creator\n+     * is available for this instantiator\n+     */\n+    public boolean canCreateFromString() {\n+        return false;\n+    }\n+\n+    /**\n+     * Method that can be called to check whether an integer (int, Integer) based\n+     * creator is available to use (to call {@link #createFromInt}).\n+     */\n+    public boolean canCreateFromInt() {\n+        return false;\n+    }\n+\n+    /**\n+     * Method that can be called to check whether a long (long, Long) based\n+     * creator is available to use (to call {@link #createFromLong}).\n+     */\n+    public boolean canCreateFromLong() {\n+        return false;\n+    }\n+\n+    /**\n+     * Method that can be called to check whether a double (double / Double) based\n+     * creator is available to use (to call {@link #createFromDouble}).\n+     */\n+    public boolean canCreateFromDouble() {\n+        return false;\n+    }\n+\n+    /**\n+     * Method that can be called to check whether a double (boolean / Boolean) based\n+     * creator is available to use (to call {@link #createFromDouble}).\n+     */\n+    public boolean canCreateFromBoolean() {\n+        return false;\n+    }\n+    \n+    /**\n+     * Method that can be called to check whether a default creator (constructor,\n+     * or no-arg static factory method)\n+     * is available for this instantiator\n+     */\n+    public boolean canCreateUsingDefault() {\n+        return getDefaultCreator() != null;\n+    }\n+\n+    /**\n+     * Method that can be called to check whether a delegate-based creator (single-arg\n+     * constructor or factory method)\n+     * is available for this instantiator\n+     */\n+    public boolean canCreateUsingDelegate() {\n+        return getDelegateType() != null;\n+    }\n+\n+    /**\n+     * Method that can be called to check whether a property-based creator\n+     * (argument-taking constructor or factory method)\n+     * is available to instantiate values from JSON Object\n+     */\n+    public boolean canCreateFromObjectWith() {\n+        return false;\n+    }\n+\n+    /**\n+     * Method called to determine types of instantiation arguments\n+     * to use when creating instances with creator arguments\n+     * (when {@link #canCreateFromObjectWith()} returns  true).\n+     * These arguments are bound from JSON, using specified\n+     * property types to locate deserializers.\n+     *<p>\n+     * NOTE: all properties will be of type\n+     * {@link com.fasterxml.jackson.databind.deser.impl.CreatorProperty}.\n+     */\n+    public SettableBeanProperty[] getFromObjectArguments() {\n+        return null;\n+    }\n+\n+    /**\n+     * Method that can be used to determine what is the type of delegate\n+     * type to use, if any; if no delegates are used, will return null.\n+     * If non-null type is returned, deserializer will bind JSON into\n+     * specified type (using standard deserializer for that type), and\n+     * pass that to instantiator.\n+     */\n+    public JavaType getDelegateType() {\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Instantiation methods for JSON Object\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to create value instance from a JSON value when\n+     * no data needs to passed to creator (constructor, factory method);\n+     * typically this will call the default constructor of the value object.\n+     * It will only be used if more specific creator methods are not\n+     * applicable; hence \"default\".\n+     *<p>\n+     * This method is called if {@link #getFromObjectArguments} returns\n+     * null or empty List.\n+     */\n+    public Object createUsingDefault()\n+        throws IOException, JsonProcessingException {\n+        throw new JsonMappingException(\"Can not instantiate value of type \"\n+                +getValueTypeDesc()+\"; no default creator found\");\n+    }\n+\n+    /**\n+     * Method called to create value instance from JSON Object when\n+     * instantiation arguments are passed; this is done, for example when passing information\n+     * specified with \"Creator\" annotations.\n+     *<p>\n+     * This method is called if {@link #getFromObjectArguments} returns\n+     * a non-empty List of arguments.\n+     */\n+    public Object createFromObjectWith(Object[] args)\n+        throws IOException, JsonProcessingException {\n+        throw new JsonMappingException(\"Can not instantiate value of type \"\n+                +getValueTypeDesc()+\" with arguments\");\n+    }\n+\n+    /**\n+     * Method to called to create value instance from JSON Object using\n+     * an intermediate \"delegate\" value to pass to createor method\n+     */\n+    public Object createUsingDelegate(Object delegate)\n+        throws IOException, JsonProcessingException\n+    {\n+        throw new JsonMappingException(\"Can not instantiate value of type \"\n+                +getValueTypeDesc()+\" using delegate\");\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Instantiation methods for JSON scalar types\n+    /* (String, Number, Boolean)\n+    /**********************************************************\n+     */\n+    \n+    public Object createFromString(String value) throws IOException, JsonProcessingException {\n+        throw new JsonMappingException(\"Can not instantiate value of type \"\n+                +getValueTypeDesc()+\" from JSON String\");\n+    }\n+    \n+    public Object createFromInt(int value) throws IOException, JsonProcessingException {\n+        throw new JsonMappingException(\"Can not instantiate value of type \"\n+                +getValueTypeDesc()+\" from JSON int number\");\n+    }\n+\n+    public Object createFromLong(long value) throws IOException, JsonProcessingException {\n+        throw new JsonMappingException(\"Can not instantiate value of type \"\n+                +getValueTypeDesc()+\" from JSON long number\");\n+    }\n+\n+    public Object createFromDouble(double value) throws IOException, JsonProcessingException {\n+        throw new JsonMappingException(\"Can not instantiate value of type \"\n+                +getValueTypeDesc()+\" from JSON floating-point number\");\n+    }\n+    \n+    public Object createFromBoolean(boolean value) throws IOException, JsonProcessingException {\n+        throw new JsonMappingException(\"Can not instantiate value of type \"\n+                +getValueTypeDesc()+\" from JSON boolean value\");\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Accessors for underlying creator objects (optional)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be called to try to access member (constructor,\n+     * static factory method) that is used as the \"default creator\"\n+     * (creator that is called without arguments; typically default\n+     * [zero-argument] constructor of the type).\n+     * Note that implementations not required to return actual object\n+     * they use (or, they may use some other instantiation) method.\n+     * That is, even if {@link #canCreateUsingDefault()} returns true,\n+     * this method may return null .\n+     */\n+    public AnnotatedWithParams getDefaultCreator() {\n+        return null;\n+    }\n+    \n+    /**\n+     * Method that can be called to try to access member (constructor,\n+     * static factory method) that is used as the \"delegate creator\".\n+     * Note that implementations not required to return actual object\n+     * they use (or, they may use some other instantiation) method.\n+     * That is, even if {@link #canCreateUsingDelegate()} returns true,\n+     * this method may return null .\n+     */\n+    public AnnotatedWithParams getDelegateCreator() {\n+        return null;\n+    }\n+\n+    /**\n+     * Method that can be called to try to access member (constructor,\n+     * static factory method) that is used as the \"non-default creator\"\n+     * (constructor or factory method that takes one or more arguments).\n+     * Note that implementations not required to return actual object\n+     * they use (or, they may use some other instantiation) method.\n+     * That is, even if {@link #canCreateFromObjectWith()} returns true,\n+     * this method may return null .\n+     */\n+    public AnnotatedWithParams getWithArgsCreator() {\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/ValueInstantiators.java\n+package com.fasterxml.jackson.databind.deser;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Interface for providers of {@link ValueInstantiator} instances.\n+ * Implemented when an object wants to provide custom value instantiators,\n+ * usually to support custom value types with alternate constructors, or\n+ * which need specified post-processing after construction but before\n+ * binding data.\n+ * \n+ * @since 1.9\n+ */\n+public interface ValueInstantiators\n+{\n+    /**\n+     * Method called to find the {@link ValueInstantiator} to use for creating\n+     * instances of specified type during deserialization.\n+     * Note that a default value instantiator is always created first and passed;\n+     * if an implementation does not want to modify or replace it, it has to return\n+     * passed instance as is (returning null is an error)\n+     * \n+     * @param config Deserialization configuration in use\n+     * @param beanDesc Additional information about POJO type to be instantiated:\n+     *    description will always be of type\n+     *    {@link com.fasterxml.jackson.databind.introspect.BasicBeanDescription} (that is,\n+     *    safe to cast to this more specific type)\n+     * @param defaultInstantiator Instantiator that will be used if no changes are made;\n+     *   passed to allow custom instances to use annotation-provided information\n+     *   (note, however, that earlier {@link ValueInstantiators} may have changed it to\n+     *   a custom instantiator already)\n+     *   \n+     * @return Instantiator to use; either <code>defaultInstantiator</code> that was passed,\n+     *   or a custom variant; can not be null.\n+     */\n+    public ValueInstantiator findValueInstantiator(DeserializationConfig config,\n+            BeanDescription beanDesc, ValueInstantiator defaultInstantiator);\n+\n+    /**\n+     * Basic \"NOP\" implementation that can be used as the base class for custom implementations.\n+     * Safer to extend (instead of implementing {@link ValueInstantiators}) in case later\n+     * Jackson versions add new methods in base interface.\n+     */\n+    public static class Base implements ValueInstantiators\n+    {\n+        @Override\n+        public ValueInstantiator findValueInstantiator(DeserializationConfig config,\n+                BeanDescription beanDesc, ValueInstantiator defaultInstantiator) {\n+            return defaultInstantiator;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+\n+/**\n+ * Helper class used for storing mapping from property name to\n+ * {@link SettableBeanProperty} instances.\n+ *<p>\n+ * Note that this class is used instead of generic {@link java.util.HashMap}\n+ * is performance: although default implementation is very good for generic\n+ * use cases, it can still be streamlined a bit for specific use case\n+ * we have.\n+ * \n+ * @since 1.7\n+ */\n+public final class BeanPropertyMap\n+{\n+    private final Bucket[] _buckets;\n+    \n+    private final int _hashMask;\n+\n+    private final int _size;\n+    \n+    public BeanPropertyMap(Collection<SettableBeanProperty> properties)\n+    {\n+        _size = properties.size();\n+        int bucketCount = findSize(_size);\n+        _hashMask = bucketCount-1;\n+        Bucket[] buckets = new Bucket[bucketCount];\n+        for (SettableBeanProperty property : properties) {\n+            String key = property.getName();\n+            int index = key.hashCode() & _hashMask;\n+            buckets[index] = new Bucket(buckets[index], key, property);\n+        }\n+        _buckets = buckets;\n+    }\n+\n+    public void assignIndexes()\n+    {\n+        // order is arbitrary, but stable:\n+        int index = 0;\n+        for (Bucket bucket : _buckets) {\n+            while (bucket != null) {\n+                bucket.value.assignIndex(index++);\n+                bucket = bucket.next;\n+            }\n+        }\n+    }\n+    \n+    private final static int findSize(int size)\n+    {\n+        // For small enough results (32 or less), we'll require <= 50% fill rate; otherwise 80%\n+        int needed = (size <= 32) ? (size + size) : (size + (size >> 2));\n+        int result = 2;\n+        while (result < needed) {\n+            result += result;\n+        }\n+        return result;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    public int size() { return _size; }\n+\n+    /**\n+     * Accessor for traversing over all contained properties.\n+     */\n+    public Iterator<SettableBeanProperty> allProperties() {\n+        return new IteratorImpl(_buckets);\n+    }\n+    \n+    public SettableBeanProperty find(String key)\n+    {\n+        int index = key.hashCode() & _hashMask;\n+        Bucket bucket = _buckets[index];\n+        // Let's unroll first lookup since that is null or match in 90+% cases\n+        if (bucket == null) {\n+            return null;\n+        }\n+        // Primarily we do just identity comparison as keys should be interned\n+        if (bucket.key == key) {\n+            return bucket.value;\n+        }\n+        while ((bucket = bucket.next) != null) {\n+            if (bucket.key == key) {\n+                return bucket.value;\n+            }\n+        }\n+        // Do we need fallback for non-interned Strings?\n+        return _findWithEquals(key, index);\n+    }\n+\n+    /**\n+     * Specialized method that can be used to replace an existing entry\n+     * (note: entry MUST exist; otherwise exception is thrown) with\n+     * specified replacement.\n+     */\n+    public void replace(SettableBeanProperty property)\n+    {\n+        String name = property.getName();\n+        int index = name.hashCode() & (_buckets.length-1);\n+\n+        /* This is bit tricky just because buckets themselves\n+         * are immutable, so we need to recreate the chain. Fine.\n+         */\n+        Bucket tail = null;\n+        boolean found = false;\n+\n+        \n+        for (Bucket bucket = _buckets[index]; bucket != null; bucket = bucket.next) {\n+            // match to remove?\n+            if (!found && bucket.key.equals(name)) {\n+                found = true;\n+            } else {\n+                tail = new Bucket(tail, bucket.key, bucket.value);\n+            }\n+        }\n+        // Not finding specified entry is error, so:\n+        if (!found) {\n+            throw new NoSuchElementException(\"No entry '\"+property+\"' found, can't replace\");\n+        }\n+        /* So let's attach replacement in front: useful also because\n+         * it allows replacement even when iterating over entries\n+         */\n+        _buckets[index] = new Bucket(tail, name, property);\n+    }\n+\n+    /**\n+     * Specialized method for removing specified existing entry.\n+     * NOTE: entry MUST exist, otherwise an exception is thrown.\n+     * \n+     * @since 1.9\n+     */\n+    public void remove(SettableBeanProperty property)\n+    {\n+        // Mostly this is the same as code with 'replace', just bit simpler...\n+        String name = property.getName();\n+        int index = name.hashCode() & (_buckets.length-1);\n+        Bucket tail = null;\n+        boolean found = false;\n+        // slightly complex just because chain is immutable, must recreate\n+        for (Bucket bucket = _buckets[index]; bucket != null; bucket = bucket.next) {\n+            // match to remove?\n+            if (!found && bucket.key.equals(name)) {\n+                found = true;\n+            } else {\n+                tail = new Bucket(tail, bucket.key, bucket.value);\n+            }\n+        }\n+        if (!found) { // must be found\n+            throw new NoSuchElementException(\"No entry '\"+property+\"' found, can't remove\");\n+        }\n+        _buckets[index] = tail;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    private SettableBeanProperty _findWithEquals(String key, int index)\n+    {\n+        Bucket bucket = _buckets[index];\n+        while (bucket != null) {\n+            if (key.equals(bucket.key)) {\n+                return bucket.value;\n+            }\n+            bucket = bucket.next;\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper beans\n+    /**********************************************************\n+     */\n+    \n+    private final static class Bucket\n+    {\n+        public final Bucket next;\n+        public final String key;\n+        public final SettableBeanProperty value;\n+        \n+        public Bucket(Bucket next, String key, SettableBeanProperty value)\n+        {\n+            this.next = next;\n+            this.key = key;\n+            this.value = value;\n+        }\n+    }\n+\n+    private final static class IteratorImpl implements Iterator<SettableBeanProperty>\n+    {\n+        /**\n+         * Buckets of the map\n+         */\n+        private final Bucket[] _buckets;\n+\n+        /**\n+         * Bucket that contains next value to return (if any); null if nothing more to iterate\n+         */\n+        private Bucket _currentBucket;\n+\n+        /**\n+         * Index of the next bucket in bucket array to check.\n+         */\n+        private int _nextBucketIndex;\n+        \n+        public IteratorImpl(Bucket[] buckets) {\n+            _buckets = buckets;\n+            // need to initialize to point to first entry...\n+            int i = 0;\n+            for (int len = _buckets.length; i < len; ) {\n+                Bucket b = _buckets[i++];\n+                if (b != null) {\n+                    _currentBucket = b;\n+                    break;\n+                }\n+            }\n+            _nextBucketIndex = i;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            return _currentBucket != null;\n+        }\n+\n+        @Override\n+        public SettableBeanProperty next()\n+        {\n+            Bucket curr = _currentBucket;\n+            if (curr == null) { // sanity check\n+                throw new NoSuchElementException();\n+            }\n+            // need to advance, too\n+            Bucket b = curr.next;\n+            while (b == null && _nextBucketIndex < _buckets.length) {\n+                b = _buckets[_nextBucketIndex++];\n+            }\n+            _currentBucket = b;\n+            return curr.value;\n+        }\n+\n+        @Override\n+        public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.lang.reflect.Member;\n+import java.util.*;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.type.TypeBindings;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+/**\n+ * Container class for storing information on creators (based on annotations,\n+ * visibility), to be able to build actual instantiator later on.\n+ */\n+public class CreatorCollector\n+{\n+    /// Type of bean being created\n+    final BasicBeanDescription _beanDesc;\n+\n+    final boolean _canFixAccess;\n+\n+    protected AnnotatedConstructor _defaultConstructor;\n+    \n+    protected AnnotatedWithParams _stringCreator, _intCreator, _longCreator;\n+    protected AnnotatedWithParams _doubleCreator, _booleanCreator;\n+\n+    protected AnnotatedWithParams _delegateCreator;\n+    \n+    protected AnnotatedWithParams _propertyBasedCreator;\n+    protected CreatorProperty[] _propertyBasedArgs = null;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    public CreatorCollector(BasicBeanDescription beanDesc, boolean canFixAccess)\n+    {\n+        _beanDesc = beanDesc;\n+        _canFixAccess = canFixAccess;\n+    }\n+\n+    /**\n+     * @since 1.9.0\n+     */\n+    public ValueInstantiator constructValueInstantiator(DeserializationConfig config)\n+    {\n+        StdValueInstantiator inst = new StdValueInstantiator(config, _beanDesc.getType());\n+\n+        JavaType delegateType;\n+\n+        if (_delegateCreator == null) {\n+            delegateType = null;\n+        } else {\n+            TypeBindings bindings = _beanDesc.bindingsForBeanType();\n+            delegateType = bindings.resolveType(_delegateCreator.getParameterType(0));\n+        }\n+        \n+        inst.configureFromObjectSettings(_defaultConstructor,\n+                _delegateCreator, delegateType,\n+                _propertyBasedCreator, _propertyBasedArgs);\n+        inst.configureFromStringCreator(_stringCreator);\n+        inst.configureFromIntCreator(_intCreator);\n+        inst.configureFromLongCreator(_longCreator);\n+        inst.configureFromDoubleCreator(_doubleCreator);\n+        inst.configureFromBooleanCreator(_booleanCreator);\n+        return inst;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Setters\n+    /**********************************************************\n+     */\n+\n+    public void setDefaultConstructor(AnnotatedConstructor ctor) {\n+        _defaultConstructor = ctor;\n+    }\n+    \n+    public void addStringCreator(AnnotatedWithParams creator) {\n+        _stringCreator = verifyNonDup(creator, _stringCreator, \"String\");\n+    }\n+    public void addIntCreator(AnnotatedWithParams creator) {\n+        _intCreator = verifyNonDup(creator, _intCreator, \"int\");\n+    }\n+    public void addLongCreator(AnnotatedWithParams creator) {\n+        _longCreator = verifyNonDup(creator, _longCreator, \"long\");\n+    }\n+    public void addDoubleCreator(AnnotatedWithParams creator) {\n+        _doubleCreator = verifyNonDup(creator, _doubleCreator, \"double\");\n+    }\n+    public void addBooleanCreator(AnnotatedWithParams creator) {\n+        _booleanCreator = verifyNonDup(creator, _booleanCreator, \"boolean\");\n+    }\n+\n+    public void addDelegatingCreator(AnnotatedWithParams creator) {\n+        _delegateCreator = verifyNonDup(creator, _delegateCreator, \"delegate\");\n+    }\n+    \n+    public void addPropertyCreator(AnnotatedWithParams creator, CreatorProperty[] properties)\n+    {\n+        _propertyBasedCreator = verifyNonDup(creator, _propertyBasedCreator, \"property-based\");\n+        // [JACKSON-470] Better ensure we have no duplicate names either...\n+        if (properties.length > 1) {\n+            HashMap<String,Integer> names = new HashMap<String,Integer>();\n+            for (int i = 0, len = properties.length; i < len; ++i) {\n+                String name = properties[i].getName();\n+                Integer old = names.put(name, Integer.valueOf(i));\n+                if (old != null) {\n+                    throw new IllegalArgumentException(\"Duplicate creator property \\\"\"+name+\"\\\" (index \"+old+\" vs \"+i+\")\");\n+                }\n+            }\n+        }\n+        _propertyBasedArgs = properties;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected AnnotatedWithParams verifyNonDup(AnnotatedWithParams newOne, AnnotatedWithParams oldOne,\n+            String type)\n+    {\n+        if (oldOne != null) {\n+            // important: ok to override factory with constructor; but not within same type, so:\n+            if (oldOne.getClass() == newOne.getClass()) {\n+                throw new IllegalArgumentException(\"Conflicting \"+type+\" creators: already had \"+oldOne+\", encountered \"+newOne);\n+            }\n+        }\n+        if (_canFixAccess) {\n+            ClassUtil.checkAndFixAccess((Member) newOne.getAnnotated());\n+        }\n+        return newOne;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorProperty.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+import java.lang.annotation.Annotation;\n+\n+import org.codehaus.jackson.JsonParser;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.TypeDeserializer;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedParameter;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * This concrete sub-class implements property that is passed\n+ * via Creator (constructor or static factory method).\n+ * It is not a full-featured implementation in that its set method\n+ * should never be called -- instead, value must separately passed.\n+ *<p>\n+ * Note on injectable values (1.9): unlike with other mutators, where\n+ * deserializer and injecting are separate, here we deal the two as related\n+ * things. This is necessary to add proper priority, as well as to simplify\n+ * coordination.\n+ *<p>\n+ * Note that this class was moved in Jackson 1.9\n+ * from being a static sub-class of \"org.codehaus.jackson.map.deser.SettableBeanProperty\"\n+ * into separate class, to make it easier to use it for custom creators.\n+ */\n+public class CreatorProperty\n+    extends SettableBeanProperty\n+{\n+    /**\n+     * Placeholder that represents constructor parameter, when it is created\n+     * from actual constructor.\n+     * May be null when a synthetic instance is created.\n+     */\n+    protected final AnnotatedParameter _annotated;\n+\n+    /**\n+     * Id of value to inject, if value injection should be used for this parameter\n+     * (in addition to, or instead of, regular deserialization).\n+     * \n+     * @since 1.9\n+     */\n+    protected final Object _injectableValueId;\n+    \n+    /**\n+     * @param name Name of the logical property\n+     * @param type Type of the property, used to find deserializer\n+     * @param typeDeser Type deserializer to use for handling polymorphic type\n+     *    information, if one is needed\n+     * @param contextAnnotations Contextual annotations (usually by class that\n+     *    declares creator [constructor, factory method] that includes\n+     *    this property)\n+     * @param param Representation of property, constructor or factory\n+     *    method parameter; used for accessing annotations of the property\n+     */\n+    public CreatorProperty(String name, JavaType type, TypeDeserializer typeDeser,\n+            Annotations contextAnnotations, AnnotatedParameter param,\n+            int index, Object injectableValueId)\n+    {\n+        super(name, type, typeDeser, contextAnnotations);\n+        _annotated = param;\n+        _propertyIndex = index;\n+        _injectableValueId = injectableValueId;\n+    }\n+\n+    protected CreatorProperty(CreatorProperty src, JsonDeserializer<Object> deser) {\n+        super(src, deser);\n+        _annotated = src._annotated;\n+        _injectableValueId = src._injectableValueId;\n+    }\n+    \n+    @Override\n+    public CreatorProperty withValueDeserializer(JsonDeserializer<Object> deser) {\n+        return new CreatorProperty(this, deser);\n+    }\n+\n+    /**\n+     * Method that can be called to locate value to be injected for this\n+     * property, if it is configured for this.\n+     * \n+     * @since 1.9\n+     */\n+    public Object findInjectableValue(DeserializationContext context, Object beanInstance)\n+    {\n+        if (_injectableValueId == null) {\n+            throw new IllegalStateException(\"Property '\"+getName()\n+                    +\"' (type \"+getClass().getName()+\") has no injectable value id configured\");\n+        }\n+        return context.findInjectableValue(_injectableValueId, this, beanInstance);\n+    }\n+    \n+    /**\n+     * Method to find value to inject, and inject it to this property.\n+     * \n+     * @since 1.9\n+     */\n+    public void inject(DeserializationContext context, Object beanInstance)\n+        throws IOException\n+    {\n+        set(beanInstance, findInjectableValue(context, beanInstance));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* BeanProperty impl\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+        if (_annotated == null) {\n+            return null;\n+        }\n+        return _annotated.getAnnotation(acls);\n+    }\n+\n+    @Override public AnnotatedMember getMember() {  return _annotated; }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void deserializeAndSet(JsonParser jp, DeserializationContext ctxt,\n+                                  Object instance)\n+        throws IOException, JsonProcessingException\n+    {\n+        set(instance, deserialize(jp, ctxt));\n+    }\n+\n+    @Override\n+    public void set(Object instance, Object value)\n+        throws IOException\n+    {\n+        /* Hmmmh. Should we return quietly (NOP), or error?\n+         * For now, let's just bail out without fuss.\n+         */\n+        //throw new IllegalStateException(\"Method should never be called on a \"+getClass().getName());\n+    }\n+\n+    @Override\n+    public Object getInjectableValueId() {\n+        return _injectableValueId;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.TokenBuffer;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+\n+\n+/**\n+ * Helper class that is used to flatten JSON structure when using\n+ * \"external type id\" (see {@link org.codehaus.jackson.annotate.JsonTypeInfo.As#EXTERNAL_PROPERTY}).\n+ * This is needed to store temporary state and buffer tokens, as the structure is\n+ * rearranged a bit so that actual type deserializer can resolve type and \n+ * finalize deserialization.\n+ * \n+ * @since 1.9\n+ */\n+public class ExternalTypeHandler\n+{\n+    private final ExtTypedProperty[] _properties;\n+    private final HashMap<String, Integer> _nameToPropertyIndex;\n+\n+    private final String[] _typeIds;\n+    private final TokenBuffer[] _tokens;\n+    \n+    protected ExternalTypeHandler(ExtTypedProperty[] properties,\n+            HashMap<String, Integer> nameToPropertyIndex,\n+            String[] typeIds, TokenBuffer[] tokens)\n+    {\n+        _properties = properties;        \n+        _nameToPropertyIndex = nameToPropertyIndex;\n+        _typeIds = typeIds;\n+        _tokens = tokens;\n+    }\n+\n+    protected ExternalTypeHandler(ExternalTypeHandler h)\n+    {\n+        _properties = h._properties;\n+        _nameToPropertyIndex = h._nameToPropertyIndex;\n+        int len = _properties.length;\n+        _typeIds = new String[len];\n+        _tokens = new TokenBuffer[len];\n+    }\n+    \n+    public ExternalTypeHandler start() {\n+        return new ExternalTypeHandler(this);\n+    }\n+\n+    /**\n+     * Method called to ask handler to handle \n+     */\n+    public boolean handleToken(JsonParser jp, DeserializationContext ctxt,\n+            String propName, Object bean)\n+        throws IOException, JsonProcessingException\n+    {\n+        Integer I = _nameToPropertyIndex.get(propName);\n+        if (I == null) {\n+            return false;\n+        }\n+        int index = I.intValue();\n+        ExtTypedProperty prop = _properties[index];\n+        boolean canDeserialize;\n+        if (prop.hasTypePropertyName(propName)) {\n+            _typeIds[index] = jp.getText();\n+            jp.skipChildren();\n+            canDeserialize = (bean != null) && (_tokens[index] != null);\n+        } else {\n+            TokenBuffer tokens = new TokenBuffer(jp.getCodec());\n+            tokens.copyCurrentStructure(jp);\n+            _tokens[index] = tokens;\n+            canDeserialize = (bean != null) && (_typeIds[index] != null);\n+        }\n+        /* Minor optimization: let's deserialize properties as soon as\n+         * we have all pertinent information:\n+         */\n+        if (canDeserialize) {\n+            _deserialize(jp, ctxt, bean, index);\n+            // clear stored data, to avoid deserializing+setting twice:\n+            _typeIds[index] = null;\n+            _tokens[index] = null;\n+        }\n+        return true;\n+    }\n+\n+    public Object complete(JsonParser jp, DeserializationContext ctxt, Object bean)\n+        throws IOException, JsonProcessingException\n+    {\n+        for (int i = 0, len = _properties.length; i < len; ++i) {\n+            if (_typeIds[i] == null) {\n+                // let's allow missing both type and property (may already have been set, too)\n+                if (_tokens[i] == null) {\n+                    continue;\n+                }\n+                // but not just one\n+                throw ctxt.mappingException(\"Missing external type id property '\"+_properties[i].getTypePropertyName());\n+            } else if (_tokens[i] == null) {\n+                SettableBeanProperty prop = _properties[i].getProperty();\n+                throw ctxt.mappingException(\"Missing property '\"+prop.getName()+\"' for external type id '\"+_properties[i].getTypePropertyName());\n+            }\n+            _deserialize(jp, ctxt, bean, i);\n+        }\n+        return bean;\n+    }\n+    \n+    protected final void _deserialize(JsonParser jp, DeserializationContext ctxt, Object bean, int index)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* Ok: time to mix type id, value; and we will actually use \"wrapper-array\"\n+         * style to ensure we can handle all kinds of JSON constructs.\n+         */\n+        TokenBuffer merged = new TokenBuffer(jp.getCodec());\n+        merged.writeStartArray();\n+        merged.writeString(_typeIds[index]);\n+        JsonParser p2 = _tokens[index].asParser(jp);\n+        p2.nextToken();\n+        merged.copyCurrentStructure(p2);\n+        merged.writeEndArray();\n+        // needs to point to START_OBJECT (or whatever first token is)\n+        p2 = merged.asParser(jp);\n+        p2.nextToken();\n+        _properties[index].getProperty().deserializeAndSet(p2, ctxt, bean);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+    \n+    public static class Builder\n+    {\n+        private final ArrayList<ExtTypedProperty> _properties = new ArrayList<ExtTypedProperty>();\n+        private final HashMap<String, Integer> _nameToPropertyIndex = new HashMap<String, Integer>();\n+        \n+        public void addExternal(SettableBeanProperty property, String extPropName)\n+        {\n+            Integer index = _properties.size();\n+            _properties.add(new ExtTypedProperty(property, extPropName));\n+            _nameToPropertyIndex.put(property.getName(), index);\n+            _nameToPropertyIndex.put(extPropName, index);\n+        }\n+        \n+        public ExternalTypeHandler build() {\n+            return new ExternalTypeHandler(_properties.toArray(new ExtTypedProperty[_properties.size()]),\n+                    _nameToPropertyIndex, null, null);\n+        }\n+    }\n+\n+    private final static class ExtTypedProperty\n+    {\n+        private final SettableBeanProperty _property;\n+        private final String _typePropertyName;\n+        \n+        public ExtTypedProperty(SettableBeanProperty property, String typePropertyName)\n+        {\n+            _property = property;\n+            _typePropertyName = typePropertyName;\n+        }\n+\n+        public boolean hasTypePropertyName(String n) {\n+            return n.equals(_typePropertyName);\n+        }\n+\n+        public String getTypePropertyName() { return _typePropertyName; }\n+        \n+        public SettableBeanProperty getProperty() {\n+            return _property;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyBasedCreator.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+\n+import org.codehaus.jackson.JsonParser;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+/**\n+ * Object that is used to collect arguments for non-default creator\n+ * (non-default-constructor, or argument-taking factory method)\n+ * before creator can be called.\n+ * Since ordering of JSON properties is not guaranteed, this may\n+ * require buffering of values other than ones being passed to\n+ * creator.\n+ */\n+public final class PropertyBasedCreator\n+{\n+    protected final ValueInstantiator _valueInstantiator;\n+    \n+    /**\n+     * Map that contains property objects for either constructor or factory\n+     * method (whichever one is null: one property for each\n+     * parameter for that one), keyed by logical property name\n+     */\n+    protected final HashMap<String, SettableBeanProperty> _properties;\n+\n+    /**\n+     * If some property values must always have a non-null value (like\n+     * primitive types do), this array contains such default values.\n+     */\n+    protected final Object[]  _defaultValues;\n+\n+    /**\n+     * Array that contains properties that expect value to inject, if any;\n+     * null if no injectable values are expected.\n+     * \n+     * @since 1.9\n+     */\n+    protected final SettableBeanProperty[] _propertiesWithInjectables;\n+    \n+    public PropertyBasedCreator(ValueInstantiator valueInstantiator)\n+    {\n+        _valueInstantiator = valueInstantiator;\n+        _properties = new HashMap<String, SettableBeanProperty>();\n+        // [JACKSON-372]: primitive types need extra care\n+        Object[] defValues = null;\n+        SettableBeanProperty[] creatorProps = valueInstantiator.getFromObjectArguments();\n+        SettableBeanProperty[] propertiesWithInjectables = null;\n+        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n+            SettableBeanProperty prop = creatorProps[i];\n+            _properties.put(prop.getName(), prop);\n+            if (prop.getType().isPrimitive()) {\n+                if (defValues == null) {\n+                    defValues = new Object[len];\n+                }\n+                defValues[i] = ClassUtil.defaultValue(prop.getType().getRawClass());\n+            }\n+            Object injectableValueId = prop.getInjectableValueId();\n+            if (injectableValueId != null) {\n+                if (propertiesWithInjectables == null) {\n+                    propertiesWithInjectables = new SettableBeanProperty[len];\n+                }\n+                propertiesWithInjectables[i] = prop;\n+            }\n+        }\n+        _defaultValues = defValues;\n+        _propertiesWithInjectables = propertiesWithInjectables;        \n+    }\n+\n+    public Collection<SettableBeanProperty> getCreatorProperties() {\n+        return _properties.values();\n+    }\n+    \n+    public SettableBeanProperty findCreatorProperty(String name) {\n+        return _properties.get(name);\n+    }\n+\n+    public void assignDeserializer(SettableBeanProperty prop, JsonDeserializer<Object> deser) {\n+        prop = prop.withValueDeserializer(deser);\n+        _properties.put(prop.getName(), prop);\n+    }\n+    \n+    /**\n+     * Method called when starting to build a bean instance.\n+     */\n+    public PropertyValueBuffer startBuilding(JsonParser jp, DeserializationContext ctxt)\n+    {\n+        PropertyValueBuffer buffer = new PropertyValueBuffer(jp, ctxt, _properties.size());\n+        if (_propertiesWithInjectables != null) {\n+            buffer.inject(_propertiesWithInjectables);\n+        }\n+        return buffer;\n+    }\n+    \n+    public Object build(PropertyValueBuffer buffer) throws IOException\n+    {\n+        Object bean = _valueInstantiator.createFromObjectWith(buffer.getParameters(_defaultValues));\n+        // Anything buffered?\n+        for (PropertyValue pv = buffer.buffered(); pv != null; pv = pv.next) {\n+            pv.assign(bean);\n+        }\n+        return bean;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValue.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+import org.codehaus.jackson.JsonProcessingException;\n+\n+import com.fasterxml.jackson.databind.deser.SettableAnyProperty;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+\n+/**\n+ * Base class for property values that need to be buffered during\n+ * deserialization.\n+ */\n+public abstract class PropertyValue\n+{\n+    public final PropertyValue next;\n+\n+    /**\n+     * Value to assign when POJO has been instantiated.\n+     */\n+    public final Object value;\n+    \n+    protected PropertyValue(PropertyValue next, Object value)\n+    {\n+        this.next = next;\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Method called to assign stored value of this property to specified\n+     * bean instance\n+     */\n+    public abstract void assign(Object bean)\n+        throws IOException, JsonProcessingException;\n+\n+    /*\n+    /**********************************************************\n+    /* Concrete property value classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Property value that used when assigning value to property using\n+     * a setter method or direct field access.\n+     */\n+    final static class Regular\n+        extends PropertyValue\n+    {\n+        final SettableBeanProperty _property;\n+        \n+        public Regular(PropertyValue next, Object value,\n+                       SettableBeanProperty prop)\n+        {\n+            super(next, value);\n+            _property = prop;\n+        }\n+\n+        @Override\n+        public void assign(Object bean)\n+            throws IOException, JsonProcessingException\n+        {\n+            _property.set(bean, value);\n+        }\n+    }\n+    \n+    /**\n+     * Property value type used when storing entries to be added\n+     * to a POJO using \"any setter\" (method that takes name and\n+     * value arguments, allowing setting multiple different\n+     * properties using single method).\n+     */\n+    final static class Any\n+        extends PropertyValue\n+    {\n+        final SettableAnyProperty _property;\n+        final String _propertyName;\n+        \n+        public Any(PropertyValue next, Object value,\n+                   SettableAnyProperty prop,\n+                   String propName)\n+        {\n+            super(next, value);\n+            _property = prop;\n+            _propertyName = propName;\n+        }\n+\n+        @Override\n+        public void assign(Object bean)\n+            throws IOException, JsonProcessingException\n+        {\n+            _property.set(bean, _propertyName, value);\n+        }\n+    }\n+\n+    /**\n+     * Property value type used when storing entries to be added\n+     * to a Map.\n+     */\n+    final static class Map\n+        extends PropertyValue\n+    {\n+        final Object _key;\n+        \n+        public Map(PropertyValue next, Object value, Object key)\n+        {\n+            super(next, value);\n+            _key = key;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\") \n+        @Override\n+        public void assign(Object bean)\n+            throws IOException, JsonProcessingException\n+        {\n+            ((java.util.Map<Object,Object>) bean).put(_key, value);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/PropertyValueBuffer.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import org.codehaus.jackson.JsonParser;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.deser.SettableAnyProperty;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+\n+/**\n+ * Simple container used for temporarily buffering a set of\n+ * <code>PropertyValue</code>s.\n+ * Using during construction of beans (and Maps) that use Creators, \n+ * and hence need buffering before instance (that will have properties\n+ * to assign values to) is constructed.\n+ */\n+public final class PropertyValueBuffer\n+{\n+    final JsonParser _parser;\n+    final DeserializationContext _context;\n+    \n+    /**\n+     * Buffer used for storing creator parameters for constructing\n+     * instance\n+     */\n+    final Object[] _creatorParameters;\n+    \n+    /**\n+     * Number of creator parameters we are still missing.\n+     *<p>\n+     * NOTE: assumes there are no duplicates, for now.\n+     */\n+    private int _paramsNeeded;\n+    \n+    /**\n+     * If we get non-creator parameters before or between\n+     * creator parameters, those need to be buffered. Buffer\n+     * is just a simple linked list\n+     */\n+    private PropertyValue _buffered;\n+    \n+    public PropertyValueBuffer(JsonParser jp, DeserializationContext ctxt, int paramCount)\n+    {\n+        _parser = jp;\n+        _context = ctxt;\n+        _paramsNeeded = paramCount;\n+        _creatorParameters = new Object[paramCount];\n+    }\n+\n+    public void inject(SettableBeanProperty[] injectableProperties)\n+    {\n+        for (int i = 0, len = injectableProperties.length; i < len; ++i) {\n+            SettableBeanProperty prop = injectableProperties[i];\n+            if (prop != null) {\n+                // null since there is no POJO yet\n+                _creatorParameters[i] = _context.findInjectableValue(prop.getInjectableValueId(),\n+                        prop, null);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * @param defaults If any of parameters requires nulls to be replaced with a non-null\n+     *    object (usually primitive types), this is a non-null array that has such replacement\n+     *    values (and nulls for cases where nulls are ok)\n+     */\n+    protected final Object[] getParameters(Object[] defaults)\n+    {\n+        if (defaults != null) {\n+            for (int i = 0, len = _creatorParameters.length; i < len; ++i) {\n+                if (_creatorParameters[i] == null) {\n+                    Object value = defaults[i];\n+                    if (value != null) {\n+                        _creatorParameters[i] = value;\n+                    }\n+                }\n+            }\n+        }\n+        return _creatorParameters;\n+    }\n+\n+    protected PropertyValue buffered() { return _buffered; }\n+    \n+    /**\n+     * @return True if we have received all creator parameters\n+     */\n+    public boolean assignParameter(int index, Object value) {\n+        _creatorParameters[index] = value;\n+        return --_paramsNeeded <= 0;\n+    }\n+    \n+    public void bufferProperty(SettableBeanProperty prop, Object value) {\n+        _buffered = new PropertyValue.Regular(_buffered, value, prop);\n+    }\n+    \n+    public void bufferAnyProperty(SettableAnyProperty prop, String propName, Object value) {\n+        _buffered = new PropertyValue.Any(_buffered, value, prop, propName);\n+    }\n+\n+    public void bufferMapProperty(Object key, Object value) {\n+        _buffered = new PropertyValue.Map(_buffered, value, key);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/UnwrappedPropertyHandler.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.TokenBuffer;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+\n+\n+/**\n+ * Object that is responsible for handling acrobatics related to\n+ * deserializing \"unwrapped\" values; sets of properties that are\n+ * embedded (inlined) as properties of parent JSON object.\n+ *\n+ * @since 1.9\n+ */\n+public class UnwrappedPropertyHandler\n+{\n+    protected final ArrayList<SettableBeanProperty> _properties = new ArrayList<SettableBeanProperty>();\n+    \n+    public UnwrappedPropertyHandler()  { }\n+\n+    public void addProperty(SettableBeanProperty property) {\n+        _properties.add(property);\n+    }\n+\n+    public Object processUnwrapped(JsonParser originalParser, DeserializationContext ctxt, Object bean,\n+            TokenBuffer buffered)\n+        throws IOException, JsonProcessingException\n+    {\n+        for (int i = 0, len = _properties.size(); i < len; ++i) {\n+            SettableBeanProperty prop = _properties.get(i);\n+            JsonParser jp = buffered.asParser();\n+            jp.nextToken();\n+            prop.deserializeAndSet(jp, ctxt, bean);\n+        }\n+        return bean;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ValueInjector.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * Class that encapsulates details of value injection that occurs before\n+ * deserialization of a POJO. Details include information needed to find\n+ * injectable value (logical id) as well as method used for assigning\n+ * value (setter or field)\n+ * \n+ * @since 1.9\n+ */\n+public class ValueInjector\n+    extends BeanProperty.Std\n+{\n+    /**\n+     * Identifier used for looking up value to inject\n+     */\n+    protected final Object _valueId;\n+\n+    public ValueInjector(String propertyName, JavaType type,\n+            Annotations contextAnnotations, AnnotatedMember mutator,\n+            Object valueId)\n+    {\n+        super(propertyName, type, contextAnnotations, mutator);\n+        _valueId = valueId;\n+    }\n+\n+    public Object findValue(DeserializationContext context, Object beanInstance)\n+    {\n+        return context.findInjectableValue(_valueId, this, beanInstance);\n+    }\n+    \n+    public void inject(DeserializationContext context, Object beanInstance)\n+        throws IOException\n+    {\n+        _member.setValue(beanInstance, findValue(context, beanInstance));\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/package-info.java\n+/**\n+ * Contains those implementation classes of deserialization part of \n+ * data binding that are not considered part of public or semi-public\n+ * interfaces. Use of these classes by non-core classes is discouraged,\n+ * although occasionally this may be necessary.\n+ * Note that backwards-compatibility of these classes is not guaranteed\n+ * between minor releases (but is between patch releases).\n+ */\n+package com.fasterxml.jackson.databind.deser.impl;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/package-info.java\n+/**\n+ * Contains implementation classes of deserialization part of \n+ * data binding.\n+ */\n+package com.fasterxml.jackson.databind.deser;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicBooleanDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.codehaus.jackson.JsonParser;\n+import org.codehaus.jackson.JsonProcessingException;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+\n+public class AtomicBooleanDeserializer\n+    extends StdScalarDeserializer<AtomicBoolean>\n+{\n+    public AtomicBooleanDeserializer() { super(AtomicBoolean.class); }\n+    \n+    @Override\n+    public AtomicBoolean deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // 16-Dec-2010, tatu: Should we actually convert null to null AtomicBoolean?\n+        return new AtomicBoolean(_parseBooleanPrimitive(jp, ctxt));\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/AtomicReferenceDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+\n+public class AtomicReferenceDeserializer\n+    extends StdScalarDeserializer<AtomicReference<?>>\n+    implements ResolvableDeserializer\n+{\n+    /**\n+     * Type of value that we reference\n+     */\n+    protected final JavaType _referencedType;\n+    \n+    protected final BeanProperty _property;\n+    \n+    protected JsonDeserializer<?> _valueDeserializer;\n+    \n+    /**\n+     * @param referencedType Parameterization of this reference\n+     */\n+    public AtomicReferenceDeserializer(JavaType referencedType, BeanProperty property)\n+    {\n+        super(AtomicReference.class);\n+        _referencedType = referencedType;\n+        _property = property;\n+    }\n+    \n+    @Override\n+    public AtomicReference<?> deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        return new AtomicReference<Object>(_valueDeserializer.deserialize(jp, ctxt));\n+    }\n+    \n+    @Override\n+    public void resolve(DeserializationConfig config, DeserializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        _valueDeserializer = provider.findValueDeserializer(config, _referencedType, _property);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CalendarDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import org.codehaus.jackson.JsonParser;\n+import org.codehaus.jackson.JsonProcessingException;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+@JacksonStdImpl\n+public class CalendarDeserializer\n+    extends StdScalarDeserializer<Calendar>\n+{\n+    /**\n+     * We may know actual expected type; if so, it will be\n+     * used for instantiation.\n+     */\n+    protected final Class<? extends Calendar> _calendarClass;\n+    \n+    public CalendarDeserializer() { this(null); }\n+    public CalendarDeserializer(Class<? extends Calendar> cc) {\n+        super(Calendar.class);\n+        _calendarClass = cc;\n+    }\n+\n+    @Override\n+    public Calendar deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        Date d = _parseDate(jp, ctxt);\n+        if (d == null) {\n+            return null;\n+        }\n+        if (_calendarClass == null) {\n+            return ctxt.constructCalendar(d);\n+        }\n+        try {\n+            Calendar c = _calendarClass.newInstance();            \n+            c.setTimeInMillis(d.getTime());\n+            return c;\n+        } catch (Exception e) {\n+            throw ctxt.instantiationException(_calendarClass, e);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ClassDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.JsonParser;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.JsonToken;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * \n+ * @since 1.9 (renamed from 'org.codehaus.jackson.map.deser.StdDeserializer#ClassDeserializer')\n+ */\n+@JacksonStdImpl\n+public class ClassDeserializer\n+    extends StdScalarDeserializer<Class<?>>\n+{\n+    public ClassDeserializer() { super(Class.class); }\n+\n+    @Override\n+    public Class<?> deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken curr = jp.getCurrentToken();\n+        // Currently will only accept if given simple class name\n+        if (curr == JsonToken.VALUE_STRING) {\n+            String className = jp.getText();\n+            // [JACKSON-597]: support primitive types (and void)\n+            if (className.indexOf('.') < 0) {\n+                if (\"int\".equals(className)) return Integer.TYPE;\n+                if (\"long\".equals(className)) return Long.TYPE;\n+                if (\"float\".equals(className)) return Float.TYPE;\n+                if (\"double\".equals(className)) return Double.TYPE;\n+                if (\"boolean\".equals(className)) return Boolean.TYPE;\n+                if (\"byte\".equals(className)) return Byte.TYPE;\n+                if (\"char\".equals(className)) return Character.TYPE;\n+                if (\"short\".equals(className)) return Short.TYPE;\n+                if (\"void\".equals(className)) return Void.TYPE;\n+            }\n+            try {\n+                return Class.forName(jp.getText());\n+            } catch (ClassNotFoundException e) {\n+                throw ctxt.instantiationException(_valueClass, e);\n+            }\n+        }\n+        throw ctxt.mappingException(_valueClass, curr);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n+import com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedConstructor;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n+\n+\n+/**\n+ * Basic serializer that can take JSON \"Array\" structure and\n+ * construct a {@link java.util.Collection} instance, with typed contents.\n+ *<p>\n+ * Note: for untyped content (one indicated by passing Object.class\n+ * as the type), {@link UntypedObjectDeserializer} is used instead.\n+ * It can also construct {@link java.util.List}s, but not with specific\n+ * POJO types, only other containers and primitives/wrappers.\n+ * \n+ * @since 1.9 (renamed from 'org.codehaus.jackson.map.deser.CollectionDeserializer)\n+ */\n+@JacksonStdImpl\n+public class CollectionDeserializer\n+    extends ContainerDeserializerBase<Collection<Object>>\n+    implements ResolvableDeserializer\n+{\n+    // // Configuration\n+\n+    protected final JavaType _collectionType;\n+\n+    /**\n+     * Value deserializer.\n+     */\n+    protected final JsonDeserializer<Object> _valueDeserializer;\n+\n+    /**\n+     * If element instances have polymorphic type information, this\n+     * is the type deserializer that can handle it\n+     */\n+    protected final TypeDeserializer _valueTypeDeserializer;\n+\n+    // // Instance construction settings:\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    protected final ValueInstantiator _valueInstantiator;\n+    \n+    /**\n+     * Deserializer that is used iff delegate-based creator is\n+     * to be used for deserializing from JSON Object.\n+     */\n+    protected JsonDeserializer<Object> _delegateDeserializer;\n+\n+    // NOTE: no PropertyBasedCreator, as JSON Arrays have no properties\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @deprecated Since 1.9, use variant that takes ValueInstantiator\n+     */\n+    @Deprecated\n+    protected CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser,\n+            TypeDeserializer valueTypeDeser,\n+            Constructor<Collection<Object>> defCtor)\n+    {\n+        super(collectionType.getRawClass());\n+        _collectionType = collectionType;\n+        _valueDeserializer = valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n+        // not super-clean, but has to do...\n+        StdValueInstantiator inst = new StdValueInstantiator(null, collectionType);\n+        if (defCtor != null) {\n+            AnnotatedConstructor aCtor = new AnnotatedConstructor(defCtor,\n+                    null, null);\n+            inst.configureFromObjectSettings(aCtor, null, null, null, null);\n+        }\n+        _valueInstantiator = inst;\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public CollectionDeserializer(JavaType collectionType, JsonDeserializer<Object> valueDeser,\n+            TypeDeserializer valueTypeDeser, ValueInstantiator valueInstantiator)\n+    {\n+        super(collectionType.getRawClass());\n+        _collectionType = collectionType;\n+        _valueDeserializer = valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n+        _valueInstantiator = valueInstantiator;\n+    }\n+\n+    /**\n+     * Copy-constructor that can be used by sub-classes to allow\n+     * copy-on-write styling copying of settings of an existing instance.\n+     * \n+     * @since 1.9\n+     */\n+    protected CollectionDeserializer(CollectionDeserializer src)\n+    {\n+        super(src._valueClass);\n+        _collectionType = src._collectionType;\n+        _valueDeserializer = src._valueDeserializer;\n+        _valueTypeDeserializer = src._valueTypeDeserializer;\n+        _valueInstantiator = src._valueInstantiator;\n+        _delegateDeserializer = src._delegateDeserializer;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Validation, post-processing (ResolvableDeserializer)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to finalize setup of this deserializer,\n+     * after deserializer itself has been registered. This\n+     * is needed to handle recursive and transitive dependencies.\n+     */\n+    @Override\n+    public void resolve(DeserializationConfig config, DeserializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        // May need to resolve types for delegate-based creators:\n+        if (_valueInstantiator.canCreateUsingDelegate()) {\n+            JavaType delegateType = _valueInstantiator.getDelegateType();\n+            if (delegateType == null) {\n+                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType\n+                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n+                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n+            }\n+            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+            // Need to create a temporary property to allow contextual deserializers:\n+            // Note: unlike BeanDeserializer, we don't have an AnnotatedClass around; hence no annotations passed\n+            BeanProperty.Std property = new BeanProperty.Std(null,\n+                    delegateType, null, delegateCreator);\n+            _delegateDeserializer = findDeserializer(config, provider, delegateType, property);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* ContainerDeserializerBase API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _collectionType.getContentType();\n+    }\n+\n+    @Override\n+    public JsonDeserializer<Object> getContentDeserializer() {\n+        return _valueDeserializer;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer API\n+    /**********************************************************\n+     */\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_delegateDeserializer != null) {\n+            return (Collection<Object>) _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        /* [JACKSON-620]: empty String may be ok; bit tricky to check, however, since\n+         *  there is also possibility of \"auto-wrapping\" of single-element arrays.\n+         *  Hence we only accept empty String here.\n+         */\n+        if (jp.getCurrentToken() == JsonToken.VALUE_STRING) {\n+            String str = jp.getText();\n+            if (str.length() == 0) {\n+                return (Collection<Object>) _valueInstantiator.createFromString(str);\n+            }\n+        }\n+        return deserialize(jp, ctxt, (Collection<Object>) _valueInstantiator.createUsingDefault());\n+    }\n+\n+    @Override\n+    public Collection<Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+            Collection<Object> result)\n+        throws IOException, JsonProcessingException\n+    {\n+        // Ok: must point to START_ARRAY (or equivalent)\n+        if (!jp.isExpectedStartArrayToken()) {\n+            return handleNonArray(jp, ctxt, result);\n+        }\n+\n+        JsonDeserializer<Object> valueDes = _valueDeserializer;\n+        JsonToken t;\n+        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+\n+        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+            Object value;\n+            \n+            if (t == JsonToken.VALUE_NULL) {\n+                value = null;\n+            } else if (typeDeser == null) {\n+                value = valueDes.deserialize(jp, ctxt);\n+            } else {\n+                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+            }\n+            result.add(value);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        // In future could check current token... for now this should be enough:\n+        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n+    }\n+\n+    /**\n+     * Helper method called when current token is no START_ARRAY. Will either\n+     * throw an exception, or try to handle value as if member of implicit\n+     * array, depending on configuration.\n+     */\n+    private final Collection<Object> handleNonArray(JsonParser jp, DeserializationContext ctxt,\n+            Collection<Object> result)\n+        throws IOException, JsonProcessingException\n+    {\n+        // [JACKSON-526]: implicit arrays from single values?\n+        if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+            throw ctxt.mappingException(_collectionType.getRawClass());\n+        }\n+        JsonDeserializer<Object> valueDes = _valueDeserializer;\n+        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+        JsonToken t = jp.getCurrentToken();\n+\n+        Object value;\n+        \n+        if (t == JsonToken.VALUE_NULL) {\n+            value = null;\n+        } else if (typeDeser == null) {\n+            value = valueDes.deserialize(jp, ctxt);\n+        } else {\n+            value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+        }\n+        result.add(value);\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ContainerDeserializerBase.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+\n+/**\n+ * Intermediate base deserializer class that adds more shared accessor\n+ * so that other classes can access information about contained (value)\n+ * types\n+ */\n+public abstract class ContainerDeserializerBase<T>\n+    extends StdDeserializer<T>\n+{\n+    protected ContainerDeserializerBase(Class<?> selfType)\n+    {\n+        super(selfType);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Accessor for declared type of contained value elements; either exact\n+     * type, or one of its supertypes.\n+     */\n+    public abstract JavaType getContentType();\n+\n+    /**\n+     * Accesor for deserializer use for deserializing content values.\n+     */\n+    public abstract JsonDeserializer<Object> getContentDeserializer();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.Date;\n+\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.JsonParser;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+\n+/**\n+ * Simple deserializer for handling {@link java.util.Date} values.\n+ *<p>\n+ * One way to customize Date formats accepted is to override method\n+ * {@link DeserializationContext#parseDate} that this basic\n+ * deserializer calls.\n+ * \n+ * @since 1.9 (moved from higher-level package)\n+ */\n+public class DateDeserializer\n+    extends StdScalarDeserializer<Date>\n+{\n+    public DateDeserializer() { super(Date.class); }\n+    \n+    @Override\n+    public java.util.Date deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _parseDate(jp, ctxt);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+\n+import org.codehaus.jackson.JsonParser;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.JsonToken;\n+\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.annotate.JsonCachable;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.EnumResolver;\n+\n+/**\n+ * Deserializer class that can deserialize instances of\n+ * specified Enum class from Strings and Integers.\n+ * \n+ * @since 1.9 (moved from higher-level package)\n+ */\n+@JsonCachable\n+public class EnumDeserializer\n+    extends StdScalarDeserializer<Enum<?>>\n+{\n+    protected final EnumResolver<?> _resolver;\n+    \n+    public EnumDeserializer(EnumResolver<?> res)\n+    {\n+        super(Enum.class);\n+        _resolver = res;\n+    }\n+\n+    /**\n+     * Factory method used when Enum instances are to be deserialized\n+     * using a creator (static factory method)\n+     * \n+     * @return Deserializer based on given factory method, if type was suitable;\n+     *  null if type can not be used\n+     * \n+     * @since 1.6\n+     */\n+    public static JsonDeserializer<?> deserializerForCreator(DeserializationConfig config,\n+            Class<?> enumClass, AnnotatedMethod factory)\n+    {\n+        // note: caller has verified there's just one arg; but we must verify its type\n+        if (factory.getParameterType(0) != String.class) {\n+            throw new IllegalArgumentException(\"Parameter #0 type for factory method (\"+factory+\") not suitable, must be java.lang.String\");\n+        }\n+        if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+            ClassUtil.checkAndFixAccess(factory.getMember());\n+        }\n+        return new FactoryBasedDeserializer(enumClass, factory);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Default JsonDeserializer implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Enum<?> deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken curr = jp.getCurrentToken();\n+        \n+        // Usually should just get string value:\n+        if (curr == JsonToken.VALUE_STRING) {\n+            String name = jp.getText();\n+            Enum<?> result = _resolver.findEnum(name);\n+            if (result == null) {\n+                throw ctxt.weirdStringException(_resolver.getEnumClass(), \"value not one of declared Enum instance names\");\n+            }\n+            return result;\n+        }\n+        // But let's consider int acceptable as well (if within ordinal range)\n+        if (curr == JsonToken.VALUE_NUMBER_INT) {\n+            /* ... unless told not to do that. :-)\n+             * (as per [JACKSON-412]\n+             */\n+            if (ctxt.isEnabled(DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS)) {\n+                throw ctxt.mappingException(\"Not allowed to deserialize Enum value out of JSON number (disable DeserializationConfig.Feature.FAIL_ON_NUMBERS_FOR_ENUMS to allow)\");\n+            }\n+            \n+            int index = jp.getIntValue();\n+            Enum<?> result = _resolver.getEnum(index);\n+            if (result == null) {\n+                throw ctxt.weirdNumberException(_resolver.getEnumClass(), \"index value outside legal index range [0..\"+_resolver.lastValidIndex()+\"]\");\n+            }\n+            return result;\n+        }\n+        throw ctxt.mappingException(_resolver.getEnumClass());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Default JsonDeserializer implementation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Deserializer that uses a single-String static factory method\n+     * for locating Enum values by String id.\n+     */\n+    protected static class FactoryBasedDeserializer\n+        extends StdScalarDeserializer<Object>\n+    {\n+        protected final Class<?> _enumClass;\n+        protected final Method _factory;\n+        \n+        public FactoryBasedDeserializer(Class<?> cls, AnnotatedMethod f)\n+        {\n+            super(Enum.class);\n+            _enumClass = cls;\n+            _factory = f.getAnnotated();\n+        }\n+\n+        @Override\n+        public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken curr = jp.getCurrentToken();\n+            \n+            // Usually should just get string value:\n+            if (curr != JsonToken.VALUE_STRING) {\n+                throw ctxt.mappingException(_enumClass);\n+            }\n+            String value = jp.getText();\n+            try {\n+                return _factory.invoke(_enumClass, value);\n+            } catch (Exception e) {\n+                ClassUtil.unwrapAndThrowAsIAE(e);\n+            }\n+            return null;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.JsonParser;\n+import org.codehaus.jackson.JsonToken;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.TypeDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.util.EnumResolver;\n+\n+/**\n+ * \n+ * <p>\n+ * Note: casting within this class is all messed up -- just could not figure out a way\n+ * to properly deal with recursive definition of \"EnumMap<K extends Enum<K>, V>\n+ * \n+ * @author tsaloranta\n+ * \n+ * @since 1.9 (renamed from 'org.codehaus.jackson.map.deser.EnumMapDeserializer')\n+ */\n+@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) \n+public class EnumMapDeserializer\n+    extends StdDeserializer<EnumMap<?,?>>\n+{\n+    protected final EnumResolver<?> _enumResolver;\n+\n+    protected final JsonDeserializer<Object> _valueDeserializer;\n+\n+    public EnumMapDeserializer(EnumResolver<?> enumRes, JsonDeserializer<Object> valueDes)\n+    {\n+        super(EnumMap.class);\n+        _enumResolver = enumRes;\n+        _valueDeserializer = valueDes;\n+    }\n+\n+    @Override\n+    public EnumMap<?,?> deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // Ok: must point to START_OBJECT\n+        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n+            throw ctxt.mappingException(EnumMap.class);\n+        }\n+        EnumMap result = constructMap();\n+\n+        while ((jp.nextToken()) != JsonToken.END_OBJECT) {\n+            String fieldName = jp.getCurrentName();\n+            Enum<?> key = _enumResolver.findEnum(fieldName);\n+            if (key == null) {\n+                throw ctxt.weirdStringException(_enumResolver.getEnumClass(), \"value not one of declared Enum instance names\");\n+            }\n+            // And then the value...\n+            JsonToken t = jp.nextToken();\n+            /* note: MUST check for nulls separately: deserializers will\n+             * not handle them (and maybe fail or return bogus data)\n+             */\n+            Object value = (t == JsonToken.VALUE_NULL) ?\n+                null :  _valueDeserializer.deserialize(jp, ctxt);\n+            result.put(key, value);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        // In future could check current token... for now this should be enough:\n+        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+    }\n+    \n+    private EnumMap<?,?> constructMap()\n+    {\n+        Class<? extends Enum<?>> enumCls = _enumResolver.getEnumClass();\n+    \treturn new EnumMap(enumCls);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.JsonParser;\n+import org.codehaus.jackson.JsonToken;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.TypeDeserializer;\n+import com.fasterxml.jackson.databind.util.EnumResolver;\n+\n+/**\n+ * \n+ * <p>\n+ * Note: casting within this class is all messed up -- just could not figure out a way\n+ * to properly deal with recursive definition of \"EnumSet<K extends Enum<K>, V>\n+ * \n+ * @author tsaloranta\n+ * \n+ * @since 1.9 (moved from higher-level package)\n+ */\n+@SuppressWarnings(\"rawtypes\")\n+public class EnumSetDeserializer\n+    extends StdDeserializer<EnumSet<?>>\n+{\n+    protected final Class<Enum> _enumClass;\n+\n+    protected final EnumDeserializer _enumDeserializer;\n+\n+    @SuppressWarnings(\"unchecked\" )\n+    public EnumSetDeserializer(EnumResolver enumRes)\n+    {\n+        super(EnumSet.class);\n+        _enumDeserializer = new EnumDeserializer(enumRes);\n+        // this is fugly, but not sure of a better way...\n+        _enumClass = (Class<Enum>) ((Class<?>) enumRes.getEnumClass());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\") \n+    @Override\n+    public EnumSet<?> deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // Ok: must point to START_ARRAY (or equivalent)\n+        if (!jp.isExpectedStartArrayToken()) {\n+            throw ctxt.mappingException(EnumSet.class);\n+        }\n+        EnumSet result = constructSet();\n+        JsonToken t;\n+\n+        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+            /* What to do with nulls? Fail or ignore? Fail, for now\n+             * (note: would fail if we passed it to EnumDeserializer, too,\n+             * but in general nulls should never be passed to non-container\n+             * deserializers)\n+             */\n+            if (t == JsonToken.VALUE_NULL) {\n+                throw ctxt.mappingException(_enumClass);\n+            }\n+            Enum<?> value = _enumDeserializer.deserialize(jp, ctxt);\n+            result.add(value);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\") \n+    private EnumSet constructSet()\n+    {\n+    \t// superbly ugly... but apparently necessary\n+    \treturn EnumSet.noneOf(_enumClass);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.*;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.JsonParser;\n+import org.codehaus.jackson.JsonToken;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+\n+/**\n+ * Base class for simple deserializer which only accept JSON String\n+ * values as the source.\n+ * \n+ * @since 1.9 (moved from higher-level package)\n+ */\n+public abstract class FromStringDeserializer<T>\n+    extends StdScalarDeserializer<T>\n+{\n+    protected FromStringDeserializer(Class<?> vc) {\n+        super(vc);\n+    }\n+\n+    public static Iterable<FromStringDeserializer<?>>all()\n+    {\n+        ArrayList<FromStringDeserializer<?>> all = new ArrayList<FromStringDeserializer<?>>();\n+\n+        all.add(new UUIDDeserializer());\n+        all.add(new URLDeserializer());\n+        all.add(new URIDeserializer());\n+        all.add(new CurrencyDeserializer());\n+        all.add(new PatternDeserializer());\n+        // since 1.7:\n+        all.add(new LocaleDeserializer());\n+        // 1.8:\n+        all.add(new InetAddressDeserializer());\n+        all.add(new TimeZoneDeserializer());\n+\n+        return all;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public final T deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (jp.getCurrentToken() == JsonToken.VALUE_STRING) {\n+            String text = jp.getText().trim();\n+            // 15-Oct-2010, tatu: Empty String usually means null, so\n+            if (text.length() == 0) {\n+                return null;\n+            }\n+            try {\n+                T result = _deserialize(text, ctxt);\n+                if (result != null) {\n+                    return result;\n+                }\n+            } catch (IllegalArgumentException iae) {\n+                // nothing to do here, yet? We'll fail anyway\n+            }\n+            throw ctxt.weirdStringException(_valueClass, \"not a valid textual representation\");\n+        }\n+        if (jp.getCurrentToken() == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+            // Trivial cases; null to null, instance of type itself returned as is\n+            Object ob = jp.getEmbeddedObject();\n+            if (ob == null) {\n+                return null;\n+            }\n+            if (_valueClass.isAssignableFrom(ob.getClass())) {\n+                return (T) ob;\n+            }\n+            return _deserializeEmbedded(ob, ctxt);\n+        }\n+        throw ctxt.mappingException(_valueClass);\n+    }\n+        \n+    protected abstract T _deserialize(String value, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException;\n+\n+    protected T _deserializeEmbedded(Object ob, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // default impl: error out\n+        throw ctxt.mappingException(\"Don't know how to convert embedded Object of type \"\n+                +ob.getClass().getName()+\" into \"+_valueClass.getName());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Then concrete implementations\n+    /**********************************************************\n+     */\n+\n+    public static class UUIDDeserializer\n+        extends FromStringDeserializer<UUID>\n+    {\n+        public UUIDDeserializer() { super(UUID.class); }\n+\n+        @Override\n+        protected UUID _deserialize(String value, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return UUID.fromString(value);\n+        }\n+\n+        @Override\n+        protected UUID _deserializeEmbedded(Object ob, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            if (ob instanceof byte[]) {\n+                byte[] bytes = (byte[]) ob;\n+                if (bytes.length != 16) {\n+                    ctxt.mappingException(\"Can only construct UUIDs from 16 byte arrays; got \"+bytes.length+\" bytes\");\n+                }\n+                // clumsy, but should work for now...\n+                DataInputStream in = new DataInputStream(new ByteArrayInputStream(bytes));\n+                long l1 = in.readLong();\n+                long l2 = in.readLong();\n+                return new UUID(l1, l2);\n+            }\n+            super._deserializeEmbedded(ob, ctxt);\n+            return null; // never gets here\n+        }\n+    }\n+\n+    public static class URLDeserializer\n+        extends FromStringDeserializer<URL>\n+    {\n+        public URLDeserializer() { super(URL.class); }\n+        \n+        @Override\n+        protected URL _deserialize(String value, DeserializationContext ctxt)\n+            throws IOException\n+        {\n+            return new URL(value);\n+        }\n+    }\n+\n+    public static class URIDeserializer\n+        extends FromStringDeserializer<URI>\n+    {\n+        public URIDeserializer() { super(URI.class); }\n+\n+        @Override\n+        protected URI _deserialize(String value, DeserializationContext ctxt)\n+            throws IllegalArgumentException\n+        {\n+            return URI.create(value);\n+        }\n+    }\n+\n+    public static class CurrencyDeserializer\n+        extends FromStringDeserializer<Currency>\n+    {\n+        public CurrencyDeserializer() { super(Currency.class); }\n+        \n+        @Override\n+        protected Currency _deserialize(String value, DeserializationContext ctxt)\n+            throws IllegalArgumentException\n+        {\n+            // will throw IAE if unknown:\n+            return Currency.getInstance(value);\n+        }\n+    }\n+\n+    public static class PatternDeserializer\n+        extends FromStringDeserializer<Pattern>\n+    {\n+        public PatternDeserializer() { super(Pattern.class); }\n+        \n+        @Override\n+        protected Pattern _deserialize(String value, DeserializationContext ctxt)\n+            throws IllegalArgumentException\n+        {\n+            // will throw IAE (or its subclass) if malformed\n+            return Pattern.compile(value);\n+        }\n+    }\n+\n+    /**\n+     * Kept protected as it's not meant to be extensible at this point\n+     * \n+     * @since 1.7\n+     */\n+    protected static class LocaleDeserializer\n+        extends FromStringDeserializer<Locale>\n+    {\n+        public LocaleDeserializer() { super(Locale.class); }\n+        \n+        @Override\n+        protected Locale _deserialize(String value, DeserializationContext ctxt)\n+            throws IOException\n+        {\n+            int ix = value.indexOf('_');\n+            if (ix < 0) { // single argument\n+                return new Locale(value);\n+            }\n+            String first = value.substring(0, ix);\n+            value = value.substring(ix+1);\n+            ix = value.indexOf('_');\n+            if (ix < 0) { // two pieces\n+                return new Locale(first, value);\n+            }\n+            String second = value.substring(0, ix);\n+            return new Locale(first, second, value.substring(ix+1));\n+        }\n+    }\n+\n+    /**\n+     * As per [JACKSON-484], also need special handling for InetAddress...\n+     * \n+     * @since 1.7.4\n+     */\n+    protected static class InetAddressDeserializer\n+        extends FromStringDeserializer<InetAddress>\n+    {\n+        public InetAddressDeserializer() { super(InetAddress.class); }\n+\n+        @Override\n+        protected InetAddress _deserialize(String value, DeserializationContext ctxt)\n+            throws IOException\n+        {\n+            return InetAddress.getByName(value);\n+        }\n+    }\n+\n+    /**\n+     * As per [JACKSON-522], also need special handling for InetAddress...\n+     * \n+     * @since 1.7.4\n+     */\n+    protected static class TimeZoneDeserializer\n+        extends FromStringDeserializer<TimeZone>\n+    {\n+        public TimeZoneDeserializer() { super(TimeZone.class); }\n+\n+        @Override\n+        protected TimeZone _deserialize(String value, DeserializationContext ctxt)\n+            throws IOException\n+        {\n+            return TimeZone.getTimeZone(value);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JavaTypeDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+\n+/**\n+ * @since 1.9\n+ */\n+public class JavaTypeDeserializer\n+    extends StdScalarDeserializer<JavaType>\n+{\n+    public JavaTypeDeserializer() { super(JavaType.class); }\n+    \n+    @Override\n+    public JavaType deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken curr = jp.getCurrentToken();\n+        // Usually should just get string value:\n+        if (curr == JsonToken.VALUE_STRING) {\n+            String str = jp.getText().trim();\n+            if (str.length() == 0) {\n+                return getEmptyValue();\n+            }\n+            return ctxt.getTypeFactory().constructFromCanonical(str);\n+        }\n+        // or occasionally just embedded object maybe\n+        if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+            return (JavaType) jp.getEmbeddedObject();\n+        }\n+        throw ctxt.mappingException(_valueClass);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+\n+import org.codehaus.jackson.node.*;\n+\n+/**\n+ * Deserializer that can build instances of {@link JsonNode} from any\n+ * JSON content, using appropriate {@link JsonNode} type.\n+ * \n+ * @since 1.9 (moved from higher-level package)\n+ */\n+public class JsonNodeDeserializer\n+    extends BaseNodeDeserializer<JsonNode>\n+{\n+    /**\n+     * Singleton instance of generic deserializer for {@link JsonNode}.\n+     * Only used for types other than JSON Object and Array.\n+     */\n+    private final static JsonNodeDeserializer instance = new JsonNodeDeserializer();\n+\n+    protected JsonNodeDeserializer() { super(JsonNode.class); }\n+\n+    /**\n+     * Factory method for accessing deserializer for specific node type\n+     */\n+    public static JsonDeserializer<? extends JsonNode> getDeserializer(Class<?> nodeClass)\n+    {\n+        if (nodeClass == ObjectNode.class) {\n+            return ObjectDeserializer.getInstance();\n+        }\n+        if (nodeClass == ArrayNode.class) {\n+            return ArrayDeserializer.getInstance();\n+        }\n+        // For others, generic one works fine\n+        return instance;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Actual deserializer implementations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Implementation that will produce types of any JSON nodes; not just one\n+     * deserializer is registered to handle (in case of more specialized handler).\n+     * Overridden by typed sub-classes for more thorough checking\n+     */\n+    @Override\n+    public JsonNode deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        switch (jp.getCurrentToken()) {\n+        case START_OBJECT:\n+            return deserializeObject(jp, ctxt, ctxt.getNodeFactory());\n+        case START_ARRAY:\n+            return deserializeArray(jp, ctxt, ctxt.getNodeFactory());\n+        default:\n+            return deserializeAny(jp, ctxt, ctxt.getNodeFactory());\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Specific instances for more accurate types\n+    /**********************************************************\n+     */\n+\n+    final static class ObjectDeserializer\n+        extends BaseNodeDeserializer<ObjectNode>\n+    {\n+        protected final static ObjectDeserializer _instance = new ObjectDeserializer();\n+\n+        protected ObjectDeserializer() {\n+            super(ObjectNode.class);\n+        }\n+\n+        public static ObjectDeserializer getInstance() { return _instance; }\n+        \n+        @Override\n+        public ObjectNode deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            if (jp.getCurrentToken() == JsonToken.START_OBJECT) {\n+                jp.nextToken();\n+                return deserializeObject(jp, ctxt, ctxt.getNodeFactory());\n+            }\n+            if (jp.getCurrentToken() == JsonToken.FIELD_NAME) {\n+                return deserializeObject(jp, ctxt, ctxt.getNodeFactory());\n+            }\n+            throw ctxt.mappingException(ObjectNode.class);\n+         }\n+    }\n+        \n+    final static class ArrayDeserializer\n+        extends BaseNodeDeserializer<ArrayNode>\n+    {\n+        protected final static ArrayDeserializer _instance = new ArrayDeserializer();\n+\n+        protected ArrayDeserializer() {\n+            super(ArrayNode.class);\n+        }\n+\n+        public static ArrayDeserializer getInstance() { return _instance; }\n+        \n+        @Override\n+        public ArrayNode deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            if (jp.isExpectedStartArrayToken()) {\n+                return deserializeArray(jp, ctxt, ctxt.getNodeFactory());\n+            }\n+            throw ctxt.mappingException(ArrayNode.class);\n+        }\n+    }\n+}\n+\n+/**\n+ * Base class for all actual {@link JsonNode} deserializer\n+ * implementations\n+ */\n+abstract class BaseNodeDeserializer<N extends JsonNode>\n+    extends StdDeserializer<N>\n+{\n+    public BaseNodeDeserializer(Class<N> nodeClass)\n+    {\n+        super(nodeClass);\n+    }\n+    \n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* Output can be as JSON Object, Array or scalar: no way to know\n+         * a priori. So:\n+         */\n+        return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable methods\n+    /**********************************************************\n+     */\n+    \n+    protected void _reportProblem(JsonParser jp, String msg)\n+        throws JsonMappingException\n+    {\n+        throw new JsonMappingException(msg, jp.getTokenLocation());\n+    }\n+    \n+    /**\n+     * Method called when there is a duplicate value for a field.\n+     * By default we don't care, and the last value is used.\n+     * Can be overridden to provide alternate handling, such as throwing\n+     * an exception, or choosing different strategy for combining values\n+     * or choosing which one to keep.\n+     *\n+     * @param fieldName Name of the field for which duplicate value was found\n+     * @param objectNode Object node that contains values\n+     * @param oldValue Value that existed for the object node before newValue\n+     *   was added\n+     * @param newValue Newly added value just added to the object node\n+     */\n+    protected void _handleDuplicateField(String fieldName, ObjectNode objectNode,\n+                                         JsonNode oldValue, JsonNode newValue)\n+        throws JsonProcessingException\n+    {\n+        // By default, we don't do anything\n+        ;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected final ObjectNode deserializeObject(JsonParser jp, DeserializationContext ctxt,\n+            final JsonNodeFactory nodeFactory)            \n+        throws IOException, JsonProcessingException\n+    {\n+        ObjectNode node = nodeFactory.objectNode();\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        }\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String fieldName = jp.getCurrentName();\n+            JsonNode value;\n+            switch (jp.nextToken()) {\n+            case START_OBJECT:\n+                value = deserializeObject(jp, ctxt, nodeFactory);\n+                break;\n+            case START_ARRAY:\n+                value = deserializeArray(jp, ctxt, nodeFactory);\n+                break;\n+            case VALUE_STRING:\n+                value = nodeFactory.textNode(jp.getText());\n+                break;\n+            default:\n+                value = deserializeAny(jp, ctxt, nodeFactory);\n+            }\n+            JsonNode old = node.put(fieldName, value);\n+            if (old != null) {\n+                _handleDuplicateField(fieldName, node, old, value);\n+            }\n+        }\n+        return node;\n+    }\n+    \n+    protected final ArrayNode deserializeArray(JsonParser jp, DeserializationContext ctxt,\n+            final JsonNodeFactory nodeFactory)            \n+        throws IOException, JsonProcessingException\n+    {\n+        ArrayNode node = nodeFactory.arrayNode();\n+        while (true) {\n+            switch (jp.nextToken()) {\n+            case START_OBJECT:\n+                node.add(deserializeObject(jp, ctxt, nodeFactory));\n+                break;\n+            case START_ARRAY:\n+                node.add(deserializeArray(jp, ctxt, nodeFactory));\n+                break;\n+            case END_ARRAY:\n+                return node;\n+            case VALUE_STRING:\n+                node.add(nodeFactory.textNode(jp.getText()));\n+                break;\n+            default:\n+                node.add(deserializeAny(jp, ctxt, nodeFactory));\n+                break;\n+            }\n+        }\n+    }\n+\n+    protected final JsonNode deserializeAny(JsonParser jp, DeserializationContext ctxt,\n+            final JsonNodeFactory nodeFactory)            \n+        throws IOException, JsonProcessingException\n+    {\n+        switch (jp.getCurrentToken()) {\n+        case START_OBJECT:\n+            return deserializeObject(jp, ctxt, nodeFactory);\n+\n+        case START_ARRAY:\n+            return deserializeArray(jp, ctxt, nodeFactory);\n+\n+        case FIELD_NAME:\n+            return deserializeObject(jp, ctxt, nodeFactory);\n+\n+        case VALUE_EMBEDDED_OBJECT:\n+            return nodeFactory.POJONode(jp.getEmbeddedObject());\n+\n+        case VALUE_STRING:\n+            return nodeFactory.textNode(jp.getText());\n+\n+        case VALUE_NUMBER_INT:\n+            {\n+                JsonParser.NumberType nt = jp.getNumberType();\n+                if (nt == JsonParser.NumberType.BIG_INTEGER\n+                    || ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                    return nodeFactory.numberNode(jp.getBigIntegerValue());\n+                }\n+                if (nt == JsonParser.NumberType.INT) {\n+                    return nodeFactory.numberNode(jp.getIntValue());\n+                }\n+                return nodeFactory.numberNode(jp.getLongValue());\n+            }\n+\n+        case VALUE_NUMBER_FLOAT:\n+            {\n+                JsonParser.NumberType nt = jp.getNumberType();\n+                if (nt == JsonParser.NumberType.BIG_DECIMAL\n+                    || ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                    return nodeFactory.numberNode(jp.getDecimalValue());\n+                }\n+                return nodeFactory.numberNode(jp.getDoubleValue());\n+            }\n+\n+        case VALUE_TRUE:\n+            return nodeFactory.booleanNode(true);\n+\n+        case VALUE_FALSE:\n+            return nodeFactory.booleanNode(false);\n+\n+        case VALUE_NULL:\n+            return nodeFactory.nullNode();\n+            \n+            // These states can not be mapped; input stream is\n+            // off by an event or two\n+\n+        //case END_OBJECT:\n+        //case END_ARRAY:\n+        default:\n+            throw ctxt.mappingException(getValueClass());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.deser.impl.PropertyBasedCreator;\n+import com.fasterxml.jackson.databind.deser.impl.PropertyValueBuffer;\n+import com.fasterxml.jackson.databind.deser.std.ContainerDeserializerBase;\n+import com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedConstructor;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n+import com.fasterxml.jackson.databind.util.ArrayBuilders;\n+\n+\n+/**\n+ * Basic serializer that can take Json \"Object\" structure and\n+ * construct a {@link java.util.Map} instance, with typed contents.\n+ *<p>\n+ * Note: for untyped content (one indicated by passing Object.class\n+ * as the type), {@link UntypedObjectDeserializer} is used instead.\n+ * It can also construct {@link java.util.Map}s, but not with specific\n+ * POJO types, only other containers and primitives/wrappers.\n+ */\n+@JacksonStdImpl\n+public class MapDeserializer\n+    extends ContainerDeserializerBase<Map<Object,Object>>\n+    implements ResolvableDeserializer\n+{\n+    // // Configuration: typing, deserializers\n+\n+    protected final JavaType _mapType;\n+\n+    /**\n+     * Key deserializer used, if not null. If null, String from JSON\n+     * content is used as is.\n+     */\n+    protected final KeyDeserializer _keyDeserializer;\n+\n+    /**\n+     * Value deserializer.\n+     */\n+    protected final JsonDeserializer<Object> _valueDeserializer;\n+\n+    /**\n+     * If value instances have polymorphic type information, this\n+     * is the type deserializer that can handle it\n+     */\n+    protected final TypeDeserializer _valueTypeDeserializer;\n+    \n+    // // Instance construction settings:\n+\n+    /**\n+     * @since 1.9\n+     */\n+    protected final ValueInstantiator _valueInstantiator;\n+\n+    /**\n+     * @since 1.9\n+     */\n+    protected final boolean _hasDefaultCreator;\n+    \n+    /**\n+     * If the Map is to be instantiated using non-default constructor\n+     * or factory method\n+     * that takes one or more named properties as argument(s),\n+     * this creator is used for instantiation.\n+     */\n+    protected PropertyBasedCreator _propertyBasedCreator;    \n+    \n+    /**\n+     * Deserializer that is used iff delegate-based creator is\n+     * to be used for deserializing from JSON Object.\n+     */\n+    protected JsonDeserializer<Object> _delegateDeserializer;\n+    \n+    // // Any properties to ignore if seen?\n+    \n+    protected HashSet<String> _ignorableProperties;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @deprecated Since 1.9, use variant that takes ValueInstantiator\n+     */\n+    @Deprecated\n+    protected MapDeserializer(JavaType mapType, Constructor<Map<Object,Object>> defCtor,\n+            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n+            TypeDeserializer valueTypeDeser)\n+    {\n+        super(Map.class);\n+        _mapType = mapType;\n+        _keyDeserializer = keyDeser;\n+        _valueDeserializer = valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n+        // not super-clean, but has to do...\n+        StdValueInstantiator inst = new StdValueInstantiator(null, mapType);\n+        if (defCtor != null) {\n+            AnnotatedConstructor aCtor = new AnnotatedConstructor(defCtor,\n+                    null, null);\n+            inst.configureFromObjectSettings(aCtor, null, null, null, null);\n+        }\n+        _hasDefaultCreator = (defCtor != null);\n+        _valueInstantiator = inst;\n+    }\n+\n+    public MapDeserializer(JavaType mapType, ValueInstantiator valueInstantiator,\n+            KeyDeserializer keyDeser, JsonDeserializer<Object> valueDeser,\n+            TypeDeserializer valueTypeDeser)\n+    {\n+        super(Map.class);\n+        _mapType = mapType;\n+        _keyDeserializer = keyDeser;\n+        _valueDeserializer = valueDeser;\n+        _valueTypeDeserializer = valueTypeDeser;\n+        _valueInstantiator = valueInstantiator;\n+        if (valueInstantiator.canCreateFromObjectWith()) {\n+            _propertyBasedCreator = new PropertyBasedCreator(valueInstantiator);\n+        } else {\n+            _propertyBasedCreator = null;\n+        }\n+        _hasDefaultCreator = valueInstantiator.canCreateUsingDefault();\n+    }\n+\n+    /**\n+     * Copy-constructor that can be used by sub-classes to allow\n+     * copy-on-write styling copying of settings of an existing instance.\n+     * \n+     * @since 1.9\n+     */\n+    protected MapDeserializer(MapDeserializer src)\n+    {\n+        super(src._valueClass);\n+        _mapType = src._mapType;\n+        _keyDeserializer = src._keyDeserializer;\n+        _valueDeserializer = src._valueDeserializer;\n+        _valueTypeDeserializer = src._valueTypeDeserializer;\n+        _valueInstantiator = src._valueInstantiator;\n+        _propertyBasedCreator = src._propertyBasedCreator;\n+        _delegateDeserializer = src._delegateDeserializer;\n+        _hasDefaultCreator = src._hasDefaultCreator;\n+        // should we make a copy here?\n+        _ignorableProperties = src._ignorableProperties;\n+    }\n+\n+    public void setIgnorableProperties(String[] ignorable)\n+    {\n+        _ignorableProperties = (ignorable == null || ignorable.length == 0) ?\n+            null : ArrayBuilders.arrayToSet(ignorable);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Validation, post-processing (ResolvableDeserializer)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to finalize setup of this deserializer,\n+     * after deserializer itself has been registered. This\n+     * is needed to handle recursive and transitive dependencies.\n+     */\n+    @Override\n+    public void resolve(DeserializationConfig config, DeserializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        // May need to resolve types for delegate- and/or property-based creators:\n+        if (_valueInstantiator.canCreateUsingDelegate()) {\n+            JavaType delegateType = _valueInstantiator.getDelegateType();\n+            if (delegateType == null) {\n+                throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_mapType\n+                        +\": value instantiator (\"+_valueInstantiator.getClass().getName()\n+                        +\") returned true for 'canCreateUsingDelegate()', but null for 'getDelegateType()'\");\n+            }\n+            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+            // Need to create a temporary property to allow contextual deserializers:\n+            // Note: unlike BeanDeserializer, we don't have an AnnotatedClass around; hence no annotations passed\n+            BeanProperty.Std property = new BeanProperty.Std(null,\n+                    delegateType, null, delegateCreator);\n+            _delegateDeserializer = findDeserializer(config, provider, delegateType, property);\n+        }\n+        if (_propertyBasedCreator != null) {\n+            for (SettableBeanProperty prop : _propertyBasedCreator.getCreatorProperties()) {\n+                if (!prop.hasValueDeserializer()) {\n+                    _propertyBasedCreator.assignDeserializer(prop, findDeserializer(config, provider, prop.getType(), prop));\n+                }\n+            }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* ContainerDeserializerBase API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _mapType.getContentType();\n+    }\n+\n+    @Override\n+    public JsonDeserializer<Object> getContentDeserializer() {\n+        return _valueDeserializer;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_propertyBasedCreator != null) {\n+            return _deserializeUsingCreator(jp, ctxt);\n+        }\n+        if (_delegateDeserializer != null) {\n+            return (Map<Object,Object>) _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        if (!_hasDefaultCreator) {\n+            throw ctxt.instantiationException(getMapClass(), \"No default constructor found\");\n+        }\n+        // Ok: must point to START_OBJECT, FIELD_NAME or END_OBJECT\n+        JsonToken t = jp.getCurrentToken();\n+        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME && t != JsonToken.END_OBJECT) {\n+            // [JACKSON-620] (empty) String may be ok however:\n+            if (t == JsonToken.VALUE_STRING) {\n+                return (Map<Object,Object>) _valueInstantiator.createFromString(jp.getText());\n+            }\n+            throw ctxt.mappingException(getMapClass());\n+        }\n+        final Map<Object,Object> result = (Map<Object,Object>) _valueInstantiator.createUsingDefault();\n+        _readAndBind(jp, ctxt, result);\n+        return result;\n+    }\n+\n+    @Override\n+    public Map<Object,Object> deserialize(JsonParser jp, DeserializationContext ctxt,\n+            Map<Object,Object> result)\n+        throws IOException, JsonProcessingException\n+    {\n+        // Ok: must point to START_OBJECT or FIELD_NAME\n+        JsonToken t = jp.getCurrentToken();\n+        if (t != JsonToken.START_OBJECT && t != JsonToken.FIELD_NAME) {\n+            throw ctxt.mappingException(getMapClass());\n+        }\n+        _readAndBind(jp, ctxt, result);\n+        return result;\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        // In future could check current token... for now this should be enough:\n+        return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other public accessors\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public final Class<?> getMapClass() { return (Class<Map<Object,Object>>) _mapType.getRawClass(); }\n+\n+    @Override public JavaType getValueType() { return _mapType; }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    protected final void _readAndBind(JsonParser jp, DeserializationContext ctxt,\n+                                      Map<Object,Object> result)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        }\n+        final KeyDeserializer keyDes = _keyDeserializer;\n+        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n+        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            // Must point to field name\n+            String fieldName = jp.getCurrentName();\n+            Object key = (keyDes == null) ? fieldName : keyDes.deserializeKey(fieldName, ctxt);\n+            // And then the value...\n+            t = jp.nextToken();\n+            if (_ignorableProperties != null && _ignorableProperties.contains(fieldName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            // Note: must handle null explicitly here; value deserializers won't\n+            Object value;            \n+            if (t == JsonToken.VALUE_NULL) {\n+                value = null;\n+            } else if (typeDeser == null) {\n+                value = valueDes.deserialize(jp, ctxt);\n+            } else {\n+                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+            }\n+            /* !!! 23-Dec-2008, tatu: should there be an option to verify\n+             *   that there are no duplicate field names? (and/or what\n+             *   to do, keep-first or keep-last)\n+             */\n+            result.put(key, value);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\") \n+    public Map<Object,Object> _deserializeUsingCreator(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        final PropertyBasedCreator creator = _propertyBasedCreator;\n+        PropertyValueBuffer buffer = creator.startBuilding(jp, ctxt);\n+\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        }\n+        final JsonDeserializer<Object> valueDes = _valueDeserializer;\n+        final TypeDeserializer typeDeser = _valueTypeDeserializer;\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            t = jp.nextToken(); // to get to value\n+            if (_ignorableProperties != null && _ignorableProperties.contains(propName)) {\n+                jp.skipChildren(); // and skip it (in case of array/object)\n+                continue;\n+            }\n+            // creator property?\n+            SettableBeanProperty prop = creator.findCreatorProperty(propName);\n+            if (prop != null) {\n+                // Last property to set?\n+                Object value = prop.deserialize(jp, ctxt);\n+                if (buffer.assignParameter(prop.getPropertyIndex(), value)) {\n+                    jp.nextToken();\n+                    Map<Object,Object> result;\n+                    try {\n+                        result = (Map<Object,Object>)creator.build(buffer);\n+                    } catch (Exception e) {\n+                        wrapAndThrow(e, _mapType.getRawClass());\n+                        return null;\n+                    }\n+                    _readAndBind(jp, ctxt, result);\n+                    return result;\n+                }\n+                continue;\n+            }\n+            // other property? needs buffering\n+            String fieldName = jp.getCurrentName();\n+            Object key = (_keyDeserializer == null) ? fieldName : _keyDeserializer.deserializeKey(fieldName, ctxt);\n+            Object value;            \n+            if (t == JsonToken.VALUE_NULL) {\n+                value = null;\n+            } else if (typeDeser == null) {\n+                value = valueDes.deserialize(jp, ctxt);\n+            } else {\n+                value = valueDes.deserializeWithType(jp, ctxt, typeDeser);\n+            }\n+            buffer.bufferMapProperty(key, value);\n+        }\n+        // end of JSON object?\n+        // if so, can just construct and leave...\n+        try {\n+            return (Map<Object,Object>)creator.build(buffer);\n+        } catch (Exception e) {\n+            wrapAndThrow(e, _mapType.getRawClass());\n+            return null;\n+        }\n+    }\n+\n+    // note: copied form BeanDeserializer; should try to share somehow...\n+    protected void wrapAndThrow(Throwable t, Object ref)\n+        throws IOException\n+    {\n+        // to handle StackOverflow:\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors and \"plain\" IOExceptions to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        // ... except for mapping exceptions\n+        if (t instanceof IOException && !(t instanceof JsonMappingException)) {\n+            throw (IOException) t;\n+        }\n+        throw JsonMappingException.wrapWithPath(t, ref, null);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.type.ArrayType;\n+import com.fasterxml.jackson.databind.util.ObjectBuffer;\n+\n+/**\n+ * Basic serializer that can serialize non-primitive arrays.\n+ */\n+@JacksonStdImpl\n+public class ObjectArrayDeserializer\n+    extends ContainerDeserializerBase<Object[]>\n+{\n+    // // Configuration\n+\n+    protected final JavaType _arrayType;\n+    \n+    /**\n+     * Flag that indicates whether the component type is Object or not.\n+     * Used for minor optimization when constructing result.\n+     */\n+    protected final boolean _untyped;\n+\n+    /**\n+     * Type of contained elements: needed for constructing actual\n+     * result array\n+     */\n+    protected final Class<?> _elementClass;\n+\n+    /**\n+     * Element deserializer\n+     */\n+    protected final JsonDeserializer<Object> _elementDeserializer;\n+\n+    /**\n+     * If element instances have polymorphic type information, this\n+     * is the type deserializer that can handle it\n+     */\n+    protected final TypeDeserializer _elementTypeDeserializer;\n+\n+    public ObjectArrayDeserializer(ArrayType arrayType, JsonDeserializer<Object> elemDeser,\n+            TypeDeserializer elemTypeDeser)\n+    {\n+        super(Object[].class);\n+        _arrayType = arrayType;\n+        _elementClass = arrayType.getContentType().getRawClass();\n+        _untyped = (_elementClass == Object.class);\n+        _elementDeserializer = elemDeser;\n+        _elementTypeDeserializer = elemTypeDeser;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* ContainerDeserializerBase API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _arrayType.getContentType();\n+    }\n+\n+    @Override\n+    public JsonDeserializer<Object> getContentDeserializer() {\n+        return _elementDeserializer;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer API\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public Object[] deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // Ok: must point to START_ARRAY (or equivalent)\n+        if (!jp.isExpectedStartArrayToken()) {\n+            return handleNonArray(jp, ctxt);\n+        }\n+\n+        final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n+        Object[] chunk = buffer.resetAndStart();\n+        int ix = 0;\n+        JsonToken t;\n+        final TypeDeserializer typeDeser = _elementTypeDeserializer;\n+\n+        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+            // Note: must handle null explicitly here; value deserializers won't\n+            Object value;\n+            \n+            if (t == JsonToken.VALUE_NULL) {\n+                value = null;\n+            } else if (typeDeser == null) {\n+                value = _elementDeserializer.deserialize(jp, ctxt);\n+            } else {\n+                value = _elementDeserializer.deserializeWithType(jp, ctxt, typeDeser);\n+            }\n+            if (ix >= chunk.length) {\n+                chunk = buffer.appendCompletedChunk(chunk);\n+                ix = 0;\n+            }\n+            chunk[ix++] = value;\n+        }\n+\n+        Object[] result;\n+\n+        if (_untyped) {\n+            result = buffer.completeAndClearBuffer(chunk, ix);\n+        } else {\n+            result = buffer.completeAndClearBuffer(chunk, ix, _elementClass);\n+        }\n+        ctxt.returnObjectBuffer(buffer);\n+        return result;\n+    }\n+\n+    @Override\n+    public Object[] deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* Should there be separate handling for base64 stuff?\n+         * for now this should be enough:\n+         */\n+        return (Object[]) typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    protected Byte[] deserializeFromBase64(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // First same as what PrimitiveArrayDeserializers.ByteDeser does:\n+        byte[] b = jp.getBinaryValue(ctxt.getBase64Variant());\n+        // But then need to convert to wrappers\n+        Byte[] result = new Byte[b.length];\n+        for (int i = 0, len = b.length; i < len; ++i) {\n+            result[i] = Byte.valueOf(b[i]);\n+        }\n+        return result;\n+    }\n+\n+    private final Object[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // [JACKSON-620] Empty String can become null...\n+        if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n+                && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+            String str = jp.getText();\n+            if (str.length() == 0) {\n+                return null;\n+            }\n+        }\n+        \n+        // Can we do implicit coercion to a single-element array still?\n+        if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+            /* 04-Oct-2009, tatu: One exception; byte arrays are generally\n+             *   serialized as base64, so that should be handled\n+             */\n+            if (jp.getCurrentToken() == JsonToken.VALUE_STRING\n+                && _elementClass == Byte.class) {\n+                return deserializeFromBase64(jp, ctxt);\n+            }\n+            throw ctxt.mappingException(_arrayType.getRawClass());\n+        }\n+        JsonToken t = jp.getCurrentToken();\n+        Object value;\n+        \n+        if (t == JsonToken.VALUE_NULL) {\n+            value = null;\n+        } else if (_elementTypeDeserializer == null) {\n+            value = _elementDeserializer.deserialize(jp, ctxt);\n+        } else {\n+            value = _elementDeserializer.deserializeWithType(jp, ctxt, _elementTypeDeserializer);\n+        }\n+        // Ok: bit tricky, since we may want T[], not just Object[]\n+        Object[] result;\n+\n+        if (_untyped) {\n+            result = new Object[1];\n+        } else {\n+            result = (Object[]) Array.newInstance(_elementClass, 1);\n+        }\n+        result[0] = value;\n+        return result;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.type.*;\n+import com.fasterxml.jackson.databind.util.ArrayBuilders;\n+import com.fasterxml.jackson.databind.util.ObjectBuffer;\n+\n+\n+/**\n+ * Container for deserializers used for instantiating \"primitive arrays\",\n+ * arrays that contain non-object java primitive types.\n+ * \n+ * @since 1.9 (renamed from 'org.codehaus.jackson.map.deser.ArrayDeserilizers)\n+ */\n+public class PrimitiveArrayDeserializers\n+{\n+    HashMap<JavaType,JsonDeserializer<Object>> _allDeserializers;\n+\n+    final static PrimitiveArrayDeserializers instance = new PrimitiveArrayDeserializers();\n+\n+    protected PrimitiveArrayDeserializers()\n+    {\n+        _allDeserializers = new HashMap<JavaType,JsonDeserializer<Object>>();\n+        // note: we'll use component type as key, not array type\n+        add(boolean.class, new BooleanDeser());\n+\n+        /* ByteDeser is bit special, as it has 2 separate modes of operation;\n+         * one for String input (-> base64 input), the other for\n+         * numeric input\n+         */\n+        add(byte.class, new ByteDeser());\n+        add(short.class, new ShortDeser());\n+        add(int.class, new IntDeser());\n+        add(long.class, new LongDeser());\n+\n+        add(float.class, new FloatDeser());\n+        add(double.class, new DoubleDeser());\n+\n+        add(String.class, new StringDeser());\n+        /* also: char[] is most likely only used with Strings; doesn't\n+         * seem to make sense to transfer as numbers\n+         */\n+        add(char.class, new CharDeser());\n+    }\n+\n+    public static HashMap<JavaType,JsonDeserializer<Object>> getAll()\n+    {\n+        return instance._allDeserializers;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private void add(Class<?> cls, JsonDeserializer<?> deser)\n+    {\n+        /* Not super clean to use default TypeFactory in general, but\n+         * since primitive array types can't be modified for anything\n+         * useful, this should be ok:\n+         */\n+        _allDeserializers.put(TypeFactory.defaultInstance().constructType(cls),\n+                (JsonDeserializer<Object>) deser);\n+    }\n+\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* Should there be separate handling for base64 stuff?\n+         * for now this should be enough:\n+         */\n+        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n+    }\n+\n+    /*\n+    /********************************************************\n+    /* Intermediate base class\n+    /********************************************************\n+     */\n+    \n+    /**\n+     * Intermediate base class for primitive array deserializers\n+     */\n+    static abstract class Base<T> extends StdDeserializer<T>\n+    {\n+        protected Base(Class<T> cls) {\n+            super(cls);\n+        }\n+\n+        @Override\n+        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+            throws IOException, JsonProcessingException\n+        {\n+            return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n+        }\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Actual deserializers: efficient String[], char[] deserializers\n+    /********************************************************\n+    */\n+\n+    @JacksonStdImpl\n+    final static class StringDeser\n+        extends Base<String[]>\n+    {\n+        public StringDeser() { super(String[].class); }\n+\n+        @Override\n+        public String[] deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            // Ok: must point to START_ARRAY (or equivalent)\n+            if (!jp.isExpectedStartArrayToken()) {\n+                return handleNonArray(jp, ctxt);\n+            }\n+            final ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n+            Object[] chunk = buffer.resetAndStart();\n+            int ix = 0;\n+            JsonToken t;\n+            \n+            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+                // Ok: no need to convert Strings, but must recognize nulls\n+                String value = (t == JsonToken.VALUE_NULL) ? null : jp.getText();\n+                if (ix >= chunk.length) {\n+                    chunk = buffer.appendCompletedChunk(chunk);\n+                    ix = 0;\n+                }\n+                chunk[ix++] = value;\n+            }\n+            String[] result = buffer.completeAndClearBuffer(chunk, ix, String.class);\n+            ctxt.returnObjectBuffer(buffer);\n+            return result;\n+        }\n+    \n+        private final String[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            // [JACKSON-526]: implicit arrays from single values?\n+            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                // [JACKSON-620] Empty String can become null...\n+                if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n+                        && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                    String str = jp.getText();\n+                    if (str.length() == 0) {\n+                        return null;\n+                    }\n+                }\n+                throw ctxt.mappingException(_valueClass);\n+            }\n+            return new String[] { (jp.getCurrentToken() == JsonToken.VALUE_NULL) ? null : jp.getText() };\n+        }\n+    }\n+    \n+    @JacksonStdImpl\n+    final static class CharDeser\n+        extends Base<char[]>\n+    {\n+        public CharDeser() { super(char[].class); }\n+\n+        @Override\n+        public char[] deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            /* Won't take arrays, must get a String (could also\n+             * convert other tokens to Strings... but let's not bother\n+             * yet, doesn't seem to make sense)\n+             */\n+            JsonToken t = jp.getCurrentToken();\n+            if (t == JsonToken.VALUE_STRING) {\n+                // note: can NOT return shared internal buffer, must copy:\n+                char[] buffer = jp.getTextCharacters();\n+                int offset = jp.getTextOffset();\n+                int len = jp.getTextLength();\n+    \n+                char[] result = new char[len];\n+                System.arraycopy(buffer, offset, result, 0, len);\n+                return result;\n+            }\n+            if (jp.isExpectedStartArrayToken()) {\n+                // Let's actually build as a String, then get chars\n+                StringBuilder sb = new StringBuilder(64);\n+                while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+                    if (t != JsonToken.VALUE_STRING) {\n+                        throw ctxt.mappingException(Character.TYPE);\n+                    }\n+                    String str = jp.getText();\n+                    if (str.length() != 1) {\n+                        throw JsonMappingException.from(jp, \"Can not convert a JSON String of length \"+str.length()+\" into a char element of char array\");\n+                    }\n+                    sb.append(str.charAt(0));\n+                }\n+                return sb.toString().toCharArray();\n+            }\n+            // or, maybe an embedded object?\n+            if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+                Object ob = jp.getEmbeddedObject();\n+                if (ob == null) return null;\n+                if (ob instanceof char[]) {\n+                    return (char[]) ob;\n+                }\n+                if (ob instanceof String) {\n+                    return ((String) ob).toCharArray();\n+                }\n+                // 04-Feb-2011, tatu: byte[] can be converted; assuming base64 is wanted\n+                if (ob instanceof byte[]) {\n+                    return Base64Variants.getDefaultVariant().encode((byte[]) ob, false).toCharArray();\n+                }\n+                // not recognized, just fall through\n+            }\n+            throw ctxt.mappingException(_valueClass);\n+        }\n+    }\n+\n+    /*\n+    /********************************************************\n+    /* Actual deserializers: primivate array desers\n+    /********************************************************\n+    */\n+\n+    @JacksonStdImpl\n+    final static class BooleanDeser\n+        extends Base<boolean[]>\n+    {\n+        public BooleanDeser() { super(boolean[].class); }\n+\n+        @Override\n+        public boolean[] deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            if (!jp.isExpectedStartArrayToken()) {\n+                return handleNonArray(jp, ctxt);\n+            }\n+            ArrayBuilders.BooleanBuilder builder = ctxt.getArrayBuilders().getBooleanBuilder();\n+            boolean[] chunk = builder.resetAndStart();\n+            int ix = 0;\n+\n+            while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                // whether we should allow truncating conversions?\n+                boolean value = _parseBooleanPrimitive(jp, ctxt);\n+                if (ix >= chunk.length) {\n+                    chunk = builder.appendCompletedChunk(chunk, ix);\n+                    ix = 0;\n+                }\n+                chunk[ix++] = value;\n+            }\n+            return builder.completeAndClearBuffer(chunk, ix);\n+        }\n+\n+        private final boolean[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            // [JACKSON-620] Empty String can become null...\n+            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n+                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                throw ctxt.mappingException(_valueClass);\n+            }\n+            return new boolean[] { _parseBooleanPrimitive(jp, ctxt) };\n+        }\n+    }\n+\n+    /**\n+     * When dealing with byte arrays we have one more alternative (compared\n+     * to int/long/shorts): base64 encoded data.\n+     */\n+    @JacksonStdImpl\n+    final static class ByteDeser\n+        extends Base<byte[]>\n+    {\n+        public ByteDeser() { super(byte[].class); }\n+\n+        @Override\n+        public byte[] deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken t = jp.getCurrentToken();\n+            \n+            // Most likely case: base64 encoded String?\n+            if (t == JsonToken.VALUE_STRING) {\n+                return jp.getBinaryValue(ctxt.getBase64Variant());\n+            }\n+            // 31-Dec-2009, tatu: Also may be hidden as embedded Object\n+            if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+                Object ob = jp.getEmbeddedObject();\n+                if (ob == null) return null;\n+                if (ob instanceof byte[]) {\n+                    return (byte[]) ob;\n+                }\n+            }\n+            if (!jp.isExpectedStartArrayToken()) {\n+                return handleNonArray(jp, ctxt);\n+            }\n+            ArrayBuilders.ByteBuilder builder = ctxt.getArrayBuilders().getByteBuilder();\n+            byte[] chunk = builder.resetAndStart();\n+            int ix = 0;\n+\n+            while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+                // whether we should allow truncating conversions?\n+                byte value;\n+                if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {\n+                    // should we catch overflow exceptions?\n+                    value = jp.getByteValue();\n+                } else {\n+                    // [JACKSON-79]: should probably accept nulls as 0\n+                    if (t != JsonToken.VALUE_NULL) {\n+                        throw ctxt.mappingException(_valueClass.getComponentType());\n+                    }\n+                    value = (byte) 0;\n+                }\n+                if (ix >= chunk.length) {\n+                    chunk = builder.appendCompletedChunk(chunk, ix);\n+                    ix = 0;\n+                }\n+                chunk[ix++] = value;\n+            }\n+            return builder.completeAndClearBuffer(chunk, ix);\n+        }\n+\n+        private final byte[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            // [JACKSON-620] Empty String can become null...\n+            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n+                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                throw ctxt.mappingException(_valueClass);\n+            }\n+            byte value;\n+            JsonToken t = jp.getCurrentToken();\n+            if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {\n+                // should we catch overflow exceptions?\n+                value = jp.getByteValue();\n+            } else {\n+                // [JACKSON-79]: should probably accept nulls as 'false'\n+                if (t != JsonToken.VALUE_NULL) {\n+                    throw ctxt.mappingException(_valueClass.getComponentType());\n+                }\n+                value = (byte) 0;\n+            }\n+            return new byte[] { value };\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    final static class ShortDeser\n+        extends Base<short[]>\n+    {\n+        public ShortDeser() { super(short[].class); }\n+\n+        @Override\n+        public short[] deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            if (!jp.isExpectedStartArrayToken()) {\n+                return handleNonArray(jp, ctxt);\n+            }\n+            ArrayBuilders.ShortBuilder builder = ctxt.getArrayBuilders().getShortBuilder();\n+            short[] chunk = builder.resetAndStart();\n+            int ix = 0;\n+\n+            while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                short value = _parseShortPrimitive(jp, ctxt);\n+                if (ix >= chunk.length) {\n+                    chunk = builder.appendCompletedChunk(chunk, ix);\n+                    ix = 0;\n+                }\n+                chunk[ix++] = value;\n+            }\n+            return builder.completeAndClearBuffer(chunk, ix);\n+        }\n+\n+        private final short[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            // [JACKSON-620] Empty String can become null...\n+            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n+                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                throw ctxt.mappingException(_valueClass);\n+            }\n+            return new short[] { _parseShortPrimitive(jp, ctxt) };\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    final static class IntDeser\n+        extends Base<int[]>\n+    {\n+        public IntDeser() { super(int[].class); }\n+\n+        @Override\n+        public int[] deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            if (!jp.isExpectedStartArrayToken()) {\n+                return handleNonArray(jp, ctxt);\n+            }\n+            ArrayBuilders.IntBuilder builder = ctxt.getArrayBuilders().getIntBuilder();\n+            int[] chunk = builder.resetAndStart();\n+            int ix = 0;\n+\n+            while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                // whether we should allow truncating conversions?\n+                int value = _parseIntPrimitive(jp, ctxt);\n+                if (ix >= chunk.length) {\n+                    chunk = builder.appendCompletedChunk(chunk, ix);\n+                    ix = 0;\n+                }\n+                chunk[ix++] = value;\n+            }\n+            return builder.completeAndClearBuffer(chunk, ix);\n+        }\n+\n+        private final int[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            // [JACKSON-620] Empty String can become null...\n+            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n+                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                throw ctxt.mappingException(_valueClass);\n+            }\n+            return new int[] { _parseIntPrimitive(jp, ctxt) };\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    final static class LongDeser\n+        extends Base<long[]>\n+    {\n+        public LongDeser() { super(long[].class); }\n+\n+        @Override\n+        public long[] deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            if (!jp.isExpectedStartArrayToken()) {\n+                return handleNonArray(jp, ctxt);\n+            }\n+            ArrayBuilders.LongBuilder builder = ctxt.getArrayBuilders().getLongBuilder();\n+            long[] chunk = builder.resetAndStart();\n+            int ix = 0;\n+\n+            while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                long value = _parseLongPrimitive(jp, ctxt);\n+                if (ix >= chunk.length) {\n+                    chunk = builder.appendCompletedChunk(chunk, ix);\n+                    ix = 0;\n+                }\n+                chunk[ix++] = value;\n+            }\n+            return builder.completeAndClearBuffer(chunk, ix);\n+        }\n+\n+        private final long[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            // [JACKSON-620] Empty String can become null...\n+            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n+                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                throw ctxt.mappingException(_valueClass);\n+            }\n+            return new long[] { _parseLongPrimitive(jp, ctxt) };\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    final static class FloatDeser\n+        extends Base<float[]>\n+    {\n+        public FloatDeser() { super(float[].class); }\n+\n+        @Override\n+        public float[] deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            if (!jp.isExpectedStartArrayToken()) {\n+                return handleNonArray(jp, ctxt);\n+            }\n+            ArrayBuilders.FloatBuilder builder = ctxt.getArrayBuilders().getFloatBuilder();\n+            float[] chunk = builder.resetAndStart();\n+            int ix = 0;\n+\n+            while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                // whether we should allow truncating conversions?\n+                float value = _parseFloatPrimitive(jp, ctxt);\n+                if (ix >= chunk.length) {\n+                    chunk = builder.appendCompletedChunk(chunk, ix);\n+                    ix = 0;\n+                }\n+                chunk[ix++] = value;\n+            }\n+            return builder.completeAndClearBuffer(chunk, ix);\n+        }\n+\n+        private final float[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            // [JACKSON-620] Empty String can become null...\n+            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n+                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                throw ctxt.mappingException(_valueClass);\n+            }\n+            return new float[] { _parseFloatPrimitive(jp, ctxt) };\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    final static class DoubleDeser\n+        extends Base<double[]>\n+    {\n+        public DoubleDeser() { super(double[].class); }\n+\n+        @Override\n+        public double[] deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            if (!jp.isExpectedStartArrayToken()) {\n+                return handleNonArray(jp, ctxt);\n+            }\n+            ArrayBuilders.DoubleBuilder builder = ctxt.getArrayBuilders().getDoubleBuilder();\n+            double[] chunk = builder.resetAndStart();\n+            int ix = 0;\n+\n+            while (jp.nextToken() != JsonToken.END_ARRAY) {\n+                double value = _parseDoublePrimitive(jp, ctxt);\n+                if (ix >= chunk.length) {\n+                    chunk = builder.appendCompletedChunk(chunk, ix);\n+                    ix = 0;\n+                }\n+                chunk[ix++] = value;\n+            }\n+            return builder.completeAndClearBuffer(chunk, ix);\n+        }\n+\n+        private final double[] handleNonArray(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            // [JACKSON-620] Empty String can become null...\n+            if ((jp.getCurrentToken() == JsonToken.VALUE_STRING)\n+                    && ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) {\n+                if (jp.getText().length() == 0) {\n+                    return null;\n+                }\n+            }\n+            if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+                throw ctxt.mappingException(_valueClass);\n+            }\n+            return new double[] { _parseDoublePrimitive(jp, ctxt) };\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.*;\n+\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.JsonParser;\n+import org.codehaus.jackson.JsonToken;\n+import org.codehaus.jackson.io.NumberInput;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * Base class for common deserializers. Contains shared\n+ * base functionality for dealing with primitive values, such\n+ * as (re)parsing from String.\n+ * \n+ * @since 1.9 (moved from higher-level package)\n+ */\n+public abstract class StdDeserializer<T>\n+    extends JsonDeserializer<T>\n+{\n+    /**\n+     * Type of values this deserializer handles: sometimes\n+     * exact types, other time most specific supertype of\n+     * types deserializer handles (which may be as generic\n+     * as {@link Object} in some case)\n+     */\n+    final protected Class<?> _valueClass;\n+\n+    protected StdDeserializer(Class<?> vc) {\n+        _valueClass = vc;\n+    }\n+\n+    protected StdDeserializer(JavaType valueType) {\n+        _valueClass = (valueType == null) ? null : valueType.getRawClass();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    public Class<?> getValueClass() { return _valueClass; }\n+\n+    /**\n+     * Exact structured type deserializer handles, if known.\n+     *<p>\n+     * Default implementation just returns null.\n+     */\n+    public JavaType getValueType() { return null; }\n+\n+    /**\n+     * Method that can be called to determine if given deserializer is the default\n+     * deserializer Jackson uses; as opposed to a custom deserializer installed by\n+     * a module or calling application. Determination is done using\n+     * {@link JacksonStdImpl} annotation on deserializer class.\n+     * \n+     * @since 1.7\n+     */\n+    protected boolean isDefaultSerializer(JsonDeserializer<?> deserializer)\n+    {\n+        return (deserializer != null && deserializer.getClass().getAnnotation(JacksonStdImpl.class) != null);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Partial JsonDeserializer implementation \n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Base implementation that does not assume specific type\n+     * inclusion mechanism. Sub-classes are expected to override\n+     * this method if they are to handle type information.\n+     */\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods for sub-classes, parsing\n+    /**********************************************************\n+     */\n+\n+    protected final boolean _parseBooleanPrimitive(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.VALUE_TRUE) {\n+            return true;\n+        }\n+        if (t == JsonToken.VALUE_FALSE) {\n+            return false;\n+        }\n+        if (t == JsonToken.VALUE_NULL) {\n+            return false;\n+        }\n+        // [JACKSON-78]: should accept ints too, (0 == false, otherwise true)\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return (jp.getIntValue() != 0);\n+        }\n+        // And finally, let's allow Strings to be converted too\n+        if (t == JsonToken.VALUE_STRING) {\n+            String text = jp.getText().trim();\n+            if (\"true\".equals(text)) {\n+                return true;\n+            }\n+            if (\"false\".equals(text) || text.length() == 0) {\n+                return Boolean.FALSE;\n+            }\n+            throw ctxt.weirdStringException(_valueClass, \"only \\\"true\\\" or \\\"false\\\" recognized\");\n+        }\n+        // Otherwise, no can do:\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+\n+    protected final Boolean _parseBoolean(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.VALUE_TRUE) {\n+            return Boolean.TRUE;\n+        }\n+        if (t == JsonToken.VALUE_FALSE) {\n+            return Boolean.FALSE;\n+        }\n+        // [JACKSON-78]: should accept ints too, (0 == false, otherwise true)\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return (jp.getIntValue() == 0) ? Boolean.FALSE : Boolean.TRUE; \n+        }\n+        if (t == JsonToken.VALUE_NULL) {\n+            return (Boolean) getNullValue();\n+        }\n+        // And finally, let's allow Strings to be converted too\n+        if (t == JsonToken.VALUE_STRING) {\n+            String text = jp.getText().trim();\n+            if (\"true\".equals(text)) {\n+                return Boolean.TRUE;\n+            }\n+            if (\"false\".equals(text)) {\n+                return Boolean.FALSE;\n+            }\n+            if (text.length() == 0) {\n+                return (Boolean) getEmptyValue();\n+            }\n+            throw ctxt.weirdStringException(_valueClass, \"only \\\"true\\\" or \\\"false\\\" recognized\");\n+        }\n+        // Otherwise, no can do:\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+\n+    protected Byte _parseByte(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too\n+            return jp.getByteValue();\n+        }\n+        if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse\n+            String text = jp.getText().trim();\n+            int value;\n+            try {\n+                int len = text.length();\n+                if (len == 0) {\n+                    return (Byte) getEmptyValue();\n+                }\n+                value = NumberInput.parseInt(text);\n+            } catch (IllegalArgumentException iae) {\n+                throw ctxt.weirdStringException(_valueClass, \"not a valid Byte value\");\n+            }\n+            // So far so good: but does it fit?\n+            if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\n+                throw ctxt.weirdStringException(_valueClass, \"overflow, value can not be represented as 8-bit value\");\n+            }\n+            return Byte.valueOf((byte) value);\n+        }\n+        if (t == JsonToken.VALUE_NULL) {\n+            return (Byte) getNullValue();\n+        }\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+    \n+    protected Short _parseShort(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too\n+            return jp.getShortValue();\n+        }\n+        if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse\n+            String text = jp.getText().trim();\n+            int value;\n+            try {\n+                int len = text.length();\n+                if (len == 0) {\n+                    return (Short) getEmptyValue();\n+                }\n+                value = NumberInput.parseInt(text);\n+            } catch (IllegalArgumentException iae) {\n+                throw ctxt.weirdStringException(_valueClass, \"not a valid Short value\");\n+            }\n+            // So far so good: but does it fit?\n+            if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n+                throw ctxt.weirdStringException(_valueClass, \"overflow, value can not be represented as 16-bit value\");\n+            }\n+            return Short.valueOf((short) value);\n+        }\n+        if (t == JsonToken.VALUE_NULL) {\n+            return (Short) getNullValue();\n+        }\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+\n+    protected final short _parseShortPrimitive(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        int value = _parseIntPrimitive(jp, ctxt);\n+        // So far so good: but does it fit?\n+        if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n+            throw ctxt.weirdStringException(_valueClass, \"overflow, value can not be represented as 16-bit value\");\n+        }\n+        return (short) value;\n+    }\n+    \n+    protected final int _parseIntPrimitive(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+\n+        // Int works as is, coercing fine as well\n+        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too\n+            return jp.getIntValue();\n+        }\n+        if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse\n+            /* 31-Dec-2009, tatus: Should improve handling of overflow\n+             *   values... but this'll have to do for now\n+             */\n+            String text = jp.getText().trim();\n+            try {\n+                int len = text.length();\n+                if (len > 9) {\n+                    long l = Long.parseLong(text);\n+                    if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) {\n+                        throw ctxt.weirdStringException(_valueClass,\n+                            \"Overflow: numeric value (\"+text+\") out of range of int (\"+Integer.MIN_VALUE+\" - \"+Integer.MAX_VALUE+\")\");\n+                    }\n+                    return (int) l;\n+                }\n+                if (len == 0) {\n+                    return 0;\n+                }\n+                return NumberInput.parseInt(text);\n+            } catch (IllegalArgumentException iae) {\n+                throw ctxt.weirdStringException(_valueClass, \"not a valid int value\");\n+            }\n+        }\n+        if (t == JsonToken.VALUE_NULL) {\n+            return 0;\n+        }\n+        // Otherwise, no can do:\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+\n+    protected final Integer _parseInteger(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too\n+            return Integer.valueOf(jp.getIntValue());\n+        }\n+        if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse\n+            String text = jp.getText().trim();\n+            try {\n+                int len = text.length();\n+                if (len > 9) {\n+                    long l = Long.parseLong(text);\n+                    if (l < Integer.MIN_VALUE || l > Integer.MAX_VALUE) {\n+                        throw ctxt.weirdStringException(_valueClass,\n+                            \"Overflow: numeric value (\"+text+\") out of range of Integer (\"+Integer.MIN_VALUE+\" - \"+Integer.MAX_VALUE+\")\");\n+                    }\n+                    return Integer.valueOf((int) l);\n+                }\n+                if (len == 0) {\n+                    return (Integer) getEmptyValue();\n+                }\n+                return Integer.valueOf(NumberInput.parseInt(text));\n+            } catch (IllegalArgumentException iae) {\n+                throw ctxt.weirdStringException(_valueClass, \"not a valid Integer value\");\n+            }\n+        }\n+        if (t == JsonToken.VALUE_NULL) {\n+            return (Integer) getNullValue();\n+        }\n+        // Otherwise, no can do:\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+\n+    protected final Long _parseLong(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+    \n+        // it should be ok to coerce (although may fail, too)\n+        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {\n+            return jp.getLongValue();\n+        }\n+        // let's allow Strings to be converted too\n+        if (t == JsonToken.VALUE_STRING) {\n+            // !!! 05-Jan-2009, tatu: Should we try to limit value space, JDK is too lenient?\n+            String text = jp.getText().trim();\n+            if (text.length() == 0) {\n+                return (Long) getEmptyValue();\n+            }\n+            try {\n+                return Long.valueOf(NumberInput.parseLong(text));\n+            } catch (IllegalArgumentException iae) { }\n+            throw ctxt.weirdStringException(_valueClass, \"not a valid Long value\");\n+        }\n+        if (t == JsonToken.VALUE_NULL) {\n+            return (Long) getNullValue();\n+        }\n+        // Otherwise, no can do:\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+\n+    protected final long _parseLongPrimitive(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {\n+            return jp.getLongValue();\n+        }\n+        if (t == JsonToken.VALUE_STRING) {\n+            String text = jp.getText().trim();\n+            if (text.length() == 0) {\n+                return 0L;\n+            }\n+            try {\n+                return NumberInput.parseLong(text);\n+            } catch (IllegalArgumentException iae) { }\n+            throw ctxt.weirdStringException(_valueClass, \"not a valid long value\");\n+        }\n+        if (t == JsonToken.VALUE_NULL) {\n+            return 0L;\n+        }\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+    \n+    protected final Float _parseFloat(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // We accept couple of different types; obvious ones first:\n+        JsonToken t = jp.getCurrentToken();\n+        \n+        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too\n+            return jp.getFloatValue();\n+        }\n+        // And finally, let's allow Strings to be converted too\n+        if (t == JsonToken.VALUE_STRING) {\n+            String text = jp.getText().trim();\n+            if (text.length() == 0) {\n+                return (Float) getEmptyValue();\n+            }\n+            switch (text.charAt(0)) {\n+            case 'I':\n+                if (\"Infinity\".equals(text) || \"INF\".equals(text)) {\n+                    return Float.POSITIVE_INFINITY;\n+                }\n+                break;\n+            case 'N':\n+                if (\"NaN\".equals(text)) {\n+                    return Float.NaN;\n+                }\n+                break;\n+            case '-':\n+                if (\"-Infinity\".equals(text) || \"-INF\".equals(text)) {\n+                    return Float.NEGATIVE_INFINITY;\n+                }\n+                break;\n+            }\n+            try {\n+                return Float.parseFloat(text);\n+            } catch (IllegalArgumentException iae) { }\n+            throw ctxt.weirdStringException(_valueClass, \"not a valid Float value\");\n+        }\n+        if (t == JsonToken.VALUE_NULL) {\n+            return (Float) getNullValue();\n+        }\n+        // Otherwise, no can do:\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+\n+    protected final float _parseFloatPrimitive(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        \n+        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too\n+            return jp.getFloatValue();\n+        }\n+        if (t == JsonToken.VALUE_STRING) {\n+            String text = jp.getText().trim();\n+            if (text.length() == 0) {\n+                return 0.0f;\n+            }\n+            switch (text.charAt(0)) {\n+            case 'I':\n+                if (\"Infinity\".equals(text) || \"INF\".equals(text)) {\n+                    return Float.POSITIVE_INFINITY;\n+                }\n+                break;\n+            case 'N':\n+                if (\"NaN\".equals(text)) {\n+                    return Float.NaN;\n+                }\n+                break;\n+            case '-':\n+                if (\"-Infinity\".equals(text) || \"-INF\".equals(text)) {\n+                    return Float.NEGATIVE_INFINITY;\n+                }\n+                break;\n+            }\n+            try {\n+                return Float.parseFloat(text);\n+            } catch (IllegalArgumentException iae) { }\n+            throw ctxt.weirdStringException(_valueClass, \"not a valid float value\");\n+        }\n+        if (t == JsonToken.VALUE_NULL) {\n+            return 0.0f;\n+        }\n+        // Otherwise, no can do:\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+\n+    protected final Double _parseDouble(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        \n+        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too\n+            return jp.getDoubleValue();\n+        }\n+        if (t == JsonToken.VALUE_STRING) {\n+            String text = jp.getText().trim();\n+            if (text.length() == 0) {\n+                return (Double) getEmptyValue();\n+            }\n+            switch (text.charAt(0)) {\n+            case 'I':\n+                if (\"Infinity\".equals(text) || \"INF\".equals(text)) {\n+                    return Double.POSITIVE_INFINITY;\n+                }\n+                break;\n+            case 'N':\n+                if (\"NaN\".equals(text)) {\n+                    return Double.NaN;\n+                }\n+                break;\n+            case '-':\n+                if (\"-Infinity\".equals(text) || \"-INF\".equals(text)) {\n+                    return Double.NEGATIVE_INFINITY;\n+                }\n+                break;\n+            }\n+            try {\n+                return parseDouble(text);\n+            } catch (IllegalArgumentException iae) { }\n+            throw ctxt.weirdStringException(_valueClass, \"not a valid Double value\");\n+        }\n+        if (t == JsonToken.VALUE_NULL) {\n+            return (Double) getNullValue();\n+        }\n+            // Otherwise, no can do:\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+\n+    protected final double _parseDoublePrimitive(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // We accept couple of different types; obvious ones first:\n+        JsonToken t = jp.getCurrentToken();\n+        \n+        if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) { // coercing should work too\n+            return jp.getDoubleValue();\n+        }\n+        // And finally, let's allow Strings to be converted too\n+        if (t == JsonToken.VALUE_STRING) {\n+            String text = jp.getText().trim();\n+            if (text.length() == 0) {\n+                return 0.0;\n+            }\n+            switch (text.charAt(0)) {\n+            case 'I':\n+                if (\"Infinity\".equals(text) || \"INF\".equals(text)) {\n+                    return Double.POSITIVE_INFINITY;\n+                }\n+                break;\n+            case 'N':\n+                if (\"NaN\".equals(text)) {\n+                    return Double.NaN;\n+                }\n+                break;\n+            case '-':\n+                if (\"-Infinity\".equals(text) || \"-INF\".equals(text)) {\n+                    return Double.NEGATIVE_INFINITY;\n+                }\n+                break;\n+            }\n+            try {\n+                return parseDouble(text);\n+            } catch (IllegalArgumentException iae) { }\n+            throw ctxt.weirdStringException(_valueClass, \"not a valid double value\");\n+        }\n+        if (t == JsonToken.VALUE_NULL) {\n+            return 0.0;\n+        }\n+            // Otherwise, no can do:\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+\n+    \n+    protected java.util.Date _parseDate(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.VALUE_NUMBER_INT) {\n+            return new java.util.Date(jp.getLongValue());\n+        }\n+        if (t == JsonToken.VALUE_NULL) {\n+            return (java.util.Date) getNullValue();\n+        }\n+        if (t == JsonToken.VALUE_STRING) {\n+            try {\n+                /* As per [JACKSON-203], take empty Strings to mean\n+                 * null\n+                 */\n+                String str = jp.getText().trim();\n+                if (str.length() == 0) {\n+                    return (Date) getEmptyValue();\n+                }\n+                return ctxt.parseDate(str);\n+            } catch (IllegalArgumentException iae) {\n+                throw ctxt.weirdStringException(_valueClass, \"not a valid representation (error: \"+iae.getMessage()+\")\");\n+            }\n+        }\n+        throw ctxt.mappingException(_valueClass, t);\n+    }\n+\n+    /**\n+     * Helper method for encapsulating calls to low-level double value parsing; single place\n+     * just because we need a work-around that must be applied to all calls.\n+     *<p>\n+     * Note: copied from <code>org.codehaus.jackson.io.NumberUtil</code> (to avoid dependency to\n+     * version 1.8; except for String constants, but that gets compiled in bytecode here)\n+     */\n+    protected final static double parseDouble(String numStr) throws NumberFormatException\n+    {\n+        // [JACKSON-486]: avoid some nasty float representations... but should it be MIN_NORMAL or MIN_VALUE?\n+        if (NumberInput.NASTY_SMALL_DOUBLE.equals(numStr)) {\n+            return Double.MIN_NORMAL;\n+        }\n+        return Double.parseDouble(numStr);\n+    }\n+    \n+    /*\n+    /****************************************************\n+    /* Helper methods for sub-classes, resolving dependencies\n+    /****************************************************\n+    */\n+\n+    /**\n+     * Helper method used to locate deserializers for properties the\n+     * type this deserializer handles contains (usually for properties of\n+     * bean types)\n+     * \n+     * @param config Active deserialization configuration \n+     * @param provider Deserializer provider to use for actually finding deserializer(s)\n+     * @param type Type of property to deserialize\n+     * @param property Actual property object (field, method, constuctor parameter) used\n+     *     for passing deserialized values; provided so deserializer can be contextualized if necessary (since 1.7)\n+     */\n+    protected JsonDeserializer<Object> findDeserializer(DeserializationConfig config, DeserializerProvider provider,\n+                                                        JavaType type, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser = provider.findValueDeserializer(config, type, property);\n+        return deser;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for sub-classes, problem reporting\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to deal with a property that did not map to a known\n+     * Bean property. Method can deal with the problem as it sees fit (ignore,\n+     * throw exception); but if it does return, it has to skip the matching\n+     * Json content parser has.\n+     *<p>\n+     * NOTE: method signature was changed in version 1.5; explicit JsonParser\n+     * <b>must</b> be passed since it may be something other than what\n+     * context has. Prior versions did not include the first parameter.\n+     *\n+     * @param jp Parser that points to value of the unknown property\n+     * @param ctxt Context for deserialization; allows access to the parser,\n+     *    error reporting functionality\n+     * @param instanceOrClass Instance that is being populated by this\n+     *   deserializer, or if not known, Class that would be instantiated.\n+     *   If null, will assume type is what {@link #getValueClass} returns.\n+     * @param propName Name of the property that can not be mapped\n+     */\n+    protected void handleUnknownProperty(JsonParser jp, DeserializationContext ctxt, Object instanceOrClass, String propName)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (instanceOrClass == null) {\n+            instanceOrClass = getValueClass();\n+        }\n+        // Maybe we have configured handler(s) to take care of it?\n+        if (ctxt.handleUnknownProperty(jp, this, instanceOrClass, propName)) {\n+            return;\n+        }\n+        // Nope, not handled. Potentially that's a problem...\n+        reportUnknownProperty(ctxt, instanceOrClass, propName);\n+\n+        /* If we get this far, need to skip now; we point to first token of\n+         * value (START_xxx for structured, or the value token for others)\n+         */\n+        jp.skipChildren();\n+    }\n+        \n+    protected void reportUnknownProperty(DeserializationContext ctxt,\n+                                         Object instanceOrClass, String fieldName)\n+        throws IOException, JsonProcessingException\n+    {\n+        // throw exception if that's what we are expected to do\n+        if (ctxt.isEnabled(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n+            throw ctxt.unknownFieldException(instanceOrClass, fieldName);\n+        }\n+        // ... or if not, just ignore\n+    }\n+\n+\n+    /*\n+    /**********************************************************\n+    /* Then one intermediate base class for things that have\n+    /* both primitive and wrapper types\n+    /**********************************************************\n+     */\n+\n+    protected abstract static class PrimitiveOrWrapperDeserializer<T>\n+        extends StdScalarDeserializer<T>\n+    {\n+        final T _nullValue;\n+        \n+        protected PrimitiveOrWrapperDeserializer(Class<T> vc, T nvl)\n+        {\n+            super(vc);\n+            _nullValue = nvl;\n+        }\n+        \n+        @Override\n+        public final T getNullValue() {\n+            return _nullValue;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Then primitive/wrapper types\n+    /**********************************************************\n+     */\n+\n+    @JacksonStdImpl\n+    public final static class BooleanDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Boolean>\n+    {\n+        public BooleanDeserializer(Class<Boolean> cls, Boolean nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+        \n+        @Override\n+\tpublic Boolean deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseBoolean(jp, ctxt);\n+        }\n+\n+        // 1.6: since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n+        // (is it an error to even call this version?)\n+        @Override\n+        public Boolean deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+                TypeDeserializer typeDeserializer)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseBoolean(jp, ctxt);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class ByteDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Byte>\n+    {\n+        public ByteDeserializer(Class<Byte> cls, Byte nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Byte deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseByte(jp, ctxt);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class ShortDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Short>\n+    {\n+        public ShortDeserializer(Class<Short> cls, Short nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Short deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseShort(jp, ctxt);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class CharacterDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Character>\n+    {\n+        public CharacterDeserializer(Class<Character> cls, Character nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Character deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken t = jp.getCurrentToken();\n+            int value;\n+\n+            if (t == JsonToken.VALUE_NUMBER_INT) { // ok iff ascii value\n+                value = jp.getIntValue();\n+                if (value >= 0 && value <= 0xFFFF) {\n+                    return Character.valueOf((char) value);\n+                }\n+            } else if (t == JsonToken.VALUE_STRING) { // this is the usual type\n+                // But does it have to be exactly one char?\n+                String text = jp.getText();\n+                if (text.length() == 1) {\n+                    return Character.valueOf(text.charAt(0));\n+                }\n+                // actually, empty should become null?\n+                if (text.length() == 0) {\n+                    return (Character) getEmptyValue();\n+                }\n+            }\n+            throw ctxt.mappingException(_valueClass, t);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class IntegerDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Integer>\n+    {\n+        public IntegerDeserializer(Class<Integer> cls, Integer nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Integer deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseInteger(jp, ctxt);\n+        }\n+\n+        // 1.6: since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n+        // (is it an error to even call this version?)\n+        @Override\n+        public Integer deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+                TypeDeserializer typeDeserializer)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseInteger(jp, ctxt);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class LongDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Long>\n+    {\n+        public LongDeserializer(Class<Long> cls, Long nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Long deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseLong(jp, ctxt);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class FloatDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Float>\n+    {\n+        public FloatDeserializer(Class<Float> cls, Float nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Float deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            /* 22-Jan-2009, tatu: Bounds/range checks would be tricky\n+             *   here, so let's not bother even trying...\n+             */\n+            return _parseFloat(jp, ctxt);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class DoubleDeserializer\n+        extends PrimitiveOrWrapperDeserializer<Double>\n+    {\n+        public DoubleDeserializer(Class<Double> cls, Double nvl)\n+        {\n+            super(cls, nvl);\n+        }\n+\n+        @Override\n+        public Double deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseDouble(jp, ctxt);\n+        }\n+\n+        // 1.6: since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n+        // (is it an error to even call this version?)\n+        @Override\n+        public Double deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+                TypeDeserializer typeDeserializer)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _parseDouble(jp, ctxt);\n+        }\n+    }\n+\n+    /**\n+     * For type <code>Number.class</code>, we can just rely on type\n+     * mappings that plain {@link JsonParser#getNumberValue} returns.\n+     *<p>\n+     * Since 1.5, there is one additional complication: some numeric\n+     * types (specifically, int/Integer and double/Double) are \"non-typed\";\n+     * meaning that they will NEVER be output with type information.\n+     * But other numeric types may need such type information.\n+     * This is why {@link #deserializeWithType} must be overridden.\n+     */\n+    @JacksonStdImpl\n+    public final static class NumberDeserializer\n+        extends StdScalarDeserializer<Number>\n+    {\n+        public NumberDeserializer() { super(Number.class); }\n+\n+        @Override\n+        public Number deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken t = jp.getCurrentToken();\n+            if (t == JsonToken.VALUE_NUMBER_INT) {\n+                if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                    return jp.getBigIntegerValue();\n+                }\n+                return jp.getNumberValue();\n+            } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+                /* [JACKSON-72]: need to allow overriding the behavior\n+                 * regarding which type to use\n+                 */\n+                if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                    return jp.getDecimalValue();\n+                }\n+                return Double.valueOf(jp.getDoubleValue());\n+            }\n+\n+            /* Textual values are more difficult... not parsing itself, but figuring\n+             * out 'minimal' type to use \n+             */\n+            if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse\n+                String text = jp.getText().trim();\n+                try {\n+                    if (text.indexOf('.') >= 0) { // floating point\n+                        // as per [JACKSON-72]:\n+                        if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                            return new BigDecimal(text);\n+                        }\n+                        return new Double(text);\n+                    }\n+                    // as per [JACKSON-100]:\n+                    if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                        return new BigInteger(text);\n+                    }\n+                    long value = Long.parseLong(text);\n+                    if (value <= Integer.MAX_VALUE && value >= Integer.MIN_VALUE) {\n+                        return Integer.valueOf((int) value);\n+                    }\n+                    return Long.valueOf(value);\n+                } catch (IllegalArgumentException iae) {\n+                    throw ctxt.weirdStringException(_valueClass, \"not a valid number\");\n+                }\n+            }\n+            // Otherwise, no can do:\n+            throw ctxt.mappingException(_valueClass, t);\n+        }\n+\n+        /**\n+         * As mentioned in class Javadoc, there is additional complexity in\n+         * handling potentially mixed type information here. Because of this,\n+         * we must actually check for \"raw\" integers and doubles first, before\n+         * calling type deserializer.\n+         */\n+        @Override\n+        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+                                          TypeDeserializer typeDeserializer)\n+            throws IOException, JsonProcessingException\n+        {\n+            switch (jp.getCurrentToken()) {\n+            case VALUE_NUMBER_INT:\n+            case VALUE_NUMBER_FLOAT:\n+            case VALUE_STRING:\n+                // can not point to type information: hence must be non-typed (int/double)\n+                return deserialize(jp, ctxt);\n+            }\n+            return typeDeserializer.deserializeTypedFromScalar(jp, ctxt);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* And then bit more complicated (but non-structured) number\n+    /* types\n+    /**********************************************************\n+     */\n+\n+    @JacksonStdImpl\n+    public static class BigDecimalDeserializer\n+        extends StdScalarDeserializer<BigDecimal>\n+    {\n+        public BigDecimalDeserializer() { super(BigDecimal.class); }\n+\n+        @Override\n+\tpublic BigDecimal deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken t = jp.getCurrentToken();\n+            if (t == JsonToken.VALUE_NUMBER_INT || t == JsonToken.VALUE_NUMBER_FLOAT) {\n+                return jp.getDecimalValue();\n+            }\n+            // String is ok too, can easily convert\n+            if (t == JsonToken.VALUE_STRING) { // let's do implicit re-parse\n+                String text = jp.getText().trim();\n+                if (text.length() == 0) {\n+                    return null;\n+                }\n+                try {\n+                    return new BigDecimal(text);\n+                } catch (IllegalArgumentException iae) {\n+                    throw ctxt.weirdStringException(_valueClass, \"not a valid representation\");\n+                }\n+            }\n+            // Otherwise, no can do:\n+            throw ctxt.mappingException(_valueClass, t);\n+        }\n+    }\n+\n+    /**\n+     * This is bit trickier to implement efficiently, while avoiding\n+     * overflow problems.\n+     */\n+    @JacksonStdImpl\n+    public static class BigIntegerDeserializer\n+        extends StdScalarDeserializer<BigInteger>\n+    {\n+        public BigIntegerDeserializer() { super(BigInteger.class); }\n+\n+        @Override\n+\t\tpublic BigInteger deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken t = jp.getCurrentToken();\n+            String text;\n+\n+            if (t == JsonToken.VALUE_NUMBER_INT) {\n+                switch (jp.getNumberType()) {\n+                case INT:\n+                case LONG:\n+                    return BigInteger.valueOf(jp.getLongValue());\n+                }\n+            } else if (t == JsonToken.VALUE_NUMBER_FLOAT) {\n+                /* Whether to fail if there's non-integer part?\n+                 * Could do by calling BigDecimal.toBigIntegerExact()\n+                 */\n+                return jp.getDecimalValue().toBigInteger();\n+            } else if (t != JsonToken.VALUE_STRING) { // let's do implicit re-parse\n+                // String is ok too, can easily convert; otherwise, no can do:\n+                throw ctxt.mappingException(_valueClass, t);\n+            }\n+            text = jp.getText().trim();\n+            if (text.length() == 0) {\n+                return null;\n+            }\n+            try {\n+                return new BigInteger(text);\n+            } catch (IllegalArgumentException iae) {\n+                throw ctxt.weirdStringException(_valueClass, \"not a valid representation\");\n+            }\n+        }\n+    }\n+\n+    /*\n+    /****************************************************\n+    /* Then trickier things: Date/Calendar types\n+    /****************************************************\n+     */\n+\n+    /**\n+     * Compared to plain old {@link java.util.Date}, SQL version is easier\n+     * to deal with: mostly because it is more limited.\n+     */\n+    public static class SqlDateDeserializer\n+        extends StdScalarDeserializer<java.sql.Date>\n+    {\n+        public SqlDateDeserializer() { super(java.sql.Date.class); }\n+\n+        @Override\n+        public java.sql.Date deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            Date d = _parseDate(jp, ctxt);\n+            return (d == null) ? null : new java.sql.Date(d.getTime());\n+        }\n+    }\n+\n+    /*\n+    /****************************************************\n+    /* And other oddities\n+    /****************************************************\n+    */\n+\n+    public static class StackTraceElementDeserializer\n+        extends StdScalarDeserializer<StackTraceElement>\n+    {\n+        public StackTraceElementDeserializer() { super(StackTraceElement.class); }\n+\n+        @Override\n+        public StackTraceElement deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken t = jp.getCurrentToken();\n+            // Must get an Object\n+            if (t == JsonToken.START_OBJECT) {\n+                String className = \"\", methodName = \"\", fileName = \"\";\n+                int lineNumber = -1;\n+\n+                while ((t = jp.nextValue()) != JsonToken.END_OBJECT) {\n+                    String propName = jp.getCurrentName();\n+                    if (\"className\".equals(propName)) {\n+                        className = jp.getText();\n+                    } else if (\"fileName\".equals(propName)) {\n+                        fileName = jp.getText();\n+                    } else if (\"lineNumber\".equals(propName)) {\n+                        if (t.isNumeric()) {\n+                            lineNumber = jp.getIntValue();\n+                        } else {\n+                            throw JsonMappingException.from(jp, \"Non-numeric token (\"+t+\") for property 'lineNumber'\");\n+                        }\n+                    } else if (\"methodName\".equals(propName)) {\n+                        methodName = jp.getText();\n+                    } else if (\"nativeMethod\".equals(propName)) {\n+                        // no setter, not passed via constructor: ignore\n+                    } else {\n+                        handleUnknownProperty(jp, ctxt, _valueClass, propName);\n+                    }\n+                }\n+                return new StackTraceElement(className, methodName, fileName, lineNumber);\n+            }\n+            throw ctxt.mappingException(_valueClass, t);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.UUID;\n+\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.io.NumberInput;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.EnumResolver;\n+\n+/**\n+ * Base class for simple key deserializers.\n+ * \n+ * @since 1.9 (moved from 'org.codehaus.jackson.map.deser.StdKeyDeserializer')\n+ */\n+public abstract class StdKeyDeserializer\n+    extends KeyDeserializer\n+{\n+    final protected Class<?> _keyClass;\n+\n+    protected StdKeyDeserializer(Class<?> cls) { _keyClass = cls; }\n+\n+    @Override\n+    public final Object deserializeKey(String key, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (key == null) { // is this even legal call?\n+            return null;\n+        }\n+        try {\n+            Object result = _parse(key, ctxt);\n+            if (result != null) {\n+                return result;\n+            }\n+        } catch (Exception re) {\n+            throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation: \"+re.getMessage());\n+        }\n+        throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation\");\n+    }\n+\n+    public Class<?> getKeyClass() { return _keyClass; }\n+\n+    protected abstract Object _parse(String key, DeserializationContext ctxt) throws Exception;\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for sub-classes\n+    /**********************************************************\n+     */\n+\n+    protected int _parseInt(String key) throws IllegalArgumentException\n+    {\n+        return Integer.parseInt(key);\n+    }\n+\n+    protected long _parseLong(String key) throws IllegalArgumentException\n+    {\n+        return Long.parseLong(key);\n+    }\n+\n+    protected double _parseDouble(String key) throws IllegalArgumentException\n+    {\n+        return NumberInput.parseDouble(key);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Key deserializer implementations; wrappers\n+    /**********************************************************\n+     */\n+\n+    final static class BoolKD extends StdKeyDeserializer\n+    {\n+        BoolKD() { super(Boolean.class); }\n+\n+        @Override\n+        public Boolean _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n+        {\n+            if (\"true\".equals(key)) {\n+                return Boolean.TRUE;\n+            }\n+            if (\"false\".equals(key)) {\n+                return Boolean.FALSE;\n+            }\n+            throw ctxt.weirdKeyException(_keyClass, key, \"value not 'true' or 'false'\");\n+        }\n+    }\n+\n+    final static class ByteKD extends StdKeyDeserializer\n+    {\n+        ByteKD() { super(Byte.class); }\n+\n+        @Override\n+\t\tpublic Byte _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n+        {\n+            int value = _parseInt(key);\n+            if (value < Byte.MIN_VALUE || value > Byte.MAX_VALUE) {\n+                throw ctxt.weirdKeyException(_keyClass, key, \"overflow, value can not be represented as 8-bit value\");\n+            }\n+            return Byte.valueOf((byte) value);\n+        }\n+    }\n+\n+    final static class ShortKD extends StdKeyDeserializer\n+    {\n+        ShortKD() { super(Integer.class); }\n+\n+        @Override\n+\t\tpublic Short _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n+        {\n+            int value = _parseInt(key);\n+            if (value < Short.MIN_VALUE || value > Short.MAX_VALUE) {\n+                throw ctxt.weirdKeyException(_keyClass, key, \"overflow, value can not be represented as 16-bit value\");\n+            }\n+            return Short.valueOf((short) value);\n+        }\n+    }\n+\n+    /**\n+     * Dealing with Characters is bit trickier: let's assume it must be a String, and that\n+     * Unicode numeric value is never used.\n+     */\n+    final static class CharKD extends StdKeyDeserializer\n+    {\n+        CharKD() { super(Character.class); }\n+\n+        @Override\n+\t\tpublic Character _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n+        {\n+            if (key.length() == 1) {\n+                return Character.valueOf(key.charAt(0));\n+            }\n+            throw ctxt.weirdKeyException(_keyClass, key, \"can only convert 1-character Strings\");\n+        }\n+    }\n+\n+    final static class IntKD extends StdKeyDeserializer\n+    {\n+        IntKD() { super(Integer.class); }\n+\n+        @Override\n+\t\tpublic Integer _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n+        {\n+            return _parseInt(key);\n+        }\n+    }\n+\n+    final static class LongKD extends StdKeyDeserializer\n+    {\n+        LongKD() { super(Long.class); }\n+\n+        @Override\n+        public Long _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n+        {\n+            return _parseLong(key);\n+        }\n+    }\n+\n+    final static class DoubleKD extends StdKeyDeserializer\n+    {\n+        DoubleKD() { super(Double.class); }\n+\n+        @Override\n+        public Double _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n+        {\n+            return _parseDouble(key);\n+        }\n+    }\n+\n+    final static class FloatKD extends StdKeyDeserializer\n+    {\n+        FloatKD() { super(Float.class); }\n+\n+        @Override\n+        public Float _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n+        {\n+            /* 22-Jan-2009, tatu: Bounds/range checks would be tricky\n+             *   here, so let's not bother even trying...\n+             */\n+            return Float.valueOf((float) _parseDouble(key));\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Key deserializer implementations; other\n+    /**********************************************************\n+     */\n+\n+    final static class EnumKD extends StdKeyDeserializer\n+    {\n+        protected final EnumResolver<?> _resolver;\n+\n+        protected EnumKD(EnumResolver<?> er)\n+        {\n+            super(er.getEnumClass());\n+            _resolver = er;\n+        }\n+\n+        @Override\n+        public Enum<?> _parse(String key, DeserializationContext ctxt) throws JsonMappingException\n+        {\n+            Enum<?> e = _resolver.findEnum(key);\n+            if (e == null) {\n+                throw ctxt.weirdKeyException(_keyClass, key, \"not one of values for Enum class\");\n+            }\n+            return e;\n+        }\n+    }\n+\n+    /**\n+     * Key deserializer that calls a single-string-arg constructor\n+     * to instantiate desired key type.\n+     */\n+    final static class StringCtorKeyDeserializer extends StdKeyDeserializer\n+    {\n+        protected final Constructor<?> _ctor;\n+\n+        public StringCtorKeyDeserializer(Constructor<?> ctor) {\n+            super(ctor.getDeclaringClass());\n+            _ctor = ctor;\n+        }\n+\n+        @Override\n+        public Object _parse(String key, DeserializationContext ctxt) throws Exception\n+        {\n+            return _ctor.newInstance(key);\n+        }\n+    }\n+\n+    /**\n+     * Key deserializer that calls a static no-args factory method\n+     * to instantiate desired key type.\n+     */\n+    final static class StringFactoryKeyDeserializer extends StdKeyDeserializer\n+    {\n+        final Method _factoryMethod;\n+\n+        public StringFactoryKeyDeserializer(Method fm) {\n+            super(fm.getDeclaringClass());\n+            _factoryMethod = fm;\n+        }\n+\n+        @Override\n+        public Object _parse(String key, DeserializationContext ctxt) throws Exception\n+        {\n+            return _factoryMethod.invoke(null, key);\n+        }\n+    }\n+\n+    // as per [JACKSON-657]\n+    final static class DateKD extends StdKeyDeserializer\n+    {\n+        protected DateKD() {\n+            super(java.util.Date.class);\n+        }\n+\n+        @Override\n+        public java.util.Date _parse(String key, DeserializationContext ctxt)\n+            throws IllegalArgumentException, JsonMappingException\n+        {\n+            return ctxt.parseDate(key);\n+        }\n+    }\n+        \n+    // as per [JACKSON-657]\n+    final static class CalendarKD extends StdKeyDeserializer\n+    {\n+        protected CalendarKD() {\n+            super(java.util.Calendar.class);\n+        }\n+\n+        @Override\n+        public java.util.Calendar _parse(String key, DeserializationContext ctxt)\n+            throws IllegalArgumentException, JsonMappingException\n+        {\n+            java.util.Date date = ctxt.parseDate(key);\n+            return (date == null)  ? null : ctxt.constructCalendar(date);\n+        }\n+    }\n+\n+    // as per [JACKSON-726]\n+    final static class UuidKD extends StdKeyDeserializer\n+    {\n+        protected UuidKD() {\n+            super(UUID.class);\n+        }\n+\n+        @Override\n+        public UUID _parse(String key, DeserializationContext ctxt)\n+            throws IllegalArgumentException, JsonMappingException\n+        {\n+            return UUID.fromString(key);\n+        }\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.KeyDeserializer;\n+import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n+import com.fasterxml.jackson.databind.type.*;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.EnumResolver;\n+\n+\n+/**\n+ * Helper class used to contain simple/well-known key deserializers.\n+ * Following kinds of Objects can be handled currently:\n+ *<ul>\n+ * <li>Primitive wrappers</li>\n+ * <li>Enums (usually not needed, since EnumMap doesn't call us)</li>\n+ * <li>Anything with constructor that takes a single String arg\n+ *   (if not explicitly @JsonIgnore'd)</li>\n+ * <li>Anything with 'static T valueOf(String)' factory method\n+ *   (if not explicitly @JsonIgnore'd)</li>\n+ *</ul>\n+ */\n+public class StdKeyDeserializers\n+{\n+    protected final HashMap<JavaType, KeyDeserializer> _keyDeserializers = new HashMap<JavaType, KeyDeserializer>();\n+\n+    protected StdKeyDeserializers()\n+    {\n+        add(new StdKeyDeserializer.BoolKD());\n+        add(new StdKeyDeserializer.ByteKD());\n+        add(new StdKeyDeserializer.CharKD());\n+        add(new StdKeyDeserializer.ShortKD());\n+        add(new StdKeyDeserializer.IntKD());\n+        add(new StdKeyDeserializer.LongKD());\n+        add(new StdKeyDeserializer.FloatKD());\n+        add(new StdKeyDeserializer.DoubleKD());\n+        add(new StdKeyDeserializer.DateKD());\n+        add(new StdKeyDeserializer.CalendarKD());\n+        add(new StdKeyDeserializer.UuidKD());\n+    }\n+\n+    private void add(StdKeyDeserializer kdeser)\n+    {\n+        Class<?> keyClass = kdeser.getKeyClass();\n+        /* As with other cases involving primitive types, we can use\n+         * default TypeFactory ok, even if it's not our first choice:\n+         */\n+        _keyDeserializers.put(TypeFactory.defaultInstance().constructType(keyClass), kdeser);\n+    }\n+\n+    public static HashMap<JavaType, KeyDeserializer> constructAll()\n+    {\n+        return new StdKeyDeserializers()._keyDeserializers;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Dynamic factory methods\n+    /**********************************************************\n+     */\n+\n+    public static KeyDeserializer constructEnumKeyDeserializer(DeserializationConfig config, JavaType type)\n+    {\n+        EnumResolver<?> er = EnumResolver.constructUnsafe(type.getRawClass(), config.getAnnotationIntrospector());\n+        return new StdKeyDeserializer.EnumKD(er);\n+    }\n+\n+    public static KeyDeserializer findStringBasedKeyDeserializer(DeserializationConfig config, JavaType type)\n+    {\n+        /* We don't need full deserialization information, just need to\n+         * know creators.\n+         */\n+    \tBasicBeanDescription beanDesc = config.introspect(type);\n+        // Ok, so: can we find T(String) constructor?\n+        Constructor<?> ctor = beanDesc.findSingleArgConstructor(String.class);\n+        if (ctor != null) {\n+            if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+                ClassUtil.checkAndFixAccess(ctor);\n+            }\n+            return new StdKeyDeserializer.StringCtorKeyDeserializer(ctor);\n+        }\n+        /* or if not, \"static T valueOf(String)\" (or equivalent marked\n+         * with @JsonCreator annotation?)\n+         */\n+        Method m = beanDesc.findFactoryMethod(String.class);\n+        if (m != null){\n+            if (config.isEnabled(DeserializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+                ClassUtil.checkAndFixAccess(m);\n+            }\n+            return new StdKeyDeserializer.StringFactoryKeyDeserializer(m);\n+        }\n+        // nope, no such luck...\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdScalarDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.TypeDeserializer;\n+\n+/**\n+ * Base class for deserializers that handle types that are serialized\n+ * as JSON scalars (non-structured, i.e. non-Object, non-Array, values).\n+ * \n+ * @since 1.9 (moved from higher-level package)\n+ */\n+public abstract class StdScalarDeserializer<T> extends StdDeserializer<T>\n+{\n+    protected StdScalarDeserializer(Class<?> vc) {\n+        super(vc);\n+    }\n+\n+    protected StdScalarDeserializer(JavaType valueType) {\n+        super(valueType);\n+    }\n+    \n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        return typeDeserializer.deserializeTypedFromScalar(jp, ctxt);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdValueInstantiator.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.deser.impl.CreatorProperty;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n+\n+\n+/**\n+ * Basic {@link ValueInstantiator} implementation, which only\n+ * supports use of default constructor. Sub-types can add\n+ * support for alternate construction methods, such as using\n+ * argument-taking constructors or static factory methods.\n+ * \n+ * @since 1.9.0\n+ */\n+public class StdValueInstantiator\n+    extends ValueInstantiator\n+{\n+    /**\n+     * Type of values that are instantiated; used\n+     * for error reporting purposes.\n+     */\n+    protected final String _valueTypeDesc;\n+\n+    /**\n+     * Are we allowed to convert empty Strings to null objects?\n+     */\n+    protected final boolean _cfgEmptyStringsAsObjects;\n+    \n+    // // // Default (no-args) construction\n+\n+    /**\n+     * Default (no-argument) constructor to use for instantiation\n+     * (with {@link #createUsingDefault})\n+     */\n+    protected AnnotatedWithParams _defaultCreator;\n+\n+    // // // With-args (property-based) construction\n+\n+    protected CreatorProperty[] _constructorArguments;\n+    protected AnnotatedWithParams _withArgsCreator;\n+\n+    // // // Delegate construction\n+    \n+    protected JavaType _delegateType;\n+    protected AnnotatedWithParams _delegateCreator;\n+    \n+    // // // Scalar construction\n+\n+    protected AnnotatedWithParams _fromStringCreator;\n+    protected AnnotatedWithParams _fromIntCreator;\n+    protected AnnotatedWithParams _fromLongCreator;\n+    protected AnnotatedWithParams _fromDoubleCreator;\n+    protected AnnotatedWithParams _fromBooleanCreator;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public StdValueInstantiator(DeserializationConfig config, Class<?> valueType)\n+    {\n+        _cfgEmptyStringsAsObjects = (config == null) ? false\n+                : config.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n+        _valueTypeDesc = (valueType == null) ? \"UNKNOWN TYPE\" : valueType.getName();\n+    }\n+    \n+    public StdValueInstantiator(DeserializationConfig config, JavaType valueType)\n+    {\n+        _cfgEmptyStringsAsObjects = (config == null) ? false\n+                : config.isEnabled(DeserializationConfig.Feature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);\n+        _valueTypeDesc = (valueType == null) ? \"UNKNOWN TYPE\" : valueType.toString();\n+    }\n+    \n+    /**\n+     * Copy-constructor that sub-classes can use when creating new instances\n+     * by fluent-style construction\n+     */\n+    protected StdValueInstantiator(StdValueInstantiator src)\n+    {\n+        _cfgEmptyStringsAsObjects = src._cfgEmptyStringsAsObjects;\n+        _valueTypeDesc = src._valueTypeDesc;\n+\n+        _defaultCreator = src._defaultCreator;\n+\n+        _constructorArguments = src._constructorArguments;\n+        _withArgsCreator = src._withArgsCreator;\n+\n+        _delegateType = src._delegateType;\n+        _delegateCreator = src._delegateCreator;\n+        \n+        _fromStringCreator = src._fromStringCreator;\n+        _fromIntCreator = src._fromIntCreator;\n+        _fromLongCreator = src._fromLongCreator;\n+        _fromDoubleCreator = src._fromDoubleCreator;\n+        _fromBooleanCreator = src._fromBooleanCreator;\n+    }\n+\n+    /**\n+     * Method for setting properties related to instantiating values\n+     * from JSON Object. We will choose basically only one approach (out of possible\n+     * three), and clear other properties\n+     */\n+    public void configureFromObjectSettings(AnnotatedWithParams defaultCreator,\n+            AnnotatedWithParams delegateCreator, JavaType delegateType,\n+            AnnotatedWithParams withArgsCreator, CreatorProperty[] constructorArgs)\n+    {\n+        _defaultCreator = defaultCreator;\n+        _delegateCreator = delegateCreator;\n+        _delegateType = delegateType;\n+        _withArgsCreator = withArgsCreator;\n+        _constructorArguments = constructorArgs;\n+    }\n+\n+    public void configureFromStringCreator(AnnotatedWithParams creator) {\n+        _fromStringCreator = creator;\n+    }\n+\n+    public void configureFromIntCreator(AnnotatedWithParams creator) {\n+        _fromIntCreator = creator;\n+    }\n+\n+    public void configureFromLongCreator(AnnotatedWithParams creator) {\n+        _fromLongCreator = creator;\n+    }\n+\n+    public void configureFromDoubleCreator(AnnotatedWithParams creator) {\n+        _fromDoubleCreator = creator;\n+    }\n+\n+    public void configureFromBooleanCreator(AnnotatedWithParams creator) {\n+        _fromBooleanCreator = creator;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API implementation; metadata\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String getValueTypeDesc() {\n+        return _valueTypeDesc;\n+    }\n+    \n+    @Override\n+    public boolean canCreateFromString() {\n+        return (_fromStringCreator != null);\n+    }\n+\n+    @Override\n+    public boolean canCreateFromInt() {\n+        return (_fromIntCreator != null);\n+    }\n+\n+    @Override\n+    public boolean canCreateFromLong() {\n+        return (_fromLongCreator != null);\n+    }\n+\n+    @Override\n+    public boolean canCreateFromDouble() {\n+        return (_fromDoubleCreator != null);\n+    }\n+\n+    @Override\n+    public boolean canCreateFromBoolean() {\n+        return (_fromBooleanCreator != null);\n+    }\n+    \n+    @Override\n+    public boolean canCreateUsingDefault() {\n+        return (_defaultCreator != null);\n+    }\n+\n+    @Override\n+    public boolean canCreateFromObjectWith() {\n+        return (_withArgsCreator != null);\n+    }\n+\n+    @Override\n+    public JavaType getDelegateType() {\n+        return _delegateType;\n+    }\n+\n+    @Override\n+    public SettableBeanProperty[] getFromObjectArguments() {\n+        return _constructorArguments;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API implementation; instantiation from JSON Object\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public Object createUsingDefault()\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_defaultCreator == null) { // sanity-check; caller should check\n+            throw new IllegalStateException(\"No default constructor for \"+getValueTypeDesc());\n+        }\n+        try {\n+            return _defaultCreator.call();\n+        } catch (ExceptionInInitializerError e) {\n+            throw wrapException(e);\n+        } catch (Exception e) {\n+            throw wrapException(e);\n+        }\n+    }\n+    \n+    @Override\n+    public Object createFromObjectWith(Object[] args)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_withArgsCreator == null) { // sanity-check; caller should check\n+            throw new IllegalStateException(\"No with-args constructor for \"+getValueTypeDesc());\n+        }\n+        try {\n+            return _withArgsCreator.call(args);\n+        } catch (ExceptionInInitializerError e) {\n+            throw wrapException(e);\n+        } catch (Exception e) {\n+            throw wrapException(e);\n+        }\n+    }\n+\n+    @Override\n+    public Object createUsingDelegate(Object delegate)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_delegateCreator == null) { // sanity-check; caller should check\n+            throw new IllegalStateException(\"No delegate constructor for \"+getValueTypeDesc());\n+        }\n+        try {\n+            return _delegateCreator.call1(delegate);\n+        } catch (ExceptionInInitializerError e) {\n+            throw wrapException(e);\n+        } catch (Exception e) {\n+            throw wrapException(e);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API implementation; instantiation from JSON scalars\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public Object createFromString(String value) throws IOException, JsonProcessingException\n+    {\n+        if (_fromStringCreator != null) {\n+            try {\n+                return _fromStringCreator.call1(value);\n+            } catch (Exception e) {\n+                throw wrapException(e);\n+            }\n+        }\n+        return _createFromStringFallbacks(value);\n+    }\n+    \n+    @Override\n+    public Object createFromInt(int value) throws IOException, JsonProcessingException\n+    {\n+        try {\n+            // First: \"native\" int methods work best:\n+            if (_fromIntCreator != null) {\n+                return _fromIntCreator.call1(Integer.valueOf(value));\n+            }\n+            // but if not, can do widening conversion\n+            if (_fromLongCreator != null) {\n+                return _fromLongCreator.call1(Long.valueOf(value));\n+            }\n+        } catch (Exception e) {\n+            throw wrapException(e);\n+        }\n+        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n+                +\" from JSON integral number; no single-int-arg constructor/factory method\");\n+    }\n+\n+    @Override\n+    public Object createFromLong(long value) throws IOException, JsonProcessingException\n+    {\n+        try {\n+            if (_fromLongCreator != null) {\n+                return _fromLongCreator.call1(Long.valueOf(value));\n+            }\n+        } catch (Exception e) {\n+            throw wrapException(e);\n+        }\n+        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n+                +\" from JSON long integral number; no single-long-arg constructor/factory method\");\n+    }\n+\n+    @Override\n+    public Object createFromDouble(double value) throws IOException, JsonProcessingException\n+    {\n+        try {\n+            if (_fromDoubleCreator != null) {\n+                return _fromDoubleCreator.call1(Double.valueOf(value));\n+            }\n+        } catch (Exception e) {\n+            throw wrapException(e);\n+        }\n+        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n+                +\" from JSON floating-point number; no one-double/Double-arg constructor/factory method\");\n+    }\n+\n+    @Override\n+    public Object createFromBoolean(boolean value) throws IOException, JsonProcessingException\n+    {\n+        try {\n+            if (_fromBooleanCreator != null) {\n+                return _fromBooleanCreator.call1(Boolean.valueOf(value));\n+            }\n+        } catch (Exception e) {\n+            throw wrapException(e);\n+        }\n+        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n+                +\" from JSON boolean value; no single-boolean/Boolean-arg constructor/factory method\");\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API: configuration mutators, accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public AnnotatedWithParams getDelegateCreator() {\n+        return _delegateCreator;\n+    }\n+\n+    @Override\n+    public AnnotatedWithParams getDefaultCreator() {\n+        return _defaultCreator;\n+    }\n+\n+    @Override\n+    public AnnotatedWithParams getWithArgsCreator() {\n+        return _withArgsCreator;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    protected Object _createFromStringFallbacks(String value) throws IOException, JsonProcessingException\n+    {\n+        /* 28-Sep-2011, tatu: Ok this is not clean at all; but since there are legacy\n+         *   systems that expect conversions in some cases, let's just add a minimal\n+         *   patch (note: same could conceivably be used for numbers too).\n+         */\n+        if (_fromBooleanCreator != null) {\n+            String str = value.trim();\n+            if (\"true\".equals(str)) {\n+                return createFromBoolean(true);\n+            }\n+            if (\"false\".equals(str)) {\n+                return createFromBoolean(false);\n+            }\n+        }\n+        \n+        // and finally, empty Strings might be accepted as null Object...\n+        if (_cfgEmptyStringsAsObjects && value.length() == 0) {\n+            return null;\n+        }\n+        throw new JsonMappingException(\"Can not instantiate value of type \"+getValueTypeDesc()\n+                +\" from JSON String; no single-String constructor/factory method\");\n+    }\n+    \n+    protected JsonMappingException wrapException(Throwable t)\n+    {\n+        while (t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        return new JsonMappingException(\"Instantiation of \"+getValueTypeDesc()+\" value failed: \"+t.getMessage(), t);\n+    }\n+}\n+\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedWithParams;\n+\n+\n+@JacksonStdImpl\n+public final class StringCollectionDeserializer\n+    extends ContainerDeserializerBase<Collection<String>>\n+    implements ResolvableDeserializer\n+{\n+    // // Configuration\n+\n+    protected final JavaType _collectionType;\n+\n+    /**\n+     * Value deserializer; needed even if it is the standard String\n+     * deserializer\n+     */\n+    protected final JsonDeserializer<String> _valueDeserializer;\n+\n+    /**\n+     * Flag that indicates whether value deserializer is the standard\n+     * Jackson-provided one; if it is, we can use more efficient\n+     * handling.\n+     */\n+    protected final boolean _isDefaultDeserializer;\n+\n+    // // Instance construction settings:\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    protected final ValueInstantiator _valueInstantiator;\n+\n+    /**\n+     * Deserializer that is used iff delegate-based creator is\n+     * to be used for deserializing from JSON Object.\n+     */\n+    protected JsonDeserializer<Object> _delegateDeserializer;\n+\n+    // NOTE: no PropertyBasedCreator, as JSON Arrays have no properties\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    public StringCollectionDeserializer(JavaType collectionType, JsonDeserializer<?> valueDeser,\n+            ValueInstantiator valueInstantiator)\n+    {\n+        super(collectionType.getRawClass());\n+        _collectionType = collectionType;\n+        _valueDeserializer = (JsonDeserializer<String>) valueDeser;\n+        _valueInstantiator = valueInstantiator;\n+        _isDefaultDeserializer = isDefaultSerializer(valueDeser);\n+    }\n+\n+    /**\n+     * Copy-constructor that can be used by sub-classes to allow\n+     * copy-on-write styling copying of settings of an existing instance.\n+     * \n+     * @since 1.9\n+     */\n+    protected StringCollectionDeserializer(StringCollectionDeserializer src)\n+    {\n+        super(src._valueClass);\n+        _collectionType = src._collectionType;\n+        _valueDeserializer = src._valueDeserializer;\n+        _valueInstantiator = src._valueInstantiator;\n+        _isDefaultDeserializer = src._isDefaultDeserializer;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Validation, post-processing (ResolvableDeserializer)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to finalize setup of this deserializer,\n+     * after deserializer itself has been registered. This\n+     * is needed to handle recursive and transitive dependencies.\n+     */\n+    @Override\n+    public void resolve(DeserializationConfig config, DeserializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        // May need to resolve types for delegate-based creators:\n+        AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+        if (delegateCreator != null) {\n+            JavaType delegateType = _valueInstantiator.getDelegateType();\n+            // Need to create a temporary property to allow contextual deserializers:\n+            BeanProperty.Std property = new BeanProperty.Std(null,\n+                    delegateType, null, delegateCreator);\n+            _delegateDeserializer = findDeserializer(config, provider, delegateType, property);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* ContainerDeserializerBase API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JavaType getContentType() {\n+        return _collectionType.getContentType();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public JsonDeserializer<Object> getContentDeserializer() {\n+        JsonDeserializer<?> deser = _valueDeserializer;\n+        return (JsonDeserializer<Object>) deser;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonDeserializer API\n+    /**********************************************************\n+     */\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_delegateDeserializer != null) {\n+            return (Collection<String>) _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        final Collection<String> result = (Collection<String>) _valueInstantiator.createUsingDefault();\n+        return deserialize(jp, ctxt, result);\n+    }\n+\n+    @Override\n+    public Collection<String> deserialize(JsonParser jp, DeserializationContext ctxt,\n+                                          Collection<String> result)\n+        throws IOException, JsonProcessingException\n+    {\n+        // Ok: must point to START_ARRAY\n+        if (!jp.isExpectedStartArrayToken()) {\n+            return handleNonArray(jp, ctxt, result);\n+        }\n+\n+        if (!_isDefaultDeserializer) {\n+            return deserializeUsingCustom(jp, ctxt, result);\n+        }\n+        JsonToken t;\n+\n+        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+            result.add((t == JsonToken.VALUE_NULL) ? null : jp.getText());\n+        }\n+        return result;\n+    }\n+    \n+    private Collection<String> deserializeUsingCustom(JsonParser jp, DeserializationContext ctxt,\n+            Collection<String> result)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t;\n+        final JsonDeserializer<String> deser = _valueDeserializer;\n+\n+        while ((t = jp.nextToken()) != JsonToken.END_ARRAY) {\n+            String value;\n+\n+            if (t == JsonToken.VALUE_NULL) {\n+                value = null;\n+            } else {\n+                value = deser.deserialize(jp, ctxt);\n+            }\n+            result.add(value);\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        // In future could check current token... for now this should be enough:\n+        return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n+    }\n+\n+    /**\n+     * Helper method called when current token is no START_ARRAY. Will either\n+     * throw an exception, or try to handle value as if member of implicit\n+     * array, depending on configuration.\n+     */\n+    private final Collection<String> handleNonArray(JsonParser jp, DeserializationContext ctxt,\n+            Collection<String> result)\n+        throws IOException, JsonProcessingException\n+    {\n+        // [JACKSON-526]: implicit arrays from single values?\n+        if (!ctxt.isEnabled(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY)) {\n+            throw ctxt.mappingException(_collectionType.getRawClass());\n+        }\n+        // Strings are one of \"native\" (intrinsic) types, so there's never type deserializer involved\n+        JsonDeserializer<String> valueDes = _valueDeserializer;\n+        JsonToken t = jp.getCurrentToken();\n+\n+        String value;\n+        \n+        if (t == JsonToken.VALUE_NULL) {\n+            value = null;\n+        } else {\n+            value = (valueDes == null) ? jp.getText() : valueDes.deserialize(jp, ctxt);\n+        }\n+        result.add(value);\n+        return result;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.TypeDeserializer;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+@JacksonStdImpl\n+public class StringDeserializer\n+    extends StdScalarDeserializer<String>\n+{\n+    public StringDeserializer() { super(String.class); }\n+\n+    @Override\n+    public String deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken curr = jp.getCurrentToken();\n+        // Usually should just get string value:\n+        if (curr == JsonToken.VALUE_STRING) {\n+            return jp.getText();\n+        }\n+        // [JACKSON-330]: need to gracefully handle byte[] data, as base64\n+        if (curr == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+            Object ob = jp.getEmbeddedObject();\n+            if (ob == null) {\n+                return null;\n+            }\n+            if (ob instanceof byte[]) {\n+                return Base64Variants.getDefaultVariant().encode((byte[]) ob, false);\n+            }\n+            // otherwise, try conversion using toString()...\n+            return ob.toString();\n+        }\n+        // Can deserialize any scalar value, but not markers\n+        if (curr.isScalarValue()) {\n+            return jp.getText();\n+        }\n+        throw ctxt.mappingException(_valueClass, curr);\n+    }\n+\n+    // 1.6: since we can never have type info (\"natural type\"; String, Boolean, Integer, Double):\n+    // (is it an error to even call this version?)\n+    @Override\n+    public String deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        return deserialize(jp, ctxt);\n+    }}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ThrowableDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.BeanDeserializer;\n+import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n+\n+/**\n+ * Deserializer that builds on basic {@link BeanDeserializer} but\n+ * override some aspects like instance construction.\n+ *<p>\n+ * Note that this deserializer was significantly changed in Jackson 1.7\n+ * (due to massive changes in {@link BeanDeserializer}).\n+ * \n+ * @since 1.9 (renamed from 'org.codehaus.jackson.map.deser.ThrowableDeserializer')\n+ */\n+public class ThrowableDeserializer\n+    extends BeanDeserializer\n+{\n+    protected final static String PROP_NAME_MESSAGE = \"message\";\n+\n+    /*\n+    /************************************************************\n+    /* Construction\n+    /************************************************************\n+     */\n+\n+    public ThrowableDeserializer(BeanDeserializer baseDeserializer)\n+    {\n+        super(baseDeserializer);\n+    }\n+\n+    /**\n+     * Alternative constructor used when creating \"unwrapping\" deserializers\n+     * \n+     * @since 1.9\n+     */\n+    protected ThrowableDeserializer(BeanDeserializer src, boolean ignoreAllUnknown)\n+    {\n+        super(src, ignoreAllUnknown);\n+    }\n+    \n+    @Override\n+    public JsonDeserializer<Object> unwrappingDeserializer()\n+    {\n+        if (getClass() != ThrowableDeserializer.class) {\n+            return this;\n+        }\n+        /* main thing really is to just enforce ignoring of unknown\n+         * properties; since there may be multiple unwrapped values\n+         * and properties for all may be interleaved...\n+         */\n+        return new ThrowableDeserializer(this, true);\n+    }\n+\n+    \n+    /*\n+    /************************************************************\n+    /* Overridden methods\n+    /************************************************************\n+     */\n+\n+    @Override\n+    public Object deserializeFromObject(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // 30-Sep-2010, tatu: Need to allow use of @JsonCreator, so:\n+        if (_propertyBasedCreator != null) { // proper @JsonCreator\n+            return _deserializeUsingPropertyBased(jp, ctxt);\n+        }\n+        if (_delegateDeserializer != null) {\n+            return _valueInstantiator.createUsingDelegate(_delegateDeserializer.deserialize(jp, ctxt));\n+        }\n+        if (_beanType.isAbstract()) { // for good measure, check this too\n+            throw JsonMappingException.from(jp, \"Can not instantiate abstract type \"+_beanType\n+                    +\" (need to add/enable type information?)\");\n+        }\n+        boolean hasStringCreator = _valueInstantiator.canCreateFromString();\n+        boolean hasDefaultCtor = _valueInstantiator.canCreateUsingDefault();\n+        // and finally, verify we do have single-String arg constructor (if no @JsonCreator)\n+        if (!hasStringCreator && !hasDefaultCtor) {\n+            throw new JsonMappingException(\"Can not deserialize Throwable of type \"+_beanType\n+                    +\" without having a default contructor, a single-String-arg constructor; or explicit @JsonCreator\");\n+        }\n+        \n+        Object throwable = null;\n+        Object[] pending = null;\n+        int pendingIx = 0;\n+\n+        for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n+            String propName = jp.getCurrentName();\n+            SettableBeanProperty prop = _beanProperties.find(propName);\n+            jp.nextToken(); // to point to field value\n+\n+            if (prop != null) { // normal case\n+                if (throwable != null) {\n+                    prop.deserializeAndSet(jp, ctxt, throwable);\n+                    continue;\n+                }\n+                // nope; need to defer\n+                if (pending == null) {\n+                    int len = _beanProperties.size();\n+                    pending = new Object[len + len];\n+                }\n+                pending[pendingIx++] = prop;\n+                pending[pendingIx++] = prop.deserialize(jp, ctxt);\n+                continue;\n+            }\n+\n+            // Maybe it's \"message\"?\n+            if (PROP_NAME_MESSAGE.equals(propName)) {\n+                if (hasStringCreator) {\n+                    throwable = _valueInstantiator.createFromString(jp.getText());\n+                    // any pending values?\n+                    if (pending != null) {\n+                        for (int i = 0, len = pendingIx; i < len; i += 2) {\n+                            prop = (SettableBeanProperty)pending[i];\n+                            prop.set(throwable, pending[i+1]);\n+                        }\n+                        pending = null;\n+                    }\n+                    continue;\n+                }\n+            }\n+            /* As per [JACKSON-313], things marked as ignorable should not be\n+             * passed to any setter\n+             */\n+            if (_ignorableProps != null && _ignorableProps.contains(propName)) {\n+                jp.skipChildren();\n+                continue;\n+            }\n+            if (_anySetter != null) {\n+                _anySetter.deserializeAndSet(jp, ctxt, throwable, propName);\n+                continue;\n+            }\n+            // Unknown: let's call handler method\n+            handleUnknownProperty(jp, ctxt, throwable, propName);\n+        }\n+        // Sanity check: did we find \"message\"?\n+        if (throwable == null) {\n+            /* 15-Oct-2010, tatu: Can't assume missing message is an error, since it may be\n+             *   suppressed during serialization, as per [JACKSON-388].\n+             *   \n+             *   Should probably allow use of default constructor, too...\n+             */\n+            //throw new JsonMappingException(\"No 'message' property found: could not deserialize \"+_beanType);\n+            if (hasStringCreator) {\n+                throwable = _valueInstantiator.createFromString(null);\n+            } else {\n+                throwable = _valueInstantiator.createUsingDefault();\n+            }\n+            // any pending values?\n+            if (pending != null) {\n+                for (int i = 0, len = pendingIx; i < len; i += 2) {\n+                    SettableBeanProperty prop = (SettableBeanProperty)pending[i];\n+                    prop.set(throwable, pending[i+1]);\n+                }\n+            }\n+        }\n+        return throwable;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/TimestampDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.sql.Timestamp;\n+\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.JsonParser;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+\n+/**\n+ * Simple deserializer for handling {@link java.sql.Timestamp} values.\n+ *<p>\n+ * One way to customize Timestamp formats accepted is to override method\n+ * {@link DeserializationContext#parseDate} that this basic\n+ * deserializer calls.\n+ *\n+ * @since 1.9 (moved from higher-level package)\n+ */\n+public class TimestampDeserializer\n+    extends StdScalarDeserializer<Timestamp>\n+{\n+    public TimestampDeserializer() { super(Timestamp.class); }\n+\n+    @Override\n+    public java.sql.Timestamp deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        return new Timestamp(_parseDate(jp, ctxt).getTime());\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/TokenBufferDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.JsonParser;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.util.TokenBuffer;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * We also want to directly support deserialization of\n+ * {@link TokenBuffer}.\n+ *<p>\n+ * Note that we use scalar deserializer base just because we claim\n+ * to be of scalar for type information inclusion purposes; actual\n+ * underlying content can be of any (Object, Array, scalar) type.\n+ *\n+ * @since 1.9 (moved from higher-level package)\n+ */\n+@JacksonStdImpl\n+public class TokenBufferDeserializer\n+    extends StdScalarDeserializer<TokenBuffer>\n+{\n+    public TokenBufferDeserializer() { super(TokenBuffer.class); }\n+\n+    @Override\n+    public TokenBuffer deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        TokenBuffer tb = new TokenBuffer(jp.getCodec());\n+        // quite simple, given that TokenBuffer is a JsonGenerator:\n+        tb.copyCurrentStructure(jp);\n+        return tb;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/UntypedObjectDeserializer.java\n+package com.fasterxml.jackson.databind.deser.std;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.JsonParser;\n+import org.codehaus.jackson.JsonToken;\n+\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.TypeDeserializer;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.util.ObjectBuffer;\n+\n+/**\n+ * Deserializer implementation that is used if it is necessary to bind content of\n+ * \"unknown\" type; something declared as basic {@link java.lang.Object}\n+ * (either explicitly, or due to type erasure).\n+ * If so, \"natural\" mapping is used to convert JSON values to their natural\n+ * Java object matches: JSON arrays to Java {@link java.util.List}s (or, if configured,\n+ * Object[]), JSON objects to {@link java.util.Map}s, numbers to\n+ * {@link java.lang.Number}s, booleans to {@link java.lang.Boolean}s and\n+ * strings to {@link java.lang.String} (and nulls to nulls).\n+ *\n+ * @since 1.9 (moved from higher-level package)\n+ */\n+@JacksonStdImpl\n+public class UntypedObjectDeserializer\n+    extends StdDeserializer<Object>\n+{\n+    private final static Object[] NO_OBJECTS = new Object[0];\n+    \n+    public UntypedObjectDeserializer() { super(Object.class); }\n+\n+    /*\n+    /**********************************************************\n+    /* Deserializer API\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        switch (jp.getCurrentToken()) {\n+        case START_OBJECT:\n+            return mapObject(jp, ctxt);\n+        case END_OBJECT: // invalid\n+            break;\n+        case START_ARRAY:\n+            return mapArray(jp, ctxt);\n+        case END_ARRAY: // invalid\n+            break;\n+        case FIELD_NAME:\n+            return mapObject(jp, ctxt);\n+        case VALUE_EMBEDDED_OBJECT:\n+            return jp.getEmbeddedObject();\n+        case VALUE_STRING:\n+            return jp.getText();\n+\n+        case VALUE_NUMBER_INT:\n+            /* [JACKSON-100]: caller may want to get all integral values\n+             * returned as BigInteger, for consistency\n+             */\n+            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                return jp.getBigIntegerValue(); // should be optimal, whatever it is\n+            }\n+            return jp.getNumberValue(); // should be optimal, whatever it is\n+\n+        case VALUE_NUMBER_FLOAT:\n+            /* [JACKSON-72]: need to allow overriding the behavior regarding\n+             *   which type to use\n+             */\n+            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                return jp.getDecimalValue();\n+            }\n+            return Double.valueOf(jp.getDoubleValue());\n+\n+        case VALUE_TRUE:\n+            return Boolean.TRUE;\n+        case VALUE_FALSE:\n+            return Boolean.FALSE;\n+\n+        case VALUE_NULL: // should not get this but...\n+            return null;\n+            \n+         }\n+\n+        throw ctxt.mappingException(Object.class);\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+            TypeDeserializer typeDeserializer)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        switch (t) {\n+        // First: does it look like we had type id wrapping of some kind?\n+        case START_ARRAY:\n+        case START_OBJECT:\n+        case FIELD_NAME:\n+            /* Output can be as JSON Object, Array or scalar: no way to know\n+             * a this point:\n+             */\n+            return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n+\n+        /* Otherwise we probably got a \"native\" type (ones that map\n+         * naturally and thus do not need or use type ids)\n+         */\n+        case VALUE_STRING:\n+            return jp.getText();\n+\n+        case VALUE_NUMBER_INT:\n+            // For [JACKSON-100], see above:\n+            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_INTEGER_FOR_INTS)) {\n+                return jp.getBigIntegerValue();\n+            }\n+            return jp.getIntValue();\n+\n+        case VALUE_NUMBER_FLOAT:\n+            // For [JACKSON-72], see above\n+            if (ctxt.isEnabled(DeserializationConfig.Feature.USE_BIG_DECIMAL_FOR_FLOATS)) {\n+                return jp.getDecimalValue();\n+            }\n+            return Double.valueOf(jp.getDoubleValue());\n+\n+        case VALUE_TRUE:\n+            return Boolean.TRUE;\n+        case VALUE_FALSE:\n+            return Boolean.FALSE;\n+        case VALUE_EMBEDDED_OBJECT:\n+            return jp.getEmbeddedObject();\n+\n+        case VALUE_NULL: // should not get this far really but...\n+            return null;\n+        }\n+        throw ctxt.mappingException(Object.class);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called to map a JSON Array into a Java value.\n+     */\n+    protected Object mapArray(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (ctxt.isEnabled(DeserializationConfig.Feature.USE_JAVA_ARRAY_FOR_JSON_ARRAY)) {\n+            return mapArrayToArray(jp, ctxt);\n+        }\n+        // Minor optimization to handle small lists (default size for ArrayList is 10)\n+        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n+            return new ArrayList<Object>(4);\n+        }\n+        ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n+        Object[] values = buffer.resetAndStart();\n+        int ptr = 0;\n+        int totalSize = 0;\n+        do {\n+            Object value = deserialize(jp, ctxt);\n+            ++totalSize;\n+            if (ptr >= values.length) {\n+                values = buffer.appendCompletedChunk(values);\n+                ptr = 0;\n+            }\n+            values[ptr++] = value;\n+        } while (jp.nextToken() != JsonToken.END_ARRAY);\n+        // let's create almost full array, with 1/8 slack\n+        ArrayList<Object> result = new ArrayList<Object>(totalSize + (totalSize >> 3) + 1);\n+        buffer.completeAndClearBuffer(values, ptr, result);\n+        return result;\n+    }\n+\n+    /**\n+     * Method called to map a JSON Object into a Java value.\n+     */\n+    protected Object mapObject(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        }\n+        // 1.6: minor optimization; let's handle 1 and 2 entry cases separately\n+        if (t != JsonToken.FIELD_NAME) { // and empty one too\n+            // empty map might work; but caller may want to modify... so better just give small modifiable\n+            return new LinkedHashMap<String,Object>(4);\n+        }\n+        String field1 = jp.getText();\n+        jp.nextToken();\n+        Object value1 = deserialize(jp, ctxt);\n+        if (jp.nextToken() != JsonToken.FIELD_NAME) { // single entry; but we want modifiable\n+            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4);\n+            result.put(field1, value1);\n+            return result;\n+        }\n+        String field2 = jp.getText();\n+        jp.nextToken();\n+        Object value2 = deserialize(jp, ctxt);\n+        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n+            LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>(4);\n+            result.put(field1, value1);\n+            result.put(field2, value2);\n+            return result;\n+        }\n+        // And then the general case; default map size is 16\n+        LinkedHashMap<String, Object> result = new LinkedHashMap<String, Object>();\n+        result.put(field1, value1);\n+        result.put(field2, value2);\n+        do {\n+            String fieldName = jp.getText();\n+            jp.nextToken();\n+            result.put(fieldName, deserialize(jp, ctxt));\n+        } while (jp.nextToken() != JsonToken.END_OBJECT);\n+        return result;\n+    }\n+\n+    /**\n+     * Method called to map a JSON Array into a Java Object array (Object[]).\n+     * \n+     * @since 1.9\n+     */\n+    protected Object[] mapArrayToArray(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // Minor optimization to handle small lists (default size for ArrayList is 10)\n+        if (jp.nextToken()  == JsonToken.END_ARRAY) {\n+            return NO_OBJECTS;\n+        }\n+        ObjectBuffer buffer = ctxt.leaseObjectBuffer();\n+        Object[] values = buffer.resetAndStart();\n+        int ptr = 0;\n+        do {\n+            Object value = deserialize(jp, ctxt);\n+            if (ptr >= values.length) {\n+                values = buffer.appendCompletedChunk(values);\n+                ptr = 0;\n+            }\n+            values[ptr++] = value;\n+        } while (jp.nextToken() != JsonToken.END_ARRAY);\n+        return buffer.completeAndClearBuffer(values, ptr);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/package-info.java\n+/**\n+ * Contains public standard implementations of abstraction that\n+ * Jackson uses. This means that they are not merely implementation\n+ * details, but part of semi-public interface where project\n+ * tries to maintain backwards compatibility at higher level\n+ * than for 'impl' types (although less so than with fully\n+ * public interfaces).\n+ *<p>\n+ * Note that since this package was only added relatively late\n+ * in development cycle, not all classes that belong here are\n+ * included. Plan is to move more classes over time.\n+ * \n+ * @since 1.9\n+ */\n+package com.fasterxml.jackson.databind.deser.std;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java\n+package com.fasterxml.jackson.databind.exc;\n+\n+import org.codehaus.jackson.JsonLocation;\n+import org.codehaus.jackson.JsonParser;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+\n+/**\n+ * Specialized {@link JsonMappingException} sub-class specifically used\n+ * to indicate problems due to encountering a JSON property that could\n+ * not be mapped to an Object property (via getter, constructor argument\n+ * or field).\n+ * \n+ * @since 1.6\n+ */\n+public class UnrecognizedPropertyException\n+    extends JsonMappingException\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Class that does not contain mapping for the unrecognized property.\n+     */\n+    protected final Class<?> _referringClass;\n+    \n+    /**\n+     *<p>\n+     * Note: redundant information since it is also included in the\n+     * reference path.\n+     */\n+    protected final String _unrecognizedPropertyName;\n+    \n+    public UnrecognizedPropertyException(String msg, JsonLocation loc,\n+            Class<?> referringClass, String propName)\n+    {\n+        \n+        super(msg, loc);\n+        _referringClass = referringClass;\n+        _unrecognizedPropertyName = propName;\n+    }\n+\n+    public static UnrecognizedPropertyException from(JsonParser jp, Object fromObjectOrClass, String propertyName)\n+    {\n+        if (fromObjectOrClass == null) {\n+            throw new IllegalArgumentException();\n+        }\n+        Class<?> ref;\n+        if (fromObjectOrClass instanceof Class<?>) {\n+            ref = (Class<?>) fromObjectOrClass;\n+        } else {\n+            ref = fromObjectOrClass.getClass();\n+        }\n+        String msg = \"Unrecognized field \\\"\"+propertyName+\"\\\" (Class \"+ref.getName()+\"), not marked as ignorable\";\n+        UnrecognizedPropertyException e = new UnrecognizedPropertyException(msg, jp.getCurrentLocation(), ref, propertyName);\n+        // but let's also ensure path includes this last (missing) segment\n+        e.prependPath(fromObjectOrClass, propertyName);\n+        return e;\n+    }\n+\n+    /**\n+     * Method for accessing type (class) that is missing definition to allow\n+     * binding of the unrecognized property.\n+     */\n+    public Class<?> getReferringClass() {\n+        return _referringClass;\n+    }\n+    \n+    /**\n+     * Convenience method for accessing logical property name that could\n+     * not be mapped. Note that it is the last path reference in the\n+     * underlying path.\n+     */\n+    public String getUnrecognizedPropertyName() {\n+        return _unrecognizedPropertyName;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLDeserializers.java\n+package com.fasterxml.jackson.databind.ext;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import javax.xml.datatype.DatatypeConfigurationException;\n+import javax.xml.datatype.DatatypeFactory;\n+import javax.xml.datatype.Duration;\n+import javax.xml.datatype.XMLGregorianCalendar;\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.deser.std.FromStringDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;\n+import com.fasterxml.jackson.databind.util.Provider;\n+\n+/**\n+ * Container deserializers that handle \"core\" XML types: ones included in standard\n+ * JDK 1.5. Types are directly needed by JAXB, and are thus supported within core\n+ * mapper package, not in \"xc\" package.\n+ *\n+ * @since 1.3\n+ */\n+public class CoreXMLDeserializers\n+    implements Provider<StdDeserializer<?>>\n+{\n+    /**\n+     * Data type factories are thread-safe after instantiation (and\n+     * configuration, if any); and since instantion (esp. implementation\n+     * introspection) can be expensive we better reuse the instance.\n+     */\n+    final static DatatypeFactory _dataTypeFactory;\n+    static {\n+        try {\n+            _dataTypeFactory = DatatypeFactory.newInstance();\n+        } catch (DatatypeConfigurationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Provider implementation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called by {@link com.fasterxml.jackson.databind.deser.BasicDeserializerFactory}\n+     * to register deserializers this class provides.\n+     */\n+    @Override\n+    public Collection<StdDeserializer<?>> provide()\n+    {\n+        return Arrays.asList(new StdDeserializer<?>[] {\n+            new DurationDeserializer()\n+            ,new GregorianCalendarDeserializer()\n+            ,new QNameDeserializer()\n+        });\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Concrete deserializers\n+    /**********************************************************\n+     */\n+\n+    public static class DurationDeserializer\n+        extends FromStringDeserializer<Duration>\n+    {\n+        public DurationDeserializer() { super(Duration.class); }\n+    \n+        @Override\n+        protected Duration _deserialize(String value, DeserializationContext ctxt)\n+            throws IllegalArgumentException\n+        {\n+            return _dataTypeFactory.newDuration(value);\n+        }\n+    }\n+\n+    public static class GregorianCalendarDeserializer\n+        extends StdScalarDeserializer<XMLGregorianCalendar>\n+    {\n+        public GregorianCalendarDeserializer() { super(XMLGregorianCalendar.class); }\n+        \n+        @Override\n+        public XMLGregorianCalendar deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            Date d = _parseDate(jp, ctxt);\n+            if (d == null) {\n+                return null;\n+            }\n+            GregorianCalendar calendar = new GregorianCalendar();\n+            calendar.setTime(d);\n+            return _dataTypeFactory.newXMLGregorianCalendar(calendar);\n+        }\n+    }\n+\n+    public static class QNameDeserializer\n+        extends FromStringDeserializer<QName>\n+    {\n+        public QNameDeserializer() { super(QName.class); }\n+        \n+        @Override\n+        protected QName _deserialize(String value, DeserializationContext ctxt)\n+            throws IllegalArgumentException\n+        {\n+            return QName.valueOf(value);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n+package com.fasterxml.jackson.databind.ext;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.xml.datatype.Duration;\n+import javax.xml.datatype.XMLGregorianCalendar;\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.ser.std.CalendarSerializer;\n+import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n+import com.fasterxml.jackson.databind.util.Provider;\n+\n+/**\n+ * Provider for serializers of XML types that are part of full JDK 1.5, but\n+ * that some alleged 1.5 platforms are missing (Android, GAE).\n+ * And for this reason these are added using more dynamic mechanism.\n+ *<p>\n+ * Note: since many of classes defined are abstract, caller must take\n+ * care not to just use straight equivalency check but rather consider\n+ * subclassing as well.\n+ *\n+ * @since 1.4\n+ */\n+public class CoreXMLSerializers\n+    implements Provider<Map.Entry<Class<?>,JsonSerializer<?>>>\n+{\n+    final static HashMap<Class<?>,JsonSerializer<?>> _serializers = new HashMap<Class<?>,JsonSerializer<?>>();\n+    /**\n+     * We will construct instances statically, during class loading, to try to\n+     * make things fail-fast, i.e. to catch problems as soon as possible.\n+     */\n+    static {\n+        ToStringSerializer tss = ToStringSerializer.instance;\n+        _serializers.put(Duration.class, tss);\n+        _serializers.put(XMLGregorianCalendar.class, new XMLGregorianCalendarSerializer());\n+        _serializers.put(QName.class, tss);\n+    }\n+    \n+    @Override\n+    public Collection<Map.Entry<Class<?>,JsonSerializer<?>>> provide() {\n+        return _serializers.entrySet();\n+    }\n+\n+    public static class XMLGregorianCalendarSerializer extends SerializerBase<XMLGregorianCalendar>\n+    {\n+        public XMLGregorianCalendarSerializer() {\n+            super(XMLGregorianCalendar.class);\n+        }\n+\n+        @Override\n+        public void serialize(XMLGregorianCalendar value, JsonGenerator jgen, SerializerProvider provider)\n+                throws IOException, JsonGenerationException {\n+            CalendarSerializer.instance.serialize(value.toGregorianCalendar(), jgen, provider);\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n+            return CalendarSerializer.instance.getSchema(provider, typeHint);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/DOMDeserializer.java\n+package com.fasterxml.jackson.databind.ext;\n+\n+import java.io.StringReader;\n+\n+import javax.xml.parsers.DocumentBuilderFactory;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.xml.sax.InputSource;\n+\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.deser.std.FromStringDeserializer;\n+\n+/**\n+ * Base for serializers that allows parsing DOM Documents from JSON Strings.\n+ * Nominal type can be either {@link org.w3c.dom.Node} or\n+ * {@link org.w3c.dom.Document}.\n+ */\n+public abstract class DOMDeserializer<T> extends FromStringDeserializer<T>\n+{\n+    final static DocumentBuilderFactory _parserFactory;\n+    static {\n+        _parserFactory = DocumentBuilderFactory.newInstance();\n+        // yup, only cave men do XML without recognizing namespaces...\n+        _parserFactory.setNamespaceAware(true);\n+    }\n+\n+    protected DOMDeserializer(Class<T> cls) { super(cls); }\n+\n+    @Override\n+    public abstract T _deserialize(String value, DeserializationContext ctxt);\n+\n+    protected final Document parse(String value) throws IllegalArgumentException\n+    {\n+        try {\n+            return _parserFactory.newDocumentBuilder().parse(new InputSource(new StringReader(value)));\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Failed to parse JSON String as XML: \"+e.getMessage(), e);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Concrete deserializers\n+    /**********************************************************\n+     */\n+    \n+    public static class NodeDeserializer extends DOMDeserializer<Node>\n+    {\n+        public NodeDeserializer() { super(Node.class); }\n+        @Override\n+        public Node _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException {\n+            return parse(value);\n+        }\n+    }    \n+\n+    public static class DocumentDeserializer extends DOMDeserializer<Document>\n+    {\n+        public DocumentDeserializer() { super(Document.class); }\n+        @Override\n+        public Document _deserialize(String value, DeserializationContext ctxt) throws IllegalArgumentException {\n+            return parse(value);\n+        }\n+    }    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/DOMSerializer.java\n+package com.fasterxml.jackson.databind.ext;\n+\n+import java.io.IOException;\n+import org.w3c.dom.Node;\n+import  org.w3c.dom.bootstrap.DOMImplementationRegistry;\n+import  org.w3c.dom.ls.DOMImplementationLS;\n+import  org.w3c.dom.ls.LSSerializer;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+\n+public class DOMSerializer\n+    extends SerializerBase<Node>\n+{\n+    protected final DOMImplementationLS _domImpl;\n+\n+    public DOMSerializer()\n+    {\n+        super(Node.class);\n+        DOMImplementationRegistry registry;\n+        try {\n+            registry = DOMImplementationRegistry.newInstance();\n+        } catch (Exception e) {\n+            throw new IllegalStateException(\"Could not instantiate DOMImplementationRegistry: \"+e.getMessage(), e);\n+        }\n+        _domImpl = (DOMImplementationLS)registry.getDOMImplementation(\"LS\");\n+    }\n+    \n+    @Override\n+    public void serialize(Node value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_domImpl == null) throw new IllegalStateException(\"Could not find DOM LS\");    \t\n+        LSSerializer writer = _domImpl.createLSSerializer();\n+        jgen.writeString(writer.writeToString(value));\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n+    {\n+        // Well... it is serialized as String\n+        return createSchemaNode(\"string\", true);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/JodaDeserializers.java\n+package com.fasterxml.jackson.databind.ext;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import org.joda.time.*;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import org.codehaus.jackson.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;\n+import com.fasterxml.jackson.databind.util.Provider;\n+\n+/**\n+ * Provider for deserializers that handle some basic data types\n+ * for <a href=\"http://joda-time.sourceforge.net/\">Joda</a> date/time library.\n+ *\n+ * @since 1.4\n+ */\n+public class JodaDeserializers\n+    implements Provider<StdDeserializer<?>>\n+{\n+    @Override\n+    public Collection<StdDeserializer<?>> provide() {\n+        return Arrays.asList(new StdDeserializer<?>[] {\n+                new DateTimeDeserializer<DateTime>(DateTime.class)\n+                ,new DateTimeDeserializer<ReadableDateTime>(ReadableDateTime.class)\n+                ,new DateTimeDeserializer<ReadableInstant>(ReadableInstant.class)\n+                ,new LocalDateDeserializer()\n+                ,new LocalDateTimeDeserializer()\n+                ,new DateMidnightDeserializer()\n+                ,new PeriodDeserializer()\n+        });\n+    }\n+\n+    /*\n+    /*********************************************************************\n+    /* Intermediate base classes\n+    /*********************************************************************\n+    */\n+\n+    abstract static class JodaDeserializer<T> extends StdScalarDeserializer<T>\n+    {\n+        final static DateTimeFormatter _localDateTimeFormat = ISODateTimeFormat.localDateOptionalTimeParser();\n+\n+        protected JodaDeserializer(Class<T> cls) { super(cls); }\n+\n+        protected DateTime parseLocal(JsonParser jp)\n+            throws IOException, JsonProcessingException\n+        {\n+            String str = jp.getText().trim();\n+            if (str.length() == 0) { // [JACKSON-360]\n+                return null;\n+            }\n+            return _localDateTimeFormat.parseDateTime(str);\n+        }\n+    }\n+    \n+    /*\n+    /*********************************************************************\n+    /* Concrete deserializers\n+    /*********************************************************************\n+    */\n+\n+    /**\n+     * Basic deserializer for {@link DateTime}. Accepts JSON String and Number\n+     * values and passes those to single-argument constructor.\n+     * Does not (yet?) support JSON object; support can be added if desired.\n+     *<p>\n+     * Since 1.6 this has been generic, to handle multiple related types,\n+     * including super types of {@link DateTime}\n+     */\n+    public static class DateTimeDeserializer<T extends ReadableInstant>\n+        extends JodaDeserializer<T>\n+    {\n+        public DateTimeDeserializer(Class<T> cls) { super(cls); }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public T deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            JsonToken t = jp.getCurrentToken();\n+            if (t == JsonToken.VALUE_NUMBER_INT) {\n+                return (T) new DateTime(jp.getLongValue(), DateTimeZone.UTC);\n+            }\n+            if (t == JsonToken.VALUE_STRING) {\n+                String str = jp.getText().trim();\n+                if (str.length() == 0) { // [JACKSON-360]\n+                    return null;\n+                }\n+                return (T) new DateTime(str, DateTimeZone.UTC);\n+            }\n+            throw ctxt.mappingException(getValueClass());\n+        }\n+    }\n+\n+    /**\n+     * @since 1.5\n+     */\n+    public static class LocalDateDeserializer\n+        extends JodaDeserializer<LocalDate>\n+    {\n+        public LocalDateDeserializer() { super(LocalDate.class); }\n+    \n+        @Override\n+        public LocalDate deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            // We'll accept either long (timestamp) or array:\n+            if (jp.isExpectedStartArrayToken()) {\n+                jp.nextToken(); // VALUE_NUMBER_INT \n+                int year = jp.getIntValue(); \n+                jp.nextToken(); // VALUE_NUMBER_INT\n+                int month = jp.getIntValue();\n+                jp.nextToken(); // VALUE_NUMBER_INT\n+                int day = jp.getIntValue();\n+                if (jp.nextToken() != JsonToken.END_ARRAY) {\n+                    throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"after LocalDate ints\");\n+                }\n+                return new LocalDate(year, month, day);\n+            }\n+            switch (jp.getCurrentToken()) {\n+            case VALUE_NUMBER_INT:\n+                return new LocalDate(jp.getLongValue());            \n+            case VALUE_STRING:\n+                DateTime local = parseLocal(jp);\n+                if (local == null) {\n+                    return null;\n+                }\n+                return local.toLocalDate();\n+            }\n+            throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, \"expected JSON Array, String or Number\");\n+        }\n+    }\n+\n+    /**\n+     * @since 1.5\n+     */\n+    public static class LocalDateTimeDeserializer\n+        extends JodaDeserializer<LocalDateTime>\n+    {\n+        public LocalDateTimeDeserializer() { super(LocalDateTime.class); }\n+    \n+        @Override\n+        public LocalDateTime deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            // We'll accept either long (timestamp) or array:\n+            if (jp.isExpectedStartArrayToken()) {\n+                jp.nextToken(); // VALUE_NUMBER_INT\n+                int year = jp.getIntValue();\n+                jp.nextToken(); // VALUE_NUMBER_INT\n+                int month = jp.getIntValue();\n+                jp.nextToken(); // VALUE_NUMBER_INT\n+                int day = jp.getIntValue();\n+                jp.nextToken(); // VALUE_NUMBER_INT\n+                int hour = jp.getIntValue();\n+                jp.nextToken(); // VALUE_NUMBER_INT\n+                int minute = jp.getIntValue();\n+                jp.nextToken(); // VALUE_NUMBER_INT\n+                int second = jp.getIntValue();\n+                // let's leave milliseconds optional?\n+                int millisecond = 0;\n+                if (jp.nextToken() != JsonToken.END_ARRAY) { // VALUE_NUMBER_INT           \n+                    millisecond = jp.getIntValue();\n+                    jp.nextToken(); // END_ARRAY?\n+                }\n+                if (jp.getCurrentToken() != JsonToken.END_ARRAY) {\n+                    throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"after LocalDateTime ints\");\n+                }\n+                return new LocalDateTime(year, month, day, hour, minute, second, millisecond);                 \n+            }\n+\n+            switch (jp.getCurrentToken()) {\n+            case VALUE_NUMBER_INT:\n+                return new LocalDateTime(jp.getLongValue());            \n+            case VALUE_STRING:\n+                DateTime local = parseLocal(jp);\n+                if (local == null) {\n+                    return null;\n+                }\n+                return local.toLocalDateTime();\n+            }\n+            throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, \"expected JSON Array or Number\");\n+        }\n+    }\n+\n+    /**\n+     * @since 1.5\n+     */\n+    public static class DateMidnightDeserializer\n+        extends JodaDeserializer<DateMidnight>\n+    {\n+        public DateMidnightDeserializer() { super(DateMidnight.class); }\n+    \n+        @Override\n+        public DateMidnight deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+        {\n+            // We'll accept either long (timestamp) or array:\n+            if (jp.isExpectedStartArrayToken()) {\n+                jp.nextToken(); // VALUE_NUMBER_INT \n+                int year = jp.getIntValue(); \n+                jp.nextToken(); // VALUE_NUMBER_INT\n+                int month = jp.getIntValue();\n+                jp.nextToken(); // VALUE_NUMBER_INT\n+                int day = jp.getIntValue();\n+                if (jp.nextToken() != JsonToken.END_ARRAY) {\n+                    throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY, \"after DateMidnight ints\");\n+                }\n+                return new DateMidnight(year, month, day);\n+            }\n+            switch (jp.getCurrentToken()) {\n+            case VALUE_NUMBER_INT:\n+                return new DateMidnight(jp.getLongValue());            \n+            case VALUE_STRING:\n+                DateTime local = parseLocal(jp);\n+                if (local == null) {\n+                    return null;\n+                }\n+                return local.toDateMidnight();\n+            }\n+            throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, \"expected JSON Array, Number or String\");\n+        }\n+    }\n+\n+    /**\n+     * @since 1.9.2\n+     */\n+    public static class PeriodDeserializer\n+        extends JodaDeserializer<ReadablePeriod>\n+    {\n+       public PeriodDeserializer() { super(ReadablePeriod.class); }\n+   \n+       @Override\n+       public ReadablePeriod deserialize(JsonParser jp, DeserializationContext ctxt)\n+           throws IOException, JsonProcessingException\n+       {\n+           // TODO: perhaps support array of numbers...\n+           //if (jp.isExpectedStartArrayToken()) { ]\n+           switch (jp.getCurrentToken()) {\n+           case VALUE_NUMBER_INT: // assume it's millisecond count\n+               return new Period(jp.getLongValue());            \n+           case VALUE_STRING:\n+               return new Period(jp.getText());\n+           }\n+           throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY, \"expected JSON Number or String\");\n+       }\n+   }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/JodaSerializers.java\n+package com.fasterxml.jackson.databind.ext;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import org.joda.time.*;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import org.codehaus.jackson.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n+import com.fasterxml.jackson.databind.util.Provider;\n+\n+/**\n+ * Provider for serializers that handle some basic data types\n+ * for <a href=\"http://joda-time.sourceforge.net/\">Joda</a> date/time library.\n+ *<p>\n+ * Since version 1.5, more types are supported. These types use slightly\n+ * different approach to serialization than core date types: \"timestamp\"\n+ * notation is implemented using JSON arrays, for improved readability.\n+ *\n+ * @since 1.4\n+ */\n+public class JodaSerializers\n+    implements Provider<Map.Entry<Class<?>,JsonSerializer<?>>>\n+{\n+    final static HashMap<Class<?>,JsonSerializer<?>> _serializers = new HashMap<Class<?>,JsonSerializer<?>>();\n+    static {\n+        _serializers.put(DateTime.class, new DateTimeSerializer());\n+        _serializers.put(LocalDateTime.class, new LocalDateTimeSerializer());\n+        _serializers.put(LocalDate.class, new LocalDateSerializer());\n+        _serializers.put(DateMidnight.class, new DateMidnightSerializer());\n+        // [JACKSON-706]:\n+        _serializers.put(Period.class, ToStringSerializer.instance);\n+    }\n+\n+    public JodaSerializers() { }\n+    \n+    @Override\n+    public Collection<Map.Entry<Class<?>,JsonSerializer<?>>> provide() {\n+        return _serializers.entrySet();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Intermediate base classes\n+    /**********************************************************\n+     */\n+\n+    protected abstract static class JodaSerializer<T> extends SerializerBase<T>\n+    {\n+        final static DateTimeFormatter _localDateTimeFormat = ISODateTimeFormat.dateTime();\n+        final static DateTimeFormatter _localDateFormat = ISODateTimeFormat.date();\n+\n+        protected JodaSerializer(Class<T> cls) { super(cls); }\n+\n+        protected String printLocalDateTime(ReadablePartial dateValue)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _localDateTimeFormat.print(dateValue);\n+        }\n+\n+        protected String printLocalDate(ReadablePartial dateValue)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _localDateFormat.print(dateValue);\n+        }\n+\n+        protected String printLocalDate(ReadableInstant dateValue)\n+            throws IOException, JsonProcessingException\n+        {\n+            return _localDateFormat.print(dateValue);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Concrete serializers\n+    /**********************************************************\n+     */\n+\n+    public final static class DateTimeSerializer\n+        extends JodaSerializer<DateTime>\n+    {\n+        public DateTimeSerializer() { super(DateTime.class); }\n+\n+        @Override\n+        public void serialize(DateTime value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            if (provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+                jgen.writeNumber(value.getMillis());\n+            } else {\n+                jgen.writeString(value.toString());\n+            }\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n+        {\n+            return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+                    ? \"number\" : \"string\", true);\n+        }\n+    }\n+ \n+    /**\n+     * \n+     * @since 1.5\n+     */\n+    public final static class LocalDateTimeSerializer\n+        extends JodaSerializer<LocalDateTime>\n+    {\n+        public LocalDateTimeSerializer() { super(LocalDateTime.class); }\n+    \n+        @Override\n+        public void serialize(LocalDateTime dt, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            if (provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+                // Timestamp here actually means an array of values\n+                jgen.writeStartArray();\n+                jgen.writeNumber(dt.year().get());\n+                jgen.writeNumber(dt.monthOfYear().get());\n+                jgen.writeNumber(dt.dayOfMonth().get());\n+                jgen.writeNumber(dt.hourOfDay().get());\n+                jgen.writeNumber(dt.minuteOfHour().get());\n+                jgen.writeNumber(dt.secondOfMinute().get());\n+                jgen.writeNumber(dt.millisOfSecond().get());\n+                jgen.writeEndArray();\n+            } else {\n+                jgen.writeString(printLocalDateTime(dt));\n+            }\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n+        {\n+            return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+                    ? \"array\" : \"string\", true);\n+        }\n+    }\n+\n+    public final static class LocalDateSerializer\n+        extends JodaSerializer<LocalDate>\n+    {\n+        public LocalDateSerializer() { super(LocalDate.class); }\n+    \n+        @Override\n+        public void serialize(LocalDate dt, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            if (provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+                // Timestamp here actually means an array of values\n+                jgen.writeStartArray();\n+                jgen.writeNumber(dt.year().get());\n+                jgen.writeNumber(dt.monthOfYear().get());\n+                jgen.writeNumber(dt.dayOfMonth().get());\n+                jgen.writeEndArray();\n+            } else {\n+                jgen.writeString(printLocalDate(dt));\n+            }\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n+        {\n+            return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+                    ? \"array\" : \"string\", true);\n+        }\n+    }\n+\n+    public final static class DateMidnightSerializer\n+        extends JodaSerializer<DateMidnight>\n+    {\n+        public DateMidnightSerializer() { super(DateMidnight.class); }\n+    \n+        @Override\n+        public void serialize(DateMidnight dt, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            if (provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+                // same as with other date-only values\n+                jgen.writeStartArray();\n+                jgen.writeNumber(dt.year().get());\n+                jgen.writeNumber(dt.monthOfYear().get());\n+                jgen.writeNumber(dt.dayOfMonth().get());\n+                jgen.writeEndArray();\n+            } else {\n+                jgen.writeString(printLocalDate(dt));\n+            }\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, java.lang.reflect.Type typeHint)\n+        {\n+            return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+                    ? \"array\" : \"string\", true);\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n+package com.fasterxml.jackson.databind.ext;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.util.Provider;\n+\n+/**\n+ * Helper class used for isolating details of handling optional+external types (Joda datetime,\n+ * javax.xml classes) from standard factories that offer them.\n+ * \n+ * @author tatu\n+ *\n+ * @since 1.6.1\n+ */\n+public class OptionalHandlerFactory\n+{\n+    /* 1.6.1+ To make 2 main \"optional\" handler groups (javax.xml.stream, Joda date/time)\n+     * more dynamic, we better only figure out handlers completely dynamically, if and\n+     * when they are needed. To do this we need to assume package prefixes.\n+     */\n+\n+    private final static String PACKAGE_PREFIX_JODA_DATETIME = \"org.joda.time.\";\n+    private final static String PACKAGE_PREFIX_JAVAX_XML = \"javax.xml.\";\n+\n+    private final static String SERIALIZERS_FOR_JODA_DATETIME = \"org.codehaus.jackson.map.ext.JodaSerializers\";\n+    private final static String SERIALIZERS_FOR_JAVAX_XML = \"org.codehaus.jackson.map.ext.CoreXMLSerializers\";\n+    private final static String DESERIALIZERS_FOR_JODA_DATETIME = \"org.codehaus.jackson.map.ext.JodaDeserializers\";\n+    private final static String DESERIALIZERS_FOR_JAVAX_XML = \"org.codehaus.jackson.map.ext.CoreXMLDeserializers\";\n+\n+    // Plus we also have a single serializer for DOM Node:\n+    private final static String CLASS_NAME_DOM_NODE = \"org.w3c.dom.Node\";\n+    private final static String CLASS_NAME_DOM_DOCUMENT = \"org.w3c.dom.Node\";\n+    private final static String SERIALIZER_FOR_DOM_NODE = \"org.codehaus.jackson.map.ext.DOMSerializer\";\n+    private final static String DESERIALIZER_FOR_DOM_DOCUMENT = \"org.codehaus.jackson.map.ext.DOMDeserializer$DocumentDeserializer\";\n+    private final static String DESERIALIZER_FOR_DOM_NODE = \"org.codehaus.jackson.map.ext.DOMDeserializer$NodeDeserializer\";\n+    \n+    public final static OptionalHandlerFactory instance = new OptionalHandlerFactory();\n+    \n+    protected OptionalHandlerFactory() { }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+    \n+    public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type)\n+//            BasicBeanDescription beanInfo, BeanProperty property)\n+    {\n+        Class<?> rawType = type.getRawClass();\n+        String className = rawType.getName();\n+        String factoryName;\n+        \n+        if (className.startsWith(PACKAGE_PREFIX_JODA_DATETIME)) {\n+            factoryName = SERIALIZERS_FOR_JODA_DATETIME;\n+        } else if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML)\n+                || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) {\n+            factoryName = SERIALIZERS_FOR_JAVAX_XML;\n+        } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) {\n+            return (JsonSerializer<?>) instantiate(SERIALIZER_FOR_DOM_NODE);\n+        } else {\n+            return null;\n+        }\n+\n+        Object ob = instantiate(factoryName);\n+        if (ob == null) { // could warn, if we had logging system (j.u.l?)\n+            return null;\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        Provider<Map.Entry<Class<?>,JsonSerializer<?>>> prov = (Provider<Map.Entry<Class<?>,JsonSerializer<?>>>) ob;\n+        Collection<Map.Entry<Class<?>,JsonSerializer<?>>> entries = prov.provide();\n+\n+        // first, check for exact match (concrete)\n+        for (Map.Entry<Class<?>,JsonSerializer<?>> entry : entries) {\n+            if (rawType == entry.getKey()) {\n+                return entry.getValue();\n+            }\n+        }\n+        // if no match, check super-type match\n+        for (Map.Entry<Class<?>,JsonSerializer<?>> entry : entries) {\n+            if (entry.getKey().isAssignableFrom(rawType)) {\n+                return entry.getValue();\n+            }\n+        }\n+        // but maybe there's just no match to be found?\n+        return null;\n+    }\n+\n+    public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config, DeserializerProvider p)\n+    {\n+        Class<?> rawType = type.getRawClass();\n+        String className = rawType.getName();\n+        String factoryName;\n+        \n+        if (className.startsWith(PACKAGE_PREFIX_JODA_DATETIME)) {\n+            factoryName = DESERIALIZERS_FOR_JODA_DATETIME;\n+        } else if (className.startsWith(PACKAGE_PREFIX_JAVAX_XML)\n+                || hasSupertypeStartingWith(rawType, PACKAGE_PREFIX_JAVAX_XML)) {\n+            factoryName = DESERIALIZERS_FOR_JAVAX_XML;\n+        } else if (doesImplement(rawType, CLASS_NAME_DOM_DOCUMENT)) {\n+            return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_DOCUMENT);\n+        } else if (doesImplement(rawType, CLASS_NAME_DOM_NODE)) {\n+            return (JsonDeserializer<?>) instantiate(DESERIALIZER_FOR_DOM_NODE);\n+        } else {\n+            return null;\n+        }\n+        Object ob = instantiate(factoryName);\n+        if (ob == null) { // could warn, if we had logging system (j.u.l?)\n+            return null;\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        Provider<StdDeserializer<?>> prov = (Provider<StdDeserializer<?>>) ob;\n+        Collection<StdDeserializer<?>> entries = prov.provide();\n+\n+        // first, check for exact match (concrete)\n+        for (StdDeserializer<?> deser : entries) {\n+            if (rawType == deser.getValueClass()) {\n+                return deser;\n+            }\n+        }\n+        // if no match, check super-type match\n+        for (StdDeserializer<?> deser : entries) {\n+            if (deser.getValueClass().isAssignableFrom(rawType)) {\n+                return deser;\n+            }\n+        }\n+        // but maybe there's just no match to be found?\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal helper methods\n+    /**********************************************************\n+     */\n+\n+    private Object instantiate(String className)\n+    {\n+        try {\n+            return Class.forName(className).newInstance();\n+        }\n+        catch (LinkageError e) { }\n+        // too many different kinds to enumerate here:\n+        catch (Exception e) { }\n+        return null;\n+    }\n+    \n+    private boolean doesImplement(Class<?> actualType, String classNameToImplement)\n+    {\n+        for (Class<?> type = actualType; type != null; type = type.getSuperclass()) {\n+            if (type.getName().equals(classNameToImplement)) {\n+                return true;\n+            }\n+            // or maybe one of super-interfaces\n+            if (hasInterface(type, classNameToImplement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+        \n+    private boolean hasInterface(Class<?> type, String interfaceToImplement)\n+    {\n+        Class<?>[] interfaces = type.getInterfaces();\n+        for (Class<?> iface : interfaces) {\n+            if (iface.getName().equals(interfaceToImplement)) {\n+                return true;\n+            }\n+        }\n+        // maybe super-interface?\n+        for (Class<?> iface : interfaces) {\n+            if (hasInterface(iface, interfaceToImplement)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean hasSupertypeStartingWith(Class<?> rawType, String prefix)\n+    {\n+        // first, superclasses\n+        for (Class<?> supertype = rawType.getSuperclass(); supertype != null; supertype = supertype.getSuperclass()) {\n+            if (supertype.getName().startsWith(prefix)) {\n+                return true;\n+            }\n+        }\n+        // then interfaces\n+        for (Class<?> cls = rawType; cls != null; cls = cls.getSuperclass()) {\n+            if (hasInterfaceStartingWith(cls, prefix)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean hasInterfaceStartingWith(Class<?> type, String prefix)\n+    {\n+        Class<?>[] interfaces = type.getInterfaces();\n+        for (Class<?> iface : interfaces) {\n+            if (iface.getName().startsWith(prefix)) {\n+                return true;\n+            }\n+        }\n+        // maybe super-interface?\n+        for (Class<?> iface : interfaces) {\n+            if (hasInterfaceStartingWith(iface, prefix)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/package-info.java\n+/**\n+Contains extended support for \"external\" packages: things that\n+may or may not be present in runtime environment, but that are\n+commonly enough used so that explicit support can be added.\n+<p>\n+Currently supported extensions include:\n+<ul>\n+ <li>Support for Java 1.5 core XML datatypes: the reason these are\n+considered \"external\" is that some platforms that claim to be 1.5 conformant\n+are only partially so (Google Android, GAE) and do not included these\n+ types.\n+  </li>\n+ <li>Joda time. This package has superior date/time handling functionality,\n+and is thus supported. However, to minimize forced dependencies this\n+support is added as extension so that Joda is not needed by Jackson\n+itself: but if it is present, its core types are supported to some\n+degree\n+  </li>\n+</ul>\n+\n+*/\n+\n+package com.fasterxml.jackson.databind.ext;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.type.TypeBindings;\n+\n+/**\n+ * Shared base class used for anything on which annotations (included\n+ * within a {@link AnnotationMap}).\n+ */\n+public abstract class Annotated\n+{\n+    protected Annotated() { }\n+    \n+    public abstract <A extends Annotation> A getAnnotation(Class<A> acls);\n+\n+    public final <A extends Annotation> boolean hasAnnotation(Class<A> acls)\n+    {\n+        return getAnnotation(acls) != null;\n+    }\n+\n+    /**\n+     * Fluent factory method that will construct a new instance that uses specified\n+     * instance annotations instead of currently configured ones.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract Annotated withAnnotations(AnnotationMap fallback);\n+\n+    /**\n+     * Fluent factory method that will construct a new instance that uses\n+     * annotations from specified {@link Annotated} as fallback annotations\n+     * \n+     * @since 1.9\n+     */\n+    public final Annotated withFallBackAnnotationsFrom(Annotated annotated) {\n+        return withAnnotations(AnnotationMap.merge(getAllAnnotations(), annotated.getAllAnnotations()));\n+    }\n+    \n+    /**\n+     * Method that can be used to find actual JDK element that this instance\n+     * represents. It is non-null, except for method/constructor parameters\n+     * which do not have a JDK counterpart.\n+     */\n+    public abstract AnnotatedElement getAnnotated();\n+\n+    protected abstract int getModifiers();\n+\n+    public final boolean isPublic() {\n+        return Modifier.isPublic(getModifiers());\n+    }\n+\n+    public abstract String getName();\n+\n+    /**\n+     * Full generic type of the annotated element; definition\n+     * of what exactly this means depends on sub-class.\n+     */\n+    public JavaType getType(TypeBindings context) {\n+        return context.resolveType(getGenericType());\n+    }\n+\n+    /**\n+     * Full generic type of the annotated element; definition\n+     * of what exactly this means depends on sub-class.\n+     * \n+     * @since 1.5\n+     */\n+    public abstract Type getGenericType();\n+\n+    /**\n+     * \"Raw\" type (type-erased class) of the annotated element; definition\n+     * of what exactly this means depends on sub-class.\n+     * \n+     * @since 1.5\n+     */\n+    public abstract Class<?> getRawType();\n+\n+    protected abstract AnnotationMap getAllAnnotations();\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.ClassIntrospector.MixInResolver;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+public final class AnnotatedClass\n+    extends Annotated\n+{\n+    private final static AnnotationMap[] NO_ANNOTATION_MAPS = new AnnotationMap[0];\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Class for which annotations apply, and that owns other\n+     * components (constructors, methods)\n+     */\n+    final protected Class<?> _class;\n+\n+    /**\n+     * Ordered set of super classes and interfaces of the\n+     * class itself: included in order of precedence\n+     */\n+    final protected List<Class<?>> _superTypes;\n+\n+    /**\n+     * Filter used to determine which annotations to gather; used\n+     * to optimize things so that unnecessary annotations are\n+     * ignored.\n+     */\n+    final protected AnnotationIntrospector _annotationIntrospector;\n+\n+    /**\n+     * Object that knows mapping of mix-in classes (ones that contain\n+     * annotations to add) with their target classes (ones that\n+     * get these additional annotations \"mixed in\").\n+     */\n+    final protected MixInResolver _mixInResolver;\n+\n+    /**\n+     * Primary mix-in class; one to use for the annotated class\n+     * itself. Can be null.\n+     */\n+    final protected Class<?> _primaryMixIn;\n+\n+    /*\n+    /**********************************************************\n+    /* Gathered information\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Combined list of Jackson annotations that the class has,\n+     * including inheritable ones from super classes and interfaces\n+     */\n+    protected AnnotationMap _classAnnotations;\n+\n+    /**\n+     * Default constructor of the annotated class, if it has one.\n+     */\n+    protected AnnotatedConstructor _defaultConstructor;\n+\n+    /**\n+     * Single argument constructors the class has, if any.\n+     */\n+    protected List<AnnotatedConstructor> _constructors;\n+\n+    /**\n+     * Single argument static methods that might be usable\n+     * as factory methods\n+     */\n+    protected List<AnnotatedMethod> _creatorMethods;\n+\n+    /**\n+     * Member methods of interest; for now ones with 0 or 1 arguments\n+     * (just optimization, since others won't be used now)\n+     */\n+    protected AnnotatedMethodMap  _memberMethods;\n+\n+    /**\n+     * Member fields of interest: ones that are either public,\n+     * or have at least one annotation.\n+     */\n+    protected List<AnnotatedField> _fields;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor will not do any initializations, to allow for\n+     * configuring instances differently depending on use cases\n+     */\n+    private AnnotatedClass(Class<?> cls, List<Class<?>> superTypes,\n+            AnnotationIntrospector aintr, MixInResolver mir,\n+            AnnotationMap classAnnotations)\n+    {\n+        _class = cls;\n+        _superTypes = superTypes;\n+        _annotationIntrospector = aintr;\n+        _mixInResolver = mir;\n+        _primaryMixIn = (_mixInResolver == null) ? null\n+            : _mixInResolver.findMixInClassFor(_class);\n+        _classAnnotations = classAnnotations;\n+    }\n+\n+    @Override\n+    public AnnotatedClass withAnnotations(AnnotationMap ann) {\n+        return new AnnotatedClass(_class, _superTypes,\n+                _annotationIntrospector, _mixInResolver, ann);\n+    }\n+    \n+    /**\n+     * Factory method that instantiates an instance. Returned instance\n+     * will only be initialized with class annotations, but not with\n+     * any method information.\n+     */\n+    public static AnnotatedClass construct(Class<?> cls,\n+            AnnotationIntrospector aintr, MixInResolver mir)\n+    {\n+        List<Class<?>> st = ClassUtil.findSuperTypes(cls, null);\n+        AnnotatedClass ac = new AnnotatedClass(cls, st, aintr, mir, null);\n+        ac.resolveClassAnnotations();\n+        return ac;\n+    }\n+\n+    /**\n+     * Method similar to {@link #construct}, but that will NOT include\n+     * information from supertypes; only class itself and any direct\n+     * mix-ins it may have.\n+     */\n+    public static AnnotatedClass constructWithoutSuperTypes(Class<?> cls,\n+            AnnotationIntrospector aintr, MixInResolver mir)\n+    {\n+        List<Class<?>> empty = Collections.emptyList();\n+        AnnotatedClass ac = new AnnotatedClass(cls, empty, aintr, mir, null);\n+        ac.resolveClassAnnotations();\n+        return ac;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Annotated impl \n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Class<?> getAnnotated() { return _class; }\n+\n+    @Override\n+    public int getModifiers() { return _class.getModifiers(); }\n+\n+    @Override\n+    public String getName() { return _class.getName(); }\n+\n+    @Override\n+    public <A extends Annotation> A getAnnotation(Class<A> acls)\n+    {\n+        if (_classAnnotations == null) {\n+            return null;\n+        }\n+        return _classAnnotations.get(acls);\n+    }\n+\n+    @Override\n+    public Type getGenericType() {\n+        return _class;\n+    }\n+\n+    @Override\n+    public Class<?> getRawType() {\n+        return _class;\n+    }\n+\n+    @Override\n+    protected AnnotationMap getAllAnnotations() {\n+        return _classAnnotations;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, generic accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @return 1.7\n+     */\n+    public Annotations getAnnotations() { return _classAnnotations; }\n+    \n+    public boolean hasAnnotations() { return _classAnnotations.size() > 0; }\n+\n+    public AnnotatedConstructor getDefaultConstructor() { return _defaultConstructor; }\n+\n+    public List<AnnotatedConstructor> getConstructors()\n+    {\n+        if (_constructors == null) {\n+            return Collections.emptyList();\n+        }\n+        return _constructors;\n+    }\n+\n+    public List<AnnotatedMethod> getStaticMethods()\n+    {\n+        if (_creatorMethods == null) {\n+            return Collections.emptyList();\n+        }\n+        return _creatorMethods;\n+    }\n+\n+    public Iterable<AnnotatedMethod> memberMethods()\n+    {\n+        return _memberMethods;\n+    }\n+\n+    public int getMemberMethodCount()\n+    {\n+        return _memberMethods.size();\n+    }\n+\n+    public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes)\n+    {\n+        return _memberMethods.find(name, paramTypes);\n+    }\n+\n+    public int getFieldCount() {\n+        return (_fields == null) ? 0 : _fields.size();\n+    }\n+\n+    public Iterable<AnnotatedField> fields()\n+    {\n+        if (_fields == null) {\n+            return Collections.emptyList();\n+        }\n+        return _fields;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, main-level resolution methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Initialization method that will recursively collect Jackson\n+     * annotations for this class and all super classes and\n+     * interfaces.\n+     *<p>\n+     * Starting with 1.2, it will also apply mix-in annotations,\n+     * as per [JACKSON-76]\n+     */\n+    public void resolveClassAnnotations()\n+    {\n+        _classAnnotations = new AnnotationMap();\n+        // [JACKSON-659] Should skip processing if annotation processing disabled\n+        if (_annotationIntrospector == null) {\n+            return;\n+        }\n+        \n+        // add mix-in annotations first (overrides)\n+        if (_primaryMixIn != null) {\n+            _addClassMixIns(_classAnnotations, _class, _primaryMixIn);\n+        }\n+        // first, annotations from the class itself:\n+        for (Annotation a : _class.getDeclaredAnnotations()) {\n+            if (_annotationIntrospector.isHandled(a)) {\n+                _classAnnotations.addIfNotPresent(a);\n+            }\n+        }\n+\n+        // and then from super types\n+        for (Class<?> cls : _superTypes) {\n+            // and mix mix-in annotations in-between\n+            _addClassMixIns(_classAnnotations, cls);\n+            for (Annotation a : cls.getDeclaredAnnotations()) {\n+                if (_annotationIntrospector.isHandled(a)) {\n+                    _classAnnotations.addIfNotPresent(a);\n+                }\n+            }\n+        }\n+\n+        /* and finally... any annotations there might be for plain\n+         * old Object.class: separate because for all other purposes\n+         * it is just ignored (not included in super types)\n+         */\n+        /* 12-Jul-2009, tatu: Should this be done for interfaces too?\n+         *   For now, yes, seems useful for some cases, and not harmful\n+         *   for any?\n+         */\n+        _addClassMixIns(_classAnnotations, Object.class);\n+    }\n+\n+    /**\n+     * Initialization method that will find out all constructors\n+     * and potential static factory methods the class has.\n+     *<p>\n+     * Starting with 1.2, it will also apply mix-in annotations,\n+     * as per [JACKSON-76]\n+     *\n+     * @param includeAll If true, includes all creator methods; if false,\n+     *   will only include the no-arguments \"default\" constructor\n+     */\n+    public void resolveCreators(boolean includeAll)\n+    {\n+        // Then see which constructors we have\n+        _constructors = null;\n+        Constructor<?>[] declaredCtors = _class.getDeclaredConstructors();\n+        for (Constructor<?> ctor : declaredCtors) {\n+            if (ctor.getParameterTypes().length == 0) {\n+                _defaultConstructor = _constructConstructor(ctor, true);\n+            } else {\n+                if (includeAll) {\n+                    if (_constructors == null) {\n+                        _constructors = new ArrayList<AnnotatedConstructor>(Math.max(10, declaredCtors.length));\n+                    }\n+                    _constructors.add(_constructConstructor(ctor, false));\n+                }\n+            }\n+        }\n+        // and if need be, augment with mix-ins\n+        if (_primaryMixIn != null) {\n+            if (_defaultConstructor != null || _constructors != null) {\n+                _addConstructorMixIns(_primaryMixIn);\n+            }\n+        }\n+\n+\n+        /* And then... let's remove all constructors that are deemed\n+         * ignorable after all annotations have been properly collapsed.\n+         */\n+        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n+        if (_annotationIntrospector != null) {\n+            if (_defaultConstructor != null) {\n+                if (_annotationIntrospector.isIgnorableConstructor(_defaultConstructor)) {\n+                    _defaultConstructor = null;\n+                }\n+            }\n+            if (_constructors != null) {\n+                // count down to allow safe removal\n+                for (int i = _constructors.size(); --i >= 0; ) {\n+                    if (_annotationIntrospector.isIgnorableConstructor(_constructors.get(i))) {\n+                        _constructors.remove(i);\n+                    }\n+                }\n+            }\n+        }\n+\n+        _creatorMethods = null;\n+        \n+        if (includeAll) {\n+            // Then static methods which are potential factory methods\n+            for (Method m : _class.getDeclaredMethods()) {\n+                if (!Modifier.isStatic(m.getModifiers())) {\n+                    continue;\n+                }\n+                int argCount = m.getParameterTypes().length;\n+                // factory methods take at least one arg:\n+                if (argCount < 1) {\n+                    continue;\n+                }\n+                if (_creatorMethods == null) {\n+                    _creatorMethods = new ArrayList<AnnotatedMethod>(8);\n+                }\n+                _creatorMethods.add(_constructCreatorMethod(m));\n+            }\n+            // mix-ins to mix in?\n+            if (_primaryMixIn != null && _creatorMethods != null) {\n+                _addFactoryMixIns(_primaryMixIn);\n+            }\n+            // anything to ignore at this point?\n+            if (_annotationIntrospector != null) {\n+                if (_creatorMethods != null) {\n+                    // count down to allow safe removal\n+                    for (int i = _creatorMethods.size(); --i >= 0; ) {\n+                        if (_annotationIntrospector.isIgnorableMethod(_creatorMethods.get(i))) {\n+                            _creatorMethods.remove(i);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Method for resolving member method information: aggregating all non-static methods\n+     * and combining annotations (to implement method-annotation inheritance)\n+     * \n+     * @param methodFilter Filter used to determine which methods to include\n+     * \n+     * @since 1.9\n+     */\n+    public void resolveMemberMethods(MethodFilter methodFilter)\n+    {\n+        _memberMethods = new AnnotatedMethodMap();\n+        AnnotatedMethodMap mixins = new AnnotatedMethodMap();\n+        // first: methods from the class itself\n+        _addMemberMethods(_class, methodFilter, _memberMethods, _primaryMixIn, mixins);\n+\n+        // and then augment these with annotations from super-types:\n+        for (Class<?> cls : _superTypes) {\n+            Class<?> mixin = (_mixInResolver == null) ? null : _mixInResolver.findMixInClassFor(cls);\n+            _addMemberMethods(cls, methodFilter, _memberMethods, mixin, mixins);\n+        }\n+        // Special case: mix-ins for Object.class? (to apply to ALL classes)\n+        if (_mixInResolver != null) {\n+            Class<?> mixin = _mixInResolver.findMixInClassFor(Object.class);\n+            if (mixin != null) {\n+                _addMethodMixIns(methodFilter, _memberMethods, mixin, mixins);\n+            }\n+        }\n+\n+        /* Any unmatched mix-ins? Most likely error cases (not matching\n+         * any method); but there is one possible real use case:\n+         * exposing Object#hashCode (alas, Object#getClass can NOT be\n+         * exposed, see [JACKSON-140])\n+         */\n+        // 14-Feb-2011, tatu: AnnotationIntrospector is null if annotations not enabled; if so, can skip:\n+        if (_annotationIntrospector != null) {\n+            if (!mixins.isEmpty()) {\n+                Iterator<AnnotatedMethod> it = mixins.iterator();\n+                while (it.hasNext()) {\n+                    AnnotatedMethod mixIn = it.next();\n+                    try {\n+                        Method m = Object.class.getDeclaredMethod(mixIn.getName(), mixIn.getParameterClasses());\n+                        if (m != null) {\n+                            AnnotatedMethod am = _constructMethod(m);\n+                            _addMixOvers(mixIn.getAnnotated(), am, false);\n+                            _memberMethods.add(am);\n+                        }\n+                    } catch (Exception e) { }\n+                }\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Method that will collect all member (non-static) fields\n+     * that are either public, or have at least a single annotation\n+     * associated with them.\n+     * \n+     * @since 1.9\n+     */\n+    public void resolveFields()\n+    {\n+        LinkedHashMap<String,AnnotatedField> foundFields = new LinkedHashMap<String,AnnotatedField>();\n+        _addFields(foundFields, _class);\n+        if (foundFields.isEmpty()) {\n+            _fields = Collections.emptyList();\n+        } else {\n+            _fields = new ArrayList<AnnotatedField>(foundFields.size());\n+            _fields.addAll(foundFields.values());\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deprecated methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @since 1.9 Use version without arguments\n+     */\n+    @Deprecated\n+    public void resolveMemberMethods(MethodFilter methodFilter, boolean collectIgnored)\n+    {\n+        resolveMemberMethods(methodFilter);\n+    }\n+    \n+    /**\n+     * @since 1.9 Use version without arguments\n+     */\n+    @Deprecated\n+    public void resolveFields(boolean collectIgnored)\n+    {\n+        resolveFields();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods for resolving class annotations\n+    /* (resolution consisting of inheritance, overrides,\n+    /* and injection of mix-ins as necessary)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method for adding any mix-in annotations specified\n+     * class might have.\n+     */\n+    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask)\n+    {\n+        if (_mixInResolver != null) {\n+            _addClassMixIns(annotations, toMask, _mixInResolver.findMixInClassFor(toMask));\n+        }\n+    }\n+\n+    protected void _addClassMixIns(AnnotationMap annotations, Class<?> toMask,\n+                                   Class<?> mixin)\n+    {\n+        if (mixin == null) {\n+            return;\n+        }\n+        // Ok, first: annotations from mix-in class itself:\n+        for (Annotation a : mixin.getDeclaredAnnotations()) {\n+            if (_annotationIntrospector.isHandled(a)) {\n+                annotations.addIfNotPresent(a);\n+            }\n+        }\n+        /* And then from its supertypes, if any. But note that we will\n+         *  only consider super-types up until reaching the masked\n+         * class (if found); this because often mix-in class\n+         * is a sub-class (for convenience reasons). And if so, we\n+         * absolutely must NOT include super types of masked class,\n+         * as that would inverse precedence of annotations.\n+         */\n+        for (Class<?> parent : ClassUtil.findSuperTypes(mixin, toMask)) {\n+            for (Annotation a : parent.getDeclaredAnnotations()) {\n+                if (_annotationIntrospector.isHandled(a)) {\n+                    annotations.addIfNotPresent(a);\n+                }\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for populating creator (ctor, factory) information\n+    /**********************************************************\n+     */\n+\n+    protected void _addConstructorMixIns(Class<?> mixin)\n+    {\n+        MemberKey[] ctorKeys = null;\n+        int ctorCount = (_constructors == null) ? 0 : _constructors.size();\n+        for (Constructor<?> ctor : mixin.getDeclaredConstructors()) {\n+            if (ctor.getParameterTypes().length == 0) {\n+                if (_defaultConstructor != null) {\n+                    _addMixOvers(ctor, _defaultConstructor, false);\n+                }\n+            } else {\n+                if (ctorKeys == null) {\n+                    ctorKeys = new MemberKey[ctorCount];\n+                    for (int i = 0; i < ctorCount; ++i) {\n+                        ctorKeys[i] = new MemberKey(_constructors.get(i).getAnnotated());\n+                    }\n+                }\n+                MemberKey key = new MemberKey(ctor);\n+\n+                for (int i = 0; i < ctorCount; ++i) {\n+                    if (!key.equals(ctorKeys[i])) {\n+                        continue;\n+                    }\n+                    _addMixOvers(ctor, _constructors.get(i), true);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void _addFactoryMixIns(Class<?> mixin)\n+    {\n+        MemberKey[] methodKeys = null;\n+        int methodCount = _creatorMethods.size();\n+\n+        for (Method m : mixin.getDeclaredMethods()) {\n+            if (!Modifier.isStatic(m.getModifiers())) {\n+                continue;\n+            }\n+            if (m.getParameterTypes().length == 0) {\n+                continue;\n+            }\n+            if (methodKeys == null) {\n+                methodKeys = new MemberKey[methodCount];\n+                for (int i = 0; i < methodCount; ++i) {\n+                    methodKeys[i] = new MemberKey(_creatorMethods.get(i).getAnnotated());\n+                }\n+            }\n+            MemberKey key = new MemberKey(m);\n+            for (int i = 0; i < methodCount; ++i) {\n+                if (!key.equals(methodKeys[i])) {\n+                    continue;\n+                }\n+                _addMixOvers(m, _creatorMethods.get(i), true);\n+                break;\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for populating method information\n+    /**********************************************************\n+     */\n+\n+    protected void _addMemberMethods(Class<?> cls,\n+            MethodFilter methodFilter, AnnotatedMethodMap methods,\n+            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n+    {\n+        // first, mixIns, since they have higher priority then class methods\n+        if (mixInCls != null) {\n+            _addMethodMixIns(methodFilter, methods, mixInCls, mixIns);\n+        }\n+\n+        if (cls == null) { // just so caller need not check when passing super-class\n+            return;\n+        }\n+        // then methods from the class itself\n+        for (Method m : cls.getDeclaredMethods()) {\n+            if (!_isIncludableMethod(m, methodFilter)) {\n+                continue;\n+            }\n+            AnnotatedMethod old = methods.find(m);\n+            if (old == null) {\n+                AnnotatedMethod newM = _constructMethod(m);\n+                methods.add(newM);\n+                // Ok, but is there a mix-in to connect now?\n+                old = mixIns.remove(m);\n+                if (old != null) {\n+                    _addMixOvers(old.getAnnotated(), newM, false);\n+                }\n+            } else {\n+                /* If sub-class already has the method, we only want to augment\n+                 * annotations with entries that are not masked by sub-class.\n+                 */\n+                _addMixUnders(m, old);\n+\n+                /* 06-Jan-2010, tatu: [JACKSON-450] Except that if method we saw first is\n+                 *   from an interface, and we now find a non-interface definition, we should\n+                 *   use this method, but with combination of annotations.\n+                 *   This helps (or rather, is essential) with JAXB annotations and\n+                 *   may also result in faster method calls (interface calls are slightly\n+                 *   costlier than regular method calls)\n+                 */\n+                if (old.getDeclaringClass().isInterface() && !m.getDeclaringClass().isInterface()) {\n+                    methods.add(old.withMethod(m));\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void _addMethodMixIns(MethodFilter methodFilter, AnnotatedMethodMap methods,\n+            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n+    {\n+        for (Method m : mixInCls.getDeclaredMethods()) {\n+            if (!_isIncludableMethod(m, methodFilter)) {\n+                continue;\n+            }\n+            AnnotatedMethod am = methods.find(m);\n+            /* Do we already have a method to augment (from sub-class\n+             * that will mask this mixIn)? If so, add if visible\n+             * without masking (no such annotation)\n+             */\n+            if (am != null) {\n+                _addMixUnders(m, am);\n+                /* Otherwise will have precedence, but must wait\n+                 * until we find the real method (mixIn methods are\n+                 * just placeholder, can't be called)\n+                 */\n+            } else {\n+                mixIns.add(_constructMethod(m));\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for populating field information\n+    /**********************************************************\n+     */\n+\n+    protected void _addFields(Map<String,AnnotatedField> fields, Class<?> c)\n+    {\n+        /* First, a quick test: we only care for regular classes (not\n+         * interfaces, primitive types etc), except for Object.class.\n+         * A simple check to rule out other cases is to see if there\n+         * is a super class or not.\n+         */\n+        Class<?> parent = c.getSuperclass();\n+        if (parent != null) {\n+            // Let's add super-class' fields first, then ours.\n+            /* 21-Feb-2010, tatu: Need to handle masking: as per [JACKSON-226]\n+             *    we otherwise get into trouble...\n+             */\n+            _addFields(fields, parent);\n+            for (Field f : c.getDeclaredFields()) {\n+                // static fields not included, nor transient\n+                if (!_isIncludableField(f)) {\n+                    continue;\n+                }\n+                /* Ok now: we can (and need) not filter out ignorable fields\n+                 * at this point; partly because mix-ins haven't been\n+                 * added, and partly because logic can be done when\n+                 * determining get/settability of the field.\n+                 */\n+                fields.put(f.getName(), _constructField(f));\n+            }\n+            // And then... any mix-in overrides?\n+            if (_mixInResolver != null) {\n+                Class<?> mixin = _mixInResolver.findMixInClassFor(c);\n+                if (mixin != null) {\n+                    _addFieldMixIns(mixin, fields);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method called to add field mix-ins from given mix-in class (and its fields)\n+     * into already collected actual fields (from introspected classes and their\n+     * super-classes)\n+     */\n+    protected void _addFieldMixIns(Class<?> mixin, Map<String,AnnotatedField> fields)\n+    {\n+        for (Field mixinField : mixin.getDeclaredFields()) {\n+            /* there are some dummy things (static, synthetic); better\n+             * ignore\n+             */\n+            if (!_isIncludableField(mixinField)) {\n+                continue;\n+            }\n+            String name = mixinField.getName();\n+            // anything to mask? (if not, quietly ignore)\n+            AnnotatedField maskedField = fields.get(name);\n+            if (maskedField != null) {\n+                for (Annotation a : mixinField.getDeclaredAnnotations()) {\n+                    if (_annotationIntrospector.isHandled(a)) {\n+                        maskedField.addOrOverride(a);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, constructing value types\n+    /**********************************************************\n+     */\n+\n+    protected AnnotatedMethod _constructMethod(Method m)\n+    {\n+        /* note: parameter annotations not used for regular (getter, setter)\n+         * methods; only for creator methods (static factory methods)\n+         * -- at least not yet!\n+         */\n+        if (_annotationIntrospector == null) { // when annotation processing is disabled\n+            return new AnnotatedMethod(m, _emptyAnnotationMap(), null);\n+        }\n+        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()), null);\n+    }\n+\n+    protected AnnotatedConstructor _constructConstructor(Constructor<?> ctor, boolean defaultCtor)\n+    {\n+        if (_annotationIntrospector == null) { // when annotation processing is disabled\n+            return new AnnotatedConstructor(ctor, _emptyAnnotationMap(), _emptyAnnotationMaps(ctor.getParameterTypes().length));\n+        }\n+        if (defaultCtor) {\n+            return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()), null);\n+        }\n+        Annotation[][] paramAnns = ctor.getParameterAnnotations();\n+        int paramCount = ctor.getParameterTypes().length;\n+        /* [JACKSON-701]: Looks like JDK has discrepancy, whereas annotations for implicit 'this'\n+         * (for non-static inner classes) are NOT included, but type is? Strange, sounds like\n+         * a bug. Alas, we can't really fix that...\n+         */\n+        AnnotationMap[] resolvedAnnotations;\n+        if (paramCount != paramAnns.length) {\n+            // only cover one \"missing\" annotation, and only for member classes; to try to avoid\n+            // false \"fixes\" for possible other error cases\n+            if (ctor.getDeclaringClass().isMemberClass() &&  paramCount == (paramAnns.length + 1)) {\n+                // hack attack: prepend a null entry to make things match\n+                Annotation[][] old = paramAnns;\n+                paramAnns = new Annotation[old.length+1][];\n+                System.arraycopy(old, 0, paramAnns, 1, old.length);\n+                resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n+            } else {\n+                throw new IllegalStateException(\"Internal error: constructor for \"+ctor.getDeclaringClass().getName()\n+                        +\" has mismatch: \"+paramCount+\" parameters; \"+paramAnns.length+\" sets of annotations\");\n+            }\n+        } else {\n+            resolvedAnnotations = _collectRelevantAnnotations(paramAnns);\n+        }\n+        return new AnnotatedConstructor(ctor, _collectRelevantAnnotations(ctor.getDeclaredAnnotations()),\n+                resolvedAnnotations);\n+    }\n+\n+    protected AnnotatedMethod _constructCreatorMethod(Method m)\n+    {\n+        if (_annotationIntrospector == null) { // when annotation processing is disabled\n+            return new AnnotatedMethod(m, _emptyAnnotationMap(), _emptyAnnotationMaps(m.getParameterTypes().length));\n+        }\n+        return new AnnotatedMethod(m, _collectRelevantAnnotations(m.getDeclaredAnnotations()),\n+                                   _collectRelevantAnnotations(m.getParameterAnnotations()));\n+    }\n+\n+    protected AnnotatedField _constructField(Field f)\n+    {\n+        if (_annotationIntrospector == null) { // when annotation processing is disabled\n+            return new AnnotatedField(f, _emptyAnnotationMap());\n+        }\n+        return new AnnotatedField(f, _collectRelevantAnnotations(f.getDeclaredAnnotations()));\n+    }\n+\n+    protected AnnotationMap[] _collectRelevantAnnotations(Annotation[][] anns)\n+    {\n+        int len = anns.length;\n+        AnnotationMap[] result = new AnnotationMap[len];\n+        for (int i = 0; i < len; ++i) {\n+            result[i] = _collectRelevantAnnotations(anns[i]);\n+        }\n+        return result;\n+    }\n+\n+    protected AnnotationMap _collectRelevantAnnotations(Annotation[] anns)\n+    {\n+        AnnotationMap annMap = new AnnotationMap();\n+        if (anns != null) {\n+            for (Annotation a : anns) {\n+                if (_annotationIntrospector.isHandled(a)) {\n+                    annMap.add(a);\n+                }\n+            }\n+        }\n+        return annMap;\n+    }\n+ \n+    private AnnotationMap _emptyAnnotationMap() {\n+        return new AnnotationMap();\n+    }\n+\n+    private AnnotationMap[] _emptyAnnotationMaps(int count) {\n+        if (count == 0) {\n+            return NO_ANNOTATION_MAPS;\n+        }\n+        AnnotationMap[] maps = new AnnotationMap[count];\n+        for (int i = 0; i < count; ++i) {\n+            maps[i] = _emptyAnnotationMap();\n+        }\n+        return maps;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods, inclusion filtering\n+    /**********************************************************\n+     */\n+\n+    protected boolean _isIncludableMethod(Method m, MethodFilter filter)\n+    {\n+        if (filter != null && !filter.includeMethod(m)) {\n+            return false;\n+        }\n+        /* 07-Apr-2009, tatu: Looks like generics can introduce hidden\n+         *   bridge and/or synthetic methods. I don't think we want to\n+         *   consider those...\n+         */\n+        if (m.isSynthetic() || m.isBridge()) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private boolean _isIncludableField(Field f)\n+    {\n+        /* I'm pretty sure synthetic fields are to be skipped...\n+         * (methods definitely are)\n+         */\n+        if (f.isSynthetic()) {\n+            return false;\n+        }\n+        // Static fields are never included, nor transient\n+        int mods = f.getModifiers();\n+        if (Modifier.isStatic(mods) || Modifier.isTransient(mods)) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods, attaching annotations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @param addParamAnnotations Whether parameter annotations are to be\n+     *   added as well\n+     */\n+    protected void _addMixOvers(Constructor<?> mixin, AnnotatedConstructor target,\n+            boolean addParamAnnotations)\n+    {\n+        for (Annotation a : mixin.getDeclaredAnnotations()) {\n+            if (_annotationIntrospector.isHandled(a)) {\n+                target.addOrOverride(a);\n+            }\n+        }\n+        if (addParamAnnotations) {\n+            Annotation[][] pa = mixin.getParameterAnnotations();\n+            for (int i = 0, len = pa.length; i < len; ++i) {\n+                for (Annotation a : pa[i]) {\n+                    target.addOrOverrideParam(i, a);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @param addParamAnnotations Whether parameter annotations are to be\n+     *   added as well\n+     */\n+    protected void _addMixOvers(Method mixin, AnnotatedMethod target,\n+            boolean addParamAnnotations)\n+    {\n+        for (Annotation a : mixin.getDeclaredAnnotations()) {\n+            if (_annotationIntrospector.isHandled(a)) {\n+                target.addOrOverride(a);\n+            }\n+        }\n+        if (addParamAnnotations) {\n+            Annotation[][] pa = mixin.getParameterAnnotations();\n+            for (int i = 0, len = pa.length; i < len; ++i) {\n+                for (Annotation a : pa[i]) {\n+                    target.addOrOverrideParam(i, a);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method that will add annotations from specified source method to target method,\n+     * but only if target does not yet have them.\n+     */\n+    protected void _addMixUnders(Method src, AnnotatedMethod target)\n+    {\n+        for (Annotation a : src.getDeclaredAnnotations()) {\n+            if (_annotationIntrospector.isHandled(a)) {\n+                target.addIfNotPresent(a);\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Other methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"[AnnotedClass \"+_class.getName()+\"]\";\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedConstructor.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.type.TypeBindings;\n+\n+public final class AnnotatedConstructor\n+    extends AnnotatedWithParams\n+{\n+    protected final Constructor<?> _constructor;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public AnnotatedConstructor(Constructor<?> constructor,\n+            AnnotationMap classAnn, AnnotationMap[] paramAnn)\n+    {\n+        super(classAnn, paramAnn);\n+        if (constructor == null) {\n+            throw new IllegalArgumentException(\"Null constructor not allowed\");\n+        }\n+        _constructor = constructor;\n+    }\n+\n+    @Override\n+    public AnnotatedConstructor withAnnotations(AnnotationMap ann) {\n+        return new AnnotatedConstructor(_constructor, ann, _paramAnnotations);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Annotated impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Constructor<?> getAnnotated() { return _constructor; }\n+\n+    @Override\n+    public int getModifiers() { return _constructor.getModifiers(); }\n+\n+    @Override\n+    public String getName() { return _constructor.getName(); }\n+\n+    @Override\n+    public Type getGenericType() {\n+        return getRawType();\n+    }\n+\n+    @Override\n+    public Class<?> getRawType() {\n+        return _constructor.getDeclaringClass();\n+    }\n+\n+    // note: copied verbatim from AnnotatedMethod; hard to generalize\n+    /**\n+     * As per [JACKSON-468], we need to also allow declaration of local\n+     * type bindings; mostly it will allow defining bounds.\n+     */\n+    @Override\n+    public JavaType getType(TypeBindings bindings)\n+    {\n+        return getType(bindings, _constructor.getTypeParameters());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public int getParameterCount() {\n+        return _constructor.getParameterTypes().length;\n+    }\n+\n+    @Override\n+    public Class<?> getParameterClass(int index)\n+    {\n+        Class<?>[] types = _constructor.getParameterTypes();\n+        return (index >= types.length) ? null : types[index];\n+    }\n+\n+    @Override\n+    public Type getParameterType(int index)\n+    {\n+        Type[] types = _constructor.getGenericParameterTypes();\n+        return (index >= types.length) ? null : types[index];\n+    }\n+\n+    @Override\n+    public final Object call() throws Exception {\n+        return _constructor.newInstance();\n+    }\n+\n+    @Override\n+    public final Object call(Object[] args) throws Exception {\n+        return _constructor.newInstance(args);\n+    }\n+\n+    @Override\n+    public final Object call1(Object arg) throws Exception {\n+        return _constructor.newInstance(arg);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* AnnotatedMember impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Class<?> getDeclaringClass() { return _constructor.getDeclaringClass(); }\n+\n+    @Override\n+    public Member getMember() { return _constructor; }\n+\n+    @Override\n+    public void setValue(Object pojo, Object value)\n+        throws UnsupportedOperationException\n+    {\n+        throw new UnsupportedOperationException(\"Cannot call setValue() on constructor of \"\n+                +getDeclaringClass().getName());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API, specific annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString() {\n+        return \"[constructor for \"+getName()+\", annotations: \"+_annotations+\"]\";\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedField.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Object that represents non-static (and usually non-transient/volatile)\n+ * fields of a class.\n+ * \n+ * @author tatu\n+ */\n+public final class AnnotatedField\n+    extends AnnotatedMember\n+{\n+    protected final Field _field;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public AnnotatedField(Field field, AnnotationMap annMap)\n+    {\n+        super(annMap);\n+        _field = field;\n+    }\n+\n+    @Override\n+    public AnnotatedField withAnnotations(AnnotationMap ann) {\n+        return new AnnotatedField(_field, ann);\n+    }\n+    \n+    /**\n+     * Method called to override an annotation, usually due to a mix-in\n+     * annotation masking or overriding an annotation 'real' constructor\n+     * has.\n+     */\n+    public void addOrOverride(Annotation a)\n+    {\n+        _annotations.add(a);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Annotated impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Field getAnnotated() { return _field; }\n+\n+    @Override\n+    public int getModifiers() { return _field.getModifiers(); }\n+\n+    @Override\n+    public String getName() { return _field.getName(); }\n+\n+    @Override\n+    public <A extends Annotation> A getAnnotation(Class<A> acls)\n+    {\n+        return _annotations.get(acls);\n+    }\n+\n+    @Override\n+    public Type getGenericType() {\n+        return _field.getGenericType();\n+    }\n+\n+    @Override\n+    public Class<?> getRawType() {\n+        return _field.getType();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* AnnotatedMember impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Class<?> getDeclaringClass() { return _field.getDeclaringClass(); }\n+\n+    @Override\n+    public Member getMember() { return _field; }\n+\n+    @Override\n+    public void setValue(Object pojo, Object value)\n+        throws IllegalArgumentException\n+    {\n+        try {\n+            _field.set(pojo, value);\n+        } catch (IllegalAccessException e) {\n+            throw new IllegalArgumentException(\"Failed to setValue() for field \"\n+                    +getFullName()+\": \"+e.getMessage(), e);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API, generic\n+    /**********************************************************\n+     */\n+\n+    public String getFullName() {\n+        return getDeclaringClass().getName() + \"#\" + getName();\n+    }\n+\n+    public int getAnnotationCount() { return _annotations.size(); }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"[field \"+getName()+\", annotations: \"+_annotations+\"]\";\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.reflect.Member;\n+\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+/**\n+ * Intermediate base class for annotated entities that are members of\n+ * a class; fields, methods and constructors. This is a superset\n+ * of things that can represent logical properties as it contains\n+ * constructors in addition to fields and methods.\n+ * \n+ * @author tatu\n+ * @since 1.5\n+ */\n+public abstract class AnnotatedMember extends Annotated\n+{\n+    protected final AnnotationMap _annotations;\n+\n+    protected AnnotatedMember(AnnotationMap annotations) {\n+        super();\n+        _annotations = annotations;\n+    }\n+\n+    public abstract Class<?> getDeclaringClass();\n+\n+    public abstract Member getMember();\n+\n+    @Override\n+    protected AnnotationMap getAllAnnotations() {\n+        return _annotations;\n+    }\n+    \n+    /**\n+     * Method that can be called to modify access rights, by calling\n+     * {@link java.lang.reflect.AccessibleObject#setAccessible} on\n+     * the underlying annotated element.\n+     */\n+    public final void fixAccess() {\n+        ClassUtil.checkAndFixAccess(getMember());\n+    }\n+\n+    /**\n+     * Optional method that can be used to assign value of\n+     * this member on given object, if this is a supported\n+     * operation for member type.\n+     *<p>\n+     * This is implemented for fiedlds and single-argument\n+     * methods; but not for constructor parameters or\n+     * other types of methods.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract void setValue(Object pojo, Object value)\n+        throws UnsupportedOperationException, IllegalArgumentException;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethod.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.reflect.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.type.TypeBindings;\n+\n+public final class AnnotatedMethod\n+    extends AnnotatedWithParams\n+{\n+    final protected Method _method;\n+\n+    // // Simple lazy-caching:\n+\n+    protected Class<?>[] _paramTypes;\n+\n+    /*\n+    /*****************************************************\n+    /* Life-cycle\n+    /*****************************************************\n+     */\n+\n+    public AnnotatedMethod(Method method, AnnotationMap classAnn, AnnotationMap[] paramAnnotations)\n+    {\n+        super(classAnn, paramAnnotations);\n+        _method = method;\n+    }\n+\n+    /**\n+     * Method that constructs a new instance with settings (annotations, parameter annotations)\n+     * of this instance, but with different physical {@link Method}.\n+     * \n+     * @since 1.7\n+     */\n+    public AnnotatedMethod withMethod(Method m)\n+    {\n+        return new AnnotatedMethod(m, _annotations, _paramAnnotations);\n+    }\n+    \n+    @Override\n+    public AnnotatedMethod withAnnotations(AnnotationMap ann) {\n+        return new AnnotatedMethod(_method, ann, _paramAnnotations);\n+    }\n+\n+    /*\n+    /*****************************************************\n+    /* Annotated impl\n+    /*****************************************************\n+     */\n+\n+    @Override\n+    public Method getAnnotated() { return _method; }\n+\n+    @Override\n+    public int getModifiers() { return _method.getModifiers(); }\n+\n+    @Override\n+    public String getName() { return _method.getName(); }\n+\n+    /**\n+     * For methods, this returns declared return type, which is only\n+     * useful with getters (setters do not return anything; hence \"void\"\n+     * type is returned here)\n+     */\n+    @Override\n+    public Type getGenericType() {\n+        return _method.getGenericReturnType();\n+    }\n+\n+    /**\n+     * For methods, this returns declared return type, which is only\n+     * useful with getters (setters do not return anything; hence \"void\"\n+     * type is returned here)\n+     */\n+    @Override\n+    public Class<?> getRawType() {\n+        return _method.getReturnType();\n+    }\n+\n+    /**\n+     * As per [JACKSON-468], we need to also allow declaration of local\n+     * type bindings; mostly it will allow defining bounds.\n+     */\n+    @Override\n+    public JavaType getType(TypeBindings bindings) {\n+        return getType(bindings, _method.getTypeParameters());\n+    }\n+\n+    @Override\n+    public final Object call() throws Exception {\n+        return _method.invoke(null);\n+    }\n+\n+    @Override\n+    public final Object call(Object[] args) throws Exception {\n+        return _method.invoke(null, args);\n+    }\n+\n+    @Override\n+    public final Object call1(Object arg) throws Exception {\n+        return _method.invoke(null, arg);\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* AnnotatedMember impl\n+    /********************************************************\n+     */\n+\n+    @Override\n+    public Class<?> getDeclaringClass() { return _method.getDeclaringClass(); }\n+\n+    @Override\n+    public Member getMember() { return _method; }\n+\n+    @Override\n+    public void setValue(Object pojo, Object value)\n+        throws IllegalArgumentException\n+    {\n+        try {\n+            _method.invoke(pojo, value);\n+        } catch (IllegalAccessException e) {\n+            throw new IllegalArgumentException(\"Failed to setValue() with method \"\n+                    +getFullName()+\": \"+e.getMessage(), e);\n+        } catch (InvocationTargetException e) {\n+            throw new IllegalArgumentException(\"Failed to setValue() with method \"\n+                    +getFullName()+\": \"+e.getMessage(), e);\n+        }\n+    }\n+    \n+    /*\n+    /*****************************************************\n+    /* Extended API, generic\n+    /*****************************************************\n+     */\n+\n+    @Override\n+    public int getParameterCount() {\n+        return getParameterTypes().length;\n+    }\n+\n+    public Type[] getParameterTypes() {\n+        return _method.getGenericParameterTypes();\n+    }\n+\n+    @Override\n+    public Class<?> getParameterClass(int index)\n+    {\n+        Class<?>[] types = _method.getParameterTypes();\n+        return (index >= types.length) ? null : types[index];\n+    }\n+\n+    @Override\n+    public Type getParameterType(int index)\n+    {\n+        Type[] types = _method.getGenericParameterTypes();\n+        return (index >= types.length) ? null : types[index];\n+    }\n+\n+    public Class<?>[] getParameterClasses()\n+    {\n+        if (_paramTypes == null) {\n+            _paramTypes = _method.getParameterTypes();\n+        }\n+        return _paramTypes;\n+    }\n+\n+    //public Type getGenericReturnType() { return _method.getGenericReturnType(); }\n+\n+    //public Class<?> getReturnType() { return _method.getReturnType(); }\n+\n+    public String getFullName() {\n+        return getDeclaringClass().getName() + \"#\" + getName() + \"(\"\n+            +getParameterCount()+\" params)\";\n+    }\n+\n+    /*\n+    /********************************************************\n+    /* Other\n+    /********************************************************\n+     */\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"[method \"+getName()+\", annotations: \"+_annotations+\"]\";\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMethodMap.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+/**\n+ * Simple helper class used to keep track of collection of\n+ * {@link AnnotatedMethod}s, accessible by lookup. Lookup\n+ * is usually needed for augmenting and overriding annotations.\n+ */\n+public final class AnnotatedMethodMap\n+    implements Iterable<AnnotatedMethod>\n+{\n+    protected LinkedHashMap<MemberKey,AnnotatedMethod> _methods;\n+\n+    public AnnotatedMethodMap() { }\n+\n+    /**\n+     * Method called to add specified annotated method in the Map.\n+     */\n+    public void add(AnnotatedMethod am)\n+    {\n+        if (_methods == null) {\n+            _methods = new LinkedHashMap<MemberKey,AnnotatedMethod>();\n+        }\n+        _methods.put(new MemberKey(am.getAnnotated()), am);\n+    }\n+\n+    /**\n+     * Method called to remove specified method, assuming\n+     * it exists in the Map\n+     */\n+    public AnnotatedMethod remove(AnnotatedMethod am)\n+    {\n+        return remove(am.getAnnotated());\n+    }\n+\n+    public AnnotatedMethod remove(Method m)\n+    {\n+        if (_methods != null) {\n+            return _methods.remove(new MemberKey(m));\n+        }\n+        return null;\n+    }\n+\n+    public boolean isEmpty() {\n+        return (_methods == null || _methods.size() == 0);\n+    }\n+\n+    public int size() {\n+        return (_methods == null) ? 0 : _methods.size();\n+    }\n+\n+    public AnnotatedMethod find(String name, Class<?>[] paramTypes)\n+    {\n+        if (_methods == null) {\n+            return null;\n+        }\n+        return _methods.get(new MemberKey(name, paramTypes));\n+    }\n+\n+    public AnnotatedMethod find(Method m)\n+    {\n+        if (_methods == null) {\n+            return null;\n+        }\n+        return _methods.get(new MemberKey(m));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Iterable implementation (for iterating over values)\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Iterator<AnnotatedMethod> iterator()\n+    {\n+        if (_methods != null) {\n+            return _methods.values().iterator();\n+        }\n+        List<AnnotatedMethod> empty = Collections.emptyList();\n+        return empty.iterator();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.AnnotatedElement;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Object that represents method parameters, mostly so that associated\n+ * annotations can be processed conveniently. Note that many of accessors\n+ * can not return meaningful values since parameters do not have stand-alone\n+ * JDK objects associated; so access should mostly be limited to checking\n+ * annotation values which are properly aggregated and included.\n+ *<p>\n+ * Note: as of version 1.7, this type extends {@link AnnotatedMember}, since\n+ * it behaves like a member for the most part, but earlier it just extended\n+ * {@link Annotated}\n+ */\n+public final class AnnotatedParameter\n+    extends AnnotatedMember\n+{\n+    /**\n+     * Member (method, constructor) that this parameter belongs to\n+     * \n+     * @since 1.7\n+     */\n+    protected final AnnotatedWithParams _owner;\n+    \n+    /**\n+     * JDK type of the parameter, possibly contains generic type information\n+     */\n+    protected final Type _type;\n+    \n+    /**\n+     * Index of the parameter within argument list\n+     * \n+     * @since 1.9\n+     */\n+    protected final int _index;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public AnnotatedParameter(AnnotatedWithParams owner, Type type,  AnnotationMap annotations,\n+            int index)\n+    {\n+        super(annotations);\n+        _owner = owner;\n+        _type = type;\n+        _index = index;\n+    }\n+\n+    @Override\n+    public AnnotatedParameter withAnnotations(AnnotationMap ann) {\n+        if (ann == _annotations) {\n+            return this;\n+        }\n+        return _owner.replaceParameterAnnotations(_index, ann);\n+    }\n+    \n+    public void addOrOverride(Annotation a)\n+    {\n+        _annotations.add(a);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Annotated impl\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Since there is no matching JDK element, this method will\n+     * always return null\n+     */\n+    @Override\n+    public AnnotatedElement getAnnotated() { return null; }\n+\n+    /**\n+     * Returns modifiers of the constructor, as parameters do not\n+     * have independent modifiers.\n+     */\n+    @Override\n+    public int getModifiers() { return _owner.getModifiers(); }\n+\n+    /**\n+     * Parameters have no names in bytecode (unlike in source code),\n+     * will always return empty String (\"\").\n+     */\n+    @Override\n+    public String getName() { return \"\"; }\n+\n+    /**\n+     * Accessor for annotations; all annotations associated with parameters\n+     * are properly passed and accessible.\n+     */\n+    @Override\n+    public <A extends Annotation> A getAnnotation(Class<A> acls)\n+    {\n+        return _annotations.get(acls);\n+    }\n+\n+    @Override\n+    public Type getGenericType() {\n+        return _type;\n+    }\n+\n+    @Override\n+    public Class<?> getRawType()\n+    {\n+        if (_type instanceof Class<?>) {\n+            return (Class<?>) _type;\n+        }\n+        // 14-Mar-2011, tatu: Not optimal, but has to do for now...\n+        JavaType t = TypeFactory.defaultInstance().constructType(_type);\n+        return t.getRawClass();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* AnnotatedMember extras\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Class<?> getDeclaringClass() {\n+        return _owner.getDeclaringClass();\n+    }\n+\n+    @Override\n+    public Member getMember() {\n+        /* This is bit tricky: since there is no JDK equivalent; can either\n+         * return null or owner... let's do latter, for now.\n+         */\n+        return _owner.getMember();\n+    }\n+\n+    @Override\n+    public void setValue(Object pojo, Object value)\n+        throws UnsupportedOperationException\n+    {\n+        throw new UnsupportedOperationException(\"Cannot call setValue() on constructor parameter of \"\n+                +getDeclaringClass().getName());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    public Type getParameterType() { return _type; }\n+\n+    /**\n+     * Accessor for 'owner' of this parameter; method or constructor that\n+     * has this parameter as member of its argument list.\n+     * \n+     * @return Owner (member or creator) object of this parameter\n+     * \n+     * @since 1.9\n+     */\n+    public AnnotatedWithParams getOwner() { return _owner; }\n+    \n+    /**\n+     * Accessor for index of this parameter within argument list\n+     * \n+     * @return Index of this parameter within argument list\n+     * \n+     * @since 1.9\n+     */\n+    public int getIndex() { return _index; }\n+\n+    /*\n+    /********************************************************\n+    /* Other\n+    /********************************************************\n+     */\n+    \n+    @Override\n+    public String toString()\n+    {\n+        return \"[parameter #\"+getIndex()+\", annotations: \"+_annotations+\"]\";\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedWithParams.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.type.TypeBindings;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Intermediate base class that encapsulates features that\n+ * constructors and methods share.\n+ */\n+public abstract class AnnotatedWithParams\n+    extends AnnotatedMember\n+{\n+    /**\n+     * Annotations associated with parameters of the annotated\n+     * entity (method or constructor parameters)\n+     */\n+    protected final AnnotationMap[] _paramAnnotations;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected AnnotatedWithParams(AnnotationMap annotations, AnnotationMap[] paramAnnotations)\n+    {\n+        super(annotations);\n+        _paramAnnotations = paramAnnotations;\n+    }\n+\n+    /**\n+     * Method called to override a class annotation, usually due to a mix-in\n+     * annotation masking or overriding an annotation 'real' class\n+     */\n+    public final void addOrOverride(Annotation a)\n+    {\n+        _annotations.add(a);\n+    }\n+\n+    /**\n+     * Method called to override a method parameter annotation,\n+     * usually due to a mix-in\n+     * annotation masking or overriding an annotation 'real' method\n+     * has.\n+     */\n+    public final void addOrOverrideParam(int paramIndex, Annotation a)\n+    {\n+        AnnotationMap old = _paramAnnotations[paramIndex];\n+        if (old == null) {\n+            old = new AnnotationMap();\n+            _paramAnnotations[paramIndex] = old;\n+        }\n+        old.add(a);\n+    }\n+\n+    /**\n+     * Method called to augment annotations, by adding specified\n+     * annotation if and only if it is not yet present in the\n+     * annotation map we have.\n+     */\n+    public final void addIfNotPresent(Annotation a)\n+    {\n+        _annotations.addIfNotPresent(a);\n+    }\n+\n+    \n+    /**\n+     * Method called by parameter object when an augmented instance is created;\n+     * needs to replace parameter with new instance\n+     * \n+     * @since 1.9\n+     */\n+    protected AnnotatedParameter replaceParameterAnnotations(int index, AnnotationMap ann)\n+    {\n+        _paramAnnotations[index] = ann;\n+        return getParameter(index);\n+    }    \n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for subclasses\n+    /**********************************************************\n+     */\n+\n+    protected JavaType getType(TypeBindings bindings, TypeVariable<?>[] typeParams)\n+    {\n+        // [JACKSON-468] Need to consider local type binding declarations too...\n+        if (typeParams != null && typeParams.length > 0) {\n+            bindings = bindings.childInstance();\n+            for (TypeVariable<?> var : typeParams) {\n+                String name = var.getName();\n+                // to prevent infinite loops, need to first add placeholder (\"<T extends Enum<T>>\" etc)\n+                bindings._addPlaceholder(name);\n+                // About only useful piece of information is the lower bound (which is at least Object.class)\n+                Type lowerBound = var.getBounds()[0];\n+                JavaType type = (lowerBound == null) ? TypeFactory.unknownType()\n+                        : bindings.resolveType(lowerBound);\n+                bindings.addBinding(var.getName(), type);\n+            }\n+        }\n+        return bindings.resolveType(getGenericType());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Partial Annotated impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final <A extends Annotation> A getAnnotation(Class<A> acls)\n+    {\n+        return _annotations.get(acls);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    public final AnnotationMap getParameterAnnotations(int index)\n+    {\n+        if (_paramAnnotations != null) {\n+            if (index >= 0 && index <= _paramAnnotations.length) {\n+                return _paramAnnotations[index];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public final AnnotatedParameter getParameter(int index) {\n+        return new AnnotatedParameter(this, getParameterType(index),\n+                _paramAnnotations[index], index);\n+    }\n+\n+    public abstract int getParameterCount();\n+\n+    public abstract Class<?> getParameterClass(int index);\n+\n+    public abstract Type getParameterType(int index);\n+\n+    /**\n+     * Method called to fully resolve type of one of parameters, given\n+     * specified type variable bindings.\n+     * \n+     * @since 1.8\n+     */\n+    public final JavaType resolveParameterType(int index, TypeBindings bindings) {\n+        return bindings.resolveType(getParameterType(index));\n+    }\n+    \n+    public final int getAnnotationCount() { return _annotations.size(); }\n+\n+    /**\n+     * Method that can be used to (try to) call this object without arguments.\n+     * This may succeed or fail, depending on expected number\n+     * of arguments: caller needs to take care to pass correct number.\n+     * Exceptions are thrown directly from actual low-level call.\n+     *<p>\n+     * Note: only works for constructors and static methods.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract Object call() throws Exception;\n+\n+    /**\n+     * Method that can be used to (try to) call this object with specified arguments.\n+     * This may succeed or fail, depending on expected number\n+     * of arguments: caller needs to take care to pass correct number.\n+     * Exceptions are thrown directly from actual low-level call.\n+     *<p>\n+     * Note: only works for constructors and static methods.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract Object call(Object[] args) throws Exception;\n+\n+    /**\n+     * Method that can be used to (try to) call this object with single arguments.\n+     * This may succeed or fail, depending on expected number\n+     * of arguments: caller needs to take care to pass correct number.\n+     * Exceptions are thrown directly from actual low-level call.\n+     *<p>\n+     * Note: only works for constructors and static methods.\n+     * \n+     * @since 1.9\n+     */\n+    public abstract Object call1(Object arg) throws Exception;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * Simple helper class used to keep track of collection of\n+ * Jackson Annotations associated with annotatable things\n+ * (methods, constructors, classes).\n+ * Note that only Jackson-owned annotations are tracked (for now?).\n+ */\n+public final class AnnotationMap implements Annotations\n+{\n+    protected HashMap<Class<? extends Annotation>,Annotation> _annotations;\n+\n+    public AnnotationMap() { }\n+    private AnnotationMap(HashMap<Class<? extends Annotation>,Annotation> a) {\n+        _annotations = a;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <A extends Annotation> A get(Class<A> cls)\n+    {\n+        if (_annotations == null) {\n+            return null;\n+        }\n+        return (A) _annotations.get(cls);\n+    }\n+\n+    public static AnnotationMap merge(AnnotationMap primary, AnnotationMap secondary)\n+    {\n+        if (primary == null || primary._annotations == null || primary._annotations.isEmpty()) {\n+            return secondary;\n+        }\n+        if (secondary == null || secondary._annotations == null || secondary._annotations.isEmpty()) {\n+            return primary;\n+        }\n+        HashMap<Class<? extends Annotation>,Annotation> annotations\n+            = new HashMap<Class<? extends Annotation>,Annotation>();\n+        // add secondary ones first\n+        for (Annotation ann : secondary._annotations.values()) {\n+            annotations.put(ann.annotationType(), ann);\n+        }\n+        // to be overridden by primary ones\n+        for (Annotation ann : primary._annotations.values()) {\n+            annotations.put(ann.annotationType(), ann);\n+        }\n+        return new AnnotationMap(annotations);\n+    }\n+    \n+    @Override\n+    public int size() {\n+        return (_annotations == null) ? 0 : _annotations.size();\n+    }\n+\n+    /**\n+     * Method called to add specified annotation in the Map, but\n+     * only if it didn't yet exist.\n+     */\n+    public void addIfNotPresent(Annotation ann)\n+    {\n+        if (_annotations == null || !_annotations.containsKey(ann.annotationType())) {\n+            _add(ann);\n+        }\n+    }\n+\n+    /**\n+     * Method called to add specified annotation in the Map.\n+     */\n+    public void add(Annotation ann) {\n+        _add(ann);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        if (_annotations == null) {\n+            return \"[null]\";\n+        }\n+        return _annotations.toString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected final void _add(Annotation ann)\n+    {\n+        if (_annotations == null) {\n+            _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n+        }\n+        _annotations.put(ann.annotationType(), ann);\n+    }\n+}\n+\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicBeanDescription.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n+import com.fasterxml.jackson.databind.type.TypeBindings;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+/**\n+ * Default {@link BeanDescription} implementation.\n+ * Can theoretically be subclassed to customize\n+ * some aspects of property introspection.\n+ */\n+public class BasicBeanDescription extends BeanDescription\n+{\n+    /*\n+    /**********************************************************\n+    /* General configuration\n+    /**********************************************************\n+     */\n+\n+    final protected MapperConfig<?> _config;\n+\n+    final protected AnnotationIntrospector _annotationIntrospector;\n+    \n+    /**\n+     * Information collected about the class introspected.\n+     */\n+    final protected AnnotatedClass _classInfo;\n+    \n+    /**\n+     * We may need type bindings for the bean type. If so, we'll\n+     * construct it lazily\n+     */\n+    protected TypeBindings _bindings;\n+\n+    /*\n+    /**********************************************************\n+    /* Member information\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Properties collected for the POJO.\n+     */\n+    protected final List<BeanPropertyDefinition> _properties;\n+\n+    // // for deserialization\n+    \n+    protected AnnotatedMethod _anySetterMethod;\n+\n+    protected Map<Object, AnnotatedMember> _injectables;\n+    \n+    /**\n+     * Set of properties that can be ignored during deserialization, due\n+     * to being marked as ignored.\n+     */\n+    protected Set<String> _ignoredPropertyNames;\n+\n+    // // for serialization\n+    \n+    protected AnnotatedMethod _jsonValueMethod;\n+\n+    protected AnnotatedMethod _anyGetterMethod;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @deprecated Since 1.9, should use factory methods instead\n+     */\n+    @Deprecated\n+    public BasicBeanDescription(MapperConfig<?> config, JavaType type,\n+            AnnotatedClass ac)\n+    {\n+        this(config, type, ac, Collections.<BeanPropertyDefinition>emptyList());\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    protected BasicBeanDescription(MapperConfig<?> config, JavaType type,\n+            AnnotatedClass ac, List<BeanPropertyDefinition> properties)\n+    {\n+    \tsuper(type);\n+    \t_config = config;\n+    \t_annotationIntrospector = (config == null) ? null : config.getAnnotationIntrospector();\n+    \t_classInfo = ac;\n+    \t_properties = properties;\n+    }\n+\n+    /**\n+     * Factory method to use for constructing an instance to use for building\n+     * deserializers.\n+     * \n+     * @since 1.9\n+     */\n+    public static BasicBeanDescription forDeserialization(POJOPropertiesCollector coll)\n+    {\n+        BasicBeanDescription desc = new BasicBeanDescription(coll.getConfig(),\n+                coll.getType(), coll.getClassDef(), coll.getProperties());\n+        desc._anySetterMethod = coll.getAnySetterMethod();\n+        desc._ignoredPropertyNames = coll.getIgnoredPropertyNames();\n+        desc._injectables = coll.getInjectables();\n+        return desc;\n+    }\n+\n+    /**\n+     * Factory method to use for constructing an instance to use for building\n+     * serializers.\n+     * \n+     * @since 1.9\n+     */\n+    public static BasicBeanDescription forSerialization(POJOPropertiesCollector coll)\n+    {\n+        BasicBeanDescription desc = new BasicBeanDescription(coll.getConfig(),\n+                coll.getType(), coll.getClassDef(), coll.getProperties());\n+        desc._jsonValueMethod = coll.getJsonValueMethod();\n+        desc._anyGetterMethod = coll.getAnyGetterMethod();\n+        return desc;\n+    }\n+\n+    /**\n+     * Factory method to use for constructing an instance to use for purposes\n+     * other than building serializers or deserializers; will only have information\n+     * on class, not on properties.\n+     * \n+     * @since 1.9\n+     */\n+    public static BasicBeanDescription forOtherUse(MapperConfig<?> config,\n+            JavaType type, AnnotatedClass ac)\n+    {\n+        return new BasicBeanDescription(config, type,\n+                ac, Collections.<BeanPropertyDefinition>emptyList());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Simple accessors from BeanDescription\n+    /**********************************************************\n+     */\n+\n+    /**        \n+     * @since 1.9\n+     */\n+    @Override\n+    public AnnotatedClass getClassInfo() { return _classInfo; }\n+    \n+    @Override\n+    public List<BeanPropertyDefinition> findProperties() {\n+        return _properties;\n+    }\n+\n+    /**\n+     * Method for locating the getter method that is annotated with\n+     * {@link org.codehaus.jackson.annotate.JsonValue} annotation,\n+     * if any. If multiple ones are found,\n+     * an error is reported by throwing {@link IllegalArgumentException}\n+     */\n+    @Override\n+    public AnnotatedMethod findJsonValueMethod()\n+    {\n+        return _jsonValueMethod;\n+    }\n+\n+    @Override\n+    public Set<String> getIgnoredPropertyNames() {\n+        if (_ignoredPropertyNames == null) {\n+            return Collections.emptySet();\n+        }\n+        return _ignoredPropertyNames;\n+    }\n+    \n+    /**\n+     * Method for checking whether class being described has any\n+     * annotations recognized by registered annotation introspector.\n+     */\n+    @Override\n+    public boolean hasKnownClassAnnotations() {\n+        return _classInfo.hasAnnotations();\n+    }\n+\n+    @Override\n+    public Annotations getClassAnnotations() {\n+        return _classInfo.getAnnotations();\n+    }\n+\n+    @Override\n+    public TypeBindings bindingsForBeanType()\n+    {\n+        if (_bindings == null) {\n+            _bindings = new TypeBindings(_config.getTypeFactory(), _type);\n+        }\n+        return _bindings;\n+    }\n+\n+    @Override\n+    public JavaType resolveType(java.lang.reflect.Type jdkType) {\n+        if (jdkType == null) {\n+            return null;\n+        }\n+        return bindingsForBeanType().resolveType(jdkType);\n+    }\n+\n+    /**\n+     * Method that will locate the no-arg constructor for this class,\n+     * if it has one, and that constructor has not been marked as\n+     * ignorable.\n+     * \n+     * @since 1.9\n+     */\n+    @Override\n+    public AnnotatedConstructor findDefaultConstructor()\n+    {\n+        return _classInfo.getDefaultConstructor();\n+    }\n+\n+    /**\n+     * Method used to locate the method of introspected class that\n+     * implements {@link org.codehaus.jackson.annotate.JsonAnySetter}. If no such method exists\n+     * null is returned. If more than one are found, an exception\n+     * is thrown.\n+     * Additional checks are also made to see that method signature\n+     * is acceptable: needs to take 2 arguments, first one String or\n+     * Object; second any can be any type.\n+     */\n+    @Override\n+    public AnnotatedMethod findAnySetter() throws IllegalArgumentException\n+    {\n+        if (_anySetterMethod != null) {\n+            /* Also, let's be somewhat strict on how field name is to be\n+             * passed; String, Object make sense, others not\n+             * so much.\n+             */\n+            /* !!! 18-May-2009, tatu: how about enums? Can add support if\n+             *  requested; easy enough for devs to add support within\n+             *  method.\n+             */\n+            Class<?> type = _anySetterMethod.getParameterClass(0);\n+            if (type != String.class && type != Object.class) {\n+                throw new IllegalArgumentException(\"Invalid 'any-setter' annotation on method \"+_anySetterMethod.getName()+\"(): first argument not of type String or Object, but \"+type.getName());\n+            }\n+        }\n+        return _anySetterMethod;\n+    }\n+\n+    @Override\n+    public Map<Object, AnnotatedMember> findInjectables()\n+    {\n+        return _injectables;\n+    }\n+    \n+    public List<AnnotatedConstructor> getConstructors()\n+    {\n+        return _classInfo.getConstructors();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Simple accessors, extended\n+    /**********************************************************\n+     */\n+\n+    public AnnotatedMethod findMethod(String name, Class<?>[] paramTypes)\n+    {\n+        return _classInfo.findMethod(name, paramTypes);\n+    }\n+\n+    /**\n+     * Method called to create a \"default instance\" of the bean, currently\n+     * only needed for obtaining default field values which may be used for\n+     * suppressing serialization of fields that have \"not changed\".\n+     * \n+     * @param fixAccess If true, method is allowed to fix access to the\n+     *   default constructor (to be able to call non-public constructor);\n+     *   if false, has to use constructor as is.\n+     *\n+     * @return Instance of class represented by this descriptor, if\n+     *   suitable default constructor was found; null otherwise.\n+     */\n+    public Object instantiateBean(boolean fixAccess)\n+    {\n+        AnnotatedConstructor ac = _classInfo.getDefaultConstructor();\n+        if (ac == null) {\n+            return null;\n+        }\n+        if (fixAccess) {\n+            ac.fixAccess();\n+        }\n+        try {\n+            return ac.getAnnotated().newInstance();\n+        } catch (Exception e) {\n+            Throwable t = e;\n+            while (t.getCause() != null) {\n+                t = t.getCause();\n+            }\n+            if (t instanceof Error) throw (Error) t;\n+            if (t instanceof RuntimeException) throw (RuntimeException) t;\n+            throw new IllegalArgumentException(\"Failed to instantiate bean of type \"+_classInfo.getAnnotated().getName()+\": (\"+t.getClass().getName()+\") \"+t.getMessage(), t);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Introspection for serialization, factories\n+    /**********************************************************\n+     */\n+\n+    public List<AnnotatedMethod> getFactoryMethods()\n+    {\n+        // must filter out anything that clearly is not a factory method\n+        List<AnnotatedMethod> candidates = _classInfo.getStaticMethods();\n+        if (candidates.isEmpty()) {\n+            return candidates;\n+        }\n+        ArrayList<AnnotatedMethod> result = new ArrayList<AnnotatedMethod>();\n+        for (AnnotatedMethod am : candidates) {\n+            if (isFactoryMethod(am)) {\n+                result.add(am);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Method that can be called to locate a single-arg constructor that\n+     * takes specified exact type (will not accept supertype constructors)\n+     *\n+     * @param argTypes Type(s) of the argument that we are looking for\n+     */\n+    public Constructor<?> findSingleArgConstructor(Class<?>... argTypes)\n+    {\n+        for (AnnotatedConstructor ac : _classInfo.getConstructors()) {\n+            // This list is already filtered to only include accessible\n+            /* (note: for now this is a redundant check; but in future\n+             * that may change; thus leaving here for now)\n+             */\n+            if (ac.getParameterCount() == 1) {\n+                Class<?> actArg = ac.getParameterClass(0);\n+                for (Class<?> expArg : argTypes) {\n+                    if (expArg == actArg) {\n+                        return ac.getAnnotated();\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Method that can be called to find if introspected class declares\n+     * a static \"valueOf\" factory method that returns an instance of\n+     * introspected type, given one of acceptable types.\n+     *\n+     * @param expArgTypes Types that the matching single argument factory\n+     *   method can take: will also accept super types of these types\n+     *   (ie. arg just has to be assignable from expArgType)\n+     */\n+    public Method findFactoryMethod(Class<?>... expArgTypes)\n+    {\n+        // So, of all single-arg static methods:\n+        for (AnnotatedMethod am : _classInfo.getStaticMethods()) {\n+            if (isFactoryMethod(am)) {\n+                // And must take one of expected arg types (or supertype)\n+                Class<?> actualArgType = am.getParameterClass(0);\n+                for (Class<?> expArgType : expArgTypes) {\n+                    // And one that matches what we would pass in\n+                    if (actualArgType.isAssignableFrom(expArgType)) {\n+                        return am.getAnnotated();\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected boolean isFactoryMethod(AnnotatedMethod am)\n+    {\n+        /* First: return type must be compatible with the introspected class\n+         * (i.e. allowed to be sub-class, although usually is the same\n+         * class)\n+         */\n+        Class<?> rt = am.getRawType();\n+        if (!getBeanClass().isAssignableFrom(rt)) {\n+            return false;\n+        }\n+\n+        /* Also: must be a recognized factory method, meaning:\n+         * (a) marked with @JsonCreator annotation, or\n+         * (a) \"valueOf\" (at this point, need not be public)\n+         */\n+        if (_annotationIntrospector.hasCreatorAnnotation(am)) {\n+            return true;\n+        }\n+        if (\"valueOf\".equals(am.getName())) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Method for getting ordered list of named Creator properties.\n+     * Returns an empty list is none found. If multiple Creator\n+     * methods are defined, order between properties from different\n+     * methods is undefined; however, properties for each such\n+     * Creator are ordered properly relative to each other. For the\n+     * usual case of just a single Creator, named properties are\n+     * thus properly ordered.\n+     */\n+    public List<String> findCreatorPropertyNames()\n+    {\n+        List<String> names = null;\n+\n+        for (int i = 0; i < 2; ++i) {\n+            List<? extends AnnotatedWithParams> l = (i == 0)\n+                ? getConstructors() : getFactoryMethods();\n+            for (AnnotatedWithParams creator : l) {\n+                int argCount = creator.getParameterCount();\n+                if (argCount < 1) continue;\n+                String name = _annotationIntrospector.findPropertyNameForParam(creator.getParameter(0));\n+                if (name == null) continue;\n+                if (names == null) {\n+                    names = new ArrayList<String>();\n+                }\n+                names.add(name);\n+                for (int p = 1; p < argCount; ++p) {\n+                    names.add(_annotationIntrospector.findPropertyNameForParam(creator.getParameter(p)));\n+                }\n+            }\n+        }\n+        if (names == null) {\n+            return Collections.emptyList();\n+        }\n+        return names;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Introspection for serialization, other\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for determining whether null properties should be written\n+     * out for a Bean of introspected type. This is based on global\n+     * feature (lowest priority, passed as argument)\n+     * and per-class annotation (highest priority).\n+     */\n+    public JsonSerialize.Inclusion findSerializationInclusion(JsonSerialize.Inclusion defValue)\n+    {\n+        if (_annotationIntrospector == null) {\n+            return defValue;\n+        }\n+        return _annotationIntrospector.findSerializationInclusion(_classInfo, defValue);\n+    }\n+\n+    /**\n+     * Method used to locate the method of introspected class that\n+     * implements {@link org.codehaus.jackson.annotate.JsonAnyGetter}.\n+     * If no such method exists null is returned.\n+     * If more than one are found, an exception is thrown.\n+     * \n+     * @since 1.6\n+     */\n+    @Override\n+    public AnnotatedMethod findAnyGetter() throws IllegalArgumentException\n+    {\n+        if (_anyGetterMethod != null) {\n+            /* For now let's require a Map; in future can add support for other\n+             * types like perhaps Iterable<Map.Entry>?\n+             */\n+            Class<?> type = _anyGetterMethod.getRawType();\n+            if (!Map.class.isAssignableFrom(type)) {\n+                throw new IllegalArgumentException(\"Invalid 'any-getter' annotation on method \"+_anyGetterMethod.getName()+\"(): return type is not instance of java.util.Map\");\n+            }\n+        }\n+        return _anyGetterMethod;\n+    }\n+    \n+    /**\n+     * Method for locating all back-reference properties (setters, fields) bean has\n+     * \n+     * @since 1.6\n+     */\n+    public Map<String,AnnotatedMember> findBackReferenceProperties()\n+    {\n+        HashMap<String,AnnotatedMember> result = null;\n+        for (BeanPropertyDefinition property : _properties) {\n+            AnnotatedMember am = property.getMutator();\n+            if (am == null) {\n+                continue;\n+            }\n+            AnnotationIntrospector.ReferenceProperty refDef = _annotationIntrospector.findReferenceType(am);\n+            if (refDef != null && refDef.isBackReference()) {\n+                if (result == null) {\n+                    result = new HashMap<String,AnnotatedMember>();\n+                }\n+                String refName = refDef.getName();\n+                if (result.put(refName, am) != null) {\n+                    throw new IllegalArgumentException(\"Multiple back-reference properties with name '\"+refName+\"'\");\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for field introspection\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @param ignoredProperties (optional) names of properties to ignore;\n+     *   any fields that would be recognized as one of these properties\n+     *   is ignored.\n+     * @param forSerialization If true, will collect serializable property\n+     *    fields; if false, deserializable\n+     *\n+     * @return Ordered Map with logical property name as key, and\n+     *    matching field as value.\n+     */\n+    public LinkedHashMap<String,AnnotatedField> _findPropertyFields(\n+            Collection<String> ignoredProperties, boolean forSerialization)\n+    {\n+        LinkedHashMap<String,AnnotatedField> results = new LinkedHashMap<String,AnnotatedField>();\n+        for (BeanPropertyDefinition property : _properties) {\n+            AnnotatedField f = property.getField();\n+            if (f != null) {\n+                String name = property.getName();\n+                if (ignoredProperties != null) {\n+                    if (ignoredProperties.contains(name)) {\n+                        continue;\n+                    }\n+                }\n+                results.put(name, f);\n+            }\n+        }\n+        return results;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deprecated methods from BeanDescription\n+    /**********************************************************\n+     */\n+    \n+    @SuppressWarnings(\"deprecation\")\n+    @Override\n+    public LinkedHashMap<String,AnnotatedMethod> findGetters(VisibilityChecker<?> visibilityChecker,\n+            Collection<String> ignoredProperties)\n+    {\n+        LinkedHashMap<String,AnnotatedMethod> results = new LinkedHashMap<String,AnnotatedMethod>();\n+        for (BeanPropertyDefinition property : _properties) {\n+            AnnotatedMethod m = property.getGetter();\n+            if (m != null) {\n+                String name = property.getName();\n+                if (ignoredProperties != null) {\n+                    if (ignoredProperties.contains(name)) {\n+                        continue;\n+                    }\n+                }\n+                results.put(name, m);\n+            }\n+        }\n+        return results;\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Override\n+    public LinkedHashMap<String,AnnotatedMethod> findSetters(VisibilityChecker<?> visibilityChecker)\n+    {\n+        LinkedHashMap<String,AnnotatedMethod> results = new LinkedHashMap<String,AnnotatedMethod>();\n+        for (BeanPropertyDefinition property : _properties) {\n+            AnnotatedMethod m = property.getSetter();\n+            if (m != null) {\n+                results.put(property.getName(), m);\n+            }\n+        }\n+        return results;\n+    }\n+    \n+    @SuppressWarnings(\"deprecation\")\n+    @Override\n+    public LinkedHashMap<String,AnnotatedField> findSerializableFields(VisibilityChecker<?> visibilityChecker,\n+            Collection<String> ignoredProperties)\n+    {\n+        return _findPropertyFields(ignoredProperties, true);\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Override\n+    public LinkedHashMap<String,AnnotatedField> findDeserializableFields(VisibilityChecker<?> visibilityChecker,\n+            Collection<String> ignoredProperties)\n+    {\n+        return _findPropertyFields(ignoredProperties, false);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/BasicClassIntrospector.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.ClassIntrospector;\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.MapperConfig;\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.type.SimpleType;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+public class BasicClassIntrospector\n+    extends ClassIntrospector<BasicBeanDescription>\n+{\n+    /* We keep a small set of pre-constructed descriptions to use for\n+     * common non-structured values, such as Numbers and Strings.\n+     * This is strictly performance optimization to reduce what is\n+     * usually one-time cost, but seems useful for some cases considering\n+     * simplicity.\n+     */\n+    \n+    protected final static BasicBeanDescription STRING_DESC;\n+    static {\n+        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(String.class, null, null);\n+        STRING_DESC = BasicBeanDescription.forOtherUse(null, SimpleType.constructUnsafe(String.class), ac);\n+    }\n+    protected final static BasicBeanDescription BOOLEAN_DESC;\n+    static {\n+        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(Boolean.TYPE, null, null);\n+        BOOLEAN_DESC = BasicBeanDescription.forOtherUse(null, SimpleType.constructUnsafe(Boolean.TYPE), ac);\n+    }\n+    protected final static BasicBeanDescription INT_DESC;\n+    static {\n+        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(Integer.TYPE, null, null);\n+        INT_DESC = BasicBeanDescription.forOtherUse(null, SimpleType.constructUnsafe(Integer.TYPE), ac);\n+    }\n+    protected final static BasicBeanDescription LONG_DESC;\n+    static {\n+        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(Long.TYPE, null, null);\n+        LONG_DESC = BasicBeanDescription.forOtherUse(null, SimpleType.constructUnsafe(Long.TYPE), ac);\n+    }\n+\n+    \n+    // // // Then static filter singletons\n+    \n+    /**\n+     * @since 1.8\n+     * @deprecated Since 1.9 just don't use\n+     */\n+    @Deprecated\n+    public final static GetterMethodFilter DEFAULT_GETTER_FILTER = new GetterMethodFilter();\n+\n+    /**\n+     * @since 1.8\n+     * @deprecated Since 1.9 just don't use\n+     */\n+    @Deprecated\n+    public final static SetterMethodFilter DEFAULT_SETTER_FILTER = new SetterMethodFilter();\n+\n+    /**\n+     * @since 1.8\n+     * @deprecated Since 1.9 just don't use\n+     */\n+    @Deprecated\n+    public final static SetterAndGetterMethodFilter DEFAULT_SETTER_AND_GETTER_FILTER = new SetterAndGetterMethodFilter();\n+\n+    protected final static MethodFilter MINIMAL_FILTER = new MinimalMethodFilter();\n+    \n+    /*\n+    /**********************************************************\n+    /* Life cycle\n+    /**********************************************************\n+     */\n+\n+    public final static BasicClassIntrospector instance = new BasicClassIntrospector();\n+\n+    public BasicClassIntrospector() { }\n+    \n+    /*\n+    /**********************************************************\n+    /* Factory method impls\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public BasicBeanDescription forSerialization(SerializationConfig cfg,\n+            JavaType type, MixInResolver r)\n+    {\n+        // minor optimization: for JDK types do minimal introspection\n+        BasicBeanDescription desc = _findCachedDesc(type);\n+        if (desc == null) {\n+            desc = BasicBeanDescription.forSerialization(collectProperties(cfg, type, r, true));\n+        }\n+        return desc;\n+    }\n+\n+    @Override\n+    public BasicBeanDescription forDeserialization(DeserializationConfig cfg,\n+            JavaType type, MixInResolver r)\n+    {\n+        // minor optimization: for JDK types do minimal introspection\n+        BasicBeanDescription desc = _findCachedDesc(type);\n+        if (desc == null) {\n+            desc = BasicBeanDescription.forDeserialization(collectProperties(cfg, type, r, false));\n+        }\n+        return desc;\n+    }\n+\n+    @Override\n+    public BasicBeanDescription forCreation(DeserializationConfig cfg,\n+            JavaType type, MixInResolver r)\n+    {\n+        BasicBeanDescription desc = _findCachedDesc(type);\n+        if (desc == null) {\n+            desc = BasicBeanDescription.forDeserialization(collectProperties(cfg, type, r, false));\n+        }\n+        return desc;\n+    }\n+\n+    @Override\n+    public BasicBeanDescription forClassAnnotations(MapperConfig<?> cfg,\n+            JavaType type, MixInResolver r)\n+    {\n+        boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n+        AnnotationIntrospector ai =  cfg.getAnnotationIntrospector();\n+        AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), (useAnnotations ? ai : null), r);\n+        return BasicBeanDescription.forOtherUse(cfg, type, ac);\n+    }\n+\n+    @Override\n+    public BasicBeanDescription forDirectClassAnnotations(MapperConfig<?> cfg,\n+            JavaType type, MixInResolver r)\n+    {\n+        boolean useAnnotations = cfg.isAnnotationProcessingEnabled();\n+        AnnotationIntrospector ai =  cfg.getAnnotationIntrospector();\n+        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(type.getRawClass(),\n+                (useAnnotations ? ai : null), r);\n+        return BasicBeanDescription.forOtherUse(cfg, type, ac);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridable helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public POJOPropertiesCollector collectProperties(MapperConfig<?> config,\n+            JavaType type, MixInResolver r, boolean forSerialization)\n+    {\n+        AnnotatedClass ac = classWithCreators(config, type, r);\n+        ac.resolveMemberMethods(MINIMAL_FILTER);\n+        ac.resolveFields();\n+        return constructPropertyCollector(config, ac, type, forSerialization).collect();\n+    }\n+\n+    /**\n+     * Overridable method called for creating {@link POJOPropertiesCollector} instance\n+     * to use; override is needed if a custom sub-class is to be used.\n+     * \n+     * @since 1.9\n+     */\n+    protected POJOPropertiesCollector constructPropertyCollector(MapperConfig<?> config,\n+            AnnotatedClass ac, JavaType type,\n+            boolean forSerialization)\n+    {\n+        return new POJOPropertiesCollector(config, forSerialization, type, ac);\n+    }\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    public AnnotatedClass classWithCreators(MapperConfig<?> config,\n+            JavaType type, MixInResolver r)\n+    {\n+        boolean useAnnotations = config.isAnnotationProcessingEnabled();\n+        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+        AnnotatedClass ac = AnnotatedClass.construct(type.getRawClass(), (useAnnotations ? ai : null), r);\n+        ac.resolveMemberMethods(MINIMAL_FILTER);\n+        // true -> include all creators, not just default constructor\n+        ac.resolveCreators(true);\n+        return ac;\n+    }\n+    \n+    /**\n+     * Method called to see if type is one of core JDK types\n+     * that we have cached for efficiency.\n+     * \n+     * @since 1.9\n+     */\n+    protected BasicBeanDescription _findCachedDesc(JavaType type)\n+    {\n+        Class<?> cls = type.getRawClass();\n+        if (cls == String.class) {\n+            return STRING_DESC;\n+        }\n+        if (cls == Boolean.TYPE) {\n+            return BOOLEAN_DESC;\n+        }\n+        if (cls == Integer.TYPE) {\n+            return INT_DESC;\n+        }\n+        if (cls == Long.TYPE) {\n+            return LONG_DESC;\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Helper method for getting access to filter that only guarantees\n+     * that methods used for serialization are to be included.\n+     * \n+     * @deprecated Since 1.9 just don't use\n+     */\n+    @Deprecated\n+    protected MethodFilter getSerializationMethodFilter(SerializationConfig cfg)\n+    {\n+    \treturn DEFAULT_GETTER_FILTER;\n+    }\n+\n+    /**\n+     * Helper method for getting access to filter that only guarantees\n+     * that methods used for deserialization are to be included.\n+     * \n+     * @deprecated Since 1.9 just don't use\n+     */\n+    @Deprecated\n+    protected MethodFilter getDeserializationMethodFilter(DeserializationConfig cfg)\n+    {\n+        /* [JACKSON-88]: may also need to include getters (at least for\n+         * Collection and Map types)\n+         */\n+        if (cfg.isEnabled(DeserializationConfig.Feature.USE_GETTERS_AS_SETTERS)) {\n+            return DEFAULT_SETTER_AND_GETTER_FILTER;\n+            \n+        }\n+    \treturn DEFAULT_SETTER_FILTER;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Going forward, we will only do very minimal filtering;\n+     * mostly just gets rid of static methods really.\n+     * \n+     * @since 1.9\n+     */\n+    private static class MinimalMethodFilter\n+        implements MethodFilter\n+    {\n+        @Override\n+        public boolean includeMethod(Method m)\n+        {\n+            if (Modifier.isStatic(m.getModifiers())) {\n+                return false;\n+            }\n+            int pcount = m.getParameterTypes().length;\n+            return (pcount <= 2);\n+        }\n+    }\n+    \n+    /**\n+     * Filter used to only include methods that have signature that is\n+     * compatible with \"getters\": take no arguments, are non-static,\n+     * and return something.\n+     * \n+     * @deprecated Since 1.9 just don't use\n+     */\n+    @Deprecated\n+    public static class GetterMethodFilter\n+        implements MethodFilter\n+    {\n+        private GetterMethodFilter() { }\n+    \n+        @Override\n+        public boolean includeMethod(Method m)\n+        {\n+            return ClassUtil.hasGetterSignature(m);\n+        }\n+    }\n+\n+    /**\n+     * Filter used to only include methods that have signature that is\n+     * compatible with \"setters\": take one and only argument and\n+     * are non-static.\n+     *<p>\n+     * Actually, also need to include 2-arg  methods to support\n+     * \"any setters\"; as well as 0-arg getters as long as they\n+     * return Collection or Map type.\n+     * \n+     * @deprecated Since 1.9 just don't use\n+     */\n+    @Deprecated\n+    public static class SetterMethodFilter\n+        implements MethodFilter\n+    {\n+        @Override\n+        public boolean includeMethod(Method m)\n+        {\n+            // First: we can't use static methods\n+            if (Modifier.isStatic(m.getModifiers())) {\n+                return false;\n+            }\n+            int pcount = m.getParameterTypes().length;\n+            // Ok; multiple acceptable parameter counts:\n+            switch (pcount) {\n+            case 1:\n+                // Regular setters take just one param, so include:\n+                return true;\n+            case 2:\n+                /* 2-arg version only for \"AnySetters\"; they are not\n+                 * auto-detected, and need to have an annotation.\n+                 * However, due to annotation inheritance we do, we\n+                 * don't yet know if sub-classes might have annotations...\n+                 * so shouldn't leave out any methods quite yet.\n+                 */\n+                //if (m.getAnnotation(JsonAnySetter.class) != null) { ... }\n+\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+    \n+    /**\n+     * Filter used if some getters (namely, once needed for \"setterless\n+     * collection injection\") are also needed, not just setters.\n+     * \n+     * @deprecated Since 1.9 just don't use\n+     */\n+    @Deprecated\n+    public final static class SetterAndGetterMethodFilter\n+        extends SetterMethodFilter\n+    {\n+        @SuppressWarnings(\"deprecation\")\n+        @Override\n+        public boolean includeMethod(Method m)\n+        {\n+            if (super.includeMethod(m)) {\n+                return true;\n+            }\n+            if (!ClassUtil.hasGetterSignature(m)) {\n+                return false;\n+            }\n+            // but furthermore, only accept Collections & Maps, for now\n+            Class<?> rt = m.getReturnType();\n+            if (Collection.class.isAssignableFrom(rt)\n+                || Map.class.isAssignableFrom(rt)) {\n+                return true; \n+            }\n+            return false;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Annotation;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.codehaus.jackson.annotate.*;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.*;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.std.RawSerializer;\n+\n+/**\n+ * {@link AnnotationIntrospector} implementation that handles standard\n+ * Jackson annotations.\n+ */\n+public class JacksonAnnotationIntrospector\n+    extends AnnotationIntrospector\n+{\n+    public JacksonAnnotationIntrospector() { }\n+\n+    /*\n+    /**********************************************************\n+    /* General annotation properties\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isHandled(Annotation ann)\n+    {\n+        Class<? extends Annotation> acls = ann.annotationType();\n+\n+        /* 16-May-2009, tatu: used to check this like so...\n+           final String JACKSON_PKG_PREFIX = \"org.codehaus.jackson\";\n+\n+           Package pkg = acls.getPackage();\n+           return (pkg != null) && (pkg.getName().startsWith(JACKSON_PKG_PREFIX));\n+        */\n+\n+        // but this is more reliable, now that we have tag annotation:\n+        return acls.getAnnotation(JacksonAnnotation.class) != null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* General annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String findEnumValue(Enum<?> value)\n+    {\n+        return value.name();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* General class annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Boolean findCachability(AnnotatedClass ac)\n+    {\n+        JsonCachable ann = ac.getAnnotation(JsonCachable.class);\n+        if (ann == null) {\n+            return null;\n+        }\n+        return ann.value() ? Boolean.TRUE : Boolean.FALSE;\n+    }\n+\n+    @Override\n+    public String findRootName(AnnotatedClass ac)\n+    {\n+        JsonRootName ann = ac.getAnnotation(JsonRootName.class);\n+        return (ann == null) ? null : ann.value();\n+    }\n+\n+    @Override\n+    public String[] findPropertiesToIgnore(AnnotatedClass ac) {\n+        JsonIgnoreProperties ignore = ac.getAnnotation(JsonIgnoreProperties.class);\n+        return (ignore == null) ? null : ignore.value();\n+    }\n+\n+    @Override\n+    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n+        JsonIgnoreProperties ignore = ac.getAnnotation(JsonIgnoreProperties.class);\n+        return (ignore == null) ? null : ignore.ignoreUnknown();\n+    }\n+\n+    @Override\n+    public Boolean isIgnorableType(AnnotatedClass ac) {\n+        JsonIgnoreType ignore = ac.getAnnotation(JsonIgnoreType.class);\n+        return (ignore == null) ? null : ignore.value();\n+    }\n+\n+    @Override\n+    public Object findFilterId(AnnotatedClass ac)\n+    {\n+        JsonFilter ann = ac.getAnnotation(JsonFilter.class);\n+        if (ann != null) {\n+            String id = ann.value();\n+            // Empty String is same as not having annotation, to allow overrides\n+            if (id.length() > 0) {\n+                return id;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Property auto-detection\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public VisibilityChecker<?> findAutoDetectVisibility(AnnotatedClass ac,\n+        VisibilityChecker<?> checker)\n+    {\n+        JsonAutoDetect ann = ac.getAnnotation(JsonAutoDetect.class);\n+        return (ann == null) ? checker : checker.with(ann);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* General member (field, method/constructor) annotations\n+    /**********************************************************\n+     */\n+\n+    // @since 1.6\n+    @Override        \n+    public ReferenceProperty findReferenceType(AnnotatedMember member)\n+    {\n+        JsonManagedReference ref1 = member.getAnnotation(JsonManagedReference.class);\n+        if (ref1 != null) {\n+            return AnnotationIntrospector.ReferenceProperty.managed(ref1.value());\n+        }\n+        JsonBackReference ref2 = member.getAnnotation(JsonBackReference.class);\n+        if (ref2 != null) {\n+            return AnnotationIntrospector.ReferenceProperty.back(ref2.value());\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Boolean shouldUnwrapProperty(AnnotatedMember member)\n+    {\n+        JsonUnwrapped ann = member.getAnnotation(JsonUnwrapped.class);\n+        // if not enabled, just means annotation is not enabled; not necessarily\n+        // that unwrapping should not be done (relevant when using chained introspectors)\n+        return (ann != null && ann.enabled()) ? Boolean.TRUE : null;\n+    }\n+\n+    @Override\n+    public boolean hasIgnoreMarker(AnnotatedMember m) {\n+        return _isIgnorable(m);\n+    }\n+\n+    @Override\n+    public Object findInjectableValueId(AnnotatedMember m)\n+    {\n+        JacksonInject ann = m.getAnnotation(JacksonInject.class);\n+        if (ann == null) {\n+            return null;\n+        }\n+        /* Empty String means that we should use name of declared\n+         * value class.\n+         */\n+        String id = ann.value();\n+        if (id.length() == 0) {\n+            // slight complication; for setters, type \n+            if (!(m instanceof AnnotatedMethod)) {\n+                return m.getRawType().getName();\n+            }\n+            AnnotatedMethod am = (AnnotatedMethod) m;\n+            if (am.getParameterCount() == 0) {\n+                return m.getRawType().getName();\n+            }\n+            return am.getParameterClass(0).getName();\n+        }\n+        return id;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Class annotations for PM type handling (1.5+)\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public TypeResolverBuilder<?> findTypeResolver(MapperConfig<?> config,\n+            AnnotatedClass ac, JavaType baseType)\n+    {\n+        return _findTypeResolver(config, ac, baseType);\n+    }\n+\n+    /**\n+     * Since 1.7, it is possible to use {@link JsonTypeInfo} from a property too.\n+     */\n+    @Override\n+    public TypeResolverBuilder<?> findPropertyTypeResolver(MapperConfig<?> config,\n+            AnnotatedMember am, JavaType baseType)\n+    {\n+        /* As per definition of @JsonTypeInfo, should only apply to contents of container\n+         * (collection, map) types, not container types themselves:\n+         */\n+        if (baseType.isContainerType()) return null;\n+        // No per-member type overrides (yet)\n+        return _findTypeResolver(config, am, baseType);\n+    }\n+\n+    /**\n+     * Since 1.7, it is possible to use {@link JsonTypeInfo} from a property too.\n+     */\n+    @Override\n+    public TypeResolverBuilder<?> findPropertyContentTypeResolver(MapperConfig<?> config,\n+            AnnotatedMember am, JavaType containerType)\n+    {\n+        /* First: let's ensure property is a container type: caller should have\n+         * verified but just to be sure\n+         */\n+        if (!containerType.isContainerType()) {\n+            throw new IllegalArgumentException(\"Must call method with a container type (got \"+containerType+\")\");\n+        }\n+        return _findTypeResolver(config, am, containerType);\n+    }\n+    \n+    @Override\n+    public List<NamedType> findSubtypes(Annotated a)\n+    {\n+        JsonSubTypes t = a.getAnnotation(JsonSubTypes.class);\n+        if (t == null) return null;\n+        JsonSubTypes.Type[] types = t.value();\n+        ArrayList<NamedType> result = new ArrayList<NamedType>(types.length);\n+        for (JsonSubTypes.Type type : types) {\n+            result.add(new NamedType(type.value(), type.name()));\n+        }\n+        return result;\n+    }\n+\n+    @Override        \n+    public String findTypeName(AnnotatedClass ac)\n+    {\n+        JsonTypeName tn = ac.getAnnotation(JsonTypeName.class);\n+        return (tn == null) ? null : tn.value();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* General method annotations\n+    /**********************************************************\n+    */\n+\n+    @Override\n+    public boolean isIgnorableMethod(AnnotatedMethod m) {\n+        return _isIgnorable(m);\n+    }\n+\n+    @Override\n+    public boolean isIgnorableConstructor(AnnotatedConstructor c) {\n+        return _isIgnorable(c);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* General field annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isIgnorableField(AnnotatedField f) {\n+        return _isIgnorable(f);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization: general annotations\n+    /**********************************************************\n+    */\n+\n+    @Override\n+    public Object findSerializer(Annotated a)\n+    {\n+        /* 21-May-2009, tatu: Slight change; primary annotation is now\n+         *    @JsonSerialize; @JsonUseSerializer is deprecated\n+         */\n+        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        if (ann != null) {\n+            Class<? extends JsonSerializer<?>> serClass = ann.using();\n+            if (serClass != JsonSerializer.None.class) {\n+                return serClass;\n+            }\n+        }\n+        \n+        /* 18-Oct-2010, tatu: [JACKSON-351] @JsonRawValue handled just here, for now;\n+         *  if we need to get raw indicator from other sources need to add\n+         *  separate accessor within {@link AnnotationIntrospector} interface.\n+         */\n+        JsonRawValue annRaw =  a.getAnnotation(JsonRawValue.class);\n+        if ((annRaw != null) && annRaw.value()) {\n+            // let's construct instance with nominal type:\n+            Class<?> cls = a.getRawType();\n+            return new RawSerializer<Object>(cls);\n+        }       \n+        return null;\n+    }\n+\n+    @Override\n+    public Class<? extends JsonSerializer<?>> findKeySerializer(Annotated a)\n+    {\n+        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        if (ann != null) {\n+            Class<? extends JsonSerializer<?>> serClass = ann.keyUsing();\n+            if (serClass != JsonSerializer.None.class) {\n+                return serClass;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Class<? extends JsonSerializer<?>> findContentSerializer(Annotated a)\n+    {\n+        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        if (ann != null) {\n+            Class<? extends JsonSerializer<?>> serClass = ann.contentUsing();\n+            if (serClass != JsonSerializer.None.class) {\n+                return serClass;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    @SuppressWarnings(\"deprecation\")\n+    @Override\n+    public JsonSerialize.Inclusion findSerializationInclusion(Annotated a, JsonSerialize.Inclusion defValue)\n+    {\n+        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        if (ann != null) {\n+            return ann.include();\n+        }\n+        /* 23-May-2009, tatu: Will still support now-deprecated (as of 1.1)\n+         *   legacy annotation too:\n+         */\n+        JsonWriteNullProperties oldAnn = a.getAnnotation(JsonWriteNullProperties.class);\n+        if (oldAnn != null) {\n+            boolean writeNulls = oldAnn.value();\n+            return writeNulls ? JsonSerialize.Inclusion.ALWAYS : JsonSerialize.Inclusion.NON_NULL;\n+        }\n+        return defValue;\n+    }\n+\n+    @Override\n+    public Class<?> findSerializationType(Annotated am)\n+    {\n+        JsonSerialize ann = am.getAnnotation(JsonSerialize.class);\n+        if (ann != null) {\n+            Class<?> cls = ann.as();\n+            if (cls != NoClass.class) {\n+                return cls;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Class<?> findSerializationKeyType(Annotated am, JavaType baseType)\n+    {\n+        JsonSerialize ann = am.getAnnotation(JsonSerialize.class);\n+        if (ann != null) {\n+            Class<?> cls = ann.keyAs();\n+            if (cls != NoClass.class) {\n+                return cls;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Class<?> findSerializationContentType(Annotated am, JavaType baseType)\n+    {\n+        JsonSerialize ann = am.getAnnotation(JsonSerialize.class);\n+        if (ann != null) {\n+            Class<?> cls = ann.contentAs();\n+            if (cls != NoClass.class) {\n+                return cls;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n+    public JsonSerialize.Typing findSerializationTyping(Annotated a)\n+    {\n+        JsonSerialize ann = a.getAnnotation(JsonSerialize.class);\n+        return (ann == null) ? null : ann.typing();\n+    }\n+\n+    @Override\n+    public Class<?>[] findSerializationViews(Annotated a)\n+    {\n+        JsonView ann = a.getAnnotation(JsonView.class);\n+        return (ann == null) ? null : ann.value();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Serialization: class annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n+        JsonPropertyOrder order = ac.getAnnotation(JsonPropertyOrder.class);\n+        return (order == null) ? null : order.value();\n+    }\n+\n+    @Override\n+    public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n+        JsonPropertyOrder order = ac.getAnnotation(JsonPropertyOrder.class);\n+        return (order == null) ? null : order.alphabetic();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization: method annotations\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"deprecation\")\n+    @Override\n+    public String findGettablePropertyName(AnnotatedMethod am)\n+    {\n+        /* 22-May-2009, tatu: JsonProperty is the primary annotation\n+         *   to check for\n+         */\n+        JsonProperty pann = am.getAnnotation(JsonProperty.class);\n+        if (pann != null) {\n+            return pann.value();\n+        }\n+        /* 22-May-2009, tatu: JsonGetter is deprecated as of 1.1\n+         *    but still supported\n+         */\n+        JsonGetter ann = am.getAnnotation(JsonGetter.class);\n+        if (ann != null) {\n+            return ann.value();\n+        }\n+        /* 22-May-2009, tatu: And finally, JsonSerialize implies\n+         *   that there is a property, although doesn't define name\n+         */\n+        // 09-Apr-2010, tatu: Ditto for JsonView\n+        if (am.hasAnnotation(JsonSerialize.class) || am.hasAnnotation(JsonView.class)) {\n+            return \"\";\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean hasAsValueAnnotation(AnnotatedMethod am)\n+    {\n+        JsonValue ann = am.getAnnotation(JsonValue.class);\n+        // value of 'false' means disabled...\n+        return (ann != null && ann.value());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization: field annotations\n+    /**********************************************************\n+    */\n+\n+    @Override\n+    public String findSerializablePropertyName(AnnotatedField af)\n+    {\n+        JsonProperty pann = af.getAnnotation(JsonProperty.class);\n+        if (pann != null) {\n+            return pann.value();\n+        }\n+        // Also: having JsonSerialize implies it is such a property\n+        // 09-Apr-2010, tatu: Ditto for JsonView\n+        if (af.hasAnnotation(JsonSerialize.class) || af.hasAnnotation(JsonView.class)) {\n+            return \"\";\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deserialization: general annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Class<? extends JsonDeserializer<?>> findDeserializer(Annotated a)\n+    {\n+        /* 21-May-2009, tatu: Slight change; primary annotation is now\n+         *    @JsonDeserialize; @JsonUseDeserializer is deprecated\n+         */\n+        JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class);\n+        if (ann != null) {\n+            Class<? extends JsonDeserializer<?>> deserClass = ann.using();\n+            if (deserClass != JsonDeserializer.None.class) {\n+                return deserClass;\n+            }\n+        }\n+        // 31-Jan-2010, tatus: @JsonUseDeserializer removed as of 1.5\n+        return null;\n+    }\n+\n+    @Override\n+    public Class<? extends KeyDeserializer> findKeyDeserializer(Annotated a)\n+    {\n+        JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class);\n+        if (ann != null) {\n+            Class<? extends KeyDeserializer> deserClass = ann.keyUsing();\n+            if (deserClass != KeyDeserializer.None.class) {\n+                return deserClass;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Class<? extends JsonDeserializer<?>> findContentDeserializer(Annotated a)\n+    {\n+        JsonDeserialize ann = a.getAnnotation(JsonDeserialize.class);\n+        if (ann != null) {\n+            Class<? extends JsonDeserializer<?>> deserClass = ann.contentUsing();\n+            if (deserClass != JsonDeserializer.None.class) {\n+                return deserClass;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Class<?> findDeserializationType(Annotated am, JavaType baseType,\n+            String propName)\n+    {\n+        // Primary annotation, JsonDeserialize\n+        JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class);\n+        if (ann != null) {\n+            Class<?> cls = ann.as();\n+            if (cls != NoClass.class) {\n+                return cls;\n+            }\n+        }\n+        /* 30-Jun-2011, tatu: Here we used to have support for @JsonClass;\n+         *    removed in 1.9\n+         */\n+        return null;\n+    }\n+\n+    @Override\n+    public Class<?> findDeserializationKeyType(Annotated am, JavaType baseKeyType,\n+            String propName)\n+    {\n+        // Primary annotation, JsonDeserialize\n+        JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class);\n+        if (ann != null) {\n+            Class<?> cls = ann.keyAs();\n+            if (cls != NoClass.class) {\n+                return cls;\n+            }\n+        }\n+        /* 30-Jun-2011, tatu: Here we used to have support for @JsonKeyClass;\n+         *    removed in 1.9\n+         */\n+        return null;\n+    }\n+\n+    @Override\n+    public Class<?> findDeserializationContentType(Annotated am, JavaType baseContentType,\n+            String propName)\n+    {\n+        // Primary annotation, JsonDeserialize\n+        JsonDeserialize ann = am.getAnnotation(JsonDeserialize.class);\n+        if (ann != null) {\n+            Class<?> cls = ann.contentAs();\n+            if (cls != NoClass.class) {\n+                return cls;\n+            }\n+        }\n+        /* 30-Jun-2011, tatu: Here we used to have support for @JsonContentClass;\n+         *    removed in 1.9\n+         */\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deserialization: Class annotations\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public Object findValueInstantiator(AnnotatedClass ac)\n+    {\n+        JsonValueInstantiator ann = ac.getAnnotation(JsonValueInstantiator.class);\n+        // no 'null' marker yet, so:\n+        return (ann == null) ? null : ann.value();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Deserialization: Method annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String findSettablePropertyName(AnnotatedMethod am)\n+    {\n+        /* 16-Apr-2010, tatu: Existing priority (since 1.1) is that\n+         *   @JsonProperty is checked first; and @JsonSetter next.\n+         *   This is not quite optimal now that @JsonSetter is un-deprecated.\n+         *   However, it is better to have stable behavior rather than\n+         *   cause compatibility problems by fine-tuning.\n+         */\n+        JsonProperty pann = am.getAnnotation(JsonProperty.class);\n+        if (pann != null) {\n+            return pann.value();\n+        }\n+        JsonSetter ann = am.getAnnotation(JsonSetter.class);\n+        if (ann != null) {\n+            return ann.value();\n+        }\n+        /* 22-May-2009, tatu: And finally, JsonSerialize implies\n+         *   that there is a property, although doesn't define name\n+         */\n+        // 09-Apr-2010, tatu: Ditto for JsonView\n+        // 19-Oct-2011, tatu: And JsonBackReference/JsonManagedReference\n+    \tif (am.hasAnnotation(JsonDeserialize.class)\n+    \t        || am.hasAnnotation(JsonView.class)\n+                || am.hasAnnotation(JsonBackReference.class)\n+                || am.hasAnnotation(JsonManagedReference.class)\n+    \t        ) {\n+            return \"\";\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean hasAnySetterAnnotation(AnnotatedMethod am)\n+    {\n+        /* No dedicated disabling; regular @JsonIgnore used\n+         * if needs to be ignored (and if so, is handled prior\n+         * to this method getting called)\n+         */\n+        return am.hasAnnotation(JsonAnySetter.class);\n+    }\n+\n+    @Override\n+    public boolean hasAnyGetterAnnotation(AnnotatedMethod am)\n+    {\n+        /* No dedicated disabling; regular @JsonIgnore used\n+         * if needs to be ignored (handled separately\n+         */\n+        return am.hasAnnotation(JsonAnyGetter.class);\n+    }\n+    \n+    @Override\n+    public boolean hasCreatorAnnotation(Annotated a)\n+    {\n+        /* No dedicated disabling; regular @JsonIgnore used\n+         * if needs to be ignored (and if so, is handled prior\n+         * to this method getting called)\n+         */\n+        return a.hasAnnotation(JsonCreator.class);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deserialization: field annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String findDeserializablePropertyName(AnnotatedField af)\n+    {\n+        JsonProperty pann = af.getAnnotation(JsonProperty.class);\n+        if (pann != null) {\n+            return pann.value();\n+        }\n+        // Also: having JsonDeserialize implies it is such a property\n+        // 09-Apr-2010, tatu: Ditto for JsonView\n+        if (af.hasAnnotation(JsonDeserialize.class)\n+                || af.hasAnnotation(JsonView.class)\n+                || af.hasAnnotation(JsonBackReference.class)\n+                || af.hasAnnotation(JsonManagedReference.class)\n+                ) {\n+            return \"\";\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Deserialization: parameters annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String findPropertyNameForParam(AnnotatedParameter param)\n+    {\n+        if (param != null) {\n+            JsonProperty pann = param.getAnnotation(JsonProperty.class);\n+            if (pann != null) {\n+                return pann.value();\n+            }\n+            /* And can not use JsonDeserialize as we can not use\n+             * name auto-detection (names of local variables including\n+             * parameters are not necessarily preserved in bytecode)\n+             */\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected boolean _isIgnorable(Annotated a)\n+    {\n+        JsonIgnore ann = a.getAnnotation(JsonIgnore.class);\n+        return (ann != null && ann.value());\n+    }\n+\n+    /**\n+     * Helper method called to construct and initialize instance of {@link TypeResolverBuilder}\n+     * if given annotated element indicates one is needed.\n+     */\n+    protected TypeResolverBuilder<?> _findTypeResolver(MapperConfig<?> config,\n+            Annotated ann, JavaType baseType)\n+    {\n+        // First: maybe we have explicit type resolver?\n+        TypeResolverBuilder<?> b;\n+        JsonTypeInfo info = ann.getAnnotation(JsonTypeInfo.class);\n+        JsonTypeResolver resAnn = ann.getAnnotation(JsonTypeResolver.class);\n+        if (resAnn != null) {\n+            /* 14-Aug-2010, tatu: not sure if this can ever happen normally, but unit\n+             *    tests were able to trigger this... so let's check:\n+             */\n+            if (info == null) {\n+                return null;\n+            }\n+            /* let's not try to force access override (would need to pass\n+             * settings through if we did, since that's not doable on some\n+             * platforms)\n+             */\n+            b = config.typeResolverBuilderInstance(ann, resAnn.value());\n+        } else { // if not, use standard one, if indicated by annotations\n+            if (info == null || info.use() == JsonTypeInfo.Id.NONE) {\n+                return null;\n+            }\n+            b = _constructStdTypeResolverBuilder();\n+        }\n+        // Does it define a custom type id resolver?\n+        JsonTypeIdResolver idResInfo = ann.getAnnotation(JsonTypeIdResolver.class);\n+        TypeIdResolver idRes = (idResInfo == null) ? null\n+                : config.typeIdResolverInstance(ann, idResInfo.value());\n+        if (idRes != null) { // [JACKSON-359]\n+            idRes.init(baseType);\n+        }\n+        b = b.init(info.use(), idRes);\n+        /* 13-Aug-2011, tatu: One complication wrt [JACKSON-453]; external id\n+         *   only works for properties; so if declared for a Class, we will need\n+         *   to map it to \"PROPERTY\" instead of \"EXTERNAL_PROPERTY\"\n+         */\n+        JsonTypeInfo.As inclusion = info.include();\n+        if (inclusion == JsonTypeInfo.As.EXTERNAL_PROPERTY && (ann instanceof AnnotatedClass)) {\n+            inclusion = JsonTypeInfo.As.PROPERTY;\n+        }\n+        b = b.inclusion(inclusion);\n+        b = b.typeProperty(info.property());\n+        Class<?> defaultImpl = info.defaultImpl();\n+        if (defaultImpl != JsonTypeInfo.None.class) {\n+            b = b.defaultImpl(defaultImpl);\n+        }\n+        return b;\n+    }\n+\n+    /**\n+     * Helper method for constructing standard {@link TypeResolverBuilder}\n+     * implementation.\n+     * \n+     * @since 1.7\n+     */\n+    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder()\n+    {\n+        return new StdTypeResolverBuilder();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/MemberKey.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Helper class needed to be able to efficiently access class\n+ * member functions ({@link Method}s and {@link Constructor}s)\n+ * in {@link java.util.Map}s.\n+ */\n+public final class MemberKey\n+{\n+    final static Class<?>[] NO_CLASSES = new Class<?>[0];\n+\n+    final String _name;\n+    final Class<?>[] _argTypes;\n+\n+    public MemberKey(Method m)\n+    {\n+        this(m.getName(), m.getParameterTypes());\n+    }\n+\n+    public MemberKey(Constructor<?> ctor)\n+    {\n+        this(\"\", ctor.getParameterTypes());\n+    }\n+\n+    public MemberKey(String name, Class<?>[] argTypes)\n+    {\n+        _name = name;\n+        _argTypes = (argTypes == null) ? NO_CLASSES : argTypes;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return _name + \"(\" + _argTypes.length+\"-args)\";\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return _name.hashCode() + _argTypes.length;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) {\n+            return false;\n+        }\n+        MemberKey other = (MemberKey) o;\n+        if (!_name.equals(other._name)) {\n+            return false;\n+        }\n+        Class<?>[] otherArgs = other._argTypes;\n+        int len = _argTypes.length;\n+        if (otherArgs.length != len) {\n+            return false;\n+        }\n+        for (int i = 0; i < len; ++i) {\n+            Class<?> type1 = otherArgs[i];\n+            Class<?> type2 = _argTypes[i];\n+            if (type1 == type2) {\n+                continue;\n+            }\n+            /* 23-Feb-2009, tatu: Are there any cases where we would have to\n+             *   consider some narrowing conversions or such? For now let's\n+             *   assume exact type match is enough\n+             */\n+            /* 07-Apr-2009, tatu: Indeed there are (see [JACKSON-97]).\n+             *    This happens with generics when a bound is specified.\n+             *    I hope this works; check here must be transitive\n+             */\n+            if (type1.isAssignableFrom(type2) || type2.isAssignableFrom(type1)) {\n+                continue;\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/MethodFilter.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Simple interface that defines API used to filter out irrelevant\n+ * methods\n+ */\n+public interface MethodFilter\n+{\n+    public boolean includeMethod(Method m);\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/NopAnnotationIntrospector.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.lang.annotation.Annotation;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.KeyDeserializer;\n+import com.fasterxml.jackson.databind.annotate.JsonSerialize.Typing;\n+\n+/**\n+ * Dummy, \"no-operation\" implementation of {@link AnnotationIntrospector}.\n+ * Can be used as is to suppress handling of annotations; or as a basis\n+ * for simple complementary annotators\n+ */\n+public class NopAnnotationIntrospector\n+    extends AnnotationIntrospector\n+{\n+    /**\n+     * Static immutable and shareable instance that can be used as\n+     * \"null\" introspector: one that never finds any annotation\n+     * information.\n+     */\n+    public final static NopAnnotationIntrospector instance = new NopAnnotationIntrospector();\n+\n+    /*\n+    /**********************************************************\n+    /* General annotation properties\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isHandled(Annotation ann) {\n+        return false;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* General annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String findEnumValue(Enum<?> value) {\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* General Class annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String findRootName(AnnotatedClass ac) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String[] findPropertiesToIgnore(AnnotatedClass ac) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Boolean findIgnoreUnknownProperties(AnnotatedClass ac) {\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* General member (field, method/constructor) annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean hasIgnoreMarker(AnnotatedMember member) {\n+        return false;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* General Method annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isIgnorableConstructor(AnnotatedConstructor c) {\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean isIgnorableMethod(AnnotatedMethod m) {\n+        return false;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* General field annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isIgnorableField(AnnotatedField f) {\n+        return false;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization: general annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Object findSerializer(Annotated am) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Class<?> findSerializationType(Annotated a) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Typing findSerializationTyping(Annotated a) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Class<?>[] findSerializationViews(Annotated a) {\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization: class annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String[] findSerializationPropertyOrder(AnnotatedClass ac) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Boolean findSerializationSortAlphabetically(AnnotatedClass ac) {\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serialization: method annotations\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String findGettablePropertyName(AnnotatedMethod am) {\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean hasAsValueAnnotation(AnnotatedMethod am) {\n+        return false;\n+    }\n+    \n+    @Override\n+    public String findDeserializablePropertyName(AnnotatedField af) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Class<?> findDeserializationContentType(Annotated am, JavaType t, String propName) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Class<?> findDeserializationKeyType(Annotated am, JavaType t, String propName) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Class<?> findDeserializationType(Annotated am, JavaType t, String propName) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Object findDeserializer(Annotated am) { return null; }\n+\n+    @Override\n+    public Class<KeyDeserializer> findKeyDeserializer(Annotated am) { return null; }\n+\n+    @Override\n+    public Class<JsonDeserializer<?>> findContentDeserializer(Annotated am) { return null; }\n+\n+\n+    @Override\n+    public String findPropertyNameForParam(AnnotatedParameter param) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String findSerializablePropertyName(AnnotatedField af) {\n+        return null;\n+    }\n+    \n+    @Override\n+    public String findSettablePropertyName(AnnotatedMethod am) {\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertiesCollector.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import java.util.*;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.util.BeanUtil;\n+\n+/**\n+ * Helper class used for aggregating information about all possible\n+ * properties of a POJO.\n+ * \n+ * @since 1.9\n+ */\n+public class POJOPropertiesCollector\n+{\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Configuration settings\n+     */\n+    protected final MapperConfig<?> _config;\n+\n+    /**\n+     * True if introspection is done for serialization (giving\n+     *   precedence for serialization annotations), or not (false, deserialization)\n+     */\n+    protected final boolean _forSerialization;\n+    \n+    /**\n+     * Type of POJO for which properties are being collected.\n+     */\n+    protected final JavaType _type;\n+\n+    /**\n+     * Low-level introspected class information (methods, fields etc)\n+     */\n+    protected final AnnotatedClass _classDef;\n+\n+    protected final VisibilityChecker<?> _visibilityChecker;\n+\n+    protected final AnnotationIntrospector _annotationIntrospector;\n+    \n+    /*\n+    /**********************************************************\n+    /* Collected information\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Set of logical property information collected so far\n+     */\n+    protected final LinkedHashMap<String, POJOPropertyBuilder> _properties\n+        = new LinkedHashMap<String, POJOPropertyBuilder>();\n+\n+    protected LinkedList<POJOPropertyBuilder> _creatorProperties = null;\n+    \n+    protected LinkedList<AnnotatedMethod> _anyGetters = null;\n+\n+    protected LinkedList<AnnotatedMethod> _anySetters = null;\n+\n+    /**\n+     * Method(s) marked with 'JsonValue' annotation\n+     */\n+    protected LinkedList<AnnotatedMethod> _jsonValueGetters = null;\n+\n+    /**\n+     * Lazily collected list of properties that can be implicitly\n+     * ignored during serialization; only updated when collecting\n+     * information for deserialization purposes\n+     */\n+    protected HashSet<String> _ignoredPropertyNames;\n+\n+    /**\n+     * Lazily collected list of members that were annotated to\n+     * indicate that they represent mutators for deserializer\n+     * value injection.\n+     */\n+    protected LinkedHashMap<Object, AnnotatedMember> _injectables;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    protected POJOPropertiesCollector(MapperConfig<?> config, boolean forSerialization,\n+            JavaType type, AnnotatedClass classDef)\n+    {\n+        _config = config;\n+        _forSerialization = forSerialization;\n+        _type = type;\n+        _classDef = classDef;\n+        _annotationIntrospector = config.isAnnotationProcessingEnabled() ?\n+                _config.getAnnotationIntrospector() : null;\n+        if (_annotationIntrospector == null) {\n+            _visibilityChecker = _config.getDefaultVisibilityChecker();\n+        } else {\n+            _visibilityChecker = _annotationIntrospector.findAutoDetectVisibility(classDef,\n+                    _config.getDefaultVisibilityChecker());\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    public MapperConfig<?> getConfig() {\n+        return _config;\n+    }\n+\n+    public JavaType getType() {\n+        return _type;\n+    }\n+    \n+    public AnnotatedClass getClassDef() {\n+        return _classDef;\n+    }\n+\n+    public AnnotationIntrospector getAnnotationIntrospector() {\n+        return _annotationIntrospector;\n+    }\n+    \n+    public List<BeanPropertyDefinition> getProperties() {\n+        // make sure we return a copy, so caller can remove entries if need be:\n+        return new ArrayList<BeanPropertyDefinition>(_properties.values());\n+    }\n+\n+    public Map<Object, AnnotatedMember> getInjectables() {\n+        return _injectables;\n+    }\n+    \n+    public AnnotatedMethod getJsonValueMethod()\n+    {\n+        // If @JsonValue defined, must have a single one\n+        if (_jsonValueGetters != null) {\n+            if (_jsonValueGetters.size() > 1) {\n+                reportProblem(\"Multiple value properties defined (\"+_jsonValueGetters.get(0)+\" vs \"\n+                        +_jsonValueGetters.get(1)+\")\");\n+            }\n+            // otherwise we won't greatly care\n+            return _jsonValueGetters.get(0);\n+        }\n+        return null;\n+    }\n+\n+    public AnnotatedMethod getAnyGetterMethod()\n+    {\n+        if (_anyGetters != null) {\n+            if (_anyGetters.size() > 1) {\n+                reportProblem(\"Multiple 'any-getters' defined (\"+_anyGetters.get(0)+\" vs \"\n+                        +_anyGetters.get(1)+\")\");\n+            }\n+            return _anyGetters.getFirst();\n+        }        \n+        return null;\n+    }\n+\n+    public AnnotatedMethod getAnySetterMethod()\n+    {\n+        if (_anySetters != null) {\n+            if (_anySetters.size() > 1) {\n+                reportProblem(\"Multiple 'any-setters' defined (\"+_anySetters.get(0)+\" vs \"\n+                        +_anySetters.get(1)+\")\");\n+            }\n+            return _anySetters.getFirst();\n+        }\n+        return null;\n+    }\n+\n+    public Set<String> getIgnoredPropertyNames() {\n+        return _ignoredPropertyNames;\n+    }\n+    \n+    // for unit tests:\n+    protected Map<String, POJOPropertyBuilder> getPropertyMap() {\n+        return _properties;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API: main-level collection\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that orchestrates collection activities, and needs to be called\n+     * after creating the instance.\n+     */\n+    public POJOPropertiesCollector collect()\n+    {\n+        _properties.clear();\n+        \n+        // First: gather basic data\n+        _addFields();\n+        _addMethods();\n+        _addCreators();\n+        _addInjectables();\n+\n+        // Remove ignored properties, individual entries\n+        _removeUnwantedProperties();\n+\n+        // Rename remaining properties\n+        _renameProperties();\n+        // And use custom naming strategy, if applicable...\n+        PropertyNamingStrategy naming = _config.getPropertyNamingStrategy();\n+        if (naming != null) {\n+            _renameUsing(naming);\n+        }\n+\n+        /* Sort by visibility (explicit over implicit); drop all but first\n+         * of member type (getter, setter etc) if there is visibility\n+         * difference\n+         */\n+        for (POJOPropertyBuilder property : _properties.values()) {\n+            property.trimByVisibility();\n+        }\n+\n+        // and then the final step, \"merge\" annotations\n+        for (POJOPropertyBuilder property : _properties.values()) {\n+            property.mergeAnnotations(_forSerialization);\n+        }\n+\n+        // well, almost last: there's still ordering...\n+        _sortProperties();\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable internal methods, sorting\n+    /**********************************************************\n+     */\n+    \n+    /* First, order by [JACKSON-90] (explicit ordering and/or alphabetic)\n+     * and then for [JACKSON-170] (implicitly order creator properties before others)\n+     */\n+    protected void _sortProperties()\n+    {\n+        // Then how about explicit ordering?\n+        AnnotationIntrospector intr = _config.getAnnotationIntrospector();\n+        boolean sort;\n+        Boolean alpha = intr.findSerializationSortAlphabetically(_classDef);\n+        \n+        if (alpha == null) {\n+            sort = _config.shouldSortPropertiesAlphabetically();\n+        } else {\n+            sort = alpha.booleanValue();\n+        }\n+        String[] propertyOrder = intr.findSerializationPropertyOrder(_classDef);\n+        \n+        // no sorting? no need to shuffle, then\n+        if (!sort && (_creatorProperties == null) && (propertyOrder == null)) {\n+            return;\n+        }\n+        int size = _properties.size();\n+        Map<String, POJOPropertyBuilder> all;\n+        // Need to (re)sort alphabetically?\n+        if (sort) {\n+            all = new TreeMap<String,POJOPropertyBuilder>();\n+        } else {\n+            all = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n+        }\n+\n+        for (POJOPropertyBuilder prop : _properties.values()) {\n+            all.put(prop.getName(), prop);\n+        }\n+        Map<String,POJOPropertyBuilder> ordered = new LinkedHashMap<String,POJOPropertyBuilder>(size+size);\n+        // Ok: primarily by explicit order\n+        if (propertyOrder != null) {\n+            for (String name : propertyOrder) {\n+                POJOPropertyBuilder w = all.get(name);\n+                if (w == null) { // also, as per [JACKSON-268], we will allow use of \"implicit\" names\n+                    for (POJOPropertyBuilder prop : _properties.values()) {\n+                        if (name.equals(prop.getInternalName())) {\n+                            w = prop;\n+                            // plus re-map to external name, to avoid dups:\n+                            name = prop.getName();\n+                            break;\n+                        }\n+                    }\n+                }\n+                if (w != null) {\n+                    ordered.put(name, w);\n+                }\n+            }\n+        }\n+        // And secondly by sorting Creator properties before other unordered properties\n+        if (_creatorProperties != null) {\n+            for (POJOPropertyBuilder prop : _creatorProperties) {\n+                ordered.put(prop.getName(), prop);\n+            }\n+        }\n+        // And finally whatever is left (trying to put again will not change ordering)\n+        ordered.putAll(all);\n+        \n+        _properties.clear();\n+        _properties.putAll(ordered);\n+    }        \n+\n+    /*\n+    /**********************************************************\n+    /* Overridable internal methods, adding members\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for collecting basic information on all fields found\n+     */\n+    protected void _addFields()\n+    {\n+        final AnnotationIntrospector ai = _annotationIntrospector;\n+        \n+        for (AnnotatedField f : _classDef.fields()) {\n+            String implName = f.getName();\n+\n+            String explName;\n+            if (ai == null) {\n+                explName = null;\n+            } else if (_forSerialization) {\n+                /* 18-Aug-2011, tatu: As per existing unit tests, we should only\n+                 *   use serialization annotation (@JsonSerializer) when serializing\n+                 *   fields, and similarly for deserialize-only annotations... so\n+                 *   no fallbacks in this particular case.\n+                 */\n+                explName = ai.findSerializablePropertyName(f);\n+            } else {\n+                explName = ai.findDeserializablePropertyName(f);\n+            }\n+            if (\"\".equals(explName)) { // empty String meaning \"use default name\", here just means \"same as field name\"\n+                explName = implName;\n+            }\n+            // having explicit name means that field is visible; otherwise need to check the rules\n+            boolean visible = (explName != null);\n+            if (!visible) {\n+                visible = _visibilityChecker.isFieldVisible(f);\n+            }\n+            // and finally, may also have explicit ignoral\n+            boolean ignored = (ai != null) && ai.hasIgnoreMarker(f);\n+            _property(implName).addField(f, explName, visible, ignored);\n+        }\n+    }\n+\n+    /**\n+     * Method for collecting basic information on constructor(s) found\n+     */\n+    protected void _addCreators()\n+    {\n+        final AnnotationIntrospector ai = _annotationIntrospector;\n+        // can be null if annotation processing is disabled...\n+        if (ai == null) {\n+            return;\n+        }\n+        for (AnnotatedConstructor ctor : _classDef.getConstructors()) {\n+            if (_creatorProperties == null) {\n+                _creatorProperties = new LinkedList<POJOPropertyBuilder>();\n+            }\n+            for (int i = 0, len = ctor.getParameterCount(); i < len; ++i) {\n+                AnnotatedParameter param = ctor.getParameter(i);\n+                String name = ai.findPropertyNameForParam(param);\n+                // is it legal not to have name?\n+                if (name != null) {\n+                    // shouldn't need to worry about @JsonIgnore (no real point, so)\n+                    POJOPropertyBuilder prop = _property(name);\n+                    prop.addCtor(param, name, true, false);\n+                    _creatorProperties.add(prop);\n+                }\n+            }\n+        }\n+        for (AnnotatedMethod factory : _classDef.getStaticMethods()) {\n+            if (_creatorProperties == null) {\n+                _creatorProperties = new LinkedList<POJOPropertyBuilder>();\n+            }\n+            for (int i = 0, len = factory.getParameterCount(); i < len; ++i) {\n+                AnnotatedParameter param = factory.getParameter(i);\n+                String name = ai.findPropertyNameForParam(param);\n+                // is it legal not to have name?\n+                if (name != null) {\n+                    // shouldn't need to worry about @JsonIgnore (no real point, so)\n+                    POJOPropertyBuilder prop = _property(name);\n+                    prop.addCtor(param, name, true, false);\n+                    _creatorProperties.add(prop);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method for collecting basic information on all fields found\n+     */\n+    protected void _addMethods()\n+    {\n+        final AnnotationIntrospector ai = _annotationIntrospector;\n+        \n+        for (AnnotatedMethod m : _classDef.memberMethods()) {\n+            String explName; // from annotation(s)\n+            String implName; // from naming convention\n+            \n+            /* For methods, handling differs between getters and setters; and\n+             * we will also only consider entries that either follow the bean\n+             * naming convention or are explicitly marked: just being visible\n+             * is not enough (unlike with fields)\n+             */\n+            int argCount = m.getParameterCount();\n+            boolean visible;\n+            \n+            if (argCount == 0) { // getters (including 'any getter')\n+                // any getter?\n+                if (ai != null) {\n+                    if (ai.hasAnyGetterAnnotation(m)) {\n+                        if (_anyGetters == null) {\n+                            _anyGetters = new LinkedList<AnnotatedMethod>();\n+                        }\n+                        _anyGetters.add(m);\n+                        continue;\n+                    }\n+                    // @JsonValue?\n+                    if (ai.hasAsValueAnnotation(m)) {\n+                        if (_jsonValueGetters == null) {\n+                            _jsonValueGetters = new LinkedList<AnnotatedMethod>();\n+                        }\n+                        _jsonValueGetters.add(m);\n+                        continue;\n+                    }\n+                }\n+                \n+                explName = (ai == null) ? null : ai.findGettablePropertyName(m);\n+                if (explName == null) { // no explicit name; must follow naming convention\n+                    implName = BeanUtil.okNameForRegularGetter(m, m.getName());\n+                    if (implName == null) { // if not, must skip\n+                        implName = BeanUtil.okNameForIsGetter(m, m.getName());\n+                        if (implName == null) {\n+                            continue;\n+                        }\n+                        visible = _visibilityChecker.isIsGetterVisible(m);\n+                    } else {\n+                        visible = _visibilityChecker.isGetterVisible(m);\n+                    }\n+                } else { // explicit indication of inclusion, but may be empty\n+                    // we still need implicit name to link with other pieces\n+                    implName = BeanUtil.okNameForGetter(m);\n+                    // if not regular getter name, use method name as is\n+                    if (implName == null) {\n+                        implName = m.getName();\n+                    }\n+                    if (explName.length() == 0) {\n+                        explName = implName;\n+                    }\n+                    visible = true;\n+                }\n+                boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n+                _property(implName).addGetter(m, explName, visible, ignore);\n+            } else if (argCount == 1) { // setters\n+                explName = (ai == null) ? null : ai.findSettablePropertyName(m);\n+                if (explName == null) { // no explicit name; must follow naming convention\n+                    implName = BeanUtil.okNameForSetter(m);\n+                    if (implName == null) { // if not, must skip\n+                        continue;\n+                    }\n+                    visible = _visibilityChecker.isSetterVisible(m);\n+                } else { // explicit indication of inclusion, but may be empty\n+                    // we still need implicit name to link with other pieces\n+                    implName = BeanUtil.okNameForSetter(m);\n+                    // if not regular getter name, use method name as is\n+                    if (implName == null) {\n+                        implName = m.getName();\n+                    }\n+                    if (explName.length() == 0) { \n+                        explName = implName;\n+                    }\n+                    visible = true;\n+                }\n+                boolean ignore = (ai == null) ? false : ai.hasIgnoreMarker(m);\n+                _property(implName).addSetter(m, explName, visible, ignore);\n+\n+            } else if (argCount == 2) { // any getter?\n+                if (ai != null  && ai.hasAnySetterAnnotation(m)) {\n+                    if (_anySetters == null) {\n+                        _anySetters = new LinkedList<AnnotatedMethod>();\n+                    }\n+                    _anySetters.add(m);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void _addInjectables()\n+    {\n+        final AnnotationIntrospector ai = _annotationIntrospector;\n+        if (ai == null) {\n+            return;\n+        }\n+        \n+        // first fields, then methods\n+        for (AnnotatedField f : _classDef.fields()) {\n+            _doAddInjectable(ai.findInjectableValueId(f), f);\n+        }\n+        \n+        for (AnnotatedMethod m : _classDef.memberMethods()) {\n+            /* for now, only allow injection of a single arg\n+             * (to be changed in future)\n+             */\n+            if (m.getParameterCount() != 1) {\n+                continue;\n+            }\n+            _doAddInjectable(ai.findInjectableValueId(m), m);\n+        }\n+    }\n+\n+    protected void _doAddInjectable(Object id, AnnotatedMember m)\n+    {\n+        if (id == null) {\n+            return;\n+        }\n+        if (_injectables == null) {\n+            _injectables = new LinkedHashMap<Object, AnnotatedMember>();\n+        }\n+        AnnotatedMember prev = _injectables.put(id, m);\n+        if (prev != null) {\n+            String type = (id == null) ? \"[null]\" : id.getClass().getName();\n+            throw new IllegalArgumentException(\"Duplicate injectable value with id '\"\n+                    +String.valueOf(id)+\"' (of type \"+type+\")\");\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods; removing ignored properties\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to get rid of candidate properties that are marked\n+     * as ignored, or that are not visible.\n+     */\n+    protected void _removeUnwantedProperties()\n+    {\n+        Iterator<Map.Entry<String,POJOPropertyBuilder>> it = _properties.entrySet().iterator();\n+        while (it.hasNext()) {\n+            Map.Entry<String, POJOPropertyBuilder> entry = it.next();\n+            POJOPropertyBuilder prop = entry.getValue();\n+\n+            // First: if nothing visible, just remove altogether\n+            if (!prop.anyVisible()) {\n+                it.remove();\n+                continue;\n+            }\n+            // Otherwise, check ignorals\n+            if (prop.anyIgnorals()) {\n+                // first: if one or more ignorals, and no explicit markers, remove the whole thing\n+                if (!prop.anyExplicitNames()) {\n+                    it.remove();\n+                    _addIgnored(prop.getName());\n+                    continue;\n+                }\n+                // otherwise just remove ones marked to be ignored\n+                prop.removeIgnored();\n+                if (!_forSerialization && !prop.couldDeserialize()) {\n+                    _addIgnored(prop.getName());\n+                }\n+            }\n+            // and finally, handle removal of individual non-visible elements\n+            prop.removeNonVisible();\n+        }\n+    }\n+    \n+    private void _addIgnored(String name)\n+    {\n+        if (!_forSerialization) {\n+            if (_ignoredPropertyNames == null) {\n+                _ignoredPropertyNames = new HashSet<String>();\n+            }\n+            _ignoredPropertyNames.add(name);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods; renaming properties\n+    /**********************************************************\n+     */\n+\n+    protected void _renameProperties()\n+    {\n+        // With renaming need to do in phases: first, find properties to rename\n+        Iterator<Map.Entry<String,POJOPropertyBuilder>> it = _properties.entrySet().iterator();\n+        LinkedList<POJOPropertyBuilder> renamed = null;\n+        while (it.hasNext()) {\n+            Map.Entry<String, POJOPropertyBuilder> entry = it.next();\n+            POJOPropertyBuilder prop = entry.getValue();\n+            String newName = prop.findNewName();\n+            if (newName != null) {\n+                if (renamed == null) {\n+                    renamed = new LinkedList<POJOPropertyBuilder>();\n+                }\n+                prop = prop.withName(newName);\n+                renamed.add(prop);\n+                it.remove();\n+            }\n+        }\n+        \n+        // and if any were renamed, merge back in...\n+        if (renamed != null) {\n+            for (POJOPropertyBuilder prop : renamed) {\n+                String name = prop.getName();\n+                POJOPropertyBuilder old = _properties.get(name);\n+                if (old == null) {\n+                    _properties.put(name, prop);\n+                } else {\n+                    old.addAll(prop);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void _renameUsing(PropertyNamingStrategy naming)\n+    {\n+        POJOPropertyBuilder[] props = _properties.values().toArray(new POJOPropertyBuilder[_properties.size()]);\n+        _properties.clear();\n+        for (POJOPropertyBuilder prop : props) {\n+            String name = prop.getName();\n+            if (_forSerialization) {\n+                if (prop.hasGetter()) {\n+                    name = naming.nameForGetterMethod(_config, prop.getGetter(), name);\n+                } else if (prop.hasField()) {\n+                    name = naming.nameForField(_config, prop.getField(), name);\n+                }\n+            } else {\n+                if (prop.hasSetter()) {\n+                    name = naming.nameForSetterMethod(_config, prop.getSetter(), name);\n+                } else if (prop.hasConstructorParameter()) {\n+                    name = naming.nameForConstructorParameter(_config, prop.getConstructorParameter(), name);\n+                } else if (prop.hasField()) {\n+                    name = naming.nameForField(_config, prop.getField(), name);\n+                } else if (prop.hasGetter()) {\n+                    /* Plus, when getter-as-setter is used, need to convert that too..\n+                     * (should we verify that's enabled? For now, assume it's ok always)\n+                     */\n+                    name = naming.nameForGetterMethod(_config, prop.getGetter(), name);\n+                }\n+            }\n+            if (!name.equals(prop.getName())) {\n+                prop = prop.withName(name);\n+            }\n+            /* As per [JACKSON-687], need to consider case where there may already be\n+             * something in there...\n+             */\n+            POJOPropertyBuilder old = _properties.get(name);\n+            if (old == null) {\n+                _properties.put(name, prop);\n+            } else {\n+                old.addAll(prop);\n+            }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods; helpers\n+    /**********************************************************\n+     */\n+\n+    protected void reportProblem(String msg) {\n+        throw new IllegalArgumentException(\"Problem with definition of \"+_classDef+\": \"+msg);\n+    }\n+    \n+    protected POJOPropertyBuilder _property(String implName)\n+    {\n+        POJOPropertyBuilder prop = _properties.get(implName);\n+        if (prop == null) {\n+            prop = new POJOPropertyBuilder(implName);\n+            _properties.put(implName, prop);\n+        }\n+        return prop;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/POJOPropertyBuilder.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import com.fasterxml.jackson.databind.BeanPropertyDefinition;\n+\n+/**\n+ * Helper class used for aggregating information about a single\n+ * potential POJO property.\n+ * \n+ * @since 1.9\n+ */\n+public class POJOPropertyBuilder\n+    extends BeanPropertyDefinition\n+    implements Comparable<POJOPropertyBuilder>\n+{\n+    /**\n+     * External name of logical property; may change with\n+     * renaming (by new instance being constructed using\n+     * a new name)\n+     */\n+    protected final String _name;\n+\n+    /**\n+     * Original internal name, derived from accessor, of this\n+     * property. Will not be changed by renaming.\n+     */\n+    protected final String _internalName;\n+\n+    protected Node<AnnotatedField> _fields;\n+    \n+    protected Node<AnnotatedParameter> _ctorParameters;\n+    \n+    protected Node<AnnotatedMethod> _getters;\n+\n+    protected Node<AnnotatedMethod> _setters;\n+\n+    public POJOPropertyBuilder(String internalName)\n+    {\n+        _internalName = internalName;\n+        _name = internalName;\n+    }\n+\n+    public POJOPropertyBuilder(POJOPropertyBuilder src, String newName)\n+    {\n+        _internalName = src._internalName;\n+        _name = newName;\n+        _fields = src._fields;\n+        _ctorParameters = src._ctorParameters;\n+        _getters = src._getters;\n+        _setters = src._setters;\n+    }\n+\n+    /**\n+     * Method for constructing a renamed instance\n+     */\n+    public POJOPropertyBuilder withName(String newName) {\n+        return new POJOPropertyBuilder(this, newName);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Comparable implementation: sort alphabetically, except\n+    /* that properties with constructor parameters sorted\n+    /* before other properties\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public int compareTo(POJOPropertyBuilder other)\n+    {\n+        // first, if one has ctor params, that should come first:\n+        if (_ctorParameters != null) {\n+            if (other._ctorParameters == null) {\n+                return -1;\n+            }\n+        } else if (other._ctorParameters != null) {\n+            return 1;\n+        }\n+        /* otherwise sort by external name (including sorting of\n+         * ctor parameters)\n+         */\n+        return getName().compareTo(other.getName());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* BeanPropertyDefinition implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String getName() { return _name; }\n+\n+    @Override\n+    public String getInternalName() { return _internalName; }\n+    \n+    @Override\n+    public boolean hasGetter() { return _getters != null; }\n+\n+    @Override\n+    public boolean hasSetter() { return _setters != null; }\n+\n+    @Override\n+    public boolean hasField() { return _fields != null; }\n+\n+    @Override\n+    public boolean hasConstructorParameter() { return _ctorParameters != null; }\n+\n+    @Override\n+    public AnnotatedMember getAccessor()\n+    {\n+        AnnotatedMember m = getGetter();\n+        if (m == null) {\n+            m = getField();\n+        }\n+        return m;\n+    }\n+\n+    @Override\n+    public AnnotatedMember getMutator()\n+    {\n+        AnnotatedMember m = getConstructorParameter();\n+        if (m == null) {\n+            m = getSetter();\n+            if (m == null) {\n+                m = getField();\n+            }\n+        }\n+        return m;\n+    }\n+\n+    @Override\n+    public boolean couldSerialize() {\n+        return (_getters != null) || (_fields != null);\n+    }\n+\n+    @Override\n+    public AnnotatedMethod getGetter()\n+    {\n+        if (_getters == null) {\n+            return null;\n+        }\n+        // If multiple, verify that they do not conflict...\n+        AnnotatedMethod getter = _getters.value;\n+        Node<AnnotatedMethod> next = _getters.next;\n+        for (; next != null; next = next.next) {\n+            /* [JACKSON-255] Allow masking, i.e. report exception only if\n+             *   declarations in same class, or there's no inheritance relationship\n+             *   (sibling interfaces etc)\n+             */\n+            AnnotatedMethod nextGetter = next.value;\n+            Class<?> getterClass = getter.getDeclaringClass();\n+            Class<?> nextClass = nextGetter.getDeclaringClass();\n+            if (getterClass != nextClass) {\n+                if (getterClass.isAssignableFrom(nextClass)) { // next is more specific\n+                    getter = nextGetter;\n+                    continue;\n+                }\n+                if (nextClass.isAssignableFrom(getterClass)) { // getter more specific\n+                    continue;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Conflicting getter definitions for property \\\"\"+getName()+\"\\\": \"\n+                    +getter.getFullName()+\" vs \"+nextGetter.getFullName());\n+        }\n+        return getter;\n+    }\n+\n+    @Override\n+    public AnnotatedMethod getSetter()\n+    {\n+        if (_setters == null) {\n+            return null;\n+        }\n+        // If multiple, verify that they do not conflict...\n+        AnnotatedMethod setter = _setters.value;\n+        Node<AnnotatedMethod> next = _setters.next;\n+        for (; next != null; next = next.next) {\n+            /* [JACKSON-255] Allow masking, i.e. report exception only if\n+             *   declarations in same class, or there's no inheritance relationship\n+             *   (sibling interfaces etc)\n+             */\n+            AnnotatedMethod nextSetter = next.value;\n+            Class<?> setterClass = setter.getDeclaringClass();\n+            Class<?> nextClass = nextSetter.getDeclaringClass();\n+            if (setterClass != nextClass) {\n+                if (setterClass.isAssignableFrom(nextClass)) { // next is more specific\n+                    setter = nextSetter;\n+                    continue;\n+                }\n+                if (nextClass.isAssignableFrom(setterClass)) { // getter more specific\n+                    continue;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Conflicting setter definitions for property \\\"\"+getName()+\"\\\": \"\n+                    +setter.getFullName()+\" vs \"+nextSetter.getFullName());\n+        }\n+        return setter;\n+    }\n+\n+    @Override\n+    public AnnotatedField getField()\n+    {\n+        if (_fields == null) {\n+            return null;\n+        }\n+        // If multiple, verify that they do not conflict...\n+        AnnotatedField field = _fields.value;\n+        Node<AnnotatedField> next = _fields.next;\n+        for (; next != null; next = next.next) {\n+            AnnotatedField nextField = next.value;\n+            Class<?> fieldClass = field.getDeclaringClass();\n+            Class<?> nextClass = nextField.getDeclaringClass();\n+            if (fieldClass != nextClass) {\n+                if (fieldClass.isAssignableFrom(nextClass)) { // next is more specific\n+                    field = nextField;\n+                    continue;\n+                }\n+                if (nextClass.isAssignableFrom(fieldClass)) { // getter more specific\n+                    continue;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"Multiple fields representing property \\\"\"+getName()+\"\\\": \"\n+                    +field.getFullName()+\" vs \"+nextField.getFullName());\n+        }\n+        return field;\n+    }\n+\n+    @Override\n+    public AnnotatedParameter getConstructorParameter()\n+    {\n+        if (_ctorParameters == null) {\n+            return null;\n+        }\n+        /* Hmmh. Checking for constructor parameters is trickier; for one,\n+         * we must allow creator and factory method annotations.\n+         * If this is the case, constructor parameter has the precedence.\n+         * \n+         * So, for now, just try finding the first constructor parameter;\n+         * if none, first factory method. And don't check for dups, if we must,\n+         * can start checking for them later on.\n+         */\n+        Node<AnnotatedParameter> curr = _ctorParameters;\n+        do {\n+            if (curr.value.getOwner() instanceof AnnotatedConstructor) {\n+                return curr.value;\n+            }\n+            curr = curr.next;\n+        } while (curr != null);\n+        return _ctorParameters.value;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Data aggregation\n+    /**********************************************************\n+     */\n+    \n+    public void addField(AnnotatedField a, String ename, boolean visible, boolean ignored) {\n+        _fields = new Node<AnnotatedField>(a, _fields, ename, visible, ignored);\n+    }\n+\n+    public void addCtor(AnnotatedParameter a, String ename, boolean visible, boolean ignored) {\n+        _ctorParameters = new Node<AnnotatedParameter>(a, _ctorParameters, ename, visible, ignored);\n+    }\n+\n+    public void addGetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored) {\n+        _getters = new Node<AnnotatedMethod>(a, _getters, ename, visible, ignored);\n+    }\n+\n+    public void addSetter(AnnotatedMethod a, String ename, boolean visible, boolean ignored) {\n+        _setters = new Node<AnnotatedMethod>(a, _setters, ename, visible, ignored);\n+    }\n+\n+    /**\n+     * Method for adding all property members from specified collector into\n+     * this collector.\n+     */\n+    public void addAll(POJOPropertyBuilder src)\n+    {\n+        _fields = merge(_fields, src._fields);\n+        _ctorParameters = merge(_ctorParameters, src._ctorParameters);\n+        _getters= merge(_getters, src._getters);\n+        _setters = merge(_setters, src._setters);\n+    }\n+\n+    private static <T> Node<T> merge(Node<T> chain1, Node<T> chain2)\n+    {\n+        if (chain1 == null) {\n+            return chain2;\n+        }\n+        if (chain2 == null) {\n+            return chain1;\n+        }\n+        return chain1.append(chain2);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Modifications\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to remove all entries that are marked as\n+     * ignored.\n+     */\n+    public void removeIgnored()\n+    {\n+        _fields = _removeIgnored(_fields);\n+        _getters = _removeIgnored(_getters);\n+        _setters = _removeIgnored(_setters);\n+        _ctorParameters = _removeIgnored(_ctorParameters);\n+    }\n+\n+    public void removeNonVisible()\n+    {\n+        /* 21-Aug-2011, tatu: This is tricky part -- if and when allow\n+         *   non-visible property elements to be \"pulled in\" by visible\n+         *   counterparts?\n+         *   For now, we will only do this to pull in setter or field used\n+         *   as setter, if an explicit getter is found.\n+         */\n+        _getters = _removeNonVisible(_getters);\n+        _ctorParameters = _removeNonVisible(_ctorParameters);\n+\n+        if (_getters == null) {\n+            _fields = _removeNonVisible(_fields);\n+            _setters = _removeNonVisible(_setters);\n+        }\n+    }\n+\n+    /**\n+     * Method called to trim unnecessary entries, such as implicit\n+     * getter if there is an explict one available. This is important\n+     * for later stages, to avoid unnecessary conflicts.\n+     */\n+    public void trimByVisibility()\n+    {\n+        _fields = _trimByVisibility(_fields);\n+        _getters = _trimByVisibility(_getters);\n+        _setters = _trimByVisibility(_setters);\n+        _ctorParameters = _trimByVisibility(_ctorParameters);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void mergeAnnotations(boolean forSerialization)\n+    {\n+        if (forSerialization) {\n+            if (_getters != null) {\n+                AnnotationMap ann = _mergeAnnotations(0, _getters, _fields, _ctorParameters, _setters);\n+                _getters = _getters.withValue(_getters.value.withAnnotations(ann));\n+            } else if (_fields != null) {\n+                AnnotationMap ann = _mergeAnnotations(0, _fields, _ctorParameters, _setters);\n+                _fields = _fields.withValue(_fields.value.withAnnotations(ann));\n+            }\n+        } else {\n+            if (_ctorParameters != null) {\n+                AnnotationMap ann = _mergeAnnotations(0, _ctorParameters, _setters, _fields, _getters);\n+                _ctorParameters = _ctorParameters.withValue(_ctorParameters.value.withAnnotations(ann));\n+            } else if (_setters != null) {\n+                AnnotationMap ann = _mergeAnnotations(0, _setters, _fields, _getters);\n+                _setters = _setters.withValue(_setters.value.withAnnotations(ann));\n+            } else if (_fields != null) {\n+                AnnotationMap ann = _mergeAnnotations(0, _fields, _getters);\n+                _fields = _fields.withValue(_fields.value.withAnnotations(ann));\n+            }\n+        }\n+    }\n+\n+    private AnnotationMap _mergeAnnotations(int index, Node<? extends AnnotatedMember>... nodes)\n+    {\n+        AnnotationMap ann = nodes[index].value.getAllAnnotations();\n+        ++index;\n+        for (; index < nodes.length; ++index) {\n+            if (nodes[index] != null) {\n+              return AnnotationMap.merge(ann, _mergeAnnotations(index, nodes));\n+            }\n+        }\n+        return ann;\n+    }\n+    \n+    private <T> Node<T> _removeIgnored(Node<T> node)\n+    {\n+        if (node == null) {\n+            return node;\n+        }\n+        return node.withoutIgnored();\n+    }\n+\n+    private <T> Node<T> _removeNonVisible(Node<T> node)\n+    {\n+        if (node == null) {\n+            return node;\n+        }\n+        return node.withoutNonVisible();\n+    }\n+\n+    private <T> Node<T> _trimByVisibility(Node<T> node)\n+    {\n+        if (node == null) {\n+            return node;\n+        }\n+        return node.trimByVisibility();\n+    }\n+        \n+    /*\n+    /**********************************************************\n+    /* Accessors for aggregate information\n+    /**********************************************************\n+     */\n+\n+    public boolean anyExplicitNames() {\n+        return _anyExplicitNames(_fields)\n+                || _anyExplicitNames(_getters)\n+                || _anyExplicitNames(_setters)\n+                || _anyExplicitNames(_ctorParameters)\n+                ;\n+    }\n+\n+    private <T> boolean _anyExplicitNames(Node<T> n)\n+    {\n+        for (; n != null; n = n.next) {\n+            if (n.explicitName != null && n.explicitName.length() > 0) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean anyVisible() {\n+        return _anyVisible(_fields)\n+            || _anyVisible(_getters)\n+            || _anyVisible(_setters)\n+            || _anyVisible(_ctorParameters)\n+        ;\n+    }\n+\n+    private <T> boolean _anyVisible(Node<T> n)\n+    {\n+        for (; n != null; n = n.next) {\n+            if (n.isVisible) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    public boolean anyIgnorals() {\n+        return _anyIgnorals(_fields)\n+            || _anyIgnorals(_getters)\n+            || _anyIgnorals(_setters)\n+            || _anyIgnorals(_ctorParameters)\n+        ;\n+    }\n+\n+    private <T> boolean _anyIgnorals(Node<T> n)\n+    {\n+        for (; n != null; n = n.next) {\n+            if (n.isMarkedIgnored) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Method called to check whether property represented by this collector\n+     * should be renamed from the implicit name; and also verify that there\n+     * are no conflicting rename definitions.\n+     */\n+    public String findNewName()\n+    {\n+        Node<? extends AnnotatedMember> renamed = null;\n+        renamed = findRenamed(_fields, renamed);\n+        renamed = findRenamed(_getters, renamed);\n+        renamed = findRenamed(_setters, renamed);\n+        renamed = findRenamed(_ctorParameters, renamed);\n+        return (renamed == null) ? null : renamed.explicitName;\n+    }\n+\n+    private Node<? extends AnnotatedMember> findRenamed(Node<? extends AnnotatedMember> node,\n+            Node<? extends AnnotatedMember> renamed)\n+    {\n+        for (; node != null; node = node.next) {\n+            String explName = node.explicitName;\n+            if (explName == null) {\n+                continue;\n+            }\n+            // different from default name?\n+            if (explName.equals(_name)) { // nope, skip\n+                continue;\n+            }\n+            if (renamed == null) {\n+                renamed = node;\n+            } else {\n+                // different from an earlier renaming? problem\n+                if (!explName.equals(renamed.explicitName)) {\n+                    throw new IllegalStateException(\"Conflicting property name definitions: '\"\n+                            +renamed.explicitName+\"' (for \"+renamed.value+\") vs '\"\n+                            +node.explicitName+\"' (for \"+node.value+\")\");\n+                }\n+            }\n+        }\n+        return renamed;\n+    }\n+\n+    // For trouble-shooting\n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[Property '\").append(_name)\n+          .append(\"'; ctors: \").append(_ctorParameters)\n+          .append(\", field(s): \").append(_fields)\n+          .append(\", getter(s): \").append(_getters)\n+          .append(\", setter(s): \").append(_setters)\n+          ;\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Node used for creating simple linked lists to efficiently store small sets\n+     * of things.\n+     */\n+    private final static class Node<T>\n+    {\n+        public final T value;\n+        public final Node<T> next;\n+\n+        public final String explicitName;\n+        public final boolean isVisible;\n+        public final boolean isMarkedIgnored;\n+        \n+        public Node(T v, Node<T> n,\n+                String explName, boolean visible, boolean ignored)\n+        {\n+            value = v;\n+            next = n;\n+            // ensure that we'll never have missing names\n+            if (explName == null) {\n+                explicitName = null;\n+            } else {\n+                explicitName = (explName.length() == 0) ? null : explName;\n+            }\n+            isVisible = visible;\n+            isMarkedIgnored = ignored;\n+        }\n+\n+        public Node<T> withValue(T newValue)\n+        {\n+            if (newValue == value) {\n+                return this;\n+            }\n+            return new Node<T>(newValue, next, explicitName, isVisible, isMarkedIgnored);\n+        }\n+        \n+        public Node<T> withNext(Node<T> newNext) {\n+            if (newNext == next) {\n+                return this;\n+            }\n+            return new Node<T>(value, newNext, explicitName, isVisible, isMarkedIgnored);\n+        }\n+        \n+        public Node<T> withoutIgnored()\n+        {\n+            if (isMarkedIgnored) {\n+                return (next == null) ? null : next.withoutIgnored();\n+            }\n+            if (next != null) {\n+                Node<T> newNext = next.withoutIgnored();\n+                if (newNext != next) {\n+                    return withNext(newNext);\n+                }\n+            }\n+            return this;\n+        }\n+        \n+        public Node<T> withoutNonVisible()\n+        {\n+            Node<T> newNext = (next == null) ? null : next.withoutNonVisible();\n+            return isVisible ? withNext(newNext) : newNext;\n+        }\n+\n+        /**\n+         * Method called to append given node(s) at the end of this\n+         * node chain.\n+         */\n+        private Node<T> append(Node<T> appendable) \n+        {\n+            if (next == null) {\n+                return withNext(appendable);\n+            }\n+            return withNext(next.append(appendable));\n+        }\n+        \n+        public Node<T> trimByVisibility()\n+        {\n+            if (next == null) {\n+                return this;\n+            }\n+            Node<T> newNext = next.trimByVisibility();\n+            if (explicitName != null) { // this already has highest; how about next one?\n+                if (newNext.explicitName == null) { // next one not, drop it\n+                    return withNext(null);\n+                }\n+                //  both have it, keep\n+                return withNext(newNext);\n+            }\n+            if (newNext.explicitName != null) { // next one has higher, return it...\n+                return newNext;\n+            }\n+            // neither has explicit name; how about visibility?\n+            if (isVisible == newNext.isVisible) { // same; keep both in current order\n+                return withNext(newNext);\n+            }\n+            return isVisible ? withNext(null) : newNext;\n+        }\n+        \n+        @Override\n+        public String toString() {\n+            String msg = value.toString()+\"[visible=\"+isVisible+\"]\";\n+            if (next != null) {\n+                msg = msg + \", \"+next.toString();\n+            }\n+            return msg;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/VisibilityChecker.java\n+package com.fasterxml.jackson.databind.introspect;\n+\n+import org.codehaus.jackson.annotate.JsonAutoDetect;\n+import org.codehaus.jackson.annotate.JsonAutoDetect.Visibility;\n+import org.codehaus.jackson.annotate.JsonMethod;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+\n+/**\n+ * Interface for object used for determine which property elements\n+ * (methods, fields, constructors) can be auto-detected, with respect\n+ * to their visibility modifiers.\n+ *<p>\n+ * Note on type declaration: funky recursive type is necessary to\n+ * support builder/fluent pattern.\n+ *<p>\n+ * Note on compatibility: 1.9 introduced overloaded \"with\" method\n+ * (which takes {@link Visibility} as value to assign); which could\n+ * be potential issue, but assumption here is that all custom implementations\n+ * are based on \"Std\" base class\n+ * \n+ * @author tatu\n+ * @since 1.5\n+ */\n+public interface VisibilityChecker<T extends VisibilityChecker<T>>\n+{\n+    // // Builder methods\n+\n+    /**\n+     * Builder method that will return an instance that has same\n+     * settings as this instance has, except for values that\n+     * given annotation overrides.\n+     */\n+    public T with(JsonAutoDetect ann);\n+\n+    /**\n+     * Builder method that will create and return an instance that has specified\n+     * {@link Visibility} value to use for all property elements.\n+     * Typical usage would be something like:\n+     *<pre>\n+     *  mapper.setVisibilityChecker(\n+     *     mapper.getVisibilityChecker().with(Visibility.NONE));\n+     *</pre>\n+     * (which would basically disable all auto-detection)\n+     *\n+     * @since 1.9\n+     */\n+    public T with(Visibility v);\n+\n+    /**\n+     * Builder method that will create and return an instance that has specified\n+     * {@link Visibility} value to use for specified property.\n+     * Typical usage would be:\n+     *<pre>\n+     *  mapper.setVisibilityChecker(\n+     *     mapper.getVisibilityChecker().withVisibility(JsonMethod.FIELD, Visibility.ANY));\n+     *</pre>\n+     * (which would basically enable auto-detection for all member fields)\n+     *\n+     * @since 1.9\n+     */\n+    public T withVisibility(JsonMethod method, Visibility v);\n+    \n+    /**\n+     * Builder method that will return a checker instance that has\n+     * specified minimum visibility level for regular (\"getXxx\") getters.\n+     */\n+    public T withGetterVisibility(Visibility v);\n+\n+    /**\n+     * Builder method that will return a checker instance that has\n+     * specified minimum visibility level for \"is-getters\" (\"isXxx\").\n+     */\n+    public T withIsGetterVisibility(Visibility v);\n+    \n+    /**\n+     * Builder method that will return a checker instance that has\n+     * specified minimum visibility level for setters.\n+     */\n+    public T withSetterVisibility(Visibility v);\n+\n+    /**\n+     * Builder method that will return a checker instance that has\n+     * specified minimum visibility level for creator methods\n+     * (constructors, factory methods)\n+     */\n+    public T withCreatorVisibility(Visibility v);\n+\n+    /**\n+     * Builder method that will return a checker instance that has\n+     * specified minimum visibility level for fields.\n+     */\n+    public T withFieldVisibility(Visibility v);\n+\t\n+    // // Accessors\n+\t\n+    /**\n+     * Method for checking whether given method is auto-detectable\n+     * as regular getter, with respect to its visibility (not considering\n+     * method signature or name, just visibility)\n+     */\n+    public boolean isGetterVisible(Method m);\n+    public boolean isGetterVisible(AnnotatedMethod m);\n+\n+    /**\n+     * Method for checking whether given method is auto-detectable\n+     * as is-getter, with respect to its visibility (not considering\n+     * method signature or name, just visibility)\n+     */\n+    public boolean isIsGetterVisible(Method m);\n+    public boolean isIsGetterVisible(AnnotatedMethod m);\n+    \n+    /**\n+     * Method for checking whether given method is auto-detectable\n+     * as setter, with respect to its visibility (not considering\n+     * method signature or name, just visibility)\n+     */\n+    public boolean isSetterVisible(Method m);\n+    public boolean isSetterVisible(AnnotatedMethod m);\n+\n+    /**\n+     * Method for checking whether given method is auto-detectable\n+     * as Creator, with respect to its visibility (not considering\n+     * method signature or name, just visibility)\n+     */\n+    public boolean isCreatorVisible(Member m);\n+    public boolean isCreatorVisible(AnnotatedMember m);\n+\n+    /**\n+     * Method for checking whether given field is auto-detectable\n+     * as property, with respect to its visibility (not considering\n+     * method signature or name, just visibility)\n+     */\n+    public boolean isFieldVisible(Field f);\n+    public boolean isFieldVisible(AnnotatedField f);\n+\n+    /*\n+    /********************************************************\n+    /* Standard implementation suitable for basic use\n+    /********************************************************\n+    */\n+\n+   /**\n+    * Default standard implementation is purely based on visibility\n+    * modifier of given class members, and its configured minimum\n+    * levels.\n+    * Implemented using \"builder\" (aka \"Fluid\") pattern, whereas instances\n+    * are immutable, and configuration is achieved by chainable factory\n+    * methods. As a result, type is declared is funky recursive generic\n+    * type, to allow for sub-classing of build methods with property type\n+    * co-variance.\n+    *<p>\n+    * Note on <code>JsonAutoDetect</code> annotation: it is used to\n+    * access default minimum visibility access definitions.\n+    */\n+    @JsonAutoDetect(\n+        getterVisibility = Visibility.PUBLIC_ONLY,\n+        isGetterVisibility = Visibility.PUBLIC_ONLY,\n+        setterVisibility = Visibility.ANY,\n+        /**\n+         * By default, all matching single-arg constructed are found,\n+         * regardless of visibility. Does not apply to factory methods,\n+         * they can not be auto-detected; ditto for multiple-argument\n+         * constructors.\n+         */\n+        creatorVisibility = Visibility.ANY,\n+        fieldVisibility = Visibility.PUBLIC_ONLY\n+    )\n+    public static class Std\n+        implements VisibilityChecker<Std>\n+    {\n+        /**\n+         * This is the canonical base instance, configured with default\n+         * visibility values\n+         */\n+        protected final static Std DEFAULT = new Std(Std.class.getAnnotation(JsonAutoDetect.class));\n+        \n+        protected final Visibility _getterMinLevel;\n+        protected final Visibility _isGetterMinLevel;\n+        protected final Visibility _setterMinLevel;\n+        protected final Visibility _creatorMinLevel;\n+        protected final Visibility _fieldMinLevel;\n+\t\t\n+        public static Std defaultInstance() { return DEFAULT; }\n+        \n+        /**\n+         * Constructor used for building instance that has minumum visibility\n+         * levels as indicated by given annotation instance\n+         * \n+         * @param ann Annotations to use for determining minimum visibility levels\n+         */\n+\tpublic Std(JsonAutoDetect ann)\n+\t{\n+\t    JsonMethod[] incl = ann.value();\n+\t    // let's combine checks for enabled/disabled, with minimimum level checks:\n+\t    _getterMinLevel = hasMethod(incl, JsonMethod.GETTER) ? ann.getterVisibility() : Visibility.NONE;\n+            _isGetterMinLevel = hasMethod(incl, JsonMethod.IS_GETTER) ? ann.isGetterVisibility() : Visibility.NONE;\n+            _setterMinLevel = hasMethod(incl, JsonMethod.SETTER) ? ann.setterVisibility() : Visibility.NONE;\n+            _creatorMinLevel = hasMethod(incl, JsonMethod.CREATOR) ? ann.creatorVisibility() : Visibility.NONE;\n+            _fieldMinLevel = hasMethod(incl, JsonMethod.FIELD) ? ann.fieldVisibility() : Visibility.NONE;\n+\t}\n+\n+\t/**\n+\t * Constructor that allows directly specifying minimum visibility levels to use\n+\t */\n+\tpublic Std(Visibility getter, Visibility isGetter, Visibility setter, Visibility creator, Visibility field)\n+        {\n+\t    _getterMinLevel = getter;\n+\t    _isGetterMinLevel = isGetter;\n+\t    _setterMinLevel = setter;\n+\t    _creatorMinLevel = creator;\n+\t    _fieldMinLevel = field;\n+        }\n+\t\t\n+\t/**\n+\t * Costructor that will assign given visibility value for all\n+\t * properties.\n+\t * \n+\t * @param v level to use for all property types\n+\t * \n+\t * @since 1.9\n+\t */\n+        public Std(Visibility v)\n+        {\n+            // typically we shouldn't get this value; but let's handle it if we do:\n+            if (v == Visibility.DEFAULT) {\n+                _getterMinLevel = DEFAULT._getterMinLevel;\n+                _isGetterMinLevel = DEFAULT._isGetterMinLevel;\n+                _setterMinLevel = DEFAULT._setterMinLevel;\n+                _creatorMinLevel = DEFAULT._creatorMinLevel;\n+                _fieldMinLevel = DEFAULT._fieldMinLevel;\n+            } else {\n+                _getterMinLevel = v;\n+                _isGetterMinLevel = v;\n+                _setterMinLevel = v;\n+                _creatorMinLevel = v;\n+                _fieldMinLevel = v;\n+            }\n+        }\n+\n+\t/*\n+        /********************************************************\n+\t/* Builder/fluent methods for instantiating configured\n+\t/* instances\n+\t/********************************************************\n+\t */\n+\n+        @Override\n+\tpublic Std with(JsonAutoDetect ann)\n+\t{\n+\t    if (ann == null) return this;\n+\t    Std curr = this;\n+\n+\t    JsonMethod[] incl = ann.value();\n+\t    Visibility v;\n+\n+\t    v = hasMethod(incl, JsonMethod.GETTER) ? ann.getterVisibility() : Visibility.NONE;\n+\t    curr = curr.withGetterVisibility(v);\n+\t    v = hasMethod(incl, JsonMethod.IS_GETTER) ? ann.isGetterVisibility() : Visibility.NONE;\n+\t    curr = curr.withIsGetterVisibility(v);\n+\t    v = hasMethod(incl, JsonMethod.SETTER) ? ann.setterVisibility() : Visibility.NONE;\n+            curr  = curr.withSetterVisibility(v);\n+            v = hasMethod(incl, JsonMethod.CREATOR) ? ann.creatorVisibility() : Visibility.NONE;\n+            curr = curr.withCreatorVisibility(v);\n+            v = hasMethod(incl, JsonMethod.FIELD) ? ann.fieldVisibility() : Visibility.NONE;\n+            curr = curr.withFieldVisibility(v);\n+\t    return curr;\n+\t}\n+\n+        @Override\n+\tpublic Std with(Visibility v)\n+\t{\n+\t    if (v == Visibility.DEFAULT) {\n+\t        return DEFAULT;\n+\t    }\n+\t    return new Std(v);\n+\t}\n+\n+        @Override\n+\tpublic Std withVisibility(JsonMethod method, Visibility v)\n+\t{\n+\t    switch (method) {\n+\t    case GETTER:\n+\t        return withGetterVisibility(v);\n+\t    case SETTER:\n+\t        return withSetterVisibility(v);\n+\t    case CREATOR:\n+\t        return withCreatorVisibility(v);\n+\t    case FIELD:\n+\t        return withFieldVisibility(v);\n+\t    case IS_GETTER:\n+\t        return withIsGetterVisibility(v);\n+            case ALL:\n+                return with(v);\n+            //case NONE:\n+            // break;\n+\t    }\n+            return this;\n+\t}\n+\t\n+        @Override\n+\tpublic Std withGetterVisibility(Visibility v) {\n+\t    if (v == Visibility.DEFAULT)  v = DEFAULT._getterMinLevel;\n+            if (_getterMinLevel == v) return this;\n+\t    return new Std(v, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, _fieldMinLevel);\n+\t}\n+\n+        @Override\n+        public Std withIsGetterVisibility(Visibility v) {\n+            if (v == Visibility.DEFAULT)  v = DEFAULT._isGetterMinLevel;\n+            if (_isGetterMinLevel == v) return this;\n+            return new Std(_getterMinLevel, v, _setterMinLevel, _creatorMinLevel, _fieldMinLevel);\n+        }\n+\t\t\n+        @Override\n+\tpublic Std withSetterVisibility(Visibility v) {\n+            if (v == Visibility.DEFAULT)  v = DEFAULT._setterMinLevel;\n+            if (_setterMinLevel == v) return this;\n+            return new Std(_getterMinLevel, _isGetterMinLevel, v, _creatorMinLevel, _fieldMinLevel);\n+\t}\n+\n+\t@Override\n+\tpublic Std withCreatorVisibility(Visibility v) {\n+            if (v == Visibility.DEFAULT)  v = DEFAULT._creatorMinLevel;\n+            if (_creatorMinLevel == v) return this;\n+\t    return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, v, _fieldMinLevel);\n+\t}\n+\n+        @Override\n+\tpublic Std withFieldVisibility(Visibility v) {\n+            if (v == Visibility.DEFAULT)  v = DEFAULT._fieldMinLevel;\n+            if (_fieldMinLevel == v) return this;\n+\t    return new Std(_getterMinLevel, _isGetterMinLevel, _setterMinLevel, _creatorMinLevel, v);\n+\t}\n+\t\t\n+        /*\n+        /********************************************************\n+        /* Public API impl\n+        /********************************************************\n+         */\n+\n+\t@Override\n+\tpublic boolean isCreatorVisible(Member m) {\n+\t    return _creatorMinLevel.isVisible(m);\n+    \t}\n+    \n+        @Override\n+    \tpublic boolean isCreatorVisible(AnnotatedMember m) {\n+    \t    return isCreatorVisible(m.getMember());\n+    \t}\n+    \n+        @Override\n+    \tpublic boolean isFieldVisible(Field f) {\n+    \t    return _fieldMinLevel.isVisible(f);\n+    \t}\n+    \n+        @Override\n+    \tpublic boolean isFieldVisible(AnnotatedField f) {\n+    \t    return isFieldVisible(f.getAnnotated());\n+    \t}\n+    \n+        @Override\n+    \tpublic boolean isGetterVisible(Method m) {\n+    \t    return _getterMinLevel.isVisible(m);\n+    \t}    \n+\n+        @Override\n+        public boolean isGetterVisible(AnnotatedMethod m) {\n+    \t    return isGetterVisible(m.getAnnotated());\n+    \t}\n+\n+        @Override\n+        public boolean isIsGetterVisible(Method m) {\n+            return _isGetterMinLevel.isVisible(m);\n+        }    \n+\n+        @Override\n+        public boolean isIsGetterVisible(AnnotatedMethod m) {\n+            return isIsGetterVisible(m.getAnnotated());\n+        }\n+\n+        @Override\n+        public boolean isSetterVisible(Method m) {\n+            return _setterMinLevel.isVisible(m);\n+        }\n+    \n+        @Override\n+        public boolean isSetterVisible(AnnotatedMethod m) {\n+            return isSetterVisible(m.getAnnotated());\n+        }\n+\n+        /*\n+        /********************************************************\n+        /* Helper methods\n+        /********************************************************\n+         */\n+    \n+        private static boolean hasMethod(JsonMethod[] methods, JsonMethod method)\n+        {\n+            for (JsonMethod curr : methods) {\n+                if (curr == method || curr == JsonMethod.ALL) return true;\n+            }\n+            return false;\n+        }\n+\n+        /*\n+        /********************************************************\n+        /* Standard methods\n+        /********************************************************\n+         */\n+        @Override\n+        public String toString() {\n+            return new StringBuilder(\"[Visibility:\")\n+                .append(\" getter: \").append(_getterMinLevel)\n+                .append(\", isGetter: \").append(_isGetterMinLevel)\n+                .append(\", setter: \").append(_setterMinLevel)\n+                .append(\", creator: \").append(_creatorMinLevel)\n+                .append(\", field: \").append(_fieldMinLevel)\n+                .append(\"]\").toString();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/package-info.java\n+/**\n+ * Functionality needed for Bean introspection, required for detecting\n+ * accessors and mutators for Beans, as well as locating and handling\n+ * method annotations.\n+ *<p>\n+ * Beyond collecting annotations, additional \"method annotation inheritance\"\n+ * is also supported: whereas regular JDK classes do not add annotations\n+ * from overridden methods in any situation. But code in this package does.\n+ * Similarly class-annotations are inherited properly from interfaces, in\n+ * addition to abstract and concrete classes.\n+ */\n+package com.fasterxml.jackson.databind.introspect;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/NamedType.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+/**\n+ * Simple container class for types with optional logical name, used\n+ * as external identifier\n+ * \n+ * @author tatu\n+ * @since 1.5\n+ */\n+public final class NamedType\n+{\n+    protected final Class<?> _class;\n+    protected final int _hashCode;\n+\n+    protected String _name;\n+    \n+    public NamedType(Class<?> c) { this(c, null); }\n+    \n+    public NamedType(Class<?> c, String name)\n+    {\n+        _class = c;\n+        _hashCode = c.getName().hashCode();\n+        setName(name);\n+    }\n+\n+    public Class<?> getType() { return _class; }\n+    public String getName() { return _name; }\n+    public void setName(String name) {\n+        _name = (name == null || name.length() == 0) ? null : name;\n+    }\n+\n+    public boolean hasName() { return _name != null; }\n+    \n+    /**\n+     * Equality is defined based on class only, not on name\n+     */\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) return false;\n+        return _class == ((NamedType) o)._class;\n+    }\n+\n+    @Override\n+    public int hashCode() { return _hashCode; }\n+\n+    @Override\n+    public String toString() {\n+    \treturn \"[NamedType, class \"+_class.getName()+\", name: \"+(_name == null ? \"null\" :(\"'\"+_name+\"'\"))+\"]\";\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/SubtypeResolver.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.Collection;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+\n+/**\n+ * Helper object used for handling registration on resolving of supertypes\n+ * to subtypes.\n+ * \n+ * @since 1.5\n+ */\n+public abstract class SubtypeResolver\n+{\n+    /**\n+     * Method for registering specified subtypes (possibly including type\n+     * names); for type entries without name, non-qualified class name\n+     * as used as name (unless overridden by annotation).\n+     */\n+    public abstract void registerSubtypes(NamedType... types);\n+\n+    public abstract void registerSubtypes(Class<?>... classes);\n+    \n+    /**\n+     * Method for finding out all reachable subtypes for a property specified\n+     * by given element (method or field)\n+     */\n+    public abstract Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property,\n+            MapperConfig<?> config, AnnotationIntrospector ai);\n+\n+    /**\n+     * Method for finding out all reachable subtypes for given type.\n+     */\n+    public abstract Collection<NamedType> collectAndResolveSubtypes(AnnotatedClass basetype,\n+            MapperConfig<?> config, AnnotationIntrospector ai);\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeIdResolver.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Interface that defines standard API for converting types\n+ * to type identifiers and vice versa. Used by type resolvers\n+ * ({@link com.fasterxml.jackson.databind.TypeSerializer},\n+ * {@link com.fasterxml.jackson.databind.TypeDeserializer}) for converting\n+ * between type and matching id; id is stored in JSON and needed for\n+ * creating instances of proper subtypes when deserializing values.\n+ * \n+ * @since 1.5\n+ */\n+public interface TypeIdResolver\n+{\n+    /*\n+    /**********************************************************\n+    /* Initialization/configuration methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will be called once before any type resolution calls;\n+     * used to initialize instance with configuration. This is necessary\n+     * since instances may be created via reflection, without ability to\n+     * call specific constructor to pass in configuration settings.\n+     * \n+     * @param baseType Base type for which this id resolver instance is\n+     *   used\n+     */\n+    public void init(JavaType baseType);\n+\n+    /*\n+    /**********************************************************\n+    /* Conversions between types and type ids\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called to serialize type of the type of given value\n+     * as a String to include in serialized JSON content.\n+     */\n+    public String idFromValue(Object value);\n+\n+    /**\n+     * Alternative method used for determining type from combination of\n+     * value and type, using suggested type (that serializer provides)\n+     * and possibly value of that type. Most common implementation will\n+     * use suggested type as is.\n+     * \n+     * @since 1.8\n+     */\n+    public String idFromValueAndType(Object value, Class<?> suggestedType);\n+    \n+    /**\n+     * Method called to resolve type from given type identifier.\n+     */\n+    public JavaType typeFromId(String id);\n+\n+    /*\n+    /**********************************************************\n+    /* Accessors for metadata\n+    /**********************************************************\n+     */\n+\n+     /**\n+      * Accessor for mechanism that this resolver uses for determining\n+      * type id from type. Mostly informational; not required to be called\n+      * or used.\n+      */\n+     public JsonTypeInfo.Id getMechanism();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeResolverBuilder.java\n+package com.fasterxml.jackson.databind.jsontype;\n+\n+import java.util.Collection;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.As;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.TypeDeserializer;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+\n+\n+/**\n+ * Interface that defines builders that are configured based on\n+ * annotations (like {@link JsonTypeInfo} or JAXB annotations),\n+ * and produce type serializers and deserializers used for\n+ * handling type information embedded in JSON to allow for safe\n+ * polymorphic type handling.\n+ *<p>\n+ * Builder is first initialized by calling {@link #init} method, and then\n+ * configured using <code>setXxx</code> (and <code>registerXxx</code>)\n+ * methods. Finally, after calling all configuration methods,\n+ * {@link #buildTypeSerializer} or {@link #buildTypeDeserializer}\n+ * will be called to get actual type resolver constructed\n+ * and used for resolving types for configured base type and its\n+ * subtypes.\n+ *<p>\n+ * Note that instances are used for two related but distinct use cases:\n+ *<ul>\n+ * <li>To create builders to use with explicit type information\n+ *    inclusion (usually via <code>@JsonTypeInfo</code> annotation)\n+ *   </li>\n+ * <li>To create builders when \"default typing\" is used; if so, type information\n+ *   is automatically included for certain kind of types, regardless of annotations\n+ *   </li>\n+ *</ul>\n+ * Important distinction between the cases is that in first case, calls to\n+ * create builders are only made when builders are certainly needed; whereas\n+ * in second case builder has to first verify whether type information is\n+ * applicable for given type, and if not, just return null to indicate this.\n+ * \n+ * @since 1.5\n+ * @author tatu\n+ */\n+public interface TypeResolverBuilder<T extends TypeResolverBuilder<T>>\n+{\n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Accessor for currently configured default type; implementation\n+     * class that may be used in case no valid type information is\n+     * available during type resolution\n+     * \n+     * @since 1.9\n+     */\n+    public Class<?> getDefaultImpl();\n+    \n+    /*\n+    /**********************************************************\n+    /* Actual builder methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for building type serializer based on current configuration\n+     * of this builder.\n+     * \n+     * @param baseType Base type that constructed resolver will\n+     *    handle; super type of all types it will be used for.\n+     */\n+    public TypeSerializer buildTypeSerializer(SerializationConfig config,\n+            JavaType baseType, Collection<NamedType> subtypes, BeanProperty property);\n+\n+    /**\n+     * Method for building type deserializer based on current configuration\n+     * of this builder.\n+     * \n+     * @param baseType Base type that constructed resolver will\n+     *    handle; super type of all types it will be used for.\n+     * @param subtypes Known subtypes of the base type.\n+     */\n+    public TypeDeserializer buildTypeDeserializer( DeserializationConfig config,\n+            JavaType baseType, Collection<NamedType> subtypes, BeanProperty property);\n+    \n+    /*\n+    /**********************************************************\n+    /* Initialization method(s) that must be called before other\n+    /* configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Initialization method that is called right after constructing\n+     * the builder instance.\n+     *\n+     * @param idType Which type metadata is used\n+     * @param res (optional) Custom type id resolver used, if any\n+     * \n+     * @return Resulting builder instance (usually this builder,\n+     *   but not necessarily)\n+     */\n+    public T init(JsonTypeInfo.Id idType, TypeIdResolver res);\n+    \n+    /*\n+    /**********************************************************\n+    /* Methods for configuring resolver to build \n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for specifying mechanism to use for including type metadata\n+     * in JSON.\n+     * If not explicitly called, setting defaults to\n+     * {@link As#PROPERTY}.\n+     * \n+     * @param includeAs Mechanism used for including type metadata in JSON\n+     * \n+     * @return Resulting builder instance (usually this builder,\n+     *   but not necessarily)\n+     */\n+    public T inclusion(As includeAs);\n+\n+    /**\n+     * Method for specifying name of property used for including type\n+     * information. Not used for all inclusion mechanisms;\n+     * usually only used with {@link As#PROPERTY}.\n+     *<p>\n+     * If not explicitly called, name of property to use is based on\n+     * defaults for {@link org.codehaus.jackson.annotate.JsonTypeInfo.Id} configured.\n+     * \n+     * @param propName Name of JSON property to use for including\n+     *    type information\n+     * \n+     * @return Resulting builder instance (usually this builder,\n+     *   but not necessarily)\n+     */\n+    public T typeProperty(String propName);\n+\n+    /**\n+     * Method for specifying default implementation to use if type id \n+     * is either not available, or can not be resolved.\n+     * \n+     * @since 1.9\n+     */\n+    public T defaultImpl(Class<?> defaultImpl);\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeDeserializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.*;\n+import org.codehaus.jackson.annotate.JsonTypeInfo.As;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type deserializer used with {@link As#WRAPPER_ARRAY}\n+ * inclusion mechanism. Simple since JSON structure used is always\n+ * the same, regardless of structure used for actual value: wrapping\n+ * is done using a 2-element JSON Array where type id is the first\n+ * element, and actual object data as second element.\n+ * \n+ * @author tatus\n+ */\n+public class AsArrayTypeDeserializer extends TypeDeserializerBase\n+{\n+    @Deprecated // since 1.9\n+    public AsArrayTypeDeserializer(JavaType bt, TypeIdResolver idRes, BeanProperty property) {\n+        this(bt, idRes, property, null);\n+    }\n+\n+    public AsArrayTypeDeserializer(JavaType bt, TypeIdResolver idRes, BeanProperty property,\n+            Class<?> defaultImpl)\n+    {\n+        super(bt, idRes, property, defaultImpl);\n+    }\n+    \n+    @Override\n+    public As getTypeInclusion() {\n+        return As.WRAPPER_ARRAY;\n+    }\n+\n+    /**\n+     * Method called when actual object is serialized as JSON Array.\n+     */\n+    @Override\n+    public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _deserialize(jp, ctxt);\n+    }\n+\n+    /**\n+     * Method called when actual object is serialized as JSON Object\n+     */\n+    @Override\n+    public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _deserialize(jp, ctxt);\n+    }\n+    \n+    @Override\n+    public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _deserialize(jp, ctxt);\n+    }    \n+\n+    @Override\n+    public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _deserialize(jp, ctxt);\n+    }    \n+    \n+    /*\n+    /***************************************************************\n+    /* Internal methods\n+    /***************************************************************\n+     */\n+\n+    /**\n+     * Method that handles type information wrapper, locates actual\n+     * subtype deserializer to use, and calls it to do actual\n+     * deserialization.\n+     */\n+    private final Object _deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonDeserializer<Object> deser = _findDeserializer(ctxt, _locateTypeId(jp, ctxt));\n+        Object value = deser.deserialize(jp, ctxt);\n+        // And then need the closing END_ARRAY\n+        if (jp.nextToken() != JsonToken.END_ARRAY) {\n+            throw ctxt.wrongTokenException(jp, JsonToken.END_ARRAY,\n+                    \"expected closing END_ARRAY after type information and deserialized value\");\n+        }\n+        return value;\n+    }    \n+    \n+    protected final String _locateTypeId(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (!jp.isExpectedStartArrayToken()) {\n+            throw ctxt.wrongTokenException(jp, JsonToken.START_ARRAY,\n+                    \"need JSON Array to contain As.WRAPPER_ARRAY type information for class \"+baseTypeName());\n+        }\n+        // And then type id as a String\n+        if (jp.nextToken() != JsonToken.VALUE_STRING) {\n+            throw ctxt.wrongTokenException(jp, JsonToken.VALUE_STRING,\n+                    \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n+        }\n+        String result = jp.getText();\n+        jp.nextToken();\n+        return result;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsArrayTypeSerializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.annotate.JsonTypeInfo.As;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type serializer that will embed type information in an array,\n+ * as the first element, and actual value as the second element.\n+ * \n+ * @since 1.5\n+ * @author tatu\n+ */\n+public class AsArrayTypeSerializer\n+    extends TypeSerializerBase\n+{\n+    public AsArrayTypeSerializer(TypeIdResolver idRes, BeanProperty property)\n+    {\n+        super(idRes, property);\n+    }\n+\n+    @Override\n+    public As getTypeInclusion() { return As.WRAPPER_ARRAY; }\n+    \n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        jgen.writeStartArray();\n+        jgen.writeString(_idResolver.idFromValue(value));\n+        jgen.writeStartObject();\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen,\n+            Class<?> type)\n+        throws IOException, JsonProcessingException\n+    {\n+        jgen.writeStartArray();\n+        jgen.writeString(_idResolver.idFromValueAndType(value, type));\n+        jgen.writeStartObject();\n+    }\n+    \n+    @Override\n+    public void writeTypePrefixForArray(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        jgen.writeStartArray();\n+        jgen.writeString(_idResolver.idFromValue(value));\n+        jgen.writeStartArray();\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForArray(Object value, JsonGenerator jgen,\n+            Class<?> type)\n+        throws IOException, JsonProcessingException\n+    {\n+        jgen.writeStartArray();\n+        jgen.writeString(_idResolver.idFromValueAndType(value, type));\n+        jgen.writeStartArray();\n+    }\n+    \n+    @Override\n+    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen)\n+            throws IOException, JsonProcessingException\n+    {\n+        // only need the wrapper array\n+        jgen.writeStartArray();\n+        jgen.writeString(_idResolver.idFromValue(value));\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen,\n+            Class<?> type)\n+        throws IOException, JsonProcessingException\n+    {\n+        // only need the wrapper array\n+        jgen.writeStartArray();\n+        jgen.writeString(_idResolver.idFromValueAndType(value, type));\n+    }\n+    \n+    @Override\n+    public void writeTypeSuffixForObject(Object value, JsonGenerator jgen)\n+            throws IOException, JsonProcessingException\n+    {\n+        jgen.writeEndObject();\n+        jgen.writeEndArray();\n+    }\n+\n+    @Override\n+    public void writeTypeSuffixForArray(Object value, JsonGenerator jgen)\n+            throws IOException, JsonProcessingException\n+    {\n+        // wrapper array first, and then array caller needs to close\n+        jgen.writeEndArray();\n+        jgen.writeEndArray();\n+    }\n+\n+    @Override\n+    public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen)\n+            throws IOException, JsonProcessingException\n+    {\n+        // just the wrapper array to close\n+        jgen.writeEndArray();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import org.codehaus.jackson.annotate.JsonTypeInfo.As;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type deserializer used with {@link As#EXTERNAL_PROPERTY} inclusion mechanism.\n+ * Actual implementation may look bit strange since it depends on comprehensive\n+ * pre-processing done by {@link com.fasterxml.jackson.databind.deser.BeanDeserializer}\n+ * to basically transform external type id into structure that looks more like\n+ * \"wrapper-array\" style inclusion. This intermediate form is chosen to allow\n+ * supporting all possible JSON structures.\n+ * \n+ * @since 1.9\n+ */\n+public class AsExternalTypeDeserializer extends AsArrayTypeDeserializer\n+{\n+    protected final String _typePropertyName;\n+    \n+    public AsExternalTypeDeserializer(JavaType bt, TypeIdResolver idRes, BeanProperty property,\n+            Class<?> defaultImpl,\n+            String typePropName)\n+    {\n+        super(bt, idRes, property, defaultImpl);\n+        _typePropertyName = typePropName;\n+    }\n+\n+    @Override\n+    public As getTypeInclusion() {\n+        return As.EXTERNAL_PROPERTY;\n+    }\n+\n+    @Override\n+    public String getPropertyName() { return _typePropertyName; }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeSerializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.annotate.JsonTypeInfo.As;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type serializer that preferably embeds type information as an \"external\"\n+ * type property; embedded in enclosing JSON object.\n+ * Note that this serializer should only be used when value is being output\n+ * at JSON Object context; otherwise it can not work reliably, and will have\n+ * to revert operation similar to {@link AsPropertyTypeSerializer}.\n+ *<p>\n+ * Note that implementation of serialization is bit cumbersome as we must\n+ * serialized external type id AFTER object; this because callback only\n+ * occurs after field name has been written.\n+ * \n+ * @since 1.9\n+ */\n+public class AsExternalTypeSerializer\n+   extends TypeSerializerBase\n+{\n+   protected final String _typePropertyName;\n+\n+   public AsExternalTypeSerializer(TypeIdResolver idRes, BeanProperty property,\n+           String propName)\n+   {\n+       super(idRes, property);\n+       _typePropertyName = propName;\n+   }\n+\n+   @Override\n+   public String getPropertyName() { return _typePropertyName; }\n+\n+   @Override\n+   public As getTypeInclusion() { return As.EXTERNAL_PROPERTY; }\n+   \n+   @Override\n+   public void writeTypePrefixForObject(Object value, JsonGenerator jgen)\n+       throws IOException, JsonProcessingException\n+   {\n+       _writePrefix(value, jgen);\n+   }\n+\n+   @Override\n+   public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type)\n+       throws IOException, JsonProcessingException\n+   {\n+       _writePrefix(value, jgen, type);\n+   }\n+   \n+   @Override\n+   public void writeTypePrefixForArray(Object value, JsonGenerator jgen)\n+       throws IOException, JsonProcessingException\n+   {\n+       _writePrefix(value, jgen);\n+   }\n+\n+   @Override\n+   public void writeTypePrefixForArray(Object value, JsonGenerator jgen, Class<?> type)\n+           throws IOException, JsonProcessingException\n+   {\n+       _writePrefix(value, jgen, type);\n+   }\n+\n+   @Override\n+   public void writeTypePrefixForScalar(Object value, JsonGenerator jgen)\n+           throws IOException, JsonProcessingException\n+   {\n+       _writePrefix(value, jgen);\n+   }\n+\n+   @Override\n+   public void writeTypePrefixForScalar(Object value, JsonGenerator jgen, Class<?> type)\n+           throws IOException, JsonProcessingException\n+   {\n+       _writePrefix(value, jgen, type);\n+   }\n+\n+   @Override\n+   public void writeTypeSuffixForObject(Object value, JsonGenerator jgen)\n+       throws IOException, JsonProcessingException\n+   {\n+       _writeSuffix(value, jgen);\n+   }\n+\n+   @Override\n+   public void writeTypeSuffixForArray(Object value, JsonGenerator jgen)\n+       throws IOException, JsonProcessingException\n+   {\n+       _writeSuffix(value, jgen);\n+   }\n+   \n+   @Override\n+   public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen)\n+       throws IOException, JsonProcessingException\n+   {\n+       _writeSuffix(value, jgen);\n+   }\n+\n+   /*\n+   /**********************************************************\n+   /* Helper methods\n+   /**********************************************************\n+    */\n+   \n+   protected final void _writePrefix(Object value, JsonGenerator jgen)\n+       throws IOException, JsonProcessingException\n+   {\n+       jgen.writeStartObject();\n+   }\n+\n+   protected final void _writePrefix(Object value, JsonGenerator jgen, Class<?> type)\n+       throws IOException, JsonProcessingException\n+   {\n+       jgen.writeStartObject();\n+   }\n+   \n+   protected final void _writeSuffix(Object value, JsonGenerator jgen)\n+       throws IOException, JsonProcessingException\n+   {\n+       jgen.writeEndObject();\n+       jgen.writeStringField(_typePropertyName, _idResolver.idFromValue(value));\n+   }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.*;\n+import org.codehaus.jackson.annotate.JsonTypeInfo.As;\n+import org.codehaus.jackson.type.JavaType;\n+import org.codehaus.jackson.util.JsonParserSequence;\n+import org.codehaus.jackson.util.TokenBuffer;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type deserializer used with {@link As#PROPERTY}\n+ * inclusion mechanism.\n+ * Uses regular form (additional key/value entry before actual data)\n+ * when typed object is expressed as JSON Object; otherwise behaves similar to how\n+ * {@link As#WRAPPER_ARRAY} works.\n+ * Latter is used if JSON representation is polymorphic\n+ * \n+ * @since 1.5\n+ * @author tatu\n+ */\n+public class AsPropertyTypeDeserializer extends AsArrayTypeDeserializer\n+{\n+    protected final String _typePropertyName;\n+\n+    @Deprecated // since 1.9\n+    public AsPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes, BeanProperty property,\n+            String typePropName) {\n+        this(bt, idRes, property, null, typePropName);\n+    }\n+    \n+    public AsPropertyTypeDeserializer(JavaType bt, TypeIdResolver idRes, BeanProperty property,\n+            Class<?> defaultImpl,\n+            String typePropName)\n+    {\n+        super(bt, idRes, property, defaultImpl);\n+        _typePropertyName = typePropName;\n+    }\n+\n+    @Override\n+    public As getTypeInclusion() {\n+        return As.PROPERTY;\n+    }\n+\n+    @Override\n+    public String getPropertyName() { return _typePropertyName; }\n+\n+    /**\n+     * This is the trickiest thing to handle, since property we are looking\n+     * for may be anywhere...\n+     */\n+    @Override\n+    public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // but first, sanity check to ensure we have START_OBJECT or FIELD_NAME\n+        JsonToken t = jp.getCurrentToken();\n+        if (t == JsonToken.START_OBJECT) {\n+            t = jp.nextToken();\n+        } else if (t != JsonToken.FIELD_NAME) {\n+            throw ctxt.wrongTokenException(jp, JsonToken.START_OBJECT,\n+                    \"need JSON Object to contain As.PROPERTY type information (for class \"+baseTypeName()+\")\");\n+        }\n+        // Ok, let's try to find the property. But first, need token buffer...\n+        TokenBuffer tb = null;\n+\n+        for (; t == JsonToken.FIELD_NAME; t = jp.nextToken()) {\n+            String name = jp.getCurrentName();\n+            jp.nextToken(); // to point to the value\n+            if (_typePropertyName.equals(name)) { // gotcha!\n+                String typeId = jp.getText();\n+                JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n+                // deserializer should take care of closing END_OBJECT as well\n+               if (tb != null) {\n+                    jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n+                }\n+                /* Must point to the next value; tb had no current, jp\n+                 * pointed to VALUE_STRING:\n+                 */\n+                jp.nextToken(); // to skip past String value\n+                // deserializer should take care of closing END_OBJECT as well\n+                return deser.deserialize(jp, ctxt);\n+            }\n+            if (tb == null) {\n+                tb = new TokenBuffer(null);\n+            }\n+            tb.writeFieldName(name);\n+            tb.copyCurrentStructure(jp);\n+        }\n+        return _deserializeTypedUsingDefaultImpl(jp, ctxt, tb);\n+    }\n+    \n+    // off-lined to keep main method lean and meand...\n+    protected Object _deserializeTypedUsingDefaultImpl(JsonParser jp,\n+            DeserializationContext ctxt, TokenBuffer tb)\n+        throws IOException, JsonProcessingException\n+    {\n+        // As per [JACKSON-614], may have default implement to use\n+        if (_defaultImpl != null) { \n+            JsonDeserializer<Object> deser = _findDefaultImplDeserializer(ctxt);\n+            if (tb != null) {\n+                tb.writeEndObject();\n+                jp = tb.asParser(jp);\n+                // must move to point to the first token:\n+                jp.nextToken();\n+            }\n+            return deser.deserialize(jp, ctxt);\n+        }\n+        // if not, an error\n+        throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n+                \"missing property '\"+_typePropertyName+\"' that is to contain type id  (for class \"+baseTypeName()+\")\");\n+    }\n+\n+    /* As per [JACKSON-352], also need to re-route \"unknown\" version. Need to think\n+     * this through bit more in future, but for now this does address issue and has\n+     * no negative side effects (at least within existing unit test suite).\n+     */\n+    @Override\n+    public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* [JACKSON-387]: Sometimes, however, we get an array wrapper; specifically\n+         *   when an array or list has been serialized with type information.\n+         */\n+        if (jp.getCurrentToken() == JsonToken.START_ARRAY) {\n+            return super.deserializeTypedFromArray(jp, ctxt);\n+        }\n+        return deserializeTypedFromObject(jp, ctxt);\n+    }    \n+    \n+    // These are fine from base class:\n+    //public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt)\n+    //public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt)    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeSerializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.annotate.JsonTypeInfo.As;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type serializer that preferably embeds type information as an additional\n+ * JSON Object property, if possible (when resulting serialization would\n+ * use JSON Object). If this is not possible (for JSON Arrays, scalars),\n+ * uses a JSON Array wrapper (similar to how\n+ * {@link As#WRAPPER_ARRAY} always works) as a fallback.\n+ * \n+ * @since 1.5\n+ * @author tatus\n+ */\n+public class AsPropertyTypeSerializer\n+    extends AsArrayTypeSerializer\n+{\n+    protected final String _typePropertyName;\n+\n+    public AsPropertyTypeSerializer(TypeIdResolver idRes, BeanProperty property,\n+            String propName)\n+    {\n+        super(idRes, property);\n+        _typePropertyName = propName;\n+    }\n+\n+    @Override\n+    public String getPropertyName() { return _typePropertyName; }\n+\n+    @Override\n+    public As getTypeInclusion() { return As.PROPERTY; }\n+    \n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        jgen.writeStartObject();\n+        jgen.writeStringField(_typePropertyName, _idResolver.idFromValue(value));\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen, Class<?> type)\n+        throws IOException, JsonProcessingException\n+    {\n+        jgen.writeStartObject();\n+        jgen.writeStringField(_typePropertyName, _idResolver.idFromValueAndType(value, type));\n+    }\n+    \n+    //public void writeTypePrefixForArray(Object value, JsonGenerator jgen)\n+    //public void writeTypePrefixForArray(Object value, JsonGenerator jgen, Class<?> type)\n+    //public void writeTypePrefixForScalar(Object value, JsonGenerator jgen)\n+    //public void writeTypePrefixForScalar(Object value, JsonGenerator jgen, Class<?> type)\n+\n+    @Override\n+    public void writeTypeSuffixForObject(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        jgen.writeEndObject();\n+    }\n+\n+    //public void writeTypeSuffixForArray(Object value, JsonGenerator jgen)\n+    //public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen)\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.*;\n+import org.codehaus.jackson.annotate.JsonTypeInfo.As;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type deserializer used with {@link As#WRAPPER_OBJECT}\n+ * inclusion mechanism. Simple since JSON structure used is always\n+ * the same, regardless of structure used for actual value: wrapping\n+ * is done using a single-element JSON Object where type id is the key,\n+ * and actual object data as the value.\n+ * \n+ * @author tatus\n+ */\n+public class AsWrapperTypeDeserializer extends TypeDeserializerBase\n+{\n+    @Deprecated // since 1.9\n+    public AsWrapperTypeDeserializer(JavaType bt, TypeIdResolver idRes, BeanProperty property) {\n+        this(bt, idRes, property, null);\n+    }\n+\n+    public AsWrapperTypeDeserializer(JavaType bt, TypeIdResolver idRes, BeanProperty property,\n+            Class<?> defaultImpl)\n+    {\n+        super(bt, idRes, property, null);\n+    }\n+\n+    @Override\n+    public As getTypeInclusion() {\n+        return As.WRAPPER_OBJECT;\n+    }\n+\n+    /**\n+     * Deserializing type id enclosed using WRAPPER_OBJECT style is straightforward\n+     */\n+    @Override\n+    public Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _deserialize(jp, ctxt);\n+    }    \n+\n+    @Override\n+    public Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _deserialize(jp, ctxt);\n+    }\n+\n+    @Override\n+    public Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _deserialize(jp, ctxt);\n+    }\n+\n+    @Override\n+    public Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        return _deserialize(jp, ctxt);\n+    }\n+    \n+    /*\n+    /***************************************************************\n+    /* Internal methods\n+    /***************************************************************\n+     */\n+\n+    /**\n+     * Method that handles type information wrapper, locates actual\n+     * subtype deserializer to use, and calls it to do actual\n+     * deserialization.\n+     */\n+    private final Object _deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        // first, sanity checks\n+        if (jp.getCurrentToken() != JsonToken.START_OBJECT) {\n+            throw ctxt.wrongTokenException(jp, JsonToken.START_OBJECT,\n+                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n+        }\n+        // should always get field name, but just in case...\n+        if (jp.nextToken() != JsonToken.FIELD_NAME) {\n+            throw ctxt.wrongTokenException(jp, JsonToken.FIELD_NAME,\n+                    \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n+        }\n+        JsonDeserializer<Object> deser = _findDeserializer(ctxt, jp.getText());\n+        jp.nextToken();\n+        Object value = deser.deserialize(jp, ctxt);\n+        // And then need the closing END_OBJECT\n+        if (jp.nextToken() != JsonToken.END_OBJECT) {\n+            throw ctxt.wrongTokenException(jp, JsonToken.END_OBJECT,\n+                    \"expected closing END_OBJECT after type information and deserialized value\");\n+        }\n+        return value;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeSerializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.annotate.JsonTypeInfo.As;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * Type wrapper that tries to use an extra JSON Object, with a single\n+ * entry that has type name as key, to serialize type information.\n+ * If this is not possible (value is serialize as array or primitive),\n+ * will use {@link As#WRAPPER_ARRAY} mechanism as fallback: that is,\n+ * just use a wrapping array with type information as the first element\n+ * and value as second.\n+ * \n+ * @since 1.5\n+ * @author tatus\n+ */\n+public class AsWrapperTypeSerializer\n+    extends TypeSerializerBase\n+{\n+    public AsWrapperTypeSerializer(TypeIdResolver idRes, BeanProperty property)\n+    {\n+        super(idRes, property);\n+    }\n+\n+    @Override\n+    public As getTypeInclusion() { return As.WRAPPER_OBJECT; }\n+    \n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        // wrapper\n+        jgen.writeStartObject();\n+        // and then JSON Object start caller wants\n+        jgen.writeObjectFieldStart(_idResolver.idFromValue(value));\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForObject(Object value, JsonGenerator jgen,\n+            Class<?> type)\n+        throws IOException, JsonProcessingException\n+    {\n+        // wrapper\n+        jgen.writeStartObject();\n+        // and then JSON Object start caller wants\n+        jgen.writeObjectFieldStart(_idResolver.idFromValueAndType(value, type));\n+    }\n+    \n+    @Override\n+    public void writeTypePrefixForArray(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        // can still wrap ok\n+        jgen.writeStartObject();\n+        // and then JSON Array start caller wants\n+        jgen.writeArrayFieldStart(_idResolver.idFromValue(value));\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForArray(Object value, JsonGenerator jgen,\n+            Class<?> type)\n+        throws IOException, JsonProcessingException\n+    {\n+        // can still wrap ok\n+        jgen.writeStartObject();\n+        // and then JSON Array start caller wants\n+        jgen.writeArrayFieldStart(_idResolver.idFromValueAndType(value, type));\n+    }\n+    \n+    @Override\n+    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        // can still wrap ok\n+        jgen.writeStartObject();\n+        jgen.writeFieldName(_idResolver.idFromValue(value));\n+    }\n+\n+    @Override\n+    public void writeTypePrefixForScalar(Object value, JsonGenerator jgen,\n+            Class<?> type)\n+        throws IOException, JsonProcessingException\n+    {\n+        // can still wrap ok\n+        jgen.writeStartObject();\n+        jgen.writeFieldName(_idResolver.idFromValueAndType(value, type));\n+    }\n+    \n+    @Override\n+    public void writeTypeSuffixForObject(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        // first close JSON Object caller used\n+        jgen.writeEndObject();\n+        // and then wrapper\n+        jgen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void writeTypeSuffixForArray(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        // first close array caller needed\n+        jgen.writeEndArray();\n+        // then wrapper object\n+        jgen.writeEndObject();\n+    }\n+    \n+    @Override\n+    public void writeTypeSuffixForScalar(Object value, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        // just need to close the wrapper object\n+        jgen.writeEndObject();\n+    }    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.util.*;\n+\n+import org.codehaus.jackson.type.JavaType;\n+import org.codehaus.jackson.annotate.JsonTypeInfo;\n+\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+/**\n+ * {@link com.fasterxml.jackson.databind.jsontype.TypeIdResolver} implementation\n+ * that converts between fully-qualified\n+ * Java class names and (JSON) Strings.\n+ */\n+public class ClassNameIdResolver\n+    extends TypeIdResolverBase\n+{\n+    public ClassNameIdResolver(JavaType baseType, TypeFactory typeFactory) {\n+        super(baseType, typeFactory);\n+    }\n+\n+    @Override\n+    public JsonTypeInfo.Id getMechanism() { return JsonTypeInfo.Id.CLASS; }\n+\n+    public void registerSubtype(Class<?> type, String name) {\n+        // not used with class name - based resolvers\n+    }\n+    \n+    @Override\n+    public String idFromValue(Object value)\n+    {\n+        return _idFrom(value, value.getClass());\n+    }\n+\n+    @Override\n+    public String idFromValueAndType(Object value, Class<?> type)\n+    {\n+        return _idFrom(value, type);\n+    }\n+\n+    @Override\n+    public JavaType typeFromId(String id)\n+    {\n+        /* 30-Jan-2010, tatu: Most ids are basic class names; so let's first\n+         *    check if any generics info is added; and only then ask factory\n+         *    to do translation when necessary\n+         */\n+        if (id.indexOf('<') > 0) {\n+            JavaType t = TypeFactory.fromCanonical(id);\n+            // note: may want to try combining with specialization (esp for EnumMap)\n+            return t;\n+        }\n+        try {\n+            /* [JACKSON-350]: Default Class.forName() won't work too well; context class loader\n+             *    seems like slightly better choice\n+             */\n+//          Class<?> cls = Class.forName(id);\n+            ClassLoader loader = Thread.currentThread().getContextClassLoader();\n+            Class<?> cls = Class.forName(id, true, loader);\n+            return _typeFactory.constructSpecializedType(_baseType, cls);\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): no such class found\");\n+        } catch (Exception e) {\n+            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'): \"+e.getMessage(), e);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    protected final String _idFrom(Object value, Class<?> cls)\n+    {\n+        // [JACKSON-380] Need to ensure that \"enum subtypes\" work too\n+        if (Enum.class.isAssignableFrom(cls)) {\n+            if (!cls.isEnum()) { // means that it's sub-class of base enum, so:\n+                cls = cls.getSuperclass();\n+            }\n+        }\n+        String str = cls.getName();\n+        if (str.startsWith(\"java.util\")) {\n+            /* 25-Jan-2009, tatu: There are some internal classes that\n+             *   we can not access as is. We need better mechanism; for\n+             *   now this has to do...\n+             */\n+            /* Enum sets and maps are problematic since we MUST know\n+             * type of contained enums, to be able to deserialize.\n+             * In addition, EnumSet is not a concrete type either\n+             */\n+            if (value instanceof EnumSet<?>) { // Regular- and JumboEnumSet...\n+                Class<?> enumClass = ClassUtil.findEnumType((EnumSet<?>) value);\n+                // not optimal: but EnumSet is not a customizable type so this is sort of ok\n+                str = TypeFactory.defaultInstance().constructCollectionType(EnumSet.class, enumClass).toCanonical();\n+            } else if (value instanceof EnumMap<?,?>) {\n+                Class<?> enumClass = ClassUtil.findEnumType((EnumMap<?,?>) value);\n+                Class<?> valueClass = Object.class;\n+                // not optimal: but EnumMap is not a customizable type so this is sort of ok\n+                str = TypeFactory.defaultInstance().constructMapType(EnumMap.class, enumClass, valueClass).toCanonical();\n+            } else {\n+                String end = str.substring(9);\n+                if ((end.startsWith(\".Arrays$\") || end.startsWith(\".Collections$\"))\n+                       && str.indexOf(\"List\") >= 0) {\n+                    /* 17-Feb-2010, tatus: Another such case: result of\n+                     *    Arrays.asList() is named like so in Sun JDK...\n+                     *   Let's just plain old ArrayList in its place\n+                     * NOTE: chances are there are plenty of similar cases\n+                     * for other wrappers... (immutable, singleton, synced etc)\n+                     */\n+                    str = \"java.util.ArrayList\";\n+                }\n+            }\n+        } else if (str.indexOf('$') >= 0) {\n+            /* Other special handling may be needed for inner classes, [JACKSON-584].\n+             * The best way to handle would be to find 'hidden' constructor; pass parent\n+             * value etc (which is actually done for non-anonymous static classes!),\n+             * but that is just not possible due to various things. So, we will instead\n+             * try to generalize type into something we will be more likely to be able\n+             * construct.\n+             */\n+            Class<?> outer = ClassUtil.getOuterClass(cls);\n+            if (outer != null) {\n+                /* one more check: let's actually not worry if the declared\n+                 * static type is non-static as well; if so, deserializer does\n+                 * have a chance at figuring it all out.\n+                 */\n+                Class<?> staticType = _baseType.getRawClass();\n+                if (ClassUtil.getOuterClass(staticType) == null) {\n+                    // Is this always correct? Seems like it should be...\n+                    cls = _baseType.getRawClass();\n+                    str = cls.getName();\n+                }\n+            }\n+        }\n+        return str;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/MinimalClassNameIdResolver.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import org.codehaus.jackson.type.JavaType;\n+import org.codehaus.jackson.annotate.JsonTypeInfo;\n+\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+public class MinimalClassNameIdResolver\n+    extends ClassNameIdResolver\n+{\n+    /**\n+     * Package name of the base class, to be used for determining common\n+     * prefix that can be omitted from included type id.\n+     * Does not include the trailing dot.\n+     */\n+    protected final String _basePackageName;\n+\n+    /**\n+     * Same as {@link #_basePackageName}, but includes trailing dot.\n+     */\n+    protected final String _basePackagePrefix;\n+    \n+    protected MinimalClassNameIdResolver(JavaType baseType, TypeFactory typeFactory)\n+    {\n+        super(baseType, typeFactory);\n+        String base = baseType.getRawClass().getName();\n+        int ix = base.lastIndexOf('.');\n+        if (ix < 0) { // can this ever occur?\n+            _basePackageName = \"\";\n+            _basePackagePrefix = \".\";\n+        } else {\n+            _basePackagePrefix = base.substring(0, ix+1);\n+            _basePackageName = base.substring(0, ix);\n+        }\n+    }\n+\n+    @Override\n+    public JsonTypeInfo.Id getMechanism() { return JsonTypeInfo.Id.MINIMAL_CLASS; }\n+    \n+    @Override\n+    public String idFromValue(Object value)\n+    {\n+        String n = value.getClass().getName();\n+        if (n.startsWith(_basePackagePrefix)) {\n+            // note: we will leave the leading dot in there\n+            return n.substring(_basePackagePrefix.length()-1);\n+        }\n+        return n;\n+    }\n+\n+    @Override\n+    public JavaType typeFromId(String id)\n+    {\n+        if (id.startsWith(\".\")) {\n+            StringBuilder sb = new StringBuilder(id.length() + _basePackageName.length());\n+            if  (_basePackageName.length() == 0) {\n+                // no package; must remove leading '.' from id\n+                sb.append(id.substring(1));\n+            } else {\n+                // otherwise just concatenate package, with leading-dot-partial name\n+                sb.append(_basePackageName).append(id);\n+            }\n+            id = sb.toString();\n+        }\n+        return super.typeFromId(id);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdSubtypeResolver.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+\n+/**\n+ * @since 1.5\n+ */\n+public class StdSubtypeResolver extends SubtypeResolver\n+{\n+    protected LinkedHashSet<NamedType> _registeredSubtypes;\n+\n+    public StdSubtypeResolver() { }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    @Override    \n+    public void registerSubtypes(NamedType... types)\n+    {\n+        if (_registeredSubtypes == null) {\n+            _registeredSubtypes = new LinkedHashSet<NamedType>();\n+        }\n+        for (NamedType type : types) {\n+            _registeredSubtypes.add(type);\n+        }\n+    }\n+\n+    @Override\n+    public void registerSubtypes(Class<?>... classes)\n+    {\n+        NamedType[] types = new NamedType[classes.length];\n+        for (int i = 0, len = classes.length; i < len; ++i) {\n+            types[i] = new NamedType(classes[i]);\n+        }\n+        registerSubtypes(types);\n+    }\n+    \n+    /**\n+     * \n+     * @param property Base member to use for type resolution: either annotated type (class),\n+     *    or property (field, getter/setter)\n+     */\n+    @Override\n+    public Collection<NamedType> collectAndResolveSubtypes(AnnotatedMember property,\n+        MapperConfig<?> config, AnnotationIntrospector ai)\n+    {\n+        HashMap<NamedType, NamedType> collected = new HashMap<NamedType, NamedType>();\n+        // start with registered subtypes (which have precedence)\n+        if (_registeredSubtypes != null) {\n+            Class<?> rawBase = property.getRawType();\n+            for (NamedType subtype : _registeredSubtypes) {\n+                // is it a subtype of root type?\n+                if (rawBase.isAssignableFrom(subtype.getType())) { // yes\n+                    AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config);\n+                    _collectAndResolve(curr, subtype, config, ai, collected);\n+                }\n+            }\n+        }\n+\n+        // then annotated types for property itself\n+        Collection<NamedType> st = ai.findSubtypes(property);\n+        if (st != null) {\n+            for (NamedType nt : st) {\n+                AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(nt.getType(), ai, config);\n+                _collectAndResolve(ac, nt, config, ai, collected);\n+            }            \n+        }\n+        NamedType rootType = new NamedType(property.getRawType(), null);\n+        AnnotatedClass ac = AnnotatedClass.constructWithoutSuperTypes(property.getRawType(), ai, config);\n+            \n+        // and finally subtypes via annotations from base type (recursively)\n+        _collectAndResolve(ac, rootType, config, ai, collected);\n+        return new ArrayList<NamedType>(collected.values());\n+    }\n+\n+    @Override\n+    public Collection<NamedType> collectAndResolveSubtypes(AnnotatedClass type,\n+            MapperConfig<?> config, AnnotationIntrospector ai)\n+    {\n+        HashMap<NamedType, NamedType> subtypes = new HashMap<NamedType, NamedType>();\n+        // [JACKSON-257] then consider registered subtypes (which have precedence over annotations)\n+        if (_registeredSubtypes != null) {\n+            Class<?> rawBase = type.getRawType();\n+            for (NamedType subtype : _registeredSubtypes) {\n+                // is it a subtype of root type?\n+                if (rawBase.isAssignableFrom(subtype.getType())) { // yes\n+                    AnnotatedClass curr = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config);\n+                    _collectAndResolve(curr, subtype, config, ai, subtypes);\n+                }\n+            }\n+        }\n+        // and then check subtypes via annotations from base type (recursively)\n+        NamedType rootType = new NamedType(type.getRawType(), null);\n+        _collectAndResolve(type, rootType, config, ai, subtypes);\n+        return new ArrayList<NamedType>(subtypes.values());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called to find subtypes for a specific type (class)\n+     */\n+    protected void _collectAndResolve(AnnotatedClass annotatedType, NamedType namedType,\n+            MapperConfig<?> config, AnnotationIntrospector ai, HashMap<NamedType, NamedType> collectedSubtypes)\n+    {\n+        if (!namedType.hasName()) {\n+            String name = ai.findTypeName(annotatedType);\n+            if (name != null) {\n+                namedType = new NamedType(namedType.getType(), name);\n+            }\n+        }\n+\n+        // First things first: is base type itself included?\n+        if (collectedSubtypes.containsKey(namedType)) {\n+            // if so, no recursion; however, may need to update name?\n+            if (namedType.hasName()) {\n+                NamedType prev = collectedSubtypes.get(namedType);\n+                if (!prev.hasName()) {\n+                    collectedSubtypes.put(namedType, namedType);\n+                }\n+            }\n+            return;\n+        }\n+        // if it wasn't, add and check subtypes recursively\n+        collectedSubtypes.put(namedType, namedType);\n+        Collection<NamedType> st = ai.findSubtypes(annotatedType);\n+        if (st != null && !st.isEmpty()) {\n+            for (NamedType subtype : st) {\n+                AnnotatedClass subtypeClass = AnnotatedClass.constructWithoutSuperTypes(subtype.getType(), ai, config);\n+                // One more thing: name may be either in reference, or in subtype:\n+                if (!subtype.hasName()) {\n+                    subtype = new NamedType(subtype.getType(), ai.findTypeName(subtypeClass));\n+                }\n+                _collectAndResolve(subtypeClass, subtype, config, ai, collectedSubtypes);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/StdTypeResolverBuilder.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.util.Collection;\n+\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+\n+\n+/**\n+ * Default {@link TypeResolverBuilder} implementation.\n+ *\n+ * @author tatu\n+ */\n+public class StdTypeResolverBuilder\n+    implements TypeResolverBuilder<StdTypeResolverBuilder>\n+{\n+    // Configuration settings:\n+\n+    protected JsonTypeInfo.Id _idType;\n+\n+    protected JsonTypeInfo.As _includeAs;\n+\n+    protected String _typeProperty;\n+\n+    /**\n+     * @since 1.9\n+     */\n+    protected Class<?> _defaultImpl;\n+    \n+    // Objects\n+    \n+    protected TypeIdResolver _customIdResolver;\n+\n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Class<?> getDefaultImpl() {\n+        return _defaultImpl;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Construction, initialization, actual building\n+    /**********************************************************\n+     */\n+\n+    public StdTypeResolverBuilder() { }\n+    \n+    @Override\n+    public StdTypeResolverBuilder init(JsonTypeInfo.Id idType, TypeIdResolver idRes)\n+    {\n+        // sanity checks\n+        if (idType == null) {\n+            throw new IllegalArgumentException(\"idType can not be null\");\n+        }\n+        _idType = idType;\n+        _customIdResolver = idRes;\n+        // Let's also initialize property name as per idType default\n+        _typeProperty = idType.getDefaultPropertyName();\n+        return this;\n+    }\n+    \n+    @Override\n+    public TypeSerializer buildTypeSerializer(SerializationConfig config,\n+            JavaType baseType, Collection<NamedType> subtypes, BeanProperty property)\n+    {\n+        TypeIdResolver idRes = idResolver(config, baseType, subtypes, true, false);\n+        switch (_includeAs) {\n+        case WRAPPER_ARRAY:\n+            return new AsArrayTypeSerializer(idRes, property);\n+        case PROPERTY:\n+            return new AsPropertyTypeSerializer(idRes, property, _typeProperty);\n+        case WRAPPER_OBJECT:\n+            return new AsWrapperTypeSerializer(idRes, property);\n+        case EXTERNAL_PROPERTY:\n+            return new AsExternalTypeSerializer(idRes, property, _typeProperty);\n+        }\n+        throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n+    }\n+    \n+    @Override\n+    public TypeDeserializer buildTypeDeserializer(DeserializationConfig config,\n+            JavaType baseType, Collection<NamedType> subtypes, BeanProperty property)\n+    {\n+        TypeIdResolver idRes = idResolver(config, baseType, subtypes, false, true);\n+        \n+        // First, method for converting type info to type id:\n+        switch (_includeAs) {\n+        case WRAPPER_ARRAY:\n+            return new AsArrayTypeDeserializer(baseType, idRes, property, _defaultImpl);\n+        case PROPERTY:\n+            return new AsPropertyTypeDeserializer(baseType, idRes, property,\n+                    _defaultImpl, _typeProperty);\n+        case WRAPPER_OBJECT:\n+            return new AsWrapperTypeDeserializer(baseType, idRes, property, _defaultImpl);\n+        case EXTERNAL_PROPERTY:\n+            return new AsExternalTypeDeserializer(baseType, idRes, property,\n+                    _defaultImpl, _typeProperty);\n+        }\n+        throw new IllegalStateException(\"Do not know how to construct standard type serializer for inclusion type: \"+_includeAs);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Construction, configuration\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public StdTypeResolverBuilder inclusion(JsonTypeInfo.As includeAs) {\n+        if (includeAs == null) {\n+            throw new IllegalArgumentException(\"includeAs can not be null\");\n+        }\n+        _includeAs = includeAs;\n+        return this;\n+    }\n+\n+    /**\n+     * Method for constructing an instance with specified type property name\n+     * (property name to use for type id when using \"as-property\" inclusion).\n+     */\n+    @Override\n+    public StdTypeResolverBuilder typeProperty(String typeIdPropName)\n+    {\n+        // ok to have null/empty; will restore to use defaults\n+        if (typeIdPropName == null || typeIdPropName.length() == 0) {\n+            typeIdPropName = _idType.getDefaultPropertyName();\n+        }\n+        _typeProperty = typeIdPropName;\n+        return this;\n+    }\n+\n+    @Override\n+    public StdTypeResolverBuilder defaultImpl(Class<?> defaultImpl)\n+    {\n+        _defaultImpl = defaultImpl;\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+\n+    public String getTypeProperty() { return _typeProperty; }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method that will either return configured custom\n+     * type id resolver, or construct a standard resolver\n+     * given configuration.\n+     */\n+    protected TypeIdResolver idResolver(MapperConfig<?> config,\n+            JavaType baseType, Collection<NamedType> subtypes,\n+            boolean forSer, boolean forDeser)\n+    {\n+        // Custom id resolver?\n+        if (_customIdResolver != null) {\n+            return _customIdResolver;\n+        }\n+        if (_idType == null) {\n+            throw new IllegalStateException(\"Can not build, 'init()' not yet called\");\n+        }\n+        switch (_idType) {\n+        case CLASS:\n+            return new ClassNameIdResolver(baseType, config.getTypeFactory());\n+        case MINIMAL_CLASS:\n+            return new MinimalClassNameIdResolver(baseType, config.getTypeFactory());\n+        case NAME:\n+            return TypeNameIdResolver.construct(config, baseType, subtypes, forSer, forDeser);\n+\n+        case CUSTOM: // need custom resolver...\n+        case NONE: // hmmh. should never get this far with 'none'\n+        }\n+        throw new IllegalStateException(\"Do not know how to construct standard type id resolver for idType: \"+_idType);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+\n+import org.codehaus.jackson.*;\n+import org.codehaus.jackson.annotate.JsonTypeInfo;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.TypeDeserializer;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * @since 1.5\n+ * @author tatus\n+ */\n+public abstract class TypeDeserializerBase extends TypeDeserializer\n+{\n+    protected final TypeIdResolver _idResolver;\n+    \n+    protected final JavaType _baseType;\n+\n+    protected final BeanProperty _property;\n+\n+    /**\n+     * Type to use as the default implementation, if type id is\n+     * missing or can not be resolved.\n+     * \n+     * @since 1.9\n+     */\n+    protected final JavaType _defaultImpl;\n+    \n+    /**\n+     * For efficient operation we will lazily build mappings from type ids\n+     * to actual deserializers, once needed.\n+     */\n+    protected final HashMap<String,JsonDeserializer<Object>> _deserializers;\n+\n+    /**\n+     * @since 1.9\n+     */\n+    protected JsonDeserializer<Object> _defaultImplDeserializer;\n+    \n+    /**\n+     * @deprecated Since 1.9, use the constructor that takes 'defaultImpl'\n+     */\n+    @Deprecated\n+    protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, BeanProperty property) {\n+        this(baseType, idRes, property, null);\n+    }\n+\n+    protected TypeDeserializerBase(JavaType baseType, TypeIdResolver idRes, BeanProperty property,\n+            Class<?> defaultImpl)\n+    {\n+        _baseType = baseType;\n+        _idResolver = idRes;\n+        _property = property;\n+        _deserializers = new HashMap<String,JsonDeserializer<Object>>();\n+        if (defaultImpl == null) {\n+            _defaultImpl = null;\n+        } else {\n+            /* 16-Oct-2011, tatu: should call this via TypeFactory; this is\n+             *    not entirely safe... however, since Collections/Maps are\n+             *    seldom (if ever) base types, may be ok.\n+             */\n+            _defaultImpl = baseType.forcedNarrowBy(defaultImpl);\n+        }\n+    }\n+\n+    @Override\n+    public abstract JsonTypeInfo.As getTypeInclusion();\n+\n+    public String baseTypeName() { return _baseType.getRawClass().getName(); }\n+\n+    @Override\n+    public String getPropertyName() { return null; }\n+    \n+    @Override    \n+    public TypeIdResolver getTypeIdResolver() { return _idResolver; }\n+\n+    @Override    \n+    public Class<?> getDefaultImpl() {\n+        return (_defaultImpl == null) ? null : _defaultImpl.getRawClass();\n+    }\n+    \n+    @Override\n+    public String toString()\n+    {\n+    \tStringBuilder sb = new StringBuilder();\n+    \tsb.append('[').append(getClass().getName());\n+    \tsb.append(\"; base-type:\").append(_baseType);\n+    \tsb.append(\"; id-resolver: \").append(_idResolver);\n+    \tsb.append(']');\n+    \treturn sb.toString();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods for sub-classes\n+    /**********************************************************\n+     */\n+\n+    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonDeserializer<Object> deser;\n+\n+        synchronized (_deserializers) {\n+            deser = _deserializers.get(typeId);\n+            if (deser == null) {\n+                JavaType type = _idResolver.typeFromId(typeId);\n+                if (type == null) {\n+                    // As per [JACKSON-614], use the default impl if no type id available:\n+                    if (_defaultImpl == null) {\n+                        throw ctxt.unknownTypeException(_baseType, typeId);\n+                    }\n+                    deser = _findDefaultImplDeserializer(ctxt);\n+                } else {\n+                    /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n+                     *   we actually now need to explicitly narrow from base type (which may have parameterization)\n+                     *   using raw type.\n+                     *   \n+                     *   One complication, though; can not change 'type class' (simple type to container); otherwise\n+                     *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n+                     *   type in process (getting SimpleType of Map.class which will not work as expected)\n+                     */\n+                    if (_baseType != null && _baseType.getClass() == type.getClass()) {\n+                        type = _baseType.narrowBy(type.getRawClass());\n+                    }\n+                    deser = ctxt.getDeserializerProvider().findValueDeserializer(ctxt.getConfig(), type, _property);\n+                }\n+                _deserializers.put(typeId, deser);\n+            }\n+        }\n+        return deser;\n+    }\n+\n+    protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_defaultImpl == null) {\n+            return null;\n+        }\n+        synchronized (_defaultImpl) {\n+            if (_defaultImplDeserializer == null) {\n+                _defaultImplDeserializer = ctxt.getDeserializerProvider().findValueDeserializer(ctxt.getConfig(),\n+                        _defaultImpl, _property);\n+            }\n+            return _defaultImplDeserializer;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeIdResolverBase.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+public abstract class TypeIdResolverBase\n+    implements TypeIdResolver\n+{\n+    protected final TypeFactory _typeFactory;\n+\n+    /**\n+     * Common base type for all polymorphic instances handled.\n+     */\n+    protected final JavaType _baseType;\n+\n+    protected TypeIdResolverBase(JavaType baseType, TypeFactory typeFactory)\n+    {\n+        _baseType = baseType;\n+        _typeFactory = typeFactory;\n+    }\n+\n+    @Override\n+    public void init(JavaType bt) {\n+        /* Standard type id resolvers do not need this;\n+         * only useful for custom ones.\n+         */\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeNameIdResolver.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import java.util.*;\n+\n+import org.codehaus.jackson.annotate.JsonTypeInfo;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+\n+public class TypeNameIdResolver\n+    extends TypeIdResolverBase\n+{\n+    /**\n+     * @since 1.8\n+     */\n+    protected final MapperConfig<?> _config;\n+    \n+    /**\n+     * Mappings from class name to type id, used for serialization\n+     */\n+    protected final HashMap<String, String> _typeToId;\n+\n+    /**\n+     * Mappings from type id to JavaType, used for deserialization\n+     */\n+    protected final HashMap<String, JavaType> _idToType;\n+    \n+    protected TypeNameIdResolver(MapperConfig<?> config, JavaType baseType,\n+            HashMap<String, String> typeToId, HashMap<String, JavaType> idToType)\n+    {\n+        super(baseType, config.getTypeFactory());\n+        _config = config;\n+        _typeToId = typeToId;\n+        _idToType = idToType;\n+    }\n+ \n+    public static TypeNameIdResolver construct(MapperConfig<?> config,\n+            JavaType baseType,\n+            Collection<NamedType> subtypes, boolean forSer, boolean forDeser)\n+    {\n+        // sanity check\n+        if (forSer == forDeser) throw new IllegalArgumentException();\n+        HashMap<String, String> typeToId = null;\n+        HashMap<String, JavaType> idToType = null;\n+\n+        if (forSer) {\n+            typeToId = new HashMap<String, String>();\n+        }\n+        if (forDeser) {\n+            idToType = new HashMap<String, JavaType>();\n+        }\n+        if (subtypes != null) {\n+            for (NamedType t : subtypes) {\n+                /* no name? Need to figure out default; for now, let's just\n+                 * use non-qualified class name\n+                 */\n+                Class<?> cls = t.getType();\n+                String id = t.hasName() ? t.getName() : _defaultTypeId(cls);\n+                if (forSer) {\n+                    typeToId.put(cls.getName(), id);\n+                }\n+                if (forDeser) {\n+                    /* 24-Feb-2011, tatu: [JACKSON-498] One more problem; sometimes\n+                     *   we have same name for multiple types; if so, use most specific\n+                     *   one.\n+                     */\n+                    JavaType prev = idToType.get(id);\n+                    if (prev != null) { // Can only override if more specific\n+                        if (cls.isAssignableFrom(prev.getRawClass())) { // nope, more generic (or same)\n+                            continue;\n+                        }\n+                    }\n+                    idToType.put(id, config.constructType(cls));\n+                }\n+            }\n+        }\n+        return new TypeNameIdResolver(config, baseType, typeToId, idToType);\n+    }\n+\n+    @Override\n+    public JsonTypeInfo.Id getMechanism() { return JsonTypeInfo.Id.NAME; }\n+\n+    @Override\n+    public String idFromValue(Object value)\n+    {\n+        Class<?> cls = value.getClass();\n+        final String key = cls.getName();\n+        String name;\n+        synchronized (_typeToId) {\n+            name = _typeToId.get(key);\n+            if (name == null) {\n+                // 24-Feb-2011, tatu: As per [JACKSON-498], may need to dynamically look up name\n+                // can either throw an exception, or use default name...\n+                if (_config.isAnnotationProcessingEnabled()) {\n+                    BasicBeanDescription beanDesc = _config.introspectClassAnnotations(cls);\n+                    name = _config.getAnnotationIntrospector().findTypeName(beanDesc.getClassInfo());\n+                }\n+                if (name == null) {\n+                    // And if still not found, let's choose default?\n+                    name = _defaultTypeId(cls);\n+                }\n+                _typeToId.put(key, name);\n+            }\n+        }\n+        return name;\n+    }\n+\n+    @Override\n+    public String idFromValueAndType(Object value, Class<?> type)\n+    {\n+        return idFromValue(value);\n+    }\n+    \n+    @Override\n+    public JavaType typeFromId(String id)\n+        throws IllegalArgumentException\n+    {\n+        JavaType t = _idToType.get(id);\n+        /* Now: if no type is found, should we try to locate it by\n+         * some other means? (specifically, if in same package as base type,\n+         * could just try Class.forName)\n+         * For now let's not add any such workarounds; can add if need be\n+         */\n+        return t;\n+    }    \n+\n+    @Override\n+    public String toString()\n+    {\n+    \tStringBuilder sb = new StringBuilder();\n+    \tsb.append('[').append(getClass().getName());\n+    \tsb.append(\"; id-to-type=\").append(_idToType);\n+    \tsb.append(']');\n+    \treturn sb.toString();\n+    }\n+    \n+    /*\n+    /*********************************************************\n+    /* Helper methods\n+    /*********************************************************\n+     */\n+    \n+    /**\n+     * If no name was explicitly given for a class, we will just\n+     * use non-qualified class name\n+     */\n+    protected static String _defaultTypeId(Class<?> cls)\n+    {\n+        String n = cls.getName();\n+        int ix = n.lastIndexOf('.');\n+        return (ix < 0) ? n : n.substring(ix+1);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeSerializerBase.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import org.codehaus.jackson.annotate.JsonTypeInfo;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n+\n+/**\n+ * @since 1.5\n+ */\n+public abstract class TypeSerializerBase extends TypeSerializer\n+{\n+    protected final TypeIdResolver _idResolver;\n+\n+    protected final BeanProperty _property;\n+    \n+    protected TypeSerializerBase(TypeIdResolver idRes, BeanProperty property)\n+    {\n+        _idResolver = idRes;\n+        _property = property;\n+    }\n+\n+    @Override\n+    public abstract JsonTypeInfo.As getTypeInclusion();\n+\n+    @Override\n+    public String getPropertyName() { return null; }\n+    \n+    @Override\n+    public TypeIdResolver getTypeIdResolver() { return _idResolver; }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/package-info.java\n+/**\n+ * Package that contains standard implementations for\n+ * {@link com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder}\n+ * and\n+ * {@link com.fasterxml.jackson.databind.jsontype.TypeIdResolver}.\n+ *\n+ * @since 1.5\n+ */\n+package com.fasterxml.jackson.databind.jsontype.impl;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/package-info.java\n+/**\n+ * Package that contains interfaces that define how to implement\n+ * functionality for dynamically resolving type during deserialization.\n+ * This is needed for complete handling of polymorphic types, where\n+ * actual type can not be determined statically (declared type is\n+ * a supertype of actual polymorphic serialized types).\n+ *\n+ * @since 1.5\n+ */\n+package com.fasterxml.jackson.databind.jsontype;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleAbstractTypeResolver.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.AbstractTypeResolver;\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+\n+/**\n+ * Simple {@link AbstractTypeResolver} implementation, which is\n+ * based on static mapping from abstract super types into\n+ * sub types (concrete or abstract), but retaining generic\n+ * parameterization.\n+ * Can be used for things like specifying which implementation of\n+ * {@link java.util.Collection} to use:\n+ *<pre>\n+ *  SimpleAbstractTypeResolver resolver = new SimpleAbstractTypeResolver();\n+ *  // To make all properties declared as Collection, List, to LinkedList\n+ *  resolver.addMapping(Collection.class, LinkedList.class);\n+ *  resolver.addMapping(List.class, LinkedList.class);\n+ *</pre>\n+ * Can also be used as an alternative to per-class annotations when defining\n+ * concrete implementations; however, only works with abstract types (since\n+ * this is only called for abstract types)\n+ *\n+ * @since 1.8\n+ */\n+public class SimpleAbstractTypeResolver extends AbstractTypeResolver\n+{\n+    /**\n+     * Mappings from super types to subtypes\n+     */\n+    protected final HashMap<ClassKey,Class<?>> _mappings = new HashMap<ClassKey,Class<?>>();\n+\n+    /**\n+     * Method for adding a mapping from super type to specific subtype.\n+     * Arguments will be checked by method, to ensure that <code>superType</code>\n+     * is abstract (since resolver is never called for concrete classes);\n+     * as well as to ensure that there is supertype/subtype relationship\n+     * (to ensure there won't be cycles during resolution).\n+     * \n+     * @param superType Abstract type to resolve\n+     * @param subType Sub-class of superType, to map superTo to\n+     * \n+     * @return This resolver, to allow chaining of initializations\n+     */\n+    public <T> SimpleAbstractTypeResolver addMapping(Class<T> superType, Class<? extends T> subType)\n+    {\n+        // Sanity checks, just in case someone tries to force typing...\n+        if (superType == subType) {\n+            throw new IllegalArgumentException(\"Can not add mapping from class to itself\");\n+        }\n+        if (!superType.isAssignableFrom(subType)) {\n+            throw new IllegalArgumentException(\"Can not add mapping from class \"+superType.getName()\n+                    +\" to \"+subType.getName()+\", as latter is not a subtype of former\");\n+        }\n+        if (!Modifier.isAbstract(superType.getModifiers())) {\n+            throw new IllegalArgumentException(\"Can not add mapping from class \"+superType.getName()\n+                    +\" since it is not abstract\");\n+        }\n+        _mappings.put(new ClassKey(superType), subType);\n+        return this;\n+    }\n+\n+    @Override\n+    public JavaType findTypeMapping(DeserializationConfig config, JavaType type)\n+    {\n+        // this is the main mapping base, so let's \n+        Class<?> src = type.getRawClass();\n+        Class<?> dst = _mappings.get(new ClassKey(src));\n+        if (dst == null) {\n+            return null;\n+        }\n+        return type.narrowBy(dst);\n+    }\n+\n+    \n+    @Override\n+    public JavaType resolveAbstractType(DeserializationConfig config, JavaType type)\n+    {\n+        // never materialize anything, so:\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleDeserializers.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import java.util.*;\n+\n+import org.codehaus.jackson.JsonNode;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.type.*;\n+\n+/**\n+ * Simple implementation {@link Deserializers} which allows registration of\n+ * deserializers based on raw (type erased class).\n+ * It can work well for basic bean and scalar type deserializers, but is not\n+ * a good fit for handling generic types (like {@link Map}s and {@link Collection}s\n+ * or array types).\n+ *<p>\n+ * Unlike {@link SimpleSerializers}, this class does not currently support generic mappings;\n+ * all mappings must be to exact declared deserialization type.\n+ * \n+ * @since 1.7\n+ */\n+public class SimpleDeserializers implements Deserializers\n+{\n+    protected HashMap<ClassKey,JsonDeserializer<?>> _classMappings = null;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, construction and configuring\n+    /**********************************************************\n+     */\n+    \n+    public SimpleDeserializers() { }\n+\n+    public <T> void addDeserializer(Class<T> forClass, JsonDeserializer<? extends T> deser)\n+    {\n+        ClassKey key = new ClassKey(forClass);\n+        if (_classMappings == null) {\n+            _classMappings = new HashMap<ClassKey,JsonDeserializer<?>>();\n+        }\n+        _classMappings.put(key, deser);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Serializers implementation\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonDeserializer<?> findArrayDeserializer(ArrayType type,\n+            DeserializationConfig config, DeserializerProvider provider,\n+            BeanProperty property,\n+            TypeDeserializer elementTypeDeserializer,\n+            JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass()));\n+    }\n+\n+    @Override\n+    public JsonDeserializer<?> findBeanDeserializer(JavaType type,\n+            DeserializationConfig config, DeserializerProvider provider,\n+            BeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass()));\n+    }\n+\n+    @Override\n+    public JsonDeserializer<?> findCollectionDeserializer(CollectionType type,\n+            DeserializationConfig config, DeserializerProvider provider,\n+            BeanDescription beanDesc, BeanProperty property,\n+            TypeDeserializer elementTypeDeserializer,\n+            JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass()));\n+    }\n+\n+    @Override\n+    public JsonDeserializer<?> findCollectionLikeDeserializer(CollectionLikeType type,\n+            DeserializationConfig config, DeserializerProvider provider,\n+            BeanDescription beanDesc, BeanProperty property,\n+            TypeDeserializer elementTypeDeserializer,\n+            JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass()));\n+    }\n+    \n+    @Override\n+    public JsonDeserializer<?> findEnumDeserializer(Class<?> type,\n+            DeserializationConfig config, BeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type));\n+    }\n+\n+    @Override\n+    public JsonDeserializer<?> findMapDeserializer(MapType type,\n+            DeserializationConfig config, DeserializerProvider provider,\n+            BeanDescription beanDesc, BeanProperty property,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer,\n+            JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass()));\n+    }\n+\n+    @Override\n+    public JsonDeserializer<?> findMapLikeDeserializer(MapLikeType type,\n+            DeserializationConfig config, DeserializerProvider provider,\n+            BeanDescription beanDesc, BeanProperty property,\n+            KeyDeserializer keyDeserializer,\n+            TypeDeserializer elementTypeDeserializer,\n+            JsonDeserializer<?> elementDeserializer)\n+        throws JsonMappingException\n+    {\n+        return (_classMappings == null) ? null : _classMappings.get(new ClassKey(type.getRawClass()));\n+    }\n+    \n+    @Override\n+    public JsonDeserializer<?> findTreeNodeDeserializer(Class<? extends JsonNode> nodeType,\n+            DeserializationConfig config, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        return (_classMappings == null) ? null : _classMappings.get(new ClassKey(nodeType));\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleKeyDeserializers.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+\n+/**\n+ * Simple implementation {@link KeyDeserializers} which allows registration of\n+ * deserializers based on raw (type erased class).\n+ * It can work well for basic bean and scalar type deserializers, but is not\n+ * a good fit for handling generic types (like {@link Map}s and {@link Collection}s\n+ * or array types).\n+ *<p>\n+ * Unlike {@link SimpleSerializers}, this class does not currently support generic mappings;\n+ * all mappings must be to exact declared deserialization type.\n+ * \n+ * @since 1.7\n+ */\n+public class SimpleKeyDeserializers implements KeyDeserializers\n+{\n+    protected HashMap<ClassKey,KeyDeserializer> _classMappings = null;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, construction and configuring\n+    /**********************************************************\n+     */\n+    \n+    public SimpleKeyDeserializers() { }\n+\n+    public SimpleKeyDeserializers addDeserializer(Class<?> forClass, KeyDeserializer deser)\n+    {\n+        if (_classMappings == null) {\n+            _classMappings = new HashMap<ClassKey,KeyDeserializer>();\n+        }\n+        _classMappings.put(new ClassKey(forClass), deser);\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serializers implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public KeyDeserializer findKeyDeserializer(JavaType type, DeserializationConfig config, \n+            BeanDescription beanDesc, BeanProperty property)\n+    {\n+        if (_classMappings == null) {\n+            return null;\n+        }\n+        return _classMappings.get(new ClassKey(type.getRawClass()));\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.codehaus.jackson.Version;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+\n+/**\n+ * Simple {@link Module} implementation that allows registration\n+ * of serializers and deserializers, and bean serializer\n+ * and deserializer modifiers.\n+ * \n+ * @since 1.7\n+ */\n+public class SimpleModule extends Module\n+{\n+    protected final String _name;\n+    protected final Version _version;\n+    \n+    protected SimpleSerializers _serializers = null;\n+    protected SimpleDeserializers _deserializers = null;\n+\n+    protected SimpleSerializers _keySerializers = null;\n+    protected SimpleKeyDeserializers _keyDeserializers = null;\n+\n+    /**\n+     * Lazily-constructed resolver used for storing mappings from\n+     * abstract classes to more specific implementing classes\n+     * (which may be abstract or concrete)\n+     */\n+    protected SimpleAbstractTypeResolver _abstractTypes = null;\n+\n+    /**\n+     * Lazily-constructed resolver used for storing mappings from\n+     * abstract classes to more specific implementing classes\n+     * (which may be abstract or concrete)\n+     */\n+    protected SimpleValueInstantiators _valueInstantiators = null;\n+\n+    /**\n+     * Lazily-constructed map that contains mix-in definitions, indexed\n+     * by target class, value being mix-in to apply.\n+     * \n+     * @since 1.9\n+     */\n+    protected HashMap<Class<?>, Class<?>> _mixins = null;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: creation\n+    /**********************************************************\n+     */\n+    \n+    public SimpleModule(String name, Version version)\n+    {\n+        _name = name;\n+        _version = version;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Simple setters to allow overriding\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Resets all currently configured serializers.\n+     * \n+     * @since 1.9\n+     */\n+    public void setSerializers(SimpleSerializers s) {\n+        _serializers = s;\n+    }\n+\n+    /**\n+     * Resets all currently configured deserializers.\n+     * \n+     * @since 1.9\n+     */\n+    public void setDeserializers(SimpleDeserializers d) {\n+        _deserializers = d;\n+    }\n+\n+    /**\n+     * Resets all currently configured key serializers.\n+     * \n+     * @since 1.9\n+     */\n+    public void setKeySerializers(SimpleSerializers ks) {\n+        _keySerializers = ks;\n+    }\n+\n+    /**\n+     * Resets all currently configured key deserializers.\n+     * \n+     * @since 1.9\n+     */\n+    public void setKeyDeserializers(SimpleKeyDeserializers kd) {\n+        _keyDeserializers = kd;\n+    }\n+\n+    /**\n+     * Resets currently configured abstract type mappings\n+     *\n+     * @since 1.9\n+     */\n+    public void setAbstractTypes(SimpleAbstractTypeResolver atr) {\n+        _abstractTypes = atr;        \n+    }\n+\n+    /**\n+     * Resets all currently configured value instantiators\n+     * \n+     * @since 1.9\n+     */\n+    public void setValueInstantiators(SimpleValueInstantiators svi) {\n+        _valueInstantiators = svi;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration methods\n+    /**********************************************************\n+     */\n+    \n+    public SimpleModule addSerializer(JsonSerializer<?> ser)\n+    {\n+        if (_serializers == null) {\n+            _serializers = new SimpleSerializers();\n+        }\n+        _serializers.addSerializer(ser);\n+        return this;\n+    }\n+    \n+    public <T> SimpleModule addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n+    {\n+        if (_serializers == null) {\n+            _serializers = new SimpleSerializers();\n+        }\n+        _serializers.addSerializer(type, ser);\n+        return this;\n+    }\n+\n+    public <T> SimpleModule addKeySerializer(Class<? extends T> type, JsonSerializer<T> ser)\n+    {\n+        if (_keySerializers == null) {\n+            _keySerializers = new SimpleSerializers();\n+        }\n+        _keySerializers.addSerializer(type, ser);\n+        return this;\n+    }\n+    \n+    public <T> SimpleModule addDeserializer(Class<T> type, JsonDeserializer<? extends T> deser)\n+    {\n+        if (_deserializers == null) {\n+            _deserializers = new SimpleDeserializers();\n+        }\n+        _deserializers.addDeserializer(type, deser);\n+        return this;\n+    }\n+\n+    public SimpleModule addKeyDeserializer(Class<?> type, KeyDeserializer deser)\n+    {\n+        if (_keyDeserializers == null) {\n+            _keyDeserializers = new SimpleKeyDeserializers();\n+        }\n+        _keyDeserializers.addDeserializer(type, deser);\n+        return this;\n+    }\n+\n+    /**\n+     * Lazily-constructed resolver used for storing mappings from\n+     * abstract classes to more specific implementing classes\n+     * (which may be abstract or concrete)\n+     */\n+    public <T> SimpleModule addAbstractTypeMapping(Class<T> superType,\n+            Class<? extends T> subType)\n+    {\n+        if (_abstractTypes == null) {\n+            _abstractTypes = new SimpleAbstractTypeResolver();\n+        }\n+        // note: addMapping() will verify arguments\n+        _abstractTypes = _abstractTypes.addMapping(superType, subType);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for registering {@link ValueInstantiator} to use when deserializing\n+     * instances of type <code>beanType</code>.\n+     *<p>\n+     * Instantiator is\n+     * registered when module is registered for <code>ObjectMapper</code>.\n+     */\n+    public SimpleModule addValueInstantiator(Class<?> beanType, ValueInstantiator inst)\n+    {\n+        if (_valueInstantiators == null) {\n+            _valueInstantiators = new SimpleValueInstantiators();\n+        }\n+        _valueInstantiators = _valueInstantiators.addValueInstantiator(beanType, inst);\n+        return this;\n+    }\n+\n+    /**\n+     * Method for specifying that annotations define by <code>mixinClass</code>\n+     * should be \"mixed in\" with annotations that <code>targetType</code>\n+     * has (as if they were directly included on it!).\n+     *<p>\n+     * Mix-in annotations are\n+     * registered when module is registered for <code>ObjectMapper</code>.\n+     */\n+    public SimpleModule setMixInAnnotation(Class<?> targetType, Class<?> mixinClass)\n+    {\n+        if (_mixins == null) {\n+            _mixins = new HashMap<Class<?>, Class<?>>();\n+        }\n+        _mixins.put(targetType, mixinClass);\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Module impl\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public String getModuleName() {\n+        return _name;\n+    }\n+\n+    @Override\n+    public void setupModule(SetupContext context)\n+    {\n+        if (_serializers != null) {\n+            context.addSerializers(_serializers);\n+        }\n+        if (_deserializers != null) {\n+            context.addDeserializers(_deserializers);\n+        }\n+        if (_keySerializers != null) {\n+            context.addKeySerializers(_keySerializers);\n+        }\n+        if (_keyDeserializers != null) {\n+            context.addKeyDeserializers(_keyDeserializers);\n+        }\n+        if (_abstractTypes != null) {\n+            context.addAbstractTypeResolver(_abstractTypes);\n+        }\n+        if (_valueInstantiators != null) {\n+            context.addValueInstantiators(_valueInstantiators);\n+        }\n+        if (_mixins != null) {\n+            for (Map.Entry<Class<?>,Class<?>> entry : _mixins.entrySet()) {\n+                context.setMixInAnnotations(entry.getKey(), entry.getValue());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public Version version() {\n+        return _version;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleSerializers.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import java.util.*;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.type.ArrayType;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+import com.fasterxml.jackson.databind.type.CollectionLikeType;\n+import com.fasterxml.jackson.databind.type.CollectionType;\n+import com.fasterxml.jackson.databind.type.MapLikeType;\n+import com.fasterxml.jackson.databind.type.MapType;\n+\n+/**\n+ * Simple implementation {@link Serializers} which allows registration of\n+ * serializers based on raw (type erased class).\n+ * It can work well for basic bean and scalar type serializers, but is not\n+ * a good fit for handling generic types (like {@link Map}s and {@link Collection}s).\n+ *<p>\n+ * Type registrations are assumed to be general; meaning that registration of serializer\n+ * for a super type will also be used for handling subtypes, unless an exact match\n+ * is found first. As an example, handler for {@link CharSequence} would also be used\n+ * serializing {@link StringBuilder} instances, unless a direct mapping was found.\n+ * \n+ * @since 1.7\n+ */\n+public class SimpleSerializers extends Serializers.Base\n+{\n+    /**\n+     * Class-based mappings that are used both for exact and\n+     * sub-class matches.\n+     */\n+    protected HashMap<ClassKey,JsonSerializer<?>> _classMappings = null;\n+\n+    /**\n+     * Interface-based matches.\n+     */\n+    protected HashMap<ClassKey,JsonSerializer<?>> _interfaceMappings = null;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, construction and configuring\n+    /**********************************************************\n+     */\n+    \n+    public SimpleSerializers() { }\n+\n+    /**\n+     * Method for adding given serializer for type that {@link JsonSerializer#handledType}\n+     * specifies (which MUST return a non-null class; and can NOT be {@link Object}, as a\n+     * sanity check).\n+     * For serializers that do not declare handled type, use the variant that takes\n+     * two arguments.\n+     * \n+     * @param ser\n+     */\n+    public void addSerializer(JsonSerializer<?> ser)\n+    {\n+        // Interface to match?\n+        Class<?> cls = ser.handledType();\n+        if (cls == null || cls == Object.class) {\n+            throw new IllegalArgumentException(\"JsonSerializer of type \"+ser.getClass().getName()\n+                    +\" does not define valid handledType() -- must either register with method that takes type argument \"\n+                    +\" or make serializer extend 'org.codehaus.jackson.map.ser.std.SerializerBase'\"); \n+        }\n+        _addSerializer(cls, ser);\n+    }\n+\n+    public <T> void addSerializer(Class<? extends T> type, JsonSerializer<T> ser)\n+    {\n+        _addSerializer(type, ser);\n+    }\n+    \n+    private void _addSerializer(Class<?> cls, JsonSerializer<?> ser)\n+    {\n+        ClassKey key = new ClassKey(cls);\n+        // Interface or class type?\n+        if (cls.isInterface()) {\n+            if (_interfaceMappings == null) {\n+                _interfaceMappings = new HashMap<ClassKey,JsonSerializer<?>>();\n+            }\n+            _interfaceMappings.put(key, ser);\n+        } else { // nope, class:\n+            if (_classMappings == null) {\n+                _classMappings = new HashMap<ClassKey,JsonSerializer<?>>();\n+            }\n+            _classMappings.put(key, ser);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Serializers implementation\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type,\n+             BeanDescription beanDesc, BeanProperty property)\n+    {\n+        Class<?> cls = type.getRawClass();\n+        ClassKey key = new ClassKey(cls);\n+        JsonSerializer<?> ser = null;\n+\n+        // First: direct match?\n+        if (cls.isInterface()) {\n+            if (_interfaceMappings != null) {\n+                ser = _interfaceMappings.get(key);\n+                if (ser != null) {\n+                    return ser;\n+                }\n+            }\n+        } else {\n+            if (_classMappings != null) {\n+                ser = _classMappings.get(key);\n+                if (ser != null) {\n+                    return ser;\n+                }\n+                // If not direct match, maybe super-class match?\n+                for (Class<?> curr = cls; (curr != null); curr = curr.getSuperclass()) {\n+                    key.reset(curr);\n+                    ser = _classMappings.get(key);\n+                    if (ser != null) {\n+                        return ser;\n+                    }\n+                }\n+            }\n+        }\n+        // No direct match? How about super-interfaces?\n+        if (_interfaceMappings != null) {\n+            ser = _findInterfaceMapping(cls, key);\n+            if (ser != null) {\n+                return ser;\n+            }\n+            // still no matches? Maybe interfaces of super classes\n+            if (!cls.isInterface()) {\n+                while ((cls = cls.getSuperclass()) != null) {\n+                    ser = _findInterfaceMapping(cls, key);\n+                    if (ser != null) {\n+                        return ser;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JsonSerializer<?> findArraySerializer(SerializationConfig config,\n+            ArrayType type, BeanDescription beanDesc, BeanProperty property,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) {\n+        return findSerializer(config, type, beanDesc, property);\n+    }\n+\n+    @Override\n+    public JsonSerializer<?> findCollectionSerializer(SerializationConfig config,\n+            CollectionType type, BeanDescription beanDesc, BeanProperty property,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) {\n+        return findSerializer(config, type, beanDesc, property);\n+    }\n+\n+    @Override\n+    public JsonSerializer<?> findCollectionLikeSerializer(SerializationConfig config,\n+            CollectionLikeType type, BeanDescription beanDesc, BeanProperty property,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) {\n+        return findSerializer(config, type, beanDesc, property);\n+    }\n+        \n+    @Override\n+    public JsonSerializer<?> findMapSerializer(SerializationConfig config,\n+            MapType type, BeanDescription beanDesc, BeanProperty property,\n+            JsonSerializer<Object> keySerializer,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) {\n+        return findSerializer(config, type, beanDesc, property);\n+    }\n+\n+    @Override\n+    public JsonSerializer<?> findMapLikeSerializer(SerializationConfig config,\n+            MapLikeType type, BeanDescription beanDesc, BeanProperty property,\n+            JsonSerializer<Object> keySerializer,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) {\n+        return findSerializer(config, type, beanDesc, property);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    protected JsonSerializer<?> _findInterfaceMapping(Class<?> cls, ClassKey key)\n+    {\n+        for (Class<?> iface : cls.getInterfaces()) {\n+            key.reset(iface);\n+            JsonSerializer<?> ser = _interfaceMappings.get(key);\n+            if (ser != null) {\n+                return ser;\n+            }\n+            ser = _findInterfaceMapping(iface, key);\n+            if (ser != null) {\n+                return ser;\n+            }\n+        }\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleValueInstantiators.java\n+package com.fasterxml.jackson.databind.module;\n+\n+import java.util.HashMap;\n+\n+import com.fasterxml.jackson.databind.BeanDescription;\n+import com.fasterxml.jackson.databind.DeserializationConfig;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.deser.ValueInstantiators;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+\n+public class SimpleValueInstantiators\n+    extends ValueInstantiators.Base\n+{\n+    /**\n+     * Mappings from raw (type-erased, i.e. non-generic) types\n+     * to matching {@link ValueInstantiator} instances.\n+     */\n+    protected HashMap<ClassKey,ValueInstantiator> _classMappings;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, construction and configuring\n+    /**********************************************************\n+     */\n+\n+    public SimpleValueInstantiators()\n+    {\n+        _classMappings = new HashMap<ClassKey,ValueInstantiator>();        \n+    }\n+    \n+    public SimpleValueInstantiators addValueInstantiator(Class<?> forType,\n+            ValueInstantiator inst)\n+    {\n+        _classMappings.put(new ClassKey(forType), inst);\n+        return this;\n+    }\n+    \n+    @Override\n+    public ValueInstantiator findValueInstantiator(DeserializationConfig config,\n+            BeanDescription beanDesc, ValueInstantiator defaultInstantiator)\n+    {\n+        ValueInstantiator inst = _classMappings.get(new ClassKey(beanDesc.getBeanClass()));\n+        return (inst == null) ? defaultInstantiator : inst;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/package-info.java\n+/**\n+ * Package that contains classes and interfaces to help implement\n+ * custom extension {@link com.fasterxml.jackson.databind.Module}s\n+ * (which are registered using\n+ * {@link com.fasterxml.jackson.databind.ObjectMapper#registerModule}.\n+ *<p>\n+ * Note that classes in the package only support registering\n+ * handlers for non-generic types (types without type\n+ * parameterization) -- hence \"simple\" -- which works for\n+ * many cases, but not all. So if you will need to register\n+ * handlers for generic types, you will usually need to either\n+ * sub-class handlers, or implement/extend base types directly.\n+ * \n+ * @since 1.7\n+ */\n+package com.fasterxml.jackson.databind.module;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/package-info.java\n+/**\n+Contains basic mapper (conversion) functionality that\n+allows for converting between regular streaming json content and\n+Java objects (beans or Tree Model: support for both is via\n+{@link com.fasterxml.jackson.databind.ObjectMapper} class, as well\n+as convenience methods included in\n+{@link org.codehaus.jackson.JsonParser}\n+<p>\n+Object mapper will convert Json content to ant from\n+basic Java wrapper types (Integer, Boolean, Double),\n+Collection types (List, Map), Java Beans,\n+Strings and nulls.\n+<p>\n+Tree mapper builds dynamically typed tree of <code>JsonNode</code>s\n+from Json content (and writes such trees as Json),\n+similar to how DOM model works with xml.\n+Main benefits over Object mapping are:\n+<ul>\n+ <li>No null checks are needed (dummy\n+nodes are created as necessary to represent \"missing\" Object fields\n+and Array elements)\n+  </li>\n+ <li>No type casts are usually needed: all public access methods are defined\n+in basic JsonNode class, and when \"incompatible\" method (such as Array\n+element access on, say, Boolean node) is used, returned node is\n+virtual \"missing\" node.\n+  </li>\n+</ul>\n+Because of its dynamic nature, Tree mapping is often convenient\n+for basic path access and tree navigation, where structure of\n+the resulting tree is known in advance.\n+*/\n+\n+package com.fasterxml.jackson.databind;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/AnyGetterWriter.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.lang.reflect.Method;\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+import com.fasterxml.jackson.databind.ser.std.MapSerializer;\n+\n+\n+/**\n+ * Class similar to {@link BeanPropertyWriter}, but that will be used\n+ * for serializing {@link org.codehaus.jackson.annotate.JsonAnyGetter} annotated\n+ * (Map) properties\n+ * \n+ * @since 1.6\n+ */\n+public class AnyGetterWriter\n+{\n+    protected final Method _anyGetter;\n+    \n+    protected final MapSerializer _serializer;\n+    \n+    public AnyGetterWriter(AnnotatedMethod anyGetter, MapSerializer serializer)\n+    {\n+        _anyGetter = anyGetter.getAnnotated();\n+        _serializer = serializer;\n+    }\n+\n+    public void getAndSerialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws Exception\n+    {\n+        Object value = _anyGetter.invoke(bean);\n+        if (value == null) {\n+            return;\n+        }\n+        if (!(value instanceof Map<?,?>)) {\n+            throw new JsonMappingException(\"Value returned by 'any-getter' (\"+_anyGetter.getName()+\"()) not java.util.Map but \"\n+                    +value.getClass().getName());\n+        }\n+        _serializer.serializeFields((Map<?,?>) value, jgen, provider);\n+    }\n+\n+    public void resolve(SerializerProvider provider) throws JsonMappingException\n+    {\n+        _serializer.resolve(provider);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.lang.reflect.Method;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.net.InetAddress;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.core.util.TokenBuffer;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n+import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.std.*;\n+import com.fasterxml.jackson.databind.type.*;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.EnumValues;\n+\n+\n+/**\n+ * Factory class that can provide serializers for standard JDK classes,\n+ * as well as custom classes that extend standard classes or implement\n+ * one of \"well-known\" interfaces (such as {@link java.util.Collection}).\n+ *<p>\n+ * Since all the serializers are eagerly instantiated, and there is\n+ * no additional introspection or customizability of these types,\n+ * this factory is essentially stateless.\n+ */\n+public abstract class BasicSerializerFactory\n+    extends SerializerFactory\n+{\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, lookup tables/maps\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Since these are all JDK classes, we shouldn't have to worry\n+     * about ClassLoader used to load them. Rather, we can just\n+     * use the class name, and keep things simple and efficient.\n+     */\n+    protected final static HashMap<String, JsonSerializer<?>> _concrete =\n+        new HashMap<String, JsonSerializer<?>>();\n+    \n+    /**\n+     * Actually it may not make much sense to eagerly instantiate all\n+     * kinds of serializers: so this Map actually contains class references,\n+     * not instances\n+     *\n+     * @since 1.6\n+     */\n+    protected final static HashMap<String, Class<? extends JsonSerializer<?>>> _concreteLazy =\n+        new HashMap<String, Class<? extends JsonSerializer<?>>>();\n+    \n+    static {\n+        /* String and string-like types (note: date types explicitly\n+         * not included -- can use either textual or numeric serialization)\n+         */\n+        _concrete.put(String.class.getName(), new StringSerializer());\n+        final ToStringSerializer sls = ToStringSerializer.instance;\n+        _concrete.put(StringBuffer.class.getName(), sls);\n+        _concrete.put(StringBuilder.class.getName(), sls);\n+        _concrete.put(Character.class.getName(), sls);\n+        _concrete.put(Character.TYPE.getName(), sls);\n+\n+        // Primitives/wrappers for primitives (primitives needed for Beans)\n+        _concrete.put(Boolean.TYPE.getName(), new StdSerializers.BooleanSerializer(true));\n+        _concrete.put(Boolean.class.getName(), new StdSerializers.BooleanSerializer(false));\n+        final JsonSerializer<?> intS = new StdSerializers.IntegerSerializer();\n+        _concrete.put(Integer.class.getName(), intS);\n+        _concrete.put(Integer.TYPE.getName(), intS);\n+        _concrete.put(Long.class.getName(), StdSerializers.LongSerializer.instance);\n+        _concrete.put(Long.TYPE.getName(), StdSerializers.LongSerializer.instance);\n+        _concrete.put(Byte.class.getName(), StdSerializers.IntLikeSerializer.instance);\n+        _concrete.put(Byte.TYPE.getName(), StdSerializers.IntLikeSerializer.instance);\n+        _concrete.put(Short.class.getName(), StdSerializers.IntLikeSerializer.instance);\n+        _concrete.put(Short.TYPE.getName(), StdSerializers.IntLikeSerializer.instance);\n+\n+        // Numbers, limited length floating point\n+        _concrete.put(Float.class.getName(), StdSerializers.FloatSerializer.instance);\n+        _concrete.put(Float.TYPE.getName(), StdSerializers.FloatSerializer.instance);\n+        _concrete.put(Double.class.getName(), StdSerializers.DoubleSerializer.instance);\n+        _concrete.put(Double.TYPE.getName(), StdSerializers.DoubleSerializer.instance);\n+\n+        // Other numbers, more complicated\n+        final JsonSerializer<?> ns = new StdSerializers.NumberSerializer();\n+        _concrete.put(BigInteger.class.getName(), ns);\n+        _concrete.put(BigDecimal.class.getName(), ns);\n+        \n+        // Other discrete non-container types:\n+        // First, Date/Time zoo:\n+        _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);\n+        DateSerializer dateSer = DateSerializer.instance;\n+        _concrete.put(java.util.Date.class.getName(), dateSer);\n+        // note: timestamps are very similar to java.util.Date, thus serialized as such\n+        _concrete.put(java.sql.Timestamp.class.getName(), dateSer);\n+        _concrete.put(java.sql.Date.class.getName(), new StdSerializers.SqlDateSerializer());\n+        _concrete.put(java.sql.Time.class.getName(), new StdSerializers.SqlTimeSerializer());\n+\n+        // And then other standard non-structured JDK types\n+        for (Map.Entry<Class<?>,Object> en : new StdJdkSerializers().provide()) {\n+            Object value = en.getValue();\n+            if (value instanceof JsonSerializer<?>) {\n+                _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);\n+            } else if (value instanceof Class<?>) {\n+                @SuppressWarnings(\"unchecked\")\n+                Class<? extends JsonSerializer<?>> cls = (Class<? extends JsonSerializer<?>>) value;\n+                _concreteLazy.put(en.getKey().getName(), cls);\n+            } else { // should never happen, but:\n+                throw new IllegalStateException(\"Internal error: unrecognized value of type \"+en.getClass().getName());\n+            }\n+        }\n+\n+        // Jackson-specific type(s)\n+        // (Q: can this ever be sub-classed?)\n+        _concreteLazy.put(TokenBuffer.class.getName(), TokenBufferSerializer.class);\n+    }\n+\n+    protected final static HashMap<String, JsonSerializer<?>> _arraySerializers =\n+        new HashMap<String, JsonSerializer<?>>();\n+    static {\n+        // Arrays of various types (including common object types)\n+        _arraySerializers.put(boolean[].class.getName(), new StdArraySerializers.BooleanArraySerializer());\n+        _arraySerializers.put(byte[].class.getName(), new StdArraySerializers.ByteArraySerializer());\n+        _arraySerializers.put(char[].class.getName(), new StdArraySerializers.CharArraySerializer());\n+        _arraySerializers.put(short[].class.getName(), new StdArraySerializers.ShortArraySerializer());\n+        _arraySerializers.put(int[].class.getName(), new StdArraySerializers.IntArraySerializer());\n+        _arraySerializers.put(long[].class.getName(), new StdArraySerializers.LongArraySerializer());\n+        _arraySerializers.put(float[].class.getName(), new StdArraySerializers.FloatArraySerializer());\n+        _arraySerializers.put(double[].class.getName(), new StdArraySerializers.DoubleArraySerializer());\n+    }\n+    \n+    /**\n+     * Helper object used to deal with serializers for optional JDK types (like ones\n+     * omitted from GAE, Android)\n+     */\n+    protected OptionalHandlerFactory optionalHandlers = OptionalHandlerFactory.instance;\n+\n+    /*\n+    /**********************************************************\n+    /* Life cycle\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * We will provide default constructor to allow sub-classing,\n+     * but make it protected so that no non-singleton instances of\n+     * the class will be instantiated.\n+     */\n+    protected BasicSerializerFactory() { }\n+\n+    /*\n+    /**********************************************************\n+    /* SerializerFactory impl\n+    /**********************************************************\n+     */\n+\n+    // Implemented by sub-classes\n+    @Override\n+    public abstract JsonSerializer<Object> createSerializer(SerializationConfig config, JavaType type,\n+            BeanProperty property)\n+        throws JsonMappingException;\n+\n+    /**\n+     * Method called to construct a type serializer for values with given declared\n+     * base type. This is called for values other than those of bean property\n+     * types.\n+     */\n+    @Override\n+    public TypeSerializer createTypeSerializer(SerializationConfig config, JavaType baseType,\n+            BeanProperty property)\n+    {\n+        BasicBeanDescription bean = config.introspectClassAnnotations(baseType.getRawClass());\n+        AnnotatedClass ac = bean.getClassInfo();\n+        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+        TypeResolverBuilder<?> b = ai.findTypeResolver(config, ac, baseType);\n+        /* Ok: if there is no explicit type info handler, we may want to\n+         * use a default. If so, config object knows what to use.\n+         */\n+        Collection<NamedType> subtypes = null;\n+        if (b == null) {\n+            b = config.getDefaultTyper(baseType);\n+        } else {\n+            subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(ac, config, ai);\n+        }\n+        return (b == null) ? null : b.buildTypeSerializer(config, baseType, subtypes, property);\n+    }\n+\n+    \n+    /*\n+    /**********************************************************\n+    /* Additional API for other core classes\n+    /**********************************************************\n+     */\n+\n+    public final JsonSerializer<?> getNullSerializer() {\n+        return NullSerializer.instance;\n+    }    \n+\n+    protected abstract Iterable<Serializers> customSerializers();\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridable secondary serializer accessor methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that will use fast lookup (and identity comparison) methods to\n+     * see if we know serializer to use for given type.\n+     */\n+    public final JsonSerializer<?> findSerializerByLookup(JavaType type, SerializationConfig config,\n+            BasicBeanDescription beanDesc, BeanProperty property,\n+            boolean staticTyping)\n+    {\n+        Class<?> raw = type.getRawClass();\n+        String clsName = raw.getName();\n+        JsonSerializer<?> ser = _concrete.get(clsName);\n+        if (ser != null) {\n+            return ser;\n+        }\n+        Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName);\n+        if (serClass != null) {\n+            try {\n+                return serClass.newInstance();\n+            } catch (Exception e) {\n+                throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \"\n+                        +e.getMessage(), e);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Method for checking if we can determine serializer to use based on set of\n+     * known primary types, checking for set of known base types (exact matches\n+     * having been compared against with <code>findSerializerByLookup</code>).\n+     * This does not include \"secondary\" interfaces, but\n+     * mostly concrete or abstract base classes.\n+     */\n+    @SuppressWarnings(\"deprecation\")\n+    public final JsonSerializer<?> findSerializerByPrimaryType(JavaType type, SerializationConfig config,\n+            BasicBeanDescription beanDesc, BeanProperty property,\n+            boolean staticTyping)\n+        throws JsonMappingException\n+    {\n+        Class<?> raw = type.getRawClass();\n+        // First: JsonSerializable and related\n+        if (JsonSerializable.class.isAssignableFrom(raw)) {\n+            if (JsonSerializableWithType.class.isAssignableFrom(raw)) {\n+                return SerializableWithTypeSerializer.instance;\n+            }\n+            return SerializableSerializer.instance;\n+        }\n+        // Second: as per [JACKSON-193] consider @JsonValue for any types:\n+        AnnotatedMethod valueMethod = beanDesc.findJsonValueMethod();\n+        if (valueMethod != null) {\n+            // [JACKSON-586]: need to ensure accessibility of method\n+            Method m = valueMethod.getAnnotated();\n+            if (config.isEnabled(SerializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+                ClassUtil.checkAndFixAccess(m);\n+            }\n+            JsonSerializer<Object> ser = findSerializerFromAnnotation(config, valueMethod, property);\n+            return new JsonValueSerializer(m, ser, property);\n+        }\n+        \n+        // One unfortunate special case, as per [JACKSON-484]\n+        if (InetAddress.class.isAssignableFrom(raw)) {\n+            return InetAddressSerializer.instance;\n+        }\n+        // ... and another one, [JACKSON-522], for TimeZone\n+        if (TimeZone.class.isAssignableFrom(raw)) {\n+            return TimeZoneSerializer.instance;\n+        }\n+        \n+        // Then check for optional/external serializers [JACKSON-386]\n+        JsonSerializer<?> ser = optionalHandlers.findSerializer(config, type);\n+        if (ser != null) {\n+            return ser;\n+        }\n+        \n+        if (Number.class.isAssignableFrom(raw)) {\n+            return StdSerializers.NumberSerializer.instance;\n+        }\n+        if (Enum.class.isAssignableFrom(raw)) {\n+            @SuppressWarnings(\"unchecked\")\n+            Class<Enum<?>> enumClass = (Class<Enum<?>>) raw;\n+            return EnumSerializer.construct(enumClass, config, beanDesc);\n+        }\n+        if (Calendar.class.isAssignableFrom(raw)) {\n+            return CalendarSerializer.instance;\n+        }\n+        if (java.util.Date.class.isAssignableFrom(raw)) {\n+            return DateSerializer.instance;\n+        }\n+        return null;\n+    }\n+        \n+    /**\n+     * Reflection-based serialized find method, which checks if\n+     * given class implements one of recognized \"add-on\" interfaces.\n+     * Add-on here means a role that is usually or can be a secondary\n+     * trait: for example,\n+     * bean classes may implement {@link Iterable}, but their main\n+     * function is usually something else. The reason for\n+     */\n+    public final JsonSerializer<?> findSerializerByAddonType(SerializationConfig config, JavaType javaType,\n+            BasicBeanDescription beanDesc, BeanProperty property,\n+            boolean staticTyping)\n+        throws JsonMappingException\n+    {\n+        Class<?> type = javaType.getRawClass();\n+\n+        // These need to be in decreasing order of specificity...\n+        if (Iterator.class.isAssignableFrom(type)) {\n+            return buildIteratorSerializer(config, javaType, beanDesc, property, staticTyping);\n+        }\n+        if (Iterable.class.isAssignableFrom(type)) {\n+            return buildIterableSerializer(config, javaType, beanDesc, property, staticTyping);\n+        }\n+        if (CharSequence.class.isAssignableFrom(type)) {\n+            return ToStringSerializer.instance;\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Helper method called to check if a class or method\n+     * has an annotation\n+     * (@link org.codehaus.jackson.map.ser.JsonSerialize#using)\n+     * that tells the class to use for serialization.\n+     * Returns null if no such annotation found.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonSerializer<Object> findSerializerFromAnnotation(SerializationConfig config, Annotated a,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        Object serDef = config.getAnnotationIntrospector().findSerializer(a);\n+        if (serDef == null) {\n+            return null;\n+        }\n+        if (serDef instanceof JsonSerializer) {\n+            JsonSerializer<Object> ser = (JsonSerializer<Object>) serDef;\n+            if (ser instanceof ContextualSerializer<?>) {\n+                return ((ContextualSerializer<Object>) ser).createContextual(config, property);\n+            }\n+            return ser;\n+        }\n+        /* Alas, there's no way to force return type of \"either class\n+         * X or Y\" -- need to throw an exception after the fact\n+         */\n+        if (!(serDef instanceof Class)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector returned value of type \"+serDef.getClass().getName()+\"; expected type JsonSerializer or Class<JsonSerializer> instead\");\n+        }\n+        Class<?> cls = (Class<?>) serDef;\n+        if (!JsonSerializer.class.isAssignableFrom(cls)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+cls.getName()+\"; expected Class<JsonSerializer>\");\n+        }\n+        JsonSerializer<Object> ser = config.serializerInstance(a, (Class<? extends JsonSerializer<?>>) cls);\n+        if (ser instanceof ContextualSerializer<?>) {\n+            return ((ContextualSerializer<Object>) ser).createContextual(config, property);\n+        }\n+        return ser;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods, container types:\n+    /**********************************************************\n+     */\n+    \n+    public JsonSerializer<?> buildContainerSerializer(SerializationConfig config, JavaType type,\n+            BasicBeanDescription beanDesc, BeanProperty property, boolean staticTyping)\n+    {\n+        // Let's see what we can learn about element/content/value type, type serializer for it:\n+        JavaType elementType = type.getContentType();\n+        TypeSerializer elementTypeSerializer = createTypeSerializer(config, elementType, property);\n+        \n+        // if elements have type serializer, can not force static typing:\n+        if (elementTypeSerializer != null) {\n+            staticTyping = false;\n+        } else if (!staticTyping) {\n+            staticTyping = usesStaticTyping(config, beanDesc, elementTypeSerializer, property);\n+        }\n+        JsonSerializer<Object> elementValueSerializer = findContentSerializer(config,\n+                beanDesc.getClassInfo(), property);\n+        \n+        if (type.isMapLikeType()) { // implements java.util.Map\n+            MapLikeType mlt = (MapLikeType) type;\n+            JsonSerializer<Object> keySerializer = findKeySerializer(config, beanDesc.getClassInfo(), property);\n+            if (mlt.isTrueMapType()) {\n+                return buildMapSerializer(config, (MapType) mlt, beanDesc, property, staticTyping,\n+                        keySerializer, elementTypeSerializer, elementValueSerializer);\n+            }\n+            return buildMapLikeSerializer(config, mlt, beanDesc, property, staticTyping,\n+                    keySerializer, elementTypeSerializer, elementValueSerializer);\n+        }\n+        if (type.isCollectionLikeType()) {\n+            CollectionLikeType clt = (CollectionLikeType) type;\n+            if (clt.isTrueCollectionType()) {\n+                return buildCollectionSerializer(config, (CollectionType) clt, beanDesc, property, staticTyping,\n+                        elementTypeSerializer, elementValueSerializer);\n+            }\n+            return buildCollectionLikeSerializer(config, clt, beanDesc, property, staticTyping,\n+                    elementTypeSerializer, elementValueSerializer);\n+        }\n+        if (type.isArrayType()) {\n+            return buildArraySerializer(config, (ArrayType) type, beanDesc, property, staticTyping,\n+                    elementTypeSerializer, elementValueSerializer);\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Helper method that handles configuration details when constructing serializers for\n+     * Collection and Collection-like types.\n+     * \n+     * @since 1.8\n+     */\n+    protected JsonSerializer<?> buildCollectionLikeSerializer(SerializationConfig config,\n+            CollectionLikeType type,\n+            BasicBeanDescription beanDesc, BeanProperty property,\n+            boolean staticTyping,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n+    {\n+        for (Serializers serializers : customSerializers()) {\n+            JsonSerializer<?> ser = serializers.findCollectionLikeSerializer(config, type, beanDesc, property,\n+                    elementTypeSerializer, elementValueSerializer);\n+            if (ser != null) {\n+                return ser;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Helper method that handles configuration details when constructing serializers for\n+     * {@link java.util.List} types that support efficient by-index access\n+     *<p> \n+     * Note: signature changed in 1.8, to take 'staticTyping' argument\n+     */\n+    protected JsonSerializer<?> buildCollectionSerializer(SerializationConfig config,\n+            CollectionType type,\n+            BasicBeanDescription beanDesc, BeanProperty property,\n+            boolean staticTyping,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n+    {\n+        // Module-provided custom collection serializers?\n+        for (Serializers serializers : customSerializers()) {\n+            JsonSerializer<?> ser = serializers.findCollectionSerializer(config, type, beanDesc, property,\n+                    elementTypeSerializer, elementValueSerializer);\n+            if (ser != null) {\n+                return ser;\n+            }\n+        }\n+        Class<?> raw = type.getRawClass();\n+        if (EnumSet.class.isAssignableFrom(raw)) {\n+            return buildEnumSetSerializer(config, type, beanDesc, property, staticTyping,\n+                    elementTypeSerializer, elementValueSerializer);\n+        }\n+        Class<?> elementRaw = type.getContentType().getRawClass();\n+        if (isIndexedList(raw)) {\n+            if (elementRaw == String.class) {\n+                return new IndexedStringListSerializer(property);\n+            }\n+            return StdContainerSerializers.indexedListSerializer(type.getContentType(), staticTyping,\n+                    elementTypeSerializer, property, elementValueSerializer);\n+        }\n+        if (elementRaw == String.class) {\n+            return new StringCollectionSerializer(property);\n+        }\n+        return StdContainerSerializers.collectionSerializer(type.getContentType(), staticTyping,\n+                elementTypeSerializer, property, elementValueSerializer);\n+    }\n+\n+    protected JsonSerializer<?> buildEnumSetSerializer(SerializationConfig config, JavaType type,\n+            BasicBeanDescription beanDesc, BeanProperty property,\n+            boolean staticTyping,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n+    {\n+        // this may or may not be available (Class doesn't; type of field/method does)\n+        JavaType enumType = type.getContentType();\n+        // and even if nominally there is something, only use if it really is enum\n+        if (!enumType.isEnumType()) {\n+            enumType = null;\n+        }\n+        return StdContainerSerializers.enumSetSerializer(enumType, property);\n+    }\n+    \n+    /**\n+     * @since 1.8\n+     */\n+    protected boolean isIndexedList(Class<?> cls)\n+    {\n+        return RandomAccess.class.isAssignableFrom(cls);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Factory methods, for Maps\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method that handles configuration details when constructing serializers for\n+     * all \"Map-like\" types; both ones that implement {@link java.util.Map} and\n+     * ones that do not (but that have been indicated to behave like Maps).\n+     * \n+     * @since 1.8\n+     */\n+    protected JsonSerializer<?> buildMapLikeSerializer(SerializationConfig config, MapLikeType type,\n+            BasicBeanDescription beanDesc, BeanProperty property,\n+            boolean staticTyping,\n+            JsonSerializer<Object> keySerializer,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n+    {\n+        for (Serializers serializers : customSerializers()) {\n+            JsonSerializer<?> ser = serializers.findMapLikeSerializer(config, type, beanDesc, property,\n+                    keySerializer, elementTypeSerializer, elementValueSerializer);\n+            if (ser != null) {\n+                return ser;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Helper method that handles configuration details when constructing serializers for\n+     * {@link java.util.Map} types.\n+     *<p> \n+     * Note: signature changed in 1.8, to take 'staticTyping' argument\n+     */\n+    protected JsonSerializer<?> buildMapSerializer(SerializationConfig config, MapType type,\n+            BasicBeanDescription beanDesc, BeanProperty property,\n+            boolean staticTyping,\n+            JsonSerializer<Object> keySerializer,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n+    {\n+        for (Serializers serializers : customSerializers()) {\n+            JsonSerializer<?> ser = serializers.findMapSerializer(config, type, beanDesc, property,\n+                    keySerializer, elementTypeSerializer, elementValueSerializer);\n+            if (ser != null) {\n+                return ser;\n+            }\n+        }\n+        if (EnumMap.class.isAssignableFrom(type.getRawClass())) {\n+            return buildEnumMapSerializer(config, type, beanDesc, property, staticTyping,\n+                    elementTypeSerializer, elementValueSerializer);\n+        }\n+        return MapSerializer.construct(config.getAnnotationIntrospector().findPropertiesToIgnore(beanDesc.getClassInfo()),\n+                type, staticTyping, elementTypeSerializer, property,\n+                keySerializer, elementValueSerializer);\n+    }\n+    \n+    /**\n+     * Helper method that handles configuration details when constructing serializers for\n+     * {@link java.util.EnumMap} types.\n+     *<p> \n+     * Note: signature changed in 1.8, to take 'staticTyping' argument\n+     */\n+    protected JsonSerializer<?> buildEnumMapSerializer(SerializationConfig config, JavaType type,\n+            BasicBeanDescription beanDesc, BeanProperty property,\n+            boolean staticTyping,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer) \n+    {\n+        JavaType keyType = type.getKeyType();\n+        // Need to find key enum values...\n+        EnumValues enums = null;\n+        if (keyType.isEnumType()) { // non-enum if we got it as type erased class (from instance)\n+            @SuppressWarnings(\"unchecked\")\n+            Class<Enum<?>> enumClass = (Class<Enum<?>>) keyType.getRawClass();\n+            enums = EnumValues.construct(enumClass, config.getAnnotationIntrospector());\n+        }\n+        return new EnumMapSerializer(type.getContentType(), staticTyping, enums,\n+            elementTypeSerializer, property, elementValueSerializer);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods, for Arrays\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method that handles configuration details when constructing serializers for\n+     * <code>Object[]</code> (and subtypes, except for String).\n+     */\n+    protected JsonSerializer<?> buildArraySerializer(SerializationConfig config, ArrayType type,\n+            BasicBeanDescription beanDesc, BeanProperty property,\n+            boolean staticTyping,\n+            TypeSerializer elementTypeSerializer, JsonSerializer<Object> elementValueSerializer)\n+    {\n+        Class<?> raw = type.getRawClass();\n+        if (String[].class == raw) {\n+            return new StdArraySerializers.StringArraySerializer(property);\n+        }\n+        // other standard types?\n+        JsonSerializer<?> ser = _arraySerializers.get(raw.getName());\n+        if (ser != null) {\n+            return ser;\n+        }\n+        return new ObjectArraySerializer(type.getContentType(), staticTyping, elementTypeSerializer,\n+                property, elementValueSerializer);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods, for non-container types\n+    /**********************************************************\n+     */\n+\n+    protected JsonSerializer<?> buildIteratorSerializer(SerializationConfig config, JavaType type,\n+            BasicBeanDescription beanDesc, BeanProperty property,\n+            boolean staticTyping)\n+    {\n+        // if there's generic type, it'll be the first contained type\n+        JavaType valueType = type.containedType(0);\n+        if (valueType == null) {\n+            valueType = TypeFactory.unknownType();\n+        }\n+        TypeSerializer vts = createTypeSerializer(config, valueType, property);\n+        return StdContainerSerializers.iteratorSerializer(valueType,\n+                usesStaticTyping(config, beanDesc, vts, property), vts, property);\n+    }\n+    \n+    protected JsonSerializer<?> buildIterableSerializer(SerializationConfig config, JavaType type,\n+            BasicBeanDescription beanDesc, BeanProperty property,\n+            boolean staticTyping)\n+    {\n+        // if there's generic type, it'll be the first contained type\n+        JavaType valueType = type.containedType(0);\n+        if (valueType == null) {\n+            valueType = TypeFactory.unknownType();\n+        }\n+        TypeSerializer vts = createTypeSerializer(config, valueType, property);\n+        return StdContainerSerializers.iterableSerializer(valueType,\n+                usesStaticTyping(config, beanDesc, vts, property), vts, property);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other helper methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method used to encapsulate details of annotation-based type\n+     * coercion\n+     * \n+     * @since 1.8\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T extends JavaType> T modifyTypeByAnnotation(SerializationConfig config, Annotated a, T type)\n+    {\n+        // first: let's check class for the instance itself:\n+        Class<?> superclass = config.getAnnotationIntrospector().findSerializationType(a);\n+        if (superclass != null) {\n+            try {\n+                type = (T) type.widenBy(superclass);\n+            } catch (IllegalArgumentException iae) {\n+                throw new IllegalArgumentException(\"Failed to widen type \"+type+\" with concrete-type annotation (value \"+superclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage());\n+            }\n+        }\n+        return modifySecondaryTypesByAnnotation(config, a, type);\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected static <T extends JavaType> T modifySecondaryTypesByAnnotation(SerializationConfig config, Annotated a, T type)\n+    {\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        // then key class\n+        if (type.isContainerType()) {\n+            Class<?> keyClass = intr.findSerializationKeyType(a, type.getKeyType());\n+            if (keyClass != null) {\n+                // illegal to use on non-Maps\n+                if (!(type instanceof MapType)) {\n+                    throw new IllegalArgumentException(\"Illegal key-type annotation: type \"+type+\" is not a Map type\");\n+                }\n+                try {\n+                    type = (T) ((MapType) type).widenKey(keyClass);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new IllegalArgumentException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage());\n+                }\n+            }\n+            \n+            // and finally content class; only applicable to structured types\n+            Class<?> cc = intr.findSerializationContentType(a, type.getContentType());\n+            if (cc != null) {\n+                try {\n+                    type = (T) type.widenContentsBy(cc);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new IllegalArgumentException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage());\n+                }\n+            }\n+        }\n+        return type;\n+    }\n+\n+    protected static JsonSerializer<Object> findKeySerializer(SerializationConfig config,\n+            Annotated a, BeanProperty property)\n+    {\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        Class<? extends JsonSerializer<?>> serClass = intr.findKeySerializer(a);\n+        if (serClass == null || serClass == JsonSerializer.None.class) {\n+            if (property != null) {\n+                serClass = intr.findKeySerializer(property.getMember());\n+            }\n+        }\n+        if (serClass != null && serClass != JsonSerializer.None.class) {\n+            return config.serializerInstance(a, serClass);\n+        }\n+        return null;\n+    }\n+\n+    protected static JsonSerializer<Object> findContentSerializer(SerializationConfig config,\n+            Annotated a, BeanProperty property)\n+    {\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        Class<? extends JsonSerializer<?>> serClass = intr.findContentSerializer(a);\n+        if (serClass == null || serClass == JsonSerializer.None.class) {\n+            if (property != null) {\n+                serClass = intr.findContentSerializer(property.getMember());\n+            }\n+        }\n+        if (serClass != null && serClass != JsonSerializer.None.class) {\n+            return config.serializerInstance(a, serClass);\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Helper method to check whether global settings and/or class\n+     * annotations for the bean class indicate that static typing\n+     * (declared types)  should be used for properties.\n+     * (instead of dynamic runtime types).\n+     */\n+    protected boolean usesStaticTyping(SerializationConfig config, BasicBeanDescription beanDesc,\n+            TypeSerializer typeSer, BeanProperty property)\n+    {\n+        /* 16-Aug-2010, tatu: If there is a (value) type serializer, we can not force\n+         *    static typing; that would make it impossible to handle expected subtypes\n+         */\n+        if (typeSer != null) {\n+            return false;\n+        }\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        JsonSerialize.Typing t = intr.findSerializationTyping(beanDesc.getClassInfo());\n+        if (t != null) {\n+            if (t == JsonSerialize.Typing.STATIC) {\n+                return true;\n+            }\n+        } else {\n+            if (config.isEnabled(SerializationConfig.Feature.USE_STATIC_TYPING)) {\n+                return true;\n+            }\n+        }\n+        /* 11-Mar-2011, tatu: Ok. This is bit hacky, but we really need to be able to find cases\n+         *    where key and/or value serializers were specified, to force use of static typing\n+         */\n+        if (property != null) {\n+            JavaType type = property.getType();\n+            if (type.isContainerType()) {\n+                if (intr.findSerializationContentType(property.getMember(), property.getType()) != null) {\n+                    return true;\n+                }\n+                if (type instanceof MapType) {\n+                    if (intr.findSerializationKeyType(property.getMember(), property.getType()) != null) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyFilter.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Interface that defines API for filter objects use (as configured\n+ * using {@link com.fasterxml.jackson.databind.annotate.JsonFilter})\n+ * for filtering bean properties to serialize.\n+ * \n+ * @since 1.7\n+ */\n+public interface BeanPropertyFilter\n+{\n+    /**\n+     * Method called by {@link BeanSerializer} to let filter decide what to do with\n+     * given bean property value: the usual choices are to either filter out (i.e.\n+     * do nothing) or write using given {@link BeanPropertyWriter}, although filters\n+     * can choose other to do something different altogether.\n+     * \n+     * @param bean Bean of which property value to serialize\n+     * @param jgen Generator use for serializing value\n+     * @param prov Provider that can be used for accessing dynamic aspects of serialization\n+     *    processing\n+     * @param writer Default bean property serializer to use\n+     */\n+    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov,\n+            BeanPropertyWriter writer)\n+        throws Exception;\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Type;\n+import java.util.HashMap;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.io.SerializedString;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+import com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanPropertyWriter;\n+import com.fasterxml.jackson.databind.util.Annotations;\n+\n+\n+/**\n+ * Base bean property handler class, which implements common parts of\n+ * reflection-based functionality for accessing a property value\n+ * and serializing it.\n+ */\n+public class BeanPropertyWriter\n+    implements BeanProperty\n+{\n+    /*\n+    /**********************************************************\n+    /* Settings for accessing property value to serialize\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Member (field, method) that represents property and allows access\n+     * to associated annotations.\n+     * \n+     * @since 1.7\n+     */\n+    protected final AnnotatedMember _member;\n+\n+    /**\n+     * Annotations from context (most often, class that declares property,\n+     * or in case of sub-class serializer, from that sub-class)\n+     */\n+    protected final Annotations _contextAnnotations;\n+    \n+    /**\n+     * Type property is declared to have, either in class definition \n+     * or associated annotations.\n+     */\n+    protected final JavaType _declaredType;\n+    \n+    /**\n+     * Accessor method used to get property value, for\n+     * method-accessible properties.\n+     * Null if and only if {@link #_field} is null.\n+     */\n+    protected final Method _accessorMethod;\n+    \n+    /**\n+     * Field that contains the property value for field-accessible\n+     * properties.\n+     * Null if and only if {@link #_accessorMethod} is null.\n+     */\n+    protected final Field _field;\n+    \n+    /*\n+    /**********************************************************\n+    /* Opaque internal data that bean serializer factory and\n+    /* bean serializers can add.\n+    /* \n+    /* @since 1.7\n+    /**********************************************************\n+     */\n+\n+    protected HashMap<Object,Object> _internalSettings;\n+    \n+    /*\n+    /**********************************************************\n+    /* Serialization settings\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Logical name of the property; will be used as the field name\n+     * under which value for the property is written.\n+     */\n+    protected final SerializedString _name;\n+\n+    /**\n+     * Type to use for locating serializer; normally same as return\n+     * type of the accessor method, but may be overridden by annotations.\n+     */\n+    protected final JavaType _cfgSerializationType;\n+\n+    /**\n+     * Serializer to use for writing out the value: null if it can not\n+     * be known statically; non-null if it can.\n+     */\n+    protected final JsonSerializer<Object> _serializer;\n+\n+    /**\n+     * In case serializer is not known statically (i.e. <code>_serializer</code>\n+     * is null), we will use a lookup structure for storing dynamically\n+     * resolved mapping from type(s) to serializer(s).\n+     * \n+     * @since 1.7\n+     */\n+    protected PropertySerializerMap _dynamicSerializers;\n+    \n+    /**\n+     * Flag to indicate that null values for this property are not\n+     * to be written out. That is, if property has value null,\n+     * no entry will be written\n+     */\n+    protected final boolean _suppressNulls;\n+\n+    /**\n+     * Value that is considered default value of the property; used for\n+     * default-value-suppression if enabled.\n+     */\n+    protected final Object _suppressableValue;\n+\n+    /**\n+     * Alternate set of property writers used when view-based filtering\n+     * is available for the Bean.\n+     * \n+     * @since 1.4\n+     */\n+    protected Class<?>[] _includeInViews;\n+\n+    /**\n+     * If property being serialized needs type information to be\n+     * included this is the type serializer to use.\n+     * Declared type (possibly augmented with annotations) of property\n+     * is used for determining exact mechanism to use (compared to\n+     * actual runtime type used for serializing actual state).\n+     */\n+    protected TypeSerializer _typeSerializer;\n+    \n+    /**\n+     * Base type of the property, if the declared type is \"non-trivial\";\n+     * meaning it is either a structured type (collection, map, array),\n+     * or parametrized. Used to retain type information about contained\n+     * type, which is mostly necessary if type metadata is to be\n+     * included.\n+     *\n+     * @since 1.5\n+     */\n+    protected JavaType _nonTrivialBaseType;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction, configuration\n+    /**********************************************************\n+     */\n+\n+    public BeanPropertyWriter(AnnotatedMember member, Annotations contextAnnotations,\n+            String name, JavaType declaredType,\n+            JsonSerializer<Object> ser, TypeSerializer typeSer, JavaType serType,\n+            Method m, Field f,\n+            boolean suppressNulls, Object suppressableValue)\n+    {\n+        this(member, contextAnnotations, new SerializedString(name), declaredType,\n+                ser, typeSer, serType,\n+                m, f, suppressNulls, suppressableValue);\n+    }\n+    \n+    public BeanPropertyWriter(AnnotatedMember member, Annotations contextAnnotations,\n+            SerializedString name, JavaType declaredType,\n+            JsonSerializer<Object> ser, TypeSerializer typeSer, JavaType serType,\n+            Method m, Field f, boolean suppressNulls, Object suppressableValue)\n+    {\n+        _member = member;\n+        _contextAnnotations = contextAnnotations;\n+        _name = name;\n+        _declaredType = declaredType;\n+        _serializer = ser;\n+        _dynamicSerializers = (ser == null) ? PropertySerializerMap.emptyMap() : null;\n+        _typeSerializer = typeSer;\n+        _cfgSerializationType = serType;\n+        _accessorMethod = m;\n+        _field = f;\n+        _suppressNulls = suppressNulls;\n+        _suppressableValue = suppressableValue;\n+    }\n+\n+    /**\n+     * \"Copy constructor\" to be used by filtering sub-classes\n+     */\n+    protected BeanPropertyWriter(BeanPropertyWriter base)\n+    {\n+        this(base, base._serializer);\n+    }\n+    \n+    /**\n+     * \"Copy constructor\" to be used by filtering sub-classes\n+     */\n+    protected BeanPropertyWriter(BeanPropertyWriter base, JsonSerializer<Object> ser)\n+    {\n+        _serializer = ser;\n+        \n+        _member = base._member;\n+        _contextAnnotations = base._contextAnnotations;\n+        _declaredType = base._declaredType;\n+        _accessorMethod = base._accessorMethod;\n+        _field = base._field;\n+        // one more thing: copy internal settings, if any (since 1.7)\n+        if (base._internalSettings != null) {\n+            _internalSettings = new HashMap<Object,Object>(base._internalSettings);\n+        }\n+        _name = base._name;\n+        _cfgSerializationType = base._cfgSerializationType;\n+        _dynamicSerializers = base._dynamicSerializers;\n+        _suppressNulls = base._suppressNulls;\n+        _suppressableValue = base._suppressableValue;\n+        _includeInViews = base._includeInViews;\n+        _typeSerializer = base._typeSerializer;\n+        _nonTrivialBaseType = base._nonTrivialBaseType;\n+   }\n+\n+    /**\n+     * Method that will construct and return a new writer that has\n+     * same properties as this writer, but uses specified serializer\n+     * instead of currently configured one (if any).\n+     */\n+    public BeanPropertyWriter withSerializer(JsonSerializer<Object> ser)\n+    {\n+        // sanity check to ensure sub-classes override...\n+        if (getClass() != BeanPropertyWriter.class) {\n+            throw new IllegalStateException(\"BeanPropertyWriter sub-class does not override 'withSerializer()'; needs to!\");\n+        }\n+        return new BeanPropertyWriter(this, ser);\n+    }\n+\n+    /**\n+     * Method called create an instance that handles details of unwrapping\n+     * contained value.\n+     * \n+     * @since 1.9\n+     */\n+    public BeanPropertyWriter unwrappingWriter() {\n+        return new UnwrappingBeanPropertyWriter(this);\n+    }\n+    \n+    /**\n+     * Method for defining which views to included value of this\n+     * property in. If left undefined, will always be included;\n+     * otherwise active view definition will be checked against\n+     * definition list and value is only included if active\n+     * view is one of defined views, or its sub-view (as defined\n+     * by class/sub-class relationship).\n+     */\n+    public void setViews(Class<?>[] views) { _includeInViews = views; }\n+\n+    /**\n+     * Method called to define type to consider as \"non-trivial\" basetype,\n+     * needed for dynamic serialization resolution for complex (usually container)\n+     * types\n+     *\n+     * @since 1.5\n+     */\n+    public void setNonTrivialBaseType(JavaType t) {\n+        _nonTrivialBaseType = t;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* BeanProperty impl\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public String getName() {\n+        return _name.getValue();\n+    }\n+\n+    @Override\n+    public JavaType getType() {\n+        return _declaredType;\n+    }\n+\n+    @Override\n+    public <A extends Annotation> A getAnnotation(Class<A> acls) {\n+        return _member.getAnnotation(acls);\n+    }\n+\n+    @Override\n+    public <A extends Annotation> A getContextAnnotation(Class<A> acls) {\n+        return _contextAnnotations.get(acls);\n+    }\n+    \n+    @Override\n+    public AnnotatedMember getMember() {\n+        return _member;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Managing and accessing of opaque internal settings\n+    /* (used by extensions)\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for accessing value of specified internal setting.\n+     * \n+     * @return Value of the setting, if any; null if none.\n+     * \n+     * @since 1.7\n+     */\n+    public Object getInternalSetting(Object key)\n+    {\n+        if (_internalSettings == null) {\n+            return null;\n+        }\n+        return _internalSettings.get(key);\n+    }\n+    \n+    /**\n+     * Method for setting specific internal setting to given value\n+     * \n+     * @return Old value of the setting, if any (null if none)\n+     * \n+     * @since 1.7\n+     */\n+    public Object setInternalSetting(Object key, Object value)\n+    {\n+        if (_internalSettings == null) {\n+            _internalSettings = new HashMap<Object,Object>();\n+        }\n+        return _internalSettings.put(key, value);\n+    }\n+\n+    /**\n+     * Method for removing entry for specified internal setting.\n+     * \n+     * @return Existing value of the setting, if any (null if none)\n+     * \n+     * @since 1.7\n+     */\n+    public Object removeInternalSetting(Object key)\n+    {\n+        Object removed = null;\n+        if (_internalSettings != null) {\n+            removed = _internalSettings.remove(key);\n+            // to reduce memory usage, let's also drop the Map itself, if empty\n+            if (_internalSettings.size() == 0) {\n+                _internalSettings = null;\n+            }\n+        }\n+        return removed;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Accessors\n+    /**********************************************************\n+     */\n+\n+    public SerializedString getSerializedName() { return _name; }\n+    \n+    public boolean hasSerializer() { return _serializer != null; }\n+    \n+    // Needed by BeanSerializer#getSchema\n+    public JsonSerializer<Object> getSerializer() {\n+        return _serializer;\n+    }\n+\n+    public JavaType getSerializationType() {\n+        return _cfgSerializationType;\n+    }\n+\n+    public Class<?> getRawSerializationType() {\n+        return (_cfgSerializationType == null) ? null : _cfgSerializationType.getRawClass();\n+    }\n+    \n+    public Class<?> getPropertyType() \n+    {\n+        if (_accessorMethod != null) {\n+            return _accessorMethod.getReturnType();\n+        }\n+        return _field.getType();\n+    }\n+\n+    /**\n+     * Get the generic property type of this property writer.\n+     *\n+     * @return The property type, or null if not found.\n+     */\n+    public Type getGenericPropertyType()\n+    {\n+        if (_accessorMethod != null) {\n+            return _accessorMethod.getGenericReturnType();\n+        }\n+        return _field.getGenericType();\n+    }\n+\n+    public Class<?>[] getViews() { return _includeInViews; }\n+    \n+    /*\n+    /**********************************************************\n+    /* Serialization functionality\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to access property that this bean stands for, from\n+     * within given bean, and to serialize it as a JSON Object field\n+     * using appropriate serializer.\n+     */\n+    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        Object value = get(bean);\n+        // Null handling is bit different, check that first\n+        if (value == null) {\n+            if (!_suppressNulls) {\n+                jgen.writeFieldName(_name);\n+                prov.defaultSerializeNull(jgen);\n+            }\n+            return;\n+        }\n+        // For non-nulls, first: simple check for direct cycles\n+        if (value == bean) {\n+            _reportSelfReference(bean);\n+        }\n+        if (_suppressableValue != null && _suppressableValue.equals(value)) {\n+            return;\n+        }\n+\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+        jgen.writeFieldName(_name);\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, jgen, prov);\n+        } else {\n+            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+        }\n+    }\n+\n+    /**\n+     * @since 1.7\n+     */\n+    protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            Class<?> type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result;\n+        if (_nonTrivialBaseType != null) {\n+            JavaType t = provider.constructSpecializedType(_nonTrivialBaseType, type);\n+            result = map.findAndAddSerializer(t, provider, this);\n+        } else {\n+            result = map.findAndAddSerializer(type, provider, this);\n+        }\n+        // did we get a new map of serializers? If so, start using it\n+        if (map != result.map) {\n+            _dynamicSerializers = result.map;\n+        }\n+        return result.serializer;\n+    }\n+    \n+    /**\n+     * Method that can be used to access value of the property this\n+     * Object describes, from given bean instance.\n+     *<p>\n+     * Note: method is final as it should not need to be overridden -- rather,\n+     * calling method(s) ({@link #serializeAsField}) should be overridden\n+     * to change the behavior\n+     */\n+    public final Object get(Object bean) throws Exception\n+    {\n+        if (_accessorMethod != null) {\n+            return _accessorMethod.invoke(bean);\n+        }\n+        return _field.get(bean);\n+    }\n+\n+    protected void _reportSelfReference(Object bean)\n+        throws JsonMappingException\n+    {\n+        throw new JsonMappingException(\"Direct self-reference leading to cycle\");\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder(40);\n+        sb.append(\"property '\").append(getName()).append(\"' (\");\n+        if (_accessorMethod != null) {\n+            sb.append(\"via method \").append(_accessorMethod.getDeclaringClass().getName()).append(\"#\").append(_accessorMethod.getName());\n+        } else {\n+            sb.append(\"field \\\"\").append(_field.getDeclaringClass().getName()).append(\"#\").append(_field.getName());\n+        }\n+        if (_serializer == null) {\n+            sb.append(\", no static serializer\");\n+        } else {\n+            sb.append(\", static serializer of type \"+_serializer.getClass().getName());\n+        }\n+        sb.append(')');\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.impl.UnwrappingBeanSerializer;\n+import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n+\n+\n+/**\n+ * Serializer class that can serialize arbitrary bean objects\n+ *<p>\n+ * Implementation note: we will post-process resulting serializer,\n+ * to figure out actual serializers for final types. This must be\n+ * done from {@link #resolve} method, and NOT from constructor;\n+ * otherwise we could end up with an infinite loop.\n+ *<p>\n+ * Since 1.7 instances are immutable; this is achieved by using a\n+ * separate builder during construction process.\n+ */\n+public class BeanSerializer\n+    extends BeanSerializerBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @param type Nominal type of values handled by this serializer\n+     * @param properties Property writers used for actual serialization\n+     */\n+    public BeanSerializer(JavaType type,\n+            BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties,\n+            AnyGetterWriter anyGetterWriter,\n+            Object filterId)\n+    {\n+        super(type, properties, filteredProperties, anyGetterWriter, filterId);\n+    }\n+\n+    public BeanSerializer(Class<?> rawType,\n+            BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties,\n+            AnyGetterWriter anyGetterWriter,\n+            Object filterId)\n+    {\n+        super(rawType, properties, filteredProperties, anyGetterWriter, filterId);\n+    }\n+\n+    /**\n+     * Copy-constructor that is useful for sub-classes that just want to\n+     * copy all super-class properties without modifications.\n+     * \n+     * @since 1.7\n+     */\n+    protected BeanSerializer(BeanSerializer src) {\n+        super(src);\n+    }\n+\n+    /**\n+     * Alternate copy constructor that can be used to construct\n+     * standard {@link BeanSerializer} passing an instance of\n+     * \"compatible enough\" source serializer.\n+     * \n+     * @since 1.9\n+     */\n+    protected BeanSerializer(BeanSerializerBase src) {\n+        super(src);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: factory methods, fluent factories\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for constructing dummy bean deserializer; one that\n+     * never outputs any properties\n+     */\n+    public static BeanSerializer createDummy(Class<?> forType)\n+    {\n+        return new BeanSerializer(forType, NO_PROPS, null, null, null);\n+    }\n+\n+    @Override\n+    public JsonSerializer<Object> unwrappingSerializer() {\n+        return new UnwrappingBeanSerializer(this);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonSerializer implementation that differs between impls\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Main serialization method that will delegate actual output to\n+     * configured\n+     * {@link BeanPropertyWriter} instances.\n+     */\n+    @Override\n+    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeStartObject();\n+        if (_propertyFilterId != null) {\n+            serializeFieldsFiltered(bean, jgen, provider);\n+        } else {\n+            serializeFields(bean, jgen, provider);\n+        }\n+        jgen.writeEndObject();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override public String toString() {\n+        return \"BeanSerializer for \"+handledType().getName();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerBuilder.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n+\n+/**\n+ * Builder class used for aggregating deserialization information about\n+ * a POJO, in order to build a {@link JsonSerializer} for serializing\n+ * intances.\n+ * Main reason for using separate builder class is that this makes it easier\n+ * to make actual serializer class fully immutable.\n+ * \n+ * @since 1.7\n+ */\n+public class BeanSerializerBuilder\n+{\n+    private final static BeanPropertyWriter[] NO_PROPERTIES = new BeanPropertyWriter[0];\n+\n+    /*\n+    /**********************************************************\n+    /* General information about POJO\n+    /**********************************************************\n+     */\n+\n+    final protected BasicBeanDescription _beanDesc;\n+\n+    /*\n+    /**********************************************************\n+    /* Accumulated information about properties\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Bean properties, in order of serialization\n+     */\n+    protected List<BeanPropertyWriter> _properties;\n+\n+    /**\n+     * Optional array of filtered property writers; if null, no\n+     * view-based filtering is performed.\n+     */\n+    protected BeanPropertyWriter[] _filteredProperties;\n+    \n+    /**\n+     * Writer used for \"any getter\" properties, if any.\n+     */\n+    protected AnyGetterWriter _anyGetter;\n+\n+    /**\n+     * Id of the property filter to use for POJO, if any.\n+     */\n+    protected Object _filterId;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction and setter methods\n+    /**********************************************************\n+     */\n+    \n+    public BeanSerializerBuilder(BasicBeanDescription beanDesc) {\n+        _beanDesc = beanDesc;\n+    }\n+\n+    /**\n+     * Copy-constructor that may be used for sub-classing\n+     */\n+    protected BeanSerializerBuilder(BeanSerializerBuilder src) {\n+        _beanDesc = src._beanDesc;\n+        _properties = src._properties;\n+        _filteredProperties = src._filteredProperties;\n+        _anyGetter = src._anyGetter;\n+        _filterId = src._filterId;\n+    }\n+    \n+    public BasicBeanDescription getBeanDescription() { return _beanDesc; }\n+    public List<BeanPropertyWriter> getProperties() { return _properties; }\n+    public BeanPropertyWriter[] getFilteredProperties() { return _filteredProperties; }\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    public boolean hasProperties() {\n+        return (_properties != null) && (_properties.size() > 0);\n+    }\n+\n+    public void setProperties(List<BeanPropertyWriter> properties) {\n+        _properties = properties;\n+    }\n+\n+    public void setFilteredProperties(BeanPropertyWriter[] properties) {\n+        _filteredProperties = properties;\n+    }\n+    \n+    public void setAnyGetter(AnyGetterWriter anyGetter) {\n+        _anyGetter = anyGetter;\n+    }\n+\n+    public void setFilterId(Object filterId) {\n+        _filterId = filterId;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Build methods for actually creating serializer instance\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called to create {@link BeanSerializer} instance with\n+     * all accumulated information. Will construct a serializer if we\n+     * have enough information, or return null if not.\n+     */\n+    public JsonSerializer<?> build()\n+    {\n+        BeanPropertyWriter[] properties;\n+        // No properties or any getter? No real serializer; caller gets to handle\n+        if (_properties == null || _properties.isEmpty()) {\n+            if (_anyGetter == null) {\n+                return null;\n+            }\n+            properties = NO_PROPERTIES;\n+        } else {\n+            properties = _properties.toArray(new BeanPropertyWriter[_properties.size()]);\n+            \n+        }\n+        return new BeanSerializer(_beanDesc.getType(), properties, _filteredProperties, _anyGetter, _filterId);\n+    }\n+    \n+    /**\n+     * Factory method for constructing an \"empty\" serializer; one that\n+     * outputs no properties (but handles JSON objects properly, including\n+     * type information)\n+     */\n+    public BeanSerializer createDummy() {\n+        return BeanSerializer.createDummy(_beanDesc.getBeanClass());\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.TypeResolverBuilder;\n+import com.fasterxml.jackson.databind.ser.std.MapSerializer;\n+import com.fasterxml.jackson.databind.type.*;\n+import com.fasterxml.jackson.databind.util.ArrayBuilders;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+\n+ \n+/**\n+ * Factory class that can provide serializers for any regular Java beans\n+ * (as defined by \"having at least one get method recognizable as bean\n+ * accessor\" -- where {@link Object#getClass} does not count);\n+ * as well as for \"standard\" JDK types. Latter is achieved\n+ * by delegating calls to {@link BasicSerializerFactory} \n+ * to find serializers both for \"standard\" JDK types (and in some cases,\n+ * sub-classes as is the case for collection classes like\n+ * {@link java.util.List}s and {@link java.util.Map}s) and bean (value)\n+ * classes.\n+ *<p>\n+ * Note about delegating calls to {@link BasicSerializerFactory}:\n+ * although it would be nicer to use linear delegation\n+ * for construction (to essentially dispatch all calls first to the\n+ * underlying {@link BasicSerializerFactory}; or alternatively after\n+ * failing to provide bean-based serializer}, there is a problem:\n+ * priority levels for detecting standard types are mixed. That is,\n+ * we want to check if a type is a bean after some of \"standard\" JDK\n+ * types, but before the rest.\n+ * As a result, \"mixed\" delegation used, and calls are NOT done using\n+ * regular {@link SerializerFactory} interface but rather via\n+ * direct calls to {@link BasicSerializerFactory}.\n+ *<p>\n+ * Finally, since all caching is handled by the serializer provider\n+ * (not factory) and there is no configurability, this\n+ * factory is stateless.\n+ * This means that a global singleton instance can be used.\n+ *<p>\n+ * Notes for version 1.7 (and above): the new module registration system\n+ * required addition of {@link #withConfig}, which has to\n+ * be redefined by sub-classes so that they can work properly with\n+ * pluggable additional serializer providing components.\n+ */\n+public class BeanSerializerFactory\n+    extends BasicSerializerFactory\n+{\n+    /**\n+     * Like {@link BasicSerializerFactory}, this factory is stateless, and\n+     * thus a single shared global (== singleton) instance can be used\n+     * without thread-safety issues.\n+     */\n+    public final static BeanSerializerFactory instance = new BeanSerializerFactory(null);\n+\n+    /**\n+     * Configuration settings for this factory; immutable instance (just like this\n+     * factory), new version created via copy-constructor (fluent-style)\n+     * \n+     * @since 1.7\n+     */\n+    protected final Config _factoryConfig;\n+\n+    /*\n+    /**********************************************************\n+    /* Config class implementation\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Configuration settings container class for bean serializer factory\n+     * \n+     * @since 1.7\n+     */\n+    public static class ConfigImpl extends Config\n+    {\n+        /**\n+         * Constant for empty <code>Serializers</code> array (which by definition\n+         * is stateless and reusable)\n+         */\n+        protected final static Serializers[] NO_SERIALIZERS = new Serializers[0];\n+\n+        protected final static BeanSerializerModifier[] NO_MODIFIERS = new BeanSerializerModifier[0];\n+        \n+        /**\n+         * List of providers for additional serializers, checked before considering default\n+         * basic or bean serialializers.\n+         * \n+         * @since 1.7\n+         */\n+        protected final Serializers[] _additionalSerializers;\n+\n+        /**\n+         * @since 1.8\n+         */\n+        protected final Serializers[] _additionalKeySerializers;\n+        \n+        /**\n+         * List of modifiers that can change the way {@link BeanSerializer} instances\n+         * are configured and constructed.\n+         */\n+        protected final BeanSerializerModifier[] _modifiers;\n+        \n+        public ConfigImpl() {\n+            this(null, null, null);\n+        }\n+\n+        protected ConfigImpl(Serializers[] allAdditionalSerializers,\n+                Serializers[] allAdditionalKeySerializers,\n+                BeanSerializerModifier[] modifiers)\n+        {\n+            _additionalSerializers = (allAdditionalSerializers == null) ?\n+                    NO_SERIALIZERS : allAdditionalSerializers;\n+            _additionalKeySerializers = (allAdditionalKeySerializers == null) ?\n+                    NO_SERIALIZERS : allAdditionalKeySerializers;\n+            _modifiers = (modifiers == null) ? NO_MODIFIERS : modifiers;\n+        }\n+\n+        @Override\n+        public Config withAdditionalSerializers(Serializers additional)\n+        {\n+            if (additional == null) {\n+                throw new IllegalArgumentException(\"Can not pass null Serializers\");\n+            }\n+            Serializers[] all = ArrayBuilders.insertInListNoDup(_additionalSerializers, additional);\n+            return new ConfigImpl(all, _additionalKeySerializers, _modifiers);\n+        }\n+\n+        @Override\n+        public Config withAdditionalKeySerializers(Serializers additional)\n+        {\n+            if (additional == null) {\n+                throw new IllegalArgumentException(\"Can not pass null Serializers\");\n+            }\n+            Serializers[] all = ArrayBuilders.insertInListNoDup(_additionalKeySerializers, additional);\n+            return new ConfigImpl(_additionalSerializers, all, _modifiers);\n+        }\n+        \n+        @Override\n+        public Config withSerializerModifier(BeanSerializerModifier modifier)\n+        {\n+            if (modifier == null) {\n+                throw new IllegalArgumentException(\"Can not pass null modifier\");\n+            }\n+            BeanSerializerModifier[] modifiers = ArrayBuilders.insertInListNoDup(_modifiers, modifier);\n+            return new ConfigImpl(_additionalSerializers, _additionalKeySerializers, modifiers);\n+        }\n+\n+        @Override\n+        public boolean hasSerializers() { return _additionalSerializers.length > 0; }\n+\n+        @Override\n+        public boolean hasKeySerializers() { return _additionalKeySerializers.length > 0; }\n+        \n+        @Override\n+        public boolean hasSerializerModifiers() { return _modifiers.length > 0; }\n+        \n+        @Override\n+        public Iterable<Serializers> serializers() {\n+            return ArrayBuilders.arrayAsIterable(_additionalSerializers);\n+        }\n+\n+        @Override\n+        public Iterable<Serializers> keySerializers() {\n+            return ArrayBuilders.arrayAsIterable(_additionalKeySerializers);\n+        }\n+        \n+        @Override\n+        public Iterable<BeanSerializerModifier> serializerModifiers() {\n+            return ArrayBuilders.arrayAsIterable(_modifiers);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: creation, configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor for creating instances with specified configuration.\n+     */\n+    protected BeanSerializerFactory(Config config)\n+    {\n+        if (config == null) {\n+            config = new ConfigImpl();\n+        }\n+        _factoryConfig = config;\n+    }\n+\n+    @Override public Config getConfig() { return _factoryConfig; }\n+    \n+    /**\n+     * Method used by module registration functionality, to attach additional\n+     * serializer providers into this serializer factory. This is typically\n+     * handled by constructing a new instance with additional serializers,\n+     * to ensure thread-safe access.\n+     * \n+     * @since 1.7\n+     */\n+    @Override\n+    public SerializerFactory withConfig(Config config)\n+    {\n+        if (_factoryConfig == config) {\n+            return this;\n+        }\n+        /* 22-Nov-2010, tatu: Handling of subtypes is tricky if we do immutable-with-copy-ctor;\n+         *    and we pretty much have to here either choose between losing subtype instance\n+         *    when registering additional serializers, or losing serializers.\n+         *    Instead, let's actually just throw an error if this method is called when subtype\n+         *    has not properly overridden this method; this to indicate problem as soon as possible.\n+         */\n+        if (getClass() != BeanSerializerFactory.class) {\n+            throw new IllegalStateException(\"Subtype of BeanSerializerFactory (\"+getClass().getName()\n+                    +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \"\n+                    +\"additional serializer definitions\");\n+        }\n+        return new BeanSerializerFactory(config);\n+    }\n+\n+    @Override\n+    protected Iterable<Serializers> customSerializers() {\n+        return _factoryConfig.serializers();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* SerializerFactory impl\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Main serializer constructor method. We will have to be careful\n+     * with respect to ordering of various method calls: essentially\n+     * we want to reliably figure out which classes are standard types,\n+     * and which are beans. The problem is that some bean Classes may\n+     * implement standard interfaces (say, {@link java.lang.Iterable}.\n+     *<p>\n+     * Note: sub-classes may choose to complete replace implementation,\n+     * if they want to alter priority of serializer lookups.\n+     */\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonSerializer<Object> createSerializer(SerializationConfig config, JavaType origType,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // Very first thing, let's check if there is explicit serializer annotation:\n+        BasicBeanDescription beanDesc = config.introspect(origType);\n+        JsonSerializer<?> ser = findSerializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n+        if (ser != null) {\n+            return (JsonSerializer<Object>) ser;\n+        }\n+\n+        // Next: we may have annotations that further define types to use...\n+        JavaType type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), origType);\n+        // and if so, we consider it implicit \"force static typing\" instruction\n+        boolean staticTyping = (type != origType);\n+        \n+        // Container types differ from non-container types:\n+        if (origType.isContainerType()) {\n+            return (JsonSerializer<Object>) buildContainerSerializer(config, type, beanDesc, property, staticTyping);\n+        }\n+\n+        // Modules may provide serializers of all types:\n+        for (Serializers serializers : _factoryConfig.serializers()) {\n+            ser = serializers.findSerializer(config, type, beanDesc, property);\n+            if (ser != null) {\n+                return (JsonSerializer<Object>) ser;\n+            }\n+        }\n+\n+        /* Otherwise, we will check \"primary types\"; both marker types that\n+         * indicate specific handling (JsonSerializable), or main types that have\n+         * precedence over container types\n+         */\n+        ser = findSerializerByLookup(type, config, beanDesc, property, staticTyping);\n+        if (ser == null) {\n+            ser = findSerializerByPrimaryType(type, config, beanDesc, property, staticTyping);\n+            if (ser == null) {\n+                /* And this is where this class comes in: if type is not a\n+                 * known \"primary JDK type\", perhaps it's a bean? We can still\n+                 * get a null, if we can't find a single suitable bean property.\n+                 */\n+                ser = findBeanSerializer(config, type, beanDesc, property);\n+                /* Finally: maybe we can still deal with it as an\n+                 * implementation of some basic JDK interface?\n+                 */\n+                if (ser == null) {\n+                    ser = findSerializerByAddonType(config, type, beanDesc, property, staticTyping);\n+                }\n+            }\n+        }\n+        return (JsonSerializer<Object>) ser;\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonSerializer<Object> createKeySerializer(SerializationConfig config, JavaType type,\n+            BeanProperty property)\n+    {\n+        // Minor optimization: to avoid constructing beanDesc, bail out if none registered\n+        if (!_factoryConfig.hasKeySerializers()) {\n+            return null;\n+        }\n+        \n+        // We should not need any member method info; at most class annotations for Map type\n+        BasicBeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n+        JsonSerializer<?> ser = null;\n+        \n+        // Only thing we have here are module-provided key serializers:\n+        for (Serializers serializers : _factoryConfig.keySerializers()) {\n+            ser = serializers.findSerializer(config, type, beanDesc, property);\n+            if (ser != null) {\n+                break;\n+            }\n+        }\n+        return (JsonSerializer<Object>) ser;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other public methods that are not part of\n+    /* JsonSerializerFactory API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will try to construct a {@link BeanSerializer} for\n+     * given class. Returns null if no properties are found.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public JsonSerializer<Object> findBeanSerializer(SerializationConfig config, JavaType type,\n+            BasicBeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // First things first: we know some types are not beans...\n+        if (!isPotentialBeanType(type.getRawClass())) {\n+            return null;\n+        }\n+        JsonSerializer<Object> serializer = constructBeanSerializer(config, beanDesc, property);\n+        // [JACKSON-440] Need to allow overriding actual serializer, as well...\n+        if (_factoryConfig.hasSerializerModifiers()) {\n+            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                serializer = (JsonSerializer<Object>)mod.modifySerializer(config, beanDesc, serializer);\n+            }\n+        }\n+        return serializer;\n+    }\n+\n+    /**\n+     * Method called to create a type information serializer for values of given\n+     * non-container property\n+     * if one is needed. If not needed (no polymorphic handling configured), should\n+     * return null.\n+     *\n+     * @param baseType Declared type to use as the base type for type information serializer\n+     * \n+     * @return Type serializer to use for property values, if one is needed; null if not.\n+     * \n+     * @since 1.5\n+     */\n+    public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config,\n+            AnnotatedMember accessor, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+        TypeResolverBuilder<?> b = ai.findPropertyTypeResolver(config, accessor, baseType);        \n+        // Defaulting: if no annotations on member, check value class\n+        if (b == null) {\n+            return createTypeSerializer(config, baseType, property);\n+        }\n+        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor, config, ai);\n+        return b.buildTypeSerializer(config, baseType, subtypes, property);\n+    }\n+\n+    /**\n+     * Method called to create a type information serializer for values of given\n+     * container property\n+     * if one is needed. If not needed (no polymorphic handling configured), should\n+     * return null.\n+     *\n+     * @param containerType Declared type of the container to use as the base type for type information serializer\n+     * \n+     * @return Type serializer to use for property value contents, if one is needed; null if not.\n+     * \n+     * @since 1.5\n+     */    \n+    public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config,\n+            AnnotatedMember accessor, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JavaType contentType = containerType.getContentType();\n+        AnnotationIntrospector ai = config.getAnnotationIntrospector();\n+        TypeResolverBuilder<?> b = ai.findPropertyContentTypeResolver(config, accessor, containerType);        \n+        // Defaulting: if no annotations on member, check value class\n+        if (b == null) {\n+            return createTypeSerializer(config, contentType, property);\n+        }\n+        Collection<NamedType> subtypes = config.getSubtypeResolver().collectAndResolveSubtypes(accessor, config, ai);\n+        return b.buildTypeSerializer(config, contentType, subtypes, property);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridable non-public factory methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to construct serializer for serializing specified bean type.\n+     * \n+     * @since 1.6\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonSerializer<Object> constructBeanSerializer(SerializationConfig config,\n+            BasicBeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // 13-Oct-2010, tatu: quick sanity check: never try to create bean serializer for plain Object\n+        if (beanDesc.getBeanClass() == Object.class) {\n+            throw new IllegalArgumentException(\"Can not create bean serializer for Object.class\");\n+        }\n+        \n+        BeanSerializerBuilder builder = constructBeanSerializerBuilder(beanDesc);\n+        \n+        // First: any detectable (auto-detect, annotations) properties to serialize?\n+        List<BeanPropertyWriter> props = findBeanProperties(config, beanDesc);\n+\n+        if (props == null) {\n+            props = new ArrayList<BeanPropertyWriter>();\n+        }\n+        // [JACKSON-440] Need to allow modification bean properties to serialize:\n+        if (_factoryConfig.hasSerializerModifiers()) {\n+            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                props = mod.changeProperties(config, beanDesc, props);\n+            }\n+        }\n+        \n+        // Any properties to suppress?\n+        props = filterBeanProperties(config, beanDesc, props);\n+        // Do they need to be sorted in some special way?\n+        props = sortBeanProperties(config, beanDesc, props);\n+        \n+        // [JACKSON-440] Need to allow reordering of properties to serialize\n+        if (_factoryConfig.hasSerializerModifiers()) {\n+            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                props = mod.orderProperties(config, beanDesc, props);\n+            }\n+        }\n+        \n+        builder.setProperties(props);\n+        builder.setFilterId(findFilterId(config, beanDesc));\n+        \n+        AnnotatedMethod anyGetter = beanDesc.findAnyGetter();\n+        if (anyGetter != null) { // since 1.6\n+            if (config.isEnabled(SerializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+                anyGetter.fixAccess();\n+            }\n+            JavaType type = anyGetter.getType(beanDesc.bindingsForBeanType());\n+            // copied from BasicSerializerFactory.buildMapSerializer():\n+            boolean staticTyping = config.isEnabled(SerializationConfig.Feature.USE_STATIC_TYPING);\n+            JavaType valueType = type.getContentType();\n+            TypeSerializer typeSer = createTypeSerializer(config, valueType, property);\n+            // last 2 nulls; don't know key, value serializers (yet)\n+            MapSerializer mapSer = MapSerializer.construct(/* ignored props*/ null, type, staticTyping,\n+                    typeSer, property, null, null);\n+            builder.setAnyGetter(new AnyGetterWriter(anyGetter, mapSer));\n+        }\n+        // One more thing: need to gather view information, if any:\n+        processViews(config, builder);\n+        // And maybe let interested parties mess with the result bit more...\n+        if (_factoryConfig.hasSerializerModifiers()) {\n+            for (BeanSerializerModifier mod : _factoryConfig.serializerModifiers()) {\n+                builder = mod.updateBuilder(config, beanDesc, builder);\n+            }\n+        }\n+        JsonSerializer<Object> ser = (JsonSerializer<Object>) builder.build();\n+\n+        /* However, after all modifications: no properties, no serializer\n+         * (note; as per [JACKSON-670], check was moved later on from an earlier location)\n+         */\n+        if (ser == null) {\n+            /* 27-Nov-2009, tatu: Except that as per [JACKSON-201], we are\n+             *   ok with that as long as it has a recognized class annotation\n+             *  (which may come from a mix-in too)\n+             */\n+            if (beanDesc.hasKnownClassAnnotations()) {\n+                return builder.createDummy();\n+            }\n+        }\n+        return ser;\n+    }\n+\n+    /**\n+     * Method called to construct a filtered writer, for given view\n+     * definitions. Default implementation constructs filter that checks\n+     * active view type to views property is to be included in.\n+     */\n+    protected BeanPropertyWriter constructFilteredBeanWriter(BeanPropertyWriter writer, Class<?>[] inViews)\n+    {\n+        return FilteredBeanPropertyWriter.constructViewBased(writer, inViews);\n+    }\n+    \n+    protected PropertyBuilder constructPropertyBuilder(SerializationConfig config,\n+                                                       BasicBeanDescription beanDesc)\n+    {\n+        return new PropertyBuilder(config, beanDesc);\n+    }\n+\n+    protected BeanSerializerBuilder constructBeanSerializerBuilder(BasicBeanDescription beanDesc) {\n+        return new BeanSerializerBuilder(beanDesc);\n+    }\n+\n+    /**\n+     * Method called to find filter that is configured to be used with bean\n+     * serializer being built, if any.\n+     * \n+     * @since 1.7\n+     */\n+    protected Object findFilterId(SerializationConfig config, BasicBeanDescription beanDesc)\n+    {\n+        return config.getAnnotationIntrospector().findFilterId(beanDesc.getClassInfo());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridable non-public introspection methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method used to skip processing for types that we know\n+     * can not be (i.e. are never consider to be) beans: \n+     * things like primitives, Arrays, Enums, and proxy types.\n+     *<p>\n+     * Note that usually we shouldn't really be getting these sort of\n+     * types anyway; but better safe than sorry.\n+     */\n+    protected boolean isPotentialBeanType(Class<?> type)\n+    {\n+        return (ClassUtil.canBeABeanType(type) == null) && !ClassUtil.isProxyType(type);\n+    }\n+\n+    /**\n+     * Method used to collect all actual serializable properties.\n+     * Can be overridden to implement custom detection schemes.\n+     */\n+    protected List<BeanPropertyWriter> findBeanProperties(SerializationConfig config, BasicBeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        List<BeanPropertyDefinition> properties = beanDesc.findProperties();\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+\n+        // [JACKSON-429]: ignore specified types\n+        removeIgnorableTypes(config, beanDesc, properties);\n+        \n+        // and possibly remove ones without matching mutator...\n+        if (config.isEnabled(SerializationConfig.Feature.REQUIRE_SETTERS_FOR_GETTERS)) {\n+            removeSetterlessGetters(config, beanDesc, properties);\n+        }\n+        \n+        // nothing? can't proceed (caller may or may not throw an exception)\n+        if (properties.isEmpty()) {\n+            return null;\n+        }\n+        \n+        // null is for value type serializer, which we don't have access to from here (ditto for bean prop)\n+        boolean staticTyping = usesStaticTyping(config, beanDesc, null, null);\n+        PropertyBuilder pb = constructPropertyBuilder(config, beanDesc);\n+\n+        ArrayList<BeanPropertyWriter> result = new ArrayList<BeanPropertyWriter>(properties.size());\n+        TypeBindings typeBind = beanDesc.bindingsForBeanType();\n+        // [JACKSON-98]: start with field properties, if any\n+        for (BeanPropertyDefinition property : properties) {\n+            AnnotatedMember accessor = property.getAccessor();\n+            // [JACKSON-235]: suppress writing of back references\n+            AnnotationIntrospector.ReferenceProperty prop = intr.findReferenceType(accessor);\n+            if (prop != null && prop.isBackReference()) {\n+                continue;\n+            }\n+            String name = property.getName();\n+            if (accessor instanceof AnnotatedMethod) {\n+                result.add(_constructWriter(config, typeBind, pb, staticTyping, name, (AnnotatedMethod) accessor));\n+            } else {\n+                result.add(_constructWriter(config, typeBind, pb, staticTyping, name, (AnnotatedField) accessor));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridable non-public methods for manipulating bean properties\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Overridable method that can filter out properties. Default implementation\n+     * checks annotations class may have.\n+     */\n+    protected List<BeanPropertyWriter> filterBeanProperties(SerializationConfig config,\n+            BasicBeanDescription beanDesc, List<BeanPropertyWriter> props)\n+    {\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        AnnotatedClass ac = beanDesc.getClassInfo();\n+        String[] ignored = intr.findPropertiesToIgnore(ac);\n+        if (ignored != null && ignored.length > 0) {\n+            HashSet<String> ignoredSet = ArrayBuilders.arrayToSet(ignored);\n+            Iterator<BeanPropertyWriter> it = props.iterator();\n+            while (it.hasNext()) {\n+                if (ignoredSet.contains(it.next().getName())) {\n+                    it.remove();\n+                }\n+            }\n+        }\n+        return props;\n+    }\n+\n+    /**\n+     * Overridable method that will impose given partial ordering on\n+     * list of discovered propertied. Method can be overridden to\n+     * provide custom ordering of properties, beyond configurability\n+     * offered by annotations (whic allow alphabetic ordering, as\n+     * well as explicit ordering by providing array of property names).\n+     *<p>\n+     * By default Creator properties will be ordered before other\n+     * properties. Explicit custom ordering will override this implicit\n+     * default ordering.\n+     */\n+    /**\n+     * Method that used to be called (pre-1.9) to impose configured\n+     * ordering on list of discovered properties.\n+     * With 1.9 it is not needed any more as ordering is done earlier.\n+     * \n+     * @deprecated Since 1.9 this method does nothing, so there is no\n+     *    benefit from overriding it; it will be removed from 2.0.\n+     */\n+    @Deprecated\n+    protected List<BeanPropertyWriter> sortBeanProperties(SerializationConfig config,\n+            BasicBeanDescription beanDesc, List<BeanPropertyWriter> props)\n+    {\n+        return props;\n+    }\n+\n+    /**\n+     * Method called to handle view information for constructed serializer,\n+     * based on bean property writers.\n+     *<p>\n+     * Note that this method is designed to be overridden by sub-classes\n+     * if they want to provide custom view handling. As such it is not\n+     * considered an internal implementation detail, and will be supported\n+     * as part of API going forward.\n+     *<p>\n+     * NOTE: signature of this method changed in 1.7, due to other significant\n+     * changes (esp. use of builder for serializer construction).\n+     */\n+    protected void processViews(SerializationConfig config, BeanSerializerBuilder builder)\n+    {\n+        // [JACKSON-232]: whether non-annotated fields are included by default or not is configurable\n+        List<BeanPropertyWriter> props = builder.getProperties();\n+        boolean includeByDefault = config.isEnabled(SerializationConfig.Feature.DEFAULT_VIEW_INCLUSION);\n+        final int propCount = props.size();\n+        int viewsFound = 0;\n+        BeanPropertyWriter[] filtered = new BeanPropertyWriter[propCount];\n+        // Simple: view information is stored within individual writers, need to combine:\n+        for (int i = 0; i < propCount; ++i) {\n+            BeanPropertyWriter bpw = props.get(i);\n+            Class<?>[] views = bpw.getViews();\n+            if (views == null) { // no view info? include or exclude by default?\n+                if (includeByDefault) {\n+                    filtered[i] = bpw;\n+                }\n+            } else {\n+                ++viewsFound;\n+                filtered[i] = constructFilteredBeanWriter(bpw, views);\n+            }\n+        }\n+        // minor optimization: if no view info, include-by-default, can leave out filtering info altogether:\n+        if (includeByDefault && viewsFound == 0) {\n+            return;\n+        }\n+        builder.setFilteredProperties(filtered);\n+    }\n+\n+    /**\n+     * Method that will apply by-type limitations (as per [JACKSON-429]);\n+     * by default this is based on {@link org.codehaus.jackson.annotate.JsonIgnoreType} annotation but\n+     * can be supplied by module-provided introspectors too.\n+     */\n+    protected void removeIgnorableTypes(SerializationConfig config, BasicBeanDescription beanDesc,\n+            List<BeanPropertyDefinition> properties)\n+    {\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        HashMap<Class<?>,Boolean> ignores = new HashMap<Class<?>,Boolean>();\n+        Iterator<BeanPropertyDefinition> it = properties.iterator();\n+        while (it.hasNext()) {\n+            BeanPropertyDefinition property = it.next();\n+            AnnotatedMember accessor = property.getAccessor();\n+            if (accessor == null) {\n+                it.remove();\n+                continue;\n+            }\n+            Class<?> type = accessor.getRawType();\n+            Boolean result = ignores.get(type);\n+            if (result == null) {\n+                BasicBeanDescription desc = config.introspectClassAnnotations(type);\n+                AnnotatedClass ac = desc.getClassInfo();\n+                result = intr.isIgnorableType(ac);\n+                // default to false, non-ignorable\n+                if (result == null) {\n+                    result = Boolean.FALSE;\n+                }\n+                ignores.put(type, result);\n+            }\n+            // lotsa work, and yes, it is ignorable type, so:\n+            if (result.booleanValue()) {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Helper method that will remove all properties that do not have a\n+     * mutator.\n+     * \n+     * @since 1.9\n+     */\n+    protected void removeSetterlessGetters(SerializationConfig config, BasicBeanDescription beanDesc,\n+            List<BeanPropertyDefinition> properties)\n+    {\n+        Iterator<BeanPropertyDefinition> it = properties.iterator();\n+        while (it.hasNext()) {\n+            BeanPropertyDefinition property = it.next();\n+            if (!property.couldDeserialize()) {\n+                it.remove();\n+            }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Secondary helper method for constructing {@link BeanPropertyWriter} for\n+     * given member (field or method).\n+     */\n+    protected BeanPropertyWriter _constructWriter(SerializationConfig config, TypeBindings typeContext,\n+            PropertyBuilder pb, boolean staticTyping, String name, AnnotatedMember accessor)\n+        throws JsonMappingException\n+    {\n+        if (config.isEnabled(SerializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n+            accessor.fixAccess();\n+        }\n+        JavaType type = accessor.getType(typeContext);\n+        BeanProperty.Std property = new BeanProperty.Std(name, type, pb.getClassAnnotations(), accessor);\n+\n+        // Does member specify a serializer? If so, let's use it.\n+        JsonSerializer<Object> annotatedSerializer = findSerializerFromAnnotation(config, accessor, property);\n+        // And how about polymorphic typing? First special to cover JAXB per-field settings:\n+        TypeSerializer contentTypeSer = null;\n+        if (ClassUtil.isCollectionMapOrArray(type.getRawClass())) {\n+            contentTypeSer = findPropertyContentTypeSerializer(type, config, accessor, property);\n+        }\n+\n+        // and if not JAXB collection/array with annotations, maybe regular type info?\n+        TypeSerializer typeSer = findPropertyTypeSerializer(type, config, accessor, property);\n+        BeanPropertyWriter pbw = pb.buildWriter(name, type, annotatedSerializer,\n+                        typeSer, contentTypeSer, accessor, staticTyping);\n+        // how about views? (1.4+)\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        pbw.setViews(intr.findSerializationViews(accessor));\n+        return pbw;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerModifier.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.util.List;\n+\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n+\n+/**\n+ * Abstract class that defines API for objects that can be registered (for {@link BeanSerializerFactory}\n+ * to participate in constructing {@link BeanSerializer} instances.\n+ * This is typically done by modules that want alter some aspects of serialization\n+ * process; and is preferable to sub-classing of {@link BeanSerializerFactory}.\n+ *<p>\n+ * Sequence in which callback methods are called is as follows:\n+ * <ol>\n+ *  <li>After factory has collected tentative set of properties (instances of\n+ *     <code>BeanPropertyWriter</code>) is sent for modification via\n+ *     {@link #changeProperties}. Changes can include removal, addition and\n+ *     replacement of suggested properties.\n+ *  <li>Resulting set of properties are ordered (sorted) by factory, as per\n+ *     configuration, and then {@link #orderProperties} is called to allow\n+ *     modifiers to alter ordering.\n+ *  <li>After all bean properties and related information is accumulated,\n+ *     {@link #updateBuilder} is called with builder, to allow builder state\n+ *     to be modified (including possibly replacing builder itself if necessary)\n+ *  <li>Once all bean information has been determined,\n+ *     factory creates default {@link BeanSerializer} instance and passes\n+ *     it to modifiers using {@link #modifySerializer}, for possible\n+ *     modification or replacement (by any {@link com.fasterxml.jackson.databind.JsonSerializer} instance)\n+ * </ol>\n+ *<p>\n+ * Default method implementations are \"no-op\"s, meaning that methods are implemented\n+ * but have no effect.\n+ * \n+ * @since 1.7\n+ */\n+public abstract class BeanSerializerModifier\n+{\n+    /**\n+     * Method called by {@link BeanSerializerFactory} with tentative set\n+     * of discovered properties.\n+     * Implementations can add, remove or replace any of passed properties.\n+     *\n+     * Properties <code>List</code> passed as argument is modifiable, and returned List must\n+     * likewise be modifiable as it may be passed to multiple registered\n+     * modifiers.\n+     */\n+    public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\n+            BasicBeanDescription beanDesc, List<BeanPropertyWriter> beanProperties) {\n+        return beanProperties;\n+    }\n+\n+    /**\n+     * Method called by {@link BeanSerializerFactory} with set of properties\n+     * to serialize, in default ordering (based on defaults as well as \n+     * possible type annotations).\n+     * Implementations can change ordering any way they like.\n+     *\n+     * Properties <code>List</code> passed as argument is modifiable, and returned List must\n+     * likewise be modifiable as it may be passed to multiple registered\n+     * modifiers.\n+     */\n+    public List<BeanPropertyWriter> orderProperties(SerializationConfig config,\n+            BasicBeanDescription beanDesc, List<BeanPropertyWriter> beanProperties) {\n+        return beanProperties;\n+    }\n+\n+    /**\n+     * Method called by {@link BeanSerializerFactory} after collecting all information\n+     * regarding POJO to serialize and updating builder with it, but before constructing\n+     * serializer.\n+     * Implementations may choose to modify state of builder (to affect serializer being\n+     * built), or even completely replace it (if they want to build different kind of\n+     * serializer). Typically, however, passed-in builder is returned, possibly with\n+     * some modifications.\n+     */\n+    public BeanSerializerBuilder updateBuilder(SerializationConfig config,\n+            BasicBeanDescription beanDesc, BeanSerializerBuilder builder) {\n+        return builder;\n+    }\n+    \n+    /**\n+     * Method called by {@link BeanSerializerFactory} after constructing default\n+     * bean serializer instance with properties collected and ordered earlier.\n+     * Implementations can modify or replace given serializer and return serializer\n+     * to use. Note that although initial serializer being passed is of type\n+     * {@link BeanSerializer}, modifiers may return serializers of other types;\n+     * and this is why implementations must check for type before casting.\n+     */\n+    public JsonSerializer<?> modifySerializer(SerializationConfig config,\n+            BasicBeanDescription beanDesc, JsonSerializer<?> serializer) {\n+        return serializer;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/CustomSerializerFactory.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+\n+\n+/**\n+ * Serializer factory implementation that allows for configuring\n+ * mapping between types (classes) and serializers to use, by using\n+ * multiple types of overrides. Existing mappings established by\n+ * {@link BeanSerializerFactory} (and its super class,\n+ * {@link BasicSerializerFactory}) are used if no overrides are\n+ * defined.\n+ *<p>\n+ * Unlike base serializer factories ({@link BasicSerializerFactory},\n+ * {@link BeanSerializerFactory}), this factory is stateful because\n+ * of configuration settings. It is thread-safe, however, as long as\n+ * all configuration as done before using the factory -- a single\n+ * instance can be shared between providers and mappers.\n+ *<p>\n+ * Configurations currently available are:\n+ *<ul>\n+ * <li>Ability to define explicit mappings between classes and interfaces\n+ *  and serializers to use. These can be either specific ones (class must\n+ *  match exactly) or generic ones (any sub-class or class implementing\n+ *  the interface); specific ones have precedence over generic ones (and\n+ *  precedence between generic ones is not defined).\n+ *  </li>\n+ * <li>Ability to define a single generic base serializer for all Enum\n+ *   types (precedence below specific serializer mapping)\n+ *  </li>\n+ *</ul>\n+ *<p>\n+ * Note: as of version 1.7, this class is not as useful as it used to\n+ * be, due to addition of \"modules\", which allow simpler addition\n+ * of custom serializers and deserializers. In fact, use of module system\n+ * is recommended even when not exposing serializers or deserializers\n+ * as a pluggable library (just using them locally).\n+ */\n+public class CustomSerializerFactory\n+    extends BeanSerializerFactory\n+{\n+    /*\n+    /**********************************************************\n+    /* Configuration, direct/special mappings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Direct mappings that are only used for exact class type\n+     * matches, but not for sub-class checks.\n+     */\n+    protected HashMap<ClassKey,JsonSerializer<?>> _directClassMappings = null;\n+\n+    /**\n+     * And for Enum handling we may specify a single default\n+     * serializer to use, regardless of actual enumeration.\n+     * Usually used to provide \"toString - serializer\".\n+     */\n+    protected JsonSerializer<?> _enumSerializerOverride;\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, generic (interface, super-class) mappings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * And then class-based mappings that are used both for exact and\n+     * sub-class matches.\n+     */\n+    protected HashMap<ClassKey,JsonSerializer<?>> _transitiveClassMappings = null;\n+\n+    /**\n+     * And finally interface-based matches.\n+     */\n+    protected HashMap<ClassKey,JsonSerializer<?>> _interfaceMappings = null;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle, constructors\n+    /**********************************************************\n+     */\n+\n+    public CustomSerializerFactory() {\n+        this(null);\n+    }\n+\n+    public CustomSerializerFactory(Config config) {\n+        super(config);\n+    }\n+    \n+    @Override\n+    public SerializerFactory withConfig(Config config)\n+    {\n+        /* 22-Nov-2010, tatu: As with BeanSerializerFactory, must ensure type won't change\n+         *   with this method, so:\n+         */\n+        if (getClass() != CustomSerializerFactory.class) {\n+            throw new IllegalStateException(\"Subtype of CustomSerializerFactory (\"+getClass().getName()\n+                    +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \"\n+                    +\"additional serializer definitions\");\n+        }\n+        return new CustomSerializerFactory(config);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration: type-to-serializer mappings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method used to add a generic (transitive) mapping from specified\n+     * class or its sub-classes into a serializer.\n+     * When resolving a type into a serializer, explicit class is checked\n+     * first, then immediate super-class, and so forth along inheritance\n+     * chain. But if this fails, implemented interfaces are checked;\n+     * ordering is done such that first interfaces implemented by\n+     * the exact type are checked (in order returned by\n+     * {@link Class#getInterfaces}), then super-type's and so forth.\n+     *<p>\n+     * Note that adding generic mappings may lead to problems with\n+     * sub-classing: if sub-classes add new properties, these may not\n+     * get properly serialized.\n+     *\n+     * @param type Class for which specified serializer is to be\n+     *   used. May be more specific type than what serializer indicates,\n+     *   but must be compatible (same or sub-class)\n+     */\n+    public <T> void addGenericMapping(Class<? extends T> type, JsonSerializer<T> ser)\n+    {\n+        // Interface to match?\n+        ClassKey key = new ClassKey(type);\n+        if (type.isInterface()) {\n+            if (_interfaceMappings == null) {\n+                _interfaceMappings = new HashMap<ClassKey,JsonSerializer<?>>();\n+            }\n+            _interfaceMappings.put(key, ser);\n+        } else { // nope, class:\n+            if (_transitiveClassMappings == null) {\n+                _transitiveClassMappings = new HashMap<ClassKey,JsonSerializer<?>>();\n+            }\n+            _transitiveClassMappings.put(key, ser);\n+        }\n+    }\n+\n+    /**\n+     * Method used to add a mapping from specific type -- and only that\n+     * type -- to specified serializer. This means that binding is not\n+     * used for sub-types. It also means that no such mappings are to\n+     * be defined for abstract classes or interfaces: and if an attempt\n+     * is made, {@link IllegalArgumentException} will be thrown to\n+     * indicate caller error.\n+     *\n+     * @param forClass Class for which specified serializer is to be\n+     *   used. May be more specific type than what serializer indicates,\n+     *   but must be compatible (same or sub-class)\n+     */\n+    public <T> void addSpecificMapping(Class<? extends T> forClass, JsonSerializer<T> ser)\n+    {\n+        ClassKey key = new ClassKey(forClass);\n+\n+        /* First, let's ensure it's not an interface or abstract class:\n+         * as those can not be instantiated, such mappings would never\n+         * get used.\n+         */\n+        if (forClass.isInterface()) {\n+            throw new IllegalArgumentException(\"Can not add specific mapping for an interface (\"+forClass.getName()+\")\");\n+        }\n+        if (Modifier.isAbstract(forClass.getModifiers())) {\n+            throw new IllegalArgumentException(\"Can not add specific mapping for an abstract class (\"+forClass.getName()+\")\");\n+        }\n+\n+        if (_directClassMappings == null) {\n+            _directClassMappings = new HashMap<ClassKey,JsonSerializer<?>>();\n+        }\n+        _directClassMappings.put(key, ser);\n+    }\n+\n+    /**\n+     * Method that can be used to force specified serializer to be used for\n+     * serializing all Enum instances. This is most commonly used to specify\n+     * serializers that call either <code>enum.toString()</code>, or modify\n+     * value returned by <code>enum.name()</code> (such as upper- or\n+     * lower-casing it).\n+     *<p>\n+     * Note: this serializer has lower precedence than that of specific\n+     * types; so if a specific serializer is assigned to an Enum type,\n+     * this serializer will NOT be used. It has higher precedence than\n+     * generic mappings have however.\n+     */\n+    public void setEnumSerializer(JsonSerializer<?> enumSer)\n+    {\n+        _enumSerializerOverride = enumSer;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonSerializerFactory impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")    \n+    public JsonSerializer<Object> createSerializer(SerializationConfig config, JavaType type,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<?> ser = findCustomSerializer(type.getRawClass(), config);\n+        if (ser != null) {\n+            return (JsonSerializer<Object>) ser;\n+        }\n+        return super.createSerializer(config, type, property);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    protected JsonSerializer<?> findCustomSerializer(Class<?> type, SerializationConfig config)\n+    {\n+        JsonSerializer<?> ser = null;\n+        ClassKey key = new ClassKey(type);\n+\n+        // First: exact matches\n+        if (_directClassMappings != null) {\n+            ser = _directClassMappings.get(key);\n+            if (ser != null) {\n+                return ser;\n+            }\n+        }\n+\n+        // No match? Perhaps we can use the enum serializer?\n+        if (type.isEnum()) {\n+            if (_enumSerializerOverride != null) {\n+                return _enumSerializerOverride;\n+            }\n+        }\n+\n+        // Still no match? How about more generic ones?\n+        // Mappings for super-classes?\n+        if (_transitiveClassMappings != null) {\n+            for (Class<?> curr = type; (curr != null); curr = curr.getSuperclass()) {\n+                key.reset(curr);\n+                ser = _transitiveClassMappings.get(key);\n+                if (ser != null) {\n+                    return ser;\n+                }\n+            }\n+        }\n+\n+        // And if still no match, how about interfaces?\n+        if (_interfaceMappings != null) {\n+            // as per [JACKSON-327], better check actual interface first too...\n+            key.reset(type);\n+            ser = _interfaceMappings.get(key);\n+            if (ser != null) {\n+                return ser;\n+            }\n+            for (Class<?> curr = type; (curr != null); curr = curr.getSuperclass()) {\n+                ser = _findInterfaceMapping(curr, key);\n+                if (ser != null) {\n+                    return ser;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected JsonSerializer<?> _findInterfaceMapping(Class<?> cls, ClassKey key)\n+    {\n+        for (Class<?> iface : cls.getInterfaces()) {\n+            key.reset(iface);\n+            JsonSerializer<?> ser = _interfaceMappings.get(key);\n+            if (ser != null) {\n+                return ser;\n+            }\n+            // [JACKSON-373] need to also check super-interfaces\n+            ser = _findInterfaceMapping(iface, key);\n+            if (ser != null) {\n+                return ser;\n+            }\n+        }\n+        return null;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/FilterProvider.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+/**\n+ * Interface for objects that providers instances of {@link BeanPropertyFilter}\n+ * that match given ids. A provider is configured to be used during serialization,\n+ * to find filter to used based on id specified by {@link com.fasterxml.jackson.databind.annotate.JsonFilter}\n+ * annotation on bean class.\n+ * \n+ * @since 1.7\n+ */\n+public abstract class FilterProvider\n+{\n+    /**\n+     * Lookup method used to find {@link BeanPropertyFilter} that has specified id.\n+     * Note that id is typically a {@link java.lang.String}, but is not necessarily\n+     * limited to that; that is, while standard components use String, custom\n+     * implementation can choose other kinds of keys.\n+     * \n+     * @return Filter registered with specified id, if one defined; null if\n+     *   none found.\n+     */\n+    public abstract BeanPropertyFilter findFilter(Object filterId);\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/FilteredBeanPropertyWriter.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Decorated {@link BeanPropertyWriter} that will filter out\n+ * properties that are not to be included in currently active\n+ * JsonView.\n+ *\n+ * @since 1.4\n+ */\n+public abstract class FilteredBeanPropertyWriter\n+{    \n+    public static BeanPropertyWriter constructViewBased(BeanPropertyWriter base, Class<?>[] viewsToIncludeIn)\n+    {\n+        if (viewsToIncludeIn.length == 1) {\n+            return new SingleView(base, viewsToIncludeIn[0]);\n+        }\n+        return new MultiView(base, viewsToIncludeIn);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Concrete sub-classes\n+    /**********************************************************\n+     */\n+\n+    private final static class SingleView\n+        extends BeanPropertyWriter\n+    {\n+        protected final BeanPropertyWriter _delegate;\n+\n+        protected final Class<?> _view;\n+        \n+        protected SingleView(BeanPropertyWriter delegate, Class<?> view)\n+        {\n+            super(delegate);\n+            _delegate = delegate;\n+            _view = view;\n+        }\n+        \n+        @Override\n+        public BeanPropertyWriter withSerializer(JsonSerializer<Object> ser) {\n+            return new SingleView(_delegate.withSerializer(ser), _view);\n+        }\n+        \n+        @Override\n+        public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+            throws Exception\n+        {\n+            Class<?> activeView = prov.getSerializationView();\n+            if (activeView == null || _view.isAssignableFrom(activeView)) {\n+                _delegate.serializeAsField(bean, jgen, prov);\n+            }\n+        }\n+    }\n+\n+    private final static class MultiView\n+        extends BeanPropertyWriter\n+    {\n+        protected final BeanPropertyWriter _delegate;\n+\n+        protected final Class<?>[] _views;\n+        \n+        protected MultiView(BeanPropertyWriter delegate, Class<?>[] views) {\n+            super(delegate);\n+            _delegate = delegate;\n+            _views = views;\n+        }\n+        \n+        @Override\n+        public BeanPropertyWriter withSerializer(JsonSerializer<Object> ser) {\n+            return new MultiView(_delegate.withSerializer(ser), _views);\n+        }\n+        \n+        @Override\n+        public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+            throws Exception\n+        {\n+            final Class<?> activeView = prov.getSerializationView();\n+            if (activeView != null) {\n+                int i = 0, len = _views.length;\n+                for (; i < len; ++i) {\n+                    if (_views[i].isAssignableFrom(activeView)) break;\n+                }\n+                // not included, bail out:\n+                if (i == len) {\n+                    return;\n+                }\n+            }\n+            _delegate.serializeAsField(bean, jgen, prov);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/JdkSerializers.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+/**\n+ * @deprecated Since 1.9 use {@link com.fasterxml.jackson.databind.ser.std.StdJdkSerializers}\n+ */\n+@Deprecated\n+public class JdkSerializers\n+    extends com.fasterxml.jackson.databind.ser.std.StdJdkSerializers\n+{\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JsonSerialize;\n+import com.fasterxml.jackson.databind.annotate.JsonSerialize.Inclusion;\n+import com.fasterxml.jackson.databind.introspect.*;\n+import com.fasterxml.jackson.databind.util.*;\n+\n+/**\n+ * Helper class for {@link BeanSerializerFactory} that is used to\n+ * construct {@link BeanPropertyWriter} instances. Can be sub-classed\n+ * to change behavior.\n+ */\n+public class PropertyBuilder\n+{\n+    final protected SerializationConfig _config;\n+    final protected BasicBeanDescription _beanDesc;\n+    final protected JsonSerialize.Inclusion _outputProps;\n+\n+    final protected AnnotationIntrospector _annotationIntrospector;\n+\n+    /**\n+     * If a property has serialization inclusion value of\n+     * {@link Inclusion#ALWAYS}, we need to know the default\n+     * value of the bean, to know if property value equals default\n+     * one.\n+     */\n+    protected Object _defaultBean;\n+\n+    public PropertyBuilder(SerializationConfig config, BasicBeanDescription beanDesc)\n+    {\n+        _config = config;\n+        _beanDesc = beanDesc;\n+        _outputProps = beanDesc.findSerializationInclusion(config.getSerializationInclusion());\n+        _annotationIntrospector = _config.getAnnotationIntrospector();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    public Annotations getClassAnnotations() {\n+        return _beanDesc.getClassAnnotations();\n+    }\n+    \n+    /**\n+     * @param contentTypeSer Optional explicit type information serializer\n+     *    to use for contained values (only used for properties that are\n+     *    of container type)\n+     */\n+    protected BeanPropertyWriter buildWriter(String name, JavaType declaredType,\n+            JsonSerializer<Object> ser,\n+            TypeSerializer typeSer, TypeSerializer contentTypeSer,\n+            AnnotatedMember am, boolean defaultUseStaticTyping)\n+    {\n+        Field f;\n+        Method m;\n+        if (am instanceof AnnotatedField) {\n+            m = null;\n+            f = ((AnnotatedField) am).getAnnotated();\n+        } else {\n+            m = ((AnnotatedMethod) am).getAnnotated();\n+            f = null;\n+        }\n+\n+        // do we have annotation that forces type to use (to declared type or its super type)?\n+        JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n+\n+        // Container types can have separate type serializers for content (value / element) type\n+        if (contentTypeSer != null) {\n+            /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n+             *    type information for contents. Should work well (for JAXB case); can be\n+             *    revisited if this causes problems.\n+             */\n+            if (serializationType == null) {\n+//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n+                serializationType = declaredType;\n+            }\n+            JavaType ct = serializationType.getContentType();\n+            /* 03-Sep-2010, tatu: This is somehow related to [JACKSON-356], but I don't completely\n+             *   yet understand how pieces fit together. Still, better be explicit than rely on\n+             *   NPE to indicate an issue...\n+             */\n+            if (ct == null) {\n+                throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n+                        +name+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n+            }\n+            serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n+            ct = serializationType.getContentType();\n+        }\n+        \n+        Object valueToSuppress = null;\n+        boolean suppressNulls = false;\n+\n+        JsonSerialize.Inclusion methodProps = _annotationIntrospector.findSerializationInclusion(am, _outputProps);\n+\n+        if (methodProps != null) {\n+            switch (methodProps) {\n+            case NON_DEFAULT:\n+                valueToSuppress = getDefaultValue(name, m, f);\n+                if (valueToSuppress == null) {\n+                    suppressNulls = true;\n+                } else {\n+                    // [JACKSON-531]: Allow comparison of arrays too...\n+                    if (valueToSuppress.getClass().isArray()) {\n+                        valueToSuppress = Comparators.getArrayComparator(valueToSuppress);\n+                    }\n+                }\n+                break;\n+            case NON_EMPTY:\n+                // always suppress nulls\n+                suppressNulls = true;\n+                // but possibly also 'empty' values:\n+                valueToSuppress = getEmptyValueChecker(name, declaredType);\n+                break;\n+            case NON_NULL:\n+                suppressNulls = true;\n+                // fall through\n+            case ALWAYS: // default\n+                // we may still want to suppress empty collections, as per [JACKSON-254]:\n+                if (declaredType.isContainerType()) {\n+                    valueToSuppress = getContainerValueChecker(name, declaredType);\n+                }\n+                break;\n+            }\n+        }\n+\n+        BeanPropertyWriter bpw = new BeanPropertyWriter(am, _beanDesc.getClassAnnotations(), name, declaredType,\n+                ser, typeSer, serializationType, m, f, suppressNulls, valueToSuppress);\n+        \n+        // [JACKSON-132]: Unwrapping\n+        Boolean unwrapped = _annotationIntrospector.shouldUnwrapProperty(am);\n+        if (unwrapped != null && unwrapped.booleanValue()) {\n+            bpw = bpw.unwrappingWriter();\n+        }\n+        return bpw;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods; annotation access\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will try to determine statically defined type of property\n+     * being serialized, based on annotations (for overrides), and alternatively\n+     * declared type (if static typing for serialization is enabled).\n+     * If neither can be used (no annotations, dynamic typing), returns null.\n+     */\n+    protected JavaType findSerializationType(Annotated a, boolean useStaticTyping, JavaType declaredType)\n+    {\n+        // [JACKSON-120]: Check to see if serialization type is fixed\n+        Class<?> serClass = _annotationIntrospector.findSerializationType(a);\n+        if (serClass != null) {\n+            // Must be a super type to be usable\n+            Class<?> rawDeclared = declaredType.getRawClass();\n+            if (serClass.isAssignableFrom(rawDeclared)) {\n+                declaredType = declaredType.widenBy(serClass);\n+            } else {\n+                /* 18-Nov-2010, tatu: Related to fixing [JACKSON-416], an issue with such\n+                 *   check is that for deserialization more specific type makes sense;\n+                 *   and for serialization more generic. But alas JAXB uses but a single\n+                 *   annotation to do both... Hence, we must just discard type, as long as\n+                 *   types are related\n+                 */\n+                if (!rawDeclared.isAssignableFrom(serClass)) {\n+                    throw new IllegalArgumentException(\"Illegal concrete-type annotation for method '\"+a.getName()+\"': class \"+serClass.getName()+\" not a super-type of (declared) class \"+rawDeclared.getName());\n+                }\n+                /* 03-Dec-2010, tatu: Actually, ugh, to resolve [JACKSON-415] may further relax this\n+                 *   and actually accept subtypes too for serialization. Bit dangerous in theory\n+                 *   but need to trust user here...\n+                 */\n+                declaredType = _config.constructSpecializedType(declaredType, serClass);\n+            }\n+            useStaticTyping = true;\n+        }\n+\n+        JavaType secondary = BeanSerializerFactory.modifySecondaryTypesByAnnotation(_config, a, declaredType);\n+        if (secondary != declaredType) {\n+            useStaticTyping = true;\n+            declaredType = secondary;\n+        }\n+        \n+        /* [JACKSON-114]: if using static typing, declared type is known\n+         * to be the type...\n+         */\n+        if (!useStaticTyping) {\n+            JsonSerialize.Typing typing = _annotationIntrospector.findSerializationTyping(a);\n+            if (typing != null) {\n+                useStaticTyping = (typing == JsonSerialize.Typing.STATIC);\n+            }\n+        }\n+        return useStaticTyping ? declaredType : null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for default value handling\n+    /**********************************************************\n+     */\n+    \n+    protected Object getDefaultBean()\n+    {\n+        if (_defaultBean == null) {\n+            /* If we can fix access rights, we should; otherwise non-public\n+             * classes or default constructor will prevent instantiation\n+             */\n+            _defaultBean = _beanDesc.instantiateBean(_config.isEnabled(SerializationConfig.Feature.CAN_OVERRIDE_ACCESS_MODIFIERS));\n+            if (_defaultBean == null) {\n+                Class<?> cls = _beanDesc.getClassInfo().getAnnotated();\n+                throw new IllegalArgumentException(\"Class \"+cls.getName()+\" has no default constructor; can not instantiate default bean value to support 'properties=JsonSerialize.Inclusion.NON_DEFAULT' annotation\");\n+            }\n+        }\n+        return _defaultBean;\n+    }\n+\n+    protected Object getDefaultValue(String name, Method m, Field f)\n+    {\n+        Object defaultBean = getDefaultBean();\n+        try {\n+            if (m != null) {\n+                return m.invoke(defaultBean);\n+            }\n+            return f.get(defaultBean);\n+        } catch (Exception e) {\n+            return _throwWrapped(e, name, defaultBean);\n+        }\n+    }\n+\n+    /**\n+     * Helper method called to see if we need a comparator Object to check if values\n+     * of a container (Collection, array) property should be suppressed.\n+     * This is usually\n+     * \n+     * @param propertyName Name of property to handle\n+     * @param propertyType Declared type of values of the property to handle\n+     * @return Object whose <code>equals()</code> method is called to check if given value\n+     *    is \"empty Collection\" value to suppress; or null if no such check should be done\n+     *    (declared type not Collection or array)\n+     * \n+     * @since 1.9\n+     */\n+    protected Object getContainerValueChecker(String propertyName, JavaType propertyType)\n+    {\n+        // currently we will only check for certain kinds of empty containers:\n+        if (!_config.isEnabled(SerializationConfig.Feature.WRITE_EMPTY_JSON_ARRAYS)) {\n+            if (propertyType.isArrayType()) {\n+                return new EmptyArrayChecker();\n+            }\n+            if (Collection.class.isAssignableFrom(propertyType.getRawClass())) {\n+                return new EmptyCollectionChecker();\n+            }\n+        }\n+        return null;\n+    }\n+\n+        \n+    /**\n+     * Helper method called to see if we need a comparator Object to check if values\n+     * of specified type are consider empty.\n+     * If type has such concept, will build a comparator; otherwise return null, and\n+     * in latter case, only null values are considered 'empty'.\n+     * \n+     * @param propertyName Name of property to handle\n+     * @param propertyType Declared type of values of the property to handle\n+     * @return Object whose <code>equals()</code> method is called to check if given value\n+     *    is \"empty Collection\" value to suppress; or null if no such check should be done\n+     *    (declared type not Collection or array)\n+     * \n+     * @since 1.9\n+     */\n+    protected Object getEmptyValueChecker(String propertyName, JavaType propertyType)\n+    {\n+        Class<?> rawType = propertyType.getRawClass();\n+        if (rawType == String.class) {\n+            return new EmptyStringChecker();\n+        }\n+        if (propertyType.isArrayType()) {\n+            return new EmptyArrayChecker();\n+        }\n+        if (Collection.class.isAssignableFrom(rawType)) {\n+            return new EmptyCollectionChecker();\n+        }\n+        if (Map.class.isAssignableFrom(rawType)) {\n+            return new EmptyMapChecker();\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for exception handling\n+    /**********************************************************\n+     */\n+    \n+    protected Object _throwWrapped(Exception e, String propName, Object defaultBean)\n+    {\n+        Throwable t = e;\n+        while (t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        if (t instanceof Error) throw (Error) t;\n+        if (t instanceof RuntimeException) throw (RuntimeException) t;\n+        throw new IllegalArgumentException(\"Failed to get property '\"+propName+\"' of default \"+defaultBean.getClass().getName()+\" instance\");\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper object used to check if given Collection object is null or empty\n+     * \n+     * @since 1.9\n+     */\n+    public static class EmptyCollectionChecker\n+    {\n+        @Override public boolean equals(Object other) {\n+            return (other == null) ||  ((Collection<?>) other).size() == 0;\n+        }\n+    }\n+\n+    /**\n+     * Helper object used to check if given Map object is null or empty\n+     * \n+     * @since 1.9\n+     */\n+    public static class EmptyMapChecker\n+    {\n+        @Override public boolean equals(Object other) {\n+            return (other == null) ||  ((Map<?,?>) other).size() == 0;\n+        }\n+    }\n+\n+    /**\n+     * Helper object used to check if given array object is null or empty\n+     * \n+     * @since 1.9\n+     */\n+    public static class EmptyArrayChecker\n+    {\n+        @Override\n+        public boolean equals(Object other) {\n+            return (other == null) || Array.getLength(other) == 0;\n+        }\n+     }\n+\n+    /**\n+     * Helper object used to check if given String object is null or empty\n+     * \n+     * @since 1.9\n+     */\n+    public static class EmptyStringChecker\n+    {\n+        @Override\n+        public boolean equals(Object other) {\n+            return (other == null) || ((String) other).length() == 0;\n+        }\n+     }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/ScalarSerializerBase.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+/**\n+ * @deprecated Since 1.9 use {@link  com.fasterxml.jackson.databind.ser.std.SerializerBase} instead.\n+ */\n+@Deprecated\n+public abstract class ScalarSerializerBase<T>\n+    extends com.fasterxml.jackson.databind.ser.std.SerializerBase<T>\n+{\n+    protected ScalarSerializerBase(Class<T> t) {\n+        super(t);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected ScalarSerializerBase(Class<?> t, boolean dummy) {\n+        super((Class<T>) t);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/SerializerBase.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+/**\n+ * @deprecated Since 1.9 use {@link com.fasterxml.jackson.databind.ser.std.SerializerBase}\n+ */\n+@Deprecated\n+public abstract class SerializerBase<T>\n+    extends com.fasterxml.jackson.databind.ser.std.SerializerBase<T>\n+{\n+    protected SerializerBase(Class<T> t) {\n+        super(t);\n+    }\n+\n+    protected SerializerBase(JavaType type) {\n+        super(type);\n+    }\n+    \n+    protected SerializerBase(Class<?> t, boolean dummy) {\n+        super(t, dummy);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdKeySerializer.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+/**\n+ * @deprecated Since 1.9 use {@link com.fasterxml.jackson.databind.ser.std.StdKeySerializer} instead\n+ */\n+@Deprecated\n+public final class StdKeySerializer\n+    extends com.fasterxml.jackson.databind.ser.std.StdKeySerializer\n+{\n+    final static StdKeySerializer instace = new StdKeySerializer();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.IOException;\n+import java.text.DateFormat;\n+import java.util.Date;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.impl.FailingSerializer;\n+import com.fasterxml.jackson.databind.ser.impl.ReadOnlyClassToSerializerMap;\n+import com.fasterxml.jackson.databind.ser.impl.SerializerCache;\n+import com.fasterxml.jackson.databind.ser.impl.UnknownSerializer;\n+import com.fasterxml.jackson.databind.ser.std.NullSerializer;\n+import com.fasterxml.jackson.databind.ser.std.StdKeySerializer;\n+import com.fasterxml.jackson.databind.ser.std.StdKeySerializers;\n+import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.RootNameLookup;\n+\n+import org.codehaus.jackson.node.ObjectNode;\n+import org.codehaus.jackson.schema.JsonSchema;\n+import org.codehaus.jackson.schema.SchemaAware;\n+\n+\n+/**\n+ * Default {@link SerializerProvider} implementation. Handles\n+ * caching aspects of serializer handling; all construction details\n+ * are delegated to {@link SerializerFactory} instance.\n+ *<p>\n+ * One note about implementation: the main instance constructed will\n+ * be so-called \"blueprint\" object, and will NOT be used during actual\n+ * serialization. Rather, an \"instance\" instance is created so that\n+ * state can be carried along, as well as to avoid synchronization\n+ * during serializer access. Because of this, if sub-classing, one\n+ * must override method {@link #createInstance}: if this is not done,\n+ * an exception will get thrown as base class verifies that the\n+ * instance has same class as the blueprint\n+ * (<code>instance.getClass() == blueprint.getClass()</code>).\n+ * Check is done to prevent weird bugs that would otherwise occur.\n+ *<p>\n+ * Starting with version 1.5, provider is also responsible for\n+ * some parts of type serialization; specifically for locating\n+ * proper type serializers to use for types.\n+ */\n+public class StdSerializerProvider\n+    extends SerializerProvider\n+{\n+    /**\n+     * Setting for determining whether mappings for \"unknown classes\" should be\n+     * cached for faster resolution. Usually this isn't needed, but maybe it\n+     * is in some cases?\n+     */\n+    final static boolean CACHE_UNKNOWN_MAPPINGS = false;\n+\n+    public final static JsonSerializer<Object> DEFAULT_NULL_KEY_SERIALIZER =\n+        new FailingSerializer(\"Null key for a Map not allowed in JSON (use a converting NullKeySerializer?)\");\n+\n+    /**\n+     * @deprecated Since 1.9, use {@link StdKeySerializers} instead\n+     */\n+    @Deprecated\n+    public final static JsonSerializer<Object> DEFAULT_KEY_SERIALIZER = new StdKeySerializer();\n+\n+    public final static JsonSerializer<Object> DEFAULT_UNKNOWN_SERIALIZER = new UnknownSerializer();\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration, factories\n+    /**********************************************************\n+     */\n+\n+    final protected SerializerFactory _serializerFactory;\n+\n+    /**\n+     * Cache for doing type-to-value-serializer lookups.\n+     */\n+    final protected SerializerCache _serializerCache;\n+\n+    /**\n+     * Helper object for keeping track of introspected root names\n+     */\n+    final protected RootNameLookup _rootNames;\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration, specialized serializers\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Serializer that gets called for values of types for which no\n+     * serializers can be constructed.\n+     *<p>\n+     * The default serializer will simply thrown an exception; a possible\n+     * alternative that can be used would be\n+     * {@link ToStringSerializer}.\n+     */\n+    protected JsonSerializer<Object> _unknownTypeSerializer = DEFAULT_UNKNOWN_SERIALIZER;\n+\n+    /**\n+     * Serializer used to output non-null keys of Maps (which will get\n+     * output as JSON Objects), if not null; if null, us the standard\n+     * default key serializer.\n+     */\n+    protected JsonSerializer<Object> _keySerializer;\n+\n+    /**\n+     * Serializer used to output a null value. Default implementation\n+     * writes nulls using {@link JsonGenerator#writeNull}.\n+     */\n+    protected JsonSerializer<Object> _nullValueSerializer = NullSerializer.instance;\n+\n+    /**\n+     * Serializer used to (try to) output a null key, due to an entry of\n+     * {@link java.util.Map} having null key.\n+     * The default implementation will throw an exception if this happens;\n+     * alternative implementation (like one that would write an Empty String)\n+     * can be defined.\n+     */\n+    protected JsonSerializer<Object> _nullKeySerializer = DEFAULT_NULL_KEY_SERIALIZER;\n+\n+    /*\n+    /**********************************************************\n+    /* State, for non-blueprint instances\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * For fast lookups, we will have a local non-shared read-only\n+     * map that contains serializers previously fetched.\n+     */\n+    protected final ReadOnlyClassToSerializerMap _knownSerializers;\n+\n+    /**\n+     * Lazily acquired and instantiated formatter object: initialized\n+     * first time it is needed, reused afterwards. Used via instances\n+     * (not blueprints), so that access need not be thread-safe.\n+     */\n+    protected DateFormat _dateFormat;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor for creating master (or \"blue-print\") provider object,\n+     * which is only used as the template for constructing per-binding\n+     * instances.\n+     */\n+    public StdSerializerProvider()\n+    {\n+        super(null);\n+        _serializerFactory = null;\n+        _serializerCache = new SerializerCache();\n+        // Blueprints doesn't have access to any serializers...\n+        _knownSerializers = null;\n+        _rootNames = new RootNameLookup();\n+    }\n+\n+    /**\n+     * \"Copy-constructor\", used from {@link #createInstance} (or by\n+     * sub-classes)\n+     *\n+     * @param src Blueprint object used as the baseline for this instance\n+     */\n+    protected StdSerializerProvider(SerializationConfig config,\n+            StdSerializerProvider src, SerializerFactory f)\n+    {\n+        super(config);\n+        if (config == null) {\n+            throw new NullPointerException();\n+        }\n+        _serializerFactory = f;\n+\n+        _serializerCache = src._serializerCache;\n+        _unknownTypeSerializer = src._unknownTypeSerializer;\n+        _keySerializer = src._keySerializer;\n+        _nullValueSerializer = src._nullValueSerializer;\n+        _nullKeySerializer = src._nullKeySerializer;\n+        _rootNames = src._rootNames;\n+\n+        /* Non-blueprint instances do have a read-only map; one that doesn't\n+         * need synchronization for lookups.\n+         */\n+        _knownSerializers = _serializerCache.getReadOnlyLookupMap();\n+    }\n+\n+    /**\n+     * Overridable method, used to create a non-blueprint instances from the blueprint.\n+     * This is needed to retain state during serialization.\n+     */\n+    protected StdSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf)\n+    {\n+        return new StdSerializerProvider(config, this, jsf);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void setDefaultKeySerializer(JsonSerializer<Object> ks)\n+    {\n+        if (ks == null) {\n+            throw new IllegalArgumentException(\"Can not pass null JsonSerializer\");\n+        }\n+        _keySerializer = ks;\n+    }\n+\n+    @Override\n+    public void setNullValueSerializer(JsonSerializer<Object> nvs)\n+    {\n+        if (nvs == null) {\n+            throw new IllegalArgumentException(\"Can not pass null JsonSerializer\");\n+        }\n+        _nullValueSerializer = nvs;\n+    }\n+\n+    @Override\n+    public void setNullKeySerializer(JsonSerializer<Object> nks)\n+    {\n+        if (nks == null) {\n+            throw new IllegalArgumentException(\"Can not pass null JsonSerializer\");\n+        }\n+        _nullKeySerializer = nks;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Methods to be called by ObjectMapper\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void serializeValue(SerializationConfig config,\n+            JsonGenerator jgen, Object value, SerializerFactory jsf)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (jsf == null) {\n+            throw new IllegalArgumentException(\"Can not pass null serializerFactory\");\n+        }\n+\n+        /* First: we need a separate instance, which will hold a copy of the\n+         * non-shared (\"local\") read-only lookup Map for fast\n+         * class-to-serializer lookup\n+         */\n+        StdSerializerProvider inst = createInstance(config, jsf);\n+        // sanity check to avoid weird errors; to ensure sub-classes do override createInstance\n+        if (inst.getClass() != getClass()) {\n+            throw new IllegalStateException(\"Broken serializer provider: createInstance returned instance of type \"+inst.getClass()+\"; blueprint of type \"+getClass());\n+        }\n+        // And then we can do actual serialization, through the instance\n+        inst._serializeValue(jgen, value);\n+    }\n+\n+    @Override\n+    public final void serializeValue(SerializationConfig config, JsonGenerator jgen,\n+            Object value, JavaType rootType, SerializerFactory jsf)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (jsf == null) {\n+            throw new IllegalArgumentException(\"Can not pass null serializerFactory\");\n+        }\n+        StdSerializerProvider inst = createInstance(config, jsf);\n+        if (inst.getClass() != getClass()) {\n+            throw new IllegalStateException(\"Broken serializer provider: createInstance returned instance of type \"+inst.getClass()+\"; blueprint of type \"+getClass());\n+        }\n+        inst._serializeValue(jgen, value, rootType);\n+    }\n+    \n+    @Override\n+    public JsonSchema generateJsonSchema(Class<?> type, SerializationConfig config, SerializerFactory jsf)\n+            throws JsonMappingException\n+    {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"A class must be provided\");\n+        }\n+\n+        /* First: we need a separate instance, which will hold a copy of the\n+         * non-shared (\"local\") read-only lookup Map for fast\n+         * class-to-serializer lookup\n+         */\n+        StdSerializerProvider inst = createInstance(config, jsf);\n+        // sanity check to avoid weird errors; to ensure sub-classes do override createInstance\n+        if (inst.getClass() != getClass()) {\n+            throw new IllegalStateException(\"Broken serializer provider: createInstance returned instance of type \"+inst.getClass()+\"; blueprint of type \"+getClass());\n+        }\n+        /* no need for embedded type information for JSON schema generation (all\n+         * type information it needs is accessible via \"untyped\" serializer)\n+         */\n+        JsonSerializer<Object> ser = inst.findValueSerializer(type, null);\n+        JsonNode schemaNode = (ser instanceof SchemaAware) ?\n+                ((SchemaAware) ser).getSchema(inst, null) : \n+                JsonSchema.getDefaultSchemaNode();\n+        if (!(schemaNode instanceof ObjectNode)) {\n+            throw new IllegalArgumentException(\"Class \" + type.getName() +\n+                    \" would not be serialized as a JSON object and therefore has no schema\");\n+        }\n+\n+        return new JsonSchema((ObjectNode) schemaNode);\n+    }\n+\n+    @Override\n+    public boolean hasSerializerFor(SerializationConfig config,\n+                                    Class<?> cls, SerializerFactory jsf)\n+    {\n+        return createInstance(config, jsf)._findExplicitUntypedSerializer(cls, null) != null;\n+    }\n+    \n+    @Override\n+    public int cachedSerializersCount() {\n+        return _serializerCache.size();\n+    }\n+\n+    @Override\n+    public void flushCachedSerializers() {\n+        _serializerCache.flush();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Abstract method implementations, value/type serializers\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonSerializer<Object> findValueSerializer(Class<?> valueType,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // Fast lookup from local lookup thingy works?\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            // If not, maybe shared map already has it?\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                // ... possibly as fully typed?\n+                ser = _serializerCache.untypedValueSerializer(_config.constructType(valueType));\n+                if (ser == null) {\n+                    // If neither, must create\n+                    ser = _createAndCacheUntypedSerializer(valueType, property);\n+                    // Not found? Must use the unknown type serializer\n+                    /* Couldn't create? Need to return the fallback serializer, which\n+                     * most likely will report an error: but one question is whether\n+                     * we should cache it?\n+                     */\n+                    if (ser == null) {\n+                        ser = getUnknownTypeSerializer(valueType);\n+                        // Should this be added to lookups?\n+                        if (CACHE_UNKNOWN_MAPPINGS) {\n+                            _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                        }\n+                        return ser;\n+                    }\n+                }\n+            }\n+        }            \n+        return _handleContextualResolvable(ser, property);\n+    }\n+\n+    /**\n+     * This variant was added in 1.5, to allow for efficient access using full\n+     * structured types, not just classes. This is necessary for accurate\n+     * handling of external type information, to handle polymorphic types.\n+     */    \n+    @Override\n+    public JsonSerializer<Object> findValueSerializer(JavaType valueType, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // Fast lookup from local lookup thingy works?\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(valueType);\n+        if (ser == null) {\n+            // If not, maybe shared map already has it?\n+            ser = _serializerCache.untypedValueSerializer(valueType);\n+            if (ser == null) {\n+                // If neither, must create\n+                ser = _createAndCacheUntypedSerializer(valueType, property);\n+                // Not found? Must use the unknown type serializer\n+                /* Couldn't create? Need to return the fallback serializer, which\n+                 * most likely will report an error: but one question is whether\n+                 * we should cache it?\n+                 */\n+                if (ser == null) {\n+                    ser = getUnknownTypeSerializer(valueType.getRawClass());\n+                    // Should this be added to lookups?\n+                    if (CACHE_UNKNOWN_MAPPINGS) {\n+                        _serializerCache.addAndResolveNonTypedSerializer(valueType, ser, this);\n+                    }\n+                    return ser;\n+                }\n+            }\n+        }\n+        return _handleContextualResolvable(ser, property);\n+    }\n+    \n+    /**\n+     * @param cache Whether resulting value serializer should be cached or not; this is just\n+     *    a hint \n+     */\n+    @Override\n+    public JsonSerializer<Object> findTypedValueSerializer(Class<?> valueType, boolean cache,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // Two-phase lookups; local non-shared cache, then shared:\n+        JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType);\n+        if (ser != null) {\n+            return ser;\n+        }\n+        // If not, maybe shared map already has it?\n+        ser = _serializerCache.typedValueSerializer(valueType);\n+        if (ser != null) {\n+            return ser;\n+        }\n+\n+        // Well, let's just compose from pieces:\n+        ser = findValueSerializer(valueType, property);\n+        TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config,\n+                _config.constructType(valueType), property);\n+        if (typeSer != null) {\n+            ser = new WrappedSerializer(typeSer, ser);\n+        }\n+        if (cache) {\n+            _serializerCache.addTypedSerializer(valueType, ser);\n+        }\n+        return ser;\n+    }\n+    \n+    @Override\n+    public JsonSerializer<Object> findTypedValueSerializer(JavaType valueType, boolean cache,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        // Two-phase lookups; local non-shared cache, then shared:\n+        JsonSerializer<Object> ser = _knownSerializers.typedValueSerializer(valueType);\n+        if (ser != null) {\n+            return ser;\n+        }\n+        // If not, maybe shared map already has it?\n+        ser = _serializerCache.typedValueSerializer(valueType);\n+        if (ser != null) {\n+            return ser;\n+        }\n+\n+        // Well, let's just compose from pieces:\n+        ser = findValueSerializer(valueType, property);\n+        TypeSerializer typeSer = _serializerFactory.createTypeSerializer(_config, valueType, property);\n+        if (typeSer != null) {\n+            ser = new WrappedSerializer(typeSer, ser);\n+        }\n+        if (cache) {\n+            _serializerCache.addTypedSerializer(valueType, ser);\n+        }\n+        return ser;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Abstract method implementations, other serializers\n+    /**********************************************************\n+     */\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public JsonSerializer<Object> findKeySerializer(JavaType keyType, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<Object> ser = _serializerFactory.createKeySerializer(_config, keyType, property);\n+\n+        // First things first: maybe there are registered custom implementations\n+        // if not, use default one:\n+        if (ser == null) {\n+            if (_keySerializer == null) {\n+                ser = StdKeySerializers.getStdKeySerializer(keyType);\n+            } else {\n+                ser = _keySerializer;\n+            }\n+        }\n+        // 25-Feb-2011, tatu: As per [JACKSON-519], need to ensure contextuality works here, too\n+        if (ser instanceof ContextualSerializer<?>) {\n+            ContextualSerializer<?> contextual = (ContextualSerializer<?>) ser;\n+            ser = (JsonSerializer<Object>)contextual.createContextual(_config, property);\n+        }\n+        return ser;\n+    }\n+\n+    @Override\n+    public JsonSerializer<Object> getNullKeySerializer() {\n+        return _nullKeySerializer;\n+    }\n+\n+    @Override\n+    public JsonSerializer<Object> getNullValueSerializer() {\n+        return _nullValueSerializer;\n+    }\n+\n+    @Override\n+    public JsonSerializer<Object> getUnknownTypeSerializer(Class<?> unknownType) {\n+        return _unknownTypeSerializer;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Abstract method impls, convenience methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @param timestamp Millisecond timestamp that defines date, if available;\n+     */\n+    @Override\n+    public final void defaultSerializeDateValue(long timestamp, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        // [JACKSON-87]: Support both numeric timestamps and textual\n+        if (isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+            jgen.writeNumber(timestamp);\n+        } else {\n+            if (_dateFormat == null) {\n+                // must create a clone since Formats are not thread-safe:\n+                _dateFormat = (DateFormat)_config.getDateFormat().clone();\n+            }\n+            jgen.writeString(_dateFormat.format(new Date(timestamp)));\n+        }\n+    }\n+\n+    @Override\n+    public final void defaultSerializeDateValue(Date date, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        // [JACKSON-87]: Support both numeric timestamps and textual\n+        if (isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)) {\n+            jgen.writeNumber(date.getTime());\n+        } else {\n+            if (_dateFormat == null) {\n+                DateFormat blueprint = _config.getDateFormat();\n+                // must create a clone since Formats are not thread-safe:\n+                _dateFormat = (DateFormat)blueprint.clone();\n+            }\n+            jgen.writeString(_dateFormat.format(date));\n+        }\n+    }\n+\n+    @Override\n+    public void defaultSerializeDateKey(long timestamp, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (isEnabled(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n+            jgen.writeFieldName(String.valueOf(timestamp));\n+        } else {\n+            if (_dateFormat == null) {\n+                DateFormat blueprint = _config.getDateFormat();\n+                // must create a clone since Formats are not thread-safe:\n+                _dateFormat = (DateFormat)blueprint.clone();\n+            }\n+            jgen.writeFieldName(_dateFormat.format(new Date(timestamp)));\n+        }\n+    }\n+\n+    @Override\n+    public void defaultSerializeDateKey(Date date, JsonGenerator jgen)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (isEnabled(SerializationConfig.Feature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n+            jgen.writeFieldName(String.valueOf(date.getTime()));\n+        } else {\n+            if (_dateFormat == null) {\n+                DateFormat blueprint = _config.getDateFormat();\n+                // must create a clone since Formats are not thread-safe:\n+                _dateFormat = (DateFormat)blueprint.clone();\n+            }\n+            jgen.writeFieldName(_dateFormat.format(date));\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper methods: can be overridden by sub-classes\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called on the actual non-blueprint provider instance object,\n+     * to kick off the serialization.\n+     */\n+    protected  void _serializeValue(JsonGenerator jgen, Object value)\n+        throws IOException, JsonProcessingException\n+    {\n+        JsonSerializer<Object> ser;\n+        boolean wrap;\n+\n+        if (value == null) {\n+            ser = getNullValueSerializer();\n+            wrap = false; // no name to use for wrapping; can't do!\n+        } else {\n+            Class<?> cls = value.getClass();\n+            // true, since we do want to cache root-level typed serializers (ditto for null property)\n+            ser = findTypedValueSerializer(cls, true, null);\n+            // [JACKSON-163]\n+            wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+            if (wrap) {\n+                jgen.writeStartObject();\n+                jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n+            }\n+        }\n+        try {\n+            ser.serialize(value, jgen, this);\n+            if (wrap) {\n+                jgen.writeEndObject();\n+            }\n+        } catch (IOException ioe) {\n+            /* As per [JACKSON-99], should not wrap IOException or its\n+             * sub-classes (like JsonProcessingException, JsonMappingException)\n+             */\n+            throw ioe;\n+        } catch (Exception e) {\n+            // but others are wrapped\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+    }\n+\n+    /**\n+     * Method called on the actual non-blueprint provider instance object,\n+     * to kick off the serialization, when root type is explicitly\n+     * specified and not determined from value.\n+     */\n+    protected  void _serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n+        throws IOException, JsonProcessingException\n+    {\n+        // [JACKSON-163]\n+        boolean wrap;\n+\n+        JsonSerializer<Object> ser;\n+        if (value == null) {\n+            ser = getNullValueSerializer();\n+            wrap = false;\n+        } else {\n+            // Let's ensure types are compatible at this point\n+            if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n+                _reportIncompatibleRootType(value, rootType);\n+            }\n+            // root value, not reached via property:\n+            ser = findTypedValueSerializer(rootType, true, null);\n+            // [JACKSON-163]\n+            wrap = _config.isEnabled(SerializationConfig.Feature.WRAP_ROOT_VALUE);\n+            if (wrap) {\n+                jgen.writeStartObject();\n+                jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n+            }\n+        }\n+        try {\n+            ser.serialize(value, jgen, this);\n+            if (wrap) {\n+                jgen.writeEndObject();\n+            }\n+        } catch (IOException ioe) { // no wrapping for IO (and derived)\n+            throw ioe;\n+        } catch (Exception e) { // but others do need to be, to get path etc\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+    }\n+\n+    protected void _reportIncompatibleRootType(Object value, JavaType rootType)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* 07-Jan-2010, tatu: As per [JACKSON-456] better handle distinction between wrapper types,\n+         *    primitives\n+         */\n+        if (rootType.isPrimitive()) {\n+            Class<?> wrapperType = ClassUtil.wrapperType(rootType.getRawClass());\n+            // If it's just difference between wrapper, primitive, let it slide\n+            if (wrapperType.isAssignableFrom(value.getClass())) {\n+                return;\n+            }\n+        }\n+        throw new JsonMappingException(\"Incompatible types: declared root type (\"+rootType+\") vs \"\n+                +value.getClass().getName());\n+    }\n+    \n+    /**\n+     * Method that will try to find a serializer, either from cache\n+     * or by constructing one; but will not return an \"unknown\" serializer\n+     * if this can not be done but rather returns null.\n+     *\n+     * @return Serializer if one can be found, null if not.\n+     */\n+    protected JsonSerializer<Object> _findExplicitUntypedSerializer(Class<?> runtimeType,\n+            BeanProperty property)\n+    {        \n+        // Fast lookup from local lookup thingy works?\n+        JsonSerializer<Object> ser = _knownSerializers.untypedValueSerializer(runtimeType);\n+        if (ser != null) {\n+            return ser;\n+        }\n+        // If not, maybe shared map already has it?\n+        ser = _serializerCache.untypedValueSerializer(runtimeType);\n+        if (ser != null) {\n+            return ser;\n+        }\n+        try {\n+            return _createAndCacheUntypedSerializer(runtimeType, property);\n+        } catch (Exception e) {\n+            return null;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Low-level methods for actually constructing and initializing\n+    /* serializers\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that will try to construct a value serializer; and if\n+     * one is successfully created, cache it for reuse.\n+     */\n+    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(Class<?> type,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {        \n+        JsonSerializer<Object> ser;\n+        try {\n+            ser = _createUntypedSerializer(_config.constructType(type), property);\n+        } catch (IllegalArgumentException iae) {\n+            /* We better only expose checked exceptions, since those\n+             * are what caller is expected to handle\n+             */\n+            throw new JsonMappingException(iae.getMessage(), null, iae);\n+        }\n+\n+        if (ser != null) {\n+            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);\n+        }\n+        return ser;\n+    }\n+\n+    /**\n+     * @since 1.5\n+]     */\n+    protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {        \n+        JsonSerializer<Object> ser;\n+        try {\n+            ser = _createUntypedSerializer(type, property);\n+        } catch (IllegalArgumentException iae) {\n+            /* We better only expose checked exceptions, since those\n+             * are what caller is expected to handle\n+             */\n+            throw new JsonMappingException(iae.getMessage(), null, iae);\n+        }\n+    \n+        if (ser != null) {\n+            _serializerCache.addAndResolveNonTypedSerializer(type, ser, this);\n+        }\n+        return ser;\n+    }\n+\n+    protected JsonSerializer<Object> _createUntypedSerializer(JavaType type,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        /* 10-Dec-2008, tatu: Is there a possibility of infinite loops\n+         *   here? Shouldn't be, given that we do not pass back-reference\n+         *   to this provider. But if there is, we'd need to sync calls,\n+         *   and keep track of creation chain to look for loops -- fairly\n+         *   easy to do, but won't add yet since it seems unnecessary.\n+         */\n+        return (JsonSerializer<Object>)_serializerFactory.createSerializer(_config, type, property);\n+    }\n+\n+    /**\n+     * @since 1.8.5\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonSerializer<Object> _handleContextualResolvable(JsonSerializer<Object> ser,\n+            BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        if (!(ser instanceof ContextualSerializer<?>)) {\n+            return ser;\n+        }\n+        JsonSerializer<Object> ctxtSer = ((ContextualSerializer<Object>) ser).createContextual(_config, property);\n+        if (ctxtSer != ser) {\n+            // need to re-resolve?\n+            if (ctxtSer instanceof ResolvableSerializer) {\n+                ((ResolvableSerializer) ctxtSer).resolve(this);\n+            }\n+            ser = ctxtSer;\n+        }\n+        return ser;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /*  Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Simple serializer that will call configured type serializer, passing\n+     * in configured data serializer, and exposing it all as a simple\n+     * serializer.\n+     */\n+    private final static class WrappedSerializer\n+        extends JsonSerializer<Object>\n+    {\n+        final protected TypeSerializer _typeSerializer;\n+        final protected JsonSerializer<Object> _serializer;\n+\n+        public WrappedSerializer(TypeSerializer typeSer, JsonSerializer<Object> ser)\n+        {\n+            super();\n+            _typeSerializer = typeSer;\n+            _serializer = ser;\n+        }\n+\n+        @Override\n+        public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonProcessingException\n+        {\n+            _serializer.serializeWithType(value, jgen, provider, _typeSerializer);\n+        }\n+\n+        @Override\n+        public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider,\n+                TypeSerializer typeSer)\n+            throws IOException, JsonProcessingException\n+        {\n+            /* Is this an erroneous call? For now, let's assume it is not, and\n+             * that type serializer is just overridden if so\n+             */\n+            _serializer.serializeWithType(value, jgen, provider, typeSer);\n+        }\n+        \n+        @Override\n+        public Class<Object> handledType() { return Object.class; }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializers.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.ser.std.NonTypedScalarSerializerBase;\n+import com.fasterxml.jackson.databind.ser.std.ScalarSerializerBase;\n+\n+\n+/**\n+ * Container class for serializers used for handling standard JDK-provided types.\n+ * \n+ * @since 1.5\n+ */\n+public class StdSerializers\n+{\n+    protected StdSerializers() { }\n+    \n+    /*\n+    /**********************************************************\n+    /* Concrete serializers, non-numeric primitives, Strings, Classes\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Serializer used for primitive boolean, as well as java.util.Boolean\n+     * wrapper type.\n+     *<p>\n+     * Since this is one of \"native\" types, no type information is ever\n+     * included on serialization (unlike for most scalar types as of 1.5)\n+     */\n+    @JacksonStdImpl\n+    public final static class BooleanSerializer\n+        extends NonTypedScalarSerializerBase<Boolean>\n+    {\n+        /**\n+         * Whether type serialized is primitive (boolean) or wrapper\n+         * (java.lang.Boolean); if true, former, if false, latter.\n+         */\n+        final boolean _forPrimitive;\n+    \n+        public BooleanSerializer(boolean forPrimitive)\n+        {\n+            super(Boolean.class);\n+            _forPrimitive = forPrimitive;\n+        }\n+    \n+        @Override\n+        public void serialize(Boolean value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeBoolean(value.booleanValue());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            /*(ryan) it may not, in fact, be optional, but there's no way\n+             * to tell whether we're referencing a boolean or java.lang.Boolean.\n+             */\n+            /* 27-Jun-2009, tatu: Now we can tell, after passing\n+             *   'forPrimitive' flag...\n+             */\n+            return createSchemaNode(\"boolean\", !_forPrimitive);\n+        }\n+    }\n+\n+    /**\n+     * @deprecated Since 1.9, use {@link com.fasterxml.jackson.databind.ser.std.StringSerializer} instead\n+     */\n+    @Deprecated\n+    @JacksonStdImpl\n+    public final static class StringSerializer\n+        extends NonTypedScalarSerializerBase<String>\n+    {\n+        public StringSerializer() { super(String.class); }\n+\n+        @Override\n+        public void serialize(String value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeString(value);\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"string\", true);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Concrete serializers, numerics\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This is the special serializer for regular {@link java.lang.Integer}s\n+     * (and primitive ints)\n+     *<p>\n+     * Since this is one of \"native\" types, no type information is ever\n+     * included on serialization (unlike for most scalar types as of 1.5)\n+     */\n+    @JacksonStdImpl\n+    public final static class IntegerSerializer\n+        extends NonTypedScalarSerializerBase<Integer>\n+    {\n+        public IntegerSerializer() { super(Integer.class); }\n+    \n+        @Override\n+        public void serialize(Integer value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeNumber(value.intValue());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"integer\", true);\n+        }\n+    }\n+\n+    /**\n+     * Similar to {@link IntegerSerializer}, but will not cast to Integer:\n+     * instead, cast is to {@link java.lang.Number}, and conversion is\n+     * by calling {@link java.lang.Number#intValue}.\n+     */\n+    @JacksonStdImpl\n+    public final static class IntLikeSerializer\n+        extends ScalarSerializerBase<Number>\n+    {\n+        final static IntLikeSerializer instance = new IntLikeSerializer();\n+    \n+        public IntLikeSerializer() { super(Number.class); }\n+        \n+        @Override\n+        public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeNumber(value.intValue());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"integer\", true);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class LongSerializer\n+        extends ScalarSerializerBase<Long>\n+    {\n+        final static LongSerializer instance = new LongSerializer();\n+    \n+        public LongSerializer() { super(Long.class); }\n+        \n+        @Override\n+        public void serialize(Long value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeNumber(value.longValue());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"number\", true);\n+        }\n+    }\n+    \n+    @JacksonStdImpl\n+    public final static class FloatSerializer\n+        extends ScalarSerializerBase<Float>\n+    {\n+        final static FloatSerializer instance = new FloatSerializer();\n+    \n+        public FloatSerializer() { super(Float.class); }\n+        \n+        @Override\n+        public void serialize(Float value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeNumber(value.floatValue());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"number\", true);\n+        }\n+    }\n+\n+    /**\n+     * This is the special serializer for regular {@link java.lang.Double}s\n+     * (and primitive doubles)\n+     *<p>\n+     * Since this is one of \"native\" types, no type information is ever\n+     * included on serialization (unlike for most scalar types as of 1.5)\n+     */\n+    @JacksonStdImpl\n+    public final static class DoubleSerializer\n+        extends NonTypedScalarSerializerBase<Double>\n+    {\n+        final static DoubleSerializer instance = new DoubleSerializer();\n+    \n+        public DoubleSerializer() { super(Double.class); }\n+    \n+        @Override\n+        public void serialize(Double value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeNumber(value.doubleValue());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"number\", true);\n+        }\n+    }\n+    \n+    /**\n+     * As a fallback, we may need to use this serializer for other\n+     * types of {@link Number}s (custom types).\n+     */\n+    @JacksonStdImpl\n+    public final static class NumberSerializer\n+        extends ScalarSerializerBase<Number>\n+    {\n+        public final static NumberSerializer instance = new NumberSerializer();\n+    \n+        public NumberSerializer() { super(Number.class); }\n+    \n+        @Override\n+        public void serialize(Number value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            // As per [JACKSON-423], handling for BigInteger and BigDecimal was missing!\n+            if (value instanceof BigDecimal) {\n+                jgen.writeNumber((BigDecimal) value);\n+            } else if (value instanceof BigInteger) {\n+                jgen.writeNumber((BigInteger) value);\n+                \n+            /* These shouldn't match (as there are more specific ones),\n+             * but just to be sure:\n+             */\n+            } else if (value instanceof Integer) {\n+                jgen.writeNumber(value.intValue());\n+            } else if (value instanceof Long) {\n+                jgen.writeNumber(value.longValue());\n+            } else if (value instanceof Double) {\n+                jgen.writeNumber(value.doubleValue());\n+            } else if (value instanceof Float) {\n+                jgen.writeNumber(value.floatValue());\n+            } else if ((value instanceof Byte) || (value instanceof Short)) {\n+                jgen.writeNumber(value.intValue()); // doesn't need to be cast to smaller numbers\n+            } else {\n+                // We'll have to use fallback \"untyped\" number write method\n+                jgen.writeNumber(value.toString());\n+            }\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"number\", true);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Serializers for JDK date/time data types\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @deprecated Since 1.9, use {@link com.fasterxml.jackson.databind.ser.std.DateSerializer} instead\n+     */\n+    @JacksonStdImpl\n+    @Deprecated\n+    public final static class CalendarSerializer\n+        extends com.fasterxml.jackson.databind.ser.std.CalendarSerializer { }\n+\n+    /**\n+     * @deprecated Since 1.9, use {@link com.fasterxml.jackson.databind.ser.std.DateSerializer} instead\n+     */\n+    @Deprecated\n+    @JacksonStdImpl\n+    public final static class UtilDateSerializer\n+        extends com.fasterxml.jackson.databind.ser.std.DateSerializer {\n+        \n+    }\n+\n+    /**\n+     * Compared to regular {@link UtilDateSerializer}, we do use String\n+     * representation here. Why? Basically to truncate of time part, since\n+     * that should not be used by plain SQL date.\n+     */\n+    @JacksonStdImpl\n+    public final static class SqlDateSerializer\n+        extends ScalarSerializerBase<java.sql.Date>\n+    {\n+        public SqlDateSerializer() { super(java.sql.Date.class); }\n+\n+        @Override\n+        public void serialize(java.sql.Date value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeString(value.toString());\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            //todo: (ryan) add a format for the date in the schema?\n+            return createSchemaNode(\"string\", true);\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class SqlTimeSerializer\n+        extends ScalarSerializerBase<java.sql.Time>\n+    {\n+        public SqlTimeSerializer() { super(java.sql.Time.class); }\n+\n+        @Override\n+        public void serialize(java.sql.Time value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeString(value.toString());\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"string\", true);\n+        }\n+    }\n+\n+    \n+    /*\n+    /**********************************************************\n+    / Other serializers\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @deprecated Since 1.9, use {@link com.fasterxml.jackson.databind.ser.std.DateSerializer} instead\n+     */\n+    @Deprecated\n+    @JacksonStdImpl\n+    public final static class SerializableSerializer\n+        extends com.fasterxml.jackson.databind.ser.std.SerializableSerializer { }\n+\n+    /**\n+     * @deprecated Since 1.9, use {@link com.fasterxml.jackson.databind.ser.std.DateSerializer} instead\n+     */\n+    @Deprecated\n+    @JacksonStdImpl\n+    public final static class SerializableWithTypeSerializer\n+        extends com.fasterxml.jackson.databind.ser.std.SerializableWithTypeSerializer {\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/ToStringSerializer.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * @deprecated Since 1.9 use {@link com.fasterxml.jackson.databind.ser.std.ToStringSerializer}\n+ */\n+@Deprecated\n+@JacksonStdImpl\n+public final class ToStringSerializer\n+    extends com.fasterxml.jackson.databind.ser.std.ToStringSerializer\n+{\n+    public final static ToStringSerializer instance = new ToStringSerializer();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/FailingSerializer.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+\n+\n+/**\n+ * Special bogus \"serializer\" that will throw\n+ * {@link JsonGenerationException} if its {@link #serialize}\n+ * gets invoked. Most commonly registered as handler for unknown types,\n+ * as well as for catching unintended usage (like trying to use null\n+ * as Map/Object key).\n+ */\n+public final class FailingSerializer\n+    extends SerializerBase<Object>\n+{\n+    final String _msg;\n+    \n+    public FailingSerializer(String msg) {\n+        super(Object.class);\n+        _msg = msg;\n+    }\n+    \n+    @Override\n+    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        throw new JsonGenerationException(_msg);\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return null;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/JsonSerializerMap.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ser.impl.SerializerCache.TypeKey;\n+\n+/**\n+ * Specialized read-only map used for storing and accessing serializers by type.\n+ * \n+ * @since 1.7\n+ */\n+public class JsonSerializerMap\n+{\n+    private final Bucket[] _buckets;\n+\n+    private final int _size;\n+    \n+    public JsonSerializerMap(Map<TypeKey,JsonSerializer<Object>> serializers)\n+    {\n+        int size = findSize(serializers.size());\n+        _size = size;\n+        int hashMask = (size-1);\n+        Bucket[] buckets = new Bucket[size];\n+        for (Map.Entry<TypeKey,JsonSerializer<Object>> entry : serializers.entrySet()) {\n+            TypeKey key = entry.getKey();\n+            int index = key.hashCode() & hashMask;\n+            buckets[index] = new Bucket(buckets[index], key, entry.getValue());\n+        }\n+        _buckets = buckets;\n+    }\n+    \n+    private final static int findSize(int size)\n+    {\n+        // For small enough results (64 or less), we'll require <= 50% fill rate; otherwise 80%\n+        int needed = (size <= 64) ? (size + size) : (size + (size >> 2));\n+        int result = 8;\n+        while (result < needed) {\n+            result += result;\n+        }\n+        return result;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    public int size() { return _size; }\n+    \n+    public JsonSerializer<Object> find(TypeKey key)\n+    {\n+        int index = key.hashCode() & (_buckets.length-1);\n+        Bucket bucket = _buckets[index];\n+        /* Ok let's actually try unrolling loop slightly as this shows up in profiler;\n+         * and also because in vast majority of cases first entry is either null\n+         * or matches.\n+         */\n+        if (bucket == null) {\n+            return null;\n+        }\n+        if (key.equals(bucket.key)) {\n+            return bucket.value;\n+        }\n+        while ((bucket = bucket.next) != null) {\n+            if (key.equals(bucket.key)) {\n+                return bucket.value;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper beans\n+    /**********************************************************\n+     */\n+    \n+    private final static class Bucket\n+    {\n+        public final TypeKey key;\n+        public final JsonSerializer<Object> value;\n+        public final Bucket next;\n+        \n+        public Bucket(Bucket next, TypeKey key, JsonSerializer<Object> value)\n+        {\n+            this.next = next;\n+            this.key = key;\n+            this.value = value;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Helper container used for resolving serializers for dynamic (possibly but not\n+ * necessarily polymorphic) properties: properties whose type is not forced\n+ * to use dynamic (declared) type and that are not final.\n+ * If so, serializer to use can only be established once actual value type is known.\n+ * Since this happens a lot unless static typing is forced (or types are final)\n+ * this implementation is optimized for efficiency.\n+ * Instances are immutable; new instances are created with factory methods: this\n+ * is important to ensure correct multi-threaded access.\n+ * \n+ * @since 1.7\n+ */\n+public abstract class PropertySerializerMap\n+{\n+    /**\n+     * Main lookup method. Takes a \"raw\" type since usage is always from\n+     * place where parameterization is fixed such that there can not be\n+     * type-parametric variations.\n+     */\n+    public abstract JsonSerializer<Object> serializerFor(Class<?> type);\n+\n+    /**\n+     * Method called if initial lookup fails; will both find serializer\n+     * and construct new map instance if warranted, and return both\n+     * @throws JsonMappingException \n+     */\n+    public final SerializerAndMapResult findAndAddSerializer(Class<?> type,\n+            SerializerProvider provider, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<Object> serializer = provider.findValueSerializer(type, property);\n+        return new SerializerAndMapResult(serializer, newWith(type, serializer));\n+    }\n+\n+    public final SerializerAndMapResult findAndAddSerializer(JavaType type,\n+            SerializerProvider provider, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        JsonSerializer<Object> serializer = provider.findValueSerializer(type, property);\n+        return new SerializerAndMapResult(serializer, newWith(type.getRawClass(), serializer));\n+    }\n+\n+    public abstract PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer);\n+    \n+    public static PropertySerializerMap emptyMap() {\n+        return Empty.instance;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Value class used for returning tuple that has both serializer\n+     * that was retrieved and new map instance\n+     */\n+    public final static class SerializerAndMapResult\n+    {\n+        public final JsonSerializer<Object> serializer;\n+        public final PropertySerializerMap map;\n+        \n+        public SerializerAndMapResult(JsonSerializer<Object> serializer,\n+                PropertySerializerMap map)\n+        {\n+            this.serializer = serializer;\n+            this.map = map;\n+        }\n+    }\n+\n+    /**\n+     * Trivial container for bundling type + serializer entries.\n+     */\n+    private final static class TypeAndSerializer\n+    {\n+        public final Class<?> type;\n+        public final JsonSerializer<Object> serializer;\n+\n+        public TypeAndSerializer(Class<?> type, JsonSerializer<Object> serializer) {\n+            this.type = type;\n+            this.serializer = serializer;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Implementations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Bogus instance that contains no serializers; used as the default\n+     * map with new serializers.\n+     */\n+    private final static class Empty extends PropertySerializerMap\n+    {\n+        protected final static Empty instance = new Empty();\n+\n+        @Override\n+        public JsonSerializer<Object> serializerFor(Class<?> type) {\n+            return null; // empty, nothing to find\n+        }        \n+\n+        @Override\n+        public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) {\n+            return new Single(type, serializer);\n+        }\n+    }\n+\n+    /**\n+     * Map that contains a single serializer; although seemingly silly\n+     * this is probably the most commonly used variant because many\n+     * theoretically dynamic or polymorphic types just have single\n+     * actual type.\n+     */\n+    private final static class Single extends PropertySerializerMap\n+    {\n+        private final Class<?> _type;\n+        private final JsonSerializer<Object> _serializer;\n+\n+        public Single(Class<?> type, JsonSerializer<Object> serializer) {\n+            _type = type;\n+            _serializer = serializer;\n+        }\n+\n+        @Override\n+        public JsonSerializer<Object> serializerFor(Class<?> type)\n+        {\n+            if (type == _type) {\n+                return _serializer;\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) {\n+            return new Double(_type, _serializer, type, serializer);\n+        }\n+    }\n+\n+    private final static class Double extends PropertySerializerMap\n+    {\n+        private final Class<?> _type1, _type2;\n+        private final JsonSerializer<Object> _serializer1, _serializer2;\n+\n+        public Double(Class<?> type1, JsonSerializer<Object> serializer1,\n+                Class<?> type2, JsonSerializer<Object> serializer2)\n+        {\n+            _type1 = type1;\n+            _serializer1 = serializer1;\n+            _type2 = type2;\n+            _serializer2 = serializer2;\n+        }\n+\n+        @Override\n+        public JsonSerializer<Object> serializerFor(Class<?> type)\n+        {\n+            if (type == _type1) {\n+                return _serializer1;\n+            }\n+            if (type == _type2) {\n+                return _serializer2;\n+            }\n+            return null;\n+        }        \n+\n+        @Override\n+        public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer) {\n+            // Ok: let's just create generic one\n+            TypeAndSerializer[] ts = new TypeAndSerializer[2];\n+            ts[0] = new TypeAndSerializer(_type1, _serializer1);\n+            ts[1] = new TypeAndSerializer(_type2, _serializer2);\n+            return new Multi(ts);\n+        }\n+    }\n+    \n+    private final static class Multi extends PropertySerializerMap\n+    {\n+        /**\n+         * Let's limit number of serializers we actually cache; linear\n+         * lookup won't scale too well beyond smallish number, and if\n+         * we really want to support larger collections should use\n+         * a hash map. But it seems unlikely this is a common use\n+         * case so for now let's just stop building after hard-coded\n+         * limit. 8 sounds like a reasonable stab for now.\n+         */\n+        private final static int MAX_ENTRIES = 8;\n+        \n+        private final TypeAndSerializer[] _entries;\n+\n+        public Multi(TypeAndSerializer[] entries) {\n+            _entries = entries;\n+        }\n+\n+        @Override\n+        public JsonSerializer<Object> serializerFor(Class<?> type)\n+        {\n+            for (int i = 0, len = _entries.length; i < len; ++i) {\n+                TypeAndSerializer entry = _entries[i];\n+                if (entry.type == type) {\n+                    return entry.serializer;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public PropertySerializerMap newWith(Class<?> type, JsonSerializer<Object> serializer)\n+        {\n+            int len = _entries.length;\n+            // Will only grow up to N entries\n+            if (len == MAX_ENTRIES) {\n+                return this;\n+            }\n+            // 1.6 has nice resize methods but we are still 1.5\n+            TypeAndSerializer[] entries = new TypeAndSerializer[len+1];\n+            System.arraycopy(_entries, 0, entries, 0, len);\n+            entries[len] = new TypeAndSerializer(type, serializer);\n+            return new Multi(entries);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.util.*;\n+\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ser.impl.SerializerCache.TypeKey;\n+\n+/**\n+ * Optimized lookup table for accessing two types of serializers; typed\n+ * and non-typed. Only accessed from a single thread, so no synchronization\n+ * needed for accessors.\n+ * \n+ * @since 1.7\n+ */\n+public final class ReadOnlyClassToSerializerMap\n+{\n+    /**\n+     * Actual mappings from type key to serializers\n+     */\n+    protected final JsonSerializerMap _map;\n+\n+    /**\n+     * We'll reuse key class to avoid unnecessary instantiations; since\n+     * this is not shared between threads, we can just reuse single\n+     * instance.\n+     */\n+    protected final TypeKey _cacheKey = new TypeKey(getClass(), false);\n+    \n+    private ReadOnlyClassToSerializerMap(JsonSerializerMap map)\n+    {\n+        _map = map;\n+    }\n+\n+    public ReadOnlyClassToSerializerMap instance()\n+    {\n+        return new ReadOnlyClassToSerializerMap(_map);\n+    }\n+\n+    /**\n+     * Factory method for creating the \"blueprint\" lookup map. Such map\n+     * can not be used as is but just shared: to get an actual usable\n+     * instance, {@link #instance} has to be called first.\n+     */\n+    public static ReadOnlyClassToSerializerMap from(HashMap<TypeKey, JsonSerializer<Object>> src)\n+    {\n+        return new ReadOnlyClassToSerializerMap(new JsonSerializerMap(src));\n+    }\n+\n+    public JsonSerializer<Object> typedValueSerializer(JavaType type)\n+    { \n+        _cacheKey.resetTyped(type);\n+        return _map.find(_cacheKey);\n+    }\n+\n+    public JsonSerializer<Object> typedValueSerializer(Class<?> cls)\n+    { \n+        _cacheKey.resetTyped(cls);\n+        return _map.find(_cacheKey);\n+    }\n+    \n+    public JsonSerializer<Object> untypedValueSerializer(Class<?> cls)\n+    { \n+        _cacheKey.resetUntyped(cls);\n+        return _map.find(_cacheKey);\n+    }\n+\n+    public JsonSerializer<Object> untypedValueSerializer(JavaType type)\n+    { \n+        _cacheKey.resetUntyped(type);\n+        return _map.find(_cacheKey);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SerializerCache.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ResolvableSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Simple cache object that allows for doing 2-level lookups: first level is\n+ * by \"local\" read-only lookup Map (used without locking)\n+ * and second backup level is by a shared modifiable HashMap.\n+ * The idea is that after a while, most serializers are found from the\n+ * local Map (to optimize performance, reduce lock contention),\n+ * but that during buildup we can use a shared map to reduce both\n+ * number of distinct read-only maps constructed, and number of\n+ * serializers constructed.\n+ *<p>\n+ * Since version 1.5 cache will actually contain three kinds of entries,\n+ * based on combination of class pair key. First class in key is for the\n+ * type to serialize, and second one is type used for determining how\n+ * to resolve value type. One (but not both) of entries can be null.\n+ */\n+public final class SerializerCache\n+{\n+    /**\n+     * Shared, modifiable map; all access needs to be through synchronized blocks.\n+     *<p>\n+     * NOTE: keys are of various types (see below for key types), in addition to\n+     * basic {@link JavaType} used for \"untyped\" serializers.\n+     */\n+    private HashMap<TypeKey, JsonSerializer<Object>> _sharedMap = new HashMap<TypeKey, JsonSerializer<Object>>(64);\n+\n+    /**\n+     * Most recent read-only instance, created from _sharedMap, if any.\n+     */\n+    private ReadOnlyClassToSerializerMap _readOnlyMap = null;\n+\n+    public SerializerCache() {\n+    }\n+\n+    /**\n+     * Method that can be called to get a read-only instance populated from the\n+     * most recent version of the shared lookup Map.\n+     */\n+    public ReadOnlyClassToSerializerMap getReadOnlyLookupMap()\n+    {\n+        ReadOnlyClassToSerializerMap m;\n+        synchronized (this) {\n+            m = _readOnlyMap;\n+            if (m == null) {\n+                _readOnlyMap = m = ReadOnlyClassToSerializerMap.from(_sharedMap);\n+            }\n+        }\n+        return m.instance();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Lookup methods for accessing shared (slow) cache\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 1.4\n+     */\n+    public synchronized int size() {\n+        return _sharedMap.size();\n+    }\n+    \n+    /**\n+     * Method that checks if the shared (and hence, synchronized) lookup Map might have\n+     * untyped serializer for given type.\n+     */\n+    public JsonSerializer<Object> untypedValueSerializer(Class<?> type)\n+    {\n+        synchronized (this) {\n+            return _sharedMap.get(new TypeKey(type, false));\n+        }\n+    }\n+\n+    /**\n+     * @since 1.5\n+     */\n+    public JsonSerializer<Object> untypedValueSerializer(JavaType type)\n+    {\n+        synchronized (this) {\n+            return _sharedMap.get(new TypeKey(type, false));\n+        }\n+    }\n+\n+    public JsonSerializer<Object> typedValueSerializer(JavaType type)\n+    {\n+        synchronized (this) {\n+            return _sharedMap.get(new TypeKey(type, true));\n+        }\n+    }\n+\n+    public JsonSerializer<Object> typedValueSerializer(Class<?> cls)\n+    {\n+        synchronized (this) {\n+            return _sharedMap.get(new TypeKey(cls, true));\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Methods for adding shared serializer instances\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called if none of lookups succeeded, and caller had to construct\n+     * a serializer. If so, we will update the shared lookup map so that it\n+     * can be resolved via it next time.\n+     */\n+    public void addTypedSerializer(JavaType type, JsonSerializer<Object> ser)\n+    {\n+        synchronized (this) {\n+            if (_sharedMap.put(new TypeKey(type, true), ser) == null) {\n+                // let's invalidate the read-only copy, too, to get it updated\n+                _readOnlyMap = null;\n+            }\n+        }\n+    }\n+\n+    public void addTypedSerializer(Class<?> cls, JsonSerializer<Object> ser)\n+    {\n+        synchronized (this) {\n+            if (_sharedMap.put(new TypeKey(cls, true), ser) == null) {\n+                // let's invalidate the read-only copy, too, to get it updated\n+                _readOnlyMap = null;\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * @since 1.8\n+     */\n+    public void addAndResolveNonTypedSerializer(Class<?> type, JsonSerializer<Object> ser,\n+            SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        synchronized (this) {\n+            if (_sharedMap.put(new TypeKey(type, false), ser) == null) {\n+                // let's invalidate the read-only copy, too, to get it updated\n+                _readOnlyMap = null;\n+            }\n+            /* Finally: some serializers want to do post-processing, after\n+             * getting registered (to handle cyclic deps).\n+             */\n+            /* 14-May-2011, tatu: As per [JACKSON-570], resolving needs to be done\n+             *   in synchronized manner; this because while we do need to register\n+             *   instance first, we also must keep lock until resolution is complete\n+             */\n+            if (ser instanceof ResolvableSerializer) {\n+                ((ResolvableSerializer) ser).resolve(provider);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    public void addAndResolveNonTypedSerializer(JavaType type, JsonSerializer<Object> ser,\n+            SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        synchronized (this) {\n+            if (_sharedMap.put(new TypeKey(type, false), ser) == null) {\n+                // let's invalidate the read-only copy, too, to get it updated\n+                _readOnlyMap = null;\n+            }\n+            /* Finally: some serializers want to do post-processing, after\n+             * getting registered (to handle cyclic deps).\n+             */\n+            /* 14-May-2011, tatu: As per [JACKSON-570], resolving needs to be done\n+             *   in synchronized manner; this because while we do need to register\n+             *   instance first, we also must keep lock until resolution is complete\n+             */\n+            if (ser instanceof ResolvableSerializer) {\n+                ((ResolvableSerializer) ser).resolve(provider);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method called by StdSerializerProvider#flushCachedSerializers() to\n+     * clear all cached serializers\n+     */\n+    public synchronized void flush() {\n+        _sharedMap.clear();\n+    }\n+\n+    /*\n+    /**************************************************************\n+    /* Helper class(es)\n+    /**************************************************************\n+     */\n+\n+    /**\n+     * Key that offers two \"modes\"; one with raw class, as used for\n+     * cases were raw class type is available (for example, when using\n+     * runtime type); and one with full generics-including.\n+     */\n+    public final static class TypeKey\n+    {\n+        protected int _hashCode;\n+\n+        protected Class<?> _class;\n+\n+        protected JavaType _type;\n+\n+        /**\n+         * Indicator of whether serializer stored has a type serializer\n+         * wrapper around it or not; if not, it is \"untyped\" serializer;\n+         * if it has, it is \"typed\"\n+         */\n+        protected boolean _isTyped;\n+        \n+        public TypeKey(Class<?> key, boolean typed) {\n+            _class = key;\n+            _type = null;\n+            _isTyped = typed;\n+            _hashCode = hash(key, typed);\n+        }\n+\n+        public TypeKey(JavaType key, boolean typed) {\n+            _type = key;\n+            _class = null;\n+            _isTyped = typed;\n+            _hashCode = hash(key, typed);\n+        }\n+\n+        private final static int hash(Class<?> cls, boolean typed) {\n+            int hash = cls.getName().hashCode();\n+            if (typed) {\n+                ++hash;\n+            }\n+            return hash;\n+        }\n+\n+        private final static int hash(JavaType type, boolean typed) {\n+            int hash = type.hashCode() - 1;\n+            if (typed) {\n+                --hash;\n+            }\n+            return hash;\n+        }\n+        \n+        public void resetTyped(Class<?> cls) {\n+            _type = null;\n+            _class = cls;\n+            _isTyped = true;\n+            _hashCode = hash(cls, true);\n+        }\n+\n+        public void resetUntyped(Class<?> cls) {\n+            _type = null;\n+            _class = cls;\n+            _isTyped = false;\n+            _hashCode = hash(cls, false);\n+        }\n+        \n+        public void resetTyped(JavaType type) {\n+            _type = type;\n+            _class = null;\n+            _isTyped = true;\n+            _hashCode = hash(type, true);\n+        }\n+\n+        public void resetUntyped(JavaType type) {\n+            _type = type;\n+            _class = null;\n+            _isTyped = false;\n+            _hashCode = hash(type, false);\n+        }\n+        \n+        @Override public final int hashCode() { return _hashCode; }\n+\n+        @Override public final String toString() {\n+            if (_class != null) {\n+                return \"{class: \"+_class.getName()+\", typed? \"+_isTyped+\"}\";\n+            }\n+            return \"{type: \"+_type+\", typed? \"+_isTyped+\"}\";\n+        }\n+        \n+        // note: we assume key is never used for anything other than as map key, so:\n+        @Override public final boolean equals(Object o)\n+        {\n+            if (o == this) return true;\n+            TypeKey other = (TypeKey) o;\n+            if (other._isTyped == _isTyped) {\n+                if (_class != null) {\n+                    return other._class == _class;\n+                }\n+                return _type.equals(other._type);\n+            }\n+            return false;\n+        } \n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.util.*;\n+\n+import org.codehaus.jackson.JsonGenerator;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyFilter;\n+import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n+\n+/**\n+ * Simple {@link BeanPropertyFilter} implementation that only uses property name\n+ * to determine whether to serialize property as is, or to filter it out.\n+ * \n+ * @since 1.7\n+ */\n+public abstract class SimpleBeanPropertyFilter implements BeanPropertyFilter\n+{\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    protected SimpleBeanPropertyFilter() { }\n+\n+    /**\n+     * Factory method to construct filter that filters out all properties <b>except</b>\n+     * ones includes in set\n+     */\n+    public static SimpleBeanPropertyFilter filterOutAllExcept(Set<String> properties) {\n+        return new FilterExceptFilter(properties);\n+    }\n+\n+    public static SimpleBeanPropertyFilter filterOutAllExcept(String... propertyArray) {\n+        HashSet<String> properties = new HashSet<String>(propertyArray.length);\n+        Collections.addAll(properties, propertyArray);\n+        return new FilterExceptFilter(properties);\n+    }\n+    \n+    public static SimpleBeanPropertyFilter serializeAllExcept(Set<String> properties) {\n+        return new SerializeExceptFilter(properties);\n+    }\n+\n+    public static SimpleBeanPropertyFilter serializeAllExcept(String... propertyArray) {\n+        HashSet<String> properties = new HashSet<String>(propertyArray.length);\n+        Collections.addAll(properties, propertyArray);\n+        return new SerializeExceptFilter(properties);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Sub-classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Filter implementation which defaults to filtering out unknown\n+     * properties and only serializes ones explicitly listed.\n+     */\n+    public static class FilterExceptFilter\n+        extends SimpleBeanPropertyFilter\n+    {\n+        /**\n+         * Set of property names to serialize.\n+         */\n+        protected final Set<String> _propertiesToInclude;\n+\n+        public FilterExceptFilter(Set<String> properties) {\n+            _propertiesToInclude = properties;\n+        }\n+        \n+        @Override\n+        public void serializeAsField(Object bean, JsonGenerator jgen,\n+                SerializerProvider provider, BeanPropertyWriter writer)\n+            throws Exception\n+        {\n+            if (_propertiesToInclude.contains(writer.getName())) {\n+                writer.serializeAsField(bean, jgen, provider);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Filter implementation which defaults to serializing all\n+     * properties, except for ones explicitly listed to be filtered out.\n+     */\n+    public static class SerializeExceptFilter\n+        extends SimpleBeanPropertyFilter\n+    {\n+        /**\n+         * Set of property names to filter out.\n+         */\n+        protected final Set<String> _propertiesToExclude;\n+\n+        public SerializeExceptFilter(Set<String> properties) {\n+            _propertiesToExclude = properties;\n+        }\n+        \n+        @Override\n+        public void serializeAsField(Object bean, JsonGenerator jgen,\n+                SerializerProvider provider, BeanPropertyWriter writer)\n+            throws Exception\n+        {\n+            if (!_propertiesToExclude.contains(writer.getName())) {\n+                writer.serializeAsField(bean, jgen, provider);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.databind.ser.*;\n+\n+/**\n+ * Simple {@link FilterProvider} implementation that just stores\n+ * direct id-to-filter mapping.\n+ */\n+public class SimpleFilterProvider extends FilterProvider\n+{\n+    /**\n+     * Mappings from ids to filters.\n+     */\n+    protected final Map<String,BeanPropertyFilter> _filtersById;\n+\n+    /**\n+     * This is the filter we return in case no mapping was found for\n+     * given id; default is 'null' (in which case caller typically\n+     * reports an error), but can be set to an explicit filter.\n+     */\n+    protected BeanPropertyFilter _defaultFilter;\n+\n+    /**\n+     * Flag that indicates whether request for an unknown filter id should\n+     * result an exception (default) or not.\n+     * Note that this is only relevant if no default filter has been\n+     * configured.\n+     * \n+     * @since 1.9\n+     */\n+    protected boolean _cfgFailOnUnknownId = true;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructing, configuring\n+    /**********************************************************\n+     */\n+    \n+    public SimpleFilterProvider() {\n+        _filtersById = new HashMap<String,BeanPropertyFilter>();\n+    }\n+\n+    /**\n+     * @param mapping Mapping from id to filter; used as is, no copy is made.\n+     */\n+    public SimpleFilterProvider(Map<String,BeanPropertyFilter> mapping) {\n+        _filtersById = new HashMap<String,BeanPropertyFilter>();\n+    }\n+    \n+    /**\n+     * Method for defining filter to return for \"unknown\" filters; cases\n+     * where there is no mapping from given id to an explicit filter.\n+     * \n+     * @param f Filter to return when no filter is found for given id\n+     */\n+    public SimpleFilterProvider setDefaultFilter(BeanPropertyFilter f)\n+    {\n+        _defaultFilter = f;\n+        return this;\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public BeanPropertyFilter getDefaultFilter() {\n+        return _defaultFilter;\n+    }\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    public SimpleFilterProvider setFailOnUnknownId(boolean state) {\n+        _cfgFailOnUnknownId = state;\n+        return this;\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public boolean willFailOnUnknownId() {\n+        return _cfgFailOnUnknownId;\n+    }\n+    \n+    public SimpleFilterProvider addFilter(String id, BeanPropertyFilter filter) {\n+        _filtersById.put(id, filter);\n+        return this;\n+    }\n+\n+    public BeanPropertyFilter removeFilter(String id) {\n+        return _filtersById.remove(id);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public lookup API\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public BeanPropertyFilter findFilter(Object filterId)\n+    {\n+        BeanPropertyFilter f = _filtersById.get(filterId);\n+        if (f == null) {\n+            f = _defaultFilter;\n+            if (f == null && _cfgFailOnUnknownId) {\n+                throw new IllegalArgumentException(\"No filter configured with id '\"+filterId+\"' (type \"\n+                        +filterId.getClass().getName()+\")\");\n+            }\n+        }\n+        return f;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnknownSerializer.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+\n+public class UnknownSerializer\n+    extends SerializerBase<Object>\n+{\n+    public UnknownSerializer() {\n+        super(Object.class);\n+    }\n+    \n+    @Override\n+    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonMappingException\n+    {\n+        // 27-Nov-2009, tatu: As per [JACKSON-201] may or may not fail...\n+        if (provider.isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS)) {\n+            failForEmpty(value);\n+        }\n+        // But if it's fine, we'll just output empty JSON Object:\n+        jgen.writeStartObject();\n+        jgen.writeEndObject();\n+    }\n+\n+    // since 1.6.2; needed to retain type information\n+    @Override\n+    public final void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (provider.isEnabled(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS)) {\n+            failForEmpty(value);\n+        }\n+        typeSer.writeTypePrefixForObject(value, jgen);\n+        typeSer.writeTypeSuffixForObject(value, jgen);\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint) throws JsonMappingException {\n+        return null;\n+    }\n+\n+    protected void failForEmpty(Object value) throws JsonMappingException\n+    {\n+        throw new JsonMappingException(\"No serializer found for class \"+value.getClass().getName()+\" and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS) )\");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.ser.*;\n+\n+\n+/**\n+ * Variant of {@link BeanPropertyWriter} which will handle unwrapping\n+ * of JSON Object (including of properties of Object within surrounding\n+ * JSON object, and not as sub-object).\n+ */\n+public class UnwrappingBeanPropertyWriter\n+    extends BeanPropertyWriter\n+{\n+    public UnwrappingBeanPropertyWriter(BeanPropertyWriter base) {\n+        super(base);\n+    }\n+\n+    public UnwrappingBeanPropertyWriter(BeanPropertyWriter base, JsonSerializer<Object> ser) {\n+        super(base, ser);\n+    }\n+    \n+    @Override\n+    public BeanPropertyWriter withSerializer(JsonSerializer<Object> ser)\n+    {\n+        if (getClass() != UnwrappingBeanPropertyWriter.class) {\n+            throw new IllegalStateException(\"UnwrappingBeanPropertyWriter sub-class does not override 'withSerializer()'; needs to!\");\n+        }\n+        // better try to create unwrapping instance\n+        if (!ser.isUnwrappingSerializer()) {\n+            ser = ser.unwrappingSerializer();\n+        }\n+        return new UnwrappingBeanPropertyWriter(this, ser);\n+    }\n+\n+    @Override\n+    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        Object value = get(bean);\n+        if (value == null) {\n+            /* Hmmh. I assume we MUST pretty much suppress nulls, since we\n+             * can't really unwrap it...\n+             */\n+            return;\n+        }\n+        // For non-nulls, first: simple check for direct cycles\n+        if (value == bean) {\n+            _reportSelfReference(bean);\n+        }\n+        if (_suppressableValue != null && _suppressableValue.equals(value)) {\n+            return;\n+        }\n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+\n+        // note: must verify we are using unwrapping serializer; if not, will write field name\n+        if (!ser.isUnwrappingSerializer()) {\n+            jgen.writeFieldName(_name);\n+        }\n+\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, jgen, prov);\n+        } else {\n+            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+        }\n+    }\n+\n+    // need to override as we must get unwrapping instance...\n+    @Override\n+    protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            Class<?> type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        JsonSerializer<Object> serializer;\n+        if (_nonTrivialBaseType != null) {\n+            JavaType subtype = provider.constructSpecializedType(_nonTrivialBaseType, type);\n+            serializer = provider.findValueSerializer(subtype, this);\n+        } else {\n+            serializer = provider.findValueSerializer(type, this);\n+        }\n+        if (!serializer.isUnwrappingSerializer()) {\n+            serializer = serializer.unwrappingSerializer();\n+        }\n+        _dynamicSerializers = _dynamicSerializers.newWith(type, serializer);\n+        return serializer;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanSerializer.java\n+package com.fasterxml.jackson.databind.ser.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.*;\n+import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n+\n+\n+public class UnwrappingBeanSerializer\n+    extends BeanSerializerBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Constructor used for creating unwrapping instance of a\n+     * standard <code>BeanSerializer</code>\n+     */\n+    public UnwrappingBeanSerializer(BeanSerializerBase src) {\n+        super(src);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle: factory methods, fluent factories\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonSerializer<Object> unwrappingSerializer() {\n+        // already unwrapping, nothing more to do:\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean isUnwrappingSerializer() {\n+        return true; // sure is\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonSerializer implementation that differs between impls\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Main serialization method that will delegate actual output to\n+     * configured\n+     * {@link BeanPropertyWriter} instances.\n+     */\n+    @Override\n+    public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_propertyFilterId != null) {\n+            serializeFieldsFiltered(bean, jgen, provider);\n+        } else {\n+            serializeFields(bean, jgen, provider);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override public String toString() {\n+        return \"UnwrappingBeanSerializer for \"+handledType().getName();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/package-info.java\n+/**\n+ * Contains implementation classes of serialization part of \n+ * data binding.\n+ */\n+package com.fasterxml.jackson.databind.ser.impl;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/package-info.java\n+/**\n+ * Contains implementation classes of serialization part of \n+ * data binding.\n+ */\n+package com.fasterxml.jackson.databind.ser;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+import org.codehaus.jackson.node.ObjectNode;\n+import org.codehaus.jackson.schema.JsonSchema;\n+import org.codehaus.jackson.schema.SchemaAware;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+\n+/**\n+ * Base class for serializers that will output contents as JSON\n+ * arrays; typically serializers used for {@link java.util.Collection}\n+ * and array types.\n+ */\n+public abstract class AsArraySerializerBase<T>\n+    extends ContainerSerializerBase<T>\n+    implements ResolvableSerializer\n+{\n+    protected final boolean _staticTyping;\n+\n+    protected final JavaType _elementType;\n+\n+    /**\n+     * Type serializer used for values, if any.\n+     */\n+    protected final TypeSerializer _valueTypeSerializer;\n+    \n+    /**\n+     * Value serializer to use, if it can be statically determined\n+     * \n+     * @since 1.5\n+     */\n+    protected JsonSerializer<Object> _elementSerializer;\n+\n+    /**\n+     * Collection-valued property being serialized with this instance\n+     * \n+     * @since 1.7\n+     */\n+    protected final BeanProperty _property;\n+\n+    /**\n+     * If element type can not be statically determined, mapping from\n+     * runtime type to serializer is handled using this object\n+     * \n+     * @since 1.7\n+     */\n+    protected PropertySerializerMap _dynamicSerializers;\n+\n+    /**\n+     * @deprecated since 1.8\n+     */\n+    @Deprecated\n+    protected AsArraySerializerBase(Class<?> cls, JavaType et, boolean staticTyping,\n+            TypeSerializer vts, BeanProperty property)\n+    {\n+        this(cls, et, staticTyping, vts, property, null);\n+    }\n+\n+    protected AsArraySerializerBase(Class<?> cls, JavaType et, boolean staticTyping,\n+            TypeSerializer vts, BeanProperty property, JsonSerializer<Object> elementSerializer)\n+    {\n+        // typing with generics is messy... have to resort to this:\n+        super(cls, false);\n+        _elementType = et;\n+        // static if explicitly requested, or if element type is final\n+        _staticTyping = staticTyping || (et != null && et.isFinal());\n+        _valueTypeSerializer = vts;\n+        _property = property;\n+        _elementSerializer = elementSerializer;\n+        _dynamicSerializers = PropertySerializerMap.emptyMap();\n+    }\n+\n+    @Override\n+    public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeStartArray();\n+        serializeContents(value, jgen, provider);\n+        jgen.writeEndArray();\n+    }\n+    \n+    @Override\n+    public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        typeSer.writeTypePrefixForArray(value, jgen);\n+        serializeContents(value, jgen, provider);\n+        typeSer.writeTypeSuffixForArray(value, jgen);\n+    }\n+\n+    protected abstract void serializeContents(T value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException;\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        /* 15-Jan-2010, tatu: This should probably be rewritten, given that\n+         *    more information about content type is actually being explicitly\n+         *    passed. So there should be less need to try to re-process that\n+         *    information.\n+         */\n+        ObjectNode o = createSchemaNode(\"array\", true);\n+        JavaType contentType = null;\n+        if (typeHint != null) {\n+            JavaType javaType = provider.constructType(typeHint);\n+            contentType = javaType.getContentType();\n+            if (contentType == null) { // could still be parametrized (Iterators)\n+                if (typeHint instanceof ParameterizedType) {\n+                    Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();\n+                    if (typeArgs.length == 1) {\n+                        contentType = provider.constructType(typeArgs[0]);\n+                    }\n+                }\n+            }\n+        }\n+        if (contentType == null && _elementType != null) {\n+            contentType = _elementType;\n+        }\n+        if (contentType != null) {\n+            JsonNode schemaNode = null;\n+            // 15-Oct-2010, tatu: We can't serialize plain Object.class; but what should it produce here? Untyped?\n+            if (contentType.getRawClass() != Object.class) {\n+                JsonSerializer<Object> ser = provider.findValueSerializer(contentType, _property);\n+                if (ser instanceof SchemaAware) {\n+                    schemaNode = ((SchemaAware) ser).getSchema(provider, null);\n+                }\n+            }\n+            if (schemaNode == null) {\n+                schemaNode = JsonSchema.getDefaultSchemaNode();\n+            }\n+            o.put(\"items\", schemaNode);\n+        }\n+        return o;\n+    }\n+\n+    /**\n+     * Need to get callback to resolve value serializer, if static typing\n+     * is used (either being forced, or because value type is final)\n+     */\n+    @Override\n+    public void resolve(SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        if (_staticTyping && _elementType != null && _elementSerializer == null) {\n+            _elementSerializer = provider.findValueSerializer(_elementType, _property);\n+        }\n+    }\n+\n+    /**\n+     * @since 1.7\n+     */\n+    protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            Class<?> type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property);\n+        // did we get a new map of serializers? If so, start using it\n+        if (map != result.map) {\n+            _dynamicSerializers = result.map;\n+        }\n+        return result.serializer;\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            JavaType type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property);\n+        if (map != result.map) {\n+            _dynamicSerializers = result.map;\n+        }\n+        return result.serializer;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+import org.codehaus.jackson.node.ObjectNode;\n+import org.codehaus.jackson.schema.JsonSchema;\n+import org.codehaus.jackson.schema.SchemaAware;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.*;\n+\n+/**\n+ * Base class both for the standard bean serializer, and couple\n+ * of variants that only differ in small details.\n+ * Can be used for custom bean serializers as well, although that\n+ * is not the primary design goal.\n+ * \n+ * @since 1.9\n+ */\n+public abstract class BeanSerializerBase\n+    extends SerializerBase<Object>\n+    implements ResolvableSerializer, SchemaAware\n+{\n+    final protected static BeanPropertyWriter[] NO_PROPS = new BeanPropertyWriter[0];\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Writers used for outputting actual property values\n+     */\n+    final protected BeanPropertyWriter[] _props;\n+\n+    /**\n+     * Optional filters used to suppress output of properties that\n+     * are only to be included in certain views\n+     */\n+    final protected BeanPropertyWriter[] _filteredProps;\n+\n+    /**\n+     * Handler for {@link org.codehaus.jackson.annotate.JsonAnyGetter}\n+     * annotated properties\n+     * \n+     * @since 1.6\n+     */\n+    final protected AnyGetterWriter _anyGetterWriter;\n+\n+    /**\n+     * Id of the bean property filter to use, if any; null if none.\n+     */\n+    final protected Object _propertyFilterId;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: constructors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @param type Nominal type of values handled by this serializer\n+     * @param properties Property writers used for actual serialization\n+     */\n+    protected BeanSerializerBase(JavaType type,\n+            BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties,\n+            AnyGetterWriter anyGetterWriter,\n+            Object filterId)\n+    {\n+        super(type);\n+        _props = properties;\n+        _filteredProps = filteredProperties;\n+        _anyGetterWriter = anyGetterWriter;\n+        _propertyFilterId = filterId;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public BeanSerializerBase(Class<?> rawType,\n+            BeanPropertyWriter[] properties, BeanPropertyWriter[] filteredProperties,\n+            AnyGetterWriter anyGetterWriter,\n+            Object filterId)\n+    {\n+        super((Class<Object>) rawType);\n+        _props = properties;\n+        _filteredProps = filteredProperties;\n+        _anyGetterWriter = anyGetterWriter;\n+        _propertyFilterId = filterId;\n+    }\n+\n+    /**\n+     * Copy-constructor that is useful for sub-classes that just want to\n+     * copy all super-class properties without modifications.\n+     */\n+    protected BeanSerializerBase(BeanSerializerBase src) {\n+        this(src._handledType,\n+                src._props, src._filteredProps, src._anyGetterWriter, src._propertyFilterId);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Partial JsonSerializer implementation\n+    /**********************************************************\n+     */\n+\n+    // Main serialization method left unimplemented\n+    @Override\n+    public abstract void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException;\n+\n+    // Type-info-augmented case implemented as it does not usually differ between impls\n+    @Override\n+    public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        typeSer.writeTypePrefixForObject(bean, jgen);\n+        if (_propertyFilterId != null) {\n+            serializeFieldsFiltered(bean, jgen, provider);\n+        } else {\n+            serializeFields(bean, jgen, provider);\n+        }\n+        typeSer.writeTypeSuffixForObject(bean, jgen);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Field serialization methods\n+    /**********************************************************\n+     */\n+    \n+    protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final BeanPropertyWriter[] props;\n+        if (_filteredProps != null && provider.getSerializationView() != null) {\n+            props = _filteredProps;\n+        } else {\n+            props = _props;\n+        }\n+        int i = 0;\n+        try {\n+            for (final int len = props.length; i < len; ++i) {\n+                BeanPropertyWriter prop = props[i];\n+                if (prop != null) { // can have nulls in filtered list\n+                    prop.serializeAsField(bean, jgen, provider);\n+                }\n+            }\n+            if (_anyGetterWriter != null) {\n+                _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+            }\n+        } catch (Exception e) {\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            wrapAndThrow(provider, e, bean, name);\n+        } catch (StackOverflowError e) {\n+            /* 04-Sep-2009, tatu: Dealing with this is tricky, since we do not\n+             *   have many stack frames to spare... just one or two; can't\n+             *   make many calls.\n+             */\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n+            throw mapE;\n+        }\n+    }\n+\n+    /**\n+     * Alternative serialization method that gets called when there is a\n+     * {@link BeanPropertyFilter} that needs to be called to determine\n+     * which properties are to be serialized (and possibly how)\n+     * \n+     * @since 1.7\n+     */\n+    protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        /* note: almost verbatim copy of \"serializeFields\"; copied (instead of merged)\n+         * so that old method need not add check for existence of filter.\n+         */\n+        \n+        final BeanPropertyWriter[] props;\n+        if (_filteredProps != null && provider.getSerializationView() != null) {\n+            props = _filteredProps;\n+        } else {\n+            props = _props;\n+        }\n+        final BeanPropertyFilter filter = findFilter(provider);\n+        // better also allow missing filter actually..\n+        if (filter == null) {\n+            serializeFields(bean, jgen, provider);\n+            return;\n+        }\n+        \n+        int i = 0;\n+        try {\n+            for (final int len = props.length; i < len; ++i) {\n+                BeanPropertyWriter prop = props[i];\n+                if (prop != null) { // can have nulls in filtered list\n+                    filter.serializeAsField(bean, jgen, provider, prop);\n+                }\n+            }\n+            if (_anyGetterWriter != null) {\n+                _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+            }\n+        } catch (Exception e) {\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            wrapAndThrow(provider, e, bean, name);\n+        } catch (StackOverflowError e) {\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n+            throw mapE;\n+        }\n+    }\n+\n+    /**\n+     * Helper method used to locate filter that is needed, based on filter id\n+     * this serializer was constructed with.\n+     * \n+     * @since 1.7\n+     */\n+    protected BeanPropertyFilter findFilter(SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        final Object filterId = _propertyFilterId;\n+        FilterProvider filters = provider.getFilterProvider();\n+        // Not ok to miss the provider, if a filter is declared to be needed.\n+        if (filters == null) {\n+            throw new JsonMappingException(\"Can not resolve BeanPropertyFilter with id '\"+filterId+\"'; no FilterProvider configured\");\n+        }\n+        BeanPropertyFilter filter = filters.findFilter(filterId);\n+        // But whether unknown ids are ok just depends on filter provider; if we get null that's fine\n+        return filter;\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        ObjectNode o = createSchemaNode(\"object\", true);\n+        //todo: should the classname go in the title?\n+        //o.put(\"title\", _className);\n+        ObjectNode propertiesNode = o.objectNode();\n+        for (int i = 0; i < _props.length; i++) {\n+            BeanPropertyWriter prop = _props[i];\n+            JavaType propType = prop.getSerializationType();\n+            // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n+            Type hint = (propType == null) ? prop.getGenericPropertyType() : propType.getRawClass();\n+            // Maybe it already has annotated/statically configured serializer?\n+            JsonSerializer<Object> ser = prop.getSerializer();\n+            if (ser == null) { // nope\n+                Class<?> serType = prop.getRawSerializationType();\n+                if (serType == null) {\n+                    serType = prop.getPropertyType();\n+                }\n+                ser = provider.findValueSerializer(serType, prop);\n+            }\n+            JsonNode schemaNode = (ser instanceof SchemaAware) ?\n+                    ((SchemaAware) ser).getSchema(provider, hint) : \n+                    JsonSchema.getDefaultSchemaNode();\n+            propertiesNode.put(prop.getName(), schemaNode);\n+        }\n+        o.put(\"properties\", propertiesNode);\n+        return o;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* ResolvableSerializer impl\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void resolve(SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        int filteredCount = (_filteredProps == null) ? 0 : _filteredProps.length;\n+        for (int i = 0, len = _props.length; i < len; ++i) {\n+            BeanPropertyWriter prop = _props[i];\n+            if (prop.hasSerializer()) {\n+                continue;\n+            }\n+            // Was the serialization type hard-coded? If so, use it\n+            JavaType type = prop.getSerializationType();\n+            \n+            /* It not, we can use declared return type if and only if\n+             * declared type is final -- if not, we don't really know\n+             * the actual type until we get the instance.\n+             */\n+            if (type == null) {\n+                type = provider.constructType(prop.getGenericPropertyType());\n+                if (!type.isFinal()) {\n+                    /* 18-Feb-2010, tatus: But even if it is non-final, we may\n+                     *   need to retain some of type information so that we can\n+                     *   accurately handle contained types\n+                     */\n+                    if (type.isContainerType() || type.containedTypeCount() > 0) {\n+                        prop.setNonTrivialBaseType(type);\n+                    }\n+                    continue;\n+                }\n+            }\n+            JsonSerializer<Object> ser = provider.findValueSerializer(type, prop);\n+            /* 04-Feb-2010, tatu: We may have stashed type serializer for content types\n+             *   too, earlier; if so, it's time to connect the dots here:\n+             */\n+            if (type.isContainerType()) {\n+                TypeSerializer typeSer = type.getContentType().getTypeHandler();\n+                if (typeSer != null) {\n+                    // for now, can do this only for standard containers...\n+                    if (ser instanceof ContainerSerializerBase<?>) {\n+                        // ugly casts... but necessary\n+                        @SuppressWarnings(\"unchecked\")\n+                        JsonSerializer<Object> ser2 = (JsonSerializer<Object>)((ContainerSerializerBase<?>) ser).withValueTypeSerializer(typeSer);\n+                        ser = ser2;\n+                    }\n+                }\n+            }\n+            prop = prop.withSerializer(ser);\n+            _props[i] = prop;\n+            // and maybe replace filtered property too? (see [JACKSON-364])\n+            if (i < filteredCount) {\n+                BeanPropertyWriter w2 = _filteredProps[i];\n+                if (w2 != null) {\n+                    _filteredProps[i] = w2.withSerializer(ser);\n+                }\n+            }\n+        }\n+\n+        // also, any-getter may need to be resolved\n+        if (_anyGetterWriter != null) {\n+            _anyGetterWriter.resolve(provider);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.Calendar;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * Standard serializer for {@link java.util.Calendar}.\n+ * As with other time/date types, is configurable to produce timestamps\n+ * (standard Java 64-bit timestamp) or textual formats (usually ISO-8601).\n+ * \n+ * @since 1.9 (moved from 'org.codehaus.jackson.map.ser.StdSerializers#CalendarSerializer}\n+ */\n+@JacksonStdImpl\n+public class CalendarSerializer\n+    extends ScalarSerializerBase<Calendar>\n+{\n+    public static CalendarSerializer instance = new CalendarSerializer();\n+\n+    public CalendarSerializer() { super(Calendar.class); }\n+    \n+    @Override\n+    public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        provider.defaultSerializeDateValue(value.getTimeInMillis(), jgen);\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        //TODO: (ryan) add a format for the date in the schema?\n+        return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+                ? \"number\" : \"string\", true);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+\n+\n+/**\n+ * Fallback serializer for cases where Collection is not known to be\n+ * of type for which more specializer serializer exists (such as\n+ * index-accessible List).\n+ * If so, we will just construct an {@link java.util.Iterator}\n+ * to iterate over elements.\n+ */\n+public class CollectionSerializer\n+    extends AsArraySerializerBase<Collection<?>>\n+{\n+    public CollectionSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts,\n+            BeanProperty property, JsonSerializer<Object> valueSerializer)\n+    {\n+        super(Collection.class, elemType, staticTyping, vts, property, valueSerializer);\n+    }\n+    \n+    @Override\n+    public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n+        return new CollectionSerializer(_elementType, _staticTyping, vts, _property, _elementSerializer);\n+    }\n+    \n+    @Override\n+    public void serializeContents(Collection<?> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_elementSerializer != null) {\n+            serializeContentsUsing(value, jgen, provider, _elementSerializer);\n+            return;\n+        }\n+        Iterator<?> it = value.iterator();\n+        if (!it.hasNext()) {\n+            return;\n+        }\n+        PropertySerializerMap serializers = _dynamicSerializers;\n+        final TypeSerializer typeSer = _valueTypeSerializer;\n+\n+        int i = 0;\n+        try {\n+            do {\n+                Object elem = it.next();\n+                if (elem == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                } else {\n+                    Class<?> cc = elem.getClass();\n+                    JsonSerializer<Object> serializer = serializers.serializerFor(cc);\n+                    if (serializer == null) {\n+                        // To fix [JACKSON-508]\n+                        if (_elementType.hasGenericTypes()) {\n+                            serializer = _findAndAddDynamic(serializers,\n+                                    provider.constructSpecializedType(_elementType, cc), provider);\n+                        } else {\n+                            serializer = _findAndAddDynamic(serializers, cc, provider);\n+                        }\n+                        serializers = _dynamicSerializers;\n+                    }\n+                    if (typeSer == null) {\n+                        serializer.serialize(elem, jgen, provider);\n+                    } else {\n+                        serializer.serializeWithType(elem, jgen, provider, typeSer);\n+                    }\n+                }\n+                ++i;\n+            } while (it.hasNext());\n+        } catch (Exception e) {\n+            // [JACKSON-55] Need to add reference information\n+            wrapAndThrow(provider, e, value, i);\n+        }\n+    }\n+\n+    public void serializeContentsUsing(Collection<?> value, JsonGenerator jgen, SerializerProvider provider,\n+            JsonSerializer<Object> ser)\n+        throws IOException, JsonGenerationException\n+    {\n+        Iterator<?> it = value.iterator();\n+        if (it.hasNext()) {\n+            TypeSerializer typeSer = _valueTypeSerializer;\n+            int i = 0;\n+            do {\n+                Object elem = it.next();\n+                try {\n+                    if (elem == null) {\n+                        provider.defaultSerializeNull(jgen);\n+                    } else {\n+                        if (typeSer == null) {\n+                            ser.serialize(elem, jgen, provider);\n+                        } else {\n+                            ser.serializeWithType(elem, jgen, provider, typeSer);\n+                        }\n+                    }\n+                    ++i;\n+                } catch (Exception e) {\n+                    // [JACKSON-55] Need to add reference information\n+                    wrapAndThrow(provider, e, value, i);\n+                }\n+            } while (it.hasNext());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ContainerSerializerBase.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+\n+/**\n+ * Intermediate base class for types that contain element(s) of\n+ * other types. Used for example for List, Map, Object array and\n+ * Iterator serializers.\n+ * \n+ * @since 1.5\n+ */\n+public abstract class ContainerSerializerBase<T>\n+    extends SerializerBase<T>\n+{\n+    /*\n+    /**********************************************************\n+    /* Construction, initialization\n+    /**********************************************************\n+     */\n+\n+    protected ContainerSerializerBase(Class<T> t) {\n+        super(t);\n+    }\n+    \n+    /**\n+     * Alternate constructor that is (alas!) needed to work\n+     * around kinks of generic type handling\n+     * \n+     * @param t\n+     */\n+    protected ContainerSerializerBase(Class<?> t, boolean dummy) {\n+        super(t, dummy);\n+    }\n+\n+    /**\n+     * Factory(-like) method that can be used to construct a new container\n+     * serializer that uses specified {@link TypeSerializer} for decorating\n+     * contained values with additional type information.\n+     * \n+     * @param vts Type serializer to use for contained values; can be null,\n+     *    in which case 'this' serializer is returned as is\n+     * @return Serializer instance that uses given type serializer for values if\n+     *    that is possible (or if not, just 'this' serializer)\n+     */\n+    public ContainerSerializerBase<?> withValueTypeSerializer(TypeSerializer vts) {\n+        if (vts == null) return this;\n+        return _withValueTypeSerializer(vts);\n+    }\n+\n+    public abstract ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts);\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.Date;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * For efficiency, we will serialize Dates as longs, instead of\n+ * potentially more readable Strings.\n+ *<p>\n+ * @since 1.9 (moved from 'org.codehaus.jackson.map.ser.StdSerializers#UtilDateSerializer}\n+ */\n+@JacksonStdImpl\n+public class DateSerializer\n+    extends ScalarSerializerBase<java.util.Date>\n+{\n+    public static DateSerializer instance = new DateSerializer();\n+    \n+    public DateSerializer() { super(Date.class); }\n+\n+    @Override\n+    public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        provider.defaultSerializeDateValue(value, jgen);\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        //todo: (ryan) add a format for the date in the schema?\n+        return createSchemaNode(provider.isEnabled(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS)\n+                ? \"number\" : \"string\", true);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import org.codehaus.jackson.node.JsonNodeFactory;\n+import org.codehaus.jackson.node.ObjectNode;\n+import org.codehaus.jackson.schema.JsonSchema;\n+import org.codehaus.jackson.schema.SchemaAware;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.util.EnumValues;\n+\n+/**\n+ * Specialized serializer for {@link EnumMap}s. Somewhat tricky to\n+ * implement because actual Enum value type may not be available;\n+ * and if not, it can only be gotten from actual instance.\n+ */\n+@JacksonStdImpl\n+public class EnumMapSerializer\n+    extends ContainerSerializerBase<EnumMap<? extends Enum<?>, ?>>\n+    implements ResolvableSerializer\n+{\n+    protected final boolean _staticTyping;\n+\n+    /**\n+     * If we know enumeration used as key, this will contain\n+     * value set to use for serialization\n+     */\n+    protected final EnumValues _keyEnums;\n+\n+    protected final JavaType _valueType;\n+\n+    /**\n+     * Property being serialized with this instance\n+     * \n+     * @since 1.7\n+     */\n+    protected final BeanProperty _property;\n+    \n+    /**\n+     * Value serializer to use, if it can be statically determined\n+     * \n+     * @since 1.5\n+     */\n+    protected JsonSerializer<Object> _valueSerializer;\n+\n+    /**\n+     * Type serializer used for values, if any.\n+     */\n+    protected final TypeSerializer _valueTypeSerializer;\n+\n+    /**\n+     * @deprecated Since 1.8, use variant that takes value serializer\n+     */\n+    @Deprecated\n+    public EnumMapSerializer(JavaType valueType, boolean staticTyping, EnumValues keyEnums,\n+            TypeSerializer vts, BeanProperty property)\n+    {\n+        this(valueType, staticTyping, keyEnums, vts, property, null);\n+    }\n+\n+    public EnumMapSerializer(JavaType valueType, boolean staticTyping, EnumValues keyEnums,\n+            TypeSerializer vts, BeanProperty property, JsonSerializer<Object> valueSerializer)\n+    {\n+        super(EnumMap.class, false);\n+        _staticTyping = staticTyping || (valueType != null && valueType.isFinal());\n+        _valueType = valueType;\n+        _keyEnums = keyEnums;\n+        _valueTypeSerializer = vts;\n+        _property = property;\n+        _valueSerializer = valueSerializer;\n+    }\n+\n+    @Override\n+    public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts)\n+    {\n+        return new EnumMapSerializer(_valueType, _staticTyping, _keyEnums, vts,  _property);\n+    }\n+    \n+    @Override\n+    public void serialize(EnumMap<? extends Enum<?>,?> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeStartObject();\n+        if (!value.isEmpty()) {\n+            serializeContents(value, jgen, provider);\n+        }        \n+        jgen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(EnumMap<? extends Enum<?>,?> value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        typeSer.writeTypePrefixForObject(value, jgen);\n+        if (!value.isEmpty()) {\n+            serializeContents(value, jgen, provider);\n+        }\n+        typeSer.writeTypeSuffixForObject(value, jgen);\n+    }\n+    \n+    protected void serializeContents(EnumMap<? extends Enum<?>,?> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_valueSerializer != null) {\n+            serializeContentsUsing(value, jgen, provider, _valueSerializer);\n+            return;\n+        }\n+        JsonSerializer<Object> prevSerializer = null;\n+        Class<?> prevClass = null;\n+        EnumValues keyEnums = _keyEnums;\n+\n+        for (Map.Entry<? extends Enum<?>,?> entry : value.entrySet()) {\n+            // First, serialize key\n+            Enum<?> key = entry.getKey();\n+            if (keyEnums == null) {\n+                /* 15-Oct-2009, tatu: This is clumsy, but still the simplest efficient\n+                 * way to do it currently, as Serializers get cached. (it does assume we'll always use\n+                 * default serializer tho -- so ideally code should be rewritten)\n+                 */\n+                // ... and lovely two-step casting process too...\n+                SerializerBase<?> ser = (SerializerBase<?>) provider.findValueSerializer(\n+                        key.getDeclaringClass(), _property);\n+                keyEnums = ((EnumSerializer) ser).getEnumValues();\n+            }\n+            jgen.writeFieldName(keyEnums.serializedValueFor(key));\n+            // And then value\n+            Object valueElem = entry.getValue();\n+            if (valueElem == null) {\n+                provider.defaultSerializeNull(jgen);\n+            } else {\n+                Class<?> cc = valueElem.getClass();\n+                JsonSerializer<Object> currSerializer;\n+                if (cc == prevClass) {\n+                    currSerializer = prevSerializer;\n+                } else {\n+                    currSerializer = provider.findValueSerializer(cc, _property);\n+                    prevSerializer = currSerializer;\n+                    prevClass = cc;\n+                }\n+                try {\n+                    currSerializer.serialize(valueElem, jgen, provider);\n+                } catch (Exception e) {\n+                    // [JACKSON-55] Need to add reference information\n+                    wrapAndThrow(provider, e, value, entry.getKey().name());\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void serializeContentsUsing(EnumMap<? extends Enum<?>,?> value, JsonGenerator jgen, SerializerProvider provider,\n+            JsonSerializer<Object> valueSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        EnumValues keyEnums = _keyEnums;\n+        for (Map.Entry<? extends Enum<?>,?> entry : value.entrySet()) {\n+            Enum<?> key = entry.getKey();\n+            if (keyEnums == null) {\n+                // clumsy, but has to do for now:\n+                SerializerBase<?> ser = (SerializerBase<?>) provider.findValueSerializer(key.getDeclaringClass(),\n+                        _property);\n+                keyEnums = ((EnumSerializer) ser).getEnumValues();\n+            }\n+            jgen.writeFieldName(keyEnums.serializedValueFor(key));\n+            Object valueElem = entry.getValue();\n+            if (valueElem == null) {\n+                provider.defaultSerializeNull(jgen);\n+            } else {\n+                try {\n+                    valueSer.serialize(valueElem, jgen, provider);\n+                } catch (Exception e) {\n+                    wrapAndThrow(provider, e, value, entry.getKey().name());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void resolve(SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        if (_staticTyping && _valueSerializer == null) {\n+            _valueSerializer = provider.findValueSerializer(_valueType, _property);\n+        }\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        ObjectNode o = createSchemaNode(\"object\", true);\n+        if (typeHint instanceof ParameterizedType) {\n+            Type[] typeArgs = ((ParameterizedType) typeHint).getActualTypeArguments();\n+            if (typeArgs.length == 2) {\n+                JavaType enumType = provider.constructType(typeArgs[0]);\n+                JavaType valueType = provider.constructType(typeArgs[1]);\n+                ObjectNode propsNode = JsonNodeFactory.instance.objectNode();\n+                Class<Enum<?>> enumClass = (Class<Enum<?>>) enumType.getRawClass();\n+                for (Enum<?> enumValue : enumClass.getEnumConstants()) {\n+                    JsonSerializer<Object> ser = provider.findValueSerializer(valueType.getRawClass(), _property);\n+                    JsonNode schemaNode = (ser instanceof SchemaAware) ?\n+                            ((SchemaAware) ser).getSchema(provider, null) :\n+                            JsonSchema.getDefaultSchemaNode();\n+                    propsNode.put(provider.getConfig().getAnnotationIntrospector().findEnumValue((Enum<?>)enumValue), schemaNode);\n+                }\n+                o.put(\"properties\", propsNode);\n+            }\n+        }\n+        return o;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import org.codehaus.jackson.*;\n+import org.codehaus.jackson.io.SerializedString;\n+import org.codehaus.jackson.node.ObjectNode;\n+import org.codehaus.jackson.node.ArrayNode;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n+import com.fasterxml.jackson.databind.util.EnumValues;\n+\n+/**\n+ * Standard serializer used for {@link java.lang.Enum} types.\n+ *<p>\n+ * Based on {@link ScalarSerializerBase} since the JSON value is\n+ * scalar (String).\n+ * \n+ * @author tatu\n+ */\n+@JacksonStdImpl\n+public class EnumSerializer\n+    extends ScalarSerializerBase<Enum<?>>\n+{\n+    /**\n+     * This map contains pre-resolved values (since there are ways\n+     * to customize actual String constants to use) to use as\n+     * serializations.\n+     */\n+    protected final EnumValues _values;\n+\n+    public EnumSerializer(EnumValues v) {\n+        super(Enum.class, false);\n+        _values = v;\n+    }\n+\n+    public static EnumSerializer construct(Class<Enum<?>> enumClass, SerializationConfig config,\n+            BasicBeanDescription beanDesc)\n+    {\n+        // [JACKSON-212]: If toString() is to be used instead, leave EnumValues null\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        EnumValues v = config.isEnabled(SerializationConfig.Feature.WRITE_ENUMS_USING_TO_STRING)\n+            ? EnumValues.constructFromToString(enumClass, intr) : EnumValues.constructFromName(enumClass, intr);\n+        return new EnumSerializer(v);\n+    }\n+    \n+    @Override\n+    public final void serialize(Enum<?> en, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        // [JACKSON-684]: serialize as index?\n+        if (provider.isEnabled(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX)) {\n+            jgen.writeNumber(en.ordinal());\n+            return;\n+        }\n+        jgen.writeString(_values.serializedValueFor(en));\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        // [JACKSON-684]: serialize as index?\n+        if (provider.isEnabled(SerializationConfig.Feature.WRITE_ENUMS_USING_INDEX)) {\n+            return createSchemaNode(\"integer\", true);\n+        }\n+        ObjectNode objectNode = createSchemaNode(\"string\", true);\n+        if (typeHint != null) {\n+            JavaType type = provider.constructType(typeHint);\n+            if (type.isEnumType()) {\n+                ArrayNode enumNode = objectNode.putArray(\"enum\");\n+                for (SerializedString value : _values.values()) {\n+                    enumNode.add(value.getValue());\n+                }\n+            }\n+        }\n+        return objectNode;\n+    }\n+\n+    public EnumValues getEnumValues() { return _values; }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.util.EnumSet;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+\n+public class EnumSetSerializer\n+    extends AsArraySerializerBase<EnumSet<? extends Enum<?>>>\n+{\n+    public EnumSetSerializer(JavaType elemType, BeanProperty property)\n+    {\n+        super(EnumSet.class, elemType, true, null, property, null);\n+    }\n+\n+    @Override\n+    public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n+        // no typing for enums (always \"hard\" type)\n+        return this;\n+    }\n+    \n+    @Override\n+    public void serializeContents(EnumSet<? extends Enum<?>> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        JsonSerializer<Object> enumSer = _elementSerializer;\n+        /* Need to dynamically find instance serializer; unfortunately\n+         * that seems to be the only way to figure out type (no accessors\n+         * to the enum class that set knows)\n+         */\n+        for (Enum<?> en : value) {\n+            if (enumSer == null) {\n+                /* 12-Jan-2010, tatu: Since enums can not be polymorphic, let's\n+                 *   not bother with typed serializer variant here\n+                 */\n+                enumSer = provider.findValueSerializer(en.getDeclaringClass(), _property);\n+            }\n+            enumSer.serialize(en, jgen, provider);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IndexedStringListSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ResolvableSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * Efficient implement for serializing {@link List}s that contains Strings and are random-accessible.\n+ * The only complexity is due to possibility that serializer for {@link String}\n+ * may be overridde; because of this, logic is needed to ensure that the default\n+ * serializer is in use to use fastest mode, or if not, to defer to custom\n+ * String serializer.\n+ * \n+ * @since 1.7\n+ */\n+@JacksonStdImpl\n+public final class IndexedStringListSerializer\n+    extends StaticListSerializerBase<List<String>>\n+    implements ResolvableSerializer\n+{\n+    protected JsonSerializer<String> _serializer;\n+    \n+    public IndexedStringListSerializer(BeanProperty property) {\n+        super(List.class, property);\n+    }\n+\n+    @Override protected JsonNode contentSchema() {\n+        return createSchemaNode(\"string\", true);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void resolve(SerializerProvider provider) throws JsonMappingException\n+    {\n+        JsonSerializer<?> ser = provider.findValueSerializer(String.class, _property);\n+        if (!isDefaultSerializer(ser)) {\n+            _serializer = (JsonSerializer<String>) ser;\n+        }\n+    }\n+\n+    @Override\n+    public void serialize(List<String> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeStartArray();\n+        if (_serializer == null) {\n+            serializeContents(value, jgen, provider);\n+        } else {\n+            serializeUsingCustom(value, jgen, provider);\n+        }\n+        jgen.writeEndArray();\n+    }\n+    \n+    @Override\n+    public void serializeWithType(List<String> value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        typeSer.writeTypePrefixForArray(value, jgen);\n+        if (_serializer == null) {\n+            serializeContents(value, jgen, provider);\n+        } else {\n+            serializeUsingCustom(value, jgen, provider);\n+        }\n+        typeSer.writeTypeSuffixForArray(value, jgen);\n+    }\n+    \n+    private final void serializeContents(List<String> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        int i = 0;\n+        try {\n+            final int len = value.size();\n+            for (; i < len; ++i) {\n+                String str = value.get(i);\n+                if (str == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                } else {\n+                    jgen.writeString(str);\n+                }\n+            }\n+        } catch (Exception e) {\n+            wrapAndThrow(provider, e, value, i);\n+        }\n+    }\n+\n+    private final void serializeUsingCustom(List<String> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        int i = 0;\n+        try {\n+            final int len = value.size();\n+            final JsonSerializer<String> ser = _serializer;\n+            for (i = 0; i < len; ++i) {\n+                String str = value.get(i);\n+                if (str == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                } else {\n+                    ser.serialize(str, jgen, provider);\n+                }\n+            }\n+        } catch (Exception e) {\n+            wrapAndThrow(provider, e, value, i);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/InetAddressSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+\n+/**\n+ * Simple serializer for {@link java.net.InetAddress}. Main complexity is\n+ * with registration, since same serializer is to be used for sub-classes.\n+ *\n+ * @since 1.8\n+ */\n+public class InetAddressSerializer\n+    extends ScalarSerializerBase<InetAddress>\n+{\n+    public final static InetAddressSerializer instance = new InetAddressSerializer();\n+    \n+    public InetAddressSerializer() { super(InetAddress.class); }\n+\n+    @Override\n+    public void serialize(InetAddress value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Ok: get textual description; choose \"more specific\" part\n+        String str = value.toString().trim();\n+        int ix = str.indexOf('/');\n+        if (ix >= 0) {\n+            if (ix == 0) { // missing host name; use address\n+                str = str.substring(1);\n+            } else { // otherwise use name\n+                str = str.substring(0, ix);\n+            }\n+        }\n+        jgen.writeString(str);\n+    }\n+\n+    @Override\n+    public void serializeWithType(InetAddress value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Better ensure we don't use specific sub-classes...\n+        typeSer.writeTypePrefixForScalar(value, jgen, InetAddress.class);\n+        serialize(value, jgen, provider);\n+        typeSer.writeTypeSuffixForScalar(value, jgen);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+@JacksonStdImpl\n+public class IterableSerializer\n+    extends AsArraySerializerBase<Iterable<?>>\n+{\n+    public IterableSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts, BeanProperty property)\n+    {\n+        super(Iterable.class, elemType, staticTyping, vts, property, null);\n+    }\n+\n+    @Override\n+    public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n+        return new IterableSerializer(_elementType, _staticTyping, vts, _property);\n+    }\n+    \n+    @Override\n+    public void serializeContents(Iterable<?> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        Iterator<?> it = value.iterator();\n+        if (it.hasNext()) {\n+            final TypeSerializer typeSer = _valueTypeSerializer;\n+            JsonSerializer<Object> prevSerializer = null;\n+            Class<?> prevClass = null;\n+            \n+            do {\n+                Object elem = it.next();\n+                if (elem == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                } else {\n+                    // Minor optimization to avoid most lookups:\n+                    Class<?> cc = elem.getClass();\n+                    JsonSerializer<Object> currSerializer;\n+                    if (cc == prevClass) {\n+                        currSerializer = prevSerializer;\n+                    } else {\n+                        currSerializer = provider.findValueSerializer(cc, _property);\n+                        prevSerializer = currSerializer;\n+                        prevClass = cc;\n+                    }\n+                    if (typeSer == null) {\n+                        currSerializer.serialize(elem, jgen, provider);\n+                    } else {\n+                        currSerializer.serializeWithType(elem, jgen, provider, typeSer);\n+                    }\n+                }\n+            } while (it.hasNext());\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/JsonValueSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Type;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.schema.SchemaAware;\n+import org.codehaus.jackson.schema.JsonSchema;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.ser.BeanSerializer;\n+\n+/**\n+ * Serializer class that can serialize Object that have a\n+ * {@link org.codehaus.jackson.annotate.JsonValue} annotation to\n+ * indicate that serialization should be done by calling the method\n+ * annotated, and serializing result it returns.\n+ * <p/>\n+ * Implementation note: we will post-process resulting serializer\n+ * (much like what is done with {@link BeanSerializer})\n+ * to figure out actual serializers for final types. This must be\n+ * done from {@link #resolve} method, and NOT from constructor;\n+ * otherwise we could end up with an infinite loop.\n+ */\n+@JacksonStdImpl\n+public class JsonValueSerializer\n+    extends SerializerBase<Object>\n+    implements ResolvableSerializer, SchemaAware\n+{\n+    protected final Method _accessorMethod;\n+\n+    protected JsonSerializer<Object> _valueSerializer;\n+\n+    protected final BeanProperty _property;\n+    \n+    /**\n+     * This is a flag that is set in rare (?) cases where this serializer\n+     * is used for \"natural\" types (boolean, int, String, double); and where\n+     * we actually must force type information wrapping, even though\n+     * one would not normally be added.\n+     * \n+     * @since 1.7\n+     */\n+    protected boolean _forceTypeInformation;\n+    \n+    /**\n+     * @param ser Explicit serializer to use, if caller knows it (which\n+     *            occurs if and only if the \"value method\" was annotated with\n+     *            {@link com.fasterxml.jackson.databind.annotate.JsonSerialize#using}), otherwise\n+     *            null\n+     */\n+    public JsonValueSerializer(Method valueMethod, JsonSerializer<Object> ser, BeanProperty property)\n+    {\n+        super(Object.class);\n+        _accessorMethod = valueMethod;\n+        _valueSerializer = ser;\n+        _property = property;\n+    }\n+\n+    @Override\n+    public void serialize(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws IOException, JsonGenerationException\n+    {\n+        try {\n+            Object value = _accessorMethod.invoke(bean);\n+\n+            if (value == null) {\n+                prov.defaultSerializeNull(jgen);\n+                return;\n+            }\n+            JsonSerializer<Object> ser = _valueSerializer;\n+            if (ser == null) {\n+                Class<?> c = value.getClass();\n+                /* 10-Mar-2010, tatu: Ideally we would actually separate out type\n+                 *   serializer from value serializer; but, alas, there's no access\n+                 *   to serializer factory at this point... \n+                 */\n+                // let's cache it, may be needed soon again\n+                ser = prov.findTypedValueSerializer(c, true, _property);\n+            }\n+            ser.serialize(value, jgen, prov);\n+        } catch (IOException ioe) {\n+            throw ioe;\n+        } catch (Exception e) {\n+            Throwable t = e;\n+            // Need to unwrap this specific type, to see infinite recursion...\n+            while (t instanceof InvocationTargetException && t.getCause() != null) {\n+                t = t.getCause();\n+            }\n+            // Errors shouldn't be wrapped (and often can't, as well)\n+            if (t instanceof Error) {\n+                throw (Error) t;\n+            }\n+            // let's try to indicate the path best we can...\n+            throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n+        }\n+    }\n+\n+    @Override\n+    public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException\n+    {\n+        // Regardless of other parts, first need to find value to serialize:\n+        Object value = null;\n+        try {\n+            value = _accessorMethod.invoke(bean);\n+\n+            // and if we got null, can also just write it directly\n+            if (value == null) {\n+                provider.defaultSerializeNull(jgen);\n+                return;\n+            }\n+            JsonSerializer<Object> ser = _valueSerializer;\n+            if (ser != null) { // already got a serializer? fabulous, that be easy...\n+                /* 09-Dec-2010, tatu: To work around natural type's refusal to add type info, we do\n+                 *    this (note: type is for the wrapper type, not enclosed value!)\n+                 */\n+                if (_forceTypeInformation) {\n+                    typeSer.writeTypePrefixForScalar(bean, jgen);\n+                } \n+                ser.serializeWithType(value, jgen, provider, typeSer);\n+                if (_forceTypeInformation) {\n+                    typeSer.writeTypeSuffixForScalar(bean, jgen);\n+                } \n+                return;\n+            }\n+            // But if not, it gets tad trickier (copied from main serialize() method)\n+            Class<?> c = value.getClass();\n+            ser = provider.findTypedValueSerializer(c, true, _property);\n+            // note: now we have bundled type serializer, so should NOT call with typed version\n+            ser.serialize(value, jgen, provider);\n+        } catch (IOException ioe) {\n+            throw ioe;\n+        } catch (Exception e) {\n+            Throwable t = e;\n+            // Need to unwrap this specific type, to see infinite recursion...\n+            while (t instanceof InvocationTargetException && t.getCause() != null) {\n+                t = t.getCause();\n+            }\n+            // Errors shouldn't be wrapped (and often can't, as well)\n+            if (t instanceof Error) {\n+                throw (Error) t;\n+            }\n+            // let's try to indicate the path best we can...\n+            throw JsonMappingException.wrapWithPath(t, bean, _accessorMethod.getName() + \"()\");\n+        }\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return (_valueSerializer instanceof SchemaAware) ?\n+                ((SchemaAware) _valueSerializer).getSchema(provider, null) :\n+                JsonSchema.getDefaultSchemaNode();\n+    }\n+    \n+    /*\n+    /*******************************************************\n+    /* ResolvableSerializer impl\n+    /*******************************************************\n+     */\n+\n+    /**\n+     * We can try to find the actual serializer for value, if we can\n+     * statically figure out what the result type must be.\n+     */\n+    @Override\n+    public void resolve(SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        if (_valueSerializer == null) {\n+            /* Note: we can only assign serializer statically if the\n+             * declared type is final -- if not, we don't really know\n+             * the actual type until we get the instance.\n+             */\n+            // 10-Mar-2010, tatu: Except if static typing is to be used\n+            if (provider.isEnabled(SerializationConfig.Feature.USE_STATIC_TYPING)\n+                    || Modifier.isFinal(_accessorMethod.getReturnType().getModifiers())) {\n+                JavaType t = provider.constructType(_accessorMethod.getGenericReturnType());\n+                // false -> no need to cache\n+                /* 10-Mar-2010, tatu: Ideally we would actually separate out type\n+                 *   serializer from value serializer; but, alas, there's no access\n+                 *   to serializer factory at this point... \n+                 */\n+                _valueSerializer = provider.findTypedValueSerializer(t, false, _property);\n+                /* 09-Dec-2010, tatu: Turns out we must add special handling for\n+                 *   cases where \"native\" (aka \"natural\") type is being serialized,\n+                 *   using standard serializer\n+                 */\n+                _forceTypeInformation = isNaturalTypeWithStdHandling(t, _valueSerializer);\n+            }\n+        }\n+    }\n+\n+    protected boolean isNaturalTypeWithStdHandling(JavaType type, JsonSerializer<?> ser)\n+    {\n+        Class<?> cls = type.getRawClass();\n+        // First: do we have a natural type being handled?\n+        if (type.isPrimitive()) {\n+            if (cls != Integer.TYPE && cls != Boolean.TYPE && cls != Double.TYPE) {\n+                return false;\n+            }\n+        } else {\n+            if (cls != String.class &&\n+                    cls != Integer.class && cls != Boolean.class && cls != Double.class) {\n+                return false;\n+            }\n+        }\n+        // Second: and it's handled with standard serializer?\n+        return (ser.getClass().getAnnotation(JacksonStdImpl.class)) != null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Other methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"(@JsonValue serializer for method \" + _accessorMethod.getDeclaringClass() + \"#\" + _accessorMethod.getName() + \")\";\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.*;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+import org.codehaus.jackson.node.ObjectNode;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Standard serializer implementation for serializing {link java.util.Map} types.\n+ *<p>\n+ * Note: about the only configurable setting currently is ability to filter out\n+ * entries with specified names.\n+ */\n+@JacksonStdImpl\n+public class MapSerializer\n+    extends ContainerSerializerBase<Map<?,?>>\n+    implements ResolvableSerializer\n+{\n+    protected final static JavaType UNSPECIFIED_TYPE = TypeFactory.unknownType();\n+    \n+    /**\n+     * Map-valued property being serialized with this instance\n+     * \n+     * @since 1.7\n+     */\n+    protected final BeanProperty _property;\n+    \n+    /**\n+     * Set of entries to omit during serialization, if any\n+     */\n+    protected final HashSet<String> _ignoredEntries;\n+\n+    /**\n+     * Whether static types should be used for serialization of values\n+     * or not (if not, dynamic runtime type is used)\n+     */\n+    protected final boolean _valueTypeIsStatic;\n+\n+    /**\n+     * Declared type of keys\n+     * \n+     * @since 1.7\n+     */\n+    protected final JavaType _keyType;\n+\n+    /**\n+     * Declared type of contained values\n+     */\n+    protected final JavaType _valueType;\n+\n+    /**\n+     * Key serializer to use, if it can be statically determined\n+     * \n+     * @since 1.7\n+     */\n+    protected JsonSerializer<Object> _keySerializer;\n+\n+    /**\n+     * Value serializer to use, if it can be statically determined\n+     * \n+     * @since 1.5\n+     */\n+    protected JsonSerializer<Object> _valueSerializer;\n+\n+    /**\n+     * Type identifier serializer used for values, if any.\n+     */\n+    protected final TypeSerializer _valueTypeSerializer;\n+\n+    /**\n+     * If value type can not be statically determined, mapping from\n+     * runtime value types to serializers are stored in this object.\n+     * \n+     * @since 1.8\n+     */\n+    protected PropertySerializerMap _dynamicValueSerializers;\n+    \n+    protected MapSerializer() {\n+        this((HashSet<String>)null, null, null, false, null, null, null, null);\n+    }\n+    \n+    protected MapSerializer(HashSet<String> ignoredEntries,\n+            JavaType keyType, JavaType valueType, boolean valueTypeIsStatic,\n+            TypeSerializer vts,\n+            JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer, \n+            BeanProperty property)\n+    {\n+        super(Map.class, false);\n+        _property = property;\n+        _ignoredEntries = ignoredEntries;\n+        _keyType = keyType;\n+        _valueType = valueType;\n+        _valueTypeIsStatic = valueTypeIsStatic;\n+        _valueTypeSerializer = vts;\n+        _keySerializer = keySerializer;\n+        _valueSerializer = valueSerializer;\n+        _dynamicValueSerializers = PropertySerializerMap.emptyMap();\n+    }\n+    \n+    @Override\n+    public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts)\n+    {\n+        MapSerializer ms = new MapSerializer(_ignoredEntries, _keyType, _valueType, _valueTypeIsStatic, vts,\n+                _keySerializer, _valueSerializer, _property);\n+        if (_valueSerializer != null) {\n+            ms._valueSerializer = _valueSerializer;\n+        }\n+        return ms;\n+    }\n+    \n+    /**\n+     * Factory method used to construct Map serializers.\n+     * \n+     * @param ignoredList Array of entry names that are to be filtered on\n+     *    serialization; null if none\n+     * @param mapType Declared type information (needed for static typing)\n+     * @param staticValueType Whether static typing should be used for the\n+     *    Map (which includes its contents)\n+     * @param vts Type serializer to use for map entry values, if any\n+     * \n+     * @deprecated As of 1.8; use the variant with more arguments\n+     */\n+    @Deprecated\n+    public static MapSerializer construct(String[] ignoredList, JavaType mapType,\n+            boolean staticValueType, TypeSerializer vts, BeanProperty property)\n+    {\n+        return construct(ignoredList, mapType, staticValueType, vts, property, null, null);\n+    }\n+\n+    public static MapSerializer construct(String[] ignoredList, JavaType mapType,\n+            boolean staticValueType, TypeSerializer vts, BeanProperty property,\n+            JsonSerializer<Object> keySerializer, JsonSerializer<Object> valueSerializer)\n+    {\n+        HashSet<String> ignoredEntries = toSet(ignoredList);\n+        JavaType keyType, valueType;\n+        \n+        if (mapType == null) {\n+            keyType = valueType = UNSPECIFIED_TYPE;\n+        } else { \n+            keyType = mapType.getKeyType();\n+            valueType = mapType.getContentType();\n+        }\n+        // If value type is final, it's same as forcing static value typing:\n+        if (!staticValueType) {\n+            staticValueType = (valueType != null && valueType.isFinal());\n+        }\n+        return new MapSerializer(ignoredEntries, keyType, valueType, staticValueType, vts,\n+                keySerializer, valueSerializer, property);\n+    }\n+\n+    private static HashSet<String> toSet(String[] ignoredEntries) {\n+        if (ignoredEntries == null || ignoredEntries.length == 0) {\n+            return null;\n+        }\n+        HashSet<String> result = new HashSet<String>(ignoredEntries.length);\n+        for (String prop : ignoredEntries) {\n+            result.add(prop);\n+        }\n+        return result;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonSerializer implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void serialize(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeStartObject();\n+        if (!value.isEmpty()) {\n+            if (_valueSerializer != null) {\n+                serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n+            } else {\n+                serializeFields(value, jgen, provider);\n+            }\n+        }        \n+        jgen.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        typeSer.writeTypePrefixForObject(value, jgen);\n+        if (!value.isEmpty()) {\n+            if (_valueSerializer != null) {\n+                serializeFieldsUsing(value, jgen, provider, _valueSerializer);\n+            } else {\n+                serializeFields(value, jgen, provider);\n+            }\n+        }\n+        typeSer.writeTypeSuffixForObject(value, jgen);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonSerializer implementation\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method called to serialize fields, when the value type is not statically known.\n+     */\n+    public void serializeFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        // If value type needs polymorphic type handling, some more work needed:\n+        if (_valueTypeSerializer != null) {\n+            serializeTypedFields(value, jgen, provider);\n+            return;\n+        }\n+        final JsonSerializer<Object> keySerializer = _keySerializer;\n+        \n+        final HashSet<String> ignored = _ignoredEntries;\n+        final boolean skipNulls = !provider.isEnabled(SerializationConfig.Feature.WRITE_NULL_MAP_VALUES);\n+\n+        PropertySerializerMap serializers = _dynamicValueSerializers;\n+\n+        for (Map.Entry<?,?> entry : value.entrySet()) {\n+            Object valueElem = entry.getValue();\n+            // First, serialize key\n+            Object keyElem = entry.getKey();\n+            if (keyElem == null) {\n+                provider.getNullKeySerializer().serialize(null, jgen, provider);\n+            } else {\n+                // [JACKSON-314] skip entries with null values?\n+                if (skipNulls && valueElem == null) continue;\n+                // One twist: is entry ignorable? If so, skip\n+                if (ignored != null && ignored.contains(keyElem)) continue;\n+                keySerializer.serialize(keyElem, jgen, provider);\n+            }\n+\n+            // And then value\n+            if (valueElem == null) {\n+                provider.defaultSerializeNull(jgen);\n+            } else {\n+                Class<?> cc = valueElem.getClass();\n+                JsonSerializer<Object> serializer = serializers.serializerFor(cc);\n+                if (serializer == null) {\n+                    if (_valueType.hasGenericTypes()) {\n+                        serializer = _findAndAddDynamic(serializers,\n+                                provider.constructSpecializedType(_valueType, cc), provider);\n+                    } else {\n+                        serializer = _findAndAddDynamic(serializers, cc, provider);\n+                    }\n+                    serializers = _dynamicValueSerializers;\n+                }\n+                try {\n+                    serializer.serialize(valueElem, jgen, provider);\n+                } catch (Exception e) {\n+                    // [JACKSON-55] Need to add reference information\n+                    String keyDesc = \"\"+keyElem;\n+                    wrapAndThrow(provider, e, value, keyDesc);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Method called to serialize fields, when the value type is statically known,\n+     * so that value serializer is passed and does not need to be fetched from\n+     * provider.\n+     */\n+    protected void serializeFieldsUsing(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider,\n+            JsonSerializer<Object> ser)\n+            throws IOException, JsonGenerationException\n+    {\n+        final JsonSerializer<Object> keySerializer = _keySerializer;\n+        final HashSet<String> ignored = _ignoredEntries;\n+        final TypeSerializer typeSer = _valueTypeSerializer;\n+        final boolean skipNulls = !provider.isEnabled(SerializationConfig.Feature.WRITE_NULL_MAP_VALUES);\n+\n+        for (Map.Entry<?,?> entry : value.entrySet()) {\n+            Object valueElem = entry.getValue();\n+            Object keyElem = entry.getKey();\n+            if (keyElem == null) {\n+                provider.getNullKeySerializer().serialize(null, jgen, provider);\n+            } else {\n+                // [JACKSON-314] also may need to skip entries with null values\n+                if (skipNulls && valueElem == null) continue;\n+                if (ignored != null && ignored.contains(keyElem)) continue;\n+                keySerializer.serialize(keyElem, jgen, provider);\n+            }\n+            if (valueElem == null) {\n+                provider.defaultSerializeNull(jgen);\n+            } else {\n+                try {\n+                    if (typeSer == null) {\n+                        ser.serialize(valueElem, jgen, provider);\n+                    } else {\n+                        ser.serializeWithType(valueElem, jgen, provider, typeSer);\n+                    }\n+                } catch (Exception e) {\n+                    // [JACKSON-55] Need to add reference information\n+                    String keyDesc = \"\"+keyElem;\n+                    wrapAndThrow(provider, e, value, keyDesc);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void serializeTypedFields(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final JsonSerializer<Object> keySerializer = _keySerializer;\n+        JsonSerializer<Object> prevValueSerializer = null;\n+        Class<?> prevValueClass = null;\n+        final HashSet<String> ignored = _ignoredEntries;\n+        final boolean skipNulls = !provider.isEnabled(SerializationConfig.Feature.WRITE_NULL_MAP_VALUES);\n+    \n+        for (Map.Entry<?,?> entry : value.entrySet()) {\n+            Object valueElem = entry.getValue();\n+            // First, serialize key\n+            Object keyElem = entry.getKey();\n+            if (keyElem == null) {\n+                provider.getNullKeySerializer().serialize(null, jgen, provider);\n+            } else {\n+                // [JACKSON-314] also may need to skip entries with null values\n+                if (skipNulls && valueElem == null) continue;\n+                // One twist: is entry ignorable? If so, skip\n+                if (ignored != null && ignored.contains(keyElem)) continue;\n+                keySerializer.serialize(keyElem, jgen, provider);\n+            }\n+    \n+            // And then value\n+            if (valueElem == null) {\n+                provider.defaultSerializeNull(jgen);\n+            } else {\n+                Class<?> cc = valueElem.getClass();\n+                JsonSerializer<Object> currSerializer;\n+                if (cc == prevValueClass) {\n+                    currSerializer = prevValueSerializer;\n+                } else {\n+                    currSerializer = provider.findValueSerializer(cc, _property);\n+                    prevValueSerializer = currSerializer;\n+                    prevValueClass = cc;\n+                }\n+                try {\n+                    currSerializer.serializeWithType(valueElem, jgen, provider, _valueTypeSerializer);\n+                } catch (Exception e) {\n+                    // [JACKSON-55] Need to add reference information\n+                    String keyDesc = \"\"+keyElem;\n+                    wrapAndThrow(provider, e, value, keyDesc);\n+                }\n+            }\n+        }\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        ObjectNode o = createSchemaNode(\"object\", true);\n+        //(ryan) even though it's possible to statically determine the \"value\" type of the map,\n+        // there's no way to statically determine the keys, so the \"Entries\" can't be determined.\n+        return o;\n+    }\n+\n+    /**\n+     * Need to get callback to resolve value serializer, if static typing\n+     * is used (either being forced, or because value type is final)\n+     */\n+    @Override\n+    public void resolve(SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        if (_valueTypeIsStatic && _valueSerializer == null) {\n+            _valueSerializer = provider.findValueSerializer(_valueType, _property);\n+        }\n+        /* 10-Dec-2010, tatu: Let's also fetch key serializer; and always assume we'll\n+         *   do that just by using static type information\n+         */\n+        /* 25-Feb-2011, tatu: May need to reconsider this static checking (since it\n+         *   differs from value handling)... but for now, it's ok to ensure contextual\n+         *   aspects are handled; this is done by provider.\n+         */\n+        if (_keySerializer == null) {\n+            _keySerializer = provider.findKeySerializer(_keyType, _property);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            Class<?> type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property);\n+        // did we get a new map of serializers? If so, start using it\n+        if (map != result.map) {\n+            _dynamicValueSerializers = result.map;\n+        }\n+        return result.serializer;\n+    }\n+\n+    protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            JavaType type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property);\n+        if (map != result.map) {\n+            _dynamicValueSerializers = result.map;\n+        }\n+        return result.serializer;\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NonTypedScalarSerializerBase.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+\n+/**\n+ * Intermediate base class for limited number of scalar types\n+ * that should never include type information. These are \"native\"\n+ * types that are default mappings for corresponding JSON scalar\n+ * types: {@link java.lang.String}, {@link java.lang.Integer},\n+ * {@link java.lang.Double} and {@link java.lang.Boolean}.\n+ * \n+ * @since 1.9 (refactored from 'org.codehaus.jackson.map.StdSerializers#NontTypedScalarSerializer')\n+ */\n+public abstract class NonTypedScalarSerializerBase<T>\n+    extends ScalarSerializerBase<T>\n+{\n+    protected NonTypedScalarSerializerBase(Class<T> t) {\n+        super(t);\n+    }\n+\n+    @Override\n+    public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        // no type info, just regular serialization\n+        serialize(value, jgen, provider);            \n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NullSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.lang.reflect.Type;\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * This is a simple dummy serializer that will just output literal\n+ * JSON null value whenever serialization is requested.\n+ * Used as the default \"null serializer\" (which is used for serializing\n+ * null object references unless overridden), as well as for some\n+ * more exotic types (java.lang.Void).\n+ */\n+@JacksonStdImpl\n+public class NullSerializer\n+    extends SerializerBase<Object>\n+{\n+    public final static NullSerializer instance = new NullSerializer();\n+    \n+    private NullSerializer() { super(Object.class); }\n+    \n+    @Override\n+    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeNull();\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return createSchemaNode(\"null\");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Type;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+import org.codehaus.jackson.node.ObjectNode;\n+import org.codehaus.jackson.schema.JsonSchema;\n+import org.codehaus.jackson.schema.SchemaAware;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ResolvableSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+import com.fasterxml.jackson.databind.type.ArrayType;\n+\n+/**\n+ * Generic serializer for Object arrays (<code>Object[]</code>).\n+ * \n+ * @since 1.9 (moved from 'org.codehaus.jackson.map.ser.impl.ObjectArraySerializer')\n+ */\n+@JacksonStdImpl\n+public class ObjectArraySerializer\n+    extends StdArraySerializers.ArraySerializerBase<Object[]>\n+    implements ResolvableSerializer\n+{\n+    /**\n+     * Whether we are using static typing (using declared types, ignoring\n+     * runtime type) or not for elements.\n+     */\n+    protected final boolean _staticTyping;\n+\n+    /**\n+     * Declared type of element entries\n+     */\n+    protected final JavaType _elementType;\n+\n+    /**\n+     * Value serializer to use, if it can be statically determined.\n+     * \n+     * @since 1.5\n+     */\n+    protected JsonSerializer<Object> _elementSerializer;\n+\n+    /**\n+     * If element type can not be statically determined, mapping from\n+     * runtime type to serializer is handled using this object\n+     * \n+     * @since 1.7\n+     */\n+    protected PropertySerializerMap _dynamicSerializers;\n+    \n+    /**\n+     * @deprecated since 1.8\n+     */\n+    @Deprecated\n+    public ObjectArraySerializer(JavaType elemType, boolean staticTyping,\n+            TypeSerializer vts, BeanProperty property)\n+    {\n+        this(elemType, staticTyping, vts, property, null);\n+    }\n+    \n+    public ObjectArraySerializer(JavaType elemType, boolean staticTyping,\n+            TypeSerializer vts, BeanProperty property, JsonSerializer<Object> elementSerializer)\n+    {\n+        super(Object[].class, vts, property);\n+        _elementType = elemType;\n+        _staticTyping = staticTyping;\n+        _dynamicSerializers = PropertySerializerMap.emptyMap();\n+        _elementSerializer = elementSerializer;\n+    }\n+\n+    @Override\n+    public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts)\n+    {\n+        return new ObjectArraySerializer(_elementType, _staticTyping, vts, _property, _elementSerializer);\n+    }\n+    \n+    @Override\n+    public void serializeContents(Object[] value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final int len = value.length;\n+        if (len == 0) {\n+            return;\n+        }\n+        if (_elementSerializer != null) {\n+            serializeContentsUsing(value, jgen, provider, _elementSerializer);\n+            return;\n+        }\n+        if (_valueTypeSerializer != null) {\n+            serializeTypedContents(value, jgen, provider);\n+            return;\n+        }\n+        int i = 0;\n+        Object elem = null;\n+        try {\n+            PropertySerializerMap serializers = _dynamicSerializers;\n+            for (; i < len; ++i) {\n+                elem = value[i];\n+                if (elem == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                    continue;\n+                }\n+                Class<?> cc = elem.getClass();\n+                JsonSerializer<Object> serializer = serializers.serializerFor(cc);\n+                if (serializer == null) {\n+                    // To fix [JACKSON-508]\n+                    if (_elementType.hasGenericTypes()) {\n+                        serializer = _findAndAddDynamic(serializers,\n+                                provider.constructSpecializedType(_elementType, cc), provider);\n+                    } else {\n+                        serializer = _findAndAddDynamic(serializers, cc, provider);\n+                    }\n+                }\n+                serializer.serialize(elem, jgen, provider);\n+            }\n+        } catch (IOException ioe) {\n+            throw ioe;\n+        } catch (Exception e) {\n+            // [JACKSON-55] Need to add reference information\n+            /* 05-Mar-2009, tatu: But one nasty edge is when we get\n+             *   StackOverflow: usually due to infinite loop. But that gets\n+             *   hidden within an InvocationTargetException...\n+             */\n+            Throwable t = e;\n+            while (t instanceof InvocationTargetException && t.getCause() != null) {\n+                t = t.getCause();\n+            }\n+            if (t instanceof Error) {\n+                throw (Error) t;\n+            }\n+            throw JsonMappingException.wrapWithPath(t, elem, i);\n+        }\n+    }\n+\n+    public void serializeContentsUsing(Object[] value, JsonGenerator jgen, SerializerProvider provider,\n+            JsonSerializer<Object> ser)\n+        throws IOException, JsonGenerationException\n+    {\n+        final int len = value.length;\n+        final TypeSerializer typeSer = _valueTypeSerializer;\n+\n+        int i = 0;\n+        Object elem = null;\n+        try {\n+            for (; i < len; ++i) {\n+                elem = value[i];\n+                if (elem == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                    continue;\n+                }\n+                if (typeSer == null) {\n+                    ser.serialize(elem, jgen, provider);\n+                } else {\n+                    ser.serializeWithType(elem, jgen, provider, typeSer);\n+                }\n+            }\n+        } catch (IOException ioe) {\n+            throw ioe;\n+        } catch (Exception e) {\n+            Throwable t = e;\n+            while (t instanceof InvocationTargetException && t.getCause() != null) {\n+                t = t.getCause();\n+            }\n+            if (t instanceof Error) {\n+                throw (Error) t;\n+            }\n+            throw JsonMappingException.wrapWithPath(t, elem, i);\n+        }\n+    }\n+\n+    public void serializeTypedContents(Object[] value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final int len = value.length;\n+        final TypeSerializer typeSer = _valueTypeSerializer;\n+        int i = 0;\n+        Object elem = null;\n+        try {\n+            PropertySerializerMap serializers = _dynamicSerializers;\n+            for (; i < len; ++i) {\n+                elem = value[i];\n+                if (elem == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                    continue;\n+                }\n+                Class<?> cc = elem.getClass();\n+                JsonSerializer<Object> serializer = serializers.serializerFor(cc);\n+                if (serializer == null) {\n+                    serializer = _findAndAddDynamic(serializers, cc, provider);\n+                }\n+                serializer.serializeWithType(elem, jgen, provider, typeSer);\n+            }\n+        } catch (IOException ioe) {\n+            throw ioe;\n+        } catch (Exception e) {\n+            Throwable t = e;\n+            while (t instanceof InvocationTargetException && t.getCause() != null) {\n+                t = t.getCause();\n+            }\n+            if (t instanceof Error) {\n+                throw (Error) t;\n+            }\n+            throw JsonMappingException.wrapWithPath(t, elem, i);\n+        }\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        ObjectNode o = createSchemaNode(\"array\", true);\n+        if (typeHint != null) {\n+            JavaType javaType = provider.constructType(typeHint);\n+            if (javaType.isArrayType()) {\n+                Class<?> componentType = ((ArrayType) javaType).getContentType().getRawClass();\n+                // 15-Oct-2010, tatu: We can't serialize plain Object.class; but what should it produce here? Untyped?\n+                if (componentType == Object.class) {\n+                    o.put(\"items\", JsonSchema.getDefaultSchemaNode());\n+                } else {\n+                    JsonSerializer<Object> ser = provider.findValueSerializer(componentType, _property);\n+                    JsonNode schemaNode = (ser instanceof SchemaAware) ?\n+                            ((SchemaAware) ser).getSchema(provider, null) :\n+                            JsonSchema.getDefaultSchemaNode();\n+                    o.put(\"items\", schemaNode);\n+                }\n+            }\n+        }\n+        return o;\n+    }\n+\n+    /**\n+     * Need to get callback to resolve value serializer, if static typing\n+     * is used (either being forced, or because value type is final)\n+     */\n+    @Override\n+    public void resolve(SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        if (_staticTyping && _elementSerializer == null) {\n+            _elementSerializer = provider.findValueSerializer(_elementType, _property);\n+        }\n+    }        \n+\n+    /**\n+     * @since 1.7\n+     */\n+    protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            Class<?> type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property);\n+        // did we get a new map of serializers? If so, start using it\n+        if (map != result.map) {\n+            _dynamicSerializers = result.map;\n+        }\n+        return result.serializer;\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n+            JavaType type, SerializerProvider provider) throws JsonMappingException\n+    {\n+        PropertySerializerMap.SerializerAndMapResult result = map.findAndAddSerializer(type, provider, _property);\n+        // did we get a new map of serializers? If so, start using it\n+        if (map != result.map) {\n+            _dynamicSerializers = result.map;\n+        }\n+        return result.serializer;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.lang.reflect.Type;\n+import java.io.IOException;\n+\n+import org.codehaus.jackson.*;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * This is a simple dummy serializer that will just output raw values by calling toString()\n+ * on value to serialize.\n+ * \n+ * @since 1.7\n+ */\n+@JacksonStdImpl\n+public class RawSerializer<T>\n+    extends SerializerBase<T>\n+{\n+    /**\n+     * Constructor takes in expected type of values; but since caller\n+     * typically can not really provide actual type parameter, we will\n+     * just take wild card and coerce type.\n+     */\n+    public RawSerializer(Class<?> cls) {\n+        super(cls, false);\n+    }\n+\n+    @Override\n+    public void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeRawValue(value.toString());\n+    }\n+\n+    @Override\n+    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException\n+    {\n+        typeSer.writeTypePrefixForScalar(value, jgen);\n+        serialize(value, jgen, provider);\n+        typeSer.writeTypeSuffixForScalar(value, jgen);\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        // type not really known, but since it is a JSON string:\n+        return createSchemaNode(\"string\", true);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ScalarSerializerBase.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+\n+public abstract class ScalarSerializerBase<T>\n+    extends SerializerBase<T>\n+{\n+    protected ScalarSerializerBase(Class<T> t) {\n+        super(t);\n+    }\n+\n+    /**\n+     * Alternate constructor that is (alas!) needed to work\n+     * around kinks of generic type handling\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected ScalarSerializerBase(Class<?> t, boolean dummy) {\n+        super((Class<T>) t);\n+    }\n+    \n+    /**\n+     * Default implementation will write type prefix, call regular serialization\n+     * method (since assumption is that value itself does not need JSON\n+     * Array or Object start/end markers), and then write type suffix.\n+     * This should work for most cases; some sub-classes may want to\n+     * change this behavior.\n+     */\n+    @Override\n+    public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        typeSer.writeTypePrefixForScalar(value, jgen);\n+        serialize(value, jgen, provider);\n+        typeSer.writeTypeSuffixForScalar(value, jgen);\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return createSchemaNode(\"string\", true);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+import org.codehaus.jackson.node.ObjectNode;\n+import org.codehaus.jackson.schema.JsonSerializableSchema;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializable;\n+import com.fasterxml.jackson.databind.JsonSerializableWithType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.ser.SerializerBase;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Generic handler for types that implement {@link JsonSerializable}.\n+ *<p>\n+ * Note: given that this is used for anything that implements\n+ * interface, can not be checked for direct class equivalence.\n+ */\n+@JacksonStdImpl\n+@SuppressWarnings(\"deprecation\")\n+public class SerializableSerializer\n+    extends SerializerBase<JsonSerializable>\n+{\n+    public final static SerializableSerializer instance = new SerializableSerializer();\n+\n+    protected SerializableSerializer() { super(JsonSerializable.class); }\n+\n+    @Override\n+    public void serialize(JsonSerializable value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        value.serialize(jgen, provider);\n+    }\n+\n+    @Override\n+    public final void serializeWithType(JsonSerializable value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        /* 24-Jan-2009, tatus: This is not quite optimal (perhaps we should\n+         *   just create separate serializer...), but works until 2.0 will\n+         *   deprecate non-typed interface\n+         */\n+        if (value instanceof JsonSerializableWithType) {\n+            ((JsonSerializableWithType) value).serializeWithType(jgen, provider, typeSer);\n+        } else {\n+            this.serialize(value, jgen, provider);\n+        }\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        ObjectNode objectNode = createObjectNode();\n+        String schemaType = \"any\";\n+        String objectProperties = null;\n+        String itemDefinition = null;\n+        if (typeHint != null) {\n+            Class<?> rawClass = TypeFactory.type(typeHint).getRawClass();\n+            if (rawClass.isAnnotationPresent(JsonSerializableSchema.class)) {\n+                JsonSerializableSchema schemaInfo = rawClass.getAnnotation(JsonSerializableSchema.class);\n+                schemaType = schemaInfo.schemaType();\n+                if (!\"##irrelevant\".equals(schemaInfo.schemaObjectPropertiesDefinition())) {\n+                    objectProperties = schemaInfo.schemaObjectPropertiesDefinition();\n+                }\n+                if (!\"##irrelevant\".equals(schemaInfo.schemaItemDefinition())) {\n+                    itemDefinition = schemaInfo.schemaItemDefinition();\n+                }\n+            }\n+        }\n+        objectNode.put(\"type\", schemaType);\n+        if (objectProperties != null) {\n+            try {\n+                objectNode.put(\"properties\", new ObjectMapper().readValue(objectProperties, JsonNode.class));\n+            } catch (IOException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+        if (itemDefinition != null) {\n+            try {\n+                objectNode.put(\"items\", new ObjectMapper().readValue(itemDefinition, JsonNode.class));\n+            } catch (IOException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+        // always optional, no need to specify:\n+        //objectNode.put(\"required\", false);\n+        return objectNode;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializableWithTypeSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+import org.codehaus.jackson.node.ObjectNode;\n+import org.codehaus.jackson.schema.JsonSerializableSchema;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializableWithType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Generic handler for types that implement {@link JsonSerializableWithType}.\n+ *<p>\n+ * Note: given that this is used for anything that implements\n+ * interface, can not be checked for direct class equivalence.\n+ */\n+@JacksonStdImpl\n+public class SerializableWithTypeSerializer\n+    extends SerializerBase<JsonSerializableWithType>\n+{\n+    public final static SerializableWithTypeSerializer instance = new SerializableWithTypeSerializer();\n+\n+    protected SerializableWithTypeSerializer() { super(JsonSerializableWithType.class); }\n+\n+    @SuppressWarnings(\"deprecation\") // why is this needed?\n+    @Override\n+    public void serialize(JsonSerializableWithType value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        value.serialize(jgen, provider);\n+    }\n+\n+    @Override\n+    public final void serializeWithType(JsonSerializableWithType value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        value.serializeWithType(jgen, provider, typeSer);\n+    }\n+    \n+    // copied verbatim from \"JsonSerializableSerializer\"\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        ObjectNode objectNode = createObjectNode();\n+        String schemaType = \"any\";\n+        String objectProperties = null;\n+        String itemDefinition = null;\n+        if (typeHint != null) {\n+            Class<?> rawClass = TypeFactory.rawClass(typeHint);\n+            if (rawClass.isAnnotationPresent(JsonSerializableSchema.class)) {\n+                JsonSerializableSchema schemaInfo = rawClass.getAnnotation(JsonSerializableSchema.class);\n+                schemaType = schemaInfo.schemaType();\n+                if (!\"##irrelevant\".equals(schemaInfo.schemaObjectPropertiesDefinition())) {\n+                    objectProperties = schemaInfo.schemaObjectPropertiesDefinition();\n+                }\n+                if (!\"##irrelevant\".equals(schemaInfo.schemaItemDefinition())) {\n+                    itemDefinition = schemaInfo.schemaItemDefinition();\n+                }\n+            }\n+        }\n+        objectNode.put(\"type\", schemaType);\n+        if (objectProperties != null) {\n+            try {\n+                objectNode.put(\"properties\", new ObjectMapper().readValue(objectProperties, JsonNode.class));\n+            } catch (IOException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+        if (itemDefinition != null) {\n+            try {\n+                objectNode.put(\"items\", new ObjectMapper().readValue(itemDefinition, JsonNode.class));\n+            } catch (IOException e) {\n+                throw new IllegalStateException(e);\n+            }\n+        }\n+        // always optional, no need to specify:\n+        //objectNode.put(\"required\", false);\n+        return objectNode;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/SerializerBase.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+import org.codehaus.jackson.node.JsonNodeFactory;\n+import org.codehaus.jackson.node.ObjectNode;\n+import org.codehaus.jackson.schema.SchemaAware;\n+\n+/**\n+ * Base class used by all standard serializers. Provides some convenience\n+ * methods for implementing {@link SchemaAware}\n+ */\n+public abstract class SerializerBase<T>\n+    extends JsonSerializer<T>\n+    implements SchemaAware\n+{\n+    protected final Class<T> _handledType;\n+    \n+    protected SerializerBase(Class<T> t) {\n+        _handledType = t;\n+    }\n+\n+    /**\n+     * @since 1.7\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected SerializerBase(JavaType type) {\n+        _handledType = (Class<T>) type.getRawClass();\n+    }\n+    \n+    /**\n+     * Alternate constructor that is (alas!) needed to work\n+     * around kinks of generic type handling\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected SerializerBase(Class<?> t, boolean dummy) {\n+        _handledType = (Class<T>) t;\n+    }\n+\n+    @Override\n+    public final Class<T> handledType() { return _handledType; }\n+    \n+    @Override\n+    public abstract void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException;\n+\n+    /**\n+     * Note: since Jackson 1.9, default implementation claims type is \"string\"\n+     */\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return createSchemaNode(\"string\");\n+    }\n+    \n+    protected ObjectNode createObjectNode() {\n+        return JsonNodeFactory.instance.objectNode();\n+    }\n+    \n+    protected ObjectNode createSchemaNode(String type)\n+    {\n+        ObjectNode schema = createObjectNode();\n+        schema.put(\"type\", type);\n+        return schema;\n+    }\n+    \n+    protected ObjectNode createSchemaNode(String type, boolean isOptional)\n+    {\n+        ObjectNode schema = createSchemaNode(type);\n+        // as per [JACKSON-563]. Note that 'required' defaults to false\n+        if (!isOptional) {\n+            schema.put(\"required\", !isOptional);\n+        }\n+        return schema;\n+    }\n+\n+    /**\n+     * Method that can be called to determine if given serializer is the default\n+     * serializer Jackson uses; as opposed to a custom serializer installed by\n+     * a module or calling application. Determination is done using\n+     * {@link JacksonStdImpl} annotation on serializer class.\n+     * \n+     * @since 1.7\n+     */\n+    protected boolean isDefaultSerializer(JsonSerializer<?> serializer)\n+    {\n+        return (serializer != null && serializer.getClass().getAnnotation(JacksonStdImpl.class) != null);\n+    }\n+    \n+    /**\n+     * Method that will modify caught exception (passed in as argument)\n+     * as necessary to include reference information, and to ensure it\n+     * is a subtype of {@link IOException}, or an unchecked exception.\n+     *<p>\n+     * Rules for wrapping and unwrapping are bit complicated; essentially:\n+     *<ul>\n+     * <li>Errors are to be passed as is (if uncovered via unwrapping)\n+     * <li>\"Plain\" IOExceptions (ones that are not of type\n+     *   {@link JsonMappingException} are to be passed as is\n+     *</ul>\n+     */\n+    public void wrapAndThrow(SerializerProvider provider,\n+            Throwable t, Object bean, String fieldName)\n+        throws IOException\n+    {\n+        /* 05-Mar-2009, tatu: But one nasty edge is when we get\n+         *   StackOverflow: usually due to infinite loop. But that\n+         *   usually gets hidden within an InvocationTargetException...\n+         */\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors and \"plain\" IOExceptions to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        // Ditto for IOExceptions... except for mapping exceptions!\n+        boolean wrap = (provider == null) || provider.isEnabled(SerializationConfig.Feature.WRAP_EXCEPTIONS);\n+        if (t instanceof IOException) {\n+            if (!wrap || !(t instanceof JsonMappingException)) {\n+                throw (IOException) t;\n+            }\n+        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n+            if (t instanceof RuntimeException) {\n+                throw (RuntimeException) t;\n+            }\n+        }\n+        // [JACKSON-55] Need to add reference information\n+        throw JsonMappingException.wrapWithPath(t, bean, fieldName);\n+    }\n+\n+    public void wrapAndThrow(SerializerProvider provider,\n+            Throwable t, Object bean, int index)\n+        throws IOException\n+    {\n+        while (t instanceof InvocationTargetException && t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        // Errors are to be passed as is\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        // Ditto for IOExceptions... except for mapping exceptions!\n+        boolean wrap = (provider == null) || provider.isEnabled(SerializationConfig.Feature.WRAP_EXCEPTIONS);\n+        if (t instanceof IOException) {\n+            if (!wrap || !(t instanceof JsonMappingException)) {\n+                throw (IOException) t;\n+            }\n+        } else if (!wrap) { // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions\n+            if (t instanceof RuntimeException) {\n+                throw (RuntimeException) t;\n+            }\n+        }\n+        // [JACKSON-55] Need to add reference information\n+        throw JsonMappingException.wrapWithPath(t, bean, index);\n+    }\n+\n+    /**\n+     * @deprecated Use version that takes <code>SerializerProvider</code> instead.\n+     */\n+    @Deprecated\n+    public void wrapAndThrow(Throwable t, Object bean, String fieldName) throws IOException {\n+        wrapAndThrow(null, t, bean, fieldName);\n+    }\n+\n+    /**\n+     * @deprecated Use version that takes <code>SerializerProvider</code> instead.\n+     */\n+    @Deprecated\n+    public void wrapAndThrow(Throwable t, Object bean, int index) throws IOException {\n+        wrapAndThrow(null, t, bean, index);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.lang.reflect.Type;\n+import java.util.*;\n+\n+import org.codehaus.jackson.JsonNode;\n+import org.codehaus.jackson.node.ObjectNode;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+/**\n+ * Intermediate base class for Lists, Collections and Arrays\n+ * that contain static (non-dynamic) value types.\n+ * \n+ * @since 1.7\n+ */\n+public abstract class StaticListSerializerBase<T extends Collection<?>>\n+    extends SerializerBase<T>\n+{\n+    /**\n+     * Property that contains String List to serialize, if known.\n+     */\n+    protected final BeanProperty _property;\n+\n+    protected StaticListSerializerBase(Class<?> cls, BeanProperty property)\n+    {\n+        super(cls, false);\n+        _property = property;\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        ObjectNode o = createSchemaNode(\"array\", true);\n+        o.put(\"items\", contentSchema());\n+        return o;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Abstract methods for sub-classes to implement\n+    /**********************************************************\n+     */\n+\n+    protected abstract JsonNode contentSchema();    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import org.codehaus.jackson.*;\n+import org.codehaus.jackson.node.ObjectNode;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * Dummy container class to group standard homogenous array serializer implementations\n+ * (primitive arrays and String array).\n+ */\n+public class StdArraySerializers\n+{\n+    protected StdArraySerializers() { }\n+\n+    /*\n+    /**********************************************************\n+    /* Base classes\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Base class for serializers that will output contents as JSON\n+     * arrays.\n+     */\n+    public abstract static class ArraySerializerBase<T>\n+        extends ContainerSerializerBase<T>\n+    {\n+         /**\n+         * Type serializer used for values, if any.\n+         */\n+        protected final TypeSerializer _valueTypeSerializer;\n+\n+        /**\n+         * Array-valued property being serialized with this instance\n+         * \n+         * @since 1.7\n+         */\n+        protected final BeanProperty _property;\n+        \n+        protected ArraySerializerBase(Class<T> cls, TypeSerializer vts, BeanProperty property)\n+        {\n+            super(cls);\n+            _valueTypeSerializer = vts;\n+            _property = property;\n+        }\n+        \n+        @Override\n+        public final void serialize(T value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeStartArray();\n+            serializeContents(value, jgen, provider);\n+            jgen.writeEndArray();\n+        }\n+        \n+        @Override\n+        public final void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n+                TypeSerializer typeSer)\n+            throws IOException, JsonGenerationException\n+        {\n+            typeSer.writeTypePrefixForArray(value, jgen);\n+            serializeContents(value, jgen, provider);\n+            typeSer.writeTypeSuffixForArray(value, jgen);\n+        }\n+\n+        protected abstract void serializeContents(T value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException;\n+    }\n+\n+    /*\n+     ****************************************************************\n+    /* Concrete serializers, arrays\n+     ****************************************************************\n+     */\n+\n+    /**\n+     * Standard serializer used for <code>String[]</code> values.\n+     */\n+    @JacksonStdImpl\n+    public final static class StringArraySerializer\n+        extends ArraySerializerBase<String[]>\n+        implements ResolvableSerializer\n+    {\n+        /**\n+         * Value serializer to use, if it's not the standard one\n+         * (if it is we can optimize serialization a lot)\n+         * \n+         * @since 1.7\n+         */\n+        protected JsonSerializer<Object> _elementSerializer;\n+\n+        public StringArraySerializer(BeanProperty prop) {\n+            super(String[].class, null, prop);\n+        }\n+\n+        /**\n+         * Strings never add type info; hence, even if type serializer is suggested,\n+         * we'll ignore it...\n+         */\n+        @Override\n+        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n+            return this;\n+        }\n+        \n+        @Override\n+        public void serializeContents(String[] value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            final int len = value.length;\n+            if (len == 0) {\n+                return;\n+            }\n+            if (_elementSerializer != null) {\n+                serializeContentsSlow(value, jgen, provider, _elementSerializer);\n+                return;\n+            }\n+            /* 08-Dec-2008, tatus: If we want this to be fully overridable\n+             *  (for example, to support String cleanup during writing\n+             *  or something), we should find serializer  by provider.\n+             *  But for now, that seems like an overkill: and caller can\n+             *  add custom serializer if that is needed as well.\n+             * (ditto for null values)\n+             */\n+            //JsonSerializer<String> ser = (JsonSerializer<String>)provider.findValueSerializer(String.class);\n+            for (int i = 0; i < len; ++i) {\n+                String str = value[i];\n+                if (str == null) {\n+                    jgen.writeNull();\n+                } else {\n+                    //ser.serialize(value[i], jgen, provider);\n+                    jgen.writeString(value[i]);\n+                }\n+            }\n+        }\n+\n+        private void serializeContentsSlow(String[] value, JsonGenerator jgen, SerializerProvider provider,\n+                JsonSerializer<Object> ser)\n+            throws IOException, JsonGenerationException\n+        {\n+            for (int i = 0, len = value.length; i < len; ++i) {\n+                String str = value[i];\n+                if (str == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                } else {\n+                    ser.serialize(value[i], jgen, provider);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Need to get callback to resolve value serializer, which may\n+         * be overridden by custom serializer\n+         */\n+        @Override\n+        public void resolve(SerializerProvider provider)\n+            throws JsonMappingException\n+        {\n+            JsonSerializer<Object> ser = provider.findValueSerializer(String.class, _property);\n+            // Retain if not the standard implementation\n+            if (ser != null && ser.getClass().getAnnotation(JacksonStdImpl.class) == null) {\n+                _elementSerializer = ser;\n+            }\n+        }        \n+        \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            o.put(\"items\", createSchemaNode(\"string\"));\n+            return o;\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class BooleanArraySerializer\n+        extends ArraySerializerBase<boolean[]>\n+    {\n+        public BooleanArraySerializer() { super(boolean[].class, null, null); }\n+\n+        /**\n+         * Booleans never add type info; hence, even if type serializer is suggested,\n+         * we'll ignore it...\n+         */\n+        @Override\n+        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts)\n+        {\n+            return this;\n+        }\n+        \n+        @Override\n+        public void serializeContents(boolean[] value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            for (int i = 0, len = value.length; i < len; ++i) {\n+                jgen.writeBoolean(value[i]);\n+            }\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            o.put(\"items\", createSchemaNode(\"boolean\"));\n+            return o;\n+        }\n+    }\n+\n+    /**\n+     * Unlike other integral number array serializers, we do not just print out byte values\n+     * as numbers. Instead, we assume that it would make more sense to output content\n+     * as base64 encoded bytes (using default base64 encoding).\n+     *<p>\n+     * NOTE: since it is NOT serialized as an array, can not use AsArraySerializer as base\n+     */\n+    @JacksonStdImpl\n+    public final static class ByteArraySerializer\n+        extends SerializerBase<byte[]>\n+    {\n+        public ByteArraySerializer() {\n+            super(byte[].class);\n+        }\n+        \n+        @Override\n+        public void serialize(byte[] value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeBinary(value);\n+        }\n+\n+        @Override\n+        public void serializeWithType(byte[] value, JsonGenerator jgen, SerializerProvider provider,\n+                TypeSerializer typeSer)\n+            throws IOException, JsonGenerationException\n+        {\n+            typeSer.writeTypePrefixForScalar(value, jgen);\n+            jgen.writeBinary(value);\n+            typeSer.writeTypeSuffixForScalar(value, jgen);\n+        }\n+        \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            ObjectNode itemSchema = createSchemaNode(\"string\"); //binary values written as strings?\n+            o.put(\"items\", itemSchema);\n+            return o;\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class ShortArraySerializer\n+        extends ArraySerializerBase<short[]>\n+    {\n+        public ShortArraySerializer() { this(null); }\n+        public ShortArraySerializer(TypeSerializer vts) { super(short[].class, vts, null); }\n+\n+        @Override\n+        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n+            return new ShortArraySerializer(vts);\n+        }\n+        \n+        @SuppressWarnings(\"cast\")\n+        @Override\n+        public void serializeContents(short[] value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            for (int i = 0, len = value.length; i < len; ++i) {\n+                jgen.writeNumber((int)value[i]);\n+            }\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            //no \"short\" type defined by json\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            o.put(\"items\", createSchemaNode(\"integer\"));\n+            return o;\n+        }\n+    }\n+\n+    /**\n+     * Character arrays are different from other integral number arrays in that\n+     * they are most likely to be textual data, and should be written as\n+     * Strings, not arrays of entries.\n+     *<p>\n+     * NOTE: since it is NOT serialized as an array, can not use AsArraySerializer as base\n+     */\n+    @JacksonStdImpl\n+    public final static class CharArraySerializer\n+        extends SerializerBase<char[]>\n+    {\n+        public CharArraySerializer() { super(char[].class); }\n+        \n+        @Override\n+        public void serialize(char[] value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            // [JACKSON-289] allows serializing as 'sparse' char array too:\n+            if (provider.isEnabled(SerializationConfig.Feature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {\n+                jgen.writeStartArray();\n+                _writeArrayContents(jgen, value);\n+                jgen.writeEndArray();\n+            } else {\n+                jgen.writeString(value, 0, value.length);\n+            }\n+        }\n+\n+        @Override\n+        public void serializeWithType(char[] value, JsonGenerator jgen, SerializerProvider provider,\n+                TypeSerializer typeSer)\n+            throws IOException, JsonGenerationException\n+        {\n+            // [JACKSON-289] allows serializing as 'sparse' char array too:\n+            if (provider.isEnabled(SerializationConfig.Feature.WRITE_CHAR_ARRAYS_AS_JSON_ARRAYS)) {\n+                typeSer.writeTypePrefixForArray(value, jgen);\n+                _writeArrayContents(jgen, value);\n+                typeSer.writeTypeSuffixForArray(value, jgen);\n+            } else { // default is to write as simple String\n+                typeSer.writeTypePrefixForScalar(value, jgen);\n+                jgen.writeString(value, 0, value.length);\n+                typeSer.writeTypeSuffixForScalar(value, jgen);\n+            }\n+        }\n+\n+        private final void _writeArrayContents(JsonGenerator jgen, char[] value)\n+            throws IOException, JsonGenerationException\n+        {\n+            for (int i = 0, len = value.length; i < len; ++i) {\n+                jgen.writeString(value, i, 1);\n+            }\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            ObjectNode itemSchema = createSchemaNode(\"string\");\n+            itemSchema.put(\"type\", \"string\");\n+            o.put(\"items\", itemSchema);\n+            return o;\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class IntArraySerializer\n+        extends ArraySerializerBase<int[]>\n+    {\n+        public IntArraySerializer() { super(int[].class, null, null); }\n+\n+        /**\n+         * Ints never add type info; hence, even if type serializer is suggested,\n+         * we'll ignore it...\n+         */\n+        @Override\n+        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts)\n+        {\n+            return this;\n+        }        \n+        \n+        @Override\n+        public void serializeContents(int[] value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            for (int i = 0, len = value.length; i < len; ++i) {\n+                jgen.writeNumber(value[i]);\n+            }\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            o.put(\"items\", createSchemaNode(\"integer\"));\n+            return o;\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class LongArraySerializer\n+        extends ArraySerializerBase<long[]>\n+    {\n+        public LongArraySerializer() { this(null); }\n+        public LongArraySerializer(TypeSerializer vts) { super(long[].class, vts, null); }\n+\n+        @Override\n+        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n+            return new LongArraySerializer(vts);\n+        }\n+        \n+        @Override\n+        public void serializeContents(long[] value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            for (int i = 0, len = value.length; i < len; ++i) {\n+                jgen.writeNumber(value[i]);\n+            }\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            o.put(\"items\", createSchemaNode(\"number\", true));\n+            return o;\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class FloatArraySerializer\n+        extends ArraySerializerBase<float[]>\n+    {\n+        public FloatArraySerializer() { this(null); }\n+        public FloatArraySerializer(TypeSerializer vts) { super(float[].class, vts, null); }\n+\n+        @Override\n+        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n+            return new FloatArraySerializer(vts);\n+        }\n+        \n+        @Override\n+        public void serializeContents(float[] value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            for (int i = 0, len = value.length; i < len; ++i) {\n+                jgen.writeNumber(value[i]);\n+            }\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            o.put(\"items\", createSchemaNode(\"number\"));\n+            return o;\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public final static class DoubleArraySerializer\n+        extends ArraySerializerBase<double[]>\n+    {\n+        public DoubleArraySerializer() { super(double[].class, null, null); }\n+\n+        /**\n+         * Doubles never add type info; hence, even if type serializer is suggested,\n+         * we'll ignore it...\n+         */\n+        @Override\n+        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts)\n+        {\n+            return this;\n+        }\n+        \n+        @Override\n+        public void serializeContents(double[] value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            for (int i = 0, len = value.length; i < len; ++i) {\n+                jgen.writeNumber(value[i]);\n+            }\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            ObjectNode o = createSchemaNode(\"array\", true);\n+            o.put(\"items\", createSchemaNode(\"number\"));\n+            return o;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdContainerSerializers.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+import com.fasterxml.jackson.databind.ser.impl.PropertySerializerMap;\n+import com.fasterxml.jackson.databind.ser.std.CollectionSerializer;\n+\n+/**\n+ * Dummy container class to group standard container serializers: serializers\n+ * that can serialize things like {@link java.util.List}s,\n+ * {@link java.util.Map}s and such.\n+ */\n+public class StdContainerSerializers\n+{\n+    protected StdContainerSerializers() { }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods\n+    /**********************************************************\n+     */\n+        \n+    public static ContainerSerializerBase<?> indexedListSerializer(JavaType elemType,\n+            boolean staticTyping, TypeSerializer vts, BeanProperty property,\n+            JsonSerializer<Object> valueSerializer)\n+    {\n+        return new IndexedListSerializer(elemType, staticTyping, vts, property, valueSerializer);\n+    }\n+\n+    public static ContainerSerializerBase<?> collectionSerializer(JavaType elemType,\n+            boolean staticTyping, TypeSerializer vts, BeanProperty property,\n+            JsonSerializer<Object> valueSerializer)\n+    {\n+        return new CollectionSerializer(elemType, staticTyping, vts, property, valueSerializer);\n+    }\n+\n+    public static ContainerSerializerBase<?> iteratorSerializer(JavaType elemType,\n+            boolean staticTyping, TypeSerializer vts, BeanProperty property)\n+    {\n+        return new IteratorSerializer(elemType, staticTyping, vts, property);\n+    }\n+\n+    public static ContainerSerializerBase<?> iterableSerializer(JavaType elemType,\n+            boolean staticTyping, TypeSerializer vts, BeanProperty property)\n+    {\n+        return new IterableSerializer(elemType, staticTyping, vts, property);\n+    }\n+\n+    public static JsonSerializer<?> enumSetSerializer(JavaType enumType, BeanProperty property)\n+    {\n+        return new EnumSetSerializer(enumType, property);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Concrete serializers, Lists/collections\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This is an optimized serializer for Lists that can be efficiently\n+     * traversed by index (as opposed to others, such as {@link LinkedList}\n+     * that can not}.\n+     */\n+    @JacksonStdImpl\n+    public static class IndexedListSerializer\n+        extends AsArraySerializerBase<List<?>>\n+    {\n+        public IndexedListSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts,\n+                BeanProperty property, JsonSerializer<Object> valueSerializer)\n+        {\n+            super(List.class, elemType, staticTyping, vts, property, valueSerializer);\n+        }\n+\n+        @Override\n+        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n+            return new IndexedListSerializer(_elementType, _staticTyping, vts, _property, _elementSerializer);\n+        }\n+        \n+        @Override\n+        public void serializeContents(List<?> value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            if (_elementSerializer != null) {\n+                serializeContentsUsing(value, jgen, provider, _elementSerializer);\n+                return;\n+            }\n+            if (_valueTypeSerializer != null) {\n+                serializeTypedContents(value, jgen, provider);\n+                return;\n+            }\n+            final int len = value.size();\n+            if (len == 0) {\n+                return;\n+            }\n+            int i = 0;\n+            try {\n+                PropertySerializerMap serializers = _dynamicSerializers;\n+                for (; i < len; ++i) {\n+                    Object elem = value.get(i);\n+                    if (elem == null) {\n+                        provider.defaultSerializeNull(jgen);\n+                    } else {\n+                        Class<?> cc = elem.getClass();\n+                        JsonSerializer<Object> serializer = serializers.serializerFor(cc);\n+                        if (serializer == null) {\n+                            // To fix [JACKSON-508]\n+                            if (_elementType.hasGenericTypes()) {\n+                                serializer = _findAndAddDynamic(serializers,\n+                                        provider.constructSpecializedType(_elementType, cc), provider);\n+                            } else {\n+                                serializer = _findAndAddDynamic(serializers, cc, provider);\n+                            }\n+                            serializers = _dynamicSerializers;\n+                        }\n+                        serializer.serialize(elem, jgen, provider);\n+                    }\n+                }\n+            } catch (Exception e) {\n+                // [JACKSON-55] Need to add reference information\n+                wrapAndThrow(provider, e, value, i);\n+            }\n+        }\n+        \n+        public void serializeContentsUsing(List<?> value, JsonGenerator jgen, SerializerProvider provider,\n+                JsonSerializer<Object> ser)\n+            throws IOException, JsonGenerationException\n+        {\n+            final int len = value.size();\n+            if (len == 0) {\n+                return;\n+            }\n+            final TypeSerializer typeSer = _valueTypeSerializer;\n+            for (int i = 0; i < len; ++i) {\n+                Object elem = value.get(i);\n+                try {\n+                    if (elem == null) {\n+                        provider.defaultSerializeNull(jgen);\n+                    } else if (typeSer == null) {\n+                        ser.serialize(elem, jgen, provider);\n+                    } else {\n+                        ser.serializeWithType(elem, jgen, provider, typeSer);\n+                    }\n+                } catch (Exception e) {\n+                    // [JACKSON-55] Need to add reference information\n+                    wrapAndThrow(provider, e, value, i);\n+                }\n+            }\n+        }\n+\n+        public void serializeTypedContents(List<?> value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            final int len = value.size();\n+            if (len == 0) {\n+                return;\n+            }\n+            int i = 0;\n+            try {\n+                final TypeSerializer typeSer = _valueTypeSerializer;\n+                PropertySerializerMap serializers = _dynamicSerializers;\n+                for (; i < len; ++i) {\n+                    Object elem = value.get(i);\n+                    if (elem == null) {\n+                        provider.defaultSerializeNull(jgen);\n+                    } else {\n+                        Class<?> cc = elem.getClass();\n+                        JsonSerializer<Object> serializer = serializers.serializerFor(cc);\n+                        if (serializer == null) {\n+                            // To fix [JACKSON-508]\n+                            if (_elementType.hasGenericTypes()) {\n+                                serializer = _findAndAddDynamic(serializers,\n+                                        provider.constructSpecializedType(_elementType, cc), provider);\n+                            } else {\n+                                serializer = _findAndAddDynamic(serializers, cc, provider);\n+                            }\n+                            serializers = _dynamicSerializers;\n+                        }\n+                        serializer.serializeWithType(elem, jgen, provider, typeSer);\n+                    }\n+                }\n+            } catch (Exception e) {\n+                // [JACKSON-55] Need to add reference information\n+                wrapAndThrow(provider, e, value, i);\n+            }\n+        }\n+    }\n+\n+    @JacksonStdImpl\n+    public static class IteratorSerializer\n+        extends AsArraySerializerBase<Iterator<?>>\n+    {\n+        public IteratorSerializer(JavaType elemType, boolean staticTyping, TypeSerializer vts,\n+                BeanProperty property)\n+        {\n+            super(Iterator.class, elemType, staticTyping, vts, property, null);\n+        }\n+\n+        @Override\n+        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n+            return new IteratorSerializer(_elementType, _staticTyping, vts, _property);\n+        }\n+        \n+        @Override\n+        public void serializeContents(Iterator<?> value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            if (value.hasNext()) {\n+                final TypeSerializer typeSer = _valueTypeSerializer;\n+                JsonSerializer<Object> prevSerializer = null;\n+                Class<?> prevClass = null;\n+                do {\n+                    Object elem = value.next();\n+                    if (elem == null) {\n+                        provider.defaultSerializeNull(jgen);\n+                    } else {\n+                        // Minor optimization to avoid most lookups:\n+                        Class<?> cc = elem.getClass();\n+                        JsonSerializer<Object> currSerializer;\n+                        if (cc == prevClass) {\n+                            currSerializer = prevSerializer;\n+                        } else {\n+                            currSerializer = provider.findValueSerializer(cc, _property);\n+                            prevSerializer = currSerializer;\n+                            prevClass = cc;\n+                        }\n+                        if (typeSer == null) {\n+                            currSerializer.serialize(elem, jgen, provider);\n+                        } else {\n+                            currSerializer.serializeWithType(elem, jgen, provider, typeSer);\n+                        }\n+                    }\n+                } while (value.hasNext());\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.*;\n+import java.lang.reflect.Type;\n+import java.util.*;\n+import java.util.concurrent.atomic.*;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.ser.BasicSerializerFactory;\n+import com.fasterxml.jackson.databind.util.Provider;\n+\n+/**\n+ * Class that providers access to serializers user for non-structured JDK types that\n+ * are serializer as scalars; some using basic {@link ToStringSerializer},\n+ * others explicit serializers.\n+ */\n+public class StdJdkSerializers\n+    implements Provider<Map.Entry<Class<?>,Object>>\n+{\n+    /**\n+     * Method called by {@link BasicSerializerFactory} to access\n+     * all serializers this class provides.\n+     */\n+    @Override\n+    public Collection<Map.Entry<Class<?>, Object>> provide()\n+    {\n+        HashMap<Class<?>,Object> sers = new HashMap<Class<?>,Object>();\n+\n+        // First things that 'toString()' can handle\n+        final ToStringSerializer sls = ToStringSerializer.instance;\n+\n+        sers.put(java.net.URL.class, sls);\n+        sers.put(java.net.URI.class, sls);\n+\n+        sers.put(Currency.class, sls);\n+        sers.put(UUID.class, sls);\n+        sers.put(java.util.regex.Pattern.class, sls);\n+        sers.put(Locale.class, sls);\n+\n+        // starting with 1.7, use compact String for Locale\n+        sers.put(Locale.class, sls);\n+        \n+        // then atomic types\n+        sers.put(AtomicReference.class, AtomicReferenceSerializer.class);\n+        sers.put(AtomicBoolean.class, AtomicBooleanSerializer.class);\n+        sers.put(AtomicInteger.class, AtomicIntegerSerializer.class);\n+        sers.put(AtomicLong.class, AtomicLongSerializer.class);\n+        \n+        // then types that need specialized serializers\n+        sers.put(File.class, FileSerializer.class);\n+        sers.put(Class.class, ClassSerializer.class);\n+\n+        // And then some stranger types... not 100% they are needed but:\n+        sers.put(Void.TYPE, NullSerializer.class);\n+        \n+        return sers.entrySet();\n+    }\n+\n+    /*\n+     ********************************************************\n+     * Serializers for atomic types\n+     ********************************************************\n+     */\n+\n+    public final static class AtomicBooleanSerializer\n+        extends ScalarSerializerBase<AtomicBoolean>\n+    {\n+        public AtomicBooleanSerializer() { super(AtomicBoolean.class, false); }\n+    \n+        @Override\n+        public void serialize(AtomicBoolean value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeBoolean(value.get());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"boolean\", true);\n+        }\n+    }\n+    \n+    public final static class AtomicIntegerSerializer\n+        extends ScalarSerializerBase<AtomicInteger>\n+    {\n+        public AtomicIntegerSerializer() { super(AtomicInteger.class, false); }\n+    \n+        @Override\n+        public void serialize(AtomicInteger value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeNumber(value.get());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"integer\", true);\n+        }\n+    }\n+\n+    public final static class AtomicLongSerializer\n+        extends ScalarSerializerBase<AtomicLong>\n+    {\n+        public AtomicLongSerializer() { super(AtomicLong.class, false); }\n+    \n+        @Override\n+        public void serialize(AtomicLong value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeNumber(value.get());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"integer\", true);\n+        }\n+    }\n+    \n+    public final static class AtomicReferenceSerializer\n+        extends SerializerBase<AtomicReference<?>>\n+    {\n+        public AtomicReferenceSerializer() { super(AtomicReference.class, false); }\n+\n+        @Override\n+        public void serialize(AtomicReference<?> value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            provider.defaultSerializeValue(value.get(), jgen);\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"any\", true);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Specialized serializers, referential types\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * For now, File objects get serialized by just outputting\n+     * absolute (but not canonical) name as String value\n+     */\n+    public final static class FileSerializer\n+        extends ScalarSerializerBase<File>\n+    {\n+        public FileSerializer() { super(File.class); }\n+\n+        @Override\n+        public void serialize(File value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeString(value.getAbsolutePath());\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"string\", true);\n+        }\n+    }\n+\n+    /**\n+     * Also: default bean access will not do much good with Class.class. But\n+     * we can just serialize the class name and that should be enough.\n+     */\n+    public final static class ClassSerializer\n+        extends ScalarSerializerBase<Class<?>>\n+    {\n+        public ClassSerializer() { super(Class.class, false); }\n+\n+        @Override\n+        public void serialize(Class<?> value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeString(value.getName());\n+        }\n+\n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"string\", true);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.Date;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n+\n+/**\n+ * Specialized serializer that can be used as the generic key\n+ * serializer, when serializing {@link java.util.Map}s to JSON\n+ * Objects.\n+ */\n+public class StdKeySerializer\n+    extends SerializerBase<Object>\n+{\n+    final static StdKeySerializer instace = new StdKeySerializer();\n+\n+    public StdKeySerializer() { super(Object.class); }\n+    \n+    @Override\n+    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (value instanceof Date) {\n+            provider.defaultSerializeDateKey((Date) value, jgen);\n+        } else {\n+            jgen.writeFieldName(value.toString());\n+        }\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return createSchemaNode(\"string\");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializers.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.util.Calendar;\n+import java.util.Date;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+public class StdKeySerializers\n+{\n+    protected final static JsonSerializer<Object> DEFAULT_KEY_SERIALIZER = new StdKeySerializer();\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected final static JsonSerializer<Object> DEFAULT_STRING_SERIALIZER\n+        = (JsonSerializer<Object>)(JsonSerializer<?>) new StringKeySerializer();\n+    \n+    private StdKeySerializers() { }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static JsonSerializer<Object> getStdKeySerializer(JavaType keyType)\n+    {\n+        if (keyType == null) {\n+            return DEFAULT_KEY_SERIALIZER;\n+        }\n+        Class<?> cls = keyType.getRawClass();\n+        if (cls == String.class) {\n+            return DEFAULT_STRING_SERIALIZER;\n+        }\n+        if (cls == Object.class) {\n+            return DEFAULT_KEY_SERIALIZER;\n+        }\n+        // [JACKSON-606] special handling for dates...\n+        if (Date.class.isAssignableFrom(cls)) {\n+            return (JsonSerializer<Object>) DateKeySerializer.instance;\n+        }\n+        if (Calendar.class.isAssignableFrom(cls)) {\n+            return (JsonSerializer<Object>) CalendarKeySerializer.instance;\n+        }\n+        // If no match, just use default one:\n+        return DEFAULT_KEY_SERIALIZER;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard implementations\n+    /**********************************************************\n+     */\n+\n+    public static class StringKeySerializer\n+        extends SerializerBase<String>\n+    {\n+        public StringKeySerializer() { super(String.class); }\n+        \n+        @Override\n+        public void serialize(String value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeFieldName(value);\n+        }\n+    }\n+\n+    public static class DateKeySerializer\n+        extends SerializerBase<Date>\n+    {\n+        protected final static JsonSerializer<?> instance = new DateKeySerializer();\n+\n+        public DateKeySerializer() { super(Date.class); }\n+        \n+        @Override\n+        public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            provider.defaultSerializeDateKey(value, jgen);\n+        }\n+    }\n+\n+    public static class CalendarKeySerializer\n+        extends SerializerBase<Calendar>\n+    {\n+        protected final static JsonSerializer<?> instance = new CalendarKeySerializer();\n+\n+        public CalendarKeySerializer() { super(Calendar.class); }\n+        \n+        @Override\n+        public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            provider.defaultSerializeDateKey(value.getTimeInMillis(), jgen);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringCollectionSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+\n+import com.fasterxml.jackson.databind.BeanProperty;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ResolvableSerializer;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * Efficient implement for serializing {@link Collection}s that contain Strings.\n+ * The only complexity is due to possibility that serializer for {@link String}\n+ * may be overridde; because of this, logic is needed to ensure that the default\n+ * serializer is in use to use fastest mode, or if not, to defer to custom\n+ * String serializer.\n+ * \n+ * @since 1.7\n+ */\n+@JacksonStdImpl\n+\n+public class StringCollectionSerializer\n+    extends StaticListSerializerBase<Collection<String>>\n+    implements ResolvableSerializer\n+{\n+    protected JsonSerializer<String> _serializer;\n+    \n+    public StringCollectionSerializer(BeanProperty property) {\n+        super(Collection.class, property);\n+    }\n+        \n+    @Override protected JsonNode contentSchema() {\n+        return createSchemaNode(\"string\", true);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void resolve(SerializerProvider provider) throws JsonMappingException\n+    {\n+        JsonSerializer<?> ser = provider.findValueSerializer(String.class, _property);\n+        if (!isDefaultSerializer(ser)) {\n+            _serializer = (JsonSerializer<String>) ser;\n+        }\n+    }\n+\n+    @Override\n+    public void serialize(Collection<String> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeStartArray();\n+        if (_serializer == null) {\n+            serializeContents(value, jgen, provider);\n+        } else {\n+            serializeUsingCustom(value, jgen, provider);\n+        }\n+        jgen.writeEndArray();\n+    }\n+    \n+    @Override\n+    public void serializeWithType(Collection<String> value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        typeSer.writeTypePrefixForArray(value, jgen);\n+        if (_serializer == null) {\n+            serializeContents(value, jgen, provider);\n+        } else {\n+            serializeUsingCustom(value, jgen, provider);\n+        }\n+        typeSer.writeTypeSuffixForArray(value, jgen);\n+    }\n+    \n+    private final void serializeContents(Collection<String> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_serializer != null) {\n+            serializeUsingCustom(value, jgen, provider);\n+            return;\n+        }\n+        int i = 0;\n+        for (String str : value) {\n+            try {\n+                if (str == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                } else {\n+                    jgen.writeString(str);\n+                }\n+                ++i;\n+            } catch (Exception e) {\n+                wrapAndThrow(provider, e, value, i);\n+            }\n+        }\n+    }\n+\n+    private void serializeUsingCustom(Collection<String> value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final JsonSerializer<String> ser = _serializer;\n+        int i = 0;\n+        for (String str : value) {\n+            try {\n+                if (str == null) {\n+                    provider.defaultSerializeNull(jgen);\n+                } else {\n+                    ser.serialize(str, jgen, provider);\n+                }\n+            } catch (Exception e) {\n+                wrapAndThrow(provider, e, value, i);\n+            }\n+       }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * This is the special serializer for regular {@link java.lang.String}s.\n+ *<p>\n+ * Since this is one of \"native\" types, no type information is ever\n+ * included on serialization (unlike for most scalar types as of 1.5)\n+ */\n+@JacksonStdImpl\n+public final class StringSerializer\n+    extends NonTypedScalarSerializerBase<String>\n+{\n+    public StringSerializer() { super(String.class); }\n+\n+    @Override\n+    public void serialize(String value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeString(value);\n+    }\n+\n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        return createSchemaNode(\"string\", true);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/TimeZoneSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.util.TimeZone;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+\n+/**\n+ * @since 1.8\n+ */\n+public class TimeZoneSerializer\n+    extends ScalarSerializerBase<TimeZone>\n+{\n+    public final static TimeZoneSerializer instance = new TimeZoneSerializer();\n+    \n+    public TimeZoneSerializer() { super(TimeZone.class); }\n+\n+    @Override\n+    public void serialize(TimeZone value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeString(value.getID());\n+    }\n+\n+    @Override\n+    public void serializeWithType(TimeZone value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Better ensure we don't use specific sub-classes:\n+        typeSer.writeTypePrefixForScalar(value, jgen, TimeZone.class);\n+        serialize(value, jgen, provider);\n+        typeSer.writeTypeSuffixForScalar(value, jgen);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * Simple general purpose serializer, useful for any\n+ * type for which {@link Object#toString} returns the desired JSON\n+ * value.\n+ */\n+@JacksonStdImpl\n+public class ToStringSerializer\n+    extends SerializerBase<Object>\n+{\n+    /**\n+     * Singleton instance to use.\n+     */\n+    public final static ToStringSerializer instance = new ToStringSerializer();\n+\n+    /**\n+     *<p>\n+     * Note: usually you should NOT create new instances, but instead use\n+     * {@link #instance} which is stateless and fully thread-safe. However,\n+     * there are cases where constructor is needed; for example,\n+     * when using explicit serializer annotations like\n+     * {@link com.fasterxml.jackson.databind.annotate.JsonSerialize#using}.\n+     */\n+    public ToStringSerializer() { super(Object.class); }\n+    \n+    @Override\n+    public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        jgen.writeString(value.toString());\n+    }\n+\n+    /* 01-Mar-2011, tatu: We were serializing as \"raw\" String; but generally that\n+     *   is not what we want, since lack of type information would imply real\n+     *   String type.\n+     */\n+    /**\n+     * Default implementation will write type prefix, call regular serialization\n+     * method (since assumption is that value itself does not need JSON\n+     * Array or Object start/end markers), and then write type suffix.\n+     * This should work for most cases; some sub-classes may want to\n+     * change this behavior.\n+     */\n+    @Override\n+    public void serializeWithType(Object value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        typeSer.writeTypePrefixForScalar(value, jgen);\n+        serialize(value, jgen, provider);\n+        typeSer.writeTypeSuffixForScalar(value, jgen);\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        return createSchemaNode(\"string\", true);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/TokenBufferSerializer.java\n+package com.fasterxml.jackson.databind.ser.std;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonNode;\n+import org.codehaus.jackson.util.TokenBuffer;\n+\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+import com.fasterxml.jackson.databind.annotate.JacksonStdImpl;\n+\n+/**\n+ * We also want to directly support serialization of {@link TokenBuffer};\n+ * and since it is part of core package, it can not implement\n+ * {@link com.fasterxml.jackson.databind.JsonSerializable}\n+ * (which is only included in the mapper package)\n+ *\n+ * @since 1.5\n+ */\n+@JacksonStdImpl\n+public class TokenBufferSerializer\n+    extends SerializerBase<TokenBuffer>\n+{\n+    public TokenBufferSerializer() { super(TokenBuffer.class); }\n+\n+    @Override\n+    public void serialize(TokenBuffer value, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        value.serialize(jgen);\n+    }\n+\n+    /**\n+     * Implementing typed output for contents of a TokenBuffer is very tricky,\n+     * since we do not know for sure what its contents might look like (or, rather,\n+     * we do know when serializing, but not necessarily when deserializing!)\n+     * One possibility would be to check the current token, and use that to\n+     * determine if we would output JSON Array, Object or scalar value.\n+     * Jackson 1.5 did NOT include any type information; but this seems wrong,\n+     * and so 1.6 WILL include type information.\n+     *<p>\n+     * Note that we just claim it is scalar; this should work ok and is simpler\n+     * than doing introspection on both serialization and deserialization.\n+     */\n+    @Override\n+    public final void serializeWithType(TokenBuffer value, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        typeSer.writeTypePrefixForScalar(value, jgen);\n+        serialize(value, jgen, provider);\n+        typeSer.writeTypeSuffixForScalar(value, jgen);\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+    {\n+        /* 01-Jan-2010, tatu: Not 100% sure what we should say here:\n+         *   type is basically not known. This seems closest\n+         *   approximation\n+         */\n+        return createSchemaNode(\"any\", true);\n+    }\n+}    \n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.lang.reflect.Array;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Array types represent Java arrays, both primitive and object valued.\n+ * Further, Object-valued arrays can have element type of any other\n+ * legal {@link JavaType}.\n+ */\n+public final class ArrayType\n+    extends TypeBase\n+{\n+    /**\n+     * Type of elements in the array.\n+     */\n+    protected final JavaType _componentType;\n+\n+    /**\n+     * We will also keep track of shareable instance of empty array,\n+     * since it usually needs to be constructed any way; and because\n+     * it is essentially immutable and thus can be shared.\n+     */\n+    protected final Object _emptyArray;\n+\n+    private ArrayType(JavaType componentType, Object emptyInstance,\n+            Object valueHandler, Object typeHandler)\n+    {\n+        super(emptyInstance.getClass(), componentType.hashCode(),\n+                valueHandler, typeHandler);\n+        _componentType = componentType;\n+        _emptyArray = emptyInstance;\n+    }\n+\n+    /**\n+     * @deprecated Since 1.9, if you must directly instantiate,\n+     *  call method that takes handlers\n+     */\n+    @Deprecated\n+    public static ArrayType construct(JavaType componentType)\n+    {\n+        return construct(componentType, null, null);\n+    }                                   \n+\n+    public static ArrayType construct(JavaType componentType,\n+            Object valueHandler, Object typeHandler)\n+    {\n+        /* This is bit messy: there is apparently no other way to\n+         * reconstruct actual concrete/raw array class from component\n+         * type, than to construct an instance, get class (same is\n+         * true for GenericArracyType as well; hence we won't bother\n+         * passing that in).\n+         */\n+        Object emptyInstance = Array.newInstance(componentType.getRawClass(), 0);\n+        return new ArrayType(componentType, emptyInstance, null, null);\n+    }                                   \n+    \n+    // Since 1.7:\n+    @Override\n+    public ArrayType withTypeHandler(Object h)\n+    {\n+        if (h == _typeHandler) {\n+            return this;\n+        }\n+        return new ArrayType(_componentType, _emptyArray, _valueHandler, h);\n+    }\n+\n+    // Since 1.7:\n+    @Override\n+    public ArrayType withContentTypeHandler(Object h)\n+    {\n+        if (h == _componentType.getTypeHandler()) {\n+            return this;\n+        }\n+        return new ArrayType(_componentType.withTypeHandler(h), _emptyArray,\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    // Since 1.9:\n+    @Override\n+    public ArrayType withValueHandler(Object h) {\n+        if (h == _valueHandler) {\n+            return this;\n+        }\n+        return new ArrayType(_componentType, _emptyArray, h, _typeHandler);\n+    }\n+\n+    // Since 1.9:\n+    @Override\n+    public ArrayType withContentValueHandler(Object h) {\n+        if (h == _componentType.getValueHandler()) {\n+            return this;\n+        }\n+        return new ArrayType(_componentType.withValueHandler(h), _emptyArray,\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    @Override\n+    protected String buildCanonicalName() {\n+        return _class.getName();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Methods for narrowing conversions\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Handling of narrowing conversions for arrays is trickier: for now,\n+     * it is not even allowed.\n+     */\n+    @Override\n+    protected JavaType _narrow(Class<?> subclass)\n+    {\n+        /* Ok: need a bit of indirection here. First, must replace component\n+         * type (and check that it is compatible), then re-construct.\n+         */\n+        if (!subclass.isArray()) { // sanity check, should never occur\n+            throw new IllegalArgumentException(\"Incompatible narrowing operation: trying to narrow \"+toString()+\" to class \"+subclass.getName());\n+        }\n+        /* Hmmh. This is an awkward back reference... but seems like the\n+         * only simple way to do it.\n+         */\n+        Class<?> newCompClass = subclass.getComponentType();\n+        /* 14-Mar-2011, tatu: it gets even worse, as we do not have access to\n+         *   currently configured TypeFactory. This could theoretically cause\n+         *   problems (when narrowing from array of Objects, to array of non-standard\n+         *   Maps, for example); but for now need to defer solving this until\n+         *   it actually becomes a real problem, not just potential one.\n+         *   (famous last words?)\n+         */\n+        JavaType newCompType = TypeFactory.defaultInstance().constructType(newCompClass);\n+        return construct(newCompType, _valueHandler, _typeHandler);\n+    }\n+\n+    /**\n+     * For array types, both main type and content type can be modified;\n+     * but ultimately they are interchangeable.\n+     */\n+    @Override\n+    public JavaType narrowContentsBy(Class<?> contentClass)\n+    {\n+        // Can do a quick check first:\n+        if (contentClass == _componentType.getRawClass()) {\n+            return this;\n+        }\n+        return construct(_componentType.narrowBy(contentClass),\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    @Override\n+    public JavaType widenContentsBy(Class<?> contentClass)\n+    {\n+        // Can do a quick check first:\n+        if (contentClass == _componentType.getRawClass()) {\n+            return this;\n+        }\n+        return construct(_componentType.widenBy(contentClass),\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isArrayType() { return true; }\n+    \n+    /**\n+     * For some odd reason, modifiers for array classes would\n+     * claim they are abstract types. Not so, at least for our\n+     * purposes.\n+     */\n+    @Override\n+    public boolean isAbstract() { return false; }\n+\n+    /**\n+     * For some odd reason, modifiers for array classes would\n+     * claim they are abstract types. Not so, at least for our\n+     * purposes.\n+     */\n+    @Override\n+    public boolean isConcrete() { return true; }\n+\n+    @Override\n+    public boolean hasGenericTypes() {\n+        // arrays are not parameterized, but element type may be:\n+        return _componentType.hasGenericTypes();\n+    }\n+    \n+    /**\n+     * Not sure what symbolic name is used internally, if any;\n+     * let's follow naming of Collection types here.\n+     * Should not really matter since array types have no\n+     * super types.\n+     */\n+    @Override\n+    public String containedTypeName(int index) {\n+        if (index == 0) return \"E\";\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isContainerType() { return true; }\n+\n+    @Override\n+    public JavaType getContentType() { return  _componentType; }\n+\n+    @Override\n+    public int containedTypeCount() { return 1; }\n+    @Override\n+    public JavaType containedType(int index) {\n+            return (index == 0) ? _componentType : null;\n+    }\n+    \n+    @Override\n+    public StringBuilder getGenericSignature(StringBuilder sb) {\n+        sb.append('[');\n+        return _componentType.getGenericSignature(sb);\n+    }\n+\n+    @Override\n+    public StringBuilder getErasedSignature(StringBuilder sb) {\n+        sb.append('[');\n+        return _componentType.getErasedSignature(sb);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"[array type, component type: \"+_componentType+\"]\";\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) return false;\n+\n+        ArrayType other = (ArrayType) o;\n+        return _componentType.equals(other._componentType);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ClassKey.java\n+package com.fasterxml.jackson.databind.type;\n+\n+/**\n+ * Key class, used as an efficient and accurate key\n+ * for locating per-class values, such as\n+ * {@link com.fasterxml.jackson.databind.JsonSerializer}s.\n+ *<p>\n+ * The reason for having a separate key class instead of\n+ * directly using {@link Class} as key is mostly\n+ * to allow for redefining <code>hashCode</code> method --\n+ * for some strange reason, {@link Class} does not\n+ * redefine {@link Object#hashCode} and thus uses identity\n+ * hash, which is pretty slow. This makes key access using\n+ * {@link Class} unnecessarily slow.\n+ *<p>\n+ * Note: since class is not strictly immutable, caller must\n+ * know what it is doing, if changing field values.\n+ */\n+public final class ClassKey\n+    implements Comparable<ClassKey>\n+{\n+    private String _className;\n+\n+    private Class<?> _class;\n+\n+    /**\n+     * Let's cache hash code straight away, since we are\n+     * almost certain to need it.\n+     */\n+    private int _hashCode;\n+\n+    public ClassKey() \n+    {\n+        _class = null;\n+        _className = null;\n+        _hashCode = 0;\n+    }\n+\n+    public ClassKey(Class<?> clz)\n+    {\n+        _class = clz;\n+        _className = clz.getName();\n+        _hashCode = _className.hashCode();\n+    }\n+\n+    public void reset(Class<?> clz)\n+    {\n+        _class = clz;\n+        _className = clz.getName();\n+        _hashCode = _className.hashCode();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Comparable\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public int compareTo(ClassKey other)\n+    {\n+        // Just need to sort by name, ok to collide (unless used in TreeMap/Set!)\n+        return _className.compareTo(other._className);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+        public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) return false;\n+        ClassKey other = (ClassKey) o;\n+\n+        /* Is it possible to have different Class object for same name + class loader combo?\n+         * Let's assume answer is no: if this is wrong, will need to uncomment following functionality\n+         */\n+        /*\n+        return (other._className.equals(_className))\n+            && (other._class.getClassLoader() == _class.getClassLoader());\n+        */\n+        return other._class == _class;\n+    }\n+\n+    @Override public int hashCode() { return _hashCode; }\n+\n+    @Override public String toString() { return _className; }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.util.Collection;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Type that represents things that act similar to {@link java.util.Collection};\n+ * but may or may not be instances of that interface.\n+ * This specifically allows framework to check for configuration and annotation\n+ * settings used for Map types, and pass these to custom handlers that may be more\n+ * familiar with actual type.\n+ *\n+ * @since 1.8\n+ */\n+public class CollectionLikeType extends TypeBase\n+{\n+    /**\n+     * Type of elements in collection\n+     */\n+    protected final JavaType _elementType;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    @Deprecated // since 1.9\n+    protected CollectionLikeType(Class<?> collT, JavaType elemT)\n+    {\n+        super(collT,  elemT.hashCode(), null, null);\n+        _elementType = elemT;\n+    }\n+\n+    protected CollectionLikeType(Class<?> collT, JavaType elemT,\n+            Object valueHandler, Object typeHandler)\n+    {\n+        super(collT, elemT.hashCode(), valueHandler, typeHandler);\n+        _elementType = elemT;\n+    }\n+    \n+    @Override\n+    protected JavaType _narrow(Class<?> subclass) {\n+        return new CollectionLikeType(subclass, _elementType,\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    @Override\n+    public JavaType narrowContentsBy(Class<?> contentClass)\n+    {\n+        // Can do a quick check first:\n+        if (contentClass == _elementType.getRawClass()) {\n+            return this;\n+        }\n+        return new CollectionLikeType(_class, _elementType.narrowBy(contentClass),\n+                _valueHandler, _typeHandler);    }\n+\n+    @Override\n+    public JavaType widenContentsBy(Class<?> contentClass)\n+    {\n+        // Can do a quick check first:\n+        if (contentClass == _elementType.getRawClass()) {\n+            return this;\n+        }\n+        return new CollectionLikeType(_class, _elementType.widenBy(contentClass),\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    public static CollectionLikeType construct(Class<?> rawType, JavaType elemT)\n+    {\n+        // nominally component types will be just Object.class\n+        return new CollectionLikeType(rawType, elemT, null, null);\n+    }\n+\n+    // Since 1.7:\n+    @Override\n+    public CollectionLikeType withTypeHandler(Object h)\n+    {\n+        return new CollectionLikeType(_class, _elementType, _valueHandler, h);\n+    }\n+\n+    // Since 1.7:\n+    @Override\n+    public CollectionLikeType withContentTypeHandler(Object h)\n+    {\n+        return new CollectionLikeType(_class, _elementType.withTypeHandler(h),\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    // Since 1.9:\n+    @Override\n+    public CollectionLikeType withValueHandler(Object h) {\n+        return new CollectionLikeType(_class, _elementType, h, _typeHandler);\n+    }\n+\n+    // Since 1.9:\n+    @Override\n+    public CollectionLikeType withContentValueHandler(Object h) {\n+        return new CollectionLikeType(_class, _elementType.withValueHandler(h),\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isContainerType() { return true; }\n+\n+    @Override\n+    public boolean isCollectionLikeType() { return true; }\n+    \n+    @Override\n+    public JavaType getContentType() { return _elementType; }\n+\n+    @Override\n+    public int containedTypeCount() { return 1; }\n+\n+    @Override\n+    public JavaType containedType(int index) {\n+            return (index == 0) ? _elementType : null;\n+    }\n+\n+    /**\n+     * Not sure if we should count on this, but type names\n+     * for core interfaces use \"E\" for element type\n+     */\n+    @Override\n+    public String containedTypeName(int index) {\n+        if (index == 0) return \"E\";\n+        return null;\n+    }\n+\n+    @Override\n+    public StringBuilder getErasedSignature(StringBuilder sb) {\n+        return _classSignature(_class, sb, true);\n+    }\n+    \n+    @Override\n+    public StringBuilder getGenericSignature(StringBuilder sb) {\n+        _classSignature(_class, sb, false);\n+        sb.append('<');\n+        _elementType.getGenericSignature(sb);\n+        sb.append(\">;\");\n+        return sb;\n+    }\n+    \n+    @Override\n+    protected String buildCanonicalName() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(_class.getName());\n+        if (_elementType != null) {\n+            sb.append('<');\n+            sb.append(_elementType.toCanonical());\n+            sb.append('>');\n+        }\n+        return sb.toString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used for checking whether this type is a\n+     * \"real\" Collection type; meaning whether it represents a parameterized\n+     * subtype of {@link java.util.Collection} or just something that acts\n+     * like one.\n+     * \n+     * @since 1.8\n+     */\n+    public boolean isTrueCollectionType() {\n+        return Collection.class.isAssignableFrom(_class);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) return false;\n+\n+        CollectionLikeType other = (CollectionLikeType) o;\n+        return  (_class == other._class) && _elementType.equals(other._elementType);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"[collection-like type; class \"+_class.getName()+\", contains \"+_elementType+\"]\";\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionType.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Type that represents Java Collection types (Lists, Sets).\n+ */\n+public final class CollectionType\n+    extends CollectionLikeType\n+{\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    private CollectionType(Class<?> collT, JavaType elemT,\n+            Object valueHandler, Object typeHandler)\n+    {\n+        super(collT,  elemT, valueHandler, typeHandler);\n+    }\n+\n+    @Override\n+    protected JavaType _narrow(Class<?> subclass) {\n+        return new CollectionType(subclass, _elementType, null, null);\n+    }\n+\n+    @Override\n+    public JavaType narrowContentsBy(Class<?> contentClass)\n+    {\n+        // Can do a quick check first:\n+        if (contentClass == _elementType.getRawClass()) {\n+            return this;\n+        }\n+        return new CollectionType(_class, _elementType.narrowBy(contentClass),\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    @Override\n+    public JavaType widenContentsBy(Class<?> contentClass)\n+    {\n+        // Can do a quick check first:\n+        if (contentClass == _elementType.getRawClass()) {\n+            return this;\n+        }\n+        return new CollectionType(_class, _elementType.widenBy(contentClass),\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    public static CollectionType construct(Class<?> rawType, JavaType elemT)\n+    {\n+        // nominally component types will be just Object.class\n+        return new CollectionType(rawType, elemT, null, null);\n+    }\n+\n+    // Since 1.7:\n+    @Override\n+    public CollectionType withTypeHandler(Object h) {\n+        return new CollectionType(_class, _elementType, _valueHandler, h);\n+    }\n+\n+    // Since 1.7:\n+    @Override\n+    public CollectionType withContentTypeHandler(Object h)\n+    {\n+        return new CollectionType(_class, _elementType.withTypeHandler(h),\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    // Since 1.9:\n+    @Override\n+    public CollectionType withValueHandler(Object h) {\n+        return new CollectionType(_class, _elementType, h, _typeHandler);\n+    }\n+\n+    // Since 1.9:\n+    @Override\n+    public  CollectionType withContentValueHandler(Object h) {\n+        return new CollectionType(_class, _elementType.withValueHandler(h),\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"[collection type; class \"+_class.getName()+\", contains \"+_elementType+\"]\";\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/HierarchicType.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.lang.reflect.*;\n+\n+/**\n+ * Simple replacement for {@link java.lang.Class} (and/or various Type subtypes)\n+ * that is used as part of single-path extends/implements chain to express\n+ * specific relationship between one subtype and one supertype. This is needed\n+ * for resolving type parameters. Instances are doubly-linked so that chain\n+ * can be traversed in both directions\n+ * \n+ * @since 1.6\n+ */\n+public class HierarchicType\n+{\n+    /**\n+     * Type which will be either plain {@link java.lang.Class} or\n+     * {@link java.lang.reflect.ParameterizedType}.\n+     */\n+    protected final Type _actualType;\n+    \n+    protected final Class<?> _rawClass;\n+\n+    protected final ParameterizedType _genericType;\n+    \n+    protected HierarchicType _superType;\n+\n+    protected HierarchicType _subType;\n+    \n+    public HierarchicType(Type type)\n+    {\n+        this._actualType = type;\n+        if (type instanceof Class<?>) {\n+            _rawClass = (Class<?>) type;\n+            _genericType = null;\n+        } else if (type instanceof ParameterizedType) {\n+            _genericType = (ParameterizedType) type;\n+            _rawClass = (Class<?>) _genericType.getRawType();\n+        } else { // should never happen... can't extend GenericArrayType?\n+            throw new IllegalArgumentException(\"Type \"+type.getClass().getName()+\" can not be used to construct HierarchicType\");\n+        }\n+    }\n+\n+    private HierarchicType(Type actualType, Class<?> rawClass, ParameterizedType genericType,\n+        HierarchicType superType, HierarchicType subType)\n+    {\n+        _actualType = actualType;\n+        _rawClass = rawClass;\n+        _genericType = genericType;\n+        _superType = superType;\n+        _subType = subType;\n+    }\n+    \n+    /**\n+     * Method that can be used to create a deep clone of this hierarchic type, including\n+     * super types (but not subtypes)\n+     * \n+     * @since 1.9\n+     */\n+    public HierarchicType deepCloneWithoutSubtype()\n+    {\n+        HierarchicType sup = (_superType == null) ? null : _superType.deepCloneWithoutSubtype();\n+        HierarchicType result = new HierarchicType(_actualType, _rawClass, _genericType, sup, null);\n+        if (sup != null) {\n+            sup.setSubType(result);\n+        }\n+        return result;\n+    }\n+    \n+    public void setSuperType(HierarchicType sup) { _superType = sup; }\n+    public final HierarchicType getSuperType() { return _superType; }\n+    public void setSubType(HierarchicType sub) { _subType = sub; }\n+    public final HierarchicType getSubType() { return _subType; }\n+    \n+    public final boolean isGeneric() { return _genericType != null; }\n+    public final ParameterizedType asGeneric() { return _genericType; }\n+\n+    public final Class<?> getRawClass() { return _rawClass; }\n+    \n+    @Override\n+    public String toString() {\n+        if (_genericType != null) {\n+            return _genericType.toString();\n+        }\n+        return _rawClass.getName();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Type that represents Map-like types; things that consist of key/value pairs but that\n+ * do not necessarily implement {@link java.util.Map}, but that do not have enough\n+ * introspection functionality to allow for some level of generic handling.\n+ * This specifically allows framework to check for configuration and annotation\n+ * settings used for Map types, and pass these to custom handlers that may be more\n+ * familiar with actual type.\n+ *\n+ * @since 1.8\n+ */\n+public class MapLikeType extends TypeBase\n+{\n+    /**\n+     * Type of keys of Map.\n+     */\n+    protected final JavaType _keyType;\n+\n+    /**\n+     * Type of values of Map.\n+     */\n+    protected final JavaType _valueType;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    @Deprecated // since 1.9\n+    protected MapLikeType(Class<?> mapType, JavaType keyT, JavaType valueT)\n+    {\n+        super(mapType, keyT.hashCode() ^ valueT.hashCode(), null, null);\n+        _keyType = keyT;\n+        _valueType = valueT;\n+    }\n+\n+    protected MapLikeType(Class<?> mapType, JavaType keyT, JavaType valueT,\n+            Object valueHandler, Object typeHandler)\n+    {\n+        super(mapType, keyT.hashCode() ^ valueT.hashCode(), valueHandler, typeHandler);\n+        _keyType = keyT;\n+        _valueType = valueT;\n+    }\n+    \n+    public static MapLikeType construct(Class<?> rawType, JavaType keyT, JavaType valueT)\n+    {\n+        // nominally component types will be just Object.class\n+        return new MapLikeType(rawType, keyT, valueT, null, null);\n+    }\n+\n+    @Override\n+    protected JavaType _narrow(Class<?> subclass)\n+    {\n+        return new MapLikeType(subclass, _keyType, _valueType, _valueHandler, _typeHandler);\n+    }\n+\n+    @Override\n+    public JavaType narrowContentsBy(Class<?> contentClass)\n+    {\n+        // Can do a quick check first:\n+        if (contentClass == _valueType.getRawClass()) {\n+            return this;\n+        }\n+        return new MapLikeType(_class, _keyType, _valueType.narrowBy(contentClass),\n+               _valueHandler, _typeHandler);\n+    }\n+\n+    @Override\n+    public JavaType widenContentsBy(Class<?> contentClass)\n+    {\n+        if (contentClass == _valueType.getRawClass()) {\n+            return this;\n+        }\n+        return new MapLikeType(_class, _keyType, _valueType.widenBy(contentClass),\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    public JavaType narrowKey(Class<?> keySubclass)\n+    {\n+        // Can do a quick check first:\n+        if (keySubclass == _keyType.getRawClass()) {\n+            return this;\n+        }\n+        return new MapLikeType(_class, _keyType.narrowBy(keySubclass), _valueType,\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    public JavaType widenKey(Class<?> keySubclass)\n+    {\n+        // Can do a quick check first:\n+        if (keySubclass == _keyType.getRawClass()) {\n+            return this;\n+        }\n+        return new MapLikeType(_class, _keyType.widenBy(keySubclass), _valueType,\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    // Since 1.7:\n+    @Override\n+    public MapLikeType withTypeHandler(Object h)\n+    {\n+        return new MapLikeType(_class, _keyType, _valueType, _valueHandler, h);\n+    }\n+\n+    // Since 1.7:\n+    @Override\n+    public MapLikeType withContentTypeHandler(Object h)\n+    {\n+        return new MapLikeType(_class, _keyType, _valueType.withTypeHandler(h),\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    // Since 1.9:\n+    @Override\n+    public MapLikeType withValueHandler(Object h) {\n+        return new MapLikeType(_class, _keyType, _valueType, h, _typeHandler);\n+    }\n+\n+    // Since 1.9:\n+    @Override\n+    public MapLikeType withContentValueHandler(Object h) {\n+        return new MapLikeType(_class, _keyType, _valueType.withValueHandler(h),\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    @Override\n+    protected String buildCanonicalName() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(_class.getName());\n+        if (_keyType != null) {\n+            sb.append('<');\n+            sb.append(_keyType.toCanonical());\n+            sb.append(',');\n+            sb.append(_valueType.toCanonical());\n+            sb.append('>');\n+        }\n+        return sb.toString();\n+    }\n+ \n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isContainerType() { return true; }\n+\n+    @Override\n+    public boolean isMapLikeType() { return true; }\n+    \n+    @Override\n+    public JavaType getKeyType() { return _keyType; }\n+\n+    @Override\n+    public JavaType getContentType() { return _valueType; }\n+\n+    @Override\n+    public int containedTypeCount() { return 2; }\n+    \n+    @Override\n+    public JavaType containedType(int index) {\n+        if (index == 0) return _keyType;\n+        if (index == 1) return _valueType;\n+        return null;\n+    }\n+\n+    /**\n+     * Not sure if we should count on this, but type names\n+     * for core interfaces are \"K\" and \"V\" respectively.\n+     * For now let's assume this should work.\n+     */\n+    @Override\n+    public String containedTypeName(int index) {\n+        if (index == 0) return \"K\";\n+        if (index == 1) return \"V\";\n+        return null;\n+    }\n+\n+    @Override\n+    public StringBuilder getErasedSignature(StringBuilder sb) {\n+        return _classSignature(_class, sb, true);\n+    }\n+    \n+    @Override\n+    public StringBuilder getGenericSignature(StringBuilder sb)\n+    {\n+        _classSignature(_class, sb, false);\n+        sb.append('<');\n+        _keyType.getGenericSignature(sb);\n+        _valueType.getGenericSignature(sb);\n+        sb.append(\">;\");\n+        return sb;\n+    }\n+ \n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public MapLikeType withKeyTypeHandler(Object h)\n+    {\n+        return new MapLikeType(_class, _keyType.withTypeHandler(h), _valueType,\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    public MapLikeType withKeyValueHandler(Object h) {\n+        return new MapLikeType(_class, _keyType.withValueHandler(h), _valueType,\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    /**\n+     * Method that can be used for checking whether this type is a\n+     * \"real\" Collection type; meaning whether it represents a parameterized\n+     * subtype of {@link java.util.Collection} or just something that acts\n+     * like one.\n+     * \n+     * @since 1.8\n+     */\n+    public boolean isTrueMapType() {\n+        return Map.class.isAssignableFrom(_class);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"[map-like type; class \"+_class.getName()+\", \"+_keyType+\" -> \"+_valueType+\"]\";\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) return false;\n+\n+        MapLikeType other = (MapLikeType) o;\n+        return (_class == other._class)\n+            && _keyType.equals(other._keyType)\n+            && _valueType.equals(other._valueType);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Type that represents \"true\" Java Map types.\n+ */\n+public final class MapType extends MapLikeType\n+{\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    @Deprecated\n+    private MapType(Class<?> mapType, JavaType keyT, JavaType valueT) {\n+        this(mapType, keyT, valueT, null, null);\n+    }\n+\n+    private MapType(Class<?> mapType, JavaType keyT, JavaType valueT,\n+            Object valueHandler, Object typeHandler) {\n+        super(mapType, keyT, valueT, valueHandler, typeHandler);\n+    }\n+    \n+    public static MapType construct(Class<?> rawType, JavaType keyT, JavaType valueT) {\n+        // nominally component types will be just Object.class\n+        return new MapType(rawType, keyT, valueT, null, null);\n+    }\n+\n+    @Override\n+    protected JavaType _narrow(Class<?> subclass) {\n+        return new MapType(subclass, _keyType, _valueType,\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    @Override\n+    public JavaType narrowContentsBy(Class<?> contentClass)\n+    {\n+        // Can do a quick check first:\n+        if (contentClass == _valueType.getRawClass()) {\n+            return this;\n+        }\n+        return new MapType(_class, _keyType, _valueType.narrowBy(contentClass),\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    @Override\n+    public JavaType widenContentsBy(Class<?> contentClass)\n+    {\n+        if (contentClass == _valueType.getRawClass()) {\n+            return this;\n+        }\n+        return new MapType(_class, _keyType, _valueType.widenBy(contentClass),\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    @Override\n+    public JavaType narrowKey(Class<?> keySubclass)\n+    {\n+        // Can do a quick check first:\n+        if (keySubclass == _keyType.getRawClass()) {\n+            return this;\n+        }\n+        return new MapType(_class, _keyType.narrowBy(keySubclass), _valueType,\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    /**\n+     * @since 1.8\n+     */\n+    @Override\n+    public JavaType widenKey(Class<?> keySubclass)\n+    {\n+        // Can do a quick check first:\n+        if (keySubclass == _keyType.getRawClass()) {\n+            return this;\n+        }\n+        return new MapType(_class, _keyType.widenBy(keySubclass), _valueType,\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    // Since 1.7:\n+    @Override\n+    public MapType withTypeHandler(Object h) {\n+        return new MapType(_class, _keyType, _valueType, _valueHandler, h);\n+    }\n+\n+    // Since 1.7:\n+    @Override\n+    public MapType withContentTypeHandler(Object h)\n+    {\n+        return new MapType(_class, _keyType, _valueType.withTypeHandler(h),\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    // Since 1.9:\n+    @Override\n+    public MapType withValueHandler(Object h) {\n+        return new MapType(_class, _keyType, _valueType, h, _typeHandler);\n+    }\n+\n+    // Since 1.9:\n+    @Override\n+    public MapType withContentValueHandler(Object h) {\n+        return new MapType(_class, _keyType, _valueType.withValueHandler(h),\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    @Override\n+    public MapType withKeyTypeHandler(Object h)\n+    {\n+        return new MapType(_class, _keyType.withTypeHandler(h), _valueType,\n+                _valueHandler, _typeHandler);\n+    }\n+\n+    /**\n+     * @since 1.9\n+     */\n+    @Override\n+    public MapType withKeyValueHandler(Object h) {\n+        return new MapType(_class, _keyType.withValueHandler(h), _valueType,\n+                _valueHandler, _typeHandler);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString()\n+    {\n+        return \"[map type; class \"+_class.getName()+\", \"+_keyType+\" -> \"+_valueType+\"]\";\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Simple types are defined as anything other than one of recognized\n+ * container types (arrays, Collections, Maps). For our needs we\n+ * need not know anything further, since we have no way of dealing\n+ * with generic types other than Collections and Maps.\n+ */\n+public final class SimpleType\n+    extends TypeBase\n+{\n+    /**\n+     * Generic type arguments for this type.\n+     */\n+    protected final JavaType[] _typeParameters;\n+\n+    /**\n+     * Names of generic type arguments for this type; will\n+     * match values in {@link #_typeParameters}\n+     */\n+    protected final String[] _typeNames;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    protected SimpleType(Class<?> cls) {\n+        this(cls, null, null, null, null);\n+    }\n+\n+    @Deprecated // since 1.9\n+    protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams)\n+    {\n+        this(cls, typeNames, typeParams, null, null);\n+    }\n+\n+    protected SimpleType(Class<?> cls, String[] typeNames, JavaType[] typeParams,\n+            Object valueHandler, Object typeHandler)\n+    {\n+        super(cls, 0, valueHandler, typeHandler);\n+        if (typeNames == null || typeNames.length == 0) {\n+            _typeNames = null;\n+            _typeParameters = null;\n+        } else {\n+            _typeNames = typeNames;\n+            _typeParameters = typeParams;\n+        }\n+    }\n+\n+    /**\n+     * Method used by core Jackson classes: NOT to be used by application code.\n+     *<p>\n+     * NOTE: public only because it is called by <code>ObjectMapper</code> which is\n+     * not in same package\n+     */\n+    public static SimpleType constructUnsafe(Class<?> raw) {\n+        return new SimpleType(raw, null, null, null, null);\n+    }\n+    \n+    @Override\n+    protected JavaType _narrow(Class<?> subclass)\n+    {\n+        // Should we check that there is a sub-class relationship?\n+        return new SimpleType(subclass, _typeNames, _typeParameters, _valueHandler, _typeHandler);\n+    }\n+\n+    @Override\n+    public JavaType narrowContentsBy(Class<?> subclass)\n+    {\n+        // should never get called\n+        throw new IllegalArgumentException(\"Internal error: SimpleType.narrowContentsBy() should never be called\");\n+    }\n+\n+    @Override\n+    public JavaType widenContentsBy(Class<?> subclass)\n+    {\n+        // should never get called\n+        throw new IllegalArgumentException(\"Internal error: SimpleType.widenContentsBy() should never be called\");\n+    }\n+    \n+    public static SimpleType construct(Class<?> cls)\n+    {\n+        /* Let's add sanity checks, just to ensure no\n+         * Map/Collection entries are constructed\n+         */\n+        if (Map.class.isAssignableFrom(cls)) {\n+            throw new IllegalArgumentException(\"Can not construct SimpleType for a Map (class: \"+cls.getName()+\")\");\n+        }\n+        if (Collection.class.isAssignableFrom(cls)) {\n+            throw new IllegalArgumentException(\"Can not construct SimpleType for a Collection (class: \"+cls.getName()+\")\");\n+        }\n+        // ... and while we are at it, not array types either\n+        if (cls.isArray()) {\n+            throw new IllegalArgumentException(\"Can not construct SimpleType for an array (class: \"+cls.getName()+\")\");\n+        }\n+        return new SimpleType(cls);\n+    }\n+\n+    // Since 1.7:\n+    @Override\n+    public SimpleType withTypeHandler(Object h)\n+    {\n+        return new SimpleType(_class, _typeNames, _typeParameters, _valueHandler, h);\n+    }\n+\n+    // Since 1.7:\n+    @Override\n+    public JavaType withContentTypeHandler(Object h) {\n+        // no content type, so:\n+        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenTypeHandler()\");\n+    }\n+\n+    // Since 1.9:\n+    @Override\n+    public SimpleType withValueHandler(Object h) {\n+        if (h == _valueHandler) {\n+            return this;\n+        }\n+        return new SimpleType(_class, _typeNames, _typeParameters, h, _typeHandler);\n+    }\n+    \n+    // Since 1.9:\n+    @Override\n+    public  SimpleType withContentValueHandler(Object h) {\n+        // no content type, so:\n+        throw new IllegalArgumentException(\"Simple types have no content types; can not call withContenValueHandler()\");\n+    }\n+    \n+    @Override\n+    protected String buildCanonicalName()\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(_class.getName());\n+        if (_typeParameters != null && _typeParameters.length > 0) {\n+            sb.append('<');\n+            boolean first = true;\n+            for (JavaType t : _typeParameters) {\n+                if (first) {\n+                    first = false;\n+                } else {\n+                    sb.append(',');\n+                }\n+                sb.append(t.toCanonical());\n+            }\n+            sb.append('>');\n+        }\n+        return sb.toString();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isContainerType() { return false; }\n+    \n+    @Override\n+    public int containedTypeCount() {\n+        return (_typeParameters == null) ? 0 : _typeParameters.length;\n+    }\n+\n+    @Override\n+    public JavaType containedType(int index)\n+    {\n+        if (index < 0 || _typeParameters == null || index >= _typeParameters.length) {\n+            return null;\n+        }\n+        return _typeParameters[index];\n+    }\n+\n+    @Override\n+    public String containedTypeName(int index)\n+    {\n+        if (index < 0 || _typeNames == null || index >= _typeNames.length) {\n+            return null;\n+        }\n+        return _typeNames[index];\n+    }\n+    \n+    @Override\n+    public StringBuilder getErasedSignature(StringBuilder sb) {\n+        return _classSignature(_class, sb, true);\n+    }\n+    \n+    @Override\n+    public StringBuilder getGenericSignature(StringBuilder sb)\n+    {\n+        _classSignature(_class, sb, false);\n+        if (_typeParameters != null) {\n+            sb.append('<');\n+            for (JavaType param : _typeParameters) {\n+                sb = param.getGenericSignature(sb);\n+            }\n+            sb.append('>');\n+        }\n+        sb.append(';');\n+        return sb;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder(40);\n+        sb.append(\"[simple type, class \").append(buildCanonicalName()).append(']');\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) return false;\n+\n+        SimpleType other = (SimpleType) o;\n+\n+        // Classes must be identical... \n+        if (other._class != this._class) return false;\n+\n+        // And finally, generic bindings, if any\n+        JavaType[] p1 = _typeParameters;\n+        JavaType[] p2 = other._typeParameters;\n+        if (p1 == null) {\n+            return (p2 == null) || p2.length == 0;\n+        }\n+        if (p2 == null) return false;\n+\n+        if (p1.length != p2.length) return false;\n+        for (int i = 0, len = p1.length; i < len; ++i) {\n+            if (!p1[i].equals(p2[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeBase.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.databind.JsonSerializableWithType;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+\n+\n+public abstract class TypeBase\n+    extends JavaType\n+    implements JsonSerializableWithType\n+{\n+    /**\n+     * Lazily initialized external representation of the type\n+     */\n+    volatile String _canonicalName;\n+\n+    @Deprecated // since 1.9; to remove from 2.0\n+    protected TypeBase(Class<?> raw, int hash) {\n+        super(raw, hash);\n+    }\n+\n+    /**\n+     * Main constructor to use by extending classes.\n+     * \n+     * @since 1.9\n+     */\n+    protected TypeBase(Class<?> raw, int hash,\n+            Object valueHandler, Object typeHandler)\n+    {\n+        super(raw, hash);\n+        // @TODO: !!! 16-Aug-2011, tatu: With 2.0, we will move value and type\n+        //   handles higher in type hierarchy, make final\n+\n+        // and then comment out these:\n+        _valueHandler = valueHandler;\n+        _typeHandler = typeHandler;\n+    }\n+\n+    @Override\n+    public String toCanonical()\n+    {\n+    \tString str = _canonicalName;\n+    \tif (str == null) {\n+            str = buildCanonicalName();\n+    \t}\n+    \treturn str;\n+    }\n+    \n+    protected abstract String buildCanonicalName();\n+\n+    @Override\n+    public abstract StringBuilder getGenericSignature(StringBuilder sb);\n+\n+    @Override\n+    public abstract StringBuilder getErasedSignature(StringBuilder sb);\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T getValueHandler() { return (T) _valueHandler; }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public <T> T getTypeHandler() { return (T) _typeHandler; }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonSerializableWithType base implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void serializeWithType(JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException\n+    {\n+        typeSer.writeTypePrefixForScalar(this, jgen);\n+        this.serialize(jgen, provider);\n+        typeSer.writeTypeSuffixForScalar(this, jgen);\n+    }\n+\n+    @Override\n+    public void serialize(JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonProcessingException\n+    {\n+        jgen.writeString(toCanonical());\n+    } \n+    \n+    /*\n+    /**********************************************************\n+    /* Methods for sub-classes to use\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @param trailingSemicolon Whether to add trailing semicolon for non-primitive\n+     *   (reference) types or not\n+     */\n+    protected static StringBuilder _classSignature(Class<?> cls, StringBuilder sb,\n+           boolean trailingSemicolon)\n+    {\n+        if (cls.isPrimitive()) {\n+            if (cls == Boolean.TYPE) {                \n+                sb.append('Z');\n+            } else if (cls == Byte.TYPE) {\n+                sb.append('B');\n+            }\n+            else if (cls == Short.TYPE) {\n+                sb.append('S');\n+            }\n+            else if (cls == Character.TYPE) {\n+                sb.append('C');\n+            }\n+            else if (cls == Integer.TYPE) {\n+                sb.append('I');\n+            }\n+            else if (cls == Long.TYPE) {\n+                sb.append('J');\n+            }\n+            else if (cls == Float.TYPE) {\n+                sb.append('F');\n+            }\n+            else if (cls == Double.TYPE) {\n+                sb.append('D');\n+            }\n+            else if (cls == Void.TYPE) {\n+                sb.append('V');\n+            } else {\n+                throw new IllegalStateException(\"Unrecognized primitive type: \"+cls.getName());\n+            }\n+        } else {\n+            sb.append('L');\n+            String name = cls.getName();\n+            for (int i = 0, len = name.length(); i < len; ++i) {\n+                char c = name.charAt(i);\n+                if (c == '.') c = '/';\n+                sb.append(c);\n+            }\n+            if (trailingSemicolon) {\n+                sb.append(';');\n+            }\n+        }\n+        return sb;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Helper class used for resolving type parameters for given class\n+ * \n+ * @since 1.5\n+ */\n+public class TypeBindings\n+{\n+    private final static JavaType[] NO_TYPES = new JavaType[0];\n+    \n+    /**\n+     * Marker to use for (temporarily) unbound references.\n+     */\n+    public final static JavaType UNBOUND = new SimpleType(Object.class);\n+\n+    /**\n+     * Factory to use for constructing resolved related types.\n+     */\n+    protected final TypeFactory _typeFactory;\n+    \n+    /**\n+     * Context type used for resolving all types, if specified. May be null,\n+     * in which case {@link #_contextClass} is used instead.\n+     */\n+    protected final JavaType _contextType;\n+\n+    /**\n+     * Specific class to use for resolving all types, for methods and fields\n+     * class and its superclasses and -interfaces contain.\n+     */\n+    protected final Class<?> _contextClass;\n+\n+    /**\n+     * Lazily-instantiated bindings of resolved type parameters\n+     */\n+    protected Map<String,JavaType> _bindings;\n+\n+    /**\n+     * Also: we may temporarily want to mark certain named types\n+     * as resolved (but without exact type); if so, we'll just store\n+     * names here.\n+     */\n+    protected HashSet<String> _placeholders;\n+\n+    /**\n+     * Sometimes it is necessary to allow hierarchic resolution of types: specifically\n+     * in cases where there are local bindings (for methods, constructors). If so,\n+     * we'll just use simple delegation model.\n+     * \n+     * @since 1.7\n+     */\n+    private final TypeBindings _parentBindings;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+    \n+    public TypeBindings(TypeFactory typeFactory, Class<?> cc)\n+    {\n+        this(typeFactory, null, cc, null);\n+    }\n+\n+    public TypeBindings(TypeFactory typeFactory, JavaType type)\n+    {\n+        this(typeFactory, null, type.getRawClass(), type);\n+    }\n+\n+    /**\n+     * Constructor used to create \"child\" instances; mostly to\n+     * allow delegation from explicitly defined local overrides\n+     * (local type variables for methods, constructors) to\n+     * contextual (class-defined) ones.\n+     * \n+     * @since 1.7\n+     */\n+    public TypeBindings childInstance() {\n+        return new TypeBindings(_typeFactory, this, _contextClass, _contextType);\n+    }\n+\n+    /**\n+     * @since 1.7\n+     */\n+    private TypeBindings(TypeFactory tf, TypeBindings parent, Class<?> cc, JavaType type)\n+    {\n+        _typeFactory = tf;\n+        _parentBindings = parent;\n+        _contextClass = cc;\n+        _contextType = type;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Pass-through type resolution methods\n+    /**********************************************************\n+     */\n+\n+    public JavaType resolveType(Class<?> cls) {\n+        return _typeFactory._constructType(cls, this);\n+    }\n+\n+    public JavaType resolveType(Type type) {\n+        return _typeFactory._constructType(type, this);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Accesors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 1.8\n+     */\n+    /*\n+    public TypeFactory getTypeFactory() {\n+        return _typeFactory;\n+    }\n+    */\n+    \n+    public int getBindingCount() {\n+        if (_bindings == null) {\n+            _resolve();\n+        }\n+        return _bindings.size();\n+    }\n+    \n+    public JavaType findType(String name)\n+    {\n+        if (_bindings == null) {\n+            _resolve();\n+        }\n+        JavaType t = _bindings.get(name);\n+        if (t != null) {\n+            return t;\n+        }\n+        if (_placeholders != null && _placeholders.contains(name)) {\n+            return UNBOUND;\n+        }\n+        // New with 1.7: check parent context\n+        if (_parentBindings != null) {\n+            return _parentBindings.findType(name);\n+        }\n+        // nothing found, so...\n+        // Should we throw an exception or just return null?\n+        \n+        /* [JACKSON-499] 18-Feb-2011, tatu: There are some tricky type bindings within\n+         *   java.util, such as HashMap$KeySet; so let's punt the problem\n+         *   (honestly not sure what to do -- they are unbound for good, I think)\n+         */\n+        if (_contextClass != null) {\n+            Class<?> enclosing = _contextClass.getEnclosingClass();\n+            if (enclosing != null) {\n+                // [JACKSON-572]: Actually, let's skip this for all non-static inner classes\n+                //   (which will also cover 'java.util' type cases...\n+                if (!Modifier.isStatic(_contextClass.getModifiers())) {\n+                    return UNBOUND;\n+                }\n+\n+                // ... so this piece of code should not be needed any more\n+                /*\n+                Package pkg = enclosing.getPackage();\n+                if (pkg != null) {\n+                    // as per [JACKSON-533], also include \"java.util.concurrent\":\n+                    if (pkg.getName().startsWith(\"java.util\")) {\n+                        return UNBOUND;\n+                    }\n+                }\n+                */\n+            }\n+        }\n+        \n+        String className;\n+        if (_contextClass != null) {\n+            className = _contextClass.getName();\n+        } else if (_contextType != null) {\n+            className = _contextType.toString();\n+        } else {\n+            className = \"UNKNOWN\";\n+        }\n+        throw new IllegalArgumentException(\"Type variable '\"+name\n+                +\"' can not be resolved (with context of class \"+className+\")\");\n+        //t = UNBOUND;                \n+    }\n+\n+    public void addBinding(String name, JavaType type)\n+    {\n+        // note: emptyMap() is unmodifiable, hence second check is needed:\n+        if (_bindings == null || _bindings.size() == 0) {\n+            _bindings = new LinkedHashMap<String,JavaType>();\n+        }\n+        _bindings.put(name, type);\n+    }\n+\n+    public JavaType[] typesAsArray()\n+    {\n+        if (_bindings == null) {\n+            _resolve();\n+        }\n+        if (_bindings.size() == 0) {\n+            return NO_TYPES;\n+        }\n+        return _bindings.values().toArray(new JavaType[_bindings.size()]);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+    \n+    protected void _resolve()\n+    {\n+        _resolveBindings(_contextClass);\n+\n+        // finally: may have root level type info too\n+        if (_contextType != null) {\n+            int count = _contextType.containedTypeCount();\n+            if (count > 0) {\n+                if (_bindings == null) {\n+                    _bindings = new LinkedHashMap<String,JavaType>();\n+                }\n+                for (int i = 0; i < count; ++i) {\n+                    String name = _contextType.containedTypeName(i);\n+                    JavaType type = _contextType.containedType(i);\n+                    _bindings.put(name, type);\n+                }\n+            }\n+        }\n+\n+        // nothing bound? mark with empty map to prevent further calls\n+        if (_bindings == null) {\n+            _bindings = Collections.emptyMap();\n+        }\n+    }\n+\n+    public void _addPlaceholder(String name) {\n+        if (_placeholders == null) {\n+            _placeholders = new HashSet<String>();\n+        }\n+        _placeholders.add(name);\n+    }\n+\n+    protected void _resolveBindings(Type t)\n+    {\n+        if (t == null) return;\n+        \n+        Class<?> raw;\n+        if (t instanceof ParameterizedType) {\n+            ParameterizedType pt = (ParameterizedType) t;\n+            Type[] args = pt.getActualTypeArguments();\n+            if (args  != null && args.length > 0) {\n+                Class<?> rawType = (Class<?>) pt.getRawType();    \n+                TypeVariable<?>[] vars = rawType.getTypeParameters();\n+                if (vars.length != args.length) {\n+                    throw new IllegalArgumentException(\"Strange parametrized type (in class \"+rawType.getName()+\"): number of type arguments != number of type parameters (\"+args.length+\" vs \"+vars.length+\")\");\n+                }\n+                for (int i = 0, len = args.length; i < len; ++i) {\n+                    TypeVariable<?> var = vars[i];\n+                    String name = var.getName();\n+                    if (_bindings == null) {\n+                        _bindings = new LinkedHashMap<String,JavaType>();\n+                    } else {\n+                        /* 24-Mar-2010, tatu: Better ensure that we do not overwrite something\n+                         *  collected earlier (since we descend towards super-classes):\n+                         */\n+                        if (_bindings.containsKey(name)) continue;\n+                    }\n+                    // first: add a placeholder to prevent infinite loops\n+                    _addPlaceholder(name);\n+                    // then resolve type\n+                    _bindings.put(name, _typeFactory._constructType(args[i], this));\n+                }\n+            }\n+            raw = (Class<?>)pt.getRawType();\n+        } else if (t instanceof Class<?>) {\n+            raw = (Class<?>) t;\n+            /* [JACKSON-677]: If this is an inner class then the generics are defined on the \n+             * enclosing class so we have to check there as well.  We don't\n+             * need to call getEnclosingClass since anonymous classes declare \n+             * generics\n+             */\n+            _resolveBindings(raw.getDeclaringClass());\n+            /* 24-Mar-2010, tatu: Can not have true generics definitions, but can\n+             *   have lower bounds (\"<T extends BeanBase>\") in declaration itself\n+             */\n+            TypeVariable<?>[] vars = raw.getTypeParameters();\n+            if (vars != null && vars.length > 0) {\n+                for (TypeVariable<?> var : vars) {\n+                    String name = var.getName();\n+                    Type varType = var.getBounds()[0];\n+                    if (varType != null) {\n+                        if (_bindings == null) {\n+                            _bindings = new LinkedHashMap<String,JavaType>();\n+                        } else { // and no overwriting...\n+                            if (_bindings.containsKey(name)) continue;\n+                        }\n+                        _addPlaceholder(name); // to prevent infinite loops\n+                        _bindings.put(name, _typeFactory._constructType(varType, this));\n+                    }\n+                }\n+            }\n+        } else { // probably can't be any of these... so let's skip for now\n+            //if (type instanceof GenericArrayType) {\n+            //if (type instanceof TypeVariable<?>) {\n+            // if (type instanceof WildcardType) {\n+            return;\n+        }\n+        // but even if it's not a parameterized type, its super types may be:\n+        _resolveBindings(raw.getGenericSuperclass());\n+        for (Type intType : raw.getGenericInterfaces()) {\n+            _resolveBindings(intType);\n+        }\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        if (_bindings == null) {\n+            _resolve();\n+        }\n+        StringBuilder sb = new StringBuilder(\"[TypeBindings for \");\n+        if (_contextType != null) {\n+            sb.append(_contextType.toString());\n+        } else {\n+            sb.append(_contextClass.getName());\n+        }\n+        sb.append(\": \").append(_bindings).append(\"]\");\n+        return sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.util.*;\n+import java.lang.reflect.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.util.ArrayBuilders;\n+\n+\n+/**\n+ * Class used for creating concrete {@link JavaType} instances,\n+ * given various inputs.\n+ *<p>\n+ * As of Jackson 1.8, usage should be done using instance configured\n+ * via {@link com.fasterxml.jackson.databind.ObjectMapper} (and exposed through\n+ * {@link com.fasterxml.jackson.databind.DeserializationConfig} and\n+ * {@link com.fasterxml.jackson.databind.SerializationConfig}).\n+ * However, old static-singleton access methods are supported as well; however,\n+ * using those may cause issues with extension modules that register\n+ * \"type enchancers\".\n+ *<p>\n+ * Typical usage pattern before Jackson 1.8 was to statically import factory methods\n+ * of this class, to allow convenient instantiation of structured\n+ * types, especially {@link Collection} and {@link Map} types\n+ * to represent generic types. For example\n+ *<pre>\n+ * mapType(String.class, Integer.class)\n+ *</pre>\n+ * to represent\n+ *<pre>\n+ *  Map&lt;String,Integer>\n+ *</pre>\n+ * This is an alternative to using {@link TypeReference} that would\n+ * be something like\n+ *<pre>\n+ *  new TypeReference&lt;Map&lt;String,Integer>>() { }\n+ *</pre>\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public final class TypeFactory\n+{\n+    /**\n+     * Globally shared singleton. Should never be accessed directly; non-core\n+     * code should use per-ObjectMapper instance (via configuration objects).\n+     * Core Jackson code uses {@link #defaultInstance} for accessing it.\n+     * \n+     * @deprecated As of 1.8, should use a per-ObjectMapper instance instead\n+     *    of global singleton\n+     */\n+    @Deprecated\n+    public final static TypeFactory instance = new TypeFactory();\n+\n+    private final static JavaType[] NO_TYPES = new JavaType[0];\n+\n+    /**\n+     * Registered {@link TypeModifier}s: objects that can change details\n+     * of {@link JavaType} instances factory constructs.\n+     * \n+     * @since 1.8\n+     */\n+    protected final TypeModifier[] _modifiers;\n+    \n+    protected final TypeParser _parser;\n+\n+    /*\n+     * Looks like construction of {@link JavaType} instances can be\n+     * a bottleneck, esp. for root-level Maps, so we better do bit\n+     * of low-level component caching here...\n+     */\n+\n+    /**\n+     * Lazily constructed copy of type hierarchy from {@link java.util.HashMap}\n+     * to its supertypes.\n+     * \n+     * @since 1.9\n+     */\n+    protected HierarchicType _cachedHashMapType;\n+\n+    /**\n+     * Lazily constructed copy of type hierarchy from {@link java.util.ArrayList}\n+     * to its supertypes.\n+     * \n+     * @since 1.9\n+     */\n+    protected HierarchicType _cachedArrayListType;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    private TypeFactory() {\n+        _parser = new TypeParser(this);\n+        _modifiers = null;\n+    }\n+\n+    protected TypeFactory(TypeParser p, TypeModifier[] mods) {\n+        _parser = p;\n+        _modifiers = mods;\n+    }\n+\n+    public TypeFactory withModifier(TypeModifier mod) \n+    {\n+        if (_modifiers == null) {\n+            return new TypeFactory(_parser, new TypeModifier[] { mod });\n+        }\n+        return new TypeFactory(_parser, ArrayBuilders.insertInListNoDup(_modifiers, mod));\n+    }\n+\n+    /**\n+     * Method used to access the globally shared instance, which has\n+     * no custom configuration. Used by <code>ObjectMapper</code> to\n+     * get the default factory when constructed.\n+     * \n+     * @since 1.8\n+     */\n+    public static TypeFactory defaultInstance() { return instance; }\n+\n+    /*\n+    /**********************************************************\n+    /* Static methods for non-instance-specific functionality\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method for constructing a marker type that indicates missing generic\n+     * type information, which is handled same as simple type for\n+     * <code>java.lang.Object</code>.\n+     * \n+     * @since 1.8\n+     */\n+    public static JavaType unknownType() {\n+        return defaultInstance()._unknownType();\n+    }\n+\n+    public static Class<?> rawClass(Type t) {\n+        if (t instanceof Class<?>) {\n+            return (Class<?>) t;\n+        }\n+        // Can optimize bit more in future...\n+        return defaultInstance().constructType(t).getRawClass();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Legacy factory methods (pre-1.8)\n+    /**********************************************************\n+     */\n+\n+    @Deprecated\n+    public static JavaType type(Type t) {\n+        return instance._constructType(t, null);\n+    }\n+\n+    @Deprecated\n+    public static JavaType type(Type type, Class<?> context) {\n+        return instance.constructType(type, context);\n+    }\n+\n+    @Deprecated\n+    public static JavaType type(Type type, JavaType context) {\n+        return instance.constructType(type, context);\n+    }\n+    \n+    @Deprecated\n+    public static JavaType type(Type type, TypeBindings bindings) {\n+        return instance._constructType(type, bindings);\n+    }\n+\n+    @Deprecated\n+    public static JavaType type(TypeReference<?> ref) {\n+        return instance.constructType(ref.getType());\n+    }\n+    \n+    @Deprecated\n+    public static JavaType arrayType(Class<?> elementType) {\n+        return instance.constructArrayType(instance.constructType(elementType));\n+    }\n+\n+    @Deprecated\n+    public static JavaType arrayType(JavaType elementType) {\n+        return instance.constructArrayType(elementType);\n+    }\n+\n+    @Deprecated\n+    public static JavaType collectionType(Class<? extends Collection> collectionType, Class<?> elementType) {\n+        return instance.constructCollectionType(collectionType, instance.constructType(elementType));\n+    }\n+    \n+    @Deprecated\n+    public static JavaType collectionType(Class<? extends Collection> collectionType, JavaType elementType) {\n+        return instance.constructCollectionType(collectionType, elementType);\n+    }\n+    \n+    @Deprecated\n+    public static JavaType mapType(Class<? extends Map> mapClass, Class<?> keyType, Class<?> valueType)\n+    {\n+        return instance.constructMapType(mapClass, type(keyType), instance.constructType(valueType));\n+    }\n+\n+    @Deprecated\n+    public static JavaType mapType(Class<? extends Map> mapType, JavaType keyType, JavaType valueType) {\n+        return instance.constructMapType(mapType, keyType, valueType);\n+    }\n+\n+    @Deprecated\n+    public static JavaType parametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n+        return instance.constructParametricType(parametrized, parameterClasses);\n+    }\n+    \n+    @Deprecated\n+    public static JavaType parametricType(Class<?> parametrized, JavaType... parameterTypes) {\n+        return instance.constructParametricType(parametrized, parameterTypes);\n+    }\n+\n+    public static JavaType fromCanonical(String canonical) throws IllegalArgumentException {\n+        return instance.constructFromCanonical(canonical);\n+    }\n+    \n+    @Deprecated\n+    public static JavaType specialize(JavaType baseType, Class<?> subclass) {\n+        return instance.constructSpecializedType(baseType, subclass);\n+    }\n+    \n+    @Deprecated\n+    public static JavaType fastSimpleType(Class<?> cls) {\n+        return instance.uncheckedSimpleType(cls);\n+    }\n+\n+    @Deprecated\n+    public static JavaType[] findParameterTypes(Class<?> clz, Class<?> expType) {\n+        return instance.findTypeParameters(clz, expType);\n+    }\n+\n+    @Deprecated\n+    public static JavaType[] findParameterTypes(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n+        return instance.findTypeParameters(clz, expType, bindings);\n+    }\n+\n+    @Deprecated\n+    public static JavaType[] findParameterTypes(JavaType type, Class<?> expType) {\n+        return instance.findTypeParameters(type, expType);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Legacy methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory method that can be used if only type information\n+     * available is of type {@link Class}. This means that there\n+     * will not be generic type information due to type erasure,\n+     * but at least it will be possible to recognize array\n+     * types and non-typed container types.\n+     * And for other types (primitives/wrappers, beans), this\n+     * is all that is needed.\n+     *\n+     * @deprecated Use {@link #type(Type)} instead\n+     */\n+    @Deprecated\n+    public static JavaType fromClass(Class<?> clz)\n+    {\n+        return instance._fromClass(clz, null);\n+    }\n+\n+    /**\n+     * Factory method that can be used if the full generic type has\n+     * been passed using {@link TypeReference}. This only needs to be\n+     * done if the root type to bind to is generic; but if so,\n+     * it must be done to get proper typing.\n+     *\n+     * @deprecated Use {@link #type(Type)} instead\n+     */\n+    @Deprecated\n+    public static JavaType fromTypeReference(TypeReference<?> ref)\n+    {\n+        return type(ref.getType());\n+    }\n+\n+    /**\n+     * Factory method that can be used if type information is passed\n+     * as Java typing returned from <code>getGenericXxx</code> methods\n+     * (usually for a return or argument type).\n+     *\n+     * @deprecated Use {@link #type(Type)} instead\n+     */\n+    @Deprecated\n+    public static JavaType fromType(Type type)\n+    {\n+        return instance._constructType(type, null);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Type conversion, parameterization resolution methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory method for creating a subtype of given base type, as defined\n+     * by specified subclass; but retaining generic type information if any.\n+     * Can be used, for example, to get equivalent of \"HashMap&lt;String,Integer>\"\n+     * from \"Map&ltString,Integer>\" by giving <code>HashMap.class</code>\n+     * as subclass.\n+     */\n+    public JavaType constructSpecializedType(JavaType baseType, Class<?> subclass)\n+    {\n+        // Currently only SimpleType instances can become something else\n+        if (baseType instanceof SimpleType) {\n+            // and only if subclass is an array, Collection or Map\n+            if (subclass.isArray()\n+                || Map.class.isAssignableFrom(subclass)\n+                || Collection.class.isAssignableFrom(subclass)) {\n+                // need to assert type compatibility...\n+                if (!baseType.getRawClass().isAssignableFrom(subclass)) {\n+                    throw new IllegalArgumentException(\"Class \"+subclass.getClass().getName()+\" not subtype of \"+baseType);\n+                }\n+                // this _should_ work, right?\n+                JavaType subtype = _fromClass(subclass, new TypeBindings(this, baseType.getRawClass()));\n+                // one more thing: handlers to copy?\n+                Object h = baseType.getValueHandler();\n+                if (h != null) {\n+//                  subtype.setValueHandler(h);\n+                    subtype = subtype.withValueHandler(h);\n+                }\n+                h = baseType.getTypeHandler();\n+                if (h != null) {\n+                    subtype = subtype.withTypeHandler(h);\n+                }\n+                return subtype;\n+            }\n+        }\n+        // otherwise regular narrowing should work just fine\n+        return baseType.narrowBy(subclass);\n+    }\n+\n+    /**\n+     * Factory method for constructing a {@link JavaType} out of its canonical\n+     * representation (see {@link JavaType#toCanonical()}).\n+     * \n+     * @param canonical Canonical string representation of a type\n+     * \n+     * @throws IllegalArgumentException If canonical representation is malformed,\n+     *   or class that type represents (including its generic parameters) is\n+     *   not found\n+     * \n+     * @since 1.8\n+     */\n+    public JavaType constructFromCanonical(String canonical) throws IllegalArgumentException\n+    {\n+        return _parser.parse(canonical);\n+    }\n+    \n+    /**\n+     * Method that is to figure out actual type parameters that given\n+     * class binds to generic types defined by given (generic)\n+     * interface or class.\n+     * This could mean, for example, trying to figure out\n+     * key and value types for Map implementations.\n+     * \n+     * @param type Sub-type (leaf type) that implements <code>expType</code>\n+     * \n+     * @since 1.6\n+     */\n+    public JavaType[] findTypeParameters(JavaType type, Class<?> expType)\n+    {\n+        /* Tricky part here is that some JavaType instances have been constructed\n+         * from generic type (usually via TypeReference); and in those case\n+         * types have been resolved. Alternative is that the leaf type is type-erased\n+         * class, in which case this has not been done.\n+         * For now simplest way to handle this is to split processing in two: latter\n+         * case actually fully works; and former mostly works. In future may need to\n+         * rewrite former part, which requires changes to JavaType as well.\n+         */\n+        Class<?> raw = type.getRawClass();\n+        if (raw == expType) {\n+            // Direct type info; good since we can return it as is\n+            int count = type.containedTypeCount();\n+            if (count == 0) return null;\n+            JavaType[] result = new JavaType[count];\n+            for (int i = 0; i < count; ++i) {\n+                result[i] = type.containedType(i);\n+            }\n+            return result;\n+        }\n+        /* Otherwise need to go through type-erased class. This may miss cases where\n+         * we get generic type; ideally JavaType/SimpleType would retain information\n+         * about generic declaration at main level... but let's worry about that\n+         * if/when there are problems; current handling is an improvement over earlier\n+         * code.\n+         */\n+        return findTypeParameters(raw, expType, new TypeBindings(this, type));\n+    }\n+\n+    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType) {\n+        return findTypeParameters(clz, expType, new TypeBindings(this, clz));\n+    }\n+    \n+    public JavaType[] findTypeParameters(Class<?> clz, Class<?> expType, TypeBindings bindings)\n+    {\n+        // First: find full inheritance chain\n+        HierarchicType subType = _findSuperTypeChain(clz, expType);\n+        // Caller is supposed to ensure this never happens, so:\n+        if (subType == null) {\n+            throw new IllegalArgumentException(\"Class \"+clz.getName()+\" is not a subtype of \"+expType.getName());\n+        }\n+        // Ok and then go to the ultimate super-type:\n+        HierarchicType superType = subType;\n+        while (superType.getSuperType() != null) {\n+            superType = superType.getSuperType();\n+            Class<?> raw = superType.getRawClass();\n+            TypeBindings newBindings = new TypeBindings(this, raw);\n+            if (superType.isGeneric()) { // got bindings, need to resolve\n+                ParameterizedType pt = superType.asGeneric();\n+                Type[] actualTypes = pt.getActualTypeArguments();\n+                TypeVariable<?>[] vars = raw.getTypeParameters();\n+                int len = actualTypes.length;\n+                for (int i = 0; i < len; ++i) {\n+                    String name = vars[i].getName();\n+                    JavaType type = instance._constructType(actualTypes[i], bindings);\n+                    newBindings.addBinding(name, type);\n+                }\n+            }\n+            bindings = newBindings;\n+        }\n+\n+        // which ought to be generic (if not, it's raw type)\n+        if (!superType.isGeneric()) {\n+            return null;\n+        }\n+        return bindings.typesAsArray();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public factory methods\n+    /**********************************************************\n+     */\n+\n+    public JavaType constructType(Type type) {\n+        return _constructType(type, null);\n+    }\n+\n+    public JavaType constructType(Type type, TypeBindings bindings) {\n+        return _constructType(type, bindings);\n+    }\n+    \n+    public JavaType constructType(TypeReference<?> typeRef) {\n+        return _constructType(typeRef.getType(), null);\n+    }\n+    \n+    public JavaType constructType(Type type, Class<?> context) {\n+        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n+        return _constructType(type, b);\n+    }\n+\n+    public JavaType constructType(Type type, JavaType context) {\n+        TypeBindings b = (context == null) ? null : new TypeBindings(this, context);\n+        return _constructType(type, b);\n+    }\n+    \n+    /**\n+     * Factory method that can be used if type information is passed\n+     * as Java typing returned from <code>getGenericXxx</code> methods\n+     * (usually for a return or argument type).\n+     */\n+    public JavaType _constructType(Type type, TypeBindings context)\n+    {\n+        JavaType resultType;\n+\n+        // simple class?\n+        if (type instanceof Class<?>) {\n+            Class<?> cls = (Class<?>) type;\n+            /* 24-Mar-2010, tatu: Better create context if one was not passed;\n+             *   mostly matters for root serialization types\n+             */\n+            if (context == null) {\n+                context = new TypeBindings(this, cls);\n+            }\n+            resultType = _fromClass(cls, context);\n+        }\n+        // But if not, need to start resolving.\n+        else if (type instanceof ParameterizedType) {\n+            resultType = _fromParamType((ParameterizedType) type, context);\n+        }\n+        else if (type instanceof GenericArrayType) {\n+            resultType = _fromArrayType((GenericArrayType) type, context);\n+        }\n+        else if (type instanceof TypeVariable<?>) {\n+            resultType = _fromVariable((TypeVariable<?>) type, context);\n+        }\n+        else if (type instanceof WildcardType) {\n+            resultType = _fromWildcard((WildcardType) type, context);\n+        } else {\n+            // sanity check\n+            throw new IllegalArgumentException(\"Unrecognized Type: \"+type.toString());\n+        }\n+        /* [JACKSON-521]: Need to allow TypeModifiers to alter actual type; however,\n+         * for now only call for simple types (i.e. not for arrays, map or collections).\n+         * Can be changed in future it necessary\n+         */\n+        if (_modifiers != null && !resultType.isContainerType()) {\n+            for (TypeModifier mod : _modifiers) {\n+                resultType = mod.modifyType(resultType, type, context, this);\n+            }\n+        }\n+        return resultType;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Direct factory methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for constructing an {@link ArrayType}.\n+     *<p>\n+     * NOTE: type modifiers are NOT called on array type itself; but are called\n+     * for element type (and other contained types)\n+     */\n+    public ArrayType constructArrayType(Class<?> elementType) {\n+        return ArrayType.construct(_constructType(elementType, null), null, null);\n+    }\n+    \n+    /**\n+     * Method for constructing an {@link ArrayType}.\n+     *<p>\n+     * NOTE: type modifiers are NOT called on array type itself; but are called\n+     * for contained types.\n+     */\n+    public ArrayType constructArrayType(JavaType elementType) {\n+        return ArrayType.construct(elementType, null, null);\n+    }\n+\n+    /**\n+     * Method for constructing a {@link CollectionType}.\n+     *<p>\n+     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n+     * for contained types.\n+     */\n+    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, Class<?> elementClass) {\n+        return CollectionType.construct(collectionClass, constructType(elementClass));\n+    }\n+    \n+    /**\n+     * Method for constructing a {@link CollectionType}.\n+     *<p>\n+     * NOTE: type modifiers are NOT called on Collection type itself; but are called\n+     * for contained types.\n+     */\n+    public CollectionType constructCollectionType(Class<? extends Collection> collectionClass, JavaType elementType) {\n+        return CollectionType.construct(collectionClass, elementType);\n+    }\n+\n+    /**\n+     * Method for constructing a {@link CollectionLikeType}.\n+     *<p>\n+     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n+     * for contained types.\n+     * \n+     * @since 1.8\n+     */\n+    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, Class<?> elementClass) {\n+        return CollectionLikeType.construct(collectionClass, constructType(elementClass));\n+    }\n+    \n+    /**\n+     * Method for constructing a {@link CollectionLikeType}.\n+     *<p>\n+     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n+     * for contained types.\n+     * \n+     * @since 1.8\n+     */\n+    public CollectionLikeType constructCollectionLikeType(Class<?> collectionClass, JavaType elementType) {\n+        return CollectionLikeType.construct(collectionClass, elementType);\n+    }\n+    \n+    /**\n+     * Method for constructing a {@link MapType} instance\n+     *<p>\n+     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n+     * for contained types.\n+     * \n+     * @since 1.8\n+     */\n+    public MapType constructMapType(Class<? extends Map> mapClass, JavaType keyType, JavaType valueType) {\n+        return MapType.construct(mapClass, keyType, valueType);\n+    }\n+\n+    /**\n+     * Method for constructing a {@link MapType} instance\n+     *<p>\n+     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n+     * for contained types.\n+     * \n+     * @since 1.8\n+     */\n+    public MapType constructMapType(Class<? extends Map> mapClass, Class<?> keyClass, Class<?> valueClass) {\n+        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n+    }\n+\n+    /**\n+     * Method for constructing a {@link MapLikeType} instance\n+     *<p>\n+     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n+     * for contained types.\n+     * \n+     * @since 1.8\n+     */\n+    public MapLikeType constructMapLikeType(Class<?> mapClass, JavaType keyType, JavaType valueType) {\n+        return MapLikeType.construct(mapClass, keyType, valueType);\n+    }\n+    \n+    /**\n+     * Method for constructing a {@link MapLikeType} instance\n+     *<p>\n+     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n+     * for contained types.\n+     * \n+     * @since 1.8\n+     */\n+    public MapLikeType constructMapLikeType(Class<?> mapClass, Class<?> keyClass, Class<?> valueClass) {\n+        return MapType.construct(mapClass, constructType(keyClass), constructType(valueClass));\n+    }\n+    \n+    /**\n+     * Method for constructing a type instance with specified parameterization.\n+     * \n+     * @since 1.8\n+     */\n+    public JavaType constructSimpleType(Class<?> rawType, JavaType[] parameterTypes)\n+    {\n+        // Quick sanity check: must match numbers of types with expected...\n+        TypeVariable<?>[] typeVars = rawType.getTypeParameters();\n+        if (typeVars.length != parameterTypes.length) {\n+            throw new IllegalArgumentException(\"Parameter type mismatch for \"+rawType.getName()\n+                    +\": expected \"+typeVars.length+\" parameters, was given \"+parameterTypes.length);\n+        }\n+        String[] names = new String[typeVars.length];\n+        for (int i = 0, len = typeVars.length; i < len; ++i) {\n+            names[i] = typeVars[i].getName();\n+        }\n+        JavaType resultType = new SimpleType(rawType, names, parameterTypes, null, null);\n+        return resultType;\n+    } \n+\n+    /**\n+     * Method that will force construction of a simple type, without trying to\n+     * check for more specialized types.\n+     *<p> \n+     * NOTE: no type modifiers are called on type either, so calling this method\n+     * should only be used if caller really knows what it's doing...\n+     * \n+     * @since 1.8\n+     */\n+    public JavaType uncheckedSimpleType(Class<?> cls) {\n+        return new SimpleType(cls);\n+    }\n+    \n+    /**\n+     * Factory method for constructing {@link JavaType} that\n+     * represents a parameterized type. For example, to represent\n+     * type <code>List&lt;Set&lt;Integer>></code>, you could\n+     * call\n+     *<pre>\n+     *  TypeFactory.parametricType(List.class, Integer.class);\n+     *</pre>\n+     *<p>\n+     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n+     * for contained types.\n+     *\n+     * @since 1.5\n+     */\n+    public JavaType constructParametricType(Class<?> parametrized, Class<?>... parameterClasses)\n+    {\n+        int len = parameterClasses.length;\n+        JavaType[] pt = new JavaType[len];\n+        for (int i = 0; i < len; ++i) {\n+            pt[i] = _fromClass(parameterClasses[i], null);\n+        }\n+        return constructParametricType(parametrized, pt);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link JavaType} that\n+     * represents a parameterized type. For example, to represent\n+     * type <code>List&lt;Set&lt;Integer>></code>, you could\n+     * call\n+     *<pre>\n+     *  JavaType inner = TypeFactory.parametricType(Set.class, Integer.class);\n+     *  TypeFactory.parametricType(List.class, inner);\n+     *</pre>\n+     *<p>\n+     * NOTE: type modifiers are NOT called on constructed type itself; but are called\n+     * for contained types.\n+     *\n+     * @since 1.5\n+     */\n+    public JavaType constructParametricType(Class<?> parametrized, JavaType... parameterTypes)\n+    {\n+        JavaType resultType;\n+        \n+        // Need to check kind of class we are dealing with...\n+        if (parametrized.isArray()) {\n+            // 19-Jan-2010, tatus: should we support multi-dimensional arrays directly?\n+            if (parameterTypes.length != 1) {\n+                throw new IllegalArgumentException(\"Need exactly 1 parameter type for arrays (\"+parametrized.getName()+\")\");\n+            }\n+            resultType = constructArrayType(parameterTypes[0]);\n+        }\n+        else if (Map.class.isAssignableFrom(parametrized)) {\n+            if (parameterTypes.length != 2) {\n+                throw new IllegalArgumentException(\"Need exactly 2 parameter types for Map types (\"+parametrized.getName()+\")\");\n+            }\n+            resultType = constructMapType((Class<Map<?,?>>)parametrized, parameterTypes[0], parameterTypes[1]);\n+        }\n+        else if (Collection.class.isAssignableFrom(parametrized)) {\n+            if (parameterTypes.length != 1) {\n+                throw new IllegalArgumentException(\"Need exactly 1 parameter type for Collection types (\"+parametrized.getName()+\")\");\n+            }\n+            resultType = constructCollectionType((Class<Collection<?>>)parametrized, parameterTypes[0]);\n+        } else {\n+            resultType = constructSimpleType(parametrized, parameterTypes);\n+        }\n+        return resultType;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Direct factory methods for \"raw\" variants, used when\n+    /* parameterization is unknown\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to construct \"raw\" Collection type; meaning that its\n+     * parameterization is unknown.\n+     * This is similar to using <code>Object.class</code> parameterization,\n+     * and is equivalent to calling:\n+     *<pre>\n+     *  typeFactory.constructCollectionType(collectionClass, typeFactory.unknownType());\n+     *<pre>\n+     *<p>\n+     * This method should only be used if parameterization is completely unavailable.\n+     * \n+     * @since 1.9\n+     */\n+    public CollectionType constructRawCollectionType(Class<? extends Collection> collectionClass) {\n+        return CollectionType.construct(collectionClass, unknownType());\n+    }\n+\n+    /**\n+     * Method that can be used to construct \"raw\" Collection-like type; meaning that its\n+     * parameterization is unknown.\n+     * This is similar to using <code>Object.class</code> parameterization,\n+     * and is equivalent to calling:\n+     *<pre>\n+     *  typeFactory.constructCollectionLikeType(collectionClass, typeFactory.unknownType());\n+     *<pre>\n+     *<p>\n+     * This method should only be used if parameterization is completely unavailable.\n+     * \n+     * @since 1.9\n+     */\n+    public CollectionLikeType constructRawCollectionLikeType(Class<?> collectionClass) {\n+        return CollectionLikeType.construct(collectionClass, unknownType());\n+    }\n+\n+    /**\n+     * Method that can be used to construct \"raw\" Map type; meaning that its\n+     * parameterization is unknown.\n+     * This is similar to using <code>Object.class</code> parameterization,\n+     * and is equivalent to calling:\n+     *<pre>\n+     *  typeFactory.constructMapType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n+     *<pre>\n+     *<p>\n+     * This method should only be used if parameterization is completely unavailable.\n+     * \n+     * @since 1.9\n+     */\n+    public MapType constructRawMapType(Class<? extends Map> mapClass) {\n+        return MapType.construct(mapClass, unknownType(), unknownType());\n+    }\n+\n+    /**\n+     * Method that can be used to construct \"raw\" Map-like type; meaning that its\n+     * parameterization is unknown.\n+     * This is similar to using <code>Object.class</code> parameterization,\n+     * and is equivalent to calling:\n+     *<pre>\n+     *  typeFactory.constructMapLikeType(collectionClass, typeFactory.unknownType(), typeFactory.unknownType());\n+     *<pre>\n+     *<p>\n+     * This method should only be used if parameterization is completely unavailable.\n+     * \n+     * @since 1.9\n+     */\n+    public MapLikeType constructRawMapLikeType(Class<?> mapClass) {\n+        return MapLikeType.construct(mapClass, unknownType(), unknownType());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Actual factory methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * @param context Mapping of formal parameter declarations (for generic\n+     *   types) into actual types\n+     */\n+    protected JavaType _fromClass(Class<?> clz, TypeBindings context)\n+    {\n+        // First: do we have an array type?\n+        if (clz.isArray()) {\n+            return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n+        }\n+        /* Also: although enums can also be fully resolved, there's little\n+         * point in doing so (T extends Enum<T>) etc.\n+         */\n+        if (clz.isEnum()) {\n+            return new SimpleType(clz);\n+        }\n+        /* Maps and Collections aren't quite as hot; problem is, due\n+         * to type erasure we often do not know typing and can only assume\n+         * base Object.\n+         */\n+        if (Map.class.isAssignableFrom(clz)) {\n+            return _mapType(clz);\n+        }\n+        if (Collection.class.isAssignableFrom(clz)) {\n+            return _collectionType(clz);\n+        }\n+        return new SimpleType(clz);\n+    }\n+    \n+    /**\n+     * Method used by {@link TypeParser} when generics-aware version\n+     * is constructed.\n+     */\n+    protected JavaType _fromParameterizedClass(Class<?> clz, List<JavaType> paramTypes)\n+    {\n+        if (clz.isArray()) { // ignore generics (should never have any)\n+            return ArrayType.construct(_constructType(clz.getComponentType(), null), null, null);\n+        }\n+        if (clz.isEnum()) { // ditto for enums\n+            return new SimpleType(clz);\n+        }\n+        if (Map.class.isAssignableFrom(clz)) {\n+            // First: if we do have param types, use them\n+            JavaType keyType, contentType;\n+            if (paramTypes.size() > 0) {\n+                keyType = paramTypes.get(0);\n+                contentType = (paramTypes.size() >= 2) ?\n+                        paramTypes.get(1) : _unknownType();\n+                return MapType.construct(clz, keyType, contentType);\n+            }\n+            return _mapType(clz);\n+        }\n+        if (Collection.class.isAssignableFrom(clz)) {\n+            if (paramTypes.size() >= 1) {\n+                return CollectionType.construct(clz, paramTypes.get(0));\n+            }\n+            return _collectionType(clz);\n+        }\n+        if (paramTypes.size() == 0) {\n+            return new SimpleType(clz);\n+        }\n+        JavaType[] pt = paramTypes.toArray(new JavaType[paramTypes.size()]);\n+        return constructSimpleType(clz, pt);\n+    }\n+    \n+    /**\n+     * This method deals with parameterized types, that is,\n+     * first class generic classes.\n+     *<p>\n+     * Since version 1.2, this resolves all parameterized types, not just\n+     * Maps or Collections.\n+     */\n+    protected JavaType _fromParamType(ParameterizedType type, TypeBindings context)\n+    {\n+        /* First: what is the actual base type? One odd thing\n+         * is that 'getRawType' returns Type, not Class<?> as\n+         * one might expect. But let's assume it is always of\n+         * type Class: if not, need to add more code to resolve\n+         * it to Class.\n+         */\n+        Class<?> rawType = (Class<?>) type.getRawType();\n+        Type[] args = type.getActualTypeArguments();\n+        int paramCount = (args == null) ? 0 : args.length;\n+\n+        JavaType[] pt;\n+        \n+        if (paramCount == 0) {\n+            pt = NO_TYPES;\n+        } else {\n+            pt = new JavaType[paramCount];\n+            for (int i = 0; i < paramCount; ++i) {\n+                pt[i] = _constructType(args[i], context);\n+            }\n+        }\n+\n+        // Ok: Map or Collection?\n+        if (Map.class.isAssignableFrom(rawType)) {\n+            JavaType subtype = constructSimpleType(rawType, pt);\n+            JavaType[] mapParams = findTypeParameters(subtype, Map.class);\n+            if (mapParams.length != 2) {\n+                throw new IllegalArgumentException(\"Could not find 2 type parameters for Map class \"+rawType.getName()+\" (found \"+mapParams.length+\")\");\n+            }\n+            return MapType.construct(rawType, mapParams[0], mapParams[1]);\n+        }\n+        if (Collection.class.isAssignableFrom(rawType)) {\n+            JavaType subtype = constructSimpleType(rawType, pt);\n+            JavaType[] collectionParams = findTypeParameters(subtype, Collection.class);\n+            if (collectionParams.length != 1) {\n+                throw new IllegalArgumentException(\"Could not find 1 type parameter for Collection class \"+rawType.getName()+\" (found \"+collectionParams.length+\")\");\n+            }\n+            return CollectionType.construct(rawType, collectionParams[0]);\n+        }\n+        if (paramCount == 0) { // no generics\n+            return new SimpleType(rawType);\n+        }\n+        return constructSimpleType(rawType, pt);\n+    }\n+\n+    \n+    protected JavaType _fromArrayType(GenericArrayType type, TypeBindings context)\n+    {\n+        JavaType compType = _constructType(type.getGenericComponentType(), context);\n+        return ArrayType.construct(compType, null, null);\n+    }\n+\n+    protected JavaType _fromVariable(TypeVariable<?> type, TypeBindings context)\n+    {\n+        /* 26-Sep-2009, tatus: It should be possible to try \"partial\"\n+         *  resolution; meaning that it is ok not to find bindings.\n+         *  For now this is indicated by passing null context.\n+         */\n+        if (context == null) {\n+            return _unknownType();\n+        }\n+\n+        // Ok: here's where context might come in handy!\n+        String name = type.getName();\n+        JavaType actualType = context.findType(name);\n+        if (actualType != null) {\n+            return actualType;\n+        }\n+\n+        /* 29-Jan-2010, tatu: We used to throw exception here, if type was\n+         *   bound: but the problem is that this can occur for generic \"base\"\n+         *   method, overridden by sub-class. If so, we will want to ignore\n+         *   current type (for method) since it will be masked.\n+         */\n+        Type[] bounds = type.getBounds();\n+\n+        // With type variables we must use bound information.\n+        // Theoretically this gets tricky, as there may be multiple\n+        // bounds (\"... extends A & B\"); and optimally we might\n+        // want to choose the best match. Also, bounds are optional;\n+        // but here we are lucky in that implicit \"Object\" is\n+        // added as bounds if so.\n+        // Either way let's just use the first bound, for now, and\n+        // worry about better match later on if there is need.\n+\n+        /* 29-Jan-2010, tatu: One more problem are recursive types\n+         *   (T extends Comparable<T>). Need to add \"placeholder\"\n+         *   for resolution to catch those.\n+         */\n+        context._addPlaceholder(name);        \n+        return _constructType(bounds[0], context);\n+    }\n+\n+    protected JavaType _fromWildcard(WildcardType type, TypeBindings context)\n+    {\n+        /* Similar to challenges with TypeVariable, we may have\n+         * multiple upper bounds. But it is also possible that if\n+         * upper bound defaults to Object, we might want to consider\n+         * lower bounds instead.\n+         *\n+         * For now, we won't try anything more advanced; above is\n+         * just for future reference.\n+         */\n+        return _constructType(type.getUpperBounds()[0], context);\n+    }\n+\n+    private JavaType _mapType(Class<?> rawClass)\n+    {\n+        JavaType[] typeParams = findTypeParameters(rawClass, Map.class);\n+        // ok to have no types (\"raw\")\n+        if (typeParams == null) {\n+            return MapType.construct(rawClass, _unknownType(), _unknownType());\n+        }\n+        // but exactly 2 types if any found\n+        if (typeParams.length != 2) {\n+            throw new IllegalArgumentException(\"Strange Map type \"+rawClass.getName()+\": can not determine type parameters\");\n+        }\n+        return MapType.construct(rawClass, typeParams[0], typeParams[1]);\n+    }\n+\n+    private JavaType _collectionType(Class<?> rawClass)\n+    {\n+        JavaType[] typeParams = findTypeParameters(rawClass, Collection.class);\n+        // ok to have no types (\"raw\")\n+        if (typeParams == null) {\n+            return CollectionType.construct(rawClass, _unknownType());\n+        }\n+        // but exactly 2 types if any found\n+        if (typeParams.length != 1) {\n+            throw new IllegalArgumentException(\"Strange Collection type \"+rawClass.getName()+\": can not determine type parameters\");\n+        }\n+        return CollectionType.construct(rawClass, typeParams[0]);\n+    }    \n+\n+    protected JavaType _resolveVariableViaSubTypes(HierarchicType leafType, String variableName, TypeBindings bindings)\n+    {\n+        // can't resolve raw types; possible to have as-of-yet-unbound types too:\n+        if (leafType != null && leafType.isGeneric()) {\n+            TypeVariable<?>[] typeVariables = leafType.getRawClass().getTypeParameters();\n+            for (int i = 0, len = typeVariables.length; i < len; ++i) {\n+                TypeVariable<?> tv = typeVariables[i];\n+                if (variableName.equals(tv.getName())) {\n+                    // further resolution needed?\n+                    Type type = leafType.asGeneric().getActualTypeArguments()[i];\n+                    if (type instanceof TypeVariable<?>) {\n+                        return _resolveVariableViaSubTypes(leafType.getSubType(), ((TypeVariable<?>) type).getName(), bindings);\n+                    }\n+                    // no we're good for the variable (but it may have parameterization of its own)\n+                    return _constructType(type, bindings);\n+                }\n+            }\n+        }\n+        return _unknownType();\n+    }\n+    \n+    protected JavaType _unknownType() {\n+        return new SimpleType(Object.class);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method used to find inheritance (implements, extends) path\n+     * between given types, if one exists (caller generally checks before\n+     * calling this method). Returned type represents given <b>subtype</b>,\n+     * with supertype linkage extending to <b>supertype</b>.\n+     */\n+    protected HierarchicType  _findSuperTypeChain(Class<?> subtype, Class<?> supertype)\n+    {\n+        // If super-type is a class (not interface), bit simpler\n+        if (supertype.isInterface()) {\n+            return _findSuperInterfaceChain(subtype, supertype);\n+        }\n+        return _findSuperClassChain(subtype, supertype);\n+    }\n+\n+    protected HierarchicType _findSuperClassChain(Type currentType, Class<?> target)\n+    {\n+        HierarchicType current = new HierarchicType(currentType);\n+        Class<?> raw = current.getRawClass();\n+        if (raw == target) {\n+            return current;\n+        }\n+        // Otherwise, keep on going down the rat hole...\n+        Type parent = raw.getGenericSuperclass();\n+        if (parent != null) {\n+            HierarchicType sup = _findSuperClassChain(parent, target);\n+            if (sup != null) {\n+                sup.setSubType(current);\n+                current.setSuperType(sup);\n+                return current;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected HierarchicType _findSuperInterfaceChain(Type currentType, Class<?> target)\n+    {\n+        HierarchicType current = new HierarchicType(currentType);\n+        Class<?> raw = current.getRawClass();\n+        if (raw == target) {\n+            return new HierarchicType(currentType);\n+        }\n+        // Otherwise, keep on going down the rat hole; first implemented interfaces\n+        /* 16-Aug-2011, tatu: Minor optimization based on profiled hot spot; let's\n+         *   try caching certain commonly needed cases\n+         */\n+        if (raw == HashMap.class) {\n+            if (target == Map.class) {\n+                return _hashMapSuperInterfaceChain(current);\n+            }\n+        }\n+        if (raw == ArrayList.class) {\n+            if (target == List.class) {\n+                return _arrayListSuperInterfaceChain(current);\n+            }\n+        }\n+        return _doFindSuperInterfaceChain(current, target);\n+    }\n+    \n+    protected HierarchicType _doFindSuperInterfaceChain(HierarchicType current, Class<?> target)\n+    {\n+        Class<?> raw = current.getRawClass();\n+        Type[] parents = raw.getGenericInterfaces();\n+        // as long as there are superclasses\n+        // and unless we have already seen the type (<T extends X<T>>)\n+        if (parents != null) {\n+            for (Type parent : parents) {\n+                HierarchicType sup = _findSuperInterfaceChain(parent, target);\n+                if (sup != null) {\n+                    sup.setSubType(current);\n+                    current.setSuperType(sup);\n+                    return current;\n+                }\n+            }\n+        }\n+        // and then super-class if any\n+        Type parent = raw.getGenericSuperclass();\n+        if (parent != null) {\n+            HierarchicType sup = _findSuperInterfaceChain(parent, target);\n+            if (sup != null) {\n+                sup.setSubType(current);\n+                current.setSuperType(sup);\n+                return current;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected synchronized HierarchicType _hashMapSuperInterfaceChain(HierarchicType current)\n+    {\n+        if (_cachedHashMapType == null) {\n+            HierarchicType base = current.deepCloneWithoutSubtype();\n+            _doFindSuperInterfaceChain(base, Map.class);\n+            _cachedHashMapType = base.getSuperType();\n+        }\n+        HierarchicType t = _cachedHashMapType.deepCloneWithoutSubtype();\n+        current.setSuperType(t);\n+        t.setSubType(current);\n+        return current;\n+    }\n+\n+    protected synchronized HierarchicType _arrayListSuperInterfaceChain(HierarchicType current)\n+    {\n+        if (_cachedArrayListType == null) {\n+            HierarchicType base = current.deepCloneWithoutSubtype();\n+            _doFindSuperInterfaceChain(base, List.class);\n+            _cachedArrayListType = base.getSuperType();\n+        }\n+        HierarchicType t = _cachedArrayListType.deepCloneWithoutSubtype();\n+        current.setSuperType(t);\n+        t.setSubType(current);\n+        return current;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeModifier.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.lang.reflect.Type;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Class that defines API that can be used to modify details of\n+ * {@link JavaType} instances constructed using {@link TypeFactory}.\n+ * Registered modifiers are called in order, to let them modify (or\n+ * replace) basic type instance factory constructs.\n+ * This is typically needed to support creation of\n+ * {@link MapLikeType} and {@link CollectionLikeType} instances,\n+ * as those can not be constructed in generic fashion.\n+ * \n+ * @since 1.8\n+ */\n+public abstract class TypeModifier\n+{\n+    /**\n+     * Method called to let modifier change constructed type definition.\n+     * Note that as of version 1.8 this is only guaranteed to be called for\n+     * non-container types (\"simple\" types not recognized as arrays,\n+     * <code>java.util.Collection</code> or <code>java.util.Map</code>).\n+     * \n+     * @param type Instance to modify\n+     * @param jdkType JDK type that was used to construct instance to modify\n+     * @param context Type resolution context used for the type\n+     * @param typeFactory Type factory that can be used to construct parameter type; note,\n+     *   however, that care must be taken to avoid infinite loops -- specifically, do not\n+     *   construct instance of primary type itself\n+     * \n+     * @return Actual type instance to use; usually either <code>type</code> (as is or with\n+     *    modifications), or a newly constructed type instance based on it. Can not be null.\n+     */\n+    public abstract JavaType modifyType(JavaType type, Type jdkType, TypeBindings context,\n+            TypeFactory typeFactory);\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeParser.java\n+package com.fasterxml.jackson.databind.type;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+/**\n+ * Simple recursive-descent parser for parsing canonical {@link JavaType}\n+ * representations and constructing type instances.\n+ * \n+ * @author tatu\n+ */\n+public class TypeParser\n+{\n+    final TypeFactory _factory;\n+        \n+    public TypeParser(TypeFactory f) {\n+        _factory = f;\n+    }\n+\n+    public JavaType parse(String canonical)\n+        throws IllegalArgumentException\n+    {\n+        canonical = canonical.trim();\n+        MyTokenizer tokens = new MyTokenizer(canonical);\n+        JavaType type = parseType(tokens);\n+        // must be end, now\n+        if (tokens.hasMoreTokens()) {\n+            throw _problem(tokens, \"Unexpected tokens after complete type\");\n+        }\n+        return type;\n+    }\n+\n+    protected JavaType parseType(MyTokenizer tokens)\n+        throws IllegalArgumentException\n+    {\n+        if (!tokens.hasMoreTokens()) {\n+            throw _problem(tokens, \"Unexpected end-of-string\");\n+        }\n+        Class<?> base = findClass(tokens.nextToken(), tokens);\n+        // either end (ok, non generic type), or generics\n+        if (tokens.hasMoreTokens()) {\n+            String token = tokens.nextToken();\n+            if (\"<\".equals(token)) {\n+                return _factory._fromParameterizedClass(base, parseTypes(tokens));\n+            }\n+            // can be comma that separates types, or closing '>'\n+            tokens.pushBack(token);\n+        }\n+        return _factory._fromClass(base, null);\n+    }\n+\n+    protected List<JavaType> parseTypes(MyTokenizer tokens)\n+        throws IllegalArgumentException\n+    {\n+        ArrayList<JavaType> types = new ArrayList<JavaType>();\n+        while (tokens.hasMoreTokens()) {\n+            types.add(parseType(tokens));\n+            if (!tokens.hasMoreTokens()) break;\n+            String token = tokens.nextToken();\n+            if (\">\".equals(token)) return types;\n+            if (!\",\".equals(token)) {\n+                throw _problem(tokens, \"Unexpected token '\"+token+\"', expected ',' or '>')\");\n+            }\n+        }\n+        throw _problem(tokens, \"Unexpected end-of-string\");\n+    }\n+\n+    protected Class<?> findClass(String className, MyTokenizer tokens)\n+    {\n+        try {\n+            /* [JACKSON-350]: Default Class.forName() won't work too well; context class loader\n+             *    seems like slightly better choice\n+             */\n+//          return Class.forName(className);\n+            ClassLoader loader = Thread.currentThread().getContextClassLoader();\n+            return Class.forName(className, true, loader);\n+        } catch (Exception e) {\n+            if (e instanceof RuntimeException) {\n+                throw (RuntimeException) e;\n+            }\n+            throw _problem(tokens, \"Can not locate class '\"+className+\"', problem: \"+e.getMessage());\n+        }\n+    }\n+\n+    protected IllegalArgumentException _problem(MyTokenizer tokens, String msg)\n+    {\n+        return new IllegalArgumentException(\"Failed to parse type '\"+tokens.getAllInput()\n+                +\"' (remaining: '\"+tokens.getRemainingInput()+\"'): \"+msg);\n+    }\n+\n+    final static class MyTokenizer\n+        extends StringTokenizer\n+    {\n+        protected final String _input;\n+\n+        protected int _index;\n+\n+        protected String _pushbackToken;\n+        \n+        public MyTokenizer(String str) {            \n+            super(str, \"<,>\", true);\n+            _input = str;\n+        }\n+\n+        @Override\n+        public boolean hasMoreTokens() {\n+            return (_pushbackToken != null) || super.hasMoreTokens();\n+        }\n+        \n+        @Override\n+        public String nextToken() {\n+            String token;\n+            if (_pushbackToken != null) {\n+                token = _pushbackToken;\n+                _pushbackToken = null;\n+            } else {\n+                token = super.nextToken();\n+            }\n+            _index += token.length();\n+            return token;\n+        }\n+\n+        public void pushBack(String token) {\n+            _pushbackToken = token;\n+            _index -= token.length();\n+        }\n+        \n+        public String getAllInput() { return _input; }\n+        public String getUsedInput() { return _input.substring(0, _index); }\n+        public String getRemainingInput() { return _input.substring(_index); }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/package-info.java\n+/**\n+ * Package that contains concrete implementations of\n+ * {@link org.codehaus.jackson.type.JavaType}, as\n+ * well as the factory ({@link com.fasterxml.jackson.databind.type.TypeFactory}) for\n+ * constructing instances from various input data types\n+ * (like {@link java.lang.Class}, {@link java.lang.reflect.Type})\n+ * and programmatically (for structured types, arrays,\n+ * {@link java.util.List}s and {@link java.util.Map}s).\n+ */\n+package com.fasterxml.jackson.databind.type;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/Annotations.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.lang.annotation.Annotation;\n+\n+/**\n+ * Interface that defines interface for collection of annotations.\n+ *<p>\n+ * Standard mutable implementation is {@link com.fasterxml.jackson.databind.introspect.AnnotationMap}\n+ * \n+ * @since 1.7\n+ */\n+public interface Annotations\n+{\n+    /**\n+     * Main access method used to find value for given annotation.\n+     */\n+    public <A extends Annotation> A get(Class<A> cls);\n+\n+    /**\n+     * Returns number of annotation entries in this collection.\n+     */\n+    public int size();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.lang.reflect.Array;\n+import java.util.*;\n+\n+/**\n+ * Helper class that contains set of distinct builders for different\n+ * arrays of primitive values. It also provides trivially simple\n+ * reuse scheme, which assumes that caller knows not to use instances\n+ * concurrently (which works ok with primitive arrays since they can\n+ * not contain other non-primitive types).\n+ */\n+public final class ArrayBuilders\n+{\n+    BooleanBuilder _booleanBuilder = null;\n+\n+    // note: no need for char[] builder, assume they are Strings\n+\n+    ByteBuilder _byteBuilder = null;\n+    ShortBuilder _shortBuilder = null;\n+    IntBuilder _intBuilder = null;\n+    LongBuilder _longBuilder = null;\n+    \n+    FloatBuilder _floatBuilder = null;\n+    DoubleBuilder _doubleBuilder = null;\n+\n+    public ArrayBuilders() { }\n+\n+    public BooleanBuilder getBooleanBuilder()\n+    {\n+        if (_booleanBuilder == null) {\n+            _booleanBuilder = new BooleanBuilder();\n+        }\n+        return _booleanBuilder;\n+    }\n+\n+    public ByteBuilder getByteBuilder()\n+    {\n+        if (_byteBuilder == null) {\n+            _byteBuilder = new ByteBuilder();\n+        }\n+        return _byteBuilder;\n+    }\n+    public ShortBuilder getShortBuilder()\n+    {\n+        if (_shortBuilder == null) {\n+            _shortBuilder = new ShortBuilder();\n+        }\n+        return _shortBuilder;\n+    }\n+    public IntBuilder getIntBuilder()\n+    {\n+        if (_intBuilder == null) {\n+            _intBuilder = new IntBuilder();\n+        }\n+        return _intBuilder;\n+    }\n+    public LongBuilder getLongBuilder()\n+    {\n+        if (_longBuilder == null) {\n+            _longBuilder = new LongBuilder();\n+        }\n+        return _longBuilder;\n+    }\n+\n+    public FloatBuilder getFloatBuilder()\n+    {\n+        if (_floatBuilder == null) {\n+            _floatBuilder = new FloatBuilder();\n+        }\n+        return _floatBuilder;\n+    }\n+    public DoubleBuilder getDoubleBuilder()\n+    {\n+        if (_doubleBuilder == null) {\n+            _doubleBuilder = new DoubleBuilder();\n+        }\n+        return _doubleBuilder;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Impl classes\n+    /**********************************************************\n+     */\n+\n+    public final static class BooleanBuilder\n+        extends PrimitiveArrayBuilder<boolean[]>\n+    {\n+        public BooleanBuilder() { }\n+        @Override\n+        public final boolean[] _constructArray(int len) { return new boolean[len]; }\n+    }\n+\n+    public final static class ByteBuilder\n+        extends PrimitiveArrayBuilder<byte[]>\n+    {\n+        public ByteBuilder() { }\n+        @Override\n+        public final byte[] _constructArray(int len) { return new byte[len]; }\n+    }\n+    public final static class ShortBuilder\n+        extends PrimitiveArrayBuilder<short[]>\n+    {\n+        public ShortBuilder() { }\n+        @Override\n+        public final short[] _constructArray(int len) { return new short[len]; }\n+    }\n+    public final static class IntBuilder\n+        extends PrimitiveArrayBuilder<int[]>\n+    {\n+        public IntBuilder() { }\n+        @Override\n+        public final int[] _constructArray(int len) { return new int[len]; }\n+    }\n+    public final static class LongBuilder\n+        extends PrimitiveArrayBuilder<long[]>\n+    {\n+        public LongBuilder() { }\n+        @Override\n+        public final long[] _constructArray(int len) { return new long[len]; }\n+    }\n+\n+    public final static class FloatBuilder\n+        extends PrimitiveArrayBuilder<float[]>\n+    {\n+        public FloatBuilder() { }\n+        @Override\n+        public final float[] _constructArray(int len) { return new float[len]; }\n+    }\n+    public final static class DoubleBuilder\n+        extends PrimitiveArrayBuilder<double[]>\n+    {\n+        public DoubleBuilder() { }\n+        @Override\n+        public final double[] _constructArray(int len) { return new double[len]; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Static helper methods\n+    /**********************************************************\n+     */\n+\n+    public static <T> HashSet<T> arrayToSet(T[] elements)\n+    {\n+        HashSet<T> result = new HashSet<T>();\n+        if (elements != null) {\n+            for (T elem : elements) {\n+                result.add(elem);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Helper method for adding specified element to a List, but also\n+     * considering case where the List may not have been yet constructed\n+     * (that is, null is passed instead).\n+     * \n+     * @param list List to add to; may be null to indicate that a new\n+     *    List is to be constructed\n+     * @param element Element to add to list\n+     * \n+     * @return List in which element was added; either <code>list</code>\n+     *   (if it was not null), or a newly constructed List.\n+     */\n+    public static <T> List<T> addToList(List<T> list, T element)\n+    {\n+        if (list == null) {\n+            list = new ArrayList<T>();\n+        }\n+        list.add(element);\n+        return list;\n+    }\n+\n+    /**\n+     * Helper method for constructing a new array that contains specified\n+     * element followed by contents of the given array. No checking is done\n+     * to see if element being inserted is duplicate.\n+     */\n+    public static <T> T[] insertInList(T[] array, T element)\n+    {\n+        int len = array.length;\n+        @SuppressWarnings(\"unchecked\")\n+        T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len+1);\n+        if (len > 0) {\n+            System.arraycopy(array, 0, result, 1, len);\n+        }\n+        result[0] = element;\n+        return result;\n+    }\n+\n+    /**\n+     * Helper method for constructing a new array that contains specified\n+     * element followed by contents of the given array but never contains\n+     * duplicates.\n+     * If element already existed, one of two things happens: if the element\n+     * was already the first one in array, array is returned as is; but\n+     * if not, a new copy is created in which element has moved as the head.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T> T[] insertInListNoDup(T[] array, T element)\n+    {\n+        final int len = array.length;\n+        \n+        // First: see if the element already exists\n+        for (int ix = 0; ix < len; ++ix) {\n+            if (array[ix] == element) {\n+                // if at head already, return as is\n+                if (ix == 0) {\n+                    return array;\n+                }\n+                // otherwise move things around\n+                T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len);\n+                System.arraycopy(array, 0, result, 1, ix);\n+                array[0] = element;\n+                return result;\n+            }\n+        }\n+\n+        // but if not, allocate new array, move\n+        T[] result = (T[]) Array.newInstance(array.getClass().getComponentType(), len+1);\n+        if (len > 0) {\n+            System.arraycopy(array, 0, result, 1, len);\n+        }\n+        result[0] = element;\n+        return result;\n+    }\n+    \n+    /**\n+     * Helper method for exposing contents of arrays using a read-only\n+     * iterator\n+     * \n+     * @since 1.7\n+     */\n+    public static <T> Iterator<T> arrayAsIterator(T[] array)\n+    {\n+        return new ArrayIterator<T>(array);\n+    }\n+\n+    public static <T> Iterable<T> arrayAsIterable(T[] array)\n+    {\n+        return new ArrayIterator<T>(array);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Iterator implementation used to efficiently expose contents of an\n+     * Array as read-only iterator.\n+     * \n+     * @since 1.7\n+     */\n+    private final static class ArrayIterator<T>\n+        implements Iterator<T>, Iterable<T>\n+    {\n+        private final T[] _array;\n+        \n+        private int _index;\n+\n+        public ArrayIterator(T[] array) {\n+            _array = array;\n+            _index = 0;\n+        }\n+        \n+        @Override public boolean hasNext() {\n+            return _index < _array.length;\n+        }\n+\n+        @Override\n+        public T next()\n+        {\n+            if (_index >= _array.length) {\n+                throw new NoSuchElementException();\n+            }\n+            return _array[_index++];\n+        }\n+\n+        @Override public void remove() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Iterator<T> iterator() {\n+            return this;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n+\n+/**\n+ * Helper class that contains functionality needed by both serialization\n+ * and deserialization side.\n+ *\n+ * @since 1.9\n+ */\n+public class BeanUtil\n+{\n+    /*\n+     * Helper method to use for sorting bean properties, based on\n+     * ordering rules indicated by annotations, config features.\n+     * \n+     * @param config Serialization/Deserialization configuration in effect\n+     * @param beanDesc Bean description\n+     * @param props Properties to sort if/as necessary\n+     * @param defaultSortByAlpha Whether properties should be (re)sorted alphabetically\n+     *   by default (unless overridden by type)\n+     */\n+    /*\n+    public static <T extends Named> List<T> sortProperties(MapperConfig<?> config,\n+            BasicBeanDescription beanDesc, List<T> props,\n+            boolean defaultSortByAlpha)\n+    {\n+        // First, order by [JACKSON-90] (explicit ordering and/or alphabetic)\n+        // and then for [JACKSON-170] (implicitly order creator properties before others)\n+        List<String> creatorProps = beanDesc.findCreatorPropertyNames();\n+        // Then how about explicit ordering?\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        AnnotatedClass ac = beanDesc.getClassInfo();\n+        String[] propertyOrder = intr.findSerializationPropertyOrder(ac);\n+        Boolean alpha = intr.findSerializationSortAlphabetically(ac);\n+        boolean sort;\n+        \n+        if (alpha == null) {\n+            sort = defaultSortByAlpha;\n+        } else {\n+            sort = alpha.booleanValue();\n+        }\n+        // no sorting? no need to shuffle, then\n+        if (!sort && creatorProps.isEmpty() && propertyOrder == null) {\n+            return props;\n+        }\n+        int size = props.size();\n+        Map<String,T> all;\n+        // Need to (re)sort alphabetically?\n+        if (sort) {\n+            all = new TreeMap<String,T>();\n+        } else {\n+            all = new LinkedHashMap<String,T>(size+size);\n+        }\n+\n+        for (T w : props) {\n+            all.put(w.getName(), w);\n+        }\n+        Map<String,T> ordered = new LinkedHashMap<String,T>(size+size);\n+        // Ok: primarily by explicit order\n+        if (propertyOrder != null) {\n+            for (String name : propertyOrder) {\n+                T w = all.get(name);\n+                if (w != null) {\n+                    ordered.put(name, w);\n+                }\n+            }\n+        }\n+        // And secondly by sorting Creator properties before other unordered properties\n+        for (String name : creatorProps) {\n+            T w = all.get(name);\n+            if (w != null) {\n+                ordered.put(name, w);\n+            }\n+        }\n+        // And finally whatever is left (trying to put again will not change ordering)\n+        ordered.putAll(all);\n+        return new ArrayList<T>(ordered.values());\n+    }\n+    */\n+\n+    /*\n+    /**********************************************************\n+    /* Handling \"getter\" names\n+    /**********************************************************\n+     */\n+\n+    public static String okNameForGetter(AnnotatedMethod am)\n+    {\n+        String name = am.getName();\n+        String str = okNameForIsGetter(am, name);\n+        if (str == null) {\n+            str = okNameForRegularGetter(am, name);\n+        }\n+        return str;\n+    }\n+\n+    public static String okNameForRegularGetter(AnnotatedMethod am, String name)\n+    {\n+        if (name.startsWith(\"get\")) {\n+            /* 16-Feb-2009, tatu: To handle [JACKSON-53], need to block\n+             *   CGLib-provided method \"getCallbacks\". Not sure of exact\n+             *   safe criteria to get decent coverage without false matches;\n+             *   but for now let's assume there's no reason to use any \n+             *   such getter from CGLib.\n+             *   But let's try this approach...\n+             */\n+            if (\"getCallbacks\".equals(name)) {\n+                if (isCglibGetCallbacks(am)) {\n+                    return null;\n+                }\n+            } else if (\"getMetaClass\".equals(name)) {\n+                /* 30-Apr-2009, tatu: [JACKSON-103], need to suppress\n+                 *    serialization of a cyclic (and useless) reference\n+                 */\n+                if (isGroovyMetaClassGetter(am)) {\n+                    return null;\n+                }\n+            }\n+            return manglePropertyName(name.substring(3));\n+        }\n+        return null;\n+    }\n+\n+    public static String okNameForIsGetter(AnnotatedMethod am, String name)\n+    {\n+        if (name.startsWith(\"is\")) {\n+            // plus, must return boolean...\n+            Class<?> rt = am.getRawType();\n+            if (rt != Boolean.class && rt != Boolean.TYPE) {\n+                return null;\n+            }\n+            return manglePropertyName(name.substring(2));\n+        }\n+        // no, not a match by name\n+        return null;\n+    }\n+\n+    public static String okNameForSetter(AnnotatedMethod am)\n+    {\n+        String name = am.getName();\n+        if (name.startsWith(\"set\")) {\n+            name = manglePropertyName(name.substring(3));\n+            if (name == null) { // plain old \"set\" is no good...\n+                return null;\n+            }\n+            if (\"metaClass\".equals(name)) {\n+                // 26-Nov-2009 [JACSON-103], need to suppress this internal groovy method\n+                if (isGroovyMetaClassSetter(am)) {\n+                    return null;\n+                }\n+            }\n+            return name;\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods for bean property name handling\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * This method was added to address [JACKSON-53]: need to weed out\n+     * CGLib-injected \"getCallbacks\". \n+     * At this point caller has detected a potential getter method\n+     * with name \"getCallbacks\" and we need to determine if it is\n+     * indeed injectect by Cglib. We do this by verifying that the\n+     * result type is \"net.sf.cglib.proxy.Callback[]\"\n+     *<p>\n+     * Also, see [JACKSON-177]; Hibernate may repackage cglib\n+     * it uses, so we better catch that too\n+     */\n+    protected static boolean isCglibGetCallbacks(AnnotatedMethod am)\n+    {\n+        Class<?> rt = am.getRawType();\n+        // Ok, first: must return an array type\n+        if (rt == null || !rt.isArray()) {\n+            return false;\n+        }\n+        /* And that type needs to be \"net.sf.cglib.proxy.Callback\".\n+         * Theoretically could just be a type that implements it, but\n+         * for now let's keep things simple, fix if need be.\n+         */\n+        Class<?> compType = rt.getComponentType();\n+        // Actually, let's just verify it's a \"net.sf.cglib.*\" class/interface\n+        Package pkg = compType.getPackage();\n+        if (pkg != null) {\n+            String pname = pkg.getName();\n+            if (pname.startsWith(\"net.sf.cglib\")\n+                // also, as per [JACKSON-177]\n+                || pname.startsWith(\"org.hibernate.repackage.cglib\")) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Similar to {@link #isCglibGetCallbacks}, need to suppress\n+     * a cyclic reference to resolve [JACKSON-103]\n+     */\n+    protected static boolean isGroovyMetaClassSetter(AnnotatedMethod am)\n+    {\n+        Class<?> argType = am.getParameterClass(0);\n+        Package pkg = argType.getPackage();\n+        if (pkg != null && pkg.getName().startsWith(\"groovy.lang\")) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Another helper method to deal with rest of [JACKSON-103]\n+     */\n+    protected static boolean isGroovyMetaClassGetter(AnnotatedMethod am)\n+    {\n+        Class<?> rt = am.getRawType();\n+        if (rt == null || rt.isArray()) {\n+            return false;\n+        }\n+        Package pkg = rt.getPackage();\n+        if (pkg != null && pkg.getName().startsWith(\"groovy.lang\")) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Method called to figure out name of the property, given \n+     * corresponding suggested name based on a method or field name.\n+     *\n+     * @param basename Name of accessor/mutator method, not including prefix\n+     *  (\"get\"/\"is\"/\"set\")\n+     */\n+    protected static String manglePropertyName(String basename)\n+    {\n+        int len = basename.length();\n+\n+        // First things first: empty basename is no good\n+        if (len == 0) {\n+            return null;\n+        }\n+        // otherwise, lower case initial chars\n+        StringBuilder sb = null;\n+        for (int i = 0; i < len; ++i) {\n+            char upper = basename.charAt(i);\n+            char lower = Character.toLowerCase(upper);\n+            if (upper == lower) {\n+                break;\n+            }\n+            if (sb == null) {\n+                sb = new StringBuilder(basename);\n+            }\n+            sb.setCharAt(i, lower);\n+        }\n+        return (sb == null) ? basename : sb.toString();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.lang.reflect.*;\n+import java.util.*;\n+\n+public final class ClassUtil\n+{\n+    /*\n+    /**********************************************************\n+    /* Methods that deal with inheritance\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will find all sub-classes and implemented interfaces\n+     * of a given class or interface. Classes are listed in order of\n+     * precedence, starting with the immediate super-class, followed by\n+     * interfaces class directly declares to implemented, and then recursively\n+     * followed by parent of super-class and so forth.\n+     * Note that <code>Object.class</code> is not included in the list\n+     * regardless of whether <code>endBefore</code> argument is defined or not.\n+     *\n+     * @param endBefore Super-type to NOT include in results, if any; when\n+     *    encountered, will be ignored (and no super types are checked).\n+     */\n+    public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore)\n+    {\n+        return findSuperTypes(cls, endBefore, new ArrayList<Class<?>>(8));\n+    }\n+\n+    public static List<Class<?>> findSuperTypes(Class<?> cls, Class<?> endBefore, List<Class<?>> result)\n+    {\n+        _addSuperTypes(cls, endBefore, result, false);\n+        return result;\n+    }\n+    \n+    private static void _addSuperTypes(Class<?> cls, Class<?> endBefore, Collection<Class<?>> result, boolean addClassItself)\n+    {\n+        if (cls == endBefore || cls == null || cls == Object.class) {\n+            return;\n+        }\n+        if (addClassItself) {\n+            if (result.contains(cls)) { // already added, no need to check supers\n+                return;\n+            }\n+            result.add(cls);\n+        }\n+        for (Class<?> intCls : cls.getInterfaces()) {\n+            _addSuperTypes(intCls, endBefore, result, true);\n+        }\n+        _addSuperTypes(cls.getSuperclass(), endBefore, result, true);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Class type detection methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @return Null if class might be a bean; type String (that identifies\n+     *   why it's not a bean) if not\n+     */\n+    public static String canBeABeanType(Class<?> type)\n+    {\n+        // First: language constructs that ain't beans:\n+        if (type.isAnnotation()) {\n+            return \"annotation\";\n+        }\n+        if (type.isArray()) {\n+            return \"array\";\n+        }\n+        if (type.isEnum()) {\n+            return \"enum\";\n+        }\n+        if (type.isPrimitive()) {\n+            return \"primitive\";\n+        }\n+\n+        // Anything else? Seems valid, then\n+        return null;\n+    }\n+\n+    /**\n+     * @deprecated since 1.9, use variant that takes second argument\n+     */\n+    @Deprecated\n+    public static String isLocalType(Class<?> type) {\n+        return isLocalType(type, false);\n+    }\n+    \n+    /**\n+     * @since 1.9\n+     */\n+    public static String isLocalType(Class<?> type, boolean allowNonStatic)\n+    {\n+        /* As per [JACKSON-187], GAE seems to throw SecurityExceptions\n+         * here and there... and GAE itself has a bug, too\n+         * (see []). Bah. So we need to catch some wayward exceptions on GAE\n+         */\n+        try {\n+            // one more: method locals, anonymous, are not good:\n+            if (type.getEnclosingMethod() != null) {\n+                return \"local/anonymous\";\n+            }\n+            \n+            /* But how about non-static inner classes? Can't construct\n+             * easily (theoretically, we could try to check if parent\n+             * happens to be enclosing... but that gets convoluted)\n+             */\n+            if (!allowNonStatic) {\n+                if (type.getEnclosingClass() != null) {\n+                    if (!Modifier.isStatic(type.getModifiers())) {\n+                        return \"non-static member class\";\n+                    }\n+                }\n+            }\n+        }\n+        catch (SecurityException e) { }\n+        catch (NullPointerException e) { }\n+        return null;\n+    }\n+\n+    /**\n+     * Method for finding enclosing class for non-static inner classes\n+     * \n+     * @since 1.9\n+     */\n+    public static Class<?> getOuterClass(Class<?> type)\n+    {\n+        // as above, GAE has some issues...\n+        try {\n+            // one more: method locals, anonymous, are not good:\n+            if (type.getEnclosingMethod() != null) {\n+                return null;\n+            }\n+            if (!Modifier.isStatic(type.getModifiers())) {\n+                return type.getEnclosingClass();\n+            }\n+        } catch (SecurityException e) { }\n+        catch (NullPointerException e) { }\n+        return null;\n+    }\n+    \n+    \n+    /**\n+     * Helper method used to weed out dynamic Proxy types; types that do\n+     * not expose concrete method API that we could use to figure out\n+     * automatic Bean (property) based serialization.\n+     */\n+    public static boolean isProxyType(Class<?> type)\n+    {\n+        // Then: well-known proxy (etc) classes\n+        if (Proxy.isProxyClass(type)) {\n+            return true;\n+        }\n+        String name = type.getName();\n+        // Hibernate uses proxies heavily as well:\n+        if (name.startsWith(\"net.sf.cglib.proxy.\")\n+            || name.startsWith(\"org.hibernate.proxy.\")) {\n+            return true;\n+        }\n+        // Not one of known proxies, nope:\n+        return false;\n+    }\n+\n+    /**\n+     * Helper method that checks if given class is a concrete one;\n+     * that is, not an interface or abstract class.\n+     */\n+    public static boolean isConcrete(Class<?> type)\n+    {\n+        int mod = type.getModifiers();\n+        return (mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0;\n+    }\n+\n+    /**\n+     * @since 1.6\n+     */\n+    public static boolean isConcrete(Member member)\n+    {\n+        int mod = member.getModifiers();\n+        return (mod & (Modifier.INTERFACE | Modifier.ABSTRACT)) == 0;\n+    }\n+    \n+    public static boolean isCollectionMapOrArray(Class<?> type)\n+    {\n+        if (type.isArray()) return true;\n+        if (Collection.class.isAssignableFrom(type)) return true;\n+        if (Map.class.isAssignableFrom(type)) return true;\n+        return false;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Type name handling methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method used to construct appropriate description\n+     * when passed either type (Class) or an instance; in latter\n+     * case, class of instance is to be used.\n+     */\n+    public static String getClassDescription(Object classOrInstance)\n+    {\n+        if (classOrInstance == null) {\n+            return \"unknown\";\n+        }\n+        Class<?> cls = (classOrInstance instanceof Class<?>) ?\n+            (Class<?>) classOrInstance : classOrInstance.getClass();\n+        return cls.getName();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Method type detection methods\n+    /**********************************************************\n+     */\n+\n+    public static boolean hasGetterSignature(Method m)\n+    {\n+        // First: static methods can't be getters\n+        if (Modifier.isStatic(m.getModifiers())) {\n+            return false;\n+        }\n+        // Must take no args\n+        Class<?>[] pts = m.getParameterTypes();\n+        if (pts != null && pts.length != 0) {\n+            return false;\n+        }\n+        // Can't be a void method\n+        if (Void.TYPE == m.getReturnType()) {\n+            return false;\n+        }\n+        // Otherwise looks ok:\n+        return true;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Exception handling\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to find the \"root cause\", innermost\n+     * of chained (wrapped) exceptions.\n+     */\n+    public static Throwable getRootCause(Throwable t)\n+    {\n+        while (t.getCause() != null) {\n+            t = t.getCause();\n+        }\n+        return t;\n+    }\n+\n+    /**\n+     * Method that will unwrap root causes of given Throwable, and throw\n+     * the innermost {@link Exception} or {@link Error} as is.\n+     * This is useful in cases where mandatory wrapping is added, which\n+     * is often done by Reflection API.\n+     * \n+     * @since 1.7\n+     */\n+    public static void throwRootCause(Throwable t) throws Exception\n+    {\n+        t = getRootCause(t);\n+        if (t instanceof Exception) {\n+            throw (Exception) t;\n+        }\n+        throw (Error) t;\n+    }\n+    \n+    /**\n+     * Method that will wrap 't' as an {@link IllegalArgumentException} if it\n+     * is a checked exception; otherwise (runtime exception or error) throw as is\n+     */\n+    public static void throwAsIAE(Throwable t)\n+    {\n+        throwAsIAE(t, t.getMessage());\n+    }\n+\n+    /**\n+     * Method that will wrap 't' as an {@link IllegalArgumentException} (and with\n+     * specified message) if it\n+     * is a checked exception; otherwise (runtime exception or error) throw as is\n+     */\n+    public static void throwAsIAE(Throwable t, String msg)\n+    {\n+        if (t instanceof RuntimeException) {\n+            throw (RuntimeException) t;\n+        }\n+        if (t instanceof Error) {\n+            throw (Error) t;\n+        }\n+        throw new IllegalArgumentException(msg, t);\n+    }\n+\n+    /**\n+     * Method that will locate the innermost exception for given Throwable;\n+     * and then wrap it as an {@link IllegalArgumentException} if it\n+     * is a checked exception; otherwise (runtime exception or error) throw as is\n+     */\n+    public static void unwrapAndThrowAsIAE(Throwable t)\n+    {\n+        throwAsIAE(getRootCause(t));\n+    }\n+\n+    /**\n+     * Method that will locate the innermost exception for given Throwable;\n+     * and then wrap it as an {@link IllegalArgumentException} if it\n+     * is a checked exception; otherwise (runtime exception or error) throw as is\n+     */\n+    public static void unwrapAndThrowAsIAE(Throwable t, String msg)\n+    {\n+        throwAsIAE(getRootCause(t), msg);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Instantiation\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be called to try to create an instantiate of\n+     * specified type. Instantiation is done using default no-argument\n+     * constructor.\n+     *\n+     * @param canFixAccess Whether it is possible to try to change access\n+     *   rights of the default constructor (in case it is not publicly\n+     *   accessible) or not.\n+     *\n+     * @throws IllegalArgumentException If instantiation fails for any reason;\n+     *    except for cases where constructor throws an unchecked exception\n+     *    (which will be passed as is)\n+     */\n+    public static <T> T createInstance(Class<T> cls, boolean canFixAccess)\n+        throws IllegalArgumentException\n+    {\n+        Constructor<T> ctor = findConstructor(cls, canFixAccess);\n+        if (ctor == null) {\n+            throw new IllegalArgumentException(\"Class \"+cls.getName()+\" has no default (no arg) constructor\");\n+        }\n+        try {\n+            return ctor.newInstance();\n+        } catch (Exception e) {\n+            ClassUtil.unwrapAndThrowAsIAE(e, \"Failed to instantiate class \"+cls.getName()+\", problem: \"+e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    public static <T> Constructor<T> findConstructor(Class<T> cls, boolean canFixAccess)\n+        throws IllegalArgumentException\n+    {\n+        try {\n+            Constructor<T> ctor = cls.getDeclaredConstructor();\n+            if (canFixAccess) {\n+                checkAndFixAccess(ctor);\n+            } else {\n+                // Has to be public...\n+                if (!Modifier.isPublic(ctor.getModifiers())) {\n+                    throw new IllegalArgumentException(\"Default constructor for \"+cls.getName()+\" is not accessible (non-public?): not allowed to try modify access via Reflection: can not instantiate type\");\n+                }\n+            }\n+            return ctor;\n+        } catch (NoSuchMethodException e) {\n+            ;\n+        } catch (Exception e) {\n+            ClassUtil.unwrapAndThrowAsIAE(e, \"Failed to find default constructor of class \"+cls.getName()+\", problem: \"+e.getMessage());\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Primitive type support\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method used to get default value for wrappers used for primitive types\n+     * (0 for Integer etc)\n+     * \n+     * @since 1.6.1\n+     */\n+    public static Object defaultValue(Class<?> cls)\n+    {\n+        if (cls == Integer.TYPE) {\n+            return Integer.valueOf(0);\n+        }\n+        if (cls == Long.TYPE) {\n+            return Long.valueOf(0L);\n+        }\n+        if (cls == Boolean.TYPE) {\n+            return Boolean.FALSE;\n+        }\n+        if (cls == Double.TYPE) {\n+            return Double.valueOf(0.0);\n+        }\n+        if (cls == Float.TYPE) {\n+            return Float.valueOf(0.0f);\n+        }\n+        if (cls == Byte.TYPE) {\n+            return Byte.valueOf((byte) 0);\n+        }\n+        if (cls == Short.TYPE) {\n+            return Short.valueOf((short) 0);\n+        }\n+        if (cls == Character.TYPE) {\n+            return '\\0';\n+        }\n+        throw new IllegalArgumentException(\"Class \"+cls.getName()+\" is not a primitive type\");\n+    }\n+\n+    /**\n+     * Helper method for finding wrapper type for given primitive type (why isn't\n+     * there one in JDK?)\n+     * \n+     * @since 1.7.1\n+     */\n+    public static Class<?> wrapperType(Class<?> primitiveType)\n+    {\n+        if (primitiveType == Integer.TYPE) {\n+            return Integer.class;\n+        }\n+        if (primitiveType == Long.TYPE) {\n+            return Long.class;\n+        }\n+        if (primitiveType == Boolean.TYPE) {\n+            return Boolean.class;\n+        }\n+        if (primitiveType == Double.TYPE) {\n+            return Double.class;\n+        }\n+        if (primitiveType == Float.TYPE) {\n+            return Float.class;\n+        }\n+        if (primitiveType == Byte.TYPE) {\n+            return Byte.class;\n+        }\n+        if (primitiveType == Short.TYPE) {\n+            return Short.class;\n+        }\n+        if (primitiveType == Character.TYPE) {\n+            return Character.class;\n+        }\n+        throw new IllegalArgumentException(\"Class \"+primitiveType.getName()+\" is not a primitive type\");\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Access checking/handling methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to check if we can use the passed method or constructor\n+     * (wrt access restriction -- public methods can be called, others\n+     * usually not); and if not, if there is a work-around for\n+     * the problem.\n+     */\n+    public static void checkAndFixAccess(Member member)\n+    {\n+        // We know all members are also accessible objects...\n+        AccessibleObject ao = (AccessibleObject) member;\n+\n+        /* 14-Jan-2009, tatu: It seems safe and potentially beneficial to\n+         *   always to make it accessible (latter because it will force\n+         *   skipping checks we have no use for...), so let's always call it.\n+         */\n+        //if (!ao.isAccessible()) {\n+        try {\n+            ao.setAccessible(true);\n+        } catch (SecurityException se) {\n+            /* 17-Apr-2009, tatu: Related to [JACKSON-101]: this can fail on\n+             *    platforms like EJB and Google App Engine); so let's\n+             *    only fail if we really needed it...\n+             */\n+            if (!ao.isAccessible()) {\n+                Class<?> declClass = member.getDeclaringClass();\n+                throw new IllegalArgumentException(\"Can not access \"+member+\" (from class \"+declClass.getName()+\"; failed to set access: \"+se.getMessage());\n+            }\n+        }\n+        //}\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Enum type detection\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method that can be used to dynamically figure out\n+     * enumeration type of given {@link EnumSet}, without having\n+     * access to its declaration.\n+     * Code is needed to work around design flaw in JDK.\n+     * \n+     * @since 1.5\n+     */\n+    public static Class<? extends Enum<?>> findEnumType(EnumSet<?> s)\n+\t{\n+    \t// First things first: if not empty, easy to determine\n+    \tif (!s.isEmpty()) {\n+    \t\treturn findEnumType(s.iterator().next());\n+    \t}\n+    \t// Otherwise need to locate using an internal field\n+    \treturn EnumTypeLocator.instance.enumTypeFor(s);\n+    }\n+\n+    /**\n+     * Helper method that can be used to dynamically figure out\n+     * enumeration type of given {@link EnumSet}, without having\n+     * access to its declaration.\n+     * Code is needed to work around design flaw in JDK.\n+     * \n+     * @since 1.5\n+     */\n+    public static Class<? extends Enum<?>> findEnumType(EnumMap<?,?> m)\n+    {\n+    \tif (!m.isEmpty()) {\n+    \t\treturn findEnumType(m.keySet().iterator().next());\n+    \t}\n+    \t// Otherwise need to locate using an internal field\n+    \treturn EnumTypeLocator.instance.enumTypeFor(m);\n+    }\n+\n+    /**\n+     * Helper method that can be used to dynamically figure out formal\n+     * enumeration type (class) for given enumeration. This is either\n+     * class of enum instance (for \"simple\" enumerations), or its\n+     * superclass (for enums with instance fields or methods)\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic static Class<? extends Enum<?>> findEnumType(Enum<?> en)\n+    {\n+\t\t// enums with \"body\" are sub-classes of the formal type\n+    \tClass<?> ec = en.getClass();\n+\t\tif (ec.getSuperclass() != Enum.class) {\n+\t\t\tec = ec.getSuperclass();\n+\t\t}\n+\t\treturn (Class<? extends Enum<?>>) ec;\n+    }\n+\n+    /**\n+     * Helper method that can be used to dynamically figure out formal\n+     * enumeration type (class) for given class of an enumeration value.\n+     * This is either class of enum instance (for \"simple\" enumerations),\n+     * or its superclass (for enums with instance fields or methods)\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+\tpublic static Class<? extends Enum<?>> findEnumType(Class<?> cls)\n+    {\n+\t\t// enums with \"body\" are sub-classes of the formal type\n+\t\tif (cls.getSuperclass() != Enum.class) {\n+\t\t\tcls = cls.getSuperclass();\n+\t\t}\n+\t\treturn (Class<? extends Enum<?>>) cls;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Inner class used to contain gory details of how we can determine\n+     * details of instances of common JDK types like {@link EnumMap}s.\n+     */\n+    private static class EnumTypeLocator\n+    {\n+    \tfinal static EnumTypeLocator instance = new EnumTypeLocator();\n+\n+    \tprivate final Field enumSetTypeField;\n+    \tprivate final Field enumMapTypeField;\n+    \t\n+    \tprivate EnumTypeLocator() {\n+\t\t\t/* JDK uses following fields to store information about actual Enumeration\n+\t\t\t * type for EnumSets, EnumMaps...\n+\t\t\t */\n+\t\t\tenumSetTypeField = locateField(EnumSet.class, \"elementType\", Class.class);\n+\t\t\tenumMapTypeField = locateField(EnumMap.class, \"elementType\", Class.class);\n+    \t}\n+\n+    \t@SuppressWarnings(\"unchecked\")\n+    \tpublic Class<? extends Enum<?>> enumTypeFor(EnumSet<?> set)\n+    \t{\n+    \t\tif (enumSetTypeField != null) {\n+    \t\t\treturn (Class<? extends Enum<?>>) get(set, enumSetTypeField);\n+    \t\t}\n+    \t\tthrow new IllegalStateException(\"Can not figure out type for EnumSet (odd JDK platform?)\");\n+\t\t}\n+\n+    \t@SuppressWarnings(\"unchecked\")\n+    \tpublic Class<? extends Enum<?>> enumTypeFor(EnumMap<?,?> set)\n+\t\t        {\n+    \t\tif (enumMapTypeField != null) {\n+    \t\t\treturn (Class<? extends Enum<?>>) get(set, enumMapTypeField);\n+    \t\t}\n+    \t\tthrow new IllegalStateException(\"Can not figure out type for EnumMap (odd JDK platform?)\");\n+\t\t        \n+        }\n+    \t\n+    \tprivate Object get(Object bean, Field field)\n+    \t{\n+    \t\ttry {\n+    \t\t\treturn field.get(bean);\n+    \t\t} catch (Exception e) {\n+    \t\t\tthrow new IllegalArgumentException(e);\n+    \t\t}\n+    \t}\n+    \t\n+    \tprivate static Field locateField(Class<?> fromClass, String expectedName, Class<?> type)\n+    \t{\n+    \t\tField found = null;\n+    \t\t// First: let's see if we can find exact match:\n+    \t\tField[] fields = fromClass.getDeclaredFields();\n+    \t\tfor (Field f : fields) {\n+    \t\t\tif (expectedName.equals(f.getName()) && f.getType() == type) {\n+    \t\t\t\tfound = f;\n+    \t\t\t\tbreak;\n+    \t\t\t}\n+    \t\t}\n+    \t\t// And if not, if there is just one field with the type, that field\n+    \t\tif (found == null) {\n+\t    \t\tfor (Field f : fields) {\n+\t    \t\t\tif (f.getType() == type) {\n+\t    \t\t\t\t// If more than one, can't choose\n+\t    \t\t\t\tif (found != null) return null;\n+\t    \t\t\t\tfound = f;\n+\t    \t\t\t}\n+\t    \t\t}\n+    \t\t}\n+    \t\tif (found != null) { // it's non-public, need to force accessible\n+    \t\t\ttry {\n+    \t\t\t\tfound.setAccessible(true);\n+    \t\t\t} catch (Throwable t) { }\n+    \t\t}\n+    \t\treturn found;\n+    \t}\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/Comparators.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.lang.reflect.Array;\n+\n+/**\n+ * Helper class for constructing objects for comparing content values\n+ * \n+ * @since 1.9.0\n+ */\n+public class Comparators\n+{\n+    /**\n+     * Helper method used for constructing simple value comparator used for\n+     * comparing arrays for content equality.\n+     *<p>\n+     * Note: current implementation is not optimized for speed; if performance\n+     * ever becomes an issue, it is possible to construct much more efficient\n+     * typed instances (one for Object[] and sub-types; one per primitive type)\n+     * \n+     * @since 1.9\n+     */\n+    public static Object getArrayComparator(final Object defaultValue)\n+    {\n+        final int length = Array.getLength(defaultValue);\n+        return new Object() {\n+            @Override\n+            public boolean equals(Object other) {\n+                if (other == this) return true;\n+                if (other == null || other.getClass() != defaultValue.getClass()) {\n+                    return false;\n+                }\n+                if (Array.getLength(other) != length) return false;\n+                // so far so good: compare actual equality; but only shallow one\n+                for (int i = 0; i < length; ++i) {\n+                    Object value1 = Array.get(defaultValue, i);\n+                    Object value2 = Array.get(other, i);\n+                    if (value1 == value2) continue;\n+                    if (value1 != null) {\n+                        if (!value1.equals(value2)) {\n+                            return false;\n+                        }\n+                    }\n+                }\n+                return true;\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/EnumResolver.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+\n+import java.util.*;\n+\n+/**\n+ * Helper class used to resolve String values (either JSON Object field\n+ * names or regular String values) into Java Enum instances.\n+ * \n+ * @since 1.9 renamed from 'org.codehaus.jackson.map.deser.EnumResolver'\n+ */\n+public class EnumResolver<T extends Enum<T>>\n+{\n+    protected final Class<T> _enumClass;\n+\n+    protected final T[] _enums;\n+\n+    protected final HashMap<String, T> _enumsById;\n+\n+    protected EnumResolver(Class<T> enumClass, T[] enums, HashMap<String, T> map)\n+    {\n+        _enumClass = enumClass;\n+        _enums = enums;\n+        _enumsById = map;\n+    }\n+\n+    /**\n+     * Factory method for constructing resolver that maps from Enum.name() into\n+     * Enum value\n+     */\n+    public static <ET extends Enum<ET>> EnumResolver<ET> constructFor(Class<ET> enumCls, AnnotationIntrospector ai)\n+    {\n+        ET[] enumValues = enumCls.getEnumConstants();\n+        if (enumValues == null) {\n+            throw new IllegalArgumentException(\"No enum constants for class \"+enumCls.getName());\n+        }\n+        HashMap<String, ET> map = new HashMap<String, ET>();\n+        for (ET e : enumValues) {\n+            map.put(ai.findEnumValue(e), e);\n+        }\n+        return new EnumResolver<ET>(enumCls, enumValues, map);\n+    }\n+\n+    /**\n+     * Factory method for constructing resolver that maps from Enum.toString() into\n+     * Enum value\n+     * \n+     * @since 1.6\n+     */\n+    public static <ET extends Enum<ET>> EnumResolver<ET> constructUsingToString(Class<ET> enumCls)\n+    {\n+        ET[] enumValues = enumCls.getEnumConstants();\n+        HashMap<String, ET> map = new HashMap<String, ET>();\n+        // from last to first, so that in case of duplicate values, first wins\n+        for (int i = enumValues.length; --i >= 0; ) {\n+            ET e = enumValues[i];\n+            map.put(e.toString(), e);\n+        }\n+        return new EnumResolver<ET>(enumCls, enumValues, map);\n+    }    \n+    \n+    /**\n+     * This method is needed because of the dynamic nature of constructing Enum\n+     * resolvers.\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static EnumResolver<?> constructUnsafe(Class<?> rawEnumCls, AnnotationIntrospector ai)\n+    {            \n+        /* This is oh so wrong... but at least ugliness is mostly hidden in just\n+         * this one place.\n+         */\n+        Class<Enum> enumCls = (Class<Enum>) rawEnumCls;\n+        return constructFor(enumCls, ai);\n+    }\n+\n+    /**\n+     * Method that needs to be used instead of {@link #constructUsingToString}\n+     * if static type of enum is not known.\n+     * \n+     * @since 1.6\n+     */\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    public static EnumResolver<?> constructUnsafeUsingToString(Class<?> rawEnumCls)\n+    {            \n+        // oh so wrong... not much that can be done tho\n+        Class<Enum> enumCls = (Class<Enum>) rawEnumCls;\n+        return constructUsingToString(enumCls);\n+    }\n+    \n+    public T findEnum(String key)\n+    {\n+        return _enumsById.get(key);\n+    }\n+\n+    public T getEnum(int index)\n+    {\n+        if (index < 0 || index >= _enums.length) {\n+            return null;\n+        }\n+        return _enums[index];\n+    }\n+\n+    public Class<T> getEnumClass() { return _enumClass; }\n+\n+    public int lastValidIndex() { return _enums.length-1; }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.io.SerializedString;\n+import com.fasterxml.jackson.databind.*;\n+\n+/**\n+ * Helper class used for storing String serializations of\n+ * enumerations.\n+ */\n+public final class EnumValues\n+{\n+    /**\n+     * Since 1.7, we are storing values as SerializedStrings, to further\n+     * speed up serialization.\n+     */\n+    private final EnumMap<?,SerializedString> _values;\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    private EnumValues(Map<Enum<?>,SerializedString> v) {\n+        _values = new EnumMap(v);\n+    }\n+\n+    public static EnumValues construct(Class<Enum<?>> enumClass, AnnotationIntrospector intr)\n+    {\n+        return constructFromName(enumClass, intr);\n+    }\n+\n+    public static EnumValues constructFromName(Class<Enum<?>> enumClass, AnnotationIntrospector intr)\n+    {\n+        /* [JACKSON-214]: Enum types with per-instance sub-classes\n+         *   need special handling\n+         */\n+    \tClass<? extends Enum<?>> cls = ClassUtil.findEnumType(enumClass);\n+        Enum<?>[] values = cls.getEnumConstants();\n+        if (values != null) {\n+            // Type juggling... unfortunate\n+            Map<Enum<?>,SerializedString> map = new HashMap<Enum<?>,SerializedString>();\n+            for (Enum<?> en : values) {\n+                String value = intr.findEnumValue(en);\n+                map.put(en, new SerializedString(value));\n+            }\n+            return new EnumValues(map);\n+        }\n+        throw new IllegalArgumentException(\"Can not determine enum constants for Class \"+enumClass.getName());\n+    }\n+\n+    public static EnumValues constructFromToString(Class<Enum<?>> enumClass, AnnotationIntrospector intr)\n+    {\n+        Class<? extends Enum<?>> cls = ClassUtil.findEnumType(enumClass);\n+        Enum<?>[] values = cls.getEnumConstants();\n+        if (values != null) {\n+            // Type juggling... unfortunate\n+            Map<Enum<?>,SerializedString> map = new HashMap<Enum<?>,SerializedString>();\n+            for (Enum<?> en : values) {\n+                map.put(en, new SerializedString(en.toString()));\n+            }\n+            return new EnumValues(map);\n+        }\n+        throw new IllegalArgumentException(\"Can not determine enum constants for Class \"+enumClass.getName());\n+    }\n+\n+    /**\n+     * @deprecated since 1.7, use {@link #serializedValueFor} instead\n+     */\n+    @Deprecated\n+    public String valueFor(Enum<?> key)\n+    {\n+        SerializedString sstr = _values.get(key);\n+        return (sstr == null) ? null : sstr.getValue();\n+    }\n+\n+    public SerializedString serializedValueFor(Enum<?> key)\n+    {\n+        return _values.get(key);\n+    }\n+    \n+    public Collection<SerializedString> values() {\n+        return _values.values();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601DateFormat.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.text.*;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+\n+/**\n+ * Provide a fast thread-safe formatter/parser DateFormat for ISO8601 dates ONLY.\n+ * It was mainly done to be used with Jackson JSON Processor.\n+ * <p/>\n+ * Watch out for clone implementation that returns itself.\n+ * <p/>\n+ * All other methods but parse and format and clone are undefined behavior.\n+ *\n+ * @see ISO8601Utils\n+ */\n+public class ISO8601DateFormat extends DateFormat\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    // those classes are to try to allow a consistent behavior for hascode/equals and other methods\n+    private static Calendar CALENDAR = new GregorianCalendar();\n+    private static NumberFormat NUMBER_FORMAT = new DecimalFormat();\n+\n+    public ISO8601DateFormat() {\n+        this.numberFormat = NUMBER_FORMAT;\n+        this.calendar = CALENDAR;\n+    }\n+\n+    @Override\n+    public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition fieldPosition)\n+    {\n+        String value = ISO8601Utils.format(date);\n+        toAppendTo.append(value);\n+        return toAppendTo;\n+    }\n+\n+    @Override\n+    public Date parse(String source, ParsePosition pos)\n+    {\n+        // index must be set to other than 0, I would swear this requirement is not there in\n+        // some version of jdk 6.\n+        pos.setIndex(source.length());\n+        return ISO8601Utils.parse(source);\n+    }\n+\n+    @Override\n+    public Object clone() {\n+        return this;    // jackson calls clone everytime. We are threadsafe so just returns the instance\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ISO8601Utils.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.util.*;\n+\n+/**\n+ * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than\n+ * using SimpleDateFormat so highly suitable if you (un)serialize lots of date objects.\n+ */\n+public class ISO8601Utils {\n+\n+    /**\n+     * ID to represent the 'GMT' string\n+     */\n+    private static final String GMT_ID = \"GMT\";\n+\n+    /**\n+     * The GMT timezone\n+     */\n+    private static final TimeZone TIMEZONE_GMT = TimeZone.getTimeZone(GMT_ID);\n+\n+    /**\n+     * Format a date into 'yyyy-MM-ddThh:mm:ssZ' (GMT timezone, no milliseconds precision)\n+     *\n+     * @param date the date to format\n+     * @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\n+     */\n+    public static String format(Date date) {\n+        return format(date, false, TIMEZONE_GMT);\n+    }\n+\n+    /**\n+     * Format a date into 'yyyy-MM-ddThh:mm:ss[.sss]Z' (GMT timezone)\n+     *\n+     * @param date   the date to format\n+     * @param millis true to include millis precision otherwise false\n+     * @return the date formatted as 'yyyy-MM-ddThh:mm:ss[.sss]Z'\n+     */\n+    public static String format(Date date, boolean millis) {\n+        return format(date, millis, TIMEZONE_GMT);\n+    }\n+\n+    /**\n+     * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n+     *\n+     * @param date   the date to format\n+     * @param millis true to include millis precision otherwise false\n+     * @param tz     timezone to use for the formatting (GMT will produce 'Z')\n+     * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n+     */\n+    public static String format(Date date, boolean millis, TimeZone tz) {\n+        Calendar calendar = new GregorianCalendar(tz, Locale.US);\n+        calendar.setTime(date);\n+\n+        // estimate capacity of buffer as close as we can (yeah, that's pedantic ;)\n+        int capacity = \"yyyy-MM-ddThh:mm:ss\".length();\n+        capacity += millis ? \".sss\".length() : 0;\n+        capacity += tz.getRawOffset() == 0 ? \"Z\".length() : \"+hh:mm\".length();\n+        StringBuilder formatted = new StringBuilder(capacity);\n+\n+        padInt(formatted, calendar.get(Calendar.YEAR), \"yyyy\".length());\n+        formatted.append('-');\n+        padInt(formatted, calendar.get(Calendar.MONTH) + 1, \"MM\".length());\n+        formatted.append('-');\n+        padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), \"dd\".length());\n+        formatted.append('T');\n+        padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), \"hh\".length());\n+        formatted.append(':');\n+        padInt(formatted, calendar.get(Calendar.MINUTE), \"mm\".length());\n+        formatted.append(':');\n+        padInt(formatted, calendar.get(Calendar.SECOND), \"ss\".length());\n+        if (millis) {\n+            formatted.append('.');\n+            padInt(formatted, calendar.get(Calendar.MILLISECOND), \"sss\".length());\n+        }\n+\n+        int offset = tz.getOffset(calendar.getTimeInMillis());\n+        if (offset != 0) {\n+            int hours = Math.abs((offset / (60 * 1000)) / 60);\n+            int minutes = Math.abs((offset / (60 * 1000)) % 60);\n+            formatted.append(offset < 0 ? '-' : '+');\n+            padInt(formatted, hours, \"hh\".length());\n+            formatted.append(':');\n+            padInt(formatted, minutes, \"mm\".length());\n+        } else {\n+            formatted.append('Z');\n+        }\n+\n+        return formatted.toString();\n+    }\n+\n+\n+    /**\n+     * Parse a date from ISO-8601 formatted string. It expects a format yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm]\n+     *\n+     * @param date ISO string to parse in the appropriate format.\n+     * @return the parsed date\n+     * @throws IllegalArgumentException if the date is not in the appropriate format\n+     */\n+    public static Date parse(String date) {\n+        try {\n+            int offset = 0;\n+\n+            // extract year\n+            int year = parseInt(date, offset, offset += 4);\n+            checkOffset(date, offset, '-');\n+\n+            // extract month\n+            int month = parseInt(date, offset += 1, offset += 2);\n+            checkOffset(date, offset, '-');\n+\n+            // extract day\n+            int day = parseInt(date, offset += 1, offset += 2);\n+            checkOffset(date, offset, 'T');\n+\n+            // extract hours, minutes, seconds and milliseconds\n+            int hour = parseInt(date, offset += 1, offset += 2);\n+            checkOffset(date, offset, ':');\n+\n+            int minutes = parseInt(date, offset += 1, offset += 2);\n+            checkOffset(date, offset, ':');\n+\n+            int seconds = parseInt(date, offset += 1, offset += 2);\n+            // milliseconds can be optional in the format\n+            int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n+            if (date.charAt(offset) == '.') {\n+                checkOffset(date, offset, '.');\n+                milliseconds = parseInt(date, offset += 1, offset += 3);\n+            }\n+\n+            // extract timezone\n+            String timezoneId;\n+            char timezoneIndicator = date.charAt(offset);\n+            if (timezoneIndicator == '+' || timezoneIndicator == '-') {\n+                timezoneId = GMT_ID + date.substring(offset);\n+            } else if (timezoneIndicator == 'Z') {\n+                timezoneId = GMT_ID;\n+            } else {\n+                throw new IndexOutOfBoundsException(\"Invalid time zone indicator \" + timezoneIndicator);\n+            }\n+            TimeZone timezone = TimeZone.getTimeZone(timezoneId);\n+            if (!timezone.getID().equals(timezoneId)) {\n+                throw new IndexOutOfBoundsException();\n+            }\n+\n+            Calendar calendar = new GregorianCalendar(timezone);\n+            calendar.setLenient(false);\n+            calendar.set(Calendar.YEAR, year);\n+            calendar.set(Calendar.MONTH, month - 1);\n+            calendar.set(Calendar.DAY_OF_MONTH, day);\n+            calendar.set(Calendar.HOUR_OF_DAY, hour);\n+            calendar.set(Calendar.MINUTE, minutes);\n+            calendar.set(Calendar.SECOND, seconds);\n+            calendar.set(Calendar.MILLISECOND, milliseconds);\n+\n+            return calendar.getTime();\n+        } catch (IndexOutOfBoundsException e) {\n+            throw new IllegalArgumentException(\"Failed to parse date \" + date, e);\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"Failed to parse date \" + date, e);\n+        } catch (IllegalArgumentException e) {\n+            throw new IllegalArgumentException(\"Failed to parse date \" + date, e);\n+        }\n+    }\n+\n+    /**\n+     * Check if the expected character exist at the given offset of the\n+     *\n+     * @param value    the string to check at the specified offset\n+     * @param offset   the offset to look for the expected character\n+     * @param expected the expected character\n+     * @throws IndexOutOfBoundsException if the expected character is not found\n+     */\n+    private static void checkOffset(String value, int offset, char expected) throws IndexOutOfBoundsException {\n+        char found = value.charAt(offset);\n+        if (found != expected) {\n+            throw new IndexOutOfBoundsException(\"Expected '\" + expected + \"' character but found '\" + found + \"'\");\n+        }\n+    }\n+\n+    /**\n+     * Parse an integer located between 2 given offsets in a string\n+     *\n+     * @param value      the string to parse\n+     * @param beginIndex the start index for the integer in the string\n+     * @param endIndex   the end index for the integer in the string\n+     * @return the int\n+     * @throws NumberFormatException if the value is not a number\n+     */\n+    private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\n+        if (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\n+            throw new NumberFormatException(value);\n+        }\n+        // use same logic as in Integer.parseInt() but less generic we're not supporting negative values\n+        int i = beginIndex;\n+        int result = 0;\n+        int digit;\n+        if (i < endIndex) {\n+            digit = Character.digit(value.charAt(i++), 10);\n+            if (digit < 0) {\n+                throw new NumberFormatException(\"Invalid number: \" + value);\n+            }\n+            result = -digit;\n+        }\n+        while (i < endIndex) {\n+            digit = Character.digit(value.charAt(i++), 10);\n+            if (digit < 0) {\n+                throw new NumberFormatException(\"Invalid number: \" + value);\n+            }\n+            result *= 10;\n+            result -= digit;\n+        }\n+        return -result;\n+    }\n+\n+    /**\n+     * Zero pad a number to a specified length\n+     *\n+     * @param buffer buffer to use for padding\n+     * @param value  the integer value to pad if necessary.\n+     * @param length the length of the string we should zero pad\n+     */\n+    private static void padInt(StringBuilder buffer, int value, int length) {\n+        String strValue = Integer.toString(value);\n+        for (int i = length - strValue.length(); i > 0; i--) {\n+            buffer.append('0');\n+        }\n+        buffer.append(strValue);\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/JSONPObject.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * Container class that can be used to wrap any Object instances (including\n+ * nulls), and will serialize embedded in\n+ * <a href=\"http://en.wikipedia.org/wiki/JSONP\">JSONP</a> wrapping.\n+ * \n+ * @see com.fasterxml.jackson.databind.util.JSONWrappedObject\n+ * \n+ * @author tatu\n+ * @since 1.5\n+ */\n+public class JSONPObject\n+    implements JsonSerializableWithType\n+{\n+    /**\n+     * JSONP function name to use for serialization\n+     */\n+    protected final String _function;\n+    \n+    /**\n+     * Value to be serialized as JSONP padded; can be null.\n+     */\n+    protected final Object _value;\n+\n+    /**\n+     * Optional static type to use for serialization; if null, runtime\n+     * type is used. Can be used to specify declared type which defines\n+     * serializer to use, as well as aspects of extra type information\n+     * to include (if any).\n+     */\n+    protected final JavaType _serializationType;\n+\n+    public JSONPObject(String function, Object value) {\n+        this(function, value, (JavaType) null);\n+    }\n+\n+    public JSONPObject(String function, Object value, JavaType asType)\n+    {\n+        _function = function;\n+        _value = value;\n+        _serializationType = asType;\n+    }\n+\n+    /**\n+     * @deprecated Since 1.8; instead use variant that takes JavaType: this ensures\n+     *    that type information is properly resolved\n+     */\n+    @Deprecated\n+    public JSONPObject(String function, Object value, Class<?> rawType) {\n+        _function = function;\n+        _value = value;\n+        _serializationType = (rawType == null) ? null : TypeFactory.defaultInstance().constructType(rawType);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonSerializable(WithType) implementation\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public void serializeWithType(JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer)\n+            throws IOException, JsonProcessingException\n+    {\n+        // No type for JSONP wrapping: value serializer will handle typing for value:\n+        serialize(jgen, provider);\n+    }\n+\n+    @Override\n+    public void serialize(JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonProcessingException\n+    {\n+        // First, wrapping:\n+        jgen.writeRaw(_function);\n+        jgen.writeRaw('(');\n+        if (_value == null) {\n+            provider.defaultSerializeNull(jgen);\n+        } else if (_serializationType != null) {\n+            provider.findTypedValueSerializer(_serializationType, true, null).serialize(_value, jgen, provider);\n+        } else {\n+            Class<?> cls = _value.getClass();\n+            provider.findTypedValueSerializer(cls, true, null).serialize(_value, jgen, provider);\n+        }\n+        jgen.writeRaw(')');\n+    }\n+\n+    /*\n+    /**************************************************************\n+    /* Accessors\n+    /**************************************************************\n+     */\n+    \n+    public String getFunction() { return _function; }\n+    public Object getValue() { return _value; }\n+    public JavaType getSerializationType() { return _serializationType; }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/JSONWrappedObject.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+/**\n+ * General-purpose wrapper class that can be used to decorate serialized\n+ * value with arbitrary literal prefix and suffix. This can be used for\n+ * example to construct arbitrary Javascript values (similar to how basic\n+ * function name and parenthesis are used with JSONP).\n+ * \n+ * @see com.fasterxml.jackson.databind.util.JSONPObject\n+ * \n+ * @author tatu\n+ * @since 1.5\n+ */\n+public class JSONWrappedObject\n+    implements JsonSerializableWithType\n+{\n+    /**\n+     * Literal String to output before serialized value.\n+     * Will not be quoted when serializing value.\n+     */\n+    protected final String _prefix;\n+\n+    /**\n+     * Literal String to output after serialized value.\n+     * Will not be quoted when serializing value.\n+     */\n+    protected final String _suffix;\n+    \n+    /**\n+     * Value to be serialized as JSONP padded; can be null.\n+     */\n+    protected final Object _value;\n+\n+    /**\n+     * Optional static type to use for serialization; if null, runtime\n+     * type is used. Can be used to specify declared type which defines\n+     * serializer to use, as well as aspects of extra type information\n+     * to include (if any).\n+     */\n+    protected final JavaType _serializationType;\n+    \n+    public JSONWrappedObject(String prefix, String suffix, Object value) {\n+        this(prefix, suffix, value, (JavaType) null);\n+    }\n+\n+    public JSONWrappedObject(String prefix, String suffix, Object value, JavaType asType)\n+    {\n+        _prefix = prefix;\n+        _suffix = suffix;\n+        _value = value;\n+        _serializationType = asType;\n+    }\n+\n+    /**\n+     * @deprecated Since 1.8; should construct with resolved <code>JavaType</code>,\n+     *   to ensure type has been properly resolved\n+     */\n+    @Deprecated\n+    public JSONWrappedObject(String prefix, String suffix, Object value, Class<?> rawType) {\n+        _prefix = prefix;\n+        _suffix = suffix;\n+        _value = value;\n+        _serializationType = (rawType == null) ? null : TypeFactory.defaultInstance().constructType(rawType);\n+    }\n+    \n+    /*\n+    /**************************************************************\n+    /* JsonSerializable(WithType) implementation\n+    /**************************************************************\n+     */\n+    \n+    @Override\n+    public void serializeWithType(JsonGenerator jgen, SerializerProvider provider, TypeSerializer typeSer)\n+            throws IOException, JsonProcessingException\n+    {\n+        // No type for JSONP wrapping: value serializer will handle typing for value:\n+        serialize(jgen, provider);\n+    }\n+\n+    @Override\n+    public void serialize(JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonProcessingException\n+    {\n+        // First, wrapping:\n+    \tif (_prefix != null) jgen.writeRaw(_prefix);\n+        if (_value == null) {\n+            provider.defaultSerializeNull(jgen);\n+        } else if (_serializationType != null) {\n+            provider.findTypedValueSerializer(_serializationType, true, null).serialize(_value, jgen, provider);\n+        } else {\n+            Class<?> cls = _value.getClass();\n+            provider.findTypedValueSerializer(cls, true, null).serialize(_value, jgen, provider);\n+        }\n+        if (_suffix != null) jgen.writeRaw(_suffix);\n+    }\n+\n+    /*\n+    /**************************************************************\n+    /* Accessors\n+    /**************************************************************\n+     */\n+    \n+    public String getPrefix() { return _prefix; }\n+    public String getSuffix() { return _suffix; }\n+    public Object getValue() { return _value; }\n+    public JavaType getSerializationType() { return _serializationType; }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Helper for simple bounded LRU maps used for reusing lookup values.\n+ * \n+ * @since 1.7\n+ */\n+@SuppressWarnings(\"serial\")\n+public class LRUMap<K,V> extends LinkedHashMap<K,V>\n+{\n+    protected final int _maxEntries;\n+    \n+    public LRUMap(int initialEntries, int maxEntries)\n+    {\n+        super(initialEntries, 0.8f, true);\n+        _maxEntries = maxEntries;\n+    }\n+\n+    @Override\n+    protected boolean removeEldestEntry(Map.Entry<K,V> eldest)\n+    {\n+        return size() > _maxEntries;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/LinkedNode.java\n+package com.fasterxml.jackson.databind.util;\n+\n+/**\n+ * Node of a forward-only linked list.\n+ * \n+ * @author tatu\n+ *\n+ * @param <T> Type of contained object\n+ */\n+public final class LinkedNode<T>\n+{\n+    final T _value;\n+    final LinkedNode<T> _next;\n+    \n+    public LinkedNode(T value, LinkedNode<T> next)\n+    {\n+        _value = value;\n+        _next = next;\n+    }\n+    \n+    public LinkedNode<T> next() { return _next; }\n+    \n+    public T value() { return _value; }\n+    \n+    /**\n+     * Convenience method that can be used to check if a linked list\n+     * with given head node (which may be null to indicate empty list)\n+     * contains given value\n+     * \n+     * @param <ST> Type argument that defines contents of the linked list parameter\n+     * @param node Head node of the linked list\n+     * @param value Value to look for\n+     * @return True if linked list contains the value, false otherwise\n+     */\n+    public static <ST> boolean contains(LinkedNode<ST> node, ST value)\n+    {\n+        while (node != null) {\n+            if (node.value() == value) {\n+                return true;\n+            }\n+            node = node.next();\n+        }\n+        return false;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/Named.java\n+package com.fasterxml.jackson.databind.util;\n+\n+/**\n+ * Simple tag interface mostly to allow sorting by name\n+ *\n+ * @since 1.9\n+ */\n+public interface Named {\n+    public String getName();\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ObjectBuffer.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.lang.reflect.Array;\n+import java.util.List;\n+\n+/**\n+ * Helper class to use for constructing Object arrays by appending entries\n+ * to create arrays of various lengths (length that is not known a priori). \n+ */\n+public final class ObjectBuffer\n+{\n+    // // // Config constants\n+\n+    /**\n+     * Let's start with small chunks; typical usage is for small arrays anyway.\n+     */\n+    final static int INITIAL_CHUNK_SIZE = 12;\n+\n+    /**\n+     * Also: let's expand by doubling up until 64k chunks (which is 16k entries for\n+     * 32-bit machines)\n+     */\n+    final static int SMALL_CHUNK_SIZE = (1 << 14);\n+\n+    /**\n+     * Let's limit maximum size of chunks we use; helps avoid excessive allocation\n+     * overhead for huge data sets.\n+     * For now, let's limit to quarter million entries, 1 meg chunks for 32-bit\n+     * machines.\n+     */\n+    final static int MAX_CHUNK_SIZE = (1 << 18);\n+\n+    // // // Data storage\n+\n+    private Node _bufferHead;\n+\n+    private Node _bufferTail;\n+\n+    /**\n+     * Number of total buffered entries in this buffer, counting all instances\n+     * within linked list formed by following {@link #_bufferHead}.\n+     */\n+    private int _bufferedEntryCount;\n+\n+    // // // Simple reuse\n+\n+    /**\n+     * Reusable Object array, stored here after buffer has been released having\n+     * been used previously.\n+     */\n+    private Object[] _freeBuffer;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+\n+    public ObjectBuffer() { }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to start buffering process. Will ensure that the buffer\n+     * is empty, and then return an object array to start chunking content on\n+     */\n+    public Object[] resetAndStart()\n+    {\n+        _reset();\n+        if (_freeBuffer == null) {\n+            return new Object[INITIAL_CHUNK_SIZE];\n+        }\n+        return _freeBuffer;\n+    }\n+\n+    /**\n+     * Method called to add a full Object array as a chunk buffered within\n+     * this buffer, and to obtain a new array to fill. Caller is not to use\n+     * the array it gives; but to use the returned array for continued\n+     * buffering.\n+     *\n+     * @param fullChunk Completed chunk that the caller is requesting\n+     *   to append to this buffer. It is generally chunk that was\n+     *   returned by an earlier call to {@link #resetAndStart} or\n+     *   {@link #appendCompletedChunk} (although this is not required or\n+     *   enforced)\n+     *\n+     * @return New chunk buffer for caller to fill\n+     */\n+    public Object[] appendCompletedChunk(Object[] fullChunk)\n+    {\n+        Node next = new Node(fullChunk);\n+        if (_bufferHead == null) { // first chunk\n+            _bufferHead = _bufferTail = next;\n+        } else { // have something already\n+            _bufferTail.linkNext(next);\n+            _bufferTail = next;\n+        }\n+        int len = fullChunk.length;\n+        _bufferedEntryCount += len;\n+        // double the size for small chunks\n+        if (len < SMALL_CHUNK_SIZE) {\n+            len += len;\n+        } else { // but by +25% for larger (to limit overhead)\n+            len += (len >> 2);\n+        }\n+        return new Object[len];\n+    }\n+\n+    /**\n+     * Method called to indicate that the buffering process is now\n+     * complete; and to construct a combined exactly-sized result\n+     * array. Additionally the buffer itself will be reset to\n+     * reduce memory retention.\n+     *<p>\n+     * Resulting array will be of generic <code>Object[]</code> type:\n+     * if a typed array is needed, use the method with additional\n+     * type argument.\n+     */\n+    public Object[] completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries)\n+    {\n+        int totalSize = lastChunkEntries + _bufferedEntryCount;\n+        Object[] result = new Object[totalSize];\n+        _copyTo(result, totalSize, lastChunk, lastChunkEntries);\n+        return result;\n+    }\n+\n+    /**\n+     * Type-safe alternative to\n+     * {@link #completeAndClearBuffer(Object[], int)}, to allow\n+     * for constructing explicitly typed result array.\n+     *\n+     * @param componentType Type of elements included in the buffer. Will be\n+     *   used for constructing the result array.\n+     */\n+    public <T> T[] completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, Class<T> componentType)\n+    {\n+       int totalSize = lastChunkEntries + _bufferedEntryCount;\n+ \t   @SuppressWarnings(\"unchecked\")\n+        T[] result = (T[]) Array.newInstance(componentType, totalSize);\n+        _copyTo(result, totalSize, lastChunk, lastChunkEntries);\n+        _reset();\n+        return result;\n+    }\n+\n+    /**\n+     * Another\n+     * \n+     * @since 1.6\n+     */\n+    public void completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, List<Object> resultList)\n+    {\n+        for (Node n = _bufferHead; n != null; n = n.next()) {\n+            Object[] curr = n.getData();\n+            for (int i = 0, len = curr.length; i < len; ++i) {\n+                resultList.add(curr[i]);\n+            }\n+        }\n+        // and then the last one\n+        for (int i = 0; i < lastChunkEntries; ++i) {\n+            resultList.add(lastChunk[i]);\n+        }\n+    }\n+    \n+    /**\n+     * Helper method that can be used to check how much free capacity\n+     * will this instance start with. Can be used to choose the best\n+     * instance to reuse, based on size of reusable object chunk\n+     * buffer holds reference to.\n+     */\n+    public int initialCapacity()\n+    {\n+        return (_freeBuffer == null) ? 0 : _freeBuffer.length;\n+    }\n+\n+    /**\n+     * Method that can be used to check how many Objects have been buffered\n+     * within this buffer.\n+     */\n+    public int bufferedSize() { return _bufferedEntryCount; }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    protected void _reset()\n+    {\n+        // can we reuse the last (and thereby biggest) array for next time?\n+        if (_bufferTail != null) {\n+            _freeBuffer = _bufferTail.getData();\n+        }\n+        // either way, must discard current contents\n+        _bufferHead = _bufferTail = null;\n+        _bufferedEntryCount = 0;\n+    }\n+\n+    protected final void _copyTo(Object resultArray, int totalSize,\n+                                 Object[] lastChunk, int lastChunkEntries)\n+    {\n+        int ptr = 0;\n+\n+        for (Node n = _bufferHead; n != null; n = n.next()) {\n+            Object[] curr = n.getData();\n+            int len = curr.length;\n+            System.arraycopy(curr, 0, resultArray, ptr, len);\n+            ptr += len;\n+        }\n+        System.arraycopy(lastChunk, 0, resultArray, ptr, lastChunkEntries);\n+        ptr += lastChunkEntries;\n+\n+        // sanity check (could have failed earlier due to out-of-bounds, too)\n+        if (ptr != totalSize) {\n+            throw new IllegalStateException(\"Should have gotten \"+totalSize+\" entries, got \"+ptr);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper class used to store actual data, in a linked list.\n+     */\n+    final static class Node\n+    {\n+        /**\n+         * Data stored in this node. Array is considered to be full.\n+         */\n+        final Object[] _data;\n+\n+        Node _next;\n+\n+        public Node(Object[] data) {\n+            _data = data;\n+        }\n+\n+        public Object[] getData() { return _data; }\n+\n+        public Node next() { return _next; }\n+\n+        public void linkNext(Node next)\n+        {\n+            if (_next != null) { // sanity check\n+                throw new IllegalStateException();\n+            }\n+            _next = next;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/PrimitiveArrayBuilder.java\n+package com.fasterxml.jackson.databind.util;\n+\n+/**\n+ * Base class for specialized primitive array builders.\n+ */\n+public abstract class PrimitiveArrayBuilder<T>\n+{\n+    /**\n+     * Let's start with small chunks; typical usage is for small arrays anyway.\n+     */\n+    final static int INITIAL_CHUNK_SIZE = 12;\n+\n+    /**\n+     * Also: let's expand by doubling up until 64k chunks (which is 16k entries for\n+     * 32-bit machines)\n+     */\n+    final static int SMALL_CHUNK_SIZE = (1 << 14);\n+\n+    /**\n+     * Let's limit maximum size of chunks we use; helps avoid excessive allocation\n+     * overhead for huge data sets.\n+     * For now, let's limit to quarter million entries, 1 meg chunks for 32-bit\n+     * machines.\n+     */\n+    final static int MAX_CHUNK_SIZE = (1 << 18);\n+\n+    // // // Data storage\n+\n+    T _freeBuffer;\n+\n+    Node<T> _bufferHead;\n+\n+    Node<T> _bufferTail;\n+\n+    /**\n+     * Number of total buffered entries in this buffer, counting all instances\n+     * within linked list formed by following {@link #_bufferHead}.\n+     */\n+    int _bufferedEntryCount;\n+\n+    // // // Recycled instances of sub-classes\n+\n+    // // // Life-cycle\n+\n+    protected PrimitiveArrayBuilder() { }\n+\n+    /*\n+    ////////////////////////////////////////////////////////////////////////\n+    // Public API\n+    ////////////////////////////////////////////////////////////////////////\n+     */\n+\n+    public T resetAndStart()\n+    {\n+        _reset();\n+        return (_freeBuffer == null) ?\n+            _constructArray(INITIAL_CHUNK_SIZE) : _freeBuffer;\n+    }\n+\n+    /**\n+     * @return Length of the next chunk to allocate\n+     */\n+    public final T appendCompletedChunk(T fullChunk, int fullChunkLength)\n+    {\n+        Node<T> next = new Node<T>(fullChunk, fullChunkLength);\n+        if (_bufferHead == null) { // first chunk\n+            _bufferHead = _bufferTail = next;\n+        } else { // have something already\n+            _bufferTail.linkNext(next);\n+            _bufferTail = next;\n+        }\n+        _bufferedEntryCount += fullChunkLength;\n+        int nextLen = fullChunkLength; // start with last chunk size\n+        // double the size for small chunks\n+        if (nextLen < SMALL_CHUNK_SIZE) {\n+            nextLen += nextLen;\n+        } else { // but by +25% for larger (to limit overhead)\n+            nextLen += (nextLen >> 2);\n+        }\n+        return _constructArray(nextLen);\n+    }\n+\n+    public T completeAndClearBuffer(T lastChunk, int lastChunkEntries)\n+    {\n+        int totalSize = lastChunkEntries + _bufferedEntryCount;\n+        T resultArray = _constructArray(totalSize);\n+\n+        int ptr = 0;\n+\n+        for (Node<T> n = _bufferHead; n != null; n = n.next()) {\n+            ptr = n.copyData(resultArray, ptr);\n+        }\n+        System.arraycopy(lastChunk, 0, resultArray, ptr, lastChunkEntries);\n+        ptr += lastChunkEntries;\n+\n+        // sanity check (could have failed earlier due to out-of-bounds, too)\n+        if (ptr != totalSize) {\n+            throw new IllegalStateException(\"Should have gotten \"+totalSize+\" entries, got \"+ptr);\n+        }\n+        return resultArray;\n+    }\n+\n+    /*\n+    ////////////////////////////////////////////////////////////////////////\n+    // Abstract methods for sub-classes to implement\n+    ////////////////////////////////////////////////////////////////////////\n+     */\n+\n+    protected abstract T _constructArray(int len);\n+\n+    /*\n+    ////////////////////////////////////////////////////////////////////////\n+    // Internal methods\n+    ////////////////////////////////////////////////////////////////////////\n+     */\n+\n+    protected void _reset()\n+    {\n+        // can we reuse the last (and thereby biggest) array for next time?\n+        if (_bufferTail != null) {\n+            _freeBuffer = _bufferTail.getData();\n+        }\n+        // either way, must discard current contents\n+        _bufferHead = _bufferTail = null;\n+        _bufferedEntryCount = 0;\n+    }\n+\n+    /*\n+    ////////////////////////////////////////////////////////////////////////\n+    // Helper classes\n+    ////////////////////////////////////////////////////////////////////////\n+     */\n+\n+    /**\n+     * For actual buffering beyond the current buffer, we can actually\n+     * use shared class which only deals with opaque \"untyped\" chunks.\n+     * This works because {@link java.lang.System#arraycopy} does not\n+     * take type; hence we can implement some aspects of primitive data\n+     * handling in generic fashion.\n+     */\n+    final static class Node<T>\n+    {\n+        /**\n+         * Data stored in this node.\n+         */\n+        final T _data;\n+\n+        /**\n+         * Number entries in the (untyped) array. Offset is assumed to be 0.\n+         */\n+        final int _dataLength;\n+\n+        Node<T> _next;\n+\n+        public Node(T data, int dataLen)\n+        {\n+            _data = data;\n+            _dataLength = dataLen;\n+        }\n+\n+        public T getData() { return _data; }\n+\n+        public int copyData(T dst, int ptr)\n+        {\n+            System.arraycopy(_data, 0, dst, ptr, _dataLength);\n+            ptr += _dataLength;\n+            return ptr;\n+        }\n+\n+        public Node<T> next() { return _next; }\n+\n+        public void linkNext(Node<T> next)\n+        {\n+            if (_next != null) { // sanity check\n+                throw new IllegalStateException();\n+            }\n+            _next = next;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/Provider.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.util.*;\n+\n+/**\n+* Simple helper class used for decoupling instantiation of\n+* optionally loaded handlers, like deserializers and deserializers\n+* for libraries that are only present on some platforms.\n+ * \n+ * @author tatu\n+ *\n+ * @param <T> Type of objects provided\n+ */\n+public interface Provider<T>\n+{\n+    /**\n+     * Method used to request provider to provide entries it has\n+     */\n+    public Collection<T> provide();\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/RootNameLookup.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import com.fasterxml.jackson.core.io.SerializedString;\n+import com.fasterxml.jackson.core.type.JavaType;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.BasicBeanDescription;\n+import com.fasterxml.jackson.databind.type.ClassKey;\n+\n+/**\n+ * Helper class for caching resolved root names.\n+ */\n+public class RootNameLookup\n+{\n+    /**\n+     * For efficient operation, let's try to minimize number of times we\n+     * need to introspect root element name to use.\n+     */\n+    protected LRUMap<ClassKey,SerializedString> _rootNames;\n+\n+    public RootNameLookup() { }\n+\n+    public SerializedString findRootName(JavaType rootType, MapperConfig<?> config)\n+    {\n+        return findRootName(rootType.getRawClass(), config);\n+    }\n+\n+    public synchronized SerializedString findRootName(Class<?> rootType, MapperConfig<?> config)\n+    {\n+        ClassKey key = new ClassKey(rootType);\n+\n+        if (_rootNames == null) {\n+            _rootNames = new LRUMap<ClassKey,SerializedString>(20, 200);\n+        } else {\n+            SerializedString name = _rootNames.get(key);\n+            if (name != null) {\n+                return name;\n+            }\n+        }\n+        BasicBeanDescription beanDesc = (BasicBeanDescription) config.introspectClassAnnotations(rootType);\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        AnnotatedClass ac = beanDesc.getClassInfo();\n+        String nameStr = intr.findRootName(ac);\n+        // No answer so far? Let's just default to using simple class name\n+        if (nameStr == null) {\n+            // Should we strip out enclosing class tho? For now, nope:\n+            nameStr = rootType.getSimpleName();\n+        }\n+        SerializedString name = new SerializedString(nameStr);\n+        _rootNames.put(key, name);\n+        return name;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.text.DateFormat;\n+import java.text.FieldPosition;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.io.NumberInput;\n+\n+/**\n+ * Default {@link DateFormat} implementation used by standard Date\n+ * serializers and deserializers. For serialization defaults to using\n+ * an ISO-8601 compliant format (format String \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")\n+ * and for deserialization, both ISO-8601 and RFC-1123.\n+ */\n+@SuppressWarnings(\"serial\")\n+public class StdDateFormat\n+    extends DateFormat\n+{\n+    /* TODO !!! 24-Nov-2009, tatu: Need to rewrite this class soon:\n+     * JDK date parsing is awfully brittle, and ISO-8601 is quite\n+     * permissive. The two don't mix, need to write a better one.\n+     */\n+\n+    /**\n+     * Defines a commonly used date format that conforms\n+     * to ISO-8601 date formatting standard, when it includes basic undecorated\n+     * timezone definition\n+     */\n+    protected final static String DATE_FORMAT_STR_ISO8601 = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+\n+    /**\n+     * Same as 'regular' 8601, but handles 'Z' as an alias for \"+0000\"\n+     * (or \"GMT\")\n+     */\n+    protected final static String DATE_FORMAT_STR_ISO8601_Z = \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\";\n+\n+    /**\n+     * ISO-8601 with just the Date part, no time\n+     *\n+     * @since 1.3.1\n+     */\n+    protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";\n+\n+    /**\n+     * This constant defines the date format specified by\n+     * RFC 1123.\n+     */\n+    protected final static String DATE_FORMAT_STR_RFC1123 = \"EEE, dd MMM yyyy HH:mm:ss zzz\";\n+\n+    /**\n+     * For error messages we'll also need a list of all formats.\n+     */\n+    protected final static String[] ALL_FORMATS = new String[] {\n+        DATE_FORMAT_STR_ISO8601,\n+        DATE_FORMAT_STR_ISO8601_Z,\n+        DATE_FORMAT_STR_RFC1123,\n+        DATE_FORMAT_STR_PLAIN\n+    };\n+\n+    protected final static DateFormat DATE_FORMAT_RFC1123;\n+\n+    protected final static DateFormat DATE_FORMAT_ISO8601;\n+    protected final static DateFormat DATE_FORMAT_ISO8601_Z;\n+\n+    protected final static DateFormat DATE_FORMAT_PLAIN;\n+\n+    /* Let's construct \"blueprint\" date format instances: can not be used\n+     * as is, due to thread-safety issues, but can be used for constructing\n+     * actual instances more cheaply (avoids re-parsing).\n+     */\n+    static {\n+        /* Another important thing: let's force use of GMT for\n+         * baseline DataFormat objects\n+         */\n+        TimeZone gmt = TimeZone.getTimeZone(\"GMT\");\n+        DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123);\n+        DATE_FORMAT_RFC1123.setTimeZone(gmt);\n+        DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601);\n+        DATE_FORMAT_ISO8601.setTimeZone(gmt);\n+        DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z);\n+        DATE_FORMAT_ISO8601_Z.setTimeZone(gmt);\n+        DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN);\n+        DATE_FORMAT_PLAIN.setTimeZone(gmt);\n+    }\n+\n+    /**\n+     * A singleton instance can be used for cloning purposes.\n+     */\n+    public final static StdDateFormat instance = new StdDateFormat();\n+\n+    protected transient DateFormat _formatRFC1123;\n+    protected transient DateFormat _formatISO8601;\n+    protected transient DateFormat _formatISO8601_z;\n+    protected transient DateFormat _formatPlain;\n+\n+    /*\n+    /**********************************************************\n+    /* Life cycle, accessing singleton \"standard\" formats\n+    /**********************************************************\n+     */\n+\n+    public StdDateFormat() { }\n+\n+    @Override\n+    public StdDateFormat clone() {\n+        /* Since we always delegate all work to child DateFormat instances,\n+         * let's NOT call super.clone(); this is bit unusual, but makes\n+         * sense here to avoid unnecessary work.\n+         */\n+        return new StdDateFormat();\n+    }\n+\n+    /**\n+     * Method for getting the globally shared DateFormat instance\n+     * that uses GMT timezone and can handle simple ISO-8601\n+     * compliant date format.\n+     */\n+    public static DateFormat getBlueprintISO8601Format() {\n+        return DATE_FORMAT_ISO8601;\n+    }\n+\n+    /**\n+     * Method for getting a non-shared DateFormat instance\n+     * that uses specified timezone and can handle simple ISO-8601\n+     * compliant date format.\n+     */\n+    public static DateFormat getISO8601Format(TimeZone tz) {\n+        DateFormat df = (DateFormat) DATE_FORMAT_ISO8601.clone();\n+        df.setTimeZone(tz);\n+        return df;\n+    }\n+\n+    /**\n+     * Method for getting the globally shared DateFormat instance\n+     * that uses GMT timezone and can handle RFC-1123\n+     * compliant date format.\n+     */\n+    public static DateFormat getBlueprintRFC1123Format() {\n+        return DATE_FORMAT_RFC1123;\n+    }\n+\n+\n+    /**\n+     * Method for getting a non-shared DateFormat instance\n+     * that uses specific timezone and can handle RFC-1123\n+     * compliant date format.\n+     */\n+    public static DateFormat getRFC1123Format(TimeZone tz)\n+    {\n+        DateFormat df = (DateFormat) DATE_FORMAT_RFC1123.clone();\n+        df.setTimeZone(tz);\n+        return df;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public Date parse(String dateStr) throws ParseException\n+    {\n+        dateStr = dateStr.trim();\n+        ParsePosition pos = new ParsePosition(0);\n+        Date result = parse(dateStr, pos);\n+        if (result != null) {\n+            return result;\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        for (String f : ALL_FORMATS) {\n+            if (sb.length() > 0) {\n+                sb.append(\"\\\", \\\"\");\n+            } else {\n+                sb.append('\"');\n+            }\n+            sb.append(f);\n+        }\n+        sb.append('\"');\n+        throw new ParseException\n+            (String.format(\"Can not parse date \\\"%s\\\": not compatible with any of standard forms (%s)\",\n+                           dateStr, sb.toString()), pos.getErrorIndex());\n+    }\n+\n+    @Override\n+    public Date parse(String dateStr, ParsePosition pos)\n+    {\n+        if (looksLikeISO8601(dateStr)) { // also includes \"plain\"\n+            return parseAsISO8601(dateStr, pos);\n+        }\n+        /* 14-Feb-2010, tatu: As per [JACKSON-236], better also\n+         *   consider \"stringified\" simple time stamp\n+         */\n+        int i = dateStr.length();\n+        while (--i >= 0) {\n+            char ch = dateStr.charAt(i);\n+            if (ch < '0' || ch > '9') break;\n+        }\n+        if (i < 0) { // all digits\n+            if (NumberInput.inLongRange(dateStr, false)) {\n+                return new Date(Long.parseLong(dateStr));\n+            }\n+        }\n+        // Otherwise, fall back to using RFC 1123\n+        return parseAsRFC1123(dateStr, pos);\n+    }\n+\n+    @Override\n+    public StringBuffer format(Date date, StringBuffer toAppendTo,\n+                               FieldPosition fieldPosition)\n+    {\n+        if (_formatISO8601 == null) {\n+            _formatISO8601 = (DateFormat) DATE_FORMAT_ISO8601.clone();\n+        }\n+        return _formatISO8601.format(date, toAppendTo, fieldPosition);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridable helper method used to figure out which of supported\n+     * formats is the likeliest match.\n+     */\n+    protected boolean looksLikeISO8601(String dateStr)\n+    {\n+        if (dateStr.length() >= 5\n+            && Character.isDigit(dateStr.charAt(0))\n+            && Character.isDigit(dateStr.charAt(3))\n+            && dateStr.charAt(4) == '-'\n+            ) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    protected Date parseAsISO8601(String dateStr, ParsePosition pos)\n+    {\n+        /* 21-May-2009, tatu: DateFormat has very strict handling of\n+         * timezone  modifiers for ISO-8601. So we need to do some scrubbing.\n+         */\n+\n+        /* First: do we have \"zulu\" format ('Z' == \"GMT\")? If yes, that's\n+         * quite simple because we already set date format timezone to be\n+         * GMT, and hence can just strip out 'Z' altogether\n+         */\n+        int len = dateStr.length();\n+        char c = dateStr.charAt(len-1);\n+        DateFormat df;\n+\n+        // [JACKSON-200]: need to support \"plain\" date...\n+        if (len <= 10 && Character.isDigit(c)) {\n+           df = _formatPlain;\n+            if (df == null) {\n+                df = _formatPlain = (DateFormat) DATE_FORMAT_PLAIN.clone();\n+            }\n+        } else if (c == 'Z') {\n+            df = _formatISO8601_z;\n+            if (df == null) {\n+                df = _formatISO8601_z = (DateFormat) DATE_FORMAT_ISO8601_Z.clone();\n+            }\n+            // [JACKSON-334]: may be missing milliseconds... if so, add\n+            if (dateStr.charAt(len-4) == ':') {\n+                StringBuilder sb = new StringBuilder(dateStr);\n+                sb.insert(len-1, \".000\");\n+                dateStr = sb.toString();\n+            }\n+        } else {\n+            // Let's see if we have timezone indicator or not...\n+            if (hasTimeZone(dateStr)) {\n+                c = dateStr.charAt(len-3);\n+                if (c == ':') { // remove optional colon\n+                    // remove colon\n+                    StringBuilder sb = new StringBuilder(dateStr);\n+                    sb.delete(len-3, len-2);\n+                    dateStr = sb.toString();\n+                } else if (c == '+' || c == '-') { // missing minutes\n+                    // let's just append '00'\n+                    dateStr += \"00\";\n+                }\n+                // [JACKSON-334]: may be missing milliseconds... if so, add\n+                len = dateStr.length();\n+                // '+0000' (5 chars); should come after '.000' (4 chars) of milliseconds, so:\n+                c = dateStr.charAt(len-9);\n+                if (Character.isDigit(c)) {\n+                    StringBuilder sb = new StringBuilder(dateStr);\n+                    sb.insert(len-5, \".000\");\n+                    dateStr = sb.toString();\n+                }\n+                \n+                df = _formatISO8601;\n+                if (_formatISO8601 == null) {\n+                    df = _formatISO8601 = (DateFormat) DATE_FORMAT_ISO8601.clone();\n+                }\n+            } else {\n+                /* 24-Nov-2009, tatu: Ugh. This is getting pretty\n+                 *   ugly. Need to rewrite soon!\n+                 */\n+\n+                // If not, plain date. Easiest to just patch 'Z' in the end?\n+                StringBuilder sb = new StringBuilder(dateStr);\n+                // And possible also millisecond part if missing\n+                int timeLen = len - dateStr.lastIndexOf('T') - 1;\n+                if (timeLen <= 8) {\n+                    sb.append(\".000\");\n+                }\n+                sb.append('Z');\n+                dateStr = sb.toString();\n+                df = _formatISO8601_z;\n+                if (df == null) {\n+                    df = _formatISO8601_z = (DateFormat) DATE_FORMAT_ISO8601_Z.clone();\n+                }\n+            }\n+        }\n+        return df.parse(dateStr, pos);\n+    }\n+\n+    protected Date parseAsRFC1123(String dateStr, ParsePosition pos)\n+    {\n+        if (_formatRFC1123 == null) {\n+            _formatRFC1123 = (DateFormat) DATE_FORMAT_RFC1123.clone();\n+        }\n+        return _formatRFC1123.parse(dateStr, pos);\n+    }\n+\n+    private final static boolean hasTimeZone(String str)\n+    {\n+        // Only accept \"+hh\", \"+hhmm\" and \"+hh:mm\" (and with minus), so\n+        int len = str.length();\n+        if (len >= 6) {\n+            char c = str.charAt(len-6);\n+            if (c == '+' || c == '-') return true;\n+            c = str.charAt(len-5);\n+            if (c == '+' || c == '-') return true;\n+            c = str.charAt(len-3);\n+            if (c == '+' || c == '-') return true;\n+        }\n+        return false;\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/package-info.java\n+/**\n+ * Utility classes for Mapper package.\n+ */\n+package com.fasterxml.jackson.databind.util;\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/ArrayNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+\n+\n+/**\n+ * Node class that represents Arrays mapped from Json content.\n+ */\n+public final class ArrayNode\n+    extends ContainerNode\n+{\n+    protected ArrayList<JsonNode> _children;\n+\n+    public ArrayNode(JsonNodeFactory nc) { super(nc); }\n+\n+    /*\n+    /**********************************************************\n+    /* Implementation of core JsonNode API\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken asToken() { return JsonToken.START_ARRAY; }\n+\n+    @Override\n+    public boolean isArray() { return true; }\n+\n+    @Override\n+    public int size()\n+    {\n+        return (_children == null) ? 0 : _children.size();\n+    }\n+\n+    @Override\n+    public Iterator<JsonNode> getElements()\n+    {\n+        return (_children == null) ? NoNodesIterator.instance() : _children.iterator();\n+    }\n+\n+    @Override\n+    public JsonNode get(int index)\n+    {\n+        if (index >= 0 && (_children != null) && index < _children.size()) {\n+            return _children.get(index);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public JsonNode get(String fieldName) { return null; }\n+\n+    @Override\n+    public JsonNode path(String fieldName) { return MissingNode.getInstance(); }\n+\n+    @Override\n+    public JsonNode path(int index)\n+    {\n+        if (index >= 0 && (_children != null) && index < _children.size()) {\n+            return _children.get(index);\n+        }\n+        return MissingNode.getInstance();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, serialization\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeStartArray();\n+        if (_children != null) {\n+            for (JsonNode n : _children) {\n+                /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n+                 *   extend BaseJsonNode? Or if not, at least implement\n+                 *   JsonSerializable? Let's start with former, change if\n+                 *   we must.\n+                 */\n+                ((BaseJsonNode)n).serialize(jg, provider);\n+            }\n+        }\n+        jg.writeEndArray();\n+    }\n+\n+    @Override\n+    public void serializeWithType(JsonGenerator jg, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException\n+    {\n+        typeSer.writeTypePrefixForArray(this, jg);\n+        if (_children != null) {\n+            for (JsonNode n : _children) {\n+                ((BaseJsonNode)n).serialize(jg, provider);\n+            }\n+        }\n+        typeSer.writeTypeSuffixForArray(this, jg);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, finding value nodes\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonNode findValue(String fieldName)\n+    {\n+        if (_children != null) {\n+            for (JsonNode node : _children) {\n+                JsonNode value = node.findValue(fieldName);\n+                if (value != null) {\n+                    return value;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n+    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        if (_children != null) {\n+            for (JsonNode node : _children) {\n+                foundSoFar = node.findValues(fieldName, foundSoFar);\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+\n+    @Override\n+    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n+    {\n+        if (_children != null) {\n+            for (JsonNode node : _children) {\n+                foundSoFar = node.findValuesAsText(fieldName, foundSoFar);\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+    \n+    @Override\n+    public ObjectNode findParent(String fieldName)\n+    {\n+        if (_children != null) {\n+            for (JsonNode node : _children) {\n+                JsonNode parent = node.findParent(fieldName);\n+                if (parent != null) {\n+                    return (ObjectNode) parent;\n+                }\n+            }\n+        }\n+        return null;        \n+    }\n+\n+    @Override\n+    public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        if (_children != null) {\n+            for (JsonNode node : _children) {\n+                foundSoFar = node.findParents(fieldName, foundSoFar);\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended ObjectNode API, accessors\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will set specified field, replacing old value,\n+     * if any.\n+     *\n+     * @param value to set field to; if null, will be converted\n+     *   to a {@link NullNode} first  (to remove field entry, call\n+     *   {@link #remove} instead)\n+     *\n+     * @return Old value of the field, if any; null if there was no\n+     *   old value.\n+     */\n+    public JsonNode set(int index, JsonNode value)\n+    {\n+        if (value == null) { // let's not store 'raw' nulls but nodes\n+            value = nullNode();\n+        }\n+        return _set(index, value);\n+    }\n+\n+    public void add(JsonNode value)\n+    {\n+        if (value == null) { // let's not store 'raw' nulls but nodes\n+            value = nullNode();\n+        }\n+        _add(value);\n+    }\n+\n+    /**\n+     * Method for adding all child nodes of given Array, appending to\n+     * child nodes this array contains\n+     * \n+     * @param other Array to add contents from\n+     * \n+     * @return This node (to allow chaining)\n+     * \n+     * @since 1.3\n+     */\n+    public JsonNode addAll(ArrayNode other)\n+    {\n+        int len = other.size();\n+        if (len > 0) {\n+            if (_children == null) {\n+                _children = new ArrayList<JsonNode>(len+2);\n+            }\n+            other.addContentsTo(_children);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for adding given nodes as child nodes of this array node.\n+     * \n+     * @param nodes Nodes to add\n+     * \n+     * @return This node (to allow chaining)\n+     * \n+     * @since 1.3\n+     */\n+    public JsonNode addAll(Collection<JsonNode> nodes)\n+    {\n+        int len = nodes.size();\n+        if (len > 0) {\n+            if (_children == null) {\n+                _children = new ArrayList<JsonNode>(nodes);\n+            } else {\n+                _children.addAll(nodes);\n+            }\n+        }\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for inserting specified child node as an element\n+     * of this Array. If index is 0 or less, it will be inserted as\n+     * the first element; if >= size(), appended at the end, and otherwise\n+     * inserted before existing element in specified index.\n+     * No exceptions are thrown for any index.\n+     */\n+    public void insert(int index, JsonNode value)\n+    {\n+        if (value == null) {\n+            value = nullNode();\n+        }\n+        _insert(index, value);\n+    }\n+\n+    /**\n+     * Method for removing an entry from this ArrayNode.\n+     * Will return value of the entry at specified index, if entry existed;\n+     * null if not.\n+     */\n+    public JsonNode remove(int index)\n+    {\n+        if (index >= 0 && (_children != null) && index < _children.size()) {\n+            return _children.remove(index);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public ArrayNode removeAll()\n+    {\n+        _children = null;\n+        return this;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended ObjectNode API, mutators, generic; addXxx()/insertXxx()\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will construct an ArrayNode and add it as a\n+     * field of this ObjectNode, replacing old value, if any.\n+     *\n+     * @return Newly constructed ArrayNode\n+     */\n+    public ArrayNode addArray()\n+    {\n+        ArrayNode n  = arrayNode();\n+        _add(n);\n+        return n;\n+    }\n+\n+    /**\n+     * Method that will construct an ObjectNode and add it at the end\n+     * of this array node.\n+     *\n+     * @return Newly constructed ObjectNode\n+     */\n+    public ObjectNode addObject()\n+    {\n+        ObjectNode n  = objectNode();\n+        _add(n);\n+        return n;\n+    }\n+\n+    /**\n+     * Method that will construct a POJONode and add it at the end\n+     * of this array node.\n+     */\n+    public void addPOJO(Object value)\n+    {\n+        if (value == null) {\n+            addNull();\n+        } else {\n+            _add(POJONode(value));\n+        }\n+    }\n+\n+    public void addNull()\n+    {\n+        _add(nullNode());\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void add(int v) { _add(numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void add(Integer value) {\n+        if (value == null) {\n+            addNull();\n+        } else {\n+            _add(numberNode(value.intValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void add(long v) { _add(numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void add(Long value) {\n+        if (value == null) {\n+            addNull();\n+        } else {\n+            _add(numberNode(value.longValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void add(float v) { _add(numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void add(Float value) {\n+        if (value == null) {\n+            addNull();\n+        } else {\n+            _add(numberNode(value.floatValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void add(double v) { _add(numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void add(Double value) {\n+        if (value == null) {\n+            addNull();\n+        } else {\n+            _add(numberNode(value.doubleValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void add(BigDecimal v) {\n+        if (v == null) {\n+            addNull();\n+        } else {\n+            _add(numberNode(v));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified String value.\n+     */\n+    public void add(String v) {\n+        if (v == null) {\n+            addNull();\n+        } else {\n+            _add(textNode(v));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified String value.\n+     */\n+    public void add(boolean v) { _add(booleanNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void add(Boolean value) {\n+        if (value == null) {\n+            addNull();\n+        } else {\n+            _add(booleanNode(value.booleanValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified binary value\n+     */\n+    public void add(byte[] v) {\n+        if (v == null) {\n+            addNull();\n+        } else {\n+            _add(binaryNode(v));\n+        }\n+    }\n+\n+    public ArrayNode insertArray(int index)\n+    {\n+        ArrayNode n  = arrayNode();\n+        _insert(index, n);\n+        return n;\n+    }\n+\n+    /**\n+     * Method that will construct an ObjectNode and add it at the end\n+     * of this array node.\n+     *\n+     * @return Newly constructed ObjectNode\n+     */\n+    public ObjectNode insertObject(int index)\n+    {\n+        ObjectNode n  = objectNode();\n+        _insert(index, n);\n+        return n;\n+    }\n+\n+    /**\n+     * Method that will construct a POJONode and add it at the end\n+     * of this array node.\n+     */\n+    public void insertPOJO(int index, Object value)\n+    {\n+        if (value == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, POJONode(value));\n+        }\n+    }\n+\n+    public void insertNull(int index)\n+    {\n+        _insert(index, nullNode());\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void insert(int index, int v) { _insert(index, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void insert(int index, Integer value) {\n+        if (value == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, numberNode(value.intValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void insert(int index, long v) { _insert(index, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void insert(int index, Long value) {\n+        if (value == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, numberNode(value.longValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void insert(int index, float v) { _insert(index, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void insert(int index, Float value) {\n+        if (value == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, numberNode(value.floatValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void insert(int index, double v) { _insert(index, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void insert(int index, Double value) {\n+        if (value == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, numberNode(value.doubleValue()));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void insert(int index, BigDecimal v) {\n+        if (v == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, numberNode(v));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified String value.\n+     */\n+    public void insert(int index, String v) {\n+        if (v == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, textNode(v));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified String value.\n+     */\n+    public void insert(int index, boolean v) { _insert(index, booleanNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void insert(int index, Boolean value) {\n+        if (value == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, booleanNode(value.booleanValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified binary value\n+     */\n+    public void insert(int index, byte[] v) {\n+        if (v == null) {\n+            insertNull(index);\n+        } else {\n+            _insert(index, binaryNode(v));\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Package methods (for other node classes to use)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 1.6\n+     */\n+    protected void addContentsTo(List<JsonNode> dst)\n+    {\n+        if (_children != null) {\n+            for (JsonNode n : _children) {\n+                dst.add(n);\n+            }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        ArrayNode other = (ArrayNode) o;\n+        if (_children == null || _children.size() == 0) {\n+            return other.size() == 0;\n+        }\n+        return other._sameChildren(_children);\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        int hash;\n+        if (_children == null) {\n+            hash = 1;\n+        } else {\n+            hash = _children.size();\n+            for (JsonNode n : _children) {\n+                if (n != null) {\n+                    hash ^= n.hashCode();\n+                }\n+            }\n+        }\n+        return hash;\n+    }\n+\n+\n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder(16 + (size() << 4));\n+        sb.append('[');\n+        if (_children != null) {\n+            for (int i = 0, len = _children.size(); i < len; ++i) {\n+                if (i > 0) {\n+                    sb.append(',');\n+                }\n+                sb.append(_children.get(i).toString());\n+            }\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    public JsonNode _set(int index, JsonNode value)\n+    {\n+        if (_children == null || index < 0 || index >= _children.size()) {\n+            throw new IndexOutOfBoundsException(\"Illegal index \"+index+\", array size \"+size());\n+        }\n+        return _children.set(index, value);\n+    }\n+\n+    private void _add(JsonNode node)\n+    {\n+        if (_children == null) {\n+            _children = new ArrayList<JsonNode>();\n+        }\n+        _children.add(node);\n+    }\n+\n+    private void _insert(int index, JsonNode node)\n+    {\n+        if (_children == null) {\n+            _children = new ArrayList<JsonNode>();\n+            _children.add(node);\n+            return;\n+        }\n+        if (index < 0) {\n+            _children.add(0, node);\n+        } else if (index >= _children.size()) {\n+            _children.add(node);\n+        } else {\n+            _children.add(index, node);\n+        }\n+    }\n+\n+    /**\n+     * Note: this method gets called iff <code>otherChildren</code>\n+     * is non-empty\n+     */\n+    private boolean _sameChildren(ArrayList<JsonNode> otherChildren)\n+    {\n+        int len = otherChildren.size();\n+        if (this.size() != len) { // important: call size() to handle case of null list...\n+            return false;\n+        }\n+        for (int i = 0; i < len; ++i) {\n+            if (!_children.get(i).equals(otherChildren.get(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/BaseJsonNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.JsonSerializableWithType;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+\n+\n+/**\n+ * Abstract base class common to all standard {@link JsonNode}\n+ * implementations.\n+ * The main addition here is that we declare that sub-classes must\n+ * implement {@link JsonSerializableWithType}.\n+ * This simplifies object mapping\n+ * aspects a bit, as no external serializers are needed.\n+ */\n+public abstract class BaseJsonNode\n+    extends JsonNode\n+    implements JsonSerializableWithType\n+{\n+    protected BaseJsonNode() { }\n+\n+    /*\n+    /**********************************************************\n+    /* Basic definitions for non-container types\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonNode findValue(String fieldName) {\n+        return null;\n+    }\n+\n+    @Override\n+    public final JsonNode findPath(String fieldName)\n+    {\n+        JsonNode value = findValue(fieldName);\n+        if (value == null) {\n+            return MissingNode.getInstance();\n+        }\n+        return value;\n+    }\n+    \n+    // note: co-variant return type\n+    @Override\n+    public ObjectNode findParent(String fieldName) {\n+        return null;\n+    }\n+\n+    @Override\n+    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar) {\n+        return foundSoFar;\n+    }\n+\n+    @Override\n+    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar) {\n+        return foundSoFar;\n+    }\n+    \n+    @Override\n+    public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar) {\n+        return foundSoFar;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Support for traversal-as-stream\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonParser traverse() {\n+        return new TreeTraversingParser(this);\n+    }\n+\n+    /**\n+     * Method that can be used for efficient type detection\n+     * when using stream abstraction for traversing nodes.\n+     * Will return the first {@link JsonToken} that equivalent\n+     * stream event would produce (for most nodes there is just\n+     * one token but for structured/container types multiple)\n+     *\n+     * @since 1.3\n+     */\n+    @Override\n+    public abstract JsonToken asToken();\n+\n+    /**\n+     * @since 1.3\n+     */\n+    @Override\n+    public JsonParser.NumberType getNumberType() {\n+        // most types non-numeric, so:\n+        return null; \n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonSerializable\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to serialize node instances using given generator.\n+     */\n+    @Override\n+    public abstract void serialize(JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonProcessingException;\n+\n+    /**\n+     * Type information is needed, even if JsonNode instances are \"plain\" JSON,\n+     * since they may be mixed with other types.\n+     */\n+    @Override\n+    public abstract void serializeWithType(JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException;\n+}\n+\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/BigIntegerNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Numeric node that contains simple 64-bit integer values.\n+ */\n+public final class BigIntegerNode\n+    extends NumericNode\n+{\n+    final protected BigInteger _value;\n+\n+    /*\n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+\n+    public BigIntegerNode(BigInteger v) { _value = v; }\n+\n+    public static BigIntegerNode valueOf(BigInteger v) { return new BigIntegerNode(v); }\n+\n+    /* \n+    /**********************************************************\n+    /* Overrridden JsonNode methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }\n+\n+    @Override\n+    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.BIG_INTEGER; }\n+\n+    @Override\n+    public boolean isIntegralNumber() { return true; }\n+\n+    @Override\n+    public boolean isBigInteger() { return true; }\n+\n+    @Override\n+    public Number getNumberValue() {\n+        return _value;\n+    }\n+\n+    @Override\n+    public int getIntValue() { return _value.intValue(); }\n+\n+    @Override\n+    public long getLongValue() { return _value.longValue(); }\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() { return _value; }\n+\n+    @Override\n+    public double getDoubleValue() { return _value.doubleValue(); }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() { return new BigDecimal(_value); }\n+\n+    /* \n+    /**********************************************************\n+    /* General type coercions\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public String asText() {\n+        return _value.toString();\n+    }\n+\n+    @Override\n+    public boolean asBoolean(boolean defaultValue) {\n+        return !BigInteger.ZERO.equals(_value);\n+    }\n+    \n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNumber(_value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return ((BigIntegerNode) o)._value == _value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return _value.hashCode();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/BinaryNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Value node that contains Base64 encoded binary value, which will be\n+ * output and stored as Json String value.\n+ */\n+public final class BinaryNode\n+    extends ValueNode\n+{\n+    final static BinaryNode EMPTY_BINARY_NODE = new BinaryNode(new byte[0]);\n+\n+    final byte[] _data;\n+\n+    public BinaryNode(byte[] data)\n+    {\n+        _data = data;\n+    }\n+\n+    public BinaryNode(byte[] data, int offset, int length)\n+    {\n+        if (offset == 0 && length == data.length) {\n+            _data = data;\n+        } else {\n+            _data = new byte[length];\n+            System.arraycopy(data, offset, _data, 0, length);\n+        }\n+    }\n+\n+    public static BinaryNode valueOf(byte[] data)\n+    {\n+        if (data == null) {\n+            return null;\n+        }\n+        if (data.length == 0) {\n+            return EMPTY_BINARY_NODE;\n+        }\n+        return new BinaryNode(data);\n+    }\n+\n+    public static BinaryNode valueOf(byte[] data, int offset, int length)\n+    {\n+        if (data == null) {\n+            return null;\n+        }\n+        if (length == 0) {\n+            return EMPTY_BINARY_NODE;\n+        }\n+        return new BinaryNode(data, offset, length);\n+    }\n+\n+    @Override\n+    public JsonToken asToken() {\n+        /* No distinct type; could use one for textual values,\n+         * but given that it's not in text form at this point,\n+         * embedded-object is closest\n+         */\n+        return JsonToken.VALUE_EMBEDDED_OBJECT;\n+    }\n+\n+    @Override\n+    public boolean isBinary() { return true; }\n+\n+    /**\n+     *<p>\n+     * Note: caller is not to modify returned array in any way, since\n+     * it is not a copy but reference to the underlying byte array.\n+     */\n+    @Override\n+    public byte[] getBinaryValue() { return _data; }\n+\n+    /**\n+     * Hmmh. This is not quite as efficient as using {@link #serialize},\n+     * but will work correctly.\n+     */\n+    @Override\n+    public String asText() {\n+        return Base64Variants.getDefaultVariant().encode(_data, false);\n+    }\n+\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeBinary(_data);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return Arrays.equals(((BinaryNode) o)._data, _data);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return (_data == null) ? -1 : _data.length;\n+    }\n+\n+    /**\n+     * Different from other values, since contents need to be surrounded\n+     * by (double) quotes.\n+     */\n+    @Override\n+    public String toString()\n+    {\n+        return Base64Variants.getDefaultVariant().encode(_data, true);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/BooleanNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * This concrete value class is used to contain boolean (true / false)\n+ * values. Only two instances are ever created, to minimize memory\n+ * usage\n+ */\n+public final class BooleanNode\n+    extends ValueNode\n+{\n+    // // Just need two instances...\n+\n+    public final static BooleanNode TRUE = new BooleanNode();\n+    public final static BooleanNode FALSE = new BooleanNode();\n+\n+    private BooleanNode() { }\n+\n+    public static BooleanNode getTrue() { return TRUE; }\n+    public static BooleanNode getFalse() { return FALSE; }\n+\n+    public static BooleanNode valueOf(boolean b) { return b ? TRUE : FALSE; }\n+\n+    // Interesting... two choices...\n+    @Override public JsonToken asToken() {\n+        return (this == TRUE) ? JsonToken.VALUE_TRUE : JsonToken.VALUE_FALSE;\n+    }\n+\n+    @Override\n+    public boolean isBoolean() { return true; }\n+\n+    @Override\n+    public boolean getBooleanValue() {\n+        return (this == TRUE);\n+    }\n+\n+    @Override\n+    public String asText() {\n+        return (this == TRUE) ? \"true\" : \"false\";\n+    }\n+\n+    @Override\n+    public boolean asBoolean() {\n+        return (this == TRUE);\n+    }\n+\n+    @Override\n+    public boolean asBoolean(boolean defaultValue) {\n+        return (this == TRUE);\n+    }\n+    \n+    @Override\n+    public int asInt(int defaultValue) {\n+        return (this == TRUE) ? 1 : 0;\n+    }\n+    @Override\n+    public long asLong(long defaultValue) {\n+        return (this == TRUE) ? 1L : 0L;\n+    }\n+    @Override\n+    public double asDouble(double defaultValue) {\n+        return (this == TRUE) ? 1.0 : 0.0;\n+    }\n+    \n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeBoolean(this == TRUE);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        /* Since there are only ever two instances in existence\n+         * can do identity comparison\n+         */\n+        return (o == this);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/ContainerNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.math.BigDecimal;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * This intermediate base class is used for all container nodes,\n+ * specifically, array and object nodes.\n+ */\n+public abstract class ContainerNode\n+    extends BaseJsonNode\n+{\n+    /**\n+     * We will keep a reference to the Object (usually TreeMapper)\n+     * that can construct instances of nodes to add to this container\n+     * node.\n+     */\n+    JsonNodeFactory _nodeFactory;\n+\n+    protected ContainerNode(JsonNodeFactory nc)\n+    {\n+        _nodeFactory = nc;\n+    }\n+\n+    @Override\n+    public boolean isContainerNode() { return true; }\n+\n+    @Override\n+    public abstract JsonToken asToken();\n+    \n+    @Override\n+    public String asText() { return \"\"; }\n+\n+    /*\n+    /**********************************************************\n+    /* Find methods; made abstract again to ensure implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public abstract JsonNode findValue(String fieldName);\n+    \n+    @Override\n+    public abstract ObjectNode findParent(String fieldName);\n+\n+    @Override\n+    public abstract List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar);\n+    \n+    @Override\n+    public abstract List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar);\n+\n+    @Override\n+    public abstract List<String> findValuesAsText(String fieldName, List<String> foundSoFar);\n+    \n+    /*\n+    /**********************************************************\n+    /* Methods reset as abstract to force real implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public abstract int size();\n+\n+    @Override\n+    public abstract JsonNode get(int index);\n+\n+    @Override\n+    public abstract JsonNode get(String fieldName);\n+\n+    /*\n+    /**********************************************************\n+    /* NodeCreator implementation, just dispatch to\n+    /* the real creator\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory method that constructs and returns an empty {@link ArrayNode}\n+     * Construction is done using registered {@link JsonNodeFactory}.\n+     */\n+    public final ArrayNode arrayNode() { return _nodeFactory.arrayNode(); }\n+\n+    /**\n+     * Factory method that constructs and returns an empty {@link ObjectNode}\n+     * Construction is done using registered {@link JsonNodeFactory}.\n+     */\n+    public final ObjectNode objectNode() { return _nodeFactory.objectNode(); }\n+\n+    public final NullNode nullNode() { return _nodeFactory.nullNode(); }\n+\n+    public final BooleanNode booleanNode(boolean v) { return _nodeFactory.booleanNode(v); }\n+\n+    public final NumericNode numberNode(byte v) { return _nodeFactory.numberNode(v); }\n+    public final NumericNode numberNode(short v) { return _nodeFactory.numberNode(v); }\n+    public final NumericNode numberNode(int v) { return _nodeFactory.numberNode(v); }\n+    public final NumericNode numberNode(long v) { return _nodeFactory.numberNode(v); }\n+    public final NumericNode numberNode(float v) { return _nodeFactory.numberNode(v); }\n+    public final NumericNode numberNode(double v) { return _nodeFactory.numberNode(v); }\n+    public final NumericNode numberNode(BigDecimal v) { return (_nodeFactory.numberNode(v)); }\n+\n+    public final TextNode textNode(String text) { return _nodeFactory.textNode(text); }\n+\n+    public final BinaryNode binaryNode(byte[] data) { return _nodeFactory.binaryNode(data); }\n+    public final BinaryNode binaryNode(byte[] data, int offset, int length) { return _nodeFactory.binaryNode(data, offset, length); }\n+\n+    public final POJONode POJONode(Object pojo) { return _nodeFactory.POJONode(pojo); }\n+\n+    /*\n+    /**********************************************************\n+    /* Common mutators\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method for removing all children container has (if any)\n+     *\n+     * @return Container node itself (to allow method call chaining)\n+     *\n+     * @since 1.3\n+     */\n+    public abstract ContainerNode removeAll();\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    protected static class NoNodesIterator\n+        implements Iterator<JsonNode>\n+    {\n+        final static NoNodesIterator instance = new NoNodesIterator();\n+\n+        private NoNodesIterator() { }\n+\n+        public static NoNodesIterator instance() { return instance; }\n+\n+        @Override\n+        public boolean hasNext() { return false; }\n+        @Override\n+        public JsonNode next() { throw new NoSuchElementException(); }\n+\n+        @Override\n+        public void remove() {\n+            // could as well throw IllegalOperationException?\n+            throw new IllegalStateException();\n+        }\n+    }\n+\n+    protected static class NoStringsIterator\n+        implements Iterator<String>\n+    {\n+        final static NoStringsIterator instance = new NoStringsIterator();\n+\n+        private NoStringsIterator() { }\n+\n+        public static NoStringsIterator instance() { return instance; }\n+\n+        @Override\n+        public boolean hasNext() { return false; }\n+        @Override\n+        public String next() { throw new NoSuchElementException(); }\n+\n+        @Override\n+        public void remove() {\n+            // could as well throw IllegalOperationException?\n+            throw new IllegalStateException();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/DecimalNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Numeric node that contains values that do not fit in simple\n+ * integer (int, long) or floating point (double) values.\n+ */\n+public final class DecimalNode\n+    extends NumericNode\n+{\n+    final protected BigDecimal _value;\n+\n+    /* \n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+\n+    public DecimalNode(BigDecimal v) { _value = v; }\n+\n+    public static DecimalNode valueOf(BigDecimal d) { return new DecimalNode(d); }\n+\n+    /* \n+    /**********************************************************\n+    /* BaseJsonNode extended API\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_FLOAT; }\n+\n+    @Override\n+    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.BIG_DECIMAL; }\n+\n+    /* \n+    /**********************************************************\n+    /* Overrridden JsonNode methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isFloatingPointNumber() { return true; }\n+    \n+    @Override\n+    public boolean isBigDecimal() { return true; }\n+    \n+    @Override\n+    public Number getNumberValue() { return _value; }\n+\n+    @Override\n+    public int getIntValue() { return _value.intValue(); }\n+\n+    @Override\n+    public long getLongValue() { return _value.longValue(); }\n+\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() { return _value.toBigInteger(); }\n+\n+    @Override\n+    public double getDoubleValue() { return _value.doubleValue(); }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() { return _value; }\n+\n+    @Override\n+    public String asText() {\n+        return _value.toString();\n+    }\n+\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNumber(_value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return ((DecimalNode) o)._value.equals(_value);\n+    }\n+\n+    @Override\n+    public int hashCode() { return _value.hashCode(); }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/DoubleNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.NumberOutput;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Numeric node that contains 64-bit (\"double precision\")\n+ * floating point values simple 32-bit integer values.\n+ */\n+public final class DoubleNode\n+    extends NumericNode\n+{\n+    protected final double _value;\n+\n+    /* \n+    /**********************************************************\n+    /* Construction\n+    /**********************************************************\n+     */\n+\n+    public DoubleNode(double v) { _value = v; }\n+\n+    public static DoubleNode valueOf(double v) { return new DoubleNode(v); }\n+\n+    /* \n+    /**********************************************************\n+    /* BaseJsonNode extended API\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_FLOAT; }\n+\n+    @Override\n+    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.DOUBLE; }\n+\n+    /* \n+    /**********************************************************\n+    /* Overrridden JsonNode methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isFloatingPointNumber() { return true; }\n+\n+    @Override\n+    public boolean isDouble() { return true; }\n+\n+    @Override\n+    public Number getNumberValue() {\n+        return Double.valueOf(_value);\n+    }\n+\n+    @Override\n+        public int getIntValue() { return (int) _value; }\n+\n+    @Override\n+        public long getLongValue() { return (long) _value; }\n+\n+    @Override\n+        public double getDoubleValue() { return _value; }\n+\n+    @Override\n+        public BigDecimal getDecimalValue() { return BigDecimal.valueOf(_value); }\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() {\n+        return getDecimalValue().toBigInteger();\n+    }\n+\n+    @Override\n+    public String asText() {\n+        return NumberOutput.toString(_value);\n+    }\n+\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNumber(_value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return ((DoubleNode) o)._value == _value;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        // same as hashCode Double.class uses\n+        long l = Double.doubleToLongBits(_value);\n+        return ((int) l) ^ (int) (l >> 32);\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/IntNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.NumberOutput;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Numeric node that contains simple 32-bit integer values.\n+ */\n+public final class IntNode\n+    extends NumericNode\n+{\n+    // // // Let's cache small set of common value\n+\n+    final static int MIN_CANONICAL = -1;\n+    final static int MAX_CANONICAL = 10;\n+\n+    private final static IntNode[] CANONICALS;\n+    static {\n+        int count = MAX_CANONICAL - MIN_CANONICAL + 1;\n+        CANONICALS = new IntNode[count];\n+        for (int i = 0; i < count; ++i) {\n+            CANONICALS[i] = new IntNode(MIN_CANONICAL + i);\n+        }\n+    }\n+\n+    /**\n+     * Integer value this node contains\n+     */\n+    final int _value;\n+\n+    /* \n+    ************************************************\n+    * Construction\n+    ************************************************\n+    */\n+\n+    public IntNode(int v) { _value = v; }\n+\n+    public static IntNode valueOf(int i) {\n+        if (i > MAX_CANONICAL || i < MIN_CANONICAL) return new IntNode(i);\n+        return CANONICALS[i - MIN_CANONICAL];\n+    }\n+\n+    /* \n+    /**********************************************************\n+    /* BaseJsonNode extended API\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }\n+\n+    @Override\n+    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.INT; }\n+\n+    /* \n+    /**********************************************************\n+    /* Overrridden JsonNode methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean isIntegralNumber() { return true; }\n+\n+    @Override\n+    public boolean isInt() { return true; }\n+\n+    @Override\n+    public Number getNumberValue() {\n+        return Integer.valueOf(_value);\n+    }\n+\n+    @Override\n+    public int getIntValue() { return _value; }\n+\n+    @Override\n+    public long getLongValue() { return (long) _value; }\n+\n+    @Override\n+    public double getDoubleValue() { return (double) _value; }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() { return BigDecimal.valueOf(_value); }\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() { return BigInteger.valueOf(_value); }\n+\n+    @Override\n+    public String asText() {\n+        return NumberOutput.toString(_value);\n+    }\n+\n+    @Override\n+    public boolean asBoolean(boolean defaultValue) {\n+        return _value != 0;\n+    }\n+    \n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNumber(_value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return ((IntNode) o)._value == _value;\n+    }\n+\n+    @Override\n+        public int hashCode() { return _value; }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/JsonNodeFactory.java\n+package org.codehaus.jackson.node;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+/**\n+ * Base class that specifies methods for getting access to\n+ * Node instances (newly constructed, or shared, depending\n+ * on type), as well as basic implementation of the methods. \n+ * Designed to be sub-classed if extended functionality (additions\n+ * to behavior of node types, mostly) is needed.\n+ */\n+public class JsonNodeFactory\n+{\n+    /**\n+     * Default singleton instance that construct \"standard\" node instances:\n+     * given that this class is stateless, a globally shared singleton\n+     * can be used.\n+     */\n+    public final static JsonNodeFactory instance = new JsonNodeFactory();\n+\n+    protected JsonNodeFactory() { }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods for literal values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory method for getting an instance of JSON boolean value\n+     * (either literal 'true' or 'false')\n+     */\n+    public BooleanNode booleanNode(boolean v) {\n+        return v ? BooleanNode.getTrue() : BooleanNode.getFalse();\n+    }\n+\n+    /**\n+     * Factory method for getting an instance of JSON null node (which\n+     * represents literal null value)\n+     */\n+    public NullNode nullNode() { return NullNode.getInstance(); }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods for numeric values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given 8-bit value\n+     */\n+    public NumericNode numberNode(byte v) { return IntNode.valueOf(v); }\n+\n+    /**\n+     * Alternate factory method that will handle wrapper value, which may\n+     * be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n+     * \n+     * @since 1.9\n+     */\n+    public ValueNode numberNode(Byte value) {\n+        return (value == null) ? nullNode() : IntNode.valueOf(value.intValue());\n+    }\n+    \n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given 16-bit integer value\n+     */\n+    public NumericNode numberNode(short v) { return IntNode.valueOf(v); }\n+\n+    /**\n+     * Alternate factory method that will handle wrapper value, which may\n+     * be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n+     * \n+     * @since 1.9\n+     */\n+    public ValueNode numberNode(Short value) {\n+        return (value == null) ? nullNode() : IntNode.valueOf(value.shortValue());\n+    }\n+    \n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given 32-bit integer value\n+     */\n+    public NumericNode numberNode(int v) { return IntNode.valueOf(v); }\n+\n+    /**\n+     * Alternate factory method that will handle wrapper value, which may\n+     * be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n+     * \n+     * @since 1.9\n+     */\n+    public ValueNode numberNode(Integer value) {\n+        return (value == null) ? nullNode() : IntNode.valueOf(value.intValue());\n+    }\n+    \n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given 64-bit integer value\n+     */\n+    public NumericNode numberNode(long v) { return LongNode.valueOf(v); }\n+\n+    /**\n+     * Alternate factory method that will handle wrapper value, which may\n+     * be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n+     * \n+     * @since 1.9\n+     */\n+    public ValueNode numberNode(Long value) {\n+        return (value == null) ? nullNode() : LongNode.valueOf(value.longValue());\n+    }\n+    \n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given unlimited range integer value\n+     */\n+    public NumericNode numberNode(BigInteger v) { return BigIntegerNode.valueOf(v); }\n+\n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given 32-bit floating point value\n+     */\n+    public NumericNode numberNode(float v) { return DoubleNode.valueOf((double) v); }\n+\n+    /**\n+     * Alternate factory method that will handle wrapper value, which may\n+     * be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n+     * \n+     * @since 1.9\n+     */\n+    public ValueNode numberNode(Float value) {\n+        return (value == null) ? nullNode() : DoubleNode.valueOf(value.doubleValue());\n+    }\n+    \n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given 64-bit floating point value\n+     */\n+    public NumericNode numberNode(double v) { return DoubleNode.valueOf(v); }\n+\n+    /**\n+     * Alternate factory method that will handle wrapper value, which may\n+     * be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n+     * \n+     * @since 1.9\n+     */\n+    public ValueNode numberNode(Double value) {\n+        return (value == null) ? nullNode() : DoubleNode.valueOf(value.doubleValue());\n+    }\n+    \n+    /**\n+     * Factory method for getting an instance of JSON numeric value\n+     * that expresses given unlimited precision floating point value\n+     */\n+    public NumericNode numberNode(BigDecimal v) { return DecimalNode.valueOf(v); }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory methods for textual values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory method for constructing a node that represents JSON\n+     * String value\n+     */\n+    public TextNode textNode(String text) { return TextNode.valueOf(text); }\n+\n+    /**\n+     * Factory method for constructing a node that represents given\n+     * binary data, and will get serialized as equivalent base64-encoded\n+     * String value\n+     */\n+    public BinaryNode binaryNode(byte[] data) { return BinaryNode.valueOf(data); }\n+\n+    /**\n+     * Factory method for constructing a node that represents given\n+     * binary data, and will get serialized as equivalent base64-encoded\n+     * String value\n+     */\n+    public BinaryNode binaryNode(byte[] data, int offset, int length) {\n+        return BinaryNode.valueOf(data, offset, length);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Factory method for structured values\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Factory method for constructing an empty JSON Array node\n+     */\n+    public ArrayNode arrayNode() { return new ArrayNode(this); }\n+\n+    /**\n+     * Factory method for constructing an empty JSON Object (\"struct\") node\n+     */\n+    public ObjectNode objectNode() { return new ObjectNode(this); }\n+\n+    /**\n+     * Factory method for constructing a wrapper for POJO\n+     * (\"Plain Old Java Object\") objects; these will get serialized\n+     * using data binding, usually as JSON Objects, but in some\n+     * cases as JSON Strings or other node types.\n+     */\n+    public POJONode POJONode(Object pojo) { return new POJONode(pojo); }\n+}\n+\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/LongNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.NumberOutput;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Numeric node that contains simple 64-bit integer values.\n+ */\n+public final class LongNode\n+    extends NumericNode\n+{\n+    final long _value;\n+\n+    /* \n+    ************************************************\n+    * Construction\n+    ************************************************\n+    */\n+\n+    public LongNode(long v) { _value = v; }\n+\n+    public static LongNode valueOf(long l) { return new LongNode(l); }\n+\n+    /* \n+    ************************************************\n+    * Overrridden JsonNode methods\n+    ************************************************\n+    */\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }\n+\n+    @Override\n+    public JsonParser.NumberType getNumberType() { return JsonParser.NumberType.LONG; }\n+\n+\n+    @Override\n+    public boolean isIntegralNumber() { return true; }\n+\n+    @Override\n+    public boolean isLong() { return true; }\n+\n+    @Override\n+    public Number getNumberValue() {\n+        return Long.valueOf(_value);\n+    }\n+\n+    @Override\n+    public int getIntValue() { return (int) _value; }\n+\n+    @Override\n+    public long getLongValue() { return _value; }\n+\n+    @Override\n+    public double getDoubleValue() { return (double) _value; }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() { return BigDecimal.valueOf(_value); }\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() { return BigInteger.valueOf(_value); }\n+\n+    @Override\n+    public String asText() {\n+        return NumberOutput.toString(_value);\n+    }\n+\n+    @Override\n+    public boolean asBoolean(boolean defaultValue) {\n+        return _value != 0;\n+    }\n+    \n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNumber(_value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return ((LongNode) o)._value == _value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return ((int) _value) ^ (int) (_value >> 32);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/MissingNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+\n+\n+/**\n+ * This singleton node class is generated to denote \"missing nodes\"\n+ * along paths that do not exist. For example, if a path via\n+ * element of an array is requested for an element outside range\n+ * of elements in the array; or for a non-array value, result\n+ * will be reference to this node.\n+ *<p>\n+ * In most respects this placeholder node will act as {@link NullNode};\n+ * for example, for purposes of value conversions, value is considered\n+ * to be null and represented as value zero when used for numeric\n+ * conversions. \n+ */\n+public final class MissingNode\n+    extends BaseJsonNode\n+{\n+    private final static MissingNode instance = new MissingNode();\n+\n+    private MissingNode() { }\n+\n+    public static MissingNode getInstance() { return instance; }\n+\n+    @Override public JsonToken asToken() { return JsonToken.NOT_AVAILABLE; }\n+\n+    @Override\n+    public boolean isMissingNode() { return true; }\n+\n+    @Override\n+    public String asText() { return null; }\n+    \n+    @Override\n+    public int asInt(int defaultValue) {\n+        return 0;\n+    }\n+    @Override\n+    public long asLong(long defaultValue) {\n+        return 0L;\n+    }\n+    @Override\n+    public double asDouble(double defaultValue) {\n+        return 0.0;\n+    }\n+    \n+    @Override\n+    public JsonNode path(String fieldName) { return this; }\n+\n+    @Override\n+    public JsonNode path(int index) { return this; }\n+\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        /* Nothing to output... should we signal an error tho?\n+         * Chances are, this is an erroneous call. For now, let's\n+         * not do that.\n+         */\n+        jg.writeNull();\n+    }\n+\n+    @Override\n+    public void serializeWithType(JsonGenerator jg, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNull();\n+    }\n+    \n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        /* Hmmh. Since there's just a singleton instance, this\n+         * fails in all cases but with identity comparison.\n+         * However: if this placeholder value was to be considered\n+         * similar to Sql NULL, it shouldn't even equal itself?\n+         * That might cause problems when dealing with collections\n+         * like Sets... so for now, let's let identity comparison\n+         * return true.\n+         */\n+        return (o == this);\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        // toString() should never return null\n+        return \"\";\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/NodeCursor.java\n+package org.codehaus.jackson.node;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+\n+/**\n+ * Helper class used by {@link TreeTraversingParser} to keep track\n+ * of current location within traversed JSON tree.\n+ */\n+abstract class NodeCursor\n+    extends JsonStreamContext\n+{\n+    /**\n+     * Parent cursor of this cursor, if any; null for root\n+     * cursors.\n+     */\n+    protected final NodeCursor _parent;\n+\n+    public NodeCursor(int contextType, NodeCursor p)\n+    {\n+        super();\n+        _type = contextType;\n+        _index = -1;\n+        _parent = p;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonStreamContext impl\n+    /**********************************************************\n+     */\n+\n+    // note: co-variant return type\n+    @Override\n+    public final NodeCursor getParent() { return _parent; }\n+\n+    @Override\n+    public abstract String getCurrentName();\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    public abstract JsonToken nextToken();\n+    public abstract JsonToken nextValue();\n+    public abstract JsonToken endToken();\n+\n+    public abstract JsonNode currentNode();\n+    public abstract boolean currentHasChildren();\n+\n+    /**\n+     * Method called to create a new context for iterating all\n+     * contents of the current structured value (JSON array or object)\n+     */\n+    public final NodeCursor iterateChildren() {\n+        JsonNode n = currentNode();\n+        if (n == null) throw new IllegalStateException(\"No current node\");\n+        if (n.isArray()) { // false since we have already returned START_ARRAY\n+            return new Array(n, this);\n+        }\n+        if (n.isObject()) {\n+            return new Object(n, this);\n+        }\n+        throw new IllegalStateException(\"Current node of type \"+n.getClass().getName());\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Concrete implementations\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Context matching root-level value nodes (i.e. anything other\n+     * than JSON Object and Array).\n+     * Note that context is NOT created for leaf values.\n+     */\n+    protected final static class RootValue\n+        extends NodeCursor\n+    {\n+        JsonNode _node;\n+\n+        protected boolean _done = false;\n+\n+        public RootValue(JsonNode n, NodeCursor p) {\n+            super(JsonStreamContext.TYPE_ROOT, p);\n+            _node = n;\n+        }\n+\n+        @Override\n+        public String getCurrentName() { return null; }\n+\n+        @Override\n+        public JsonToken nextToken() {\n+            if (!_done) {\n+                _done = true;\n+                return _node.asToken();\n+            }\n+            _node = null;\n+            return null;\n+        }\n+        \n+        @Override\n+        public JsonToken nextValue() { return nextToken(); }\n+        @Override\n+        public JsonToken endToken() { return null; }\n+        @Override\n+        public JsonNode currentNode() { return _node; }\n+        @Override\n+        public boolean currentHasChildren() { return false; }\n+    }\n+\n+    /**\n+     * Cursor used for traversing non-empty JSON Array nodes\n+     */\n+    protected final static class Array\n+        extends NodeCursor\n+    {\n+        Iterator<JsonNode> _contents;\n+\n+        JsonNode _currentNode;\n+\n+        public Array(JsonNode n, NodeCursor p) {\n+            super(JsonStreamContext.TYPE_ARRAY, p);\n+            _contents = n.getElements();\n+        }\n+\n+        @Override\n+        public String getCurrentName() { return null; }\n+\n+        @Override\n+        public JsonToken nextToken()\n+        {\n+            if (!_contents.hasNext()) {\n+                _currentNode = null;\n+                return null;\n+            }\n+            _currentNode = _contents.next();\n+            return _currentNode.asToken();\n+        }\n+\n+        @Override\n+        public JsonToken nextValue() { return nextToken(); }\n+        @Override\n+        public JsonToken endToken() { return JsonToken.END_ARRAY; }\n+\n+        @Override\n+        public JsonNode currentNode() { return _currentNode; }\n+        @Override\n+        public boolean currentHasChildren() {\n+            // note: ONLY to be called for container nodes\n+            return ((ContainerNode) currentNode()).size() > 0;\n+        }\n+    }\n+\n+    /**\n+     * Cursor used for traversing non-empty JSON Object nodes\n+     */\n+    protected final static class Object\n+        extends NodeCursor\n+    {\n+        Iterator<Map.Entry<String, JsonNode>> _contents;\n+        Map.Entry<String, JsonNode> _current;\n+\n+        boolean _needEntry;\n+        \n+        public Object(JsonNode n, NodeCursor p)\n+        {\n+            super(JsonStreamContext.TYPE_OBJECT, p);\n+            _contents = ((ObjectNode) n).getFields();\n+            _needEntry = true;\n+        }\n+\n+        @Override\n+        public String getCurrentName() {\n+            return (_current == null) ? null : _current.getKey();\n+        }\n+\n+        @Override\n+        public JsonToken nextToken()\n+        {\n+            // Need a new entry?\n+            if (_needEntry) {\n+                if (!_contents.hasNext()) {\n+                    _current = null;\n+                    return null;\n+                }\n+                _needEntry = false;\n+                _current = _contents.next();\n+                return JsonToken.FIELD_NAME;\n+            }\n+            _needEntry = true;\n+            return _current.getValue().asToken();\n+        }\n+\n+        @Override\n+        public JsonToken nextValue()\n+        {\n+            JsonToken t = nextToken();\n+            if (t == JsonToken.FIELD_NAME) {\n+                t = nextToken();\n+            }\n+            return t;\n+        }\n+\n+        @Override\n+        public JsonToken endToken() { return JsonToken.END_OBJECT; }\n+\n+        @Override\n+        public JsonNode currentNode() {\n+            return (_current == null) ? null : _current.getValue();\n+        }\n+        @Override\n+        public boolean currentHasChildren() {\n+            // note: ONLY to be called for container nodes\n+            return ((ContainerNode) currentNode()).size() > 0;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/NullNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * This singleton value class is used to contain explicit JSON null\n+ * value.\n+ */\n+public final class NullNode\n+    extends ValueNode\n+{\n+    // // Just need a fly-weight singleton\n+\n+    public final static NullNode instance = new NullNode();\n+\n+    private NullNode() { }\n+\n+    public static NullNode getInstance() { return instance; }\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_NULL; }\n+\n+    @Override\n+    public boolean isNull() { return true; }\n+\n+    @Override\n+    public String asText() {\n+        return \"null\";\n+    }\n+\n+    @Override\n+    public int asInt(int defaultValue) {\n+        return 0;\n+    }\n+    @Override\n+    public long asLong(long defaultValue) {\n+        return 0L;\n+    }\n+    @Override\n+    public double asDouble(double defaultValue) {\n+        return 0.0;\n+    }\n+    \n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNull();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        return (o == this);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/NumericNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+\n+/**\n+ * Intermediate value node used for numeric nodes.\n+ */\n+public abstract class NumericNode\n+    extends ValueNode\n+{\n+    protected NumericNode() { }\n+\n+    @Override\n+    public final boolean isNumber() { return true; }\n+\n+    // // // Let's re-abstract so sub-classes handle them\n+\n+    @Override\n+    public abstract JsonParser.NumberType getNumberType();\n+\n+    @Override\n+    public abstract Number getNumberValue();\n+    @Override\n+    public abstract int getIntValue();\n+    @Override\n+    public abstract long getLongValue();\n+    @Override\n+    public abstract double getDoubleValue();\n+    @Override\n+    public abstract BigDecimal getDecimalValue();\n+    @Override\n+    public abstract BigInteger getBigIntegerValue();\n+\n+    /* \n+    /**********************************************************\n+    /* General type coercions\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public abstract String asText();\n+\n+    @Override\n+    public int asInt() {\n+        return getIntValue();\n+    }\n+    @Override\n+    public int asInt(int defaultValue) {\n+        return getIntValue();\n+    }\n+\n+    @Override\n+    public long asLong() {\n+        return getLongValue();\n+    }\n+    @Override\n+    public long asLong(long defaultValue) {\n+        return getLongValue();\n+    }\n+    \n+    @Override\n+    public double asDouble() {\n+        return getDoubleValue();\n+    }\n+    @Override\n+    public double asDouble(double defaultValue) {\n+        return getDoubleValue();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/ObjectNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.*;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+\n+\n+/**\n+ * Node that maps to JSON Object structures in JSON content.\n+ */\n+public class ObjectNode\n+    extends ContainerNode\n+{\n+    protected LinkedHashMap<String, JsonNode> _children = null;\n+\n+    public ObjectNode(JsonNodeFactory nc) { super(nc); }\n+    \n+    /*\n+    /**********************************************************\n+    /* Implementation of core JsonNode API\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken asToken() { return JsonToken.START_OBJECT; }\n+\n+    @Override\n+    public boolean isObject() { return true; }\n+\n+    @Override\n+    public int size() {\n+        return (_children == null) ? 0 : _children.size();\n+    }\n+\n+    @Override\n+    public Iterator<JsonNode> getElements()\n+    {\n+        return (_children == null) ? NoNodesIterator.instance() : _children.values().iterator();\n+    }\n+\n+    @Override\n+    public JsonNode get(int index) { return null; }\n+\n+    @Override\n+    public JsonNode get(String fieldName)\n+    {\n+        if (_children != null) {\n+            return _children.get(fieldName);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Iterator<String> getFieldNames()\n+    {\n+        return (_children == null) ? NoStringsIterator.instance() : _children.keySet().iterator();\n+    }\n+\n+    @Override\n+    public JsonNode path(int index)\n+    {\n+        return MissingNode.getInstance();\n+    }\n+\n+    @Override\n+    public JsonNode path(String fieldName)\n+    {\n+        if (_children != null) {\n+            JsonNode n = _children.get(fieldName);\n+            if (n != null) {\n+                return n;\n+            }\n+        }\n+        return MissingNode.getInstance();\n+    }\n+\n+    /**\n+     * Method to use for accessing all fields (with both names\n+     * and values) of this JSON Object.\n+     */\n+    @Override\n+    public Iterator<Map.Entry<String, JsonNode>> getFields()\n+    {\n+        if (_children == null) {\n+            return NoFieldsIterator.instance;\n+        }\n+        return _children.entrySet().iterator();\n+    }\n+\n+    @Override\n+    public ObjectNode with(String propertyName)\n+    {\n+        if (_children == null) {\n+            _children = new LinkedHashMap<String, JsonNode>();\n+        } else {\n+            JsonNode n = _children.get(propertyName);\n+            if (n != null) {\n+                if (n instanceof ObjectNode) {\n+                    return (ObjectNode) n;\n+                }\n+                throw new UnsupportedOperationException(\"Property '\"+propertyName\n+                        +\"' has value that is not of type ObjectNode (but \"\n+                        +n.getClass().getName()+\")\");\n+            }\n+        }\n+        ObjectNode result = objectNode();\n+        _children.put(propertyName, result);\n+        return result;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, finding value nodes\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonNode findValue(String fieldName)\n+    {\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+                if (fieldName.equals(entry.getKey())) {\n+                    return entry.getValue();\n+                }\n+                JsonNode value = entry.getValue().findValue(fieldName);\n+                if (value != null) {\n+                    return value;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n+    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+                if (fieldName.equals(entry.getKey())) {\n+                    if (foundSoFar == null) {\n+                        foundSoFar = new ArrayList<JsonNode>();\n+                    }\n+                    foundSoFar.add(entry.getValue());\n+                } else { // only add children if parent not added\n+                    foundSoFar = entry.getValue().findValues(fieldName, foundSoFar);\n+                }\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+\n+    @Override\n+    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n+    {\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+                if (fieldName.equals(entry.getKey())) {\n+                    if (foundSoFar == null) {\n+                        foundSoFar = new ArrayList<String>();\n+                    }\n+                    foundSoFar.add(entry.getValue().asText());\n+                } else { // only add children if parent not added\n+                    foundSoFar = entry.getValue().findValuesAsText(fieldName, foundSoFar);\n+                }\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+    \n+    @Override\n+    public ObjectNode findParent(String fieldName)\n+    {\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+                if (fieldName.equals(entry.getKey())) {\n+                    return this;\n+                }\n+                JsonNode value = entry.getValue().findParent(fieldName);\n+                if (value != null) {\n+                    return (ObjectNode) value;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+                if (fieldName.equals(entry.getKey())) {\n+                    if (foundSoFar == null) {\n+                        foundSoFar = new ArrayList<JsonNode>();\n+                    }\n+                    foundSoFar.add(this);\n+                } else { // only add children if parent not added\n+                    foundSoFar = entry.getValue().findParents(fieldName, foundSoFar);\n+                }\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, serialization\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be called to serialize this node and\n+     * all of its descendants using specified JSON generator.\n+     */\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeStartObject();\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+                jg.writeFieldName(en.getKey());\n+                /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n+                 *   extend BaseJsonNode? Or if not, at least implement\n+                 *   JsonSerializable? Let's start with former, change if\n+                 *   we must.\n+                 */\n+                ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n+            }\n+        }\n+        jg.writeEndObject();\n+    }\n+\n+    @Override\n+    public void serializeWithType(JsonGenerator jg, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException\n+    {\n+        typeSer.writeTypePrefixForObject(this, jg);\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+                jg.writeFieldName(en.getKey());\n+                ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n+            }\n+        }\n+        typeSer.writeTypeSuffixForObject(this, jg);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended ObjectNode API, mutators, generic\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will set specified field, replacing old value,\n+     * if any.\n+     *\n+     * @param value to set field to; if null, will be converted\n+     *   to a {@link NullNode} first  (to remove field entry, call\n+     *   {@link #remove} instead)\n+     *\n+     * @return Old value of the field, if any; null if there was no\n+     *   old value.\n+     */\n+    public JsonNode put(String fieldName, JsonNode value)\n+    {\n+        if (value == null) { // let's not store 'raw' nulls but nodes\n+            value = nullNode();\n+        }\n+        return _put(fieldName, value);\n+    }\n+\n+    /**\n+     * Method for removing field entry from this ObjectNode.\n+     * Will return value of the field, if such field existed;\n+     * null if not.\n+     */\n+    public JsonNode remove(String fieldName)\n+    {\n+        if (_children != null) {\n+            return _children.remove(fieldName);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Method for removing specified field properties out of\n+     * this ObjectNode.\n+     * \n+     * @param fieldNames Names of fields to remove\n+     * \n+     * @return This ObjectNode after removing entries\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectNode remove(Collection<String> fieldNames)\n+    {\n+        if (_children != null) {\n+            for (String fieldName : fieldNames) {\n+                _children.remove(fieldName);\n+            }\n+        }\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for removing all field properties, such that this\n+     * ObjectNode will contain no properties after call.\n+     */\n+    @Override\n+    public ObjectNode removeAll()\n+    {\n+        _children = null;\n+        return this;\n+    }\n+\n+    /**\n+     * Method for adding given properties to this object node, overriding\n+     * any existing values for those properties.\n+     * \n+     * @param properties Properties to add\n+     * \n+     * @return This node (to allow chaining)\n+     * \n+     * @since 1.3\n+     */\n+    public JsonNode putAll(Map<String,JsonNode> properties)\n+    {\n+        if (_children == null) {\n+            _children = new LinkedHashMap<String, JsonNode>(properties);\n+        } else {\n+            for (Map.Entry<String, JsonNode> en : properties.entrySet()) {\n+                JsonNode n = en.getValue();\n+                if (n == null) {\n+                    n = nullNode();\n+                }\n+                _children.put(en.getKey(), n);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for adding all properties of the given Object, overriding\n+     * any existing values for those properties.\n+     * \n+     * @param other Object of which properties to add to this object\n+     * \n+     * @return This node (to allow chaining)\n+     * \n+     * @since 1.3\n+     */\n+    public JsonNode putAll(ObjectNode other)\n+    {\n+        int len = other.size();\n+        if (len > 0) {\n+            if (_children == null) {\n+                _children = new LinkedHashMap<String, JsonNode>(len);\n+            }\n+            other.putContentsTo(_children);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for removing all field properties out of this ObjectNode\n+     * <b>except</b> for ones specified in argument.\n+     * \n+     * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n+     * \n+     * @return This ObjectNode (to allow call chaining)\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectNode retain(Collection<String> fieldNames)\n+    {\n+        if (_children != null) {\n+            Iterator<Map.Entry<String,JsonNode>> entries = _children.entrySet().iterator();\n+            while (entries.hasNext()) {\n+                Map.Entry<String, JsonNode> entry = entries.next();\n+                if (!fieldNames.contains(entry.getKey())) {\n+                    entries.remove();\n+                }\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for removing all field properties out of this ObjectNode\n+     * <b>except</b> for ones specified in argument.\n+     * \n+     * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n+     * \n+     * @return This ObjectNode (to allow call chaining)\n+     * \n+     * @since 1.6\n+     */\n+    public ObjectNode retain(String... fieldNames) {\n+        return retain(Arrays.asList(fieldNames));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended ObjectNode API, mutators, typed\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that will construct an ArrayNode and add it as a\n+     * field of this ObjectNode, replacing old value, if any.\n+     *\n+     * @return Newly constructed ArrayNode (NOT the old value,\n+     *   which could be of any type)\n+     */\n+    public ArrayNode putArray(String fieldName)\n+    {\n+        ArrayNode n  = arrayNode();\n+        _put(fieldName, n);\n+        return n;\n+    }\n+\n+    /**\n+     * Method that will construct an ObjectNode and add it as a\n+     * field of this ObjectNode, replacing old value, if any.\n+     *\n+     * @return Newly constructed ObjectNode (NOT the old value,\n+     *   which could be of any type)\n+     */\n+    public ObjectNode putObject(String fieldName)\n+    {\n+        ObjectNode n  = objectNode();\n+        _put(fieldName, n);\n+        return n;\n+    }\n+\n+    public void putPOJO(String fieldName, Object pojo)\n+    {\n+        _put(fieldName, POJONode(pojo));\n+    }\n+\n+    public void putNull(String fieldName)\n+    {\n+        _put(fieldName, nullNode());\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void put(String fieldName, int v) { _put(fieldName, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void put(String fieldName, Integer value) {\n+        if (value == null) {\n+            _put(fieldName, nullNode());\n+        } else {\n+            _put(fieldName, numberNode(value.intValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void put(String fieldName, long v) { _put(fieldName, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void put(String fieldName, Long value) {\n+        if (value == null) {\n+            _put(fieldName, nullNode());\n+        } else {\n+            _put(fieldName, numberNode(value.longValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void put(String fieldName, float v) { _put(fieldName, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void put(String fieldName, Float value) {\n+        if (value == null) {\n+            _put(fieldName, nullNode());\n+        } else {\n+            _put(fieldName, numberNode(value.floatValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void put(String fieldName, double v) { _put(fieldName, numberNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void put(String fieldName, Double value) {\n+        if (value == null) {\n+            _put(fieldName, nullNode());\n+        } else {\n+            _put(fieldName, numberNode(value.doubleValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     */\n+    public void put(String fieldName, BigDecimal v) {\n+        if (v == null) {\n+            putNull(fieldName);\n+        } else {\n+            _put(fieldName, numberNode(v));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified String value.\n+     */\n+    public void put(String fieldName, String v) {\n+        if (v == null) {\n+            putNull(fieldName);\n+        } else {\n+            _put(fieldName, textNode(v));\n+        }\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified String value.\n+     */\n+    public void put(String fieldName, boolean v) { _put(fieldName, booleanNode(v)); }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @since 1.9\n+     */\n+    public void put(String fieldName, Boolean value) {\n+        if (value == null) {\n+            _put(fieldName, nullNode());\n+        } else {\n+            _put(fieldName, booleanNode(value.booleanValue()));\n+        }\n+    }\n+    \n+    /**\n+     * Method for setting value of a field to specified binary value\n+     */\n+    public void put(String fieldName, byte[] v) {\n+        if (v == null) {\n+            _put(fieldName, nullNode());\n+        } else {\n+            _put(fieldName, binaryNode(v));\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Package methods (for other node classes to use)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * @since 1.6\n+     */\n+    protected void putContentsTo(Map<String,JsonNode> dst)\n+    {\n+        if (_children != null) {\n+            for (Map.Entry<String,JsonNode> en : _children.entrySet()) {\n+                dst.put(en.getKey(), en.getValue());\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) {\n+            return false;\n+        }\n+        ObjectNode other = (ObjectNode) o;\n+        if (other.size() != size()) {\n+            return false;\n+        }\n+        if (_children != null) {\n+            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+                String key = en.getKey();\n+                JsonNode value = en.getValue();\n+\n+                JsonNode otherValue = other.get(key);\n+\n+                if (otherValue == null || !otherValue.equals(value)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        return (_children == null) ? -1 : _children.hashCode();\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder(32 + (size() << 4));\n+        sb.append(\"{\");\n+        if (_children != null) {\n+            int count = 0;\n+            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+                if (count > 0) {\n+                    sb.append(\",\");\n+                }\n+                ++count;\n+                TextNode.appendQuoted(sb, en.getKey());\n+                sb.append(':');\n+                sb.append(en.getValue().toString());\n+            }\n+        }\n+        sb.append(\"}\");\n+        return sb.toString();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    private final JsonNode _put(String fieldName, JsonNode value)\n+    {\n+        if (_children == null) {\n+            _children = new LinkedHashMap<String, JsonNode>();\n+        }\n+        return _children.put(fieldName, value);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * For efficiency, let's share the \"no fields\" iterator...\n+     */\n+    protected static class NoFieldsIterator\n+        implements Iterator<Map.Entry<String, JsonNode>>\n+    {\n+        final static NoFieldsIterator instance = new NoFieldsIterator();\n+\n+        private NoFieldsIterator() { }\n+\n+        @Override\n+        public boolean hasNext() { return false; }\n+        @Override\n+        public Map.Entry<String,JsonNode> next() { throw new NoSuchElementException(); }\n+\n+        @Override\n+        public void remove() { // or IllegalOperationException?\n+            throw new IllegalStateException();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/POJONode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Value node that contains a wrapped POJO, to be serialized as\n+ * a JSON constructed through data mapping (usually done by\n+ * calling {@link com.fasterxml.jackson.databind.ObjectMapper}).\n+ */\n+public final class POJONode\n+    extends ValueNode\n+{\n+    protected final Object _value;\n+\n+    public POJONode(Object v) { _value = v; }\n+\n+    /*\n+    /**********************************************************\n+    /* Base class overrides\n+    /**********************************************************\n+     */\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_EMBEDDED_OBJECT; }\n+\n+    @Override\n+    public boolean isPojo() { return true; }\n+\n+    /* \n+    /**********************************************************\n+    /* General type coercions\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String asText() {\n+        return (_value == null) ? \"null\" : _value.toString();\n+    }\n+\n+    @Override\n+    public boolean asBoolean(boolean defaultValue)\n+    {\n+        if (_value != null && _value instanceof Boolean) {\n+            return ((Boolean) _value).booleanValue();\n+        }\n+        return defaultValue;\n+    }\n+    \n+    @Override\n+    public int asInt(int defaultValue)\n+    {\n+        if (_value instanceof Number) {\n+            return ((Number) _value).intValue();\n+        }\n+        return defaultValue;\n+    }\n+\n+    @Override\n+    public long asLong(long defaultValue)\n+    {\n+        if (_value instanceof Number) {\n+            return ((Number) _value).longValue();\n+        }\n+        return defaultValue;\n+    }\n+    \n+    @Override\n+    public double asDouble(double defaultValue)\n+    {\n+        if (_value instanceof Number) {\n+            return ((Number) _value).doubleValue();\n+        }\n+        return defaultValue;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, serialization\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_value == null) {\n+            jg.writeNull();\n+        } else {\n+            jg.writeObject(_value);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to access the POJO this node wraps.\n+     */\n+    public Object getPojo() { return _value; }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden standard methods\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        POJONode other = (POJONode) o;\n+        if (_value == null) {\n+            return other._value == null;\n+        }\n+        return _value.equals(other._value);\n+    }\n+\n+    @Override\n+    public int hashCode() { return _value.hashCode(); }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return String.valueOf(_value);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/TextNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.CharTypes;\n+import com.fasterxml.jackson.core.io.NumberInput;\n+import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Value node that contains a text value.\n+ */\n+public final class TextNode\n+    extends ValueNode\n+{\n+    final static int INT_SPACE = ' ';\n+\n+    final static TextNode EMPTY_STRING_NODE = new TextNode(\"\");\n+\n+    final String _value;\n+\n+    public TextNode(String v) { _value = v; }\n+\n+    /**\n+     * Factory method that should be used to construct instances.\n+     * For some common cases, can reuse canonical instances: currently\n+     * this is the case for empty Strings, in future possible for\n+     * others as well. If null is passed, will return null.\n+     *\n+     * @return Resulting {@link TextNode} object, if <b>v</b>\n+     *   is NOT null; null if it is.\n+     */\n+    public static TextNode valueOf(String v)\n+    {\n+        if (v == null) {\n+            return null;\n+        }\n+        if (v.length() == 0) {\n+            return EMPTY_STRING_NODE;\n+        }\n+        return new TextNode(v);\n+    }\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_STRING; }\n+\n+    /**\n+     * Yes indeed it is textual\n+     */\n+    @Override\n+    public boolean isTextual() { return true; }\n+\n+    @Override\n+    public String getTextValue() {\n+        return _value;\n+    }\n+\n+    /**\n+     * Method for accessing textual contents assuming they were\n+     * base64 encoded; if so, they are decoded and resulting binary\n+     * data is returned.\n+     */\n+    public byte[] getBinaryValue(Base64Variant b64variant)\n+        throws IOException\n+    {\n+        ByteArrayBuilder builder = new ByteArrayBuilder(100);\n+        final String str = _value;\n+        int ptr = 0;\n+        int len = str.length();\n+\n+        main_loop:\n+        while (ptr < len) {\n+            // first, we'll skip preceding white space, if any\n+            char ch;\n+            do {\n+                ch = str.charAt(ptr++);\n+                if (ptr >= len) {\n+                    break main_loop;\n+                }\n+            } while (ch <= INT_SPACE);\n+            int bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(b64variant, ch, 0);\n+            }\n+            int decodedData = bits;\n+            // then second base64 char; can't get padding yet, nor ws\n+            if (ptr >= len) {\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(b64variant, ch, 1);\n+            }\n+            decodedData = (decodedData << 6) | bits;\n+            // third base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                // but as per [JACKSON-631] can be end-of-input, iff not using padding\n+                if (!b64variant.usesPadding()) {\n+                    // Got 12 bits, only need 8, need to shift\n+                    decodedData >>= 4;\n+                    builder.append(decodedData);\n+                    break;\n+                }\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+\n+            // First branch: can get padding (-> 1 byte)\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(b64variant, ch, 2);\n+                }\n+                // Ok, must get padding\n+                if (ptr >= len) {\n+                    _reportBase64EOF();\n+                }\n+                ch = str.charAt(ptr++);\n+                if (!b64variant.usesPaddingChar(ch)) {\n+                    _reportInvalidBase64(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n+                }\n+                // Got 12 bits, only need 8, need to shift\n+                decodedData >>= 4;\n+                builder.append(decodedData);\n+                continue;\n+            }\n+            // Nope, 2 or 3 bytes\n+            decodedData = (decodedData << 6) | bits;\n+            // fourth and last base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                // but as per [JACKSON-631] can be end-of-input, iff not using padding\n+                if (!b64variant.usesPadding()) {\n+                    decodedData >>= 2;\n+                    builder.appendTwoBytes(decodedData);\n+                    break;\n+                }\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(b64variant, ch, 3);\n+                }\n+                decodedData >>= 2;\n+                builder.appendTwoBytes(decodedData);\n+            } else {\n+                // otherwise, our triple is now complete\n+                decodedData = (decodedData << 6) | bits;\n+                builder.appendThreeBytes(decodedData);\n+            }\n+        }\n+        return builder.toByteArray();\n+    }\n+\n+    @Override\n+    public byte[] getBinaryValue() throws IOException\n+    {\n+        return getBinaryValue(Base64Variants.getDefaultVariant());\n+    }\n+    \n+    /* \n+    /**********************************************************\n+    /* General type coercions\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String asText() {\n+        return _value;\n+    }\n+\n+    // note: neither fast nor elegant, but these work for now:\n+\n+    @Override\n+    public boolean asBoolean(boolean defaultValue) {\n+        if (_value != null) {\n+            if (\"true\".equals(_value.trim())) {\n+                return true;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+    \n+    @Override\n+    public int asInt(int defaultValue) {\n+        return NumberInput.parseAsInt(_value, defaultValue);\n+    }\n+\n+    @Override\n+    public long asLong(long defaultValue) {\n+        return NumberInput.parseAsLong(_value, defaultValue);\n+    }\n+    \n+    @Override\n+    public double asDouble(double defaultValue) {\n+        return NumberInput.parseAsDouble(_value, defaultValue);\n+    }\n+    \n+    /* \n+    /**********************************************************\n+    /* Serialization\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        if (_value == null) {\n+            jg.writeNull();\n+        } else {\n+            jg.writeString(_value);\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden standard methods\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return ((TextNode) o)._value.equals(_value);\n+    }\n+    \n+    @Override\n+    public int hashCode() { return _value.hashCode(); }\n+\n+    /**\n+     * Different from other values, Strings need quoting\n+     */\n+    @Override\n+    public String toString()\n+    {\n+        int len = _value.length();\n+        len = len + 2 + (len >> 4);\n+        StringBuilder sb = new StringBuilder(len);\n+        appendQuoted(sb, _value);\n+        return sb.toString();\n+    }\n+\n+    protected static void appendQuoted(StringBuilder sb, String content)\n+    {\n+        sb.append('\"');\n+        CharTypes.appendQuoted(sb, content);\n+        sb.append('\"');\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex)\n+        throws JsonParseException\n+    {\n+        _reportInvalidBase64(b64variant, ch, bindex, null);\n+    }\n+\n+    /**\n+     * @param bindex Relative index within base64 character unit; between 0\n+     *   and 3 (as unit has exactly 4 characters)\n+     */\n+    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg)\n+        throws JsonParseException\n+    {\n+        String base;\n+        if (ch <= INT_SPACE) {\n+            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n+        } else if (b64variant.usesPaddingChar(ch)) {\n+            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n+        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n+            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n+            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        } else {\n+            base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        }\n+        if (msg != null) {\n+            base = base + \": \" + msg;\n+        }\n+        throw new JsonParseException(base, JsonLocation.NA);\n+    }\n+\n+    protected void _reportBase64EOF()\n+        throws JsonParseException\n+    {\n+        throw new JsonParseException(\"Unexpected end-of-String when base64 content\", JsonLocation.NA);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/TreeTraversingParser.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.base.ParserMinimalBase;\n+\n+/**\n+ * Facade over {@link JsonNode} that implements {@link JsonParser} to allow\n+ * accessing contents of JSON tree in alternate form (stream of tokens).\n+ * Useful when a streaming source is expected by code, such as data binding\n+ * functionality.\n+ * \n+ * @author tatu\n+ */\n+public class TreeTraversingParser extends ParserMinimalBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    protected ObjectCodec _objectCodec;\n+\n+    /**\n+     * Traversal context within tree\n+     */\n+    protected NodeCursor _nodeCursor;\n+\n+    /*\n+    /**********************************************************\n+    /* State\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Sometimes parser needs to buffer a single look-ahead token; if so,\n+     * it'll be stored here. This is currently used for handling \n+     */\n+    protected JsonToken _nextToken;\n+\n+    /**\n+     * Flag needed to handle recursion into contents of child\n+     * Array/Object nodes.\n+     */\n+    protected boolean _startContainer;\n+    \n+    /**\n+     * Flag that indicates whether parser is closed or not. Gets\n+     * set when parser is either closed by explicit call\n+     * ({@link #close}) or when end-of-input is reached.\n+     */\n+    protected boolean _closed;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public TreeTraversingParser(JsonNode n) { this(n, null); }\n+\n+    public TreeTraversingParser(JsonNode n, ObjectCodec codec)\n+    {\n+        super(0);\n+        _objectCodec = codec;\n+        if (n.isArray()) {\n+            _nextToken = JsonToken.START_ARRAY;\n+            _nodeCursor = new NodeCursor.Array(n, null);\n+        } else if (n.isObject()) {\n+            _nextToken = JsonToken.START_OBJECT;\n+            _nodeCursor = new NodeCursor.Object(n, null);\n+        } else { // value node\n+            _nodeCursor = new NodeCursor.RootValue(n, null);\n+        }\n+    }\n+\n+    @Override\n+    public void setCodec(ObjectCodec c) {\n+        _objectCodec = c;\n+    }\n+\n+    @Override\n+    public ObjectCodec getCodec() {\n+        return _objectCodec;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Closeable implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void close() throws IOException\n+    {\n+        if (!_closed) {\n+            _closed = true;\n+            _nodeCursor = null;\n+            _currToken = null;\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, traversal\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public JsonToken nextToken() throws IOException, JsonParseException\n+    {\n+        if (_nextToken != null) {\n+            _currToken = _nextToken;\n+            _nextToken = null;\n+            return _currToken;\n+        }\n+        // are we to descend to a container child?\n+        if (_startContainer) {\n+            _startContainer = false;\n+            // minor optimization: empty containers can be skipped\n+            if (!_nodeCursor.currentHasChildren()) {\n+                _currToken = (_currToken == JsonToken.START_OBJECT) ?\n+                    JsonToken.END_OBJECT : JsonToken.END_ARRAY;\n+                return _currToken;\n+            }\n+            _nodeCursor = _nodeCursor.iterateChildren();\n+            _currToken = _nodeCursor.nextToken();\n+            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n+                _startContainer = true;\n+            }\n+            return _currToken;\n+        }\n+        // No more content?\n+        if (_nodeCursor == null) {\n+            _closed = true; // if not already set\n+            return null;\n+        }\n+        // Otherwise, next entry from current cursor\n+        _currToken = _nodeCursor.nextToken();\n+        if (_currToken != null) {\n+            if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n+                _startContainer = true;\n+            }\n+            return _currToken;\n+        }\n+        // null means no more children; need to return end marker\n+        _currToken = _nodeCursor.endToken();\n+        _nodeCursor = _nodeCursor.getParent();\n+        return _currToken;\n+    }\n+    \n+    // default works well here:\n+    //public JsonToken nextValue() throws IOException, JsonParseException\n+\n+    @Override\n+    public JsonParser skipChildren() throws IOException, JsonParseException\n+    {\n+        if (_currToken == JsonToken.START_OBJECT) {\n+            _startContainer = false;\n+            _currToken = JsonToken.END_OBJECT;\n+        } else if (_currToken == JsonToken.START_ARRAY) {\n+            _startContainer = false;\n+            _currToken = JsonToken.END_ARRAY;\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean isClosed() {\n+        return _closed;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, token accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String getCurrentName() {\n+        return (_nodeCursor == null) ? null : _nodeCursor.getCurrentName();\n+    }\n+\n+    @Override\n+    public JsonStreamContext getParsingContext() {\n+        return _nodeCursor;\n+    }\n+\n+    @Override\n+    public JsonLocation getTokenLocation() {\n+        return JsonLocation.NA;\n+    }\n+\n+    @Override\n+    public JsonLocation getCurrentLocation() {\n+        return JsonLocation.NA;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to textual content\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String getText()\n+    {\n+        if (_closed) {\n+            return null;\n+        }\n+        // need to separate handling a bit...\n+        switch (_currToken) {\n+        case FIELD_NAME:\n+            return _nodeCursor.getCurrentName();\n+        case VALUE_STRING:\n+            return currentNode().getTextValue();\n+        case VALUE_NUMBER_INT:\n+        case VALUE_NUMBER_FLOAT:\n+            return String.valueOf(currentNode().getNumberValue());\n+        case VALUE_EMBEDDED_OBJECT:\n+            JsonNode n = currentNode();\n+            if (n != null && n.isBinary()) {\n+                // this will convert it to base64\n+                return n.asText();\n+            }\n+        }\n+\n+        return (_currToken == null) ? null : _currToken.asString();\n+    }\n+\n+    @Override\n+    public char[] getTextCharacters() throws IOException, JsonParseException {\n+        return getText().toCharArray();\n+    }\n+\n+    @Override\n+    public int getTextLength() throws IOException, JsonParseException {\n+        return getText().length();\n+    }\n+\n+    @Override\n+    public int getTextOffset() throws IOException, JsonParseException {\n+        return 0;\n+    }\n+\n+    @Override\n+    public boolean hasTextCharacters() {\n+        // generally we do not have efficient access as char[], hence:\n+        return false;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, typed non-text access\n+    /**********************************************************\n+     */\n+\n+    //public byte getByteValue() throws IOException, JsonParseException\n+\n+    @Override\n+    public NumberType getNumberType() throws IOException, JsonParseException {\n+        JsonNode n = currentNumericNode();\n+        return (n == null) ? null : n.getNumberType();\n+    }\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n+    {\n+        return currentNumericNode().getBigIntegerValue();\n+    }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() throws IOException, JsonParseException {\n+        return currentNumericNode().getDecimalValue();\n+    }\n+\n+    @Override\n+    public double getDoubleValue() throws IOException, JsonParseException {\n+        return currentNumericNode().getDoubleValue();\n+    }\n+\n+    @Override\n+    public float getFloatValue() throws IOException, JsonParseException {\n+        return (float) currentNumericNode().getDoubleValue();\n+    }\n+\n+    @Override\n+    public long getLongValue() throws IOException, JsonParseException {\n+        return currentNumericNode().getLongValue();\n+    }\n+\n+    @Override\n+    public int getIntValue() throws IOException, JsonParseException {\n+        return currentNumericNode().getIntValue();\n+    }\n+\n+    @Override\n+    public Number getNumberValue() throws IOException, JsonParseException {\n+        return currentNumericNode().getNumberValue();\n+    }\n+\n+    @Override\n+    public Object getEmbeddedObject()\n+    {\n+        if (!_closed) {\n+            JsonNode n = currentNode();\n+            if (n != null) {\n+                if (n.isPojo()) {\n+                    return ((POJONode) n).getPojo();\n+                }\n+                if (n.isBinary()) {\n+                    return ((BinaryNode) n).getBinaryValue();\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, typed binary (base64) access\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public byte[] getBinaryValue(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        // Multiple possibilities...\n+        JsonNode n = currentNode();\n+        if (n != null) { // binary node?\n+            byte[] data = n.getBinaryValue();\n+            // (or TextNode, which can also convert automatically!)\n+            if (data != null) {\n+                return data;\n+            }\n+            // Or maybe byte[] as POJO?\n+            if (n.isPojo()) {\n+                Object ob = ((POJONode) n).getPojo();\n+                if (ob instanceof byte[]) {\n+                    return (byte[]) ob;\n+                }\n+            }\n+        }\n+        // otherwise return null to mark we have no binary content\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    protected JsonNode currentNode() {\n+        if (_closed || _nodeCursor == null) {\n+            return null;\n+        }\n+        return _nodeCursor.currentNode();\n+    }\n+\n+    protected JsonNode currentNumericNode()\n+        throws JsonParseException\n+    {\n+        JsonNode n = currentNode();\n+        if (n == null || !n.isNumber()) {\n+            JsonToken t = (n == null) ? null : n.asToken();\n+            throw _constructError(\"Current token (\"+t+\") not numeric, can not use numeric value accessors\");\n+        }\n+        return n;\n+    }\n+\n+    @Override\n+    protected void _handleEOF() throws JsonParseException {\n+        _throwInternal(); // should never get called\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/ValueNode.java\n+package org.codehaus.jackson.node;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.TypeSerializer;\n+\n+\n+/**\n+ * This intermediate base class is used for all leaf nodes, that is,\n+ * all non-container (array or object) nodes, except for the\n+ * \"missing node\".\n+ */\n+public abstract class ValueNode\n+    extends BaseJsonNode\n+{\n+    protected ValueNode() { }\n+\n+    @Override\n+    public boolean isValueNode() { return true; }\n+\n+    @Override\n+    public abstract JsonToken asToken();\n+\n+    @Override\n+    public void serializeWithType(JsonGenerator jg, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonProcessingException\n+    {\n+        typeSer.writeTypePrefixForScalar(this, jg);\n+        serialize(jg, provider);\n+        typeSer.writeTypeSuffixForScalar(this, jg);\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Public API, path handling\n+    /**********************************************************************\n+     */\n+\n+    @Override\n+    public JsonNode path(String fieldName) { return MissingNode.getInstance(); }\n+\n+    @Override\n+    public JsonNode path(int index) { return MissingNode.getInstance(); }\n+\n+    /*\n+    /**********************************************************************\n+    /* Base impls for standard methods\n+    /**********************************************************************\n+     */\n+\n+    @Override\n+    public String toString() { return asText(); }\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/node/package-info.java\n+/**\n+ * Contains concrete {@link org.codehaus.jackson.JsonNode} implementations\n+ * Jackson uses for the Tree model.\n+ * These classes are public since concrete type will be needed\n+ * for most operations that modify node trees. For read-only access concrete\n+ * types are usually not needed.\n+ */\n+package org.codehaus.jackson.node;\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/schema/JsonSchema.java\n+package org.codehaus.jackson.schema;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonValue;\n+\n+import com.fasterxml.jackson.core.JsonNode;\n+\n+import org.codehaus.jackson.node.ObjectNode;\n+import org.codehaus.jackson.node.JsonNodeFactory;\n+\n+/**\n+ * A {@link org.codehaus.jackson.JsonNode} that represents a JSON-Schema instance.\n+ *\n+ * @author Ryan Heaton\n+ * @see <a href=\"http://json-schema.org/\">JSON Schema</a>\n+ */\n+public class JsonSchema\n+{\n+    private final ObjectNode schema;\n+\n+    /**\n+     * Main constructor for schema instances.\n+     *<p>\n+     * This is the creator constructor used by Jackson itself when\n+     * deserializing instances. It is so-called delegating creator, \n+     * meaning that its argument will be bound by Jackson before\n+     * constructor gets called.\n+     */\n+    @JsonCreator\n+    public JsonSchema(ObjectNode schema)\n+    {\n+        this.schema = schema;\n+    }\n+\n+    /**\n+     * Method for accessing root JSON object of the contained schema.\n+     *<p>\n+     * Note: this method is specified with {@link JsonValue} annotation\n+     * to represent serialization to use; same as if explicitly\n+     * serializing returned object.\n+     *\n+     * @return Root node of the schema tree\n+     */\n+    @JsonValue\n+    public ObjectNode getSchemaNode()\n+    {\n+        return schema;\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return this.schema.toString();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (!(o instanceof JsonSchema)) return false;\n+\n+        JsonSchema other = (JsonSchema) o;\n+        if (schema == null) {\n+            return other.schema == null;\n+        }\n+        return schema.equals(other.schema);\n+    }\n+\n+    /**\n+     * Get the default schema node.\n+     *\n+     * @return The default schema node.\n+     */\n+    public static JsonNode getDefaultSchemaNode()\n+    {\n+        ObjectNode objectNode = JsonNodeFactory.instance.objectNode();\n+        objectNode.put(\"type\", \"any\");\n+        // \"required\" is false by default, no need to include\n+        //objectNode.put(\"required\", false);\n+        return objectNode;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/schema/JsonSerializableSchema.java\n+package org.codehaus.jackson.schema;\n+\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Target;\n+\n+import com.fasterxml.jackson.annotation.JacksonAnnotation;\n+\n+/**\n+ * Annotation that can be used to define JSON Schema definition for\n+ * the annotated class.\n+ *<p>\n+ * Note that annotation is often not needed: for example, regular\n+ * Jackson beans that Jackson can introspect can be used without\n+ * annotations, to produce JSON schema definition.\n+ * \n+ * @author Ryan Heaton\n+ */\n+@Target(ElementType.TYPE)\n+@Retention(RetentionPolicy.RUNTIME)\n+@JacksonAnnotation\n+public @interface JsonSerializableSchema\n+{\n+    /**\n+     * The schema type for this JsonSerializable instance.\n+     * Possible values: \"string\", \"number\", \"boolean\", \"object\", \"array\", \"null\", \"any\"\n+     *\n+     * @return The schema type for this JsonSerializable instance.\n+     */\n+    String schemaType() default \"any\";\n+\n+    /**\n+     * If the schema type is \"object\", the node that defines the properties of the object.\n+     *\n+     * @return The node representing the schema properties, or \"##irrelevant\" if irrelevant.\n+     */\n+    String schemaObjectPropertiesDefinition() default \"##irrelevant\";\n+\n+    /**\n+     * If the schema type if \"array\", the node that defines the schema for the items in the array.\n+     *\n+     * @return The schema for the items in the array, or \"##irrelevant\" if irrelevant.\n+     */\n+    String schemaItemDefinition() default \"##irrelevant\";\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/schema/SchemaAware.java\n+package org.codehaus.jackson.schema;\n+\n+import com.fasterxml.jackson.core.JsonNode;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+import java.lang.reflect.Type;\n+\n+/**\n+ * Marker interface for schema-aware serializers.\n+ *\n+ * @author Ryan Heaton\n+ */\n+public interface SchemaAware\n+{\n+    /**\n+     * Get the representation of the schema to which this serializer will conform.\n+     *\n+     * @param provider The serializer provider.\n+     * @param typeHint A hint about the type.\n+     * @return <a href=\"http://json-schema.org/\">Json-schema</a> for this serializer.\n+     */\n+    JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+            throws JsonMappingException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/codehaus/jackson/schema/package-info.java\n+/**\n+ * Classes needed for JSON schema support (currently just ability\n+ * to generate schemas using serialization part of data mapping)\n+ */\n+package org.codehaus.jackson.schema;", "timestamp": 1324629095, "metainfo": ""}