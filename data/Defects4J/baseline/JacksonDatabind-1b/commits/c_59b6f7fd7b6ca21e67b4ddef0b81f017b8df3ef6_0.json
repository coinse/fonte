{"sha": "59b6f7fd7b6ca21e67b4ddef0b81f017b8df3ef6", "log": "Merge pull request #153 from fge/master  Looks good, will merge -- ObjectNode and ArrayNode: make _children final", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n public class ArrayNode\n     extends ContainerNode<ArrayNode>\n {\n-    // before 2.1, was explicitly `ArrayList`\n-    protected List<JsonNode> _children;\n+    protected final List<JsonNode> _children = new ArrayList<JsonNode>();\n \n     public ArrayNode(JsonNodeFactory nc) { super(nc); }\n \n-    protected ArrayNode(JsonNodeFactory nc, List<JsonNode> children) {\n-        super(nc);\n-        _children = children;\n-    }\n-    \n     // note: co-variant to allow caller-side type safety\n     @SuppressWarnings(\"unchecked\")\n     @Override\n      */\n     protected ArrayNode _defaultDeepCopy()\n     {\n-        if (_children == null) {\n-            return new ArrayNode(_nodeFactory);\n-        }\n         final int len = _children.size();\n-        List<JsonNode> newKids = _createList(Math.max(4, len));\n-        for (int i = 0; i < len; ++i) {\n-            newKids.add(_children.get(i).deepCopy());\n-        }\n-        return new ArrayNode(_nodeFactory, newKids);\n+        final ArrayNode ret = new ArrayNode(_nodeFactory);\n+\n+        for (JsonNode child : _children)\n+            ret._children.add(child.deepCopy());\n+\n+        return ret;\n     }\n     \n     /*\n     @Override\n     public int size()\n     {\n-        return (_children == null) ? 0 : _children.size();\n+        return _children.size();\n     }\n \n     @Override\n     public Iterator<JsonNode> elements()\n     {\n-        if (_children == null) {\n-            return EmptyIterator.instance();\n-        }\n         return _children.iterator();\n     }\n \n     @Override\n     public JsonNode get(int index)\n     {\n-        if (index >= 0 && (_children != null) && index < _children.size()) {\n+        if (index >= 0 && index < _children.size()) {\n             return _children.get(index);\n         }\n         return null;\n     @Override\n     public JsonNode path(int index)\n     {\n-        if (index >= 0 && (_children != null) && index < _children.size()) {\n+        if (index >= 0 && index < _children.size()) {\n             return _children.get(index);\n         }\n         return MissingNode.getInstance();\n         throws IOException, JsonProcessingException\n     {\n         jg.writeStartArray();\n-        if (_children != null) {\n-            for (JsonNode n : _children) {\n-                /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n-                 *   extend BaseJsonNode? Or if not, at least implement\n-                 *   JsonSerializable? Let's start with former, change if\n-                 *   we must.\n-                 */\n-                ((BaseJsonNode)n).serialize(jg, provider);\n-            }\n+        for (JsonNode n : _children) {\n+            /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n+             *   extend BaseJsonNode? Or if not, at least implement\n+             *   JsonSerializable? Let's start with former, change if\n+             *   we must.\n+             */\n+            ((BaseJsonNode)n).serialize(jg, provider);\n         }\n         jg.writeEndArray();\n     }\n         throws IOException, JsonProcessingException\n     {\n         typeSer.writeTypePrefixForArray(this, jg);\n-        if (_children != null) {\n-            for (JsonNode n : _children) {\n-                ((BaseJsonNode)n).serialize(jg, provider);\n+        for (JsonNode n : _children) {\n+            ((BaseJsonNode)n).serialize(jg, provider);\n+        }\n+        typeSer.writeTypeSuffixForArray(this, jg);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, finding value nodes\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public JsonNode findValue(String fieldName)\n+    {\n+        for (JsonNode node : _children) {\n+            JsonNode value = node.findValue(fieldName);\n+            if (value != null) {\n+                return value;\n             }\n         }\n-        typeSer.writeTypeSuffixForArray(this, jg);\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Public API, finding value nodes\n-    /**********************************************************\n-     */\n-    \n-    @Override\n-    public JsonNode findValue(String fieldName)\n-    {\n-        if (_children != null) {\n-            for (JsonNode node : _children) {\n-                JsonNode value = node.findValue(fieldName);\n-                if (value != null) {\n-                    return value;\n-                }\n+        return null;\n+    }\n+    \n+    @Override\n+    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        for (JsonNode node : _children) {\n+            foundSoFar = node.findValues(fieldName, foundSoFar);\n+        }\n+        return foundSoFar;\n+    }\n+\n+    @Override\n+    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n+    {\n+        for (JsonNode node : _children) {\n+            foundSoFar = node.findValuesAsText(fieldName, foundSoFar);\n+        }\n+        return foundSoFar;\n+    }\n+    \n+    @Override\n+    public ObjectNode findParent(String fieldName)\n+    {\n+        for (JsonNode node : _children) {\n+            JsonNode parent = node.findParent(fieldName);\n+            if (parent != null) {\n+                return (ObjectNode) parent;\n             }\n         }\n         return null;\n     }\n-    \n-    @Override\n-    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n-    {\n-        if (_children != null) {\n-            for (JsonNode node : _children) {\n-                foundSoFar = node.findValues(fieldName, foundSoFar);\n-            }\n-        }\n-        return foundSoFar;\n-    }\n-\n-    @Override\n-    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n-    {\n-        if (_children != null) {\n-            for (JsonNode node : _children) {\n-                foundSoFar = node.findValuesAsText(fieldName, foundSoFar);\n-            }\n-        }\n-        return foundSoFar;\n-    }\n-    \n-    @Override\n-    public ObjectNode findParent(String fieldName)\n-    {\n-        if (_children != null) {\n-            for (JsonNode node : _children) {\n-                JsonNode parent = node.findParent(fieldName);\n-                if (parent != null) {\n-                    return (ObjectNode) parent;\n-                }\n-            }\n-        }\n-        return null;        \n-    }\n \n     @Override\n     public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar)\n     {\n-        if (_children != null) {\n-            for (JsonNode node : _children) {\n-                foundSoFar = node.findParents(fieldName, foundSoFar);\n-            }\n+        for (JsonNode node : _children) {\n+            foundSoFar = node.findParents(fieldName, foundSoFar);\n         }\n         return foundSoFar;\n     }\n         if (value == null) { // let's not store 'raw' nulls but nodes\n             value = nullNode();\n         }\n-        return _set(index, value);\n+        if (index < 0 || index >= _children.size()) {\n+            throw new IndexOutOfBoundsException(\"Illegal index \"+ index +\", array size \"+size());\n+        }\n+        return _children.set(index, value);\n     }\n \n     /**\n      */\n     public ArrayNode addAll(ArrayNode other)\n     {\n-        int len = other.size();\n-        if (len > 0) {\n-            if (_children == null) {\n-                _children = _createList(len+2);\n-            }\n-            other.addContentsTo(_children);\n-        }\n+        _children.addAll(other._children);\n         return this;\n     }\n \n      */\n     public ArrayNode addAll(Collection<JsonNode> nodes)\n     {\n-        int len = nodes.size();\n-        if (len > 0) {\n-            if (_children == null) {\n-                _children = _createList(nodes.size());\n-            }\n-            _children.addAll(nodes);\n-        }\n+        _children.addAll(nodes);\n         return this;\n     }\n     \n      */\n     public JsonNode remove(int index)\n     {\n-        if (index >= 0 && (_children != null) && index < _children.size()) {\n+        if (index >= 0 && index < _children.size()) {\n             return _children.remove(index);\n         }\n         return null;\n     @Override\n     public ArrayNode removeAll()\n     {\n-        _children = null;\n+        _children.clear();\n         return this;\n     }\n     \n \n     protected void addContentsTo(List<JsonNode> dst)\n     {\n-        if (_children != null) {\n-            for (JsonNode n : _children) {\n-                dst.add(n);\n-            }\n-        }\n+        dst.addAll(_children);\n     }\n \n     /*\n     {\n         if (o == this) return true;\n         if (o == null) return false;\n-        if (o.getClass() != getClass() && !(o instanceof ArrayNode)) {\n+        if (!(o instanceof ArrayNode)) {\n             return false;\n         }\n-        /* This is bit convoluted, but the goal is to make it possible to\n-         * fully override equality comparison, even though it is\n-         * asymmetric (i.e. can be called on either side, but we\n-         * want behavior to match).\n-         */\n-        return _equals((ArrayNode) o);\n-    }\n-\n-    /**\n-     * Method that sub-classes should override, if equality comparison\n-     * needs additional verification beyond defaults.\n-     *\n-     * @since 2.1\n-     */\n-    protected boolean _equals(ArrayNode other)\n-    {\n-        return _stdEquals(other)\n-                &&_customEquals(other)\n-                && other._customEquals(this)\n-                ;\n-    }\n-    \n-    /**\n-     * Method that sub-classes should override, if equality comparison\n-     * needs additional verification beyond defaults.\n-     *\n-     * @since 2.1\n-     */\n-    protected boolean _customEquals(ArrayNode other) {\n-        return true;\n-    }\n-\n-    /**\n-     * Standard equality check, which may also be overridden by\n-     * sub-classes if necessary (but usually isn't).\n-     *\n-     * @since 2.1\n-     */\n-    protected final boolean _stdEquals(ArrayNode other)\n-    {\n-        if (_children == null || _children.size() == 0) {\n-            return other.size() == 0;\n-        }\n-        return other._sameChildren(_children);\n+        return _children.equals(((ArrayNode) o)._children);\n     }\n \n     @Override\n     public int hashCode()\n     {\n-        int hash;\n-        if (_children == null) {\n-            hash = 1;\n-        } else {\n-            hash = _children.size();\n-            for (JsonNode n : _children) {\n-                if (n != null) {\n-                    hash ^= n.hashCode();\n-                }\n-            }\n-        }\n-        return hash;\n+        return _children.hashCode();\n     }\n \n \n     {\n         StringBuilder sb = new StringBuilder(16 + (size() << 4));\n         sb.append('[');\n-        if (_children != null) {\n-            for (int i = 0, len = _children.size(); i < len; ++i) {\n-                if (i > 0) {\n-                    sb.append(',');\n-                }\n-                sb.append(_children.get(i).toString());\n+        for (int i = 0, len = _children.size(); i < len; ++i) {\n+            if (i > 0) {\n+                sb.append(',');\n             }\n+            sb.append(_children.get(i).toString());\n         }\n         sb.append(']');\n         return sb.toString();\n     /**********************************************************\n      */\n \n-    public JsonNode _set(int index, JsonNode value)\n-    {\n-        if (_children == null || index < 0 || index >= _children.size()) {\n-            throw new IndexOutOfBoundsException(\"Illegal index \"+index+\", array size \"+size());\n-        }\n-        return _children.set(index, value);\n-    }\n-\n     private ArrayNode _add(JsonNode node)\n     {\n-        if (_children == null) {\n-            _children = _createList();\n-        }\n         _children.add(node);\n         return this;\n     }\n \n     private ArrayNode _insert(int index, JsonNode node)\n     {\n-        if (_children == null) {\n-            _children = _createList();\n-            _children.add(node);\n-            return this;\n-        }\n         if (index < 0) {\n             _children.add(0, node);\n         } else if (index >= _children.size()) {\n         }\n         return this;\n     }\n-\n-    /**\n-     * Note: this method gets called iff <code>otherChildren</code>\n-     * is non-empty\n-     */\n-    private boolean _sameChildren(List<JsonNode> otherChildren)\n-    {\n-        int len = otherChildren.size();\n-        if (this.size() != len) { // important: call size() to handle case of null list...\n-            return false;\n-        }\n-        for (int i = 0; i < len; ++i) {\n-            if (!_children.get(i).equals(otherChildren.get(i))) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n public class ObjectNode\n     extends ContainerNode<ObjectNode>\n {\n-    // note: until 2.1, was explicitly `LinkedHashMap`\n-    protected Map<String, JsonNode> _children = null;\n+    // Note: LinkedHashMap for backwards compatibility\n+    protected final Map<String, JsonNode> _children\n+        = new LinkedHashMap<String, JsonNode>();\n \n     public ObjectNode(JsonNodeFactory nc) { super(nc); }\n \n-    protected ObjectNode(JsonNodeFactory nc, Map<String, JsonNode> children) {\n-        super(nc);\n-        _children = children;\n-    }\n-    \n     /* Question: should this delegate to `JsonNodeFactory`? It does not absolutely\n      * have to, as long as sub-types override the method but...\n      */\n      */\n     protected ObjectNode _defaultDeepCopy()\n     {\n-        if (_children == null) {\n-            return new ObjectNode(_nodeFactory);\n-        }\n         final int len = _children.size();\n-        Map<String, JsonNode> newKids = _createMap(Math.max(4, len));\n-        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n-            newKids.put(entry.getKey(), entry.getValue().deepCopy());\n-        }\n-        return new ObjectNode(_nodeFactory, newKids);\n+        final ObjectNode ret = new ObjectNode(_nodeFactory);\n+\n+        for (Map.Entry<String, JsonNode> entry : _children.entrySet())\n+            ret._children.put(entry.getKey(), entry.getValue().deepCopy());\n+\n+        return ret;\n     }\n     \n     /*\n \n     @Override\n     public int size() {\n-        return (_children == null) ? 0 : _children.size();\n+        return _children.size();\n     }\n \n     @Override\n     public Iterator<JsonNode> elements()\n     {\n-        if (_children == null) {\n-            return EmptyIterator.instance();\n-        }\n         return _children.values().iterator();\n     }\n \n     @Override\n     public JsonNode get(String fieldName)\n     {\n-        if (_children != null) {\n-            return _children.get(fieldName);\n-        }\n-        return null;\n+        return _children.get(fieldName);\n     }\n \n     @Override\n     public Iterator<String> fieldNames()\n     {\n-        if (_children == null) {\n-            return EmptyIterator.instance();\n-        }\n         return _children.keySet().iterator();\n     }\n \n     @Override\n     public JsonNode path(String fieldName)\n     {\n-        if (_children != null) {\n-            JsonNode n = _children.get(fieldName);\n-            if (n != null) {\n-                return n;\n-            }\n+        JsonNode n = _children.get(fieldName);\n+        if (n != null) {\n+            return n;\n         }\n         return MissingNode.getInstance();\n     }\n     @Override\n     public Iterator<Map.Entry<String, JsonNode>> fields()\n     {\n-        if (_children == null) {\n-            return EmptyIterator.instance();\n-        }\n         return _children.entrySet().iterator();\n     }\n \n     @Override\n     public ObjectNode with(String propertyName)\n     {\n-        if (_children == null) {\n-            _children = _createMap();\n-        } else {\n-            JsonNode n = _children.get(propertyName);\n-            if (n != null) {\n-                if (n instanceof ObjectNode) {\n-                    return (ObjectNode) n;\n-                }\n-                throw new UnsupportedOperationException(\"Property '\"+propertyName\n-                        +\"' has value that is not of type ObjectNode (but \"\n-                        +n.getClass().getName()+\")\");\n-            }\n+        JsonNode n = _children.get(propertyName);\n+        if (n != null) {\n+            if (n instanceof ObjectNode) {\n+                return (ObjectNode) n;\n+            }\n+            throw new UnsupportedOperationException(\"Property '\" + propertyName\n+                + \"' has value that is not of type ObjectNode (but \" + n\n+                .getClass().getName() + \")\");\n         }\n         ObjectNode result = objectNode();\n         _children.put(propertyName, result);\n     @Override\n     public ArrayNode withArray(String propertyName)\n     {\n-        if (_children == null) {\n-            _children = _createMap();\n-        } else {\n-            JsonNode n = _children.get(propertyName);\n-            if (n != null) {\n-                if (n instanceof ArrayNode) {\n-                    return (ArrayNode) n;\n-                }\n-                throw new UnsupportedOperationException(\"Property '\"+propertyName\n-                        +\"' has value that is not of type ArrayNode (but \"\n-                        +n.getClass().getName()+\")\");\n-            }\n+        JsonNode n = _children.get(propertyName);\n+        if (n != null) {\n+            if (n instanceof ArrayNode) {\n+                return (ArrayNode) n;\n+            }\n+            throw new UnsupportedOperationException(\"Property '\" + propertyName\n+                + \"' has value that is not of type ArrayNode (but \" + n\n+                .getClass().getName() + \")\");\n         }\n         ArrayNode result = arrayNode();\n         _children.put(propertyName, result);\n     @Override\n     public JsonNode findValue(String fieldName)\n     {\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n-                if (fieldName.equals(entry.getKey())) {\n-                    return entry.getValue();\n+        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+            if (fieldName.equals(entry.getKey())) {\n+                return entry.getValue();\n+            }\n+            JsonNode value = entry.getValue().findValue(fieldName);\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    @Override\n+    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+            if (fieldName.equals(entry.getKey())) {\n+                if (foundSoFar == null) {\n+                    foundSoFar = new ArrayList<JsonNode>();\n                 }\n-                JsonNode value = entry.getValue().findValue(fieldName);\n-                if (value != null) {\n-                    return value;\n+                foundSoFar.add(entry.getValue());\n+            } else { // only add children if parent not added\n+                foundSoFar = entry.getValue().findValues(fieldName, foundSoFar);\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+\n+    @Override\n+    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n+    {\n+        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+            if (fieldName.equals(entry.getKey())) {\n+                if (foundSoFar == null) {\n+                    foundSoFar = new ArrayList<String>();\n                 }\n+                foundSoFar.add(entry.getValue().asText());\n+            } else { // only add children if parent not added\n+                foundSoFar = entry.getValue().findValuesAsText(fieldName,\n+                    foundSoFar);\n+            }\n+        }\n+        return foundSoFar;\n+    }\n+    \n+    @Override\n+    public ObjectNode findParent(String fieldName)\n+    {\n+        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+            if (fieldName.equals(entry.getKey())) {\n+                return this;\n+            }\n+            JsonNode value = entry.getValue().findParent(fieldName);\n+            if (value != null) {\n+                return (ObjectNode) value;\n             }\n         }\n         return null;\n     }\n-    \n-    @Override\n-    public List<JsonNode> findValues(String fieldName, List<JsonNode> foundSoFar)\n-    {\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n-                if (fieldName.equals(entry.getKey())) {\n-                    if (foundSoFar == null) {\n-                        foundSoFar = new ArrayList<JsonNode>();\n-                    }\n-                    foundSoFar.add(entry.getValue());\n-                } else { // only add children if parent not added\n-                    foundSoFar = entry.getValue().findValues(fieldName, foundSoFar);\n+\n+    @Override\n+    public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar)\n+    {\n+        for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n+            if (fieldName.equals(entry.getKey())) {\n+                if (foundSoFar == null) {\n+                    foundSoFar = new ArrayList<JsonNode>();\n                 }\n-            }\n-        }\n-        return foundSoFar;\n-    }\n-\n-    @Override\n-    public List<String> findValuesAsText(String fieldName, List<String> foundSoFar)\n-    {\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n-                if (fieldName.equals(entry.getKey())) {\n-                    if (foundSoFar == null) {\n-                        foundSoFar = new ArrayList<String>();\n-                    }\n-                    foundSoFar.add(entry.getValue().asText());\n-                } else { // only add children if parent not added\n-                    foundSoFar = entry.getValue().findValuesAsText(fieldName, foundSoFar);\n-                }\n-            }\n-        }\n-        return foundSoFar;\n-    }\n-    \n-    @Override\n-    public ObjectNode findParent(String fieldName)\n-    {\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n-                if (fieldName.equals(entry.getKey())) {\n-                    return this;\n-                }\n-                JsonNode value = entry.getValue().findParent(fieldName);\n-                if (value != null) {\n-                    return (ObjectNode) value;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public List<JsonNode> findParents(String fieldName, List<JsonNode> foundSoFar)\n-    {\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> entry : _children.entrySet()) {\n-                if (fieldName.equals(entry.getKey())) {\n-                    if (foundSoFar == null) {\n-                        foundSoFar = new ArrayList<JsonNode>();\n-                    }\n-                    foundSoFar.add(this);\n-                } else { // only add children if parent not added\n-                    foundSoFar = entry.getValue().findParents(fieldName, foundSoFar);\n-                }\n+                foundSoFar.add(this);\n+            } else { // only add children if parent not added\n+                foundSoFar = entry.getValue()\n+                    .findParents(fieldName, foundSoFar);\n             }\n         }\n         return foundSoFar;\n         throws IOException, JsonProcessingException\n     {\n         jg.writeStartObject();\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n-                jg.writeFieldName(en.getKey());\n+        for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+            jg.writeFieldName(en.getKey());\n                 /* 17-Feb-2009, tatu: Can we trust that all nodes will always\n                  *   extend BaseJsonNode? Or if not, at least implement\n                  *   JsonSerializable? Let's start with former, change if\n                  *   we must.\n                  */\n-                ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n-            }\n+            ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n         }\n         jg.writeEndObject();\n     }\n         throws IOException, JsonProcessingException\n     {\n         typeSer.writeTypePrefixForObject(this, jg);\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n-                jg.writeFieldName(en.getKey());\n-                ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n-            }\n+        for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+            jg.writeFieldName(en.getKey());\n+            ((BaseJsonNode) en.getValue()).serialize(jg, provider);\n         }\n         typeSer.writeTypeSuffixForObject(this, jg);\n     }\n         if (value == null) {\n             value = nullNode();\n         }\n-        _put(fieldName, value);\n+        _children.put(fieldName, value);\n         return this;\n     }\n \n      */\n     public JsonNode setAll(Map<String,JsonNode> properties)\n     {\n-        if (_children == null) {\n-            _children = _createMap();\n-        }\n         for (Map.Entry<String, JsonNode> en : properties.entrySet()) {\n             JsonNode n = en.getValue();\n             if (n == null) {\n     {\n         int len = other.size();\n         if (len > 0) {\n-            if (_children == null) {\n-                _children = _createMap(len);\n-            }\n             other.putContentsTo(_children);\n         }\n         return this;\n         if (value == null) { // let's not store 'raw' nulls but nodes\n             value = nullNode();\n         }\n-        return _put(fieldName, value);\n+        return _children.put(fieldName, value);\n     }\n \n     /**\n      */\n     public JsonNode without(String fieldName)\n     {\n-        if (_children != null) {\n-            _children.remove(fieldName);\n-        }\n+        _children.remove(fieldName);\n         return this;\n     }\n \n      */\n     public ObjectNode without(Collection<String> fieldNames)\n     {\n-        if (_children != null) {\n-            for (String fieldName : fieldNames) {\n-                _children.remove(fieldName);\n-            }\n-        }\n+        _children.keySet().removeAll(fieldNames);\n         return this;\n     }\n     \n         if (value == null) { // let's not store 'raw' nulls but nodes\n             value = nullNode();\n         }\n-        return _put(fieldName, value);\n+        return _children.put(fieldName, value);\n     }\n     \n     /**\n      */\n     public JsonNode remove(String fieldName)\n     {\n-        if (_children != null) {\n-            return _children.remove(fieldName);\n-        }\n-        return null;\n+        return _children.remove(fieldName);\n     }\n \n     /**\n      */\n     public ObjectNode remove(Collection<String> fieldNames)\n     {\n-        if (_children != null) {\n-            for (String fieldName : fieldNames) {\n-                _children.remove(fieldName);\n-            }\n-        }\n+        _children.keySet().removeAll(fieldNames);\n         return this;\n     }\n     \n     @Override\n     public ObjectNode removeAll()\n     {\n-        _children = null;\n+        _children.clear();\n         return this;\n     }\n \n      */\n     public ObjectNode retain(Collection<String> fieldNames)\n     {\n-        if (_children != null) {\n-            Iterator<Map.Entry<String,JsonNode>> entries = _children.entrySet().iterator();\n-            while (entries.hasNext()) {\n-                Map.Entry<String, JsonNode> entry = entries.next();\n-                if (!fieldNames.contains(entry.getKey())) {\n-                    entries.remove();\n-                }\n-            }\n-        }\n+        _children.keySet().retainAll(fieldNames);\n         return this;\n     }\n \n     public ArrayNode putArray(String fieldName)\n     {\n         ArrayNode n  = arrayNode();\n-        _put(fieldName, n);\n+        _children.put(fieldName, n);\n         return n;\n     }\n \n     public ObjectNode putObject(String fieldName)\n     {\n         ObjectNode n  = objectNode();\n-        _put(fieldName, n);\n+        _children.put(fieldName, n);\n         return n;\n     }\n \n      * @return This node (to allow chaining)\n      */\n     public ObjectNode putPOJO(String fieldName, Object pojo) {\n-        _put(fieldName, POJONode(pojo));\n+        _children.put(fieldName, POJONode(pojo));\n         return this;\n     }\n \n      */\n     public ObjectNode putNull(String fieldName)\n     {\n-        _put(fieldName, nullNode());\n+        _children.put(fieldName, nullNode());\n         return this;\n     }\n \n      * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, int v) {\n-        _put(fieldName, numberNode(v));\n+        _children.put(fieldName, numberNode(v));\n         return this;\n     }\n \n      */\n     public ObjectNode put(String fieldName, Integer value) {\n         if (value == null) {\n-            _put(fieldName, nullNode());\n+            _children.put(fieldName, nullNode());\n         } else {\n-            _put(fieldName, numberNode(value.intValue()));\n+            _children.put(fieldName, numberNode(value.intValue()));\n         }\n         return this;\n     }\n      * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, long v) {\n-        _put(fieldName, numberNode(v));\n+        _children.put(fieldName, numberNode(v));\n         return this;\n     }\n \n      */\n     public ObjectNode put(String fieldName, Long value) {\n         if (value == null) {\n-            _put(fieldName, nullNode());\n+            _children.put(fieldName, nullNode());\n         } else {\n-            _put(fieldName, numberNode(value.longValue()));\n+            _children.put(fieldName, numberNode(value.longValue()));\n         }\n         return this;\n     }\n      * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, float v) {\n-        _put(fieldName, numberNode(v));\n+        _children.put(fieldName, numberNode(v));\n         return this;\n     }\n \n      */\n     public ObjectNode put(String fieldName, Float value) {\n         if (value == null) {\n-            _put(fieldName, nullNode());\n+            _children.put(fieldName, nullNode());\n         } else {\n-            _put(fieldName, numberNode(value.floatValue()));\n+            _children.put(fieldName, numberNode(value.floatValue()));\n         }\n         return this;\n     }\n      * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, double v) {\n-        _put(fieldName, numberNode(v));\n+        _children.put(fieldName, numberNode(v));\n         return this;\n     }\n \n      */\n     public ObjectNode put(String fieldName, Double value) {\n         if (value == null) {\n-            _put(fieldName, nullNode());\n+            _children.put(fieldName, nullNode());\n         } else {\n-            _put(fieldName, numberNode(value.doubleValue()));\n+            _children.put(fieldName, numberNode(value.doubleValue()));\n         }\n         return this;\n     }\n         if (v == null) {\n             putNull(fieldName);\n         } else {\n-            _put(fieldName, numberNode(v));\n+            _children.put(fieldName, numberNode(v));\n         }\n         return this;\n     }\n         if (v == null) {\n             putNull(fieldName);\n         } else {\n-            _put(fieldName, textNode(v));\n+            _children.put(fieldName, textNode(v));\n         }\n         return this;\n     }\n      * @return This node (to allow chaining)\n      */\n     public ObjectNode put(String fieldName, boolean v) {\n-        _put(fieldName, booleanNode(v));\n+        _children.put(fieldName, booleanNode(v));\n         return this;\n     }\n \n      */\n     public ObjectNode put(String fieldName, Boolean value) {\n         if (value == null) {\n-            _put(fieldName, nullNode());\n+            _children.put(fieldName, nullNode());\n         } else {\n-            _put(fieldName, booleanNode(value.booleanValue()));\n+            _children.put(fieldName, booleanNode(value.booleanValue()));\n         }\n         return this;\n     }\n      */\n     public ObjectNode put(String fieldName, byte[] v) {\n         if (v == null) {\n-            _put(fieldName, nullNode());\n+            _children.put(fieldName, nullNode());\n         } else {\n-            _put(fieldName, binaryNode(v));\n+            _children.put(fieldName, binaryNode(v));\n         }\n         return this;\n     }\n     /**********************************************************\n      */\n \n-    /**\n-     * Internal factory method for creating {@link Map} used for storing\n-     * child nodes. \n-     * Overridable by sub-classes, used when caller does not know what\n-     * optimal size would, used for example when constructing a Map when adding\n-     * the first one.\n-     * \n-     * @since 2.1\n-     */\n-    protected Map<String, JsonNode> _createMap() {\n-        return new LinkedHashMap<String, JsonNode>();\n-    }\n-    \n-    /**\n-     * Internal factory method for creating {@link Map} used for storing\n-     * child nodes. \n-     * Overridable by sub-classes, used when caller has an idea of what\n-     * optimal size should be: used when copying contents of an existing node.\n-     * \n-     * @since 2.1\n-     */\n-    protected Map<String, JsonNode> _createMap(int defaultSize) {\n-        return new LinkedHashMap<String, JsonNode>(defaultSize);\n-    }\n-    \n     /*\n     /**********************************************************\n     /* Package methods (for other node classes to use)\n      */\n     protected boolean _equals(ObjectNode other)\n     {\n-        return _stdEquals(other)\n-                &&_customEquals(other)\n-                && other._customEquals(this)\n-                ;\n-    }\n-    \n-    /**\n-     * Method that sub-classes should override, if equality comparison\n-     * needs additional verification beyond defaults.\n-     *\n-     * @since 2.1\n-     */\n-    protected boolean _customEquals(ObjectNode other) {\n-        return true;\n-    }\n-\n-    /**\n-     * Standard equality checks, which may also be overridden by\n-     * sub-classes if necessary (but usually isn't).\n-     *\n-     * @since 2.1\n-     */\n-    protected final boolean _stdEquals(ObjectNode other)\n-    {\n-        if (other.size() != size()) {\n-            return false;\n-        }\n-        if (_children != null) {\n-            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n-                String key = en.getKey();\n-                JsonNode value = en.getValue();\n-\n-                JsonNode otherValue = other.get(key);\n-\n-                if (otherValue == null || !otherValue.equals(value)) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n+        return _children.equals(other._children);\n+    }\n+    \n     @Override\n     public int hashCode()\n     {\n-        return (_children == null) ? -1 : _children.hashCode();\n+        return _children.hashCode();\n     }\n \n     @Override\n     {\n         StringBuilder sb = new StringBuilder(32 + (size() << 4));\n         sb.append(\"{\");\n-        if (_children != null) {\n-            int count = 0;\n-            for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n-                if (count > 0) {\n-                    sb.append(\",\");\n-                }\n-                ++count;\n-                TextNode.appendQuoted(sb, en.getKey());\n-                sb.append(':');\n-                sb.append(en.getValue().toString());\n-            }\n+        int count = 0;\n+        for (Map.Entry<String, JsonNode> en : _children.entrySet()) {\n+            if (count > 0) {\n+                sb.append(\",\");\n+            }\n+            ++count;\n+            TextNode.appendQuoted(sb, en.getKey());\n+            sb.append(':');\n+            sb.append(en.getValue().toString());\n         }\n         sb.append(\"}\");\n         return sb.toString();\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Internal methods\n-    /**********************************************************\n-     */\n-\n-    private final JsonNode _put(String fieldName, JsonNode value)\n-    {\n-        if (_children == null) {\n-            _children = _createMap();\n-        }\n-        return _children.put(fieldName, value);\n-    }\n }", "timestamp": 1359051521, "metainfo": ""}