{"sha": "3b88a6b6d8660195b161252bdb9e2ffb1bb92736", "log": "Yet more fixes for Date handling", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.LinkedNode;\n import com.fasterxml.jackson.databind.util.ObjectBuffer;\n+import com.fasterxml.jackson.databind.util.StdDateFormat;\n \n /**\n  * Context for the process of deserialization a single root-level value.\n \n     protected DateFormat getDateFormat()\n     {\n-        if (_dateFormat == null) {\n-            // must create a clone since Formats are not thread-safe:\n-            _dateFormat = (DateFormat)_config.getDateFormat().clone();\n-        }\n-        return _dateFormat;\n+        if (_dateFormat != null) {\n+            return _dateFormat;\n+        }\n+        /* 24-Feb-2012, tatu: This is tricky: whether we should force timezone\n+         *   on DateFormat? Let's only do that if (and only if) we are using\n+         *   the default date format, but not if overridden.\n+         */\n+        DateFormat df = _config.getDateFormat();\n+        if (df.getClass() == StdDateFormat.class) {\n+            TimeZone tz = _config.getTimeZone();\n+            df = ((StdDateFormat) df).withTimeZone(tz);\n+        } else {\n+            df = (DateFormat) df.clone();\n+            /*\n+            df.setTimeZone(tz);\n+            */\n+        }\n+        _dateFormat = df;\n+        return df;\n     }\n \n     protected String determineClassName(Object instance)\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      */\n     protected final static BaseSettings DEFAULT_BASE = new BaseSettings(DEFAULT_INTROSPECTOR,\n             DEFAULT_ANNOTATION_INTROSPECTOR, STD_VISIBILITY_CHECKER, null, TypeFactory.defaultInstance(),\n-            null, StdDateFormat.instance, null, Locale.getDefault(), TimeZone.getDefault());\n+            null, StdDateFormat.instance, null,\n+            Locale.getDefault(),\n+//            TimeZone.getDefault()\n+            TimeZone.getTimeZone(\"GMT\")\n+            );\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.RootNameLookup;\n+import com.fasterxml.jackson.databind.util.StdDateFormat;\n \n /**\n  * Class that defines API used by {@link ObjectMapper} and\n         if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n             jgen.writeNumber(timestamp);\n         } else {\n-            if (_dateFormat == null) {\n-                // must create a clone since Formats are not thread-safe:\n-                _dateFormat = (DateFormat)_config.getDateFormat().clone();\n-            }\n-            jgen.writeString(_dateFormat.format(new Date(timestamp)));\n+            jgen.writeString(_dateFormat().format(new Date(timestamp)));\n         }\n     }\n \n         if (isEnabled(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS)) {\n             jgen.writeNumber(date.getTime());\n         } else {\n-            if (_dateFormat == null) {\n-                DateFormat blueprint = _config.getDateFormat();\n-                // must create a clone since Formats are not thread-safe:\n-                _dateFormat = (DateFormat)blueprint.clone();\n-            }\n-            jgen.writeString(_dateFormat.format(date));\n+            jgen.writeString(_dateFormat().format(date));\n         }\n     }\n \n         if (isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n             jgen.writeFieldName(String.valueOf(timestamp));\n         } else {\n-            if (_dateFormat == null) {\n-                DateFormat blueprint = _config.getDateFormat();\n-                // must create a clone since Formats are not thread-safe:\n-                _dateFormat = (DateFormat)blueprint.clone();\n-            }\n-            jgen.writeFieldName(_dateFormat.format(new Date(timestamp)));\n+            jgen.writeFieldName(_dateFormat().format(new Date(timestamp)));\n         }\n     }\n \n         if (isEnabled(SerializationFeature.WRITE_DATE_KEYS_AS_TIMESTAMPS)) {\n             jgen.writeFieldName(String.valueOf(date.getTime()));\n         } else {\n-            if (_dateFormat == null) {\n-                DateFormat blueprint = _config.getDateFormat();\n-                // must create a clone since Formats are not thread-safe:\n-                _dateFormat = (DateFormat)blueprint.clone();\n-            }\n-            jgen.writeFieldName(_dateFormat.format(date));\n+            jgen.writeFieldName(_dateFormat().format(date));\n         }\n     }\n     \n         }\n         return (JsonSerializer<Object>) ser;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    protected final DateFormat _dateFormat()\n+    {\n+        if (_dateFormat != null) {\n+            return _dateFormat;\n+        }\n+        /* 24-Feb-2012, tatu: This is tricky: whether we should force timezone\n+         *   on DateFormat? Let's only do that if we have not specified custom\n+         *   DateFormat.\n+         */\n+        DateFormat df = _config.getDateFormat();\n+        if (df.getClass() == StdDateFormat.class) {\n+            TimeZone tz = _config.getTimeZone();\n+            df = ((StdDateFormat) df).withTimeZone(tz);\n+        } else {\n+            df = (DateFormat) df.clone();\n+        }\n+        _dateFormat = df;\n+        return df;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n         DATE_FORMAT_STR_PLAIN\n     };\n \n+    /**\n+     * By default we use GMT for everything.\n+     */\n+    private final static TimeZone DEFAULT_TIMEZONE;\n+    static {\n+        DEFAULT_TIMEZONE = TimeZone.getTimeZone(\"GMT\");\n+    }\n+    \n     protected final static DateFormat DATE_FORMAT_RFC1123;\n \n     protected final static DateFormat DATE_FORMAT_ISO8601;\n         /* Another important thing: let's force use of GMT for\n          * baseline DataFormat objects\n          */\n-        TimeZone gmt = TimeZone.getTimeZone(\"GMT\");\n         DATE_FORMAT_RFC1123 = new SimpleDateFormat(DATE_FORMAT_STR_RFC1123);\n-        DATE_FORMAT_RFC1123.setTimeZone(gmt);\n+        DATE_FORMAT_RFC1123.setTimeZone(DEFAULT_TIMEZONE);\n         DATE_FORMAT_ISO8601 = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601);\n-        DATE_FORMAT_ISO8601.setTimeZone(gmt);\n+        DATE_FORMAT_ISO8601.setTimeZone(DEFAULT_TIMEZONE);\n         DATE_FORMAT_ISO8601_Z = new SimpleDateFormat(DATE_FORMAT_STR_ISO8601_Z);\n-        DATE_FORMAT_ISO8601_Z.setTimeZone(gmt);\n+        DATE_FORMAT_ISO8601_Z.setTimeZone(DEFAULT_TIMEZONE);\n         DATE_FORMAT_PLAIN = new SimpleDateFormat(DATE_FORMAT_STR_PLAIN);\n-        DATE_FORMAT_PLAIN.setTimeZone(gmt);\n-    }\n-\n+        DATE_FORMAT_PLAIN.setTimeZone(DEFAULT_TIMEZONE);\n+    }\n+    \n     /**\n      * A singleton instance can be used for cloning purposes.\n      */\n     public final static StdDateFormat instance = new StdDateFormat();\n-\n+    \n     /**\n      * Caller may want to explicitly override timezone to use; if so,\n      * we will have non-null value here.\n         _timezone = tz;\n     }\n \n+    public static TimeZone getDefaultTimeZone() {\n+        return DEFAULT_TIMEZONE;\n+    }\n+    \n+    /**\n+     * Method used for creating a new instance with specified timezone;\n+     * if no timezone specified, defaults to the default timezone (UTC).\n+     */\n     public StdDateFormat withTimeZone(TimeZone tz) {\n+        if (tz == null) {\n+            tz = DEFAULT_TIMEZONE;\n+        }\n         return new StdDateFormat(tz);\n     }\n     \n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestMapDeserialization.java\n \n     public void testCalendarMap() throws Exception\n     {\n-    \t Calendar c = Calendar.getInstance();\n-//    \t c.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+    \t Calendar c = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n          c.setTimeInMillis(123456000L);\n          DateFormat fmt = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss zzz\");\n     \t String JSON = \"{ \\\"\"+fmt.format(c.getTime())+\"\\\" : \\\"\\\", \\\"\"+new Date(0).getTime()+\"\\\" : null }\";\n-    \t HashMap<Calendar,String> result=  MAPPER.readValue\n+    \t HashMap<Calendar,String> result = MAPPER.readValue\n     \t            (JSON, new TypeReference<HashMap<Calendar,String>>() { });\n     \t \n     \t assertNotNull(result);\n--- a/src/test/java/com/fasterxml/jackson/databind/ext/TestCoreXMLTypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ext/TestCoreXMLTypes.java\n         XMLGregorianCalendar calOut = mapper.readValue(numStr, XMLGregorianCalendar.class);\n         assertNotNull(calOut);\n         assertEquals(timestamp, calOut.toGregorianCalendar().getTimeInMillis());\n-        \n+\n         // and then textual variant\n         mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false);\n         // this is ALMOST same as default for XMLGregorianCalendar... just need to unify Z/+0000", "timestamp": 1330106039, "metainfo": ""}