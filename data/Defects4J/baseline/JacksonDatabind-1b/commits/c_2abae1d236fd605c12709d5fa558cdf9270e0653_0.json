{"sha": "2abae1d236fd605c12709d5fa558cdf9270e0653", "log": "TypeFactory cleanup", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/ClassNameIdResolver.java\n          *    to do translation when necessary\n          */\n         if (id.indexOf('<') > 0) {\n-            JavaType t = TypeFactory.fromCanonical(id);\n-            // note: may want to try combining with specialization (esp for EnumMap)\n+            JavaType t = _typeFactory.constructFromCanonical(id);\n+            // note: may want to try combining with specialization (esp for EnumMap)?\n             return t;\n         }\n         try {\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n         return defaultInstance()._unknownType();\n     }\n \n+    /**\n+     * Static helper method that can be called to figure out type-erased\n+     * call for given JDK type. It can be called statically since type resolution\n+     * process can never change actual type-erased class; thereby static\n+     * default instance is used for determination.\n+     */\n     public static Class<?> rawClass(Type t) {\n         if (t instanceof Class<?>) {\n             return (Class<?>) t;\n         }\n-        // Can optimize bit more in future...\n+        // Shouldbe able to optimize bit more in future...\n         return defaultInstance().constructType(t).getRawClass();\n     }\n     \n+    /*\n     public static JavaType fromCanonical(String canonical) throws IllegalArgumentException {\n         return instance.constructFromCanonical(canonical);\n     }\n+    */\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/LRUMap.java\n \n /**\n  * Helper for simple bounded LRU maps used for reusing lookup values.\n- * \n- * @since 1.7\n  */\n @SuppressWarnings(\"serial\")\n public class LRUMap<K,V> extends LinkedHashMap<K,V>\n--- a/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestTypeFactory.java\n \n     /**\n      * Test for checking that canonical name handling works ok\n-     * \n-     * @since 1.5\n      */\n     public void testCanonicalNames()\n     {\n         JavaType t = tf.constructType(java.util.Calendar.class);\n         String can = t.toCanonical();\n         assertEquals(\"java.util.Calendar\", can);\n-        assertEquals(t, TypeFactory.fromCanonical(can));\n+        assertEquals(t, tf.constructFromCanonical(can));\n \n         // Generic maps and collections will default to Object.class if type-erased\n         t = tf.constructType(java.util.ArrayList.class);\n         can = t.toCanonical();\n         assertEquals(\"java.util.ArrayList<java.lang.Object>\", can);\n-        assertEquals(t, TypeFactory.fromCanonical(can));\n+        assertEquals(t, tf.constructFromCanonical(can));\n \n         t = tf.constructType(java.util.TreeMap.class);\n         can = t.toCanonical();\n         assertEquals(\"java.util.TreeMap<java.lang.Object,java.lang.Object>\", can);\n-        assertEquals(t, TypeFactory.fromCanonical(can));\n+        assertEquals(t, tf.constructFromCanonical(can));\n \n         // And then EnumMap (actual use case for us)\n         t = tf.constructMapType(EnumMap.class, EnumForCanonical.class, String.class);\n         can = t.toCanonical();\n         assertEquals(\"java.util.EnumMap<com.fasterxml.jackson.databind.type.TestTypeFactory$EnumForCanonical,java.lang.String>\",\n                 can);\n-        assertEquals(t, TypeFactory.fromCanonical(can));\n+        assertEquals(t, tf.constructFromCanonical(can));\n         \n     }\n ", "timestamp": 1325201809, "metainfo": ""}