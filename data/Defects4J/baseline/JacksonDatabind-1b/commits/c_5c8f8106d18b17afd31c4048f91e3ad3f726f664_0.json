{"sha": "5c8f8106d18b17afd31c4048f91e3ad3f726f664", "log": "Implement serialization part of [JACKSON-107]", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n     public boolean isEmpty(T value) {\n         return (value == null);\n     }\n+\n+    /**\n+     * Method that can be called to see whether this serializer instance\n+     * will use Object Id to handle cyclic references.\n+     */\n+    public boolean usesObjectId() {\n+        return false;\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n      * including caching.\n      * It is configured with {@link #_serializerFactory} to allow\n      * for constructing custom serializers.\n-     */\n-    protected SerializerProvider _serializerProvider;\n+     *<p>\n+     * Note: while serializers are only exposed {@link SerializerProvider},\n+     * mappers and readers need to access additional API defined by\n+     * {@link DefaultSerializerProvider}\n+     */\n+    protected DefaultSerializerProvider _serializerProvider;\n \n     /**\n      * Serializer factory used for constructing serializers.\n      *    {@link DeserializationContext}\n      */\n     public ObjectMapper(JsonFactory jf,\n-            SerializerProvider sp, DeserializationContext dc)\n+            DefaultSerializerProvider sp, DeserializationContext dc)\n     {\n         /* 02-Mar-2009, tatu: Important: we MUST default to using\n          *   the mapping factory, otherwise tree serialization will\n                     _subtypeResolver, _mixInAnnotations);\n         _deserializationConfig = new DeserializationConfig(DEFAULT_BASE,\n                     _subtypeResolver, _mixInAnnotations);\n-        _serializerProvider = (sp == null) ? new SerializerProvider.Impl() : sp;\n+        _serializerProvider = (sp == null) ? new DefaultSerializerProvider.Impl() : sp;\n         _deserializationContext = (dc == null) ?\n                 new DeserializationContext.Std(BeanDeserializerFactory.instance) : dc;\n \n      * Method for setting specific {@link SerializerProvider} to use\n      * for handling caching of {@link JsonSerializer} instances.\n      */\n-    public ObjectMapper setSerializerProvider(SerializerProvider p) {\n+    public ObjectMapper setSerializerProvider(DefaultSerializerProvider p) {\n         _serializerProvider = p;\n         return this;\n     }\n      * Overridable helper method used for constructing\n      * {@link SerializerProvider} to use for serialization.\n      */\n-    protected SerializerProvider _serializerProvider(SerializationConfig config) {\n+    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n         return _serializerProvider.createInstance(config, _serializerFactory);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n import com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\n import com.fasterxml.jackson.databind.cfg.DatabindVersion;\n+import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n import com.fasterxml.jackson.databind.ser.FilterProvider;\n import com.fasterxml.jackson.databind.ser.SerializerFactory;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n      */\n     protected final SerializationConfig _config;\n    \n-    protected final SerializerProvider _serializerProvider;\n+    protected final DefaultSerializerProvider _serializerProvider;\n \n     protected final SerializerFactory _serializerFactory;\n \n      * Overridable helper method used for constructing\n      * {@link SerializerProvider} to use for serialization.\n      */\n-    protected SerializerProvider _serializerProvider(SerializationConfig config) {\n+    protected DefaultSerializerProvider _serializerProvider(SerializationConfig config) {\n         return _serializerProvider.createInstance(config, _serializerFactory);\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n-import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n-import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-import com.fasterxml.jackson.databind.node.ObjectNode;\n import com.fasterxml.jackson.databind.ser.*;\n import com.fasterxml.jackson.databind.ser.impl.*;\n import com.fasterxml.jackson.databind.ser.std.NullSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdKeySerializers;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n+import com.fasterxml.jackson.databind.util.ObjectIdMap;\n import com.fasterxml.jackson.databind.util.RootNameLookup;\n \n /**\n  * Object life-cycle is such that an initial instance (\"blueprint\") is created\n  * and referenced by {@link ObjectMapper} and {@link ObjectWriter} intances;\n  * but for actual usage, a configured instance is created by using\n- * {@link #createInstance}.\n+ * a create method in sub-class\n+ * {@link com.fasterxml.jackson.databind.ser.DefaultSerializerProvider}.\n  * Only this instance can be used for actual serialization calls; blueprint\n  * object is only to be used for creating instances.\n  */\n \n     /*\n     /**********************************************************\n-    /* Configuration, caching\n+    /* Helper objects for caching\n     /**********************************************************\n      */\n     \n      */\n     final protected RootNameLookup _rootNames;\n \n+    /**\n+     * Container for Object Ids we may need.\n+     */\n+    protected ObjectIdMap _objectIds;\n+    \n     /*\n     /**********************************************************\n     /* Configuration, specialized serializers\n \n         _serializationView = config.getActiveView();\n     }\n-\n-    /**\n-     * Overridable method, used to create a non-blueprint instances from the blueprint.\n-     * This is needed to retain state during serialization.\n-     */\n-    public abstract SerializerProvider createInstance(SerializationConfig config,\n-            SerializerFactory jsf);\n     \n     /*\n     /**********************************************************\n     \n     /*\n     /**********************************************************\n-    /* Methods that ObjectMapper will call\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n-     * for serializing given value, using serializers that\n-     * this provider has access to (via caching and/or creating new serializers\n-     * as need be).\n-     */\n-    public void serializeValue(JsonGenerator jgen, Object value)\n-        throws IOException, JsonGenerationException\n-    {\n-        JsonSerializer<Object> ser;\n-        boolean wrap;\n-\n-        if (value == null) {\n-            // no type provided; must just use the default null serializer\n-            ser = getDefaultNullValueSerializer();\n-            wrap = false; // no name to use for wrapping; can't do!\n-        } else {\n-            Class<?> cls = value.getClass();\n-            // true, since we do want to cache root-level typed serializers (ditto for null property)\n-            ser = findTypedValueSerializer(cls, true, null);\n-\n-            // Ok: should we wrap result in an additional property (\"root name\")?\n-            String rootName = _config.getRootName();\n-            if (rootName == null) { // not explicitly specified\n-                // [JACKSON-163]\n-                wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n-                if (wrap) {\n-                    jgen.writeStartObject();\n-                    jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n-                }\n-            } else if (rootName.length() == 0) {\n-                wrap = false;\n-            } else { // [JACKSON-764]\n-                // empty String means explicitly disabled; non-empty that it is enabled\n-                wrap = true;\n-                jgen.writeStartObject();\n-                jgen.writeFieldName(rootName);\n-            }\n-        }\n-        try {\n-            ser.serialize(value, jgen, this);\n-            if (wrap) {\n-                jgen.writeEndObject();\n-            }\n-        } catch (IOException ioe) {\n-            /* As per [JACKSON-99], should not wrap IOException or its\n-             * sub-classes (like JsonProcessingException, JsonMappingException)\n-             */\n-            throw ioe;\n-        } catch (Exception e) {\n-            // but others are wrapped\n-            String msg = e.getMessage();\n-            if (msg == null) {\n-                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n-            }\n-            throw new JsonMappingException(msg, e);\n-        }\n-    }\n-\n-    /**\n-     * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n-     * for serializing given value (assumed to be of specified root type,\n-     * instead of runtime type of value),\n-     * using serializers that\n-     * this provider has access to (via caching and/or creating new serializers\n-     * as need be),\n-     * \n-     * @param rootType Type to use for locating serializer to use, instead of actual\n-     *    runtime type. Must be actual type, or one of its super types\n-     */\n-    public void serializeValue(JsonGenerator jgen, Object value,\n-            JavaType rootType)\n-        throws IOException, JsonGenerationException\n-    {\n-        boolean wrap;\n-\n-        JsonSerializer<Object> ser;\n-        if (value == null) {\n-            ser = getDefaultNullValueSerializer();\n-            wrap = false;\n-        } else {\n-            // Let's ensure types are compatible at this point\n-            if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n-                _reportIncompatibleRootType(value, rootType);\n-            }\n-            // root value, not reached via property:\n-            ser = findTypedValueSerializer(rootType, true, null);\n-            // [JACKSON-163]\n-            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n-            if (wrap) {\n-                jgen.writeStartObject();\n-                jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n-            }\n-        }\n-        try {\n-            ser.serialize(value, jgen, this);\n-            if (wrap) {\n-                jgen.writeEndObject();\n-            }\n-        } catch (IOException ioe) { // no wrapping for IO (and derived)\n-            throw ioe;\n-        } catch (Exception e) { // but others do need to be, to get path etc\n-            String msg = e.getMessage();\n-            if (msg == null) {\n-                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n-            }\n-            throw new JsonMappingException(msg, e);\n-        }\n-    }\n-\n-    /**\n-     * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n-     * to generate <a href=\"http://json-schema.org/\">JSON schema</a> for\n-     * given type.\n-     *\n-     * @param type The type for which to generate schema\n-     */\n-    public JsonSchema generateJsonSchema(Class<?> type)\n-        throws JsonMappingException\n-    {\n-        if (type == null) {\n-            throw new IllegalArgumentException(\"A class must be provided\");\n-        }\n-        /* no need for embedded type information for JSON schema generation (all\n-         * type information it needs is accessible via \"untyped\" serializer)\n-         */\n-        JsonSerializer<Object> ser = findValueSerializer(type, null);\n-        JsonNode schemaNode = (ser instanceof SchemaAware) ?\n-                ((SchemaAware) ser).getSchema(this, null) : \n-                JsonSchema.getDefaultSchemaNode();\n-        if (!(schemaNode instanceof ObjectNode)) {\n-            throw new IllegalArgumentException(\"Class \" + type.getName() +\n-                    \" would not be serialized as a JSON object and therefore has no schema\");\n-        }\n-        return new JsonSchema((ObjectNode) schemaNode);\n-    }\n-\n-    /**\n-     * Method that can be called to see if this serializer provider\n-     * can find a serializer for an instance of given class.\n-     *<p>\n-     * Note that no Exceptions are thrown, including unchecked ones:\n-     * implementations are to swallow exceptions if necessary.\n-     */\n-    public boolean hasSerializerFor(Class<?> cls) {\n-        return _findExplicitUntypedSerializer(cls, null) != null;\n-    }\n-    \n-    /*\n-    /**********************************************************\n     /* Access to configuration\n     /**********************************************************\n      */\n      */\n     public final FilterProvider getFilterProvider() {\n         return _config.getFilterProvider();\n+    }\n+\n+    /**\n+     * Method used to try to find the Object Id for given POJO.\n+     */\n+    public final Object findObjectId(Object pojo, AnnotatedMember idAccessor)\n+    {\n+        if (_objectIds == null) {\n+            _objectIds = new ObjectIdMap();\n+        }\n+        return _objectIds.findOrInsertId(pojo, idAccessor);\n     }\n \n     /**\n     {\n         getDefaultNullValueSerializer().serialize(null, jgen, this);\n     }\n-    \n+\n     /*\n     /********************************************************\n-    /* Access to caching details\n+    /* Helper methods\n     /********************************************************\n      */\n-\n-    /**\n-     * Method that can be used to determine how many serializers this\n-     * provider is caching currently\n-     * (if it does caching: default implementation does)\n-     * Exact count depends on what kind of serializers get cached;\n-     * default implementation caches all serializers, including ones that\n-     * are eagerly constructed (for optimal access speed)\n-     *<p> \n-     * The main use case for this method is to allow conditional flushing of\n-     * serializer cache, if certain number of entries is reached.\n-     */\n-    public int cachedSerializersCount() {\n-        return _serializerCache.size();\n-    }\n-\n-    /**\n-     * Method that will drop all serializers currently cached by this provider.\n-     * This can be used to remove memory usage (in case some serializers are\n-     * only used once or so), or to force re-construction of serializers after\n-     * configuration changes for mapper than owns the provider.\n-     */\n-    public void flushCachedSerializers() {\n-        _serializerCache.flush();\n-    }\n-\n+    \n     protected void _reportIncompatibleRootType(Object value, JavaType rootType)\n         throws IOException, JsonProcessingException\n     {\n         }\n         return (JsonSerializer<Object>) ser;\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Standard implementation used by {@link ObjectMapper}; just implements\n-     * <code>createInstance</code> method which is abstract in\n-     * {@link SerializerProvider}\n-     */\n-    public final static class Impl extends SerializerProvider\n-    {\n-        public Impl() { super(); }\n-        private Impl( SerializerProvider src,\n-                SerializationConfig config,SerializerFactory f) {\n-            super(src, config, f);\n-        }\n-\n-        @Override\n-        public Impl createInstance(SerializationConfig config, SerializerFactory jsf) {\n-            return new Impl(this, config, jsf);\n-        }\n-        \n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n             }\n             return;\n         }\n-        // For non-nulls, first: simple check for direct cycles\n-        if (value == bean) {\n-            _reportSelfReference(bean);\n-        }\n         // then find serializer to use\n         JsonSerializer<Object> ser = _serializer;\n         if (ser == null) {\n                 return;\n             }\n         }\n+        // For non-nulls: simple check for direct cycles\n+        if (value == bean) {\n+            _handleSelfReference(bean, ser);\n+        }\n         jgen.writeFieldName(_name);\n         if (_typeSerializer == null) {\n             ser.serialize(value, jgen, prov);\n         return _field.get(bean);\n     }\n \n-    protected void _reportSelfReference(Object bean)\n+    protected void _handleSelfReference(Object bean, JsonSerializer<?> ser)\n         throws JsonMappingException\n     {\n+        /* 05-Feb-2012, tatu: Usually a problem, but NOT if we are handling\n+         *    object id; this may be the case for BeanSerializers at least.\n+         */\n+        if (ser.usesObjectId()) {\n+            return;\n+        }\n         throw new JsonMappingException(\"Direct self-reference leading to cycle\");\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n     public final void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n+        if (_objectIdHandler != null) {\n+            // We may want to serialize just a reference (object id):\n+            if (_objectIdHandler.handleReference(bean, jgen, provider)) {\n+                return;\n+            }\n+        }\n         jgen.writeStartObject();\n         if (_propertyFilterId != null) {\n             serializeFieldsFiltered(bean, jgen, provider);\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/DefaultSerializerProvider.java\n+package com.fasterxml.jackson.databind.ser;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import com.fasterxml.jackson.databind.SerializationConfig;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.jsonschema.JsonSchema;\n+import com.fasterxml.jackson.databind.jsonschema.SchemaAware;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+\n+/**\n+ * Standard implementation used by {@link ObjectMapper}:\n+ * adds methods only exposed to {@link ObjectMapper},\n+ * as well as constructors.\n+ *<p>\n+ * Note that class is abstract just because it does not\n+ * define\n+ */\n+public abstract class DefaultSerializerProvider extends SerializerProvider\n+{\n+    protected DefaultSerializerProvider() { super(); }\n+\n+    protected DefaultSerializerProvider( SerializerProvider src,\n+            SerializationConfig config,SerializerFactory f) {\n+        super(src, config, f);\n+    }\n+\n+//    public abstract SerializerProviderImpl createInstance(...)\n+\n+    /*\n+    /**********************************************************\n+    /* Extends API: methods that ObjectMapper will call\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridable method, used to create a non-blueprint instances from the blueprint.\n+     * This is needed to retain state during serialization.\n+     */\n+    public abstract DefaultSerializerProvider createInstance(SerializationConfig config,\n+            SerializerFactory jsf);\n+    \n+    /**\n+     * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n+     * for serializing given value, using serializers that\n+     * this provider has access to (via caching and/or creating new serializers\n+     * as need be).\n+     */\n+    public void serializeValue(JsonGenerator jgen, Object value)\n+        throws IOException, JsonGenerationException\n+    {\n+        JsonSerializer<Object> ser;\n+        boolean wrap;\n+\n+        if (value == null) {\n+            // no type provided; must just use the default null serializer\n+            ser = getDefaultNullValueSerializer();\n+            wrap = false; // no name to use for wrapping; can't do!\n+        } else {\n+            Class<?> cls = value.getClass();\n+            // true, since we do want to cache root-level typed serializers (ditto for null property)\n+            ser = findTypedValueSerializer(cls, true, null);\n+\n+            // Ok: should we wrap result in an additional property (\"root name\")?\n+            String rootName = _config.getRootName();\n+            if (rootName == null) { // not explicitly specified\n+                // [JACKSON-163]\n+                wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n+                if (wrap) {\n+                    jgen.writeStartObject();\n+                    jgen.writeFieldName(_rootNames.findRootName(value.getClass(), _config));\n+                }\n+            } else if (rootName.length() == 0) {\n+                wrap = false;\n+            } else { // [JACKSON-764]\n+                // empty String means explicitly disabled; non-empty that it is enabled\n+                wrap = true;\n+                jgen.writeStartObject();\n+                jgen.writeFieldName(rootName);\n+            }\n+        }\n+        try {\n+            ser.serialize(value, jgen, this);\n+            if (wrap) {\n+                jgen.writeEndObject();\n+            }\n+        } catch (IOException ioe) {\n+            /* As per [JACKSON-99], should not wrap IOException or its\n+             * sub-classes (like JsonProcessingException, JsonMappingException)\n+             */\n+            throw ioe;\n+        } catch (Exception e) {\n+            // but others are wrapped\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+    }\n+\n+    /**\n+     * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n+     * for serializing given value (assumed to be of specified root type,\n+     * instead of runtime type of value),\n+     * using serializers that\n+     * this provider has access to (via caching and/or creating new serializers\n+     * as need be),\n+     * \n+     * @param rootType Type to use for locating serializer to use, instead of actual\n+     *    runtime type. Must be actual type, or one of its super types\n+     */\n+    public void serializeValue(JsonGenerator jgen, Object value,\n+            JavaType rootType)\n+        throws IOException, JsonGenerationException\n+    {\n+        boolean wrap;\n+\n+        JsonSerializer<Object> ser;\n+        if (value == null) {\n+            ser = getDefaultNullValueSerializer();\n+            wrap = false;\n+        } else {\n+            // Let's ensure types are compatible at this point\n+            if (!rootType.getRawClass().isAssignableFrom(value.getClass())) {\n+                _reportIncompatibleRootType(value, rootType);\n+            }\n+            // root value, not reached via property:\n+            ser = findTypedValueSerializer(rootType, true, null);\n+            // [JACKSON-163]\n+            wrap = _config.isEnabled(SerializationFeature.WRAP_ROOT_VALUE);\n+            if (wrap) {\n+                jgen.writeStartObject();\n+                jgen.writeFieldName(_rootNames.findRootName(rootType, _config));\n+            }\n+        }\n+        try {\n+            ser.serialize(value, jgen, this);\n+            if (wrap) {\n+                jgen.writeEndObject();\n+            }\n+        } catch (IOException ioe) { // no wrapping for IO (and derived)\n+            throw ioe;\n+        } catch (Exception e) { // but others do need to be, to get path etc\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+    }\n+\n+    /**\n+     * The method to be called by {@link ObjectMapper} and {@link ObjectWriter}\n+     * to generate <a href=\"http://json-schema.org/\">JSON schema</a> for\n+     * given type.\n+     *\n+     * @param type The type for which to generate schema\n+     */\n+    public JsonSchema generateJsonSchema(Class<?> type)\n+        throws JsonMappingException\n+    {\n+        if (type == null) {\n+            throw new IllegalArgumentException(\"A class must be provided\");\n+        }\n+        /* no need for embedded type information for JSON schema generation (all\n+         * type information it needs is accessible via \"untyped\" serializer)\n+         */\n+        JsonSerializer<Object> ser = findValueSerializer(type, null);\n+        JsonNode schemaNode = (ser instanceof SchemaAware) ?\n+                ((SchemaAware) ser).getSchema(this, null) : \n+                JsonSchema.getDefaultSchemaNode();\n+        if (!(schemaNode instanceof ObjectNode)) {\n+            throw new IllegalArgumentException(\"Class \" + type.getName() +\n+                    \" would not be serialized as a JSON object and therefore has no schema\");\n+        }\n+        return new JsonSchema((ObjectNode) schemaNode);\n+    }\n+\n+    /**\n+     * Method that can be called to see if this serializer provider\n+     * can find a serializer for an instance of given class.\n+     *<p>\n+     * Note that no Exceptions are thrown, including unchecked ones:\n+     * implementations are to swallow exceptions if necessary.\n+     */\n+    public boolean hasSerializerFor(Class<?> cls) {\n+        return _findExplicitUntypedSerializer(cls, null) != null;\n+    }\n+\n+    /*\n+    /********************************************************\n+    /* Access to caching details\n+    /********************************************************\n+     */\n+\n+    /**\n+     * Method that can be used to determine how many serializers this\n+     * provider is caching currently\n+     * (if it does caching: default implementation does)\n+     * Exact count depends on what kind of serializers get cached;\n+     * default implementation caches all serializers, including ones that\n+     * are eagerly constructed (for optimal access speed)\n+     *<p> \n+     * The main use case for this method is to allow conditional flushing of\n+     * serializer cache, if certain number of entries is reached.\n+     */\n+    public int cachedSerializersCount() {\n+        return _serializerCache.size();\n+    }\n+\n+    /**\n+     * Method that will drop all serializers currently cached by this provider.\n+     * This can be used to remove memory usage (in case some serializers are\n+     * only used once or so), or to force re-construction of serializers after\n+     * configuration changes for mapper than owns the provider.\n+     */\n+    public void flushCachedSerializers() {\n+        _serializerCache.flush();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Concrete implementation that defines factory method(s),\n+     * defined as final.\n+     */\n+    public final static class Impl extends DefaultSerializerProvider\n+    {\n+        public Impl() { super(); }\n+\n+        protected Impl( SerializerProvider src,\n+                SerializationConfig config,SerializerFactory f) {\n+            super(src, config, f);\n+        }\n+\n+        @Override\n+        public Impl createInstance(SerializationConfig config,\n+                SerializerFactory jsf) {\n+            return new Impl(this, config, jsf);\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/ObjectIdHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ObjectIdHandler.java\n package com.fasterxml.jackson.databind.ser.impl;\n \n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonGenerationException;\n+import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n \n /**\n  * Object that knows how to serialize Object Ids.\n     \n     /*\n     /**********************************************************\n-    /* API\n+    /* Serialization API\n     /**********************************************************\n      */\n+\n+    public boolean handleReference(Object pojo, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+    {\n+        Object id = provider.findObjectId(pojo, _property.getMember());\n+System.err.println(\"Handle ref for: \"+pojo+\", id = \"+id);        \n+        if (id == null) {            \n+            return false;\n+        }\n+        _serializer.serialize(id, jgen, provider);\n+        return true;\n+    }        \n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/UnwrappingBeanPropertyWriter.java\n             // can't really unwrap them...\n             return;\n         }\n-        // For non-nulls, first: simple check for direct cycles\n-        if (value == bean) {\n-            _reportSelfReference(bean);\n-        }\n         JsonSerializer<Object> ser = _serializer;\n         if (ser == null) {\n             Class<?> cls = value.getClass();\n             } else if (_suppressableValue.equals(value)) {\n                 return;\n             }\n+        }\n+        // For non-nulls, first: simple check for direct cycles\n+        if (value == bean) {\n+            _handleSelfReference(bean, ser);\n         }\n \n         // note: must verify we are using unwrapping serializer; if not, will write field name\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/BeanSerializerBase.java\n      * If this POJO can be alternatively serialized using just an object id\n      * to denote a reference to previously serialized object,\n      * this Object will handle details.\n-     */\n-    final protected ObjectIdHandler _objectIdHandler;\n+     *<p>\n+     * Note: not final since we need to get contextual instance during\n+     * resolutuon.\n+     */\n+    protected ObjectIdHandler _objectIdHandler;\n     \n     /**\n      * If using custom type ids (usually via getter, or field), this is the\n         }\n         return result;\n     }\n-    \n+\n     /*\n     /**********************************************************\n-    /* Partial JsonSerializer implementation\n-    /**********************************************************\n-     */\n-\n-    // Main serialization method left unimplemented\n-    @Override\n-    public abstract void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException;\n-\n-    // Type-info-augmented case implemented as it does not usually differ between impls\n-    @Override\n-    public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n-    {\n-        if (_typeId != null) {\n-            serializeWithCustomType(bean, jgen, provider, typeSer);\n-            return;\n-        }\n-        typeSer.writeTypePrefixForObject(bean, jgen);\n-        if (_propertyFilterId != null) {\n-            serializeFieldsFiltered(bean, jgen, provider);\n-        } else {\n-            serializeFields(bean, jgen, provider);\n-        }\n-        typeSer.writeTypeSuffixForObject(bean, jgen);\n-    }\n-\n-    private final void serializeWithCustomType(Object bean,\n-            JsonGenerator jgen, SerializerProvider provider,\n-            TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n-    {\n-        final Object typeId = _typeId.getValue(bean);\n-        String typeStr;\n-        if (typeId == null) {\n-            typeStr = \"\";\n-        } else {\n-            typeStr = (typeId instanceof String) ? (String) typeId : typeId.toString();\n-        }\n-        typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr);\n-        if (_propertyFilterId != null) {\n-            serializeFieldsFiltered(bean, jgen, provider);\n-        } else {\n-            serializeFields(bean, jgen, provider);\n-        }\n-        typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr);\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Field serialization methods\n-    /**********************************************************\n-     */\n-    \n-    protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n-        final BeanPropertyWriter[] props;\n-        if (_filteredProps != null && provider.getSerializationView() != null) {\n-            props = _filteredProps;\n-        } else {\n-            props = _props;\n-        }\n-        int i = 0;\n-        try {\n-            for (final int len = props.length; i < len; ++i) {\n-                BeanPropertyWriter prop = props[i];\n-                if (prop != null) { // can have nulls in filtered list\n-                    prop.serializeAsField(bean, jgen, provider);\n-                }\n-            }\n-            if (_anyGetterWriter != null) {\n-                _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n-            }\n-        } catch (Exception e) {\n-            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n-            wrapAndThrow(provider, e, bean, name);\n-        } catch (StackOverflowError e) {\n-            /* 04-Sep-2009, tatu: Dealing with this is tricky, since we do not\n-             *   have many stack frames to spare... just one or two; can't\n-             *   make many calls.\n-             */\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n-            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n-            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n-            throw mapE;\n-        }\n-    }\n-\n-    /**\n-     * Alternative serialization method that gets called when there is a\n-     * {@link BeanPropertyFilter} that needs to be called to determine\n-     * which properties are to be serialized (and possibly how)\n-     */\n-    protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n-    {\n-        /* note: almost verbatim copy of \"serializeFields\"; copied (instead of merged)\n-         * so that old method need not add check for existence of filter.\n-         */\n-        \n-        final BeanPropertyWriter[] props;\n-        if (_filteredProps != null && provider.getSerializationView() != null) {\n-            props = _filteredProps;\n-        } else {\n-            props = _props;\n-        }\n-        final BeanPropertyFilter filter = findFilter(provider);\n-        // better also allow missing filter actually..\n-        if (filter == null) {\n-            serializeFields(bean, jgen, provider);\n-            return;\n-        }\n-        \n-        int i = 0;\n-        try {\n-            for (final int len = props.length; i < len; ++i) {\n-                BeanPropertyWriter prop = props[i];\n-                if (prop != null) { // can have nulls in filtered list\n-                    filter.serializeAsField(bean, jgen, provider, prop);\n-                }\n-            }\n-            if (_anyGetterWriter != null) {\n-                _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n-            }\n-        } catch (Exception e) {\n-            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n-            wrapAndThrow(provider, e, bean, name);\n-        } catch (StackOverflowError e) {\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n-            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n-            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n-            throw mapE;\n-        }\n-    }\n-\n-    /**\n-     * Helper method used to locate filter that is needed, based on filter id\n-     * this serializer was constructed with.\n-     */\n-    protected BeanPropertyFilter findFilter(SerializerProvider provider)\n-        throws JsonMappingException\n-    {\n-        final Object filterId = _propertyFilterId;\n-        FilterProvider filters = provider.getFilterProvider();\n-        // Not ok to miss the provider, if a filter is declared to be needed.\n-        if (filters == null) {\n-            throw new JsonMappingException(\"Can not resolve BeanPropertyFilter with id '\"+filterId+\"'; no FilterProvider configured\");\n-        }\n-        BeanPropertyFilter filter = filters.findFilter(filterId);\n-        // But whether unknown ids are ok just depends on filter provider; if we get null that's fine\n-        return filter;\n-    }\n-    \n-    @Override\n-    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n-        throws JsonMappingException\n-    {\n-        ObjectNode o = createSchemaNode(\"object\", true);\n-        //todo: should the classname go in the title?\n-        //o.put(\"title\", _className);\n-        ObjectNode propertiesNode = o.objectNode();\n-        for (int i = 0; i < _props.length; i++) {\n-            BeanPropertyWriter prop = _props[i];\n-            JavaType propType = prop.getSerializationType();\n-            // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n-            Type hint = (propType == null) ? prop.getGenericPropertyType() : propType.getRawClass();\n-            // Maybe it already has annotated/statically configured serializer?\n-            JsonSerializer<Object> ser = prop.getSerializer();\n-            if (ser == null) { // nope\n-                Class<?> serType = prop.getRawSerializationType();\n-                if (serType == null) {\n-                    serType = prop.getPropertyType();\n-                }\n-                ser = provider.findValueSerializer(serType, prop);\n-            }\n-            JsonNode schemaNode = (ser instanceof SchemaAware) ?\n-                    ((SchemaAware) ser).getSchema(provider, hint) : \n-                    JsonSchema.getDefaultSchemaNode();\n-            propertiesNode.put(prop.getName(), schemaNode);\n-        }\n-        o.put(\"properties\", propertiesNode);\n-        return o;\n-    }\n-\n-    /*\n-    /**********************************************************\n     /* ResolvableSerializer impl\n     /**********************************************************\n      */\n \n+    /**\n+     * We need to implement {@link ResolvableSerializer} to be able to\n+     * properly handle cyclic type references.\n+     */\n     @Override\n     public void resolve(SerializerProvider provider)\n         throws JsonMappingException\n         if (_anyGetterWriter != null) {\n             _anyGetterWriter.resolve(provider);\n         }\n-    }\n-\n+        // and ObjectIdHandler resolved, if there is one\n+        if (_objectIdHandler != null) {\n+            _objectIdHandler = _objectIdHandler.createContextual(provider);\n+        }\n+    }    \n+    /*\n+    /**********************************************************\n+    /* Partial JsonSerializer implementation\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public boolean usesObjectId() {\n+        return (_objectIdHandler != null);\n+    }\n+    \n+    // Main serialization method left unimplemented\n+    @Override\n+    public abstract void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException;\n+\n+    // Type-info-augmented case implemented as it does not usually differ between impls\n+    @Override\n+    public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        if (_typeId != null) {\n+            serializeWithCustomType(bean, jgen, provider, typeSer);\n+            return;\n+        }\n+        typeSer.writeTypePrefixForObject(bean, jgen);\n+        if (_propertyFilterId != null) {\n+            serializeFieldsFiltered(bean, jgen, provider);\n+        } else {\n+            serializeFields(bean, jgen, provider);\n+        }\n+        typeSer.writeTypeSuffixForObject(bean, jgen);\n+    }\n+\n+    private final void serializeWithCustomType(Object bean,\n+            JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        final Object typeId = _typeId.getValue(bean);\n+        String typeStr;\n+        if (typeId == null) {\n+            typeStr = \"\";\n+        } else {\n+            typeStr = (typeId instanceof String) ? (String) typeId : typeId.toString();\n+        }\n+        typeSer.writeCustomTypePrefixForObject(bean, jgen, typeStr);\n+        if (_propertyFilterId != null) {\n+            serializeFieldsFiltered(bean, jgen, provider);\n+        } else {\n+            serializeFields(bean, jgen, provider);\n+        }\n+        typeSer.writeCustomTypeSuffixForObject(bean, jgen, typeStr);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Field serialization methods\n+    /**********************************************************\n+     */\n+    \n+    protected void serializeFields(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final BeanPropertyWriter[] props;\n+        if (_filteredProps != null && provider.getSerializationView() != null) {\n+            props = _filteredProps;\n+        } else {\n+            props = _props;\n+        }\n+        int i = 0;\n+        try {\n+            for (final int len = props.length; i < len; ++i) {\n+                BeanPropertyWriter prop = props[i];\n+                if (prop != null) { // can have nulls in filtered list\n+                    prop.serializeAsField(bean, jgen, provider);\n+                }\n+            }\n+            if (_anyGetterWriter != null) {\n+                _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+            }\n+        } catch (Exception e) {\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            wrapAndThrow(provider, e, bean, name);\n+        } catch (StackOverflowError e) {\n+            /* 04-Sep-2009, tatu: Dealing with this is tricky, since we do not\n+             *   have many stack frames to spare... just one or two; can't\n+             *   make many calls.\n+             */\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n+            throw mapE;\n+        }\n+    }\n+\n+    /**\n+     * Alternative serialization method that gets called when there is a\n+     * {@link BeanPropertyFilter} that needs to be called to determine\n+     * which properties are to be serialized (and possibly how)\n+     */\n+    protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        /* note: almost verbatim copy of \"serializeFields\"; copied (instead of merged)\n+         * so that old method need not add check for existence of filter.\n+         */\n+        \n+        final BeanPropertyWriter[] props;\n+        if (_filteredProps != null && provider.getSerializationView() != null) {\n+            props = _filteredProps;\n+        } else {\n+            props = _props;\n+        }\n+        final BeanPropertyFilter filter = findFilter(provider);\n+        // better also allow missing filter actually..\n+        if (filter == null) {\n+            serializeFields(bean, jgen, provider);\n+            return;\n+        }\n+        \n+        int i = 0;\n+        try {\n+            for (final int len = props.length; i < len; ++i) {\n+                BeanPropertyWriter prop = props[i];\n+                if (prop != null) { // can have nulls in filtered list\n+                    filter.serializeAsField(bean, jgen, provider, prop);\n+                }\n+            }\n+            if (_anyGetterWriter != null) {\n+                _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+            }\n+        } catch (Exception e) {\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            wrapAndThrow(provider, e, bean, name);\n+        } catch (StackOverflowError e) {\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n+            throw mapE;\n+        }\n+    }\n+\n+    /**\n+     * Helper method used to locate filter that is needed, based on filter id\n+     * this serializer was constructed with.\n+     */\n+    protected BeanPropertyFilter findFilter(SerializerProvider provider)\n+        throws JsonMappingException\n+    {\n+        final Object filterId = _propertyFilterId;\n+        FilterProvider filters = provider.getFilterProvider();\n+        // Not ok to miss the provider, if a filter is declared to be needed.\n+        if (filters == null) {\n+            throw new JsonMappingException(\"Can not resolve BeanPropertyFilter with id '\"+filterId+\"'; no FilterProvider configured\");\n+        }\n+        BeanPropertyFilter filter = filters.findFilter(filterId);\n+        // But whether unknown ids are ok just depends on filter provider; if we get null that's fine\n+        return filter;\n+    }\n+    \n+    @Override\n+    public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        throws JsonMappingException\n+    {\n+        ObjectNode o = createSchemaNode(\"object\", true);\n+        //todo: should the classname go in the title?\n+        //o.put(\"title\", _className);\n+        ObjectNode propertiesNode = o.objectNode();\n+        for (int i = 0; i < _props.length; i++) {\n+            BeanPropertyWriter prop = _props[i];\n+            JavaType propType = prop.getSerializationType();\n+            // 03-Dec-2010, tatu: SchemaAware REALLY should use JavaType, but alas it doesn't...\n+            Type hint = (propType == null) ? prop.getGenericPropertyType() : propType.getRawClass();\n+            // Maybe it already has annotated/statically configured serializer?\n+            JsonSerializer<Object> ser = prop.getSerializer();\n+            if (ser == null) { // nope\n+                Class<?> serType = prop.getRawSerializationType();\n+                if (serType == null) {\n+                    serType = prop.getPropertyType();\n+                }\n+                ser = provider.findValueSerializer(serType, prop);\n+            }\n+            JsonNode schemaNode = (ser instanceof SchemaAware) ?\n+                    ((SchemaAware) ser).getSchema(provider, hint) : \n+                    JsonSchema.getDefaultSchemaNode();\n+            propertiesNode.put(prop.getName(), schemaNode);\n+        }\n+        o.put(\"properties\", propertiesNode);\n+        return o;\n+    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ObjectIdMap.java\n+package com.fasterxml.jackson.databind.util;\n+\n+import java.util.IdentityHashMap;\n+\n+import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n+\n+/**\n+ * Map used during serialization, to keep track of referable Objects\n+ * along with lazily evaluated ids.\n+ */\n+public class ObjectIdMap\n+{\n+    public final IdentityHashMap<Object,Entry> _seenObjects;\n+    \n+    public ObjectIdMap()\n+    {\n+        _seenObjects = new IdentityHashMap<Object,Entry>(16);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* API\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that is called to figure out whether we have already\n+     * seen given POJO: if yes, we will return its id (first looking\n+     * it up as necessary); if not, we will mark down that we have\n+     * seen it but return null.\n+     */\n+    public Object findOrInsertId(Object pojo, AnnotatedMember idAccessor)\n+    {\n+        Entry entry = _seenObjects.get(pojo);\n+        if (entry == null) { // no, first time: insert, return null\n+            _seenObjects.put(pojo, new Entry());\n+            return null;\n+        }\n+        Object id = entry.id;\n+        if (id == null) {\n+            id = idAccessor.getValue(pojo);\n+            entry.id = id;\n+        }\n+        return id;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    protected final static class Entry\n+    {\n+        /**\n+         * Lazily evaluated object id to use to represent object\n+         */\n+        public Object id;\n+\n+        public Entry() { }\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestConfig.java\n     public void testProviderConfig() throws Exception   \n     {\n         ObjectMapper mapper = new ObjectMapper();\n-        assertEquals(0, mapper.getSerializerProvider().cachedSerializersCount());\n+        DefaultSerializerProvider prov = (DefaultSerializerProvider) mapper.getSerializerProvider();\n+        assertEquals(0, prov.cachedSerializersCount());\n         // and then should get one constructed for:\n         Map<String,Object> result = this.writeAndMap(mapper, new AnnoBean());\n         assertEquals(2, result.size());\n         /* 12-Jan-2010, tatus: Actually, probably more, if and when we typing\n          *   aspects are considered (depending on what is cached)\n          */\n-        int count = mapper.getSerializerProvider().cachedSerializersCount();\n+        int count = prov.cachedSerializersCount();\n         if (count < 2) {\n             fail(\"Should have at least 2 cached serializers, got \"+count);\n         }\n-        mapper.getSerializerProvider().flushCachedSerializers();\n-        assertEquals(0, mapper.getSerializerProvider().cachedSerializersCount());\n+        prov.flushCachedSerializers();\n+        assertEquals(0, prov.cachedSerializersCount());\n     }\n \n }\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestNullSerialization.java\n         public String type = null;\n     }\n     \n-    static class MyNullProvider extends SerializerProvider\n+    static class MyNullProvider extends DefaultSerializerProvider\n     {\n         public MyNullProvider() { super(); }\n         public MyNullProvider(MyNullProvider base, SerializationConfig config, SerializerFactory jsf) {\n         }\n         \n         @Override\n-        public SerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf) {\n+        public DefaultSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf) {\n             return new MyNullProvider(this, config, jsf);\n         }\n         \n \n     public void testOverriddenDefaultNulls() throws Exception\n     {\n-        SerializerProvider sp = new SerializerProvider.Impl();\n+        DefaultSerializerProvider sp = new DefaultSerializerProvider.Impl();\n         sp.setNullValueSerializer(new NullSerializer());\n         ObjectMapper m = new ObjectMapper();\n         m.setSerializerProvider(sp);\n--- a/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializerProvider.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/ser/TestSerializerProvider.java\n         ObjectMapper mapper = new ObjectMapper();\n         SerializationConfig config = mapper.getSerializationConfig();\n         SerializerFactory f = new BeanSerializerFactory(null);\n-        SerializerProvider prov = new SerializerProvider.Impl().createInstance(config, f);\n+        DefaultSerializerProvider prov = new DefaultSerializerProvider.Impl().createInstance(config, f);\n \n         // Should have working default key and null key serializers\n         assertNotNull(prov.findKeySerializer(null, null));\n--- a/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectId.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/struct/TestObjectId.java\n \n     private final ObjectMapper mapper = new ObjectMapper();\n     \n-    public void testSimpleCyclic() throws Exception\n+    public void testSimpleCyclicSerialization() throws Exception\n     {\n         Identifiable src = new Identifiable(\"x123\", 13);\n         src.next = src;\n         // First, serialize:\n         String json = mapper.writeValueAsString(src);\n         assertEquals(\"{\\\"id\\\":\\\"x123\\\",\\\"value\\\":13,\\\"next\\\":\\\"x123\\\"}\", json);\n+    }\n         \n-        // then bring bacj...\n-        Identifiable result = mapper.readValue(json, Identifiable.class);\n+    public void testSimpleCyclicDeserialization() throws Exception\n+    {\n+        // then bring back...\n+        String input = \"{\\\"id\\\":\\\"x123\\\",\\\"value\\\":13,\\\"next\\\":\\\"x123\\\"}\";\n+        Identifiable result = mapper.readValue(input, Identifiable.class);\n         assertEquals(13, result.value);\n         assertEquals(\"x123\", result.id);\n         assertSame(result, result.next);", "timestamp": 1328494248, "metainfo": ""}