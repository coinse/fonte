{"sha": "bcda191872e788d5c861ae7a508e7a8d44f9097b", "log": "Merge branch 'master' of github.com:FasterXML/jackson-databind", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/Module.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/Module.java\n package com.fasterxml.jackson.databind;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.BeanDeserializerModifier;\n import com.fasterxml.jackson.databind.deser.Deserializers;\n import com.fasterxml.jackson.databind.deser.KeyDeserializers;\n import com.fasterxml.jackson.databind.deser.ValueInstantiators;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.ser.BeanSerializerModifier;\n import com.fasterxml.jackson.databind.ser.Serializers;\n import com.fasterxml.jackson.databind.type.TypeModifier;\n     /**\n      * Interface Jackson exposes to modules for purpose of registering\n      * extended functionality.\n+     * Usually implemented by {@link ObjectMapper}, but modules should\n+     * NOT rely on this -- if they do require access to mapper instance,\n+     * they need to call {@link SetupContext#getOwner} method.\n      */\n     public static interface SetupContext\n     {\n          */\n         public <C extends ObjectCodec> C getOwner();\n \n+        public boolean isEnabled(MapperConfig.Feature f);\n+        \n         public boolean isEnabled(DeserializationConfig.Feature f);\n \n         public boolean isEnabled(SerializationConfig.Feature f);\n \n+        public boolean isEnabled(JsonFactory.Feature f);\n+        \n         public boolean isEnabled(JsonParser.Feature f);\n \n         public boolean isEnabled(JsonGenerator.Feature f);\n          */\n         public void appendAnnotationIntrospector(AnnotationIntrospector ai);\n \n+        /**\n+         * Method for registering specified classes as subtypes (of supertype(s)\n+         * they have)\n+         */\n+        public void registerSubtypes(Class<?>... subtypes);\n+\n+        /**\n+         * Method for registering specified classes as subtypes (of supertype(s)\n+         * they have), using specified type names.\n+         */\n+        public void registerSubtypes(NamedType... subtypes);\n+        \n         /**\n          * Method used for defining mix-in annotations to use for augmenting\n          * specified class or interface.\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n             }\n             \n             @Override\n+            public boolean isEnabled(MapperConfig.Feature f) {\n+                return mapper.isEnabled(f);\n+            }\n+\n+            @Override\n             public boolean isEnabled(DeserializationConfig.Feature f) {\n                 return mapper.isEnabled(f);\n             }\n-\n+            \n             @Override\n             public boolean isEnabled(SerializationConfig.Feature f) {\n                 return mapper.isEnabled(f);\n             }\n \n             @Override\n+            public boolean isEnabled(JsonFactory.Feature f) {\n+                return mapper.isEnabled(f);\n+            }\n+\n+            @Override\n             public boolean isEnabled(JsonParser.Feature f) {\n                 return mapper.isEnabled(f);\n             }\n-\n+            \n             @Override\n             public boolean isEnabled(JsonGenerator.Feature f) {\n                 return mapper.isEnabled(f);\n                 mapper._serializationConfig = mapper._serializationConfig.withAppendedAnnotationIntrospector(ai);\n             }\n \n+            @Override\n+            public void registerSubtypes(Class<?>... subtypes) {\n+                mapper.registerSubtypes(subtypes);\n+            }\n+\n+            @Override\n+            public void registerSubtypes(NamedType... subtypes) {\n+                mapper.registerSubtypes(subtypes);\n+            }\n+            \n             @Override\n             public void setMixInAnnotations(Class<?> target, Class<?> mixinSource) {\n                 mapper.addMixInAnnotations(target, mixinSource);\n      *  getJsonFactory().isEnabled(f);\n      *</pre>\n      */\n+    public boolean isEnabled(JsonFactory.Feature f) {\n+        return _jsonFactory.isEnabled(f);\n+    }\n+\n+    /**\n+     * Convenience method, equivalent to:\n+     *<pre>\n+     *  getJsonFactory().isEnabled(f);\n+     *</pre>\n+     */\n     public boolean isEnabled(JsonParser.Feature f) {\n         return _jsonFactory.isEnabled(f);\n     }\n-\n+    \n     /**\n      * Convenience method, equivalent to:\n      *<pre>\n     }\n \n     /**\n+     * Factory method for constructing {@link ObjectWriter} with\n+     * specified feature enabled (compared to settings that this\n+     * mapper instance has).\n+     */\n+    public ObjectWriter writer(SerializationConfig.Feature feature) {\n+        return new ObjectWriter(this, getSerializationConfig().with(feature));\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectWriter} with\n+     * specified features enabled (compared to settings that this\n+     * mapper instance has).\n+     */\n+    public ObjectWriter writer(SerializationConfig.Feature first,\n+            SerializationConfig.Feature... other) {\n+        return new ObjectWriter(this, getSerializationConfig().with(first, other));\n+    }\n+    \n+    /**\n      * Factory method for constructing {@link ObjectWriter} that will\n      * serialize objects using specified {@link DateFormat}; or, if\n      * null passed, using timestamp (64-bit number.\n     public ObjectReader reader() {\n         return new ObjectReader(this, getDeserializationConfig())\n             .withInjectableValues(_injectableValues);\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectReader} with\n+     * specified feature enabled (compared to settings that this\n+     * mapper instance has).\n+     * Note that the resulting instance is NOT usable as is,\n+     * without defining expected value type.\n+     */\n+    public ObjectReader reader(DeserializationConfig.Feature feature) {\n+        return new ObjectReader(this, getDeserializationConfig().with(feature));\n+    }\n+\n+    /**\n+     * Factory method for constructing {@link ObjectReader} with\n+     * specified features enabled (compared to settings that this\n+     * mapper instance has).\n+     * Note that the resulting instance is NOT usable as is,\n+     * without defining expected value type.\n+     */\n+    public ObjectReader reader(DeserializationConfig.Feature first,\n+            DeserializationConfig.Feature... other) {\n+        return new ObjectReader(this, getDeserializationConfig().with(first, other));\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n             DeserializationConfig.Feature... other)\n     {\n         DeserializationConfig newConfig = _config.with(first, other);\n+        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified feature disabled.\n+     */\n+    public ObjectReader without(DeserializationConfig.Feature feature) \n+    {\n+        DeserializationConfig newConfig = _config.without(feature);\n+        return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n+    }    \n+\n+    /**\n+     * Method for constructing a new reader instance that is configured\n+     * with specified features disabled.\n+     */\n+    public ObjectReader without(DeserializationConfig.Feature first,\n+            DeserializationConfig.Feature... other)\n+    {\n+        DeserializationConfig newConfig = _config.without(first, other);\n         return (newConfig == _config) ? this : new ObjectReader(this, newConfig);\n     }    \n     \n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n     /**\n      * When using data format that uses a schema, schema is passed\n      * to generator.\n-     * \n-     * @since 1.8\n      */\n     protected final FormatSchema _schema;\n     \n \n     /**\n      * Alternative constructor for initial instantiation.\n-     * \n-     * @since 1.7\n      */\n     protected ObjectWriter(ObjectMapper mapper, SerializationConfig config)\n     {\n \n     /**\n      * Alternative constructor for initial instantiation.\n-     * \n-     * @since 1.7\n      */\n     protected ObjectWriter(ObjectMapper mapper, SerializationConfig config,\n             FormatSchema s)\n     /* Life-cycle, fluent factories\n     /**********************************************************\n      */\n+\n+    /**\n+     * Method for constructing a new instance that is configured\n+     * with specified feature enabled.\n+     */\n+    public ObjectWriter with(SerializationConfig.Feature feature) \n+    {\n+        SerializationConfig newConfig = _config.with(feature);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }    \n+\n+    /**\n+     * Method for constructing a new instance that is configured\n+     * with specified features enabled.\n+     */\n+    public ObjectWriter with(SerializationConfig.Feature first,\n+            SerializationConfig.Feature... other)\n+    {\n+        SerializationConfig newConfig = _config.with(first, other);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }    \n+\n+    /**\n+     * Method for constructing a new instance that is configured\n+     * with specified feature enabled.\n+     */\n+    public ObjectWriter without(SerializationConfig.Feature feature) \n+    {\n+        SerializationConfig newConfig = _config.without(feature);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }    \n+\n+    /**\n+     * Method for constructing a new instance that is configured\n+     * with specified features enabled.\n+     */\n+    public ObjectWriter without(SerializationConfig.Feature first,\n+            SerializationConfig.Feature... other)\n+    {\n+        SerializationConfig newConfig = _config.without(first, other);\n+        return (newConfig == _config) ? this : new ObjectWriter(this, newConfig);\n+    }    \n     \n     /**\n      * Method that will construct a new instance that uses specified\n         return withType(_config.constructType(rootType));\n     }\n \n-    /**\n-     * @since 1.7\n-     */\n     public ObjectWriter withType(TypeReference<?> rootType)\n     {\n         return withType(_config.getTypeFactory().constructType(rootType.getType()));\n     /**\n      * Method that will construct a new instance that will use specified pretty\n      * printer (or, if null, will not do any pretty-printing)\n-     * \n-     * @since 1.6\n      */\n     public ObjectWriter withPrettyPrinter(PrettyPrinter pp)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/NamedType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/NamedType.java\n  * as external identifier\n  * \n  * @author tatu\n- * @since 1.5\n  */\n public final class NamedType\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/module/SimpleModule.java\n package com.fasterxml.jackson.databind.module;\n \n import java.util.HashMap;\n+import java.util.LinkedHashSet;\n import java.util.Map;\n \n import com.fasterxml.jackson.core.Version;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.ValueInstantiator;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n \n /**\n  * Simple {@link Module} implementation that allows registration\n      */\n     protected HashMap<Class<?>, Class<?>> _mixins = null;\n     \n+    /**\n+     * Set of subtypes to register, if any.\n+     */\n+    protected LinkedHashSet<NamedType> _subtypes = null;\n+    \n     /*\n     /**********************************************************\n     /* Life-cycle: creation\n     }\n \n     /**\n+     * Method for adding set of subtypes to be registered with\n+     * {@link ObjectMapper}\n+     * this is an alternative to using annotations in super type to indicate subtypes.\n+     */\n+    public SimpleModule registerSubtypes(Class<?> ... subtypes)\n+    {\n+        if (_subtypes == null) {\n+            _subtypes = new LinkedHashSet<NamedType>(Math.max(16, subtypes.length));\n+        }\n+        for (Class<?> subtype : subtypes) {\n+            _subtypes.add(new NamedType(subtype));\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for adding set of subtypes (along with type name to use) to be registered with\n+     * {@link ObjectMapper}\n+     * this is an alternative to using annotations in super type to indicate subtypes.\n+     */\n+    public SimpleModule registerSubtypes(NamedType ... subtypes)\n+    {\n+        if (_subtypes == null) {\n+            _subtypes = new LinkedHashSet<NamedType>(Math.max(16, subtypes.length));\n+        }\n+        for (NamedType subtype : subtypes) {\n+            _subtypes.add(subtype);\n+        }\n+        return this;\n+    }\n+    \n+    /**\n      * Method for specifying that annotations define by <code>mixinClass</code>\n      * should be \"mixed in\" with annotations that <code>targetType</code>\n      * has (as if they were directly included on it!).\n         if (_valueInstantiators != null) {\n             context.addValueInstantiators(_valueInstantiators);\n         }\n+        if (_subtypes != null && _subtypes.size() > 0) {\n+            context.registerSubtypes(_subtypes.toArray(new NamedType[_subtypes.size()]));\n+        }\n         if (_mixins != null) {\n             for (Map.Entry<Class<?>,Class<?>> entry : _mixins.entrySet()) {\n                 context.setMixInAnnotations(entry.getKey(), entry.getValue());\n--- a/src/test/java/com/fasterxml/jackson/databind/TestRootName.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestRootName.java\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializationConfig;\n \n+/**\n+ * Unit tests dealing with handling of \"root element wrapping\",\n+ * including configuration of root name to use.\n+ */\n public class TestRootName extends BaseMapTest\n {\n-    /*\n-    /**********************************************************\n-    /* Helper types\n-    /**********************************************************\n-     */\n-\n     @JsonRootName(\"rudy\")\n     static class Bean {\n         public int a = 3;\n         Bean bean = mapper.reader(Bean.class).readValue(json);\n         assertNotNull(bean);\n     }\n+\n+    public void testReconfiguringOfWrapping() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        // default: no wrapping\n+        final Bean input = new Bean();\n+        String jsonUnwrapped = mapper.writeValueAsString(input);\n+        assertEquals(\"{\\\"a\\\":3}\", jsonUnwrapped);\n+        // secondary: wrapping\n+        String jsonWrapped = mapper.writer(SerializationConfig.Feature.WRAP_ROOT_VALUE)\n+            .writeValueAsString(input);\n+        assertEquals(\"{\\\"rudy\\\":{\\\"a\\\":3}}\", jsonWrapped);\n+\n+        // and then similarly for readers:\n+        Bean result = mapper.readValue(jsonUnwrapped, Bean.class);\n+        assertNotNull(result);\n+        try { // must not have extra wrapping\n+            result = mapper.reader(Bean.class).with(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE)\n+                .readValue(jsonUnwrapped);\n+            fail(\"Should have failed\");\n+        } catch (JsonMappingException e) {\n+            verifyException(e, \"Root name 'a'\");\n+        }\n+        // except wrapping may be expected:\n+        result = mapper.reader(Bean.class).with(DeserializationConfig.Feature.UNWRAP_ROOT_VALUE)\n+            .readValue(jsonWrapped);\n+        assertNotNull(result);\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/jsontype/TestSubtypes.java\n         assertSame(SubC.class, result.value.getClass());\n     }\n \n+    // [JACKSON-748]: also works via modules\n+    public void testSubtypesViaModule() throws Exception\n+    {\n+        ObjectMapper mapper = new ObjectMapper();\n+        SimpleModule module = new SimpleModule();\n+        module.registerSubtypes(SubB.class, SubC.class, SubD.class);\n+        mapper.registerModule(module);\n+        String json = mapper.writeValueAsString(new PropertyBean(new SubC()));\n+        PropertyBean result = mapper.readValue(json, PropertyBean.class);\n+        assertSame(SubC.class, result.value.getClass());\n+    }\n+    \n     public void testSerialization() throws Exception\n     {\n         // serialization can detect type name ok without anything extra:\n--- a/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/util/TestTokenBuffer.java\n import java.io.*;\n \n import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.util.JsonParserSequence;\n \n public class TestTokenBuffer extends com.fasterxml.jackson.test.BaseTest\n {\n+    /*\n+    /**********************************************************\n+    /* Basic TokenBuffer tests\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Test writing of individual simple values\n      */\n         // then content check too:\n         verifyJsonSpecSampleDoc(tb.asParser(), true);\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Tests to verify interaction of TokenBuffer and JsonParserSequence\n+    /**********************************************************\n+     */\n+    \n+    public void testWithJsonParserSequenceSimple() throws IOException\n+    {\n+        // Let's join a TokenBuffer with JsonParser first\n+        TokenBuffer buf = new TokenBuffer(null);\n+        buf.writeStartArray();\n+        buf.writeString(\"test\");\n+        JsonParser jp = createParserUsingReader(\"[ true, null ]\");\n+        \n+        JsonParserSequence seq = JsonParserSequence.createFlattened(buf.asParser(), jp);\n+        assertEquals(2, seq.containedParsersCount());\n+\n+        assertFalse(jp.isClosed());\n+        \n+        assertFalse(seq.hasCurrentToken());\n+        assertNull(seq.getCurrentToken());\n+        assertNull(seq.getCurrentName());\n+\n+        assertToken(JsonToken.START_ARRAY, seq.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, seq.nextToken());\n+        assertEquals(\"test\", seq.getText());\n+        // end of first parser input, should switch over:\n+        \n+        assertToken(JsonToken.START_ARRAY, seq.nextToken());\n+        assertToken(JsonToken.VALUE_TRUE, seq.nextToken());\n+        assertToken(JsonToken.VALUE_NULL, seq.nextToken());\n+        assertToken(JsonToken.END_ARRAY, seq.nextToken());\n+\n+        /* 17-Jan-2009, tatus: At this point, we may or may not get an\n+         *   exception, depending on how underlying parsers work.\n+         *   Ideally this should be fixed, probably by asking underlying\n+         *   parsers to disable checking for balanced start/end markers.\n+         */\n+\n+        // for this particular case, we won't get an exception tho...\n+        assertNull(seq.nextToken());\n+        // not an error to call again...\n+        assertNull(seq.nextToken());\n+\n+        // also: original parsers should be closed\n+        assertTrue(jp.isClosed());\n+    }\n+    \n+    /**\n+     * Test to verify that TokenBuffer and JsonParserSequence work together\n+     * as expected.\n+     */\n+    public void testWithMultipleJsonParserSequences() throws IOException\n+    {\n+        TokenBuffer buf1 = new TokenBuffer(null);\n+        buf1.writeStartArray();\n+        TokenBuffer buf2 = new TokenBuffer(null);\n+        buf2.writeString(\"a\");\n+        TokenBuffer buf3 = new TokenBuffer(null);\n+        buf3.writeNumber(13);\n+        TokenBuffer buf4 = new TokenBuffer(null);\n+        buf4.writeEndArray();\n+\n+        JsonParserSequence seq1 = JsonParserSequence.createFlattened(buf1.asParser(), buf2.asParser());\n+        assertEquals(2, seq1.containedParsersCount());\n+        JsonParserSequence seq2 = JsonParserSequence.createFlattened(buf3.asParser(), buf4.asParser());\n+        assertEquals(2, seq2.containedParsersCount());\n+        JsonParserSequence combo = JsonParserSequence.createFlattened(seq1, seq2);\n+        // should flatten it to have 4 underlying parsers\n+        assertEquals(4, combo.containedParsersCount());\n+\n+        assertToken(JsonToken.START_ARRAY, combo.nextToken());\n+        assertToken(JsonToken.VALUE_STRING, combo.nextToken());\n+        assertEquals(\"a\", combo.getText());\n+        assertToken(JsonToken.VALUE_NUMBER_INT, combo.nextToken());\n+        assertEquals(13, combo.getIntValue());\n+        assertToken(JsonToken.END_ARRAY, combo.nextToken());\n+        assertNull(combo.nextToken());        \n+    }    \n }\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n      *<p>\n      * Default implementation just throws\n      * {@link UnsupportedOperationException}, to indicate that types\n-     * that do not explicitly add support do not expect to get the call.\n+     * that do not explicitly add support do not necessarily support\n+     * update-existing-value operation (esp. immutable types)\n      */\n     public T deserialize(JsonParser jp, DeserializationContext ctxt,\n                          T intoValue)\n      * \n      * @param typeDeserializer Deserializer to use for handling type information\n      */\n-    @SuppressWarnings(\"unchecked\")\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n         throws IOException, JsonProcessingException\n     {\n         // We could try calling \n-        return (T) typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n+        return typeDeserializer.deserializeTypedFromAny(jp, ctxt);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n          *   field names are (usually) interned too, hence lookups will be faster.\n          */\n         // 23-Oct-2009, tatu: should this be disabled wrt [JACKSON-180]?\n+        /*   Probably need not, given that namespace of field/method names\n+         *   is not unbounded, unlike potential JSON names.\n+         */\n         if (propName == null || propName.length() == 0) {\n             _propName = \"\";\n         } else {\n         }\n         throw new JsonMappingException(th.getMessage(), null, th);\n     }\n-    \n+\n     @Override public String toString() { return \"[property '\"+getName()+\"']\"; }\n-\n+    \n     /*\n     /**********************************************************\n     /* Implementation classes\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/JodaDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/JodaDeserializers.java\n /**\n  * Provider for deserializers that handle some basic data types\n  * for <a href=\"http://joda-time.sourceforge.net/\">Joda</a> date/time library.\n- *\n- * @since 1.4\n  */\n public class JodaDeserializers\n     implements Provider<StdDeserializer<?>>\n         }\n     }\n \n-    /**\n-     * @since 1.5\n-     */\n     public static class LocalDateDeserializer\n         extends JodaDeserializer<LocalDate>\n     {\n         }\n     }\n \n-    /**\n-     * @since 1.5\n-     */\n     public static class LocalDateTimeDeserializer\n         extends JodaDeserializer<LocalDateTime>\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/Annotated.java\n     /**\n      * Fluent factory method that will construct a new instance that uses specified\n      * instance annotations instead of currently configured ones.\n-     * \n-     * @since 1.9\n      */\n     public abstract Annotated withAnnotations(AnnotationMap fallback);\n \n     /**\n      * Fluent factory method that will construct a new instance that uses\n      * annotations from specified {@link Annotated} as fallback annotations\n-     * \n-     * @since 1.9\n      */\n     public final Annotated withFallBackAnnotationsFrom(Annotated annotated) {\n         return withAnnotations(AnnotationMap.merge(getAllAnnotations(), annotated.getAllAnnotations()));\n     /**\n      * Full generic type of the annotated element; definition\n      * of what exactly this means depends on sub-class.\n-     * \n-     * @since 1.5\n      */\n     public abstract Type getGenericType();\n \n     /**\n      * \"Raw\" type (type-erased class) of the annotated element; definition\n      * of what exactly this means depends on sub-class.\n-     * \n-     * @since 1.5\n      */\n     public abstract Class<?> getRawType();\n \n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedMember.java\n      * This is implemented for fiedlds and single-argument\n      * methods; but not for constructor parameters or\n      * other types of methods.\n-     * \n-     * @since 1.9\n      */\n     public abstract void setValue(Object pojo, Object value)\n         throws UnsupportedOperationException, IllegalArgumentException;\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedParameter.java\n {\n     /**\n      * Member (method, constructor) that this parameter belongs to\n-     * \n-     * @since 1.7\n      */\n     protected final AnnotatedWithParams _owner;\n     \n     \n     /**\n      * Index of the parameter within argument list\n-     * \n-     * @since 1.9\n      */\n     protected final int _index;\n     \n      * has this parameter as member of its argument list.\n      * \n      * @return Owner (member or creator) object of this parameter\n-     * \n-     * @since 1.9\n      */\n     public AnnotatedWithParams getOwner() { return _owner; }\n     \n      * Accessor for index of this parameter within argument list\n      * \n      * @return Index of this parameter within argument list\n-     * \n-     * @since 1.9\n      */\n     public int getIndex() { return _index; }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeDeserializer.java\n  * form for inclusion mechanism {@link As#PROPERTY}\n  * is slighty different if value is not expressed as JSON Object:\n  * and as such both type deserializer and serializer need to\n- * JSON Object form (array, object or other (== scalar)) being\n- * used.\n- * \n- * @since 1.5\n- * @author tatus\n+ * JSON Object form (array, object or other (== scalar)) being used.\n  */\n public abstract class TypeDeserializer\n {\n      * class to use in cases where type id is not\n      * accessible for some reason (either missing, or can not be\n      * resolved)\n-     * \n-     * @since 1.9\n      */\n     public abstract Class<?> getDefaultImpl();\n     \n      * call it with JSON data to deserializer (which does not contain\n      * type information).\n      */\n-    public abstract Object deserializeTypedFromObject(JsonParser jp, DeserializationContext ctxt)\n+    public abstract Object deserializeTypedFromObject(JsonParser jp,\n+            DeserializationContext ctxt)\n         throws IOException, JsonProcessingException;\n \n     /**\n      * call it with JSON data to deserializer (which does not contain\n      * type information).\n      */\n-    public abstract Object deserializeTypedFromArray(JsonParser jp, DeserializationContext ctxt)\n+    public abstract Object deserializeTypedFromArray(JsonParser jp,\n+            DeserializationContext ctxt)\n         throws IOException, JsonProcessingException;\n \n     /**\n      * call it with JSON data to deserializer (which does not contain\n      * type information).\n      */\n-    public abstract Object deserializeTypedFromScalar(JsonParser jp, DeserializationContext ctxt)\n+    public abstract Object deserializeTypedFromScalar(JsonParser jp,\n+            DeserializationContext ctxt)\n         throws IOException, JsonProcessingException;\n \n     /**\n      * using JSON node representation, or \"untyped\" Java object\n      * (which may be Map, Collection, wrapper/primitive etc).\n      */\n-    public abstract Object deserializeTypedFromAny(JsonParser jp, DeserializationContext ctxt)\n+    public abstract Object deserializeTypedFromAny(JsonParser jp,\n+            DeserializationContext ctxt)\n         throws IOException, JsonProcessingException;\n \n }\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/TypeSerializer.java\n      * Alternative version of the prefix-for-scalar method, which is given\n      * actual type to use (instead of using exact type of the value); typically\n      * a super type of actual value type\n-     * \n-     * @since 1.8\n      */\n     public void writeTypePrefixForScalar(Object value, JsonGenerator jgen,\n             Class<?> type)\n      * Alternative version of the prefix-for-object method, which is given\n      * actual type to use (instead of using exact type of the value); typically\n      * a super type of actual value type\n-     * \n-     * @since 1.8\n      */\n     public void writeTypePrefixForObject(Object value, JsonGenerator jgen,\n             Class<?> type)\n      * Alternative version of the prefix-for-array method, which is given\n      * actual type to use (instead of using exact type of the value); typically\n      * a super type of actual value type\n-     * \n-     * @since 1.8\n      */\n     public void writeTypePrefixForArray(Object value, JsonGenerator jgen,\n             Class<?> type)\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsExternalTypeDeserializer.java\n  * to basically transform external type id into structure that looks more like\n  * \"wrapper-array\" style inclusion. This intermediate form is chosen to allow\n  * supporting all possible JSON structures.\n- * \n- * @since 1.9\n  */\n public class AsExternalTypeDeserializer extends AsArrayTypeDeserializer\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsPropertyTypeDeserializer.java\n             if (_typePropertyName.equals(name)) { // gotcha!\n                 String typeId = jp.getText();\n                 JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);\n-                // deserializer should take care of closing END_OBJECT as well\n-               if (tb != null) {\n+               if (tb != null) { // need to put back skipped properties?\n                     jp = JsonParserSequence.createFlattened(tb.asParser(jp), jp);\n                 }\n                 /* Must point to the next value; tb had no current, jp\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n import com.fasterxml.jackson.databind.jsontype.TypeIdResolver;\n \n /**\n- * @author tatus\n+ * Base class for all standard Jackson {@link TypeDeserializer}s.\n  */\n public abstract class TypeDeserializerBase extends TypeDeserializer\n {\n     /**\n      * Type to use as the default implementation, if type id is\n      * missing or can not be resolved.\n-     * \n-     * @since 1.9\n      */\n     protected final JavaType _defaultImpl;\n     \n--- a/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ArrayNode.java\n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n-\n \n /**\n  * Node class that represents Arrays mapped from Json content.\n      * @param other Array to add contents from\n      * \n      * @return This node (to allow chaining)\n-     * \n-     * @since 1.3\n      */\n     public JsonNode addAll(ArrayNode other)\n     {\n      * @param nodes Nodes to add\n      * \n      * @return This node (to allow chaining)\n-     * \n-     * @since 1.3\n      */\n     public JsonNode addAll(Collection<JsonNode> nodes)\n     {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void add(Integer value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void add(Long value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void add(Float value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void add(Double value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void add(Boolean value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void insert(int index, Integer value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void insert(int index, Long value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void insert(int index, Float value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void insert(int index, Double value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void insert(int index, Boolean value) {\n         if (value == null) {\n     /**********************************************************\n      */\n \n-    /**\n-     * @since 1.6\n-     */\n     protected void addContentsTo(List<JsonNode> dst)\n     {\n         if (_children != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n      * be null.\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n-     * \n-     * @since 1.9\n      */\n     public ValueNode numberNode(Byte value) {\n         return (value == null) ? nullNode() : IntNode.valueOf(value.intValue());\n      * be null.\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n-     * \n-     * @since 1.9\n      */\n     public ValueNode numberNode(Short value) {\n         return (value == null) ? nullNode() : IntNode.valueOf(value.shortValue());\n      * be null.\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n-     * \n-     * @since 1.9\n      */\n     public ValueNode numberNode(Integer value) {\n         return (value == null) ? nullNode() : IntNode.valueOf(value.intValue());\n     public NumericNode numberNode(long v) { return LongNode.valueOf(v); }\n \n     /**\n-     * Alternate factory method that will handle wrapper value, which may\n-     * be null.\n-     * Due to possibility of null, returning type is not guaranteed to be\n-     * {@link NumericNode}, but just {@link ValueNode}.\n-     * \n-     * @since 1.9\n+     * Alternate factory method that will handle wrapper value, which may be null.\n+     * Due to possibility of null, returning type is not guaranteed to be\n+     * {@link NumericNode}, but just {@link ValueNode}.\n      */\n     public ValueNode numberNode(Long value) {\n         return (value == null) ? nullNode() : LongNode.valueOf(value.longValue());\n      * be null.\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n-     * \n-     * @since 1.9\n      */\n     public ValueNode numberNode(Float value) {\n         return (value == null) ? nullNode() : DoubleNode.valueOf(value.doubleValue());\n      * be null.\n      * Due to possibility of null, returning type is not guaranteed to be\n      * {@link NumericNode}, but just {@link ValueNode}.\n-     * \n-     * @since 1.9\n      */\n     public ValueNode numberNode(Double value) {\n         return (value == null) ? nullNode() : DoubleNode.valueOf(value.doubleValue());\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n      * @param fieldNames Names of fields to remove\n      * \n      * @return This ObjectNode after removing entries\n-     * \n-     * @since 1.6\n      */\n     public ObjectNode remove(Collection<String> fieldNames)\n     {\n      * @param properties Properties to add\n      * \n      * @return This node (to allow chaining)\n-     * \n-     * @since 1.3\n      */\n     public JsonNode putAll(Map<String,JsonNode> properties)\n     {\n      * @param other Object of which properties to add to this object\n      * \n      * @return This node (to allow chaining)\n-     * \n-     * @since 1.3\n      */\n     public JsonNode putAll(ObjectNode other)\n     {\n      * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n      * \n      * @return This ObjectNode (to allow call chaining)\n-     * \n-     * @since 1.6\n      */\n     public ObjectNode retain(Collection<String> fieldNames)\n     {\n      * @param fieldNames Fields to <b>retain</b> in this ObjectNode\n      * \n      * @return This ObjectNode (to allow call chaining)\n-     * \n-     * @since 1.6\n      */\n     public ObjectNode retain(String... fieldNames) {\n         return retain(Arrays.asList(fieldNames));\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void put(String fieldName, Integer value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void put(String fieldName, Long value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void put(String fieldName, Float value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void put(String fieldName, Double value) {\n         if (value == null) {\n     /**\n      * Alternative method that we need to avoid bumping into NPE issues\n      * with auto-unboxing.\n-     * \n-     * @since 1.9\n      */\n     public void put(String fieldName, Boolean value) {\n         if (value == null) {\n     /**********************************************************\n      */\n \n-    /**\n-     * @since 1.6\n-     */\n     protected void putContentsTo(Map<String,JsonNode> dst)\n     {\n         if (_children != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerFactory.java\n      * @param baseType Declared type to use as the base type for type information serializer\n      * \n      * @return Type serializer to use for property values, if one is needed; null if not.\n-     * \n-     * @since 1.5\n      */\n     public TypeSerializer findPropertyTypeSerializer(JavaType baseType, SerializationConfig config,\n             AnnotatedMember accessor, BeanProperty property)\n      * @param containerType Declared type of the container to use as the base type for type information serializer\n      * \n      * @return Type serializer to use for property value contents, if one is needed; null if not.\n-     * \n-     * @since 1.5\n      */    \n     public TypeSerializer findPropertyContentTypeSerializer(JavaType containerType, SerializationConfig config,\n             AnnotatedMember accessor, BeanProperty property)\n \n     /**\n      * Method called to construct serializer for serializing specified bean type.\n-     * \n-     * @since 1.6\n      */\n     @SuppressWarnings(\"unchecked\")\n     protected JsonSerializer<Object> constructBeanSerializer(SerializationConfig config,\n     }\n \n     /**\n-     * Helper method that will remove all properties that do not have a\n-     * mutator.\n-     * \n-     * @since 1.9\n+     * Helper method that will remove all properties that do not have a mutator.\n      */\n     protected void removeSetterlessGetters(SerializationConfig config, BasicBeanDescription beanDesc,\n             List<BeanPropertyDefinition> properties)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/Serializers.java\n      * Basic {@link Serializers} implementation that implements all methods but provides\n      * no serializers. Its main purpose is to serve as a base class so that\n      * sub-classes only need to override methods they need.\n-     * \n-     * @since 1.9\n      */\n     public static class Base implements Serializers\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/PropertySerializerMap.java\n  * this implementation is optimized for efficiency.\n  * Instances are immutable; new instances are created with factory methods: this\n  * is important to ensure correct multi-threaded access.\n- * \n- * @since 1.7\n  */\n public abstract class PropertySerializerMap\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/ReadOnlyClassToSerializerMap.java\n  * Optimized lookup table for accessing two types of serializers; typed\n  * and non-typed. Only accessed from a single thread, so no synchronization\n  * needed for accessors.\n- * \n- * @since 1.7\n  */\n public final class ReadOnlyClassToSerializerMap\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SerializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SerializerCache.java\n     /**********************************************************\n      */\n \n-    /**\n-     * @since 1.4\n-     */\n     public synchronized int size() {\n         return _sharedMap.size();\n     }\n         }\n     }\n \n-    /**\n-     * @since 1.5\n-     */\n     public JsonSerializer<Object> untypedValueSerializer(JavaType type)\n     {\n         synchronized (this) {\n         }\n     }\n     \n-    /**\n-     * @since 1.8\n-     */\n     public void addAndResolveNonTypedSerializer(Class<?> type, JsonSerializer<Object> ser,\n             SerializerProvider provider)\n         throws JsonMappingException\n         }\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     public void addAndResolveNonTypedSerializer(JavaType type, JsonSerializer<Object> ser,\n             SerializerProvider provider)\n         throws JsonMappingException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleBeanPropertyFilter.java\n /**\n  * Simple {@link BeanPropertyFilter} implementation that only uses property name\n  * to determine whether to serialize property as is, or to filter it out.\n- * \n- * @since 1.7\n  */\n public abstract class SimpleBeanPropertyFilter implements BeanPropertyFilter\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/SimpleFilterProvider.java\n      * result an exception (default) or not.\n      * Note that this is only relevant if no default filter has been\n      * configured.\n-     * \n-     * @since 1.9\n      */\n     protected boolean _cfgFailOnUnknownId = true;\n     \n         return this;\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     public BeanPropertyFilter getDefaultFilter() {\n         return _defaultFilter;\n     }\n     \n-    /**\n-     * @since 1.9\n-     */\n     public SimpleFilterProvider setFailOnUnknownId(boolean state) {\n         _cfgFailOnUnknownId = state;\n         return this;\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     public boolean willFailOnUnknownId() {\n         return _cfgFailOnUnknownId;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/InetAddressSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/InetAddressSerializer.java\n /**\n  * Simple serializer for {@link java.net.InetAddress}. Main complexity is\n  * with registration, since same serializer is to be used for sub-classes.\n- *\n- * @since 1.8\n  */\n public class InetAddressSerializer\n     extends ScalarSerializerBase<InetAddress>\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/RawSerializer.java\n import com.fasterxml.jackson.databind.jsontype.TypeSerializer;\n \n /**\n- * This is a simple dummy serializer that will just output raw values by calling toString()\n- * on value to serialize.\n- * \n- * @since 1.7\n+ * This is a simple dummy serializer that will just output raw values by calling\n+ * toString() on value to serialize.\n  */\n @JacksonStdImpl\n public class RawSerializer<T>\n--- a/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/CollectionLikeType.java\n      * \"real\" Collection type; meaning whether it represents a parameterized\n      * subtype of {@link java.util.Collection} or just something that acts\n      * like one.\n-     * \n-     * @since 1.8\n      */\n     public boolean isTrueCollectionType() {\n         return Collection.class.isAssignableFrom(_class);\n--- a/src/main/java/com/fasterxml/jackson/databind/type/HierarchicType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/HierarchicType.java\n  * specific relationship between one subtype and one supertype. This is needed\n  * for resolving type parameters. Instances are doubly-linked so that chain\n  * can be traversed in both directions\n- * \n- * @since 1.6\n  */\n public class HierarchicType\n {\n     /**\n      * Method that can be used to create a deep clone of this hierarchic type, including\n      * super types (but not subtypes)\n-     * \n-     * @since 1.9\n      */\n     public HierarchicType deepCloneWithoutSubtype()\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapLikeType.java\n                 _valueHandler, _typeHandler);\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     public JavaType widenKey(Class<?> keySubclass)\n     {\n         // Can do a quick check first:\n                 _valueHandler, _typeHandler);\n     }\n     \n-    // Since 1.7:\n     @Override\n     public MapLikeType withTypeHandler(Object h)\n     {\n         return new MapLikeType(_class, _keyType, _valueType, _valueHandler, h);\n     }\n \n-    // Since 1.7:\n     @Override\n     public MapLikeType withContentTypeHandler(Object h)\n     {\n                 _valueHandler, _typeHandler);\n     }\n \n-    // Since 1.9:\n     @Override\n     public MapLikeType withValueHandler(Object h) {\n         return new MapLikeType(_class, _keyType, _valueType, h, _typeHandler);\n     }\n \n-    // Since 1.9:\n     @Override\n     public MapLikeType withContentValueHandler(Object h) {\n         return new MapLikeType(_class, _keyType, _valueType.withValueHandler(h),\n     /**********************************************************\n      */\n \n-    /**\n-     * @since 1.9\n-     */\n     public MapLikeType withKeyTypeHandler(Object h)\n     {\n         return new MapLikeType(_class, _keyType.withTypeHandler(h), _valueType,\n                 _valueHandler, _typeHandler);\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     public MapLikeType withKeyValueHandler(Object h) {\n         return new MapLikeType(_class, _keyType.withValueHandler(h), _valueType,\n                 _valueHandler, _typeHandler);\n      * \"real\" Collection type; meaning whether it represents a parameterized\n      * subtype of {@link java.util.Collection} or just something that acts\n      * like one.\n-     * \n-     * @since 1.8\n      */\n     public boolean isTrueMapType() {\n         return Map.class.isAssignableFrom(_class);\n--- a/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/MapType.java\n                 _valueHandler, _typeHandler);\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     @Override\n     public JavaType widenKey(Class<?> keySubclass)\n     {\n                 _valueHandler, _typeHandler);\n     }\n     \n-    // Since 1.7:\n     @Override\n     public MapType withTypeHandler(Object h) {\n         return new MapType(_class, _keyType, _valueType, _valueHandler, h);\n     }\n \n-    // Since 1.7:\n     @Override\n     public MapType withContentTypeHandler(Object h)\n     {\n                 _valueHandler, _typeHandler);\n     }\n     \n-    // Since 1.9:\n     @Override\n     public MapType withValueHandler(Object h) {\n         return new MapType(_class, _keyType, _valueType, h, _typeHandler);\n     }\n \n-    // Since 1.9:\n     @Override\n     public MapType withContentValueHandler(Object h) {\n         return new MapType(_class, _keyType, _valueType.withValueHandler(h),\n     /**********************************************************\n      */\n     \n-    /**\n-     * @since 1.9\n-     */\n     @Override\n     public MapType withKeyTypeHandler(Object h)\n     {\n                 _valueHandler, _typeHandler);\n     }\n \n-    /**\n-     * @since 1.9\n-     */\n     @Override\n     public MapType withKeyValueHandler(Object h) {\n         return new MapType(_class, _keyType.withValueHandler(h), _valueType,\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeBindings.java\n \n /**\n  * Helper class used for resolving type parameters for given class\n- * \n- * @since 1.5\n  */\n public class TypeBindings\n {\n      * Sometimes it is necessary to allow hierarchic resolution of types: specifically\n      * in cases where there are local bindings (for methods, constructors). If so,\n      * we'll just use simple delegation model.\n-     * \n-     * @since 1.7\n      */\n     private final TypeBindings _parentBindings;\n \n      * allow delegation from explicitly defined local overrides\n      * (local type variables for methods, constructors) to\n      * contextual (class-defined) ones.\n-     * \n-     * @since 1.7\n      */\n     public TypeBindings childInstance() {\n         return new TypeBindings(_typeFactory, this, _contextClass, _contextType);\n     }\n \n-    /**\n-     * @since 1.7\n-     */\n     private TypeBindings(TypeFactory tf, TypeBindings parent, Class<?> cc, JavaType type)\n     {\n         _typeFactory = tf;\n     /**********************************************************\n      */\n \n-    /**\n-     * @since 1.8\n-     */\n-    /*\n-    public TypeFactory getTypeFactory() {\n-        return _typeFactory;\n-    }\n-    */\n-    \n     public int getBindingCount() {\n         if (_bindings == null) {\n             _resolve();\n         if (_placeholders != null && _placeholders.contains(name)) {\n             return UNBOUND;\n         }\n-        // New with 1.7: check parent context\n         if (_parentBindings != null) {\n             return _parentBindings.findType(name);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ArrayBuilders.java\n     }\n     \n     /**\n-     * Helper method for exposing contents of arrays using a read-only\n-     * iterator\n-     * \n-     * @since 1.7\n+     * Helper method for exposing contents of arrays using a read-only iterator\n      */\n     public static <T> Iterator<T> arrayAsIterator(T[] array)\n     {\n     /**\n      * Iterator implementation used to efficiently expose contents of an\n      * Array as read-only iterator.\n-     * \n-     * @since 1.7\n      */\n     private final static class ArrayIterator<T>\n         implements Iterator<T>, Iterable<T>\n--- a/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/BeanUtil.java\n /**\n  * Helper class that contains functionality needed by both serialization\n  * and deserialization side.\n- *\n- * @since 1.9\n  */\n public class BeanUtil\n {\n-    /*\n-     * Helper method to use for sorting bean properties, based on\n-     * ordering rules indicated by annotations, config features.\n-     * \n-     * @param config Serialization/Deserialization configuration in effect\n-     * @param beanDesc Bean description\n-     * @param props Properties to sort if/as necessary\n-     * @param defaultSortByAlpha Whether properties should be (re)sorted alphabetically\n-     *   by default (unless overridden by type)\n-     */\n-    /*\n-    public static <T extends Named> List<T> sortProperties(MapperConfig<?> config,\n-            BasicBeanDescription beanDesc, List<T> props,\n-            boolean defaultSortByAlpha)\n-    {\n-        // First, order by [JACKSON-90] (explicit ordering and/or alphabetic)\n-        // and then for [JACKSON-170] (implicitly order creator properties before others)\n-        List<String> creatorProps = beanDesc.findCreatorPropertyNames();\n-        // Then how about explicit ordering?\n-        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        AnnotatedClass ac = beanDesc.getClassInfo();\n-        String[] propertyOrder = intr.findSerializationPropertyOrder(ac);\n-        Boolean alpha = intr.findSerializationSortAlphabetically(ac);\n-        boolean sort;\n-        \n-        if (alpha == null) {\n-            sort = defaultSortByAlpha;\n-        } else {\n-            sort = alpha.booleanValue();\n-        }\n-        // no sorting? no need to shuffle, then\n-        if (!sort && creatorProps.isEmpty() && propertyOrder == null) {\n-            return props;\n-        }\n-        int size = props.size();\n-        Map<String,T> all;\n-        // Need to (re)sort alphabetically?\n-        if (sort) {\n-            all = new TreeMap<String,T>();\n-        } else {\n-            all = new LinkedHashMap<String,T>(size+size);\n-        }\n-\n-        for (T w : props) {\n-            all.put(w.getName(), w);\n-        }\n-        Map<String,T> ordered = new LinkedHashMap<String,T>(size+size);\n-        // Ok: primarily by explicit order\n-        if (propertyOrder != null) {\n-            for (String name : propertyOrder) {\n-                T w = all.get(name);\n-                if (w != null) {\n-                    ordered.put(name, w);\n-                }\n-            }\n-        }\n-        // And secondly by sorting Creator properties before other unordered properties\n-        for (String name : creatorProps) {\n-            T w = all.get(name);\n-            if (w != null) {\n-                ordered.put(name, w);\n-            }\n-        }\n-        // And finally whatever is left (trying to put again will not change ordering)\n-        ordered.putAll(all);\n-        return new ArrayList<T>(ordered.values());\n-    }\n-    */\n-\n     /*\n     /**********************************************************\n     /* Handling \"getter\" names\n--- a/src/main/java/com/fasterxml/jackson/databind/util/Comparators.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/Comparators.java\n \n /**\n  * Helper class for constructing objects for comparing content values\n- * \n- * @since 1.9.0\n  */\n public class Comparators\n {\n      *<p>\n      * Note: current implementation is not optimized for speed; if performance\n      * ever becomes an issue, it is possible to construct much more efficient\n-     * typed instances (one for Object[] and sub-types; one per primitive type)\n-     * \n-     * @since 1.9\n+     * typed instances (one for Object[] and sub-types; one per primitive type).\n      */\n     public static Object getArrayComparator(final Object defaultValue)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/util/Named.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/Named.java\n package com.fasterxml.jackson.databind.util;\n \n /**\n- * Simple tag interface mostly to allow sorting by name\n- *\n- * @since 1.9\n+ * Simple tag interface mostly to allow sorting by name.\n  */\n public interface Named {\n     public String getName();\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ObjectBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ObjectBuffer.java\n         return result;\n     }\n \n-    /**\n-     * Another\n-     * \n-     * @since 1.6\n-     */\n     public void completeAndClearBuffer(Object[] lastChunk, int lastChunkEntries, List<Object> resultList)\n     {\n         for (Node n = _bufferHead; n != null; n = n.next()) {\n--- a/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/StdDateFormat.java\n \n     /**\n      * ISO-8601 with just the Date part, no time\n-     *\n-     * @since 1.3.1\n      */\n     protected final static String DATE_FORMAT_STR_PLAIN = \"yyyy-MM-dd\";\n ", "timestamp": 1327120380, "metainfo": ""}