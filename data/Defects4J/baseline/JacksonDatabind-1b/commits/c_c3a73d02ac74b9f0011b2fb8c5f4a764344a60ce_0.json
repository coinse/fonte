{"sha": "c3a73d02ac74b9f0011b2fb8c5f4a764344a60ce", "log": "More elimination of BeanProperty passing, getting close: one new (transient) unit test failure to fix", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.cfg.MapperConfig;\n import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.deser.impl.TypeWrappedDeserializer;\n import com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.node.JsonNodeFactory;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n \n     protected final DeserializerCache _deserCache;\n \n+    protected final DeserializerFactory _factory;\n+    \n     protected final InjectableValues _injectableValues;\n     \n     // // // Helper object recycling\n         _parser = jp;\n         _deserCache = cache;\n         _injectableValues = injectableValues;\n+        _factory = cache.getDeserializerFactory();\n     }\n \n     /*\n     /* Public API, pass-through to DeserializerCache\n     /**********************************************************\n      */\n-    /**\n-     * Convenience method, functionally same as:\n-     *<pre>\n-     *  getDeserializerProvider().findValueDeserializer(getConfig(), propertyType, property);\n-     *</pre>\n-     */\n-    public final JsonDeserializer<Object> findValueDeserializer(JavaType type,\n-            BeanProperty property) throws JsonMappingException {\n-        return _deserCache.findValueDeserializer(this, type, property);\n-    }\n-    \n-    /**\n-     * Convenience method, functionally same as:\n-     *<pre>\n-     *  getDeserializerProvider().findRootValueDeserializer(getConfig(), propertyType, property);\n-     *</pre>\n-     */\n+\n+    /**\n+     * Method for finding a value deserializer, and creating a contextual\n+     * version if necessary, for value reached via specified property.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public final JsonDeserializer<Object> findContextualValueDeserializer(JavaType type,\n+            BeanProperty property) throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser = _deserCache.findValueDeserializer(this, type);\n+        if (deser != null) {\n+            if (deser instanceof ContextualDeserializer) {\n+                deser = (JsonDeserializer<Object>)((ContextualDeserializer) deser).createContextual(this, property);\n+            }\n+        }\n+        return deser;\n+    }\n+    \n+    /**\n+     * Method for finding a deserializer for root-level value.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n     public final JsonDeserializer<Object> findRootValueDeserializer(JavaType type)\n-            throws JsonMappingException {\n-        return _deserCache.findRootValueDeserializer(this, type);\n+            throws JsonMappingException\n+    {\n+        JsonDeserializer<Object> deser = _deserCache.findValueDeserializer(this, type);\n+        if (deser == null) { // can this occur?\n+            return null;\n+        }\n+        if (deser instanceof ContextualDeserializer) {\n+            deser = (JsonDeserializer<Object>)((ContextualDeserializer) deser).createContextual(this, null);\n+        }\n+        TypeDeserializer typeDeser = _factory.findTypeDeserializer(_config, type);\n+        if (typeDeser != null) {\n+            // important: contextualize to indicate this is for root value\n+            typeDeser = typeDeser.forProperty(null);\n+            return new TypeWrappedDeserializer(typeDeser, deser);\n+        }\n+        return deser;\n     }\n \n     /**\n \n     @SuppressWarnings(\"unchecked\")\n     public JsonDeserializer<Object> deserializerInstance(Annotated annotated,\n-            BeanProperty property, Object deserDef)\n+            Object deserDef)\n         throws JsonMappingException\n     {\n         if (deserDef == null) {\n         // First: need to resolve\n         if (deser instanceof ResolvableDeserializer) {\n             ((ResolvableDeserializer) deser).resolve(this);\n-        }\n-        // Second: contextualize:\n-        if (deser instanceof ContextualDeserializer) {\n-            deser = ((ContextualDeserializer) deser).createContextual(this, property);\n         }\n         return (JsonDeserializer<Object>) deser;\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n             property = property.withType(type);\n         }\n         // Is there an annotation that specifies exact deserializer?\n-        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param, property);\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, param);\n         // If yes, we are mostly done:\n         type = modifyTypeByAnnotation(ctxt, param, type, property);\n \n         }\n         // And then other one-offs; first, Enum:\n         if (type.isEnumType()) {\n-            return _createEnumKeyDeserializer(ctxt, type, property);\n+            return _createEnumKeyDeserializer(ctxt, type);\n         }\n         // One more thing: can we find ctor(String) or valueOf(String)?\n         kdes = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n     }\n \n     private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n-            JavaType type, BeanProperty property)\n+            JavaType type)\n         throws JsonMappingException\n     {\n         final DeserializationConfig config = ctxt.getConfig();\n         BeanDescription beanDesc = config.introspect(type);\n-        JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo(), property);\n+        JsonDeserializer<?> des = findDeserializerFromAnnotation(ctxt, beanDesc.getClassInfo());\n         if (des != null) {\n             return StdKeyDeserializers.constructDelegatingKeyDeserializer(config, type, des);\n         }\n      * Returns null if no such annotation found.\n      */\n     protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n-            Annotated ann, BeanProperty property)\n+            Annotated ann)\n         throws JsonMappingException\n     {\n         Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n         if (deserDef == null) {\n             return null;\n         }\n-        return ctxt.deserializerInstance(ann, property, deserDef);\n+        return ctxt.deserializerInstance(ann, deserDef);\n     }\n \n     /**\n            JavaType contentType = type.getContentType();\n            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n                Object cdDef = intr.findContentDeserializer(a);\n-                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, prop, cdDef);\n+                JsonDeserializer<?> cd = ctxt.deserializerInstance(a, cdDef);\n                 if (cd != null) {\n                     type = (T) type.withContentValueHandler(cd);\n                 }\n             }\n             // and all container types have content types...\n             Object cdDef = intr.findContentDeserializer(member);\n-            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, property, cdDef);\n+            JsonDeserializer<?> cd = ctxt.deserializerInstance(member, cdDef);\n             if (cd != null) {\n                 type = type.withContentValueHandler(cd);\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n          * Returns null if no annotations, in which case binding will\n          * be done at a later point.\n          */\n-        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, setter, property);\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt, setter);\n         if (deser != null) {\n             return new SettableAnyProperty(property, setter, type, deser);\n         }\n         /* First: does the Method specify the deserializer to use?\n          * If so, let's use it.\n          */\n-        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator, property);\n+        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n         type = modifyTypeByAnnotation(ctxt, mutator, type, property);\n         TypeDeserializer typeDeser = type.getTypeHandler();\n         SettableBeanProperty prop;\n          */\n         BeanProperty.Std property = new BeanProperty.Std(name, type, beanDesc.getClassAnnotations(), getter);\n         // @TODO: create BeanProperty to pass?\n-        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, getter, property);\n+        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, getter);\n         type = modifyTypeByAnnotation(ctxt, getter, type, property);\n         TypeDeserializer typeDeser = type.getTypeHandler();\n         SettableBeanProperty prop = new SettableBeanProperty.SetterlessProperty(name, type, typeDeser,\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n package com.fasterxml.jackson.databind.deser;\n \n-import java.io.IOException;\n import java.util.HashMap;\n import java.util.concurrent.ConcurrentHashMap;\n-\n-import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.NoClass;\n import com.fasterxml.jackson.databind.introspect.Annotated;\n-import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n \n \n     public DeserializerCache(DeserializerFactory f) {\n         _factory = f;\n+    }\n+\n+    public DeserializerFactory getDeserializerFactory() {\n+        return _factory;\n     }\n \n     /*\n      *<p>\n      * Note: this method is only called for value types; not for keys.\n      * Key deserializers can be accessed using {@link #findKeyDeserializer}.\n+     *<p>\n+     * Note also that deserializer returned is guaranteed to be resolved\n+     * (if it is of type {@link ResolvableDeserializer}), but\n+     * not contextualized (wrt {@link ContextualDeserializer}): caller\n+     * has to handle latter if necessary.\n      *\n      * @param ctxt Deserialization context\n      * @param propertyType Declared type of the value to deserializer (obtained using\n      *   'setter' method signature and/or type annotations\n-     * @param property Object that represents accessor for property value; field,\n-     *    setter method or constructor parameter.\n      *\n      * @throws JsonMappingException if there are fatal problems with\n      *   accessing suitable deserializer; including that of not\n      *   finding any serializer\n      */\n-    @SuppressWarnings(\"unchecked\")\n     public JsonDeserializer<Object> findValueDeserializer(DeserializationContext ctxt,\n-            JavaType propertyType, BeanProperty property)\n+            JavaType propertyType)\n         throws JsonMappingException\n     {\n         JsonDeserializer<Object> deser = _findCachedDeserializer(propertyType);\n         if (deser != null) {\n-            // [JACKSON-385]: need to support contextualization:\n-            if (deser instanceof ContextualDeserializer) {\n-                JsonDeserializer<?> d = ((ContextualDeserializer) deser).createContextual(ctxt, property);\n-                deser = (JsonDeserializer<Object>) d;\n-            }\n             return deser;\n         }\n         // If not, need to request factory to construct (or recycle)\n-        deser = _createAndCacheValueDeserializer(ctxt, propertyType, property);\n+        deser = _createAndCacheValueDeserializer(ctxt, propertyType);\n         if (deser == null) {\n             /* Should we let caller handle it? Let's have a helper method\n              * decide it; can throw an exception, or return a valid\n              */\n             deser = _handleUnknownValueDeserializer(propertyType);\n         }\n-        // [JACKSON-385]: need to support contextualization:\n-        if (deser instanceof ContextualDeserializer) {\n-            JsonDeserializer<?> d = ((ContextualDeserializer) deser).createContextual(ctxt, property);\n-            deser = (JsonDeserializer<Object>) d;\n-        }\n-        return deser;\n-    }\n-    \n-    /**\n-     * Method called to locate deserializer for given type, when it as referenced\n-     * from the root context; that is, it is not referenced through a property.\n-     * Because there is no referral via property, a type deserializer will be wrapped\n-     * around deserializer, if one is needed.\n-     */\n-    public JsonDeserializer<Object> findRootValueDeserializer(DeserializationContext ctxt,\n-            JavaType type)\n-        throws JsonMappingException\n-    {\n-        JsonDeserializer<Object> deser = findValueDeserializer(ctxt, type, null);\n-        TypeDeserializer typeDeser = _factory.findTypeDeserializer(ctxt.getConfig(), type);\n-        if (typeDeser != null) {\n-            // important: contextualize\n-            typeDeser = typeDeser.forProperty(null);\n-            return new WrappedDeserializer(typeDeser, deser);\n-        }\n         return deser;\n     }\n \n         JsonDeserializer<Object> deser = _findCachedDeserializer(type);\n         if (deser == null) {\n             try {\n-                deser = _createAndCacheValueDeserializer(ctxt, type, null);\n+                deser = _createAndCacheValueDeserializer(ctxt, type);\n             } catch (Exception e) {\n                 return false;\n             }\n      * @param property Property (field, setter, ctor arg) to use deserializer for\n      */\n     protected JsonDeserializer<Object>_createAndCacheValueDeserializer(DeserializationContext ctxt,\n-            JavaType type, BeanProperty property)\n+            JavaType type)\n         throws JsonMappingException\n     {\n         /* Only one thread to construct deserializers at any given point in time;\n             }\n             // Nope: need to create and possibly cache\n             try {\n-                return _createAndCache2(ctxt, type, property);\n+                return _createAndCache2(ctxt, type);\n             } finally {\n                 // also: any deserializers that have been created are complete by now\n                 if (count == 0 && _incompleteDeserializers.size() > 0) {\n      * intermediate and eventual)\n      */\n     protected JsonDeserializer<Object> _createAndCache2(DeserializationContext ctxt,\n-            JavaType type, BeanProperty property)\n+            JavaType type)\n         throws JsonMappingException\n     {\n         JsonDeserializer<Object> deser;\n         try {\n-            deser = _createDeserializer(ctxt, type, property);\n+            deser = _createDeserializer(ctxt, type);\n         } catch (IllegalArgumentException iae) {\n             /* We better only expose checked exceptions, since those\n              * are what caller is expected to handle\n      */\n     @SuppressWarnings(\"unchecked\")\n     protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt,\n-            JavaType type, BeanProperty property)\n+            JavaType type)\n         throws JsonMappingException\n     {\n         final DeserializationConfig config = ctxt.getConfig();\n         BeanDescription beanDesc = config.introspect(type);\n         // Then: does type define explicit deserializer to use, with annotation(s)?\n         JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n-                beanDesc.getClassInfo(), property);\n+                beanDesc.getClassInfo());\n         if (deser != null) {\n             return deser;\n         }\n \n         // If not, may have further type-modification annotations to check:\n-        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type, property);\n+        JavaType newType = modifyTypeByAnnotation(ctxt, beanDesc.getClassInfo(), type);\n         if (newType != type) {\n             type = newType;\n             beanDesc = config.introspect(newType);\n         if (type.isContainerType()) {\n             if (type.isArrayType()) {\n                 return (JsonDeserializer<Object>)_factory.createArrayDeserializer(ctxt,\n-                        (ArrayType) type, beanDesc, property);\n+                        (ArrayType) type, beanDesc, null);\n             }\n             if (type.isMapLikeType()) {\n                 MapLikeType mlt = (MapLikeType) type;\n                 if (mlt.isTrueMapType()) {\n                     return (JsonDeserializer<Object>)_factory.createMapDeserializer(ctxt,\n-                            (MapType) mlt, beanDesc, property);\n+                            (MapType) mlt, beanDesc, null);\n                 }\n                 return (JsonDeserializer<Object>)_factory.createMapLikeDeserializer(ctxt,\n                         mlt, beanDesc);\n                 CollectionLikeType clt = (CollectionLikeType) type;\n                 if (clt.isTrueCollectionType()) {\n                     return (JsonDeserializer<Object>)_factory.createCollectionDeserializer(ctxt,\n-                            (CollectionType) clt, beanDesc, property);\n+                            (CollectionType) clt, beanDesc, null);\n                 }\n                 return (JsonDeserializer<Object>)_factory.createCollectionLikeDeserializer(ctxt,\n                         clt, beanDesc);\n      * Returns null if no such annotation found.\n      */\n     protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n-            Annotated ann, BeanProperty property)\n+            Annotated ann)\n         throws JsonMappingException\n     {\n         Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n         if (deserDef == null) {\n             return null;\n         }\n-        return ctxt.deserializerInstance(ann, property, deserDef);\n+        return ctxt.deserializerInstance(ann, deserDef);\n     }\n \n     /**\n      *\n      * @param a Method or field that the type is associated with\n      * @param type Type derived from the setter argument\n-     * @param prop Property that lead to this annotation, if any.\n      *\n      * @return Original type if no annotations are present; or a more\n      *   specific type derived from it if type annotation(s) was found\n      * @throws JsonMappingException if invalid annotation is found\n      */\n     private JavaType modifyTypeByAnnotation(DeserializationContext ctxt,\n-            Annotated a, JavaType type, BeanProperty prop)\n+            Annotated a, JavaType type)\n         throws JsonMappingException\n     {\n         // first: let's check class for the instance itself:\n             if (keyType != null && keyType.getValueHandler() == null) {\n                 Object kdDef = intr.findKeyDeserializer(a);\n                 if (kdDef != null) {\n-                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, prop, kdDef);\n+                    KeyDeserializer kd = ctxt.keyDeserializerInstance(a, null, kdDef);\n                     if (kd != null) {\n                         type = ((MapLikeType) type).withKeyValueHandler(kd);\n                         keyType = type.getKeyType(); // just in case it's used below\n                     } else {\n                         Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n                         if (cdClass != null) {\n-                            cd = ctxt.deserializerInstance(a, prop, cdClass);\n+                            cd = ctxt.deserializerInstance(a, cdClass);\n                         }\n                     }\n                     if (cd != null) {\n         throw new JsonMappingException(\"Can not find a (Map) Key deserializer for type \"+type);\n     }\n \n-    /*\n-    /**********************************************************\n-    /*  Helper classes\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Simple deserializer that will call configured type deserializer, passing\n-     * in configured data deserializer, and exposing it all as a simple\n-     * deserializer.\n-     */\n-    protected final static class WrappedDeserializer\n-        extends JsonDeserializer<Object>\n-    {\n-        final TypeDeserializer _typeDeserializer;\n-        final JsonDeserializer<Object> _deserializer;\n-\n-        public WrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<Object> deser)\n-        {\n-            super();\n-            _typeDeserializer = typeDeser;\n-            _deserializer = deser;\n-        }\n-\n-        @Override\n-        public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-                throws IOException, JsonProcessingException\n-        {\n-            return _deserializer.deserializeWithType(jp, ctxt, _typeDeserializer);\n-        }\n-\n-        @Override\n-        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-                throws IOException, JsonProcessingException\n-        {\n-            // should never happen? (if it can, could call on that object)\n-            throw new IllegalStateException(\"Type-wrapped deserializer's deserializeWithType should never get called\");\n-        }\n-    }\n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/TypeWrappedDeserializer.java\n+package com.fasterxml.jackson.databind.deser.impl;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+\n+/**\n+ * Simple deserializer that will call configured type deserializer, passing\n+ * in configured data deserializer, and exposing it all as a simple\n+ * deserializer.\n+ * This is necessary when there is no \"parent\" deserializer which could handle\n+ * details of calling a {@link TypeDeserializer}, most commonly used with\n+ * root values.\n+ */\n+public final class TypeWrappedDeserializer\n+    extends JsonDeserializer<Object>\n+{\n+    final TypeDeserializer _typeDeserializer;\n+    final JsonDeserializer<Object> _deserializer;\n+\n+    public TypeWrappedDeserializer(TypeDeserializer typeDeser, JsonDeserializer<Object> deser)\n+    {\n+        super();\n+        _typeDeserializer = typeDeser;\n+        _deserializer = deser;\n+    }\n+\n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException, JsonProcessingException\n+    {\n+        return _deserializer.deserializeWithType(jp, ctxt, _typeDeserializer);\n+    }\n+\n+    @Override\n+    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+        TypeDeserializer typeDeserializer)\n+            throws IOException, JsonProcessingException\n+    {\n+        // should never happen? (if it can, could call on that object)\n+        throw new IllegalStateException(\"Type-wrapped deserializer's deserializeWithType should never get called\");\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/CollectionDeserializer.java\n         // also, often value deserializer is resolved here:\n         JsonDeserializer<Object> valueDeser = _valueDeserializer;\n         if (valueDeser == null) {\n-            valueDeser = (JsonDeserializer<Object>)ctxt.findValueDeserializer(_collectionType.getContentType(), property);\n+            valueDeser = (JsonDeserializer<Object>)ctxt.findContextualValueDeserializer(\n+                    _collectionType.getContentType(), property);\n         }\n         // and finally, type deserializer needs context as well\n         TypeDeserializer valueTypeDeser = _valueTypeDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n         // quite as clean as it ought to be)\n         JsonDeserializer<?> kd = _keyDeserializer;\n         if (kd == null) {\n-            kd = ctxt.findValueDeserializer(_mapType.getKeyType(), property);\n+            kd = ctxt.findContextualValueDeserializer(_mapType.getKeyType(), property);\n         }\n         JsonDeserializer<?> vd = _valueDeserializer;\n         if (vd == null) {\n-            vd = ctxt.findValueDeserializer(_mapType.getContentType(), property);\n+            vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property);\n         }\n         return withResolved(kd, vd);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n         if (_enumDeserializer != null) {\n             return this;\n         }\n-        return withDeserializer(ctxt.findValueDeserializer(_enumType, property));\n+        return withDeserializer(ctxt.findContextualValueDeserializer(_enumType, property));\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JdkDeserializers.java\n                 return this;\n             }\n             return new AtomicReferenceDeserializer(_referencedType,\n-                    ctxt.findValueDeserializer(_referencedType, property));\n+                    ctxt.findContextualValueDeserializer(_referencedType, property));\n         }\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\n         }\n         JsonDeserializer<Object> vd = _valueDeserializer;\n         if (vd == null) {\n-            vd = ctxt.findValueDeserializer(_mapType.getContentType(), property);\n+            vd = ctxt.findContextualValueDeserializer(_mapType.getContentType(), property);\n         }\n         TypeDeserializer vtd = _valueTypeDeserializer;\n         if (vtd != null) {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/ObjectArrayDeserializer.java\n         if (elemTypeDeser != null) {\n             elemTypeDeser = elemTypeDeser.forProperty(property);\n         }\n-        return withDeserializer(ctxt.findValueDeserializer(_arrayType.getContentType(), property),\n-                elemTypeDeser);\n+        return withDeserializer(ctxt.findContextualValueDeserializer(\n+                _arrayType.getContentType(), property), elemTypeDeser);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n             JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n-        return ctxt.findValueDeserializer(type, property);\n+        return ctxt.findContextualValueDeserializer(type, property);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\n         JsonDeserializer<?> valueDeser = _valueDeserializer;\n         if (valueDeser == null) {\n             // And we may also need to get deserializer for String\n-            JsonDeserializer<?> deser = ctxt.findValueDeserializer(_collectionType.getContentType(), property);\n+            JsonDeserializer<?> deser = ctxt.findContextualValueDeserializer(\n+                    _collectionType.getContentType(), property);\n             valueDeser = (JsonDeserializer<String>) deser;\n             if (isDefaultDeserializer(valueDeser)) {\n                 valueDeser = null;\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n                     if (_baseType != null && _baseType.getClass() == type.getClass()) {\n                         type = _baseType.narrowBy(type.getRawClass());\n                     }\n-                    deser = ctxt.findValueDeserializer(type, _property);\n+                    deser = ctxt.findContextualValueDeserializer(type, _property);\n                 }\n                 _deserializers.put(typeId, deser);\n             }\n         }\n         synchronized (_defaultImpl) {\n             if (_defaultImplDeserializer == null) {\n-                _defaultImplDeserializer = ctxt.findValueDeserializer(_defaultImpl, _property);\n+                _defaultImplDeserializer = ctxt.findContextualValueDeserializer(\n+                        _defaultImpl, _property);\n             }\n             return _defaultImplDeserializer;\n         }", "timestamp": 1328042749, "metainfo": ""}