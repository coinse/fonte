{"sha": "56e8e6c7d057e6acf2d3dce98e6802cbbee48c57", "log": "Starting to add support for customizable 'is-empty' handling", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonSerializer.java\n      *<p>\n      * Default implementation just returns serializer as-is,\n      * indicating that no unwrapped variant exists\n-     * \n-     * @since 1.9\n      */\n     public JsonSerializer<T> unwrappingSerializer() {\n         return this;\n      * \"unwrapping\" serializer; this is necessary to know since\n      * it may also require caller to suppress writing of the\n      * leading property name.\n-     * \n-     * @since 1.9\n      */\n     public boolean isUnwrappingSerializer() {\n         return false;\n      * @param provider Provider that can be used to get serializers for\n      *   serializing Objects value contains, if any.\n      * @param typeSer Type serializer to use for including type information\n-     *\n-     * @since 1.5\n      */\n     public void serializeWithType(T value, JsonGenerator jgen, SerializerProvider provider,\n             TypeSerializer typeSer)\n      *<p>\n      */\n     public Class<T> handledType() { return null; }\n+\n+    /**\n+     * Method called to check whether given serializable value is\n+     * considered \"empty\" value (for purposes of suppressing serialization\n+     * of empty values).\n+     *<p>\n+     * Default implementation will consider only null values to be empty.\n+     * \n+     * @since 2.0\n+     */\n+    public boolean isEmpty(T value) {\n+        return (value == null);\n+    }\n     \n     /*\n     /**********************************************************\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializerProvider.java\n      * Method that will handle serialization of Dates used as {@link java.util.Map} keys,\n      * based on {@link SerializationConfig.Feature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n      * value (and if using textual representation, configured date format)\n-     * \n-     * @since 1.9\n      */\n     public abstract void defaultSerializeDateKey(long timestamp, JsonGenerator jgen)\n         throws IOException, JsonProcessingException;\n      * Method that will handle serialization of Dates used as {@link java.util.Map} keys,\n      * based on {@link SerializationConfig.Feature#WRITE_DATE_KEYS_AS_TIMESTAMPS}\n      * value (and if using textual representation, configured date format)\n-     * \n-     * @since 1.9\n      */\n     public abstract void defaultSerializeDateKey(Date date, JsonGenerator jgen)\n         throws IOException, JsonProcessingException;\n     \n-    /**\n-     * @since 1.7\n-     */\n     public final void defaultSerializeNull(JsonGenerator jgen)\n         throws IOException, JsonProcessingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\n     /**\n      * Member (field, method) that represents property and allows access\n      * to associated annotations.\n-     * \n-     * @since 1.7\n      */\n     protected final AnnotatedMember _member;\n \n     /**********************************************************\n     /* Opaque internal data that bean serializer factory and\n     /* bean serializers can add.\n-    /* \n-    /* @since 1.7\n     /**********************************************************\n      */\n \n      * In case serializer is not known statically (i.e. <code>_serializer</code>\n      * is null), we will use a lookup structure for storing dynamically\n      * resolved mapping from type(s) to serializer(s).\n-     * \n-     * @since 1.7\n      */\n     protected PropertySerializerMap _dynamicSerializers;\n     \n     /**\n      * Alternate set of property writers used when view-based filtering\n      * is available for the Bean.\n-     * \n-     * @since 1.4\n      */\n     protected Class<?>[] _includeInViews;\n \n     /**\n      * Base type of the property, if the declared type is \"non-trivial\";\n      * meaning it is either a structured type (collection, map, array),\n-     * or parametrized. Used to retain type information about contained\n+     * or parameterized. Used to retain type information about contained\n      * type, which is mostly necessary if type metadata is to be\n      * included.\n-     *\n-     * @since 1.5\n      */\n     protected JavaType _nonTrivialBaseType;\n \n     /**\n      * Method called create an instance that handles details of unwrapping\n      * contained value.\n-     * \n-     * @since 1.9\n      */\n     public BeanPropertyWriter unwrappingWriter() {\n         return new UnwrappingBeanPropertyWriter(this);\n      * Method called to define type to consider as \"non-trivial\" basetype,\n      * needed for dynamic serialization resolution for complex (usually container)\n      * types\n-     *\n-     * @since 1.5\n      */\n     public void setNonTrivialBaseType(JavaType t) {\n         _nonTrivialBaseType = t;\n      * Method for accessing value of specified internal setting.\n      * \n      * @return Value of the setting, if any; null if none.\n-     * \n-     * @since 1.7\n      */\n     public Object getInternalSetting(Object key)\n     {\n      * Method for setting specific internal setting to given value\n      * \n      * @return Old value of the setting, if any (null if none)\n-     * \n-     * @since 1.7\n      */\n     public Object setInternalSetting(Object key, Object value)\n     {\n      * Method for removing entry for specified internal setting.\n      * \n      * @return Existing value of the setting, if any (null if none)\n-     * \n-     * @since 1.7\n      */\n     public Object removeInternalSetting(Object key)\n     {\n         if (_suppressableValue != null && _suppressableValue.equals(value)) {\n             return;\n         }\n-\n         JsonSerializer<Object> ser = _serializer;\n         if (ser == null) {\n             Class<?> cls = value.getClass();\n         }\n     }\n \n-    /**\n-     * @since 1.7\n-     */\n     protected JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n             Class<?> type, SerializerProvider provider) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializer.java\n  * to figure out actual serializers for final types. This must be\n  * done from {@link #resolve} method, and NOT from constructor;\n  * otherwise we could end up with an infinite loop.\n- *<p>\n- * Since 1.7 instances are immutable; this is achieved by using a\n- * separate builder during construction process.\n  */\n public class BeanSerializer\n     extends BeanSerializerBase\n     /**\n      * Copy-constructor that is useful for sub-classes that just want to\n      * copy all super-class properties without modifications.\n-     * \n-     * @since 1.7\n      */\n     protected BeanSerializer(BeanSerializer src) {\n         super(src);\n      * Alternate copy constructor that can be used to construct\n      * standard {@link BeanSerializer} passing an instance of\n      * \"compatible enough\" source serializer.\n-     * \n-     * @since 1.9\n      */\n     protected BeanSerializer(BeanSerializerBase src) {\n         super(src);\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BeanSerializerBuilder.java\n  * intances.\n  * Main reason for using separate builder class is that this makes it easier\n  * to make actual serializer class fully immutable.\n- * \n- * @since 1.7\n  */\n public class BeanSerializerBuilder\n {\n     public List<BeanPropertyWriter> getProperties() { return _properties; }\n     public BeanPropertyWriter[] getFilteredProperties() { return _filteredProperties; }\n     \n-    /**\n-     * @since 1.9\n-     */\n     public boolean hasProperties() {\n         return (_properties != null) && (_properties.size() > 0);\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/StdSerializerProvider.java\n  * (<code>instance.getClass() == blueprint.getClass()</code>).\n  * Check is done to prevent weird bugs that would otherwise occur.\n  *<p>\n- * Starting with version 1.5, provider is also responsible for\n- * some parts of type serialization; specifically for locating\n- * proper type serializers to use for types.\n+ * Provider is also responsible for some parts of type serialization;\n+ * specifically for locating proper type serializers.\n  */\n public class StdSerializerProvider\n     extends SerializerProvider\n         return ser;\n     }\n \n-    /**\n-     * @since 1.5\n-]     */\n     protected JsonSerializer<Object> _createAndCacheUntypedSerializer(JavaType type,\n             BeanProperty property)\n         throws JsonMappingException\n         return (JsonSerializer<Object>)_serializerFactory.createSerializer(_config, type, property);\n     }\n \n-    /**\n-     * @since 1.8.5\n-     */\n     @SuppressWarnings(\"unchecked\")\n     protected JsonSerializer<Object> _handleContextualResolvable(JsonSerializer<Object> ser,\n             BeanProperty property)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/AsArraySerializerBase.java\n         }\n     }\n \n-    /**\n-     * @since 1.7\n-     */\n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n             Class<?> type, SerializerProvider provider) throws JsonMappingException\n     {\n         return result.serializer;\n     }\n \n-    /**\n-     * @since 1.8\n-     */\n     protected final JsonSerializer<Object> _findAndAddDynamic(PropertySerializerMap map,\n             JavaType type, SerializerProvider provider) throws JsonMappingException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CalendarSerializer.java\n     public CalendarSerializer() { super(Calendar.class); }\n     \n     @Override\n+    public boolean isEmpty(Calendar value) {\n+        // let's assume \"null date\" (timestamp 0) qualifies for empty\n+        return (value == null) || (value.getTimeInMillis() == 0L);\n+    }\n+\n+    @Override\n     public void serialize(Calendar value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/CollectionSerializer.java\n     @Override\n     public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n         return new CollectionSerializer(_elementType, _staticTyping, vts, _property, _elementSerializer);\n+    }\n+\n+    @Override\n+    public boolean isEmpty(Collection<?> value) {\n+        return (value == null) || value.isEmpty();\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ContainerSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ContainerSerializerBase.java\n  * Intermediate base class for types that contain element(s) of\n  * other types. Used for example for List, Map, Object array and\n  * Iterator serializers.\n- * \n- * @since 1.5\n  */\n public abstract class ContainerSerializerBase<T>\n     extends SerializerBase<T>\n         return _withValueTypeSerializer(vts);\n     }\n \n+    /* Overridden as abstract, to force re-implementation; necessary for all\n+     * collection types.\n+     */\n+    @Override\n+    public abstract boolean isEmpty(T value);\n+    \n     public abstract ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts);\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/DateSerializer.java\n  */\n @JacksonStdImpl\n public class DateSerializer\n-    extends ScalarSerializerBase<java.util.Date>\n+    extends ScalarSerializerBase<Date>\n {\n     public static DateSerializer instance = new DateSerializer();\n     \n     public DateSerializer() { super(Date.class); }\n \n+    @Override\n+    public boolean isEmpty(Date value) {\n+        // let's assume \"null date\" (timestamp 0) qualifies for empty\n+        return (value == null) || (value.getTime() == 0L);\n+    }\n+    \n     @Override\n     public void serialize(Date value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumMapSerializer.java\n     public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts)\n     {\n         return new EnumMapSerializer(_valueType, _staticTyping, _keyEnums, vts,  _property, _valueSerializer);\n+    }\n+\n+    @Override\n+    public boolean isEmpty(EnumMap<? extends Enum<?>,?> value) {\n+        return (value == null) || value.isEmpty();\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/EnumSetSerializer.java\n         // no typing for enums (always \"hard\" type)\n         return this;\n     }\n+\n+    @Override\n+    public boolean isEmpty(EnumSet<? extends Enum<?>> value) {\n+        return (value == null) || value.isEmpty();\n+    }\n     \n     @Override\n     public void serializeContents(EnumSet<? extends Enum<?>> value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/IterableSerializer.java\n     @Override\n     public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n         return new IterableSerializer(_elementType, _staticTyping, vts, _property);\n+    }\n+\n+    @Override\n+    public boolean isEmpty(Iterable<?> value) {\n+        // Not really good way to implement this, but has to do for now:\n+        return (value == null) || value.iterator().hasNext();\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/MapSerializer.java\n      */\n \n     @Override\n+    public boolean isEmpty(Map<?,?> value) {\n+        return (value == null) || value.isEmpty();\n+    }\n+    \n+    @Override\n     public void serialize(Map<?,?> value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ObjectArraySerializer.java\n     public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts)\n     {\n         return new ObjectArraySerializer(_elementType, _staticTyping, vts, _property, _elementSerializer);\n+    }\n+\n+    @Override\n+    public boolean isEmpty(Object[] value) {\n+        return (value == null) || (value.length == 0);\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StaticListSerializerBase.java\n /**\n  * Intermediate base class for Lists, Collections and Arrays\n  * that contain static (non-dynamic) value types.\n- * \n- * @since 1.7\n  */\n public abstract class StaticListSerializerBase<T extends Collection<?>>\n     extends SerializerBase<T>\n     {\n         super(cls, false);\n         _property = property;\n+    }\n+\n+    @Override\n+    public boolean isEmpty(T value) {\n+        return (value == null) || (value.size() == 0);\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdArraySerializers.java\n \n         /**\n          * Array-valued property being serialized with this instance\n-         * \n-         * @since 1.7\n          */\n         protected final BeanProperty _property;\n         \n         /**\n          * Value serializer to use, if it's not the standard one\n          * (if it is we can optimize serialization a lot)\n-         * \n-         * @since 1.7\n          */\n         protected JsonSerializer<Object> _elementSerializer;\n \n         @Override\n         public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n             return this;\n+        }\n+\n+        @Override\n+        public boolean isEmpty(String[] value) {\n+            return (value == null) || (value.length == 0);\n         }\n         \n         @Override\n          * we'll ignore it...\n          */\n         @Override\n-        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts)\n-        {\n+        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n             return this;\n+        }\n+\n+        @Override\n+        public boolean isEmpty(boolean[] value) {\n+            return (value == null) || (value.length == 0);\n         }\n         \n         @Override\n         public ByteArraySerializer() {\n             super(byte[].class);\n         }\n+\n+        @Override\n+        public boolean isEmpty(byte[] value) {\n+            return (value == null) || (value.length == 0);\n+        }\n         \n         @Override\n         public void serialize(byte[] value, JsonGenerator jgen, SerializerProvider provider)\n             return new ShortArraySerializer(vts);\n         }\n         \n+        @Override\n+        public boolean isEmpty(short[] value) {\n+            return (value == null) || (value.length == 0);\n+        }\n+\n         @SuppressWarnings(\"cast\")\n         @Override\n         public void serializeContents(short[] value, JsonGenerator jgen, SerializerProvider provider)\n         extends SerializerBase<char[]>\n     {\n         public CharArraySerializer() { super(char[].class); }\n+\n+        @Override\n+        public boolean isEmpty(char[] value) {\n+            return (value == null) || (value.length == 0);\n+        }\n         \n         @Override\n         public void serialize(char[] value, JsonGenerator jgen, SerializerProvider provider)\n          * we'll ignore it...\n          */\n         @Override\n-        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts)\n-        {\n+        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n             return this;\n         }        \n+\n+        @Override\n+        public boolean isEmpty(int[] value) {\n+            return (value == null) || (value.length == 0);\n+        }\n         \n         @Override\n         public void serializeContents(int[] value, JsonGenerator jgen, SerializerProvider provider)\n         public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n             return new LongArraySerializer(vts);\n         }\n+\n+        @Override\n+        public boolean isEmpty(long[] value) {\n+            return (value == null) || (value.length == 0);\n+        }\n         \n         @Override\n         public void serializeContents(long[] value, JsonGenerator jgen, SerializerProvider provider)\n         public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n             return new FloatArraySerializer(vts);\n         }\n-        \n+\n+        @Override\n+        public boolean isEmpty(float[] value) {\n+            return (value == null) || (value.length == 0);\n+        }\n+\n         @Override\n         public void serializeContents(float[] value, JsonGenerator jgen, SerializerProvider provider)\n             throws IOException, JsonGenerationException\n          * we'll ignore it...\n          */\n         @Override\n-        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts)\n-        {\n+        public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n             return this;\n         }\n+\n+        @Override\n+        public boolean isEmpty(double[] value) {\n+            return (value == null) || (value.length == 0);\n+        }\n         \n         @Override\n         public void serializeContents(double[] value, JsonGenerator jgen, SerializerProvider provider)\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdContainerSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdContainerSerializers.java\n             super(List.class, elemType, staticTyping, vts, property, valueSerializer);\n         }\n \n+        @Override\n+        public boolean isEmpty(List<?> value) {\n+            return (value == null) || value.isEmpty();\n+        }\n+        \n         @Override\n         public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n             return new IndexedListSerializer(_elementType, _staticTyping, vts, _property, _elementSerializer);\n         }\n \n         @Override\n+        public boolean isEmpty(Iterator<?> value) {\n+            return (value == null) || !value.hasNext();\n+        }\n+        \n+        @Override\n         public ContainerSerializerBase<?> _withValueTypeSerializer(TypeSerializer vts) {\n             return new IteratorSerializer(_elementType, _staticTyping, vts, _property);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringCollectionSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringCollectionSerializer.java\n  * may be overridde; because of this, logic is needed to ensure that the default\n  * serializer is in use to use fastest mode, or if not, to defer to custom\n  * String serializer.\n- * \n- * @since 1.7\n  */\n @JacksonStdImpl\n \n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StringSerializer.java\n {\n     public StringSerializer() { super(String.class); }\n \n+    /**\n+     * For Strings, both null and Empty String qualify for emptiness.\n+     */\n+    @Override\n+    public boolean isEmpty(String value) {\n+        return (value == null) || (value.length() == 0);\n+    }\n+    \n     @Override\n     public void serialize(String value, JsonGenerator jgen, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/ToStringSerializer.java\n      * {@link com.fasterxml.jackson.databind.annotation.JsonSerialize#using}.\n      */\n     public ToStringSerializer() { super(Object.class); }\n+\n+    @Override\n+    public boolean isEmpty(Object value) {\n+        if (value == null) {\n+            return true;\n+        }\n+        String str = value.toString();\n+        // would use String.isEmpty(), but that's JDK 1.6\n+        return (str == null) || (str.length() == 0);\n+    }\n     \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider)", "timestamp": 1326413381, "metainfo": ""}