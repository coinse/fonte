{"sha": "8ac635b4cdc251a48ad24c4ef6a3398ed4902f18", "log": "...", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/annotate/JsonCachable.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/annotate/JsonCachable.java\n  * Default action to take in absence of annotation depends\n  * on object using annotation; with deserializers default is\n  * to assume instances are not cachable.\n- *\n- * @since 1.1\n  */\n @Target({ElementType.TYPE})\n @Retention(RetentionPolicy.RUNTIME)\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/AbstractDeserializer.java\n import com.fasterxml.jackson.core.type.JavaType;\n import com.fasterxml.jackson.databind.*;\n \n-\n /**\n  * Deserializer only used for abstract types used as placeholders during polymorphic\n  * type handling deserialization. If so, there is no real deserializer associated\n  * pass such resolver will result in an error.\n  * \n  * @author tatu\n- * \n- * @since 1.6\n  */\n public class AbstractDeserializer\n     extends JsonDeserializer<Object>\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorProperty.java\n import java.io.IOException;\n import java.lang.annotation.Annotation;\n \n-import org.codehaus.jackson.JsonParser;\n-import org.codehaus.jackson.JsonProcessingException;\n-import org.codehaus.jackson.type.JavaType;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n-import com.fasterxml.jackson.core.util.TokenBuffer;\n+\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.deser.SettableBeanProperty;\n-\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n \n /**\n  * Helper class that is used to flatten JSON structure when using\n  * This is needed to store temporary state and buffer tokens, as the structure is\n  * rearranged a bit so that actual type deserializer can resolve type and \n  * finalize deserialization.\n- * \n- * @since 1.9\n  */\n public class ExternalTypeHandler\n {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/DateDeserializer.java\n import java.io.IOException;\n import java.util.Date;\n \n-import org.codehaus.jackson.JsonProcessingException;\n-import org.codehaus.jackson.JsonParser;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n \n  * One way to customize Date formats accepted is to override method\n  * {@link DeserializationContext#parseDate} that this basic\n  * deserializer calls.\n- * \n- * @since 1.9 (moved from higher-level package)\n  */\n public class DateDeserializer\n     extends StdScalarDeserializer<Date>\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n import java.io.IOException;\n import java.util.*;\n \n-import org.codehaus.jackson.JsonProcessingException;\n-import org.codehaus.jackson.JsonParser;\n-import org.codehaus.jackson.JsonToken;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.TypeDeserializer;\n--- a/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java\n package com.fasterxml.jackson.databind.exc;\n \n-import org.codehaus.jackson.JsonLocation;\n-import org.codehaus.jackson.JsonParser;\n-\n+import com.fasterxml.jackson.core.JsonLocation;\n+import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.databind.JsonMappingException;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/DOMSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/DOMSerializer.java\n import  org.w3c.dom.ls.DOMImplementationLS;\n import  org.w3c.dom.ls.LSSerializer;\n \n-import org.codehaus.jackson.JsonGenerationException;\n-import org.codehaus.jackson.JsonGenerator;\n-import org.codehaus.jackson.JsonNode;\n+import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.ser.std.SerializerBase;\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ArrayType.java\n         _emptyArray = emptyInstance;\n     }\n \n-    /**\n-     * @deprecated Since 1.9, if you must directly instantiate,\n-     *  call method that takes handlers\n-     */\n-    @Deprecated\n-    public static ArrayType construct(JavaType componentType)\n-    {\n-        return construct(componentType, null, null);\n-    }                                   \n-\n     public static ArrayType construct(JavaType componentType,\n             Object valueHandler, Object typeHandler)\n     {\n         return new ArrayType(componentType, emptyInstance, null, null);\n     }                                   \n     \n-    // Since 1.7:\n     @Override\n     public ArrayType withTypeHandler(Object h)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\n public final class TypeFactory\n {\n     /**\n-     * Globally shared singleton. Should never be accessed directly; non-core\n+     * Globally shared singleton. Not accessed directly; non-core\n      * code should use per-ObjectMapper instance (via configuration objects).\n      * Core Jackson code uses {@link #defaultInstance} for accessing it.\n-     * \n-     * @deprecated As of 1.8, should use a per-ObjectMapper instance instead\n-     *    of global singleton\n-     */\n-    @Deprecated\n-    public final static TypeFactory instance = new TypeFactory();\n+     */\n+    protected final static TypeFactory instance = new TypeFactory();\n \n     private final static JavaType[] NO_TYPES = new JavaType[0];\n \n     /**\n      * Registered {@link TypeModifier}s: objects that can change details\n      * of {@link JavaType} instances factory constructs.\n-     * \n-     * @since 1.8\n      */\n     protected final TypeModifier[] _modifiers;\n     \n     /**\n      * Lazily constructed copy of type hierarchy from {@link java.util.HashMap}\n      * to its supertypes.\n-     * \n-     * @since 1.9\n      */\n     protected HierarchicType _cachedHashMapType;\n \n     /**\n      * Lazily constructed copy of type hierarchy from {@link java.util.ArrayList}\n      * to its supertypes.\n-     * \n-     * @since 1.9\n      */\n     protected HierarchicType _cachedArrayListType;\n     \n      * Method used to access the globally shared instance, which has\n      * no custom configuration. Used by <code>ObjectMapper</code> to\n      * get the default factory when constructed.\n-     * \n-     * @since 1.8\n      */\n     public static TypeFactory defaultInstance() { return instance; }\n \n         return defaultInstance().constructType(t).getRawClass();\n     }\n     \n-    /*\n-    /**********************************************************\n-    /* Legacy factory methods (pre-1.8)\n-    /**********************************************************\n-     */\n-\n-    @Deprecated\n-    public static JavaType type(Type t) {\n-        return instance._constructType(t, null);\n-    }\n-\n-    @Deprecated\n-    public static JavaType type(Type type, Class<?> context) {\n-        return instance.constructType(type, context);\n-    }\n-\n-    @Deprecated\n-    public static JavaType type(Type type, JavaType context) {\n-        return instance.constructType(type, context);\n-    }\n-    \n-    @Deprecated\n-    public static JavaType type(Type type, TypeBindings bindings) {\n-        return instance._constructType(type, bindings);\n-    }\n-\n-    @Deprecated\n-    public static JavaType type(TypeReference<?> ref) {\n-        return instance.constructType(ref.getType());\n-    }\n-    \n-    @Deprecated\n-    public static JavaType arrayType(Class<?> elementType) {\n-        return instance.constructArrayType(instance.constructType(elementType));\n-    }\n-\n-    @Deprecated\n-    public static JavaType arrayType(JavaType elementType) {\n-        return instance.constructArrayType(elementType);\n-    }\n-\n-    @Deprecated\n-    public static JavaType collectionType(Class<? extends Collection> collectionType, Class<?> elementType) {\n-        return instance.constructCollectionType(collectionType, instance.constructType(elementType));\n-    }\n-    \n-    @Deprecated\n-    public static JavaType collectionType(Class<? extends Collection> collectionType, JavaType elementType) {\n-        return instance.constructCollectionType(collectionType, elementType);\n-    }\n-    \n-    @Deprecated\n-    public static JavaType mapType(Class<? extends Map> mapClass, Class<?> keyType, Class<?> valueType)\n-    {\n-        return instance.constructMapType(mapClass, type(keyType), instance.constructType(valueType));\n-    }\n-\n-    @Deprecated\n-    public static JavaType mapType(Class<? extends Map> mapType, JavaType keyType, JavaType valueType) {\n-        return instance.constructMapType(mapType, keyType, valueType);\n-    }\n-\n-    @Deprecated\n-    public static JavaType parametricType(Class<?> parametrized, Class<?>... parameterClasses) {\n-        return instance.constructParametricType(parametrized, parameterClasses);\n-    }\n-    \n-    @Deprecated\n-    public static JavaType parametricType(Class<?> parametrized, JavaType... parameterTypes) {\n-        return instance.constructParametricType(parametrized, parameterTypes);\n-    }\n-\n     public static JavaType fromCanonical(String canonical) throws IllegalArgumentException {\n         return instance.constructFromCanonical(canonical);\n     }\n     \n-    @Deprecated\n-    public static JavaType specialize(JavaType baseType, Class<?> subclass) {\n-        return instance.constructSpecializedType(baseType, subclass);\n-    }\n-    \n-    @Deprecated\n-    public static JavaType fastSimpleType(Class<?> cls) {\n-        return instance.uncheckedSimpleType(cls);\n-    }\n-\n-    @Deprecated\n-    public static JavaType[] findParameterTypes(Class<?> clz, Class<?> expType) {\n-        return instance.findTypeParameters(clz, expType);\n-    }\n-\n-    @Deprecated\n-    public static JavaType[] findParameterTypes(Class<?> clz, Class<?> expType, TypeBindings bindings) {\n-        return instance.findTypeParameters(clz, expType, bindings);\n-    }\n-\n-    @Deprecated\n-    public static JavaType[] findParameterTypes(JavaType type, Class<?> expType) {\n-        return instance.findTypeParameters(type, expType);\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Legacy methods\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * Factory method that can be used if only type information\n-     * available is of type {@link Class}. This means that there\n-     * will not be generic type information due to type erasure,\n-     * but at least it will be possible to recognize array\n-     * types and non-typed container types.\n-     * And for other types (primitives/wrappers, beans), this\n-     * is all that is needed.\n-     *\n-     * @deprecated Use {@link #type(Type)} instead\n-     */\n-    @Deprecated\n-    public static JavaType fromClass(Class<?> clz)\n-    {\n-        return instance._fromClass(clz, null);\n-    }\n-\n-    /**\n-     * Factory method that can be used if the full generic type has\n-     * been passed using {@link TypeReference}. This only needs to be\n-     * done if the root type to bind to is generic; but if so,\n-     * it must be done to get proper typing.\n-     *\n-     * @deprecated Use {@link #type(Type)} instead\n-     */\n-    @Deprecated\n-    public static JavaType fromTypeReference(TypeReference<?> ref)\n-    {\n-        return type(ref.getType());\n-    }\n-\n-    /**\n-     * Factory method that can be used if type information is passed\n-     * as Java typing returned from <code>getGenericXxx</code> methods\n-     * (usually for a return or argument type).\n-     *\n-     * @deprecated Use {@link #type(Type)} instead\n-     */\n-    @Deprecated\n-    public static JavaType fromType(Type type)\n-    {\n-        return instance._constructType(type, null);\n-    }\n-\n     /*\n     /**********************************************************\n     /* Type conversion, parameterization resolution methods\n--- a/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/ClassUtil.java\n         // Anything else? Seems valid, then\n         return null;\n     }\n-\n-    /**\n-     * @deprecated since 1.9, use variant that takes second argument\n-     */\n-    @Deprecated\n-    public static String isLocalType(Class<?> type) {\n-        return isLocalType(type, false);\n-    }\n-    \n-    /**\n-     * @since 1.9\n-     */\n+    \n     public static String isLocalType(Class<?> type, boolean allowNonStatic)\n     {\n         /* As per [JACKSON-187], GAE seems to throw SecurityExceptions\n--- a/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/EnumValues.java\n         throw new IllegalArgumentException(\"Can not determine enum constants for Class \"+enumClass.getName());\n     }\n \n-    /**\n-     * @deprecated since 1.7, use {@link #serializedValueFor} instead\n-     */\n-    @Deprecated\n-    public String valueFor(Enum<?> key)\n-    {\n-        SerializedString sstr = _values.get(key);\n-        return (sstr == null) ? null : sstr.getValue();\n-    }\n-\n     public SerializedString serializedValueFor(Enum<?> key)\n     {\n         return _values.get(key);\n--- a/src/main/java/com/fasterxml/jackson/databind/util/JSONPObject.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/JSONPObject.java\n import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * Container class that can be used to wrap any Object instances (including\n  * @see com.fasterxml.jackson.databind.util.JSONWrappedObject\n  * \n  * @author tatu\n- * @since 1.5\n  */\n public class JSONPObject\n     implements JsonSerializableWithType\n         _function = function;\n         _value = value;\n         _serializationType = asType;\n-    }\n-\n-    /**\n-     * @deprecated Since 1.8; instead use variant that takes JavaType: this ensures\n-     *    that type information is properly resolved\n-     */\n-    @Deprecated\n-    public JSONPObject(String function, Object value, Class<?> rawType) {\n-        _function = function;\n-        _value = value;\n-        _serializationType = (rawType == null) ? null : TypeFactory.defaultInstance().constructType(rawType);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/util/JSONWrappedObject.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/JSONWrappedObject.java\n import com.fasterxml.jackson.core.type.JavaType;\n \n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.type.TypeFactory;\n \n /**\n  * General-purpose wrapper class that can be used to decorate serialized\n  * @see com.fasterxml.jackson.databind.util.JSONPObject\n  * \n  * @author tatu\n- * @since 1.5\n  */\n public class JSONWrappedObject\n     implements JsonSerializableWithType\n         _suffix = suffix;\n         _value = value;\n         _serializationType = asType;\n-    }\n-\n-    /**\n-     * @deprecated Since 1.8; should construct with resolved <code>JavaType</code>,\n-     *   to ensure type has been properly resolved\n-     */\n-    @Deprecated\n-    public JSONWrappedObject(String prefix, String suffix, Object value, Class<?> rawType) {\n-        _prefix = prefix;\n-        _suffix = suffix;\n-        _value = value;\n-        _serializationType = (rawType == null) ? null : TypeFactory.defaultInstance().constructType(rawType);\n     }\n     \n     /*", "timestamp": 1324659939, "metainfo": ""}