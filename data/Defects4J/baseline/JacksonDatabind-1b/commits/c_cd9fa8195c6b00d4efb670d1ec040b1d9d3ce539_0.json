{"sha": "cd9fa8195c6b00d4efb670d1ec040b1d9d3ce539", "log": "Merge pull request #207 from msteiger/master  Support for datatype short", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonNode.java\n \n     /**\n      * Method that can be used to check whether contained value\n+     * is a number represented as Java <code>short</code>.\n+     * Note, however, that even if this method returns false, it\n+     * is possible that conversion would be possible from other numeric\n+     * types -- to check if this is possible, use\n+     * {@link #canConvertToInt()} instead.\n+     * \n+     * @return True if the value contained by this node is stored as Java short\n+     */\n+    public boolean isShort() { return false; }\n+\n+    /**\n+     * Method that can be used to check whether contained value\n      * is a number represented as Java <code>int</code>.\n      * Note, however, that even if this method returns false, it\n      * is possible that conversion would be possible from other numeric\n      *   nodes).\n      */\n     public Number numberValue() { return null; }\n+\n+    /**\n+     * Returns 16-bit short value for this node, <b>if and only if</b>\n+     * this node is numeric ({@link #isNumber} returns true). For other\n+     * types returns 0.\n+     * For floating-point numbers, value is truncated using default\n+     * Java coercion, similar to how cast from double to short operates.\n+     *\n+     * @return Short value this node contains, if any; 0 for non-number\n+     *   nodes.\n+     */\n+    public short shortValue() { return 0; }\n \n     /**\n      * Returns integer value for this node, <b>if and only if</b>\n--- a/src/main/java/com/fasterxml/jackson/databind/node/BigIntegerNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/BigIntegerNode.java\n     }\n \n     @Override\n+    public short shortValue() { return _value.shortValue(); }\n+\n+    @Override\n     public int intValue() { return _value.intValue(); }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/node/DecimalNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/DecimalNode.java\n     public Number numberValue() { return _value; }\n \n     @Override\n+    public short shortValue() { return _value.shortValue(); }\n+\n+    @Override\n     public int intValue() { return _value.intValue(); }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/node/DoubleNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/DoubleNode.java\n     }\n \n     @Override\n+    public short shortValue() { return (short) _value; }\n+\n+    @Override\n     public int intValue() { return (int) _value; }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/node/FloatNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/FloatNode.java\n  * \n  * @since 2.2\n  */\n-public class FloatNode extends NumericNode\n+public final class FloatNode extends NumericNode\n {\n     protected final float _value;\n \n     public Number numberValue() {\n         return Float.valueOf(_value);\n     }\n+\n+    @Override\n+    public short shortValue() { return (short) _value; }\n \n     @Override\n     public int intValue() { return (int) _value; }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/IntNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/IntNode.java\n     }\n \n     @Override\n+    public short shortValue() { return (short) _value; }\n+\n+    @Override\n     public int intValue() { return _value; }\n \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/JsonNodeFactory.java\n      * Factory method for getting an instance of JSON numeric value\n      * that expresses given 16-bit integer value\n      */\n-    public NumericNode numberNode(short v) { return IntNode.valueOf(v); }\n+    public NumericNode numberNode(short v) { return ShortNode.valueOf(v); }\n \n     /**\n      * Alternate factory method that will handle wrapper value, which may\n      * {@link NumericNode}, but just {@link ValueNode}.\n      */\n     public ValueNode numberNode(Short value) {\n-        return (value == null) ? nullNode() : IntNode.valueOf(value.shortValue());\n+        return (value == null) ? nullNode() : ShortNode.valueOf(value);\n     }\n     \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/node/LongNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/LongNode.java\n     }\n \n     @Override\n+    public short shortValue() { return (short) _value; }\n+\n+    @Override\n     public int intValue() { return (int) _value; }\n \n     @Override\n     public long longValue() { return _value; }\n \n     @Override\n-    public double doubleValue() { return (double) _value; }\n+    public float floatValue() { return _value; }\n+\n+    @Override\n+    public double doubleValue() { return _value; }\n \n     @Override\n     public BigDecimal decimalValue() { return BigDecimal.valueOf(_value); }\n--- a/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ObjectNode.java\n      * \n      * @return This node (to allow chaining)\n      */\n+    public ObjectNode put(String fieldName, short v) {\n+        _children.put(fieldName, numberNode(v));\n+        return this;\n+    }\n+\n+    /**\n+     * Alternative method that we need to avoid bumping into NPE issues\n+     * with auto-unboxing.\n+     * \n+     * @return This node (to allow chaining)\n+     */\n+    public ObjectNode put(String fieldName, Short value) {\n+        if (value == null) {\n+            _children.put(fieldName, nullNode());\n+        } else {\n+            _children.put(fieldName, numberNode(value.shortValue()));\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Method for setting value of a field to specified numeric value.\n+     * \n+     * @return This node (to allow chaining)\n+     */\n     public ObjectNode put(String fieldName, int v) {\n         _children.put(fieldName, numberNode(v));\n         return this;\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/ShortNode.java\n+package com.fasterxml.jackson.databind.node;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.core.io.NumberOutput;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+\n+\n+/**\n+ * Numeric node that contains simple 16-bit integer values.\n+ */\n+public final class ShortNode\n+    extends NumericNode\n+{\n+    final short _value;\n+\n+    /* \n+    ************************************************\n+    * Construction\n+    ************************************************\n+    */\n+\n+    public ShortNode(short v) { _value = v; }\n+\n+    public static ShortNode valueOf(short l) { return new ShortNode(l); }\n+\n+    /* \n+    ************************************************\n+    * Overridden JsonNode methods\n+    ************************************************\n+    */\n+\n+    @Override public JsonToken asToken() { return JsonToken.VALUE_NUMBER_INT; }\n+\n+    @Override\n+    public JsonParser.NumberType numberType() { return JsonParser.NumberType.INT; }\t\t\t// should be SHORT\n+\n+\n+    @Override\n+    public boolean isIntegralNumber() { return true; }\n+\n+    @Override\n+    public boolean isShort() { return true; }\n+\n+    @Override public boolean canConvertToInt() { return true; }\n+    @Override public boolean canConvertToLong() { return true; }\n+    \n+    @Override\n+    public Number numberValue() {\n+        return Short.valueOf(_value);\n+    }\n+\n+    @Override\n+    public short shortValue() { return _value; }\n+\n+    @Override\n+    public int intValue() { return _value; }\n+\n+    @Override\n+    public long longValue() { return _value; }\n+\n+    @Override\n+    public float floatValue() { return _value; }\n+\n+    @Override\n+    public double doubleValue() { return _value; }\n+\n+    @Override\n+    public BigDecimal decimalValue() { return BigDecimal.valueOf(_value); }\n+\n+    @Override\n+    public BigInteger bigIntegerValue() { return BigInteger.valueOf(_value); }\n+\n+    @Override\n+    public String asText() {\n+        return NumberOutput.toString(_value);\n+    }\n+\n+    @Override\n+    public boolean asBoolean(boolean defaultValue) {\n+        return _value != 0;\n+    }\n+    \n+    @Override\n+    public final void serialize(JsonGenerator jg, SerializerProvider provider)\n+        throws IOException, JsonProcessingException\n+    {\n+        jg.writeNumber(_value);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o)\n+    {\n+        if (o == this) return true;\n+        if (o == null) return false;\n+        if (o.getClass() != getClass()) { // final class, can do this\n+            return false;\n+        }\n+        return ((ShortNode) o)._value == _value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return _value;\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializers.java\n         allDeserializers.put(Long.TYPE.getName(), LongSerializer.instance);\n         allDeserializers.put(Byte.class.getName(), IntLikeSerializer.instance);\n         allDeserializers.put(Byte.TYPE.getName(), IntLikeSerializer.instance);\n-        allDeserializers.put(Short.class.getName(), IntLikeSerializer.instance);\n-        allDeserializers.put(Short.TYPE.getName(), IntLikeSerializer.instance);\n+        allDeserializers.put(Short.class.getName(), ShortSerializer.instance);\n+        allDeserializers.put(Short.TYPE.getName(), ShortSerializer.instance);\n \n         // Numbers, limited length floating point\n         allDeserializers.put(Float.class.getName(), FloatSerializer.instance);\n     /**********************************************************\n      */\n \n+    @JacksonStdImpl\n+    public final static class ShortSerializer\n+        extends StdScalarSerializer<Short>\n+    {\n+        final static ShortSerializer instance = new ShortSerializer();\n+    \n+        public ShortSerializer() { super(Short.class); }\n+        \n+        @Override\n+        public void serialize(Short value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException, JsonGenerationException\n+        {\n+            jgen.writeNumber(value.shortValue());\n+        }\n+    \n+        @Override\n+        public JsonNode getSchema(SerializerProvider provider, Type typeHint)\n+        {\n+            return createSchemaNode(\"number\", true);\t\t// msteiger: maybe \"integer\" or \"short\" ?\n+        }\n+        \n+        @Override\n+        public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n+                throws JsonMappingException\n+        {\n+            JsonIntegerFormatVisitor v2 = visitor.expectIntegerFormat(typeHint);\n+            if (v2 != null) {\n+                v2.numberType(JsonParser.NumberType.INT);\t\t\t// should be SHORT\n+            }\n+        }\n+    }\n+    \n     /**\n      * This is the special serializer for regular {@link java.lang.Integer}s\n      * (and primitive ints)\n--- a/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/TokenBuffer.java\n     /* JsonGenerator implementation: write methods, primitive types\n     /**********************************************************\n      */\n+\n+    @Override\n+    public void writeNumber(short i) throws IOException, JsonGenerationException {\n+        _append(JsonToken.VALUE_NUMBER_INT, Short.valueOf(i));\n+    }\n \n     @Override\n     public void writeNumber(int i) throws IOException, JsonGenerationException {\n         public NumberType getNumberType() throws IOException, JsonParseException\n         {\n             Number n = getNumberValue();\n+            if (n instanceof Short) return NumberType.INT;\t\t// should be SHORT\n             if (n instanceof Integer) return NumberType.INT;\n             if (n instanceof Long) return NumberType.LONG;\n             if (n instanceof Double) return NumberType.DOUBLE;\n--- a/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n \n         @Override\n         public void writeNull() throws IOException, JsonGenerationException { }\n+\n+        @Override\n+        public void writeNumber(short v) throws IOException { }\n \n         @Override\n         public void writeNumber(int v) throws IOException { }\n--- a/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/node/TestNumberNodes.java\n  */\n public class TestNumberNodes extends NodeTestBase\n {\n-    public void testInt()\n+    public void testShort()\n+    {\n+        ShortNode n = ShortNode.valueOf((short) 1);\n+        assertStandardEquals(n);\n+        assertTrue(0 != n.hashCode());\n+        assertEquals(JsonToken.VALUE_NUMBER_INT, n.asToken());\n+        assertEquals(JsonParser.NumberType.INT, n.numberType());\t// should be SHORT\n+        assertEquals(1, n.intValue());\n+        assertEquals(1L, n.longValue());\n+        assertEquals(BigDecimal.ONE, n.decimalValue());\n+        assertEquals(BigInteger.ONE, n.bigIntegerValue());\n+        assertEquals(\"1\", n.asText());\n+\n+        assertNodeNumbers(n, 1, 1.0);\n+\n+        assertTrue(ShortNode.valueOf((short) 0).canConvertToInt());\n+        assertTrue(ShortNode.valueOf(Short.MAX_VALUE).canConvertToInt());\n+        assertTrue(ShortNode.valueOf(Short.MIN_VALUE).canConvertToInt());\n+\n+        assertTrue(ShortNode.valueOf((short) 0).canConvertToLong());\n+        assertTrue(ShortNode.valueOf(Short.MAX_VALUE).canConvertToLong());\n+        assertTrue(ShortNode.valueOf(Short.MIN_VALUE).canConvertToLong());\n+    }\n+    \n+\tpublic void testInt()\n     {\n         IntNode n = IntNode.valueOf(1);\n         assertStandardEquals(n);\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationFeature.java\n      * Feature is disabled by default.\n      */\n     ACCEPT_SINGLE_VALUE_AS_ARRAY(false),\n-    \n+\n     /**\n      * Feature to allow \"unwrapping\" root-level JSON value, to match setting of\n      * {@link SerializationFeature#WRAP_ROOT_VALUE} used for serialization.\n      */\n     READ_UNKNOWN_ENUM_VALUES_AS_NULL(false),\n \n+    /**\n+     * Feature that controls whether numeric timestamp values are expected\n+     * to be written using nanosecond timestamps (enabled) or not (disabled),\n+     * <b>if and only if</b> datatype supports such resolution.\n+     * Only newer datatypes (such as Java8 Date/Time) support such resolution --\n+     * older types (pre-Java8 <b>java.util.Date</b> etc) and Joda do not --\n+     * and this setting <b>has no effect</b> on such types.\n+     *<p>\n+     * If disabled, standard millisecond timestamps are assumed.\n+     * This is the counterpart to {@link SerializationFeature#WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS}.\n+     *<p>\n+     * Feature is enabled by default, to support most accurate time values possible.\n+     * \n+     * @since 2.2\n+     */\n+    READ_DATE_TIMESTAMPS_AS_NANOSECONDS(true),\n+\n+    /**\n+     * Feature that specifies whether context provided {@link java.util.TimeZone}\n+     * ({@link DeserializationContext#getTimeZone()} should be used to adjust Date/Time\n+     * values on deserialization, even if value itself contains timezone information.\n+     * If enabled, contextual <code>TimeZone</code> will essentially override any other\n+     * TimeZone information; if disabled, it will only be used if value itself does not\n+     * contain any TimeZone information.\n+     * \n+     * @since 2.2\n+     */\n+    ADJUST_DATES_TO_CONTEXT_TIME_ZONE(true),\n+\n     /*\n     /******************************************************\n     /* Other\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\n     \n     /*\n     /**********************************************************\n-    /* Module registration\n+    /* Module registration, discovery\n     /**********************************************************\n      */\n \n         return this;\n     }\n \n+    /**\n+     * Convenience method for registering specified modules in order;\n+     * functionally equivalent to:\n+     *<pre>\n+     *   for (Module module : modules) {\n+     *      registerModule(module);\n+     *   }\n+     *</pre>\n+     * \n+     * @since 2.2\n+     */\n+    public ObjectMapper registerModules(Module... modules)\n+    {\n+        for (Module module : modules) {\n+            registerModule(module);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Convenience method for registering specified modules in order;\n+     * functionally equivalent to:\n+     *<pre>\n+     *   for (Module module : modules) {\n+     *      registerModule(module);\n+     *   }\n+     *</pre>\n+     * \n+     * @since 2.2\n+     */\n+    public ObjectMapper registerModules(Iterable<Module> modules)\n+    {\n+        for (Module module : modules) {\n+            registerModule(module);\n+        }\n+        return this;\n+    }\n+    \n+    /**\n+     * Method for locating available methods, using JDK {@link ServiceLoader}\n+     * facility, along with module-provided SPI.\n+     *<p>\n+     * Note that method does not do any caching, so calls should be considered\n+     * potentially expensive.\n+     * \n+     * @since 2.2\n+     */\n+    public List<Module> findModules() {\n+        return findModules(null);\n+    }\n+\n+    /**\n+     * Method for locating available methods, using JDK {@link ServiceLoader}\n+     * facility, along with module-provided SPI.\n+     *<p>\n+     * Note that method does not do any caching, so calls should be considered\n+     * potentially expensive.\n+     * \n+     * @since 2.2\n+     */\n+    public List<Module> findModules(ClassLoader classLoader)\n+    {\n+        ArrayList<Module> modules = new ArrayList<Module>();\n+        ServiceLoader<Module> loader = (classLoader == null) ?\n+                ServiceLoader.load(Module.class) : ServiceLoader.load(Module.class, classLoader);\n+        for (Module module : loader) {\n+            modules.add(module);\n+        }\n+        return modules;\n+    }\n+\n+    /**\n+     * Convenience method that is functionally equivalent to:\n+     *<code>\n+     *   mapper.registerModules(mapper.findModules());\n+     *<code>\n+     *<p>\n+     * As with {@link #findModules()}, no caching is done for modules, so care\n+     * needs to be taken to either create and share a single mapper instance;\n+     * or to cache introspected set of modules.\n+     *\n+     * @since 2.2\n+     */\n+    public ObjectMapper findAndRegisterModules() {\n+        return registerModules(findModules());\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Configuration: main config object access\n      * @param schema Schema to pass to generator\n      */\n     public ObjectWriter writer(FormatSchema schema) {\n+        _verifySchemaType(schema);\n         return new ObjectWriter(this, getSerializationConfig(), schema);\n     }\n \n      * @param schema Schema to pass to parser\n      */\n     public ObjectReader reader(FormatSchema schema) {\n+        _verifySchemaType(schema);\n         return new ObjectReader(this, getDeserializationConfig(), null, null,\n                 schema, _injectableValues);\n     }\n      * for deserializing a single root value.\n      * Can be overridden if a custom context is needed.\n      */\n-    protected final DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n+    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n             DeserializationConfig cfg)\n     {\n         return _deserializationContext.createInstance(cfg,\n         _rootDeserializers.put(valueType, deser);\n         return deser;\n     }\n+\n+    /**\n+     * @since 2.2\n+     */\n+    protected void _verifySchemaType(FormatSchema schema)\n+    {\n+        if (schema != null) {\n+            if (!_jsonFactory.canUseSchema(schema)) {\n+                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n+                            +\" for format \"+_jsonFactory.getFormatName());\n+            }\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n     public ObjectReader withRootName(String rootName) {\n         return _with(_config.withRootName(rootName));\n     }\n-    \n+\n     /**\n      * Method for constructing a new instance with configuration that\n      * passes specified {@link FormatSchema} to {@link JsonParser} that\n         if (_schema == schema) {\n             return this;\n         }\n+        _verifySchemaType(schema);\n         return new ObjectReader(this, _config, _valueType, _rootDeserializer, _valueToUpdate,\n                 schema, _injectableValues, _dataFormatReaders);\n     }\n     /**\n      * Method called to locate deserializer for the passed root-level value.\n      */\n-    protected final JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n+    protected JsonDeserializer<Object> _findRootDeserializer(DeserializationContext ctxt,\n             JavaType valueType)\n         throws JsonMappingException\n     {\n      * by configuration. Method also is NOT to throw an exception if\n      * access fails.\n      */\n-    protected final JsonDeserializer<Object> _prefetchRootDeserializer(\n+    protected JsonDeserializer<Object> _prefetchRootDeserializer(\n             DeserializationConfig config, JavaType valueType)\n     {\n         if (valueType == null || !_config.isEnabled(DeserializationFeature.EAGER_DESERIALIZER_FETCH)) {\n      */\n \n     /**\n+     * @since 2.2\n+     */\n+    protected void _verifySchemaType(FormatSchema schema)\n+    {\n+        if (schema != null) {\n+            if (!_jsonFactory.canUseSchema(schema)) {\n+                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n+                            +\" for format \"+_jsonFactory.getFormatName());\n+            }\n+        }\n+    }\n+\n+    /**\n      * Internal helper method called to create an instance of {@link DeserializationContext}\n      * for deserializing a single root value.\n      * Can be overridden if a custom context is needed.\n      */\n-    protected final DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n+    protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n             DeserializationConfig cfg) {\n         // 04-Jan-2010, tatu: we do actually need the provider too... (for polymorphic deser)\n         return _context.createInstance(cfg, jp, _injectableValues);\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectWriter.java\n     \n     public ObjectWriter withSchema(FormatSchema schema)\n     {\n-        return (_schema == schema) ? this :\n-            new ObjectWriter(this, _config, _rootType, _rootSerializer, _prettyPrinter, schema);\n-    }\n-    \n+        if (_schema == schema) {\n+            return this;\n+        }\n+        _verifySchemaType(schema);\n+        return new ObjectWriter(this, _config, _rootType, _rootSerializer, _prettyPrinter, schema);\n+    }\n+\n     /**\n      * Method that will construct a new instance that uses specific type\n      * as the root type for serialization, instead of runtime dynamic\n     /* Internal methods\n     /**********************************************************\n      */\n-    \n+\n+    /**\n+     * @since 2.2\n+     */\n+    protected void _verifySchemaType(FormatSchema schema)\n+    {\n+        if (schema != null) {\n+            if (!_jsonFactory.canUseSchema(schema)) {\n+                    throw new IllegalArgumentException(\"Can not use FormatSchema of type \"+schema.getClass().getName()\n+                            +\" for format \"+_jsonFactory.getFormatName());\n+            }\n+        }\n+    }\n+\n     /**\n      * Method called to configure the generator as necessary and then\n      * call write functionality\n      * by configuration. Method also is NOT to throw an exception if\n      * access fails.\n      */\n-    protected final JsonSerializer<Object> _prefetchRootSerializer(\n+    protected JsonSerializer<Object> _prefetchRootSerializer(\n             SerializationConfig config, JavaType valueType)\n     {\n         if (valueType == null || !_config.isEnabled(SerializationFeature.EAGER_SERIALIZER_FETCH)) {\n      * \n      * @since 2.1\n      */\n-    private final void _configureJsonGenerator(JsonGenerator jgen)\n+    private void _configureJsonGenerator(JsonGenerator jgen)\n     {\n         if (_prettyPrinter != null) {\n             PrettyPrinter pp = _prettyPrinter;\n--- a/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/SerializationFeature.java\n     \n     /*\n     /******************************************************\n-    /*  Error handling features\n+    /* Error handling features\n     /******************************************************\n      */\n     \n     WRITE_BIGDECIMAL_AS_PLAIN(false),\n     \n     /**\n+     * Feature that controls whether numeric timestamp values are\n+     * to be written using nanosecond timestamps (enabled) or not (disabled);\n+     * <b>if and only if</b> datatype supports such resolution.\n+     * Only newer datatypes (such as Java8 Date/Time) support such resolution --\n+     * older types (pre-Java8 <b>java.util.Date</b> etc) and Joda do not --\n+     * and this setting <b>has no effect</b> on such types.\n+     *<p>\n+     * If disabled, standard millisecond timestamps are assumed.\n+     * This is the counterpart to {@link SerializationFeature#WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS}.\n+     *<p>\n+     * Feature is enabled by default, to support most accurate time values possible.\n+     * \n+     * @since 2.2\n+     */\n+    WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS(true),    \n+    \n+    /**\n      * Feature that determines whether {@link java.util.Map} entries are first\n      * sorted by key before serialization or not: if enabled, additional sorting\n      * step is performed if necessary (not necessary for {@link java.util.SortedMap}s),\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializerFactoryConfig.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/DeserializerFactoryConfig.java\n \n import com.fasterxml.jackson.databind.AbstractTypeResolver;\n import com.fasterxml.jackson.databind.deser.*;\n+import com.fasterxml.jackson.databind.deser.std.StdKeyDeserializers;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n \n /**\n     private static final long serialVersionUID = 3683541151102256824L;\n \n     protected final static Deserializers[] NO_DESERIALIZERS = new Deserializers[0];\n-    protected final static KeyDeserializers[] NO_KEY_DESERIALIZERS = new KeyDeserializers[0];\n     protected final static BeanDeserializerModifier[] NO_MODIFIERS = new BeanDeserializerModifier[0];\n     protected final static AbstractTypeResolver[] NO_ABSTRACT_TYPE_RESOLVERS = new AbstractTypeResolver[0];\n     protected final static ValueInstantiators[] NO_VALUE_INSTANTIATORS = new ValueInstantiators[0];\n+\n+    /**\n+     * By default we plug default key deserializers using as \"just another\" set of\n+     * of key deserializers.\n+     * \n+     * @since 2.2\n+     */\n+    protected final static KeyDeserializers[] DEFAULT_KEY_DESERIALIZERS = new KeyDeserializers[] {\n+        new StdKeyDeserializers()\n+    };\n     \n     /**\n      * List of providers for additional deserializers, checked before considering default\n         _additionalDeserializers = (allAdditionalDeserializers == null) ?\n                 NO_DESERIALIZERS : allAdditionalDeserializers;\n         _additionalKeyDeserializers = (allAdditionalKeyDeserializers == null) ?\n-                NO_KEY_DESERIALIZERS : allAdditionalKeyDeserializers;\n+                DEFAULT_KEY_DESERIALIZERS : allAdditionalKeyDeserializers;\n         _modifiers = (modifiers == null) ? NO_MODIFIERS : modifiers;\n         _abstractTypeResolvers = (atr == null) ? NO_ABSTRACT_TYPE_RESOLVERS : atr;\n         _valueInstantiators = (vi == null) ? NO_VALUE_INSTANTIATORS : vi;\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n import com.fasterxml.jackson.databind.cfg.HandlerInstantiator;\n import com.fasterxml.jackson.databind.deser.impl.CreatorCollector;\n import com.fasterxml.jackson.databind.deser.std.*;\n-import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.NamedType;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n  * no additional introspection or customizability of these types,\n  * this factory is stateless.\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class BasicDeserializerFactory\n     extends DeserializerFactory\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = 1;\n-\n+    private final static Class<?> CLASS_OBJECT = Object.class;\n+    private final static Class<?> CLASS_STRING = String.class;\n+    private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n+    private final static Class<?> CLASS_ITERABLE = Iterable.class;\n+    \n     /**\n      * Also special array deserializers for primitive array types.\n      */\n-    final protected static HashMap<JavaType,JsonDeserializer<Object>> _arrayDeserializers\n-        = PrimitiveArrayDeserializers.getAll();\n-\n-    /**\n-     * Set of available key deserializers is currently limited\n-     * to standard types; and all known instances are stored in this map.\n-     */\n-    final protected static HashMap<JavaType, KeyDeserializer> _keyDeserializers = StdKeyDeserializers.constructAll();\n+//    final protected static HashMap<JavaType,JsonDeserializer<Object>> _arrayDeserializers = PrimitiveArrayDeserializers.getAll();\n     \n     /* We do some defaulting for abstract Map classes and\n      * interfaces, to avoid having to use exact types or annotations in\n          */\n         _mapFallbacks.put(\"java.util.NavigableMap\", TreeMap.class);\n         try {\n-            Class<?> key = Class.forName(\"java.util.concurrent.ConcurrentNavigableMap\");\n-            Class<?> value = Class.forName(\"java.util.concurrent.ConcurrentSkipListMap\");\n+            Class<?> key = java.util.concurrent.ConcurrentNavigableMap.class;\n+            Class<?> value = java.util.concurrent.ConcurrentSkipListMap.class;\n             @SuppressWarnings(\"unchecked\")\n                 Class<? extends Map<?,?>> mapValue = (Class<? extends Map<?,?>>) value;\n             _mapFallbacks.put(key.getName(), mapValue);\n-        } catch (ClassNotFoundException cnfe) { // occurs on 1.5\n-        } catch (SecurityException se) { // might occur in applets, see stackoverflow.com/questions/12345068\n+        } catch (Exception e) { // is this possible?\n+            System.err.println(\"Problems with (optional) types: \"+e);\n         }\n     }\n \n         _collectionFallbacks.put(SortedSet.class.getName(), TreeSet.class);\n         _collectionFallbacks.put(Queue.class.getName(), LinkedList.class);\n \n-        /* 11-Jan-2009, tatu: Let's see if we can still add support for\n-         *    JDK 1.6 interfaces, even if we run on 1.5. Just need to be\n-         *    more careful with typos, since compiler won't notice any\n-         *    problems...\n-         */\n-        _collectionFallbacks.put(\"java.util.Deque\", LinkedList.class);\n-        _collectionFallbacks.put(\"java.util.NavigableSet\", TreeSet.class);\n-    }\n-\n-    /**\n-     * To support external/optional deserializers, we'll use a helper class\n-     */\n-    protected OptionalHandlerFactory optionalHandlers = OptionalHandlerFactory.instance;\n+        // then 1.6 types:\n+        _collectionFallbacks.put(java.util.Deque.class.getName(), LinkedList.class);\n+        _collectionFallbacks.put(java.util.NavigableSet.class.getName(), TreeSet.class);\n+    }\n     \n     /*\n     /**********************************************************\n     protected BasicDeserializerFactory(DeserializerFactoryConfig config) {\n         _factoryConfig = config;\n     }\n-\n+    \n     /**\n      * Method for getting current {@link DeserializerFactoryConfig}.\n       *<p>\n                 config, beanDesc, elemTypeDeser, contentDeser);\n         if (deser == null) {\n             if (contentDeser == null) {\n-                // Maybe special array type, such as \"primitive\" arrays (int[] etc)\n-                deser = _arrayDeserializers.get(elemType);\n-                if (deser == null) {\n-                    if (elemType.isPrimitive()) { // sanity check\n-                        throw new IllegalArgumentException(\"Internal error: primitive type (\"+type+\") passed, no array deserializer found\");\n-                    }\n+                Class<?> raw = elemType.getRawClass();\n+                if (elemType.isPrimitive()) {\n+                    return PrimitiveArrayDeserializers.forType(raw);\n+                } else if (raw == String.class) {\n+                    return StringArrayDeserializer.instance;\n                 }\n             }\n             if (deser == null) {\n     /* JsonDeserializerFactory impl: Collection(-like) deserializers\n     /**********************************************************\n      */\n-    \n+\n     @Override\n     public JsonDeserializer<?> createCollectionDeserializer(DeserializationContext ctxt,\n             CollectionType type, BeanDescription beanDesc)\n          */\n         if (deser == null) {\n             if (type.isInterface() || type.isAbstract()) {\n-                Class<?> collectionClass = type.getRawClass();\n-                @SuppressWarnings({ \"rawtypes\" })\n-                Class<? extends Collection> fallback = _collectionFallbacks.get(collectionClass.getName());\n-                if (fallback == null) {\n+                CollectionType implType = _mapAbstractCollectionType(type, config);\n+                if (implType == null) {\n                     throw new IllegalArgumentException(\"Can not find a deserializer for non-concrete Collection type \"+type);\n                 }\n-                collectionClass = fallback;\n-                type = (CollectionType) config.constructSpecializedType(type, collectionClass);\n+                type = implType;\n                 // But if so, also need to re-check creators...\n                 beanDesc = config.introspectForCreation(type);\n             }\n             }\n         }\n         return deser;\n+    }\n+\n+    protected CollectionType _mapAbstractCollectionType(JavaType type, DeserializationConfig config)\n+    {\n+        Class<?> collectionClass = type.getRawClass();\n+        collectionClass = _collectionFallbacks.get(collectionClass.getName());\n+        if (collectionClass == null) {\n+            return null;\n+        }\n+        return (CollectionType) config.constructSpecializedType(type, collectionClass);\n     }\n \n     protected JsonDeserializer<?> _findCustomCollectionDeserializer(CollectionType type,\n                 }\n             }\n         }\n+        // the only non-standard thing is this:\n         if (deser == null) {\n-            // and if none found, standard ones:\n-            Class<?> raw = type.getRawClass();\n-            if (raw == String.class || raw == Object.class) {\n-                deser = StdKeyDeserializers.constructStringKeyDeserializer(config, type);\n-            } else {\n-                // Most other keys are for limited number of static types\n-                deser = _keyDeserializers.get(type);\n-                if (deser == null) {\n-                    // And then other one-offs; first, Enum:\n-                    if (type.isEnumType()) {\n-                        deser = _createEnumKeyDeserializer(ctxt, type);\n-                    } else {\n-                        // One more thing: can we find ctor(String) or valueOf(String)?\n-                        deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n-                    }\n-                }\n-            }\n-        }\n+            if (type.isEnumType()) {\n+                return _createEnumKeyDeserializer(ctxt, type);\n+            }\n+            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+        }\n+        \n         // and then new with 2.2: ability to post-process it too (Issue#120)\n-        if (_factoryConfig.hasDeserializerModifiers()) {\n-            for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n-                deser = mod.modifyKeyDeserializer(config, type, deser);\n+        if (deser != null) {\n+            if (_factoryConfig.hasDeserializerModifiers()) {\n+                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n+                    deser = mod.modifyKeyDeserializer(config, type, deser);\n+                }\n             }\n         }\n         return deser;\n         return b.buildTypeDeserializer(config, contentType, subtypes);\n     }\n \n-    private final static Class<?> CLASS_OBJECT = Object.class;\n-    private final static Class<?> CLASS_STRING = String.class;\n-    private final static Class<?> CLASS_CHAR_BUFFER = CharSequence.class;\n-\n     /**\n      * Helper method called to find one of default serializers for \"well-known\"\n      * platform types: JDK-provided types, and small number of public Jackson\n      * \n      * @since 2.2\n      */\n-    public JsonDeserializer<?> findDefaultSerializer(Class<?> rawType)\n-    {\n+    public JsonDeserializer<?> findDefaultDeserializer(DeserializationContext ctxt,\n+            JavaType type, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        Class<?> rawType = type.getRawClass();\n         String clsName = rawType.getName();\n         if (rawType.isPrimitive() || clsName.startsWith(\"java.\")) {\n             // Object (\"untyped\"), String equivalents:\n             }\n             if (rawType == CLASS_STRING || rawType == CLASS_CHAR_BUFFER) {\n                 return StringDeserializer.instance;\n+            }\n+            if (rawType == CLASS_ITERABLE) {\n+                // [Issue#199]: Can and should 'upgrade' to a Collection type:\n+                TypeFactory tf = ctxt.getTypeFactory();\n+                JavaType elemType = (type.containedTypeCount() > 0) ? type.containedType(0) : TypeFactory.unknownType();\n+                CollectionType ct = tf.constructCollectionType(Collection.class, elemType);\n+                // Should we re-introspect beanDesc? For now let's not...\n+                return createCollectionDeserializer(ctxt, ct, beanDesc);\n             }\n             // Primitives/wrappers, other Numbers:\n             JsonDeserializer<?> deser = NumberDeserializers.find(rawType, clsName);\n             \t}\n             }\n         }\n-    \tTypeDeserializer valueTypeDeser;\n+        TypeDeserializer valueTypeDeser;\n \n         if (member instanceof AnnotatedMember) { // JAXB allows per-property annotations\n             valueTypeDeser = findPropertyTypeDeserializer(ctxt.getConfig(),\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n         if (_injectables != null) {\n             injectValues(ctxt, bean);\n         }\n-\n         final Class<?> activeView = _needViewProcesing ? ctxt.getActiveView() : null;\n-        \n         for (; jp.getCurrentToken() != JsonToken.END_OBJECT; jp.nextToken()) {\n             String propName = jp.getCurrentName();\n             jp.nextToken();\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n import com.fasterxml.jackson.databind.deser.impl.*;\n import com.fasterxml.jackson.databind.deser.std.JdkDeserializers;\n import com.fasterxml.jackson.databind.deser.std.ThrowableDeserializer;\n+import com.fasterxml.jackson.databind.ext.OptionalHandlerFactory;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n          */\n         if (type.isAbstract()) {\n             // [JACKSON-41] (v1.6): Let's make it possible to materialize abstract types.\n-            JavaType concreteType = materializeAbstractType(config, beanDesc);\n+            JavaType concreteType = materializeAbstractType(ctxt, type, beanDesc);\n             if (concreteType != null) {\n                 /* important: introspect actual implementation (abstract class or\n                  * interface doesn't have constructors, for one)\n         }\n \n         // Otherwise, may want to check handlers for standard types, from superclass:\n-        JsonDeserializer<Object> deser = findStdDeserializer(config, type);\n+        @SuppressWarnings(\"unchecked\")\n+        JsonDeserializer<Object> deser = (JsonDeserializer<Object>) findStdDeserializer(ctxt, type, beanDesc);\n         if (deser != null) {\n             return deser;\n         }\n      * Method called by {@link BeanDeserializerFactory} to see if there might be a standard\n      * deserializer registered for given type.\n      */\n-    @SuppressWarnings(\"unchecked\")\n-    protected JsonDeserializer<Object> findStdDeserializer(DeserializationConfig config,\n-            JavaType type)\n-        throws JsonMappingException\n-    {\n+    protected JsonDeserializer<?> findStdDeserializer(DeserializationContext ctxt,\n+            JavaType type, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        // note: we do NOT check for custom deserializers here, caller has already\n+        // done that\n+        JsonDeserializer<?> deser = findDefaultDeserializer(ctxt, type, beanDesc);\n+        if (deser != null) {\n+            return deser;\n+        }\n+        \n         Class<?> cls = type.getRawClass();\n-        // note: we do NOT check for custom deserializers here; that's for sub-class to do\n-        JsonDeserializer<?> deser = findDefaultSerializer(cls);\n-        if (deser != null) {\n-            return (JsonDeserializer<Object>) deser;\n-        }\n-        \n         // [JACKSON-283]: AtomicReference is a rather special type...\n         if (AtomicReference.class.isAssignableFrom(cls)) {\n             // Must find parameterization\n-            TypeFactory tf = config.getTypeFactory();\n+            TypeFactory tf = ctxt.getTypeFactory();\n             JavaType[] params = tf.findTypeParameters(type, AtomicReference.class);\n             JavaType referencedType;\n             if (params == null || params.length < 1) { // untyped (raw)\n             } else {\n                 referencedType = params[0];\n             }\n-            \n-            JsonDeserializer<?> d2 = new JdkDeserializers.AtomicReferenceDeserializer(referencedType);\n-            return (JsonDeserializer<Object>)d2;\n-        }\n-        // [JACKSON-386]: External/optional type handlers are handled somewhat differently\n-        JsonDeserializer<?> d = optionalHandlers.findDeserializer(type, config);\n-        if (d != null) {\n-            return (JsonDeserializer<Object>)d;\n-        }\n-        return null;\n-    }\n-    \n-    protected JavaType materializeAbstractType(DeserializationConfig config,\n-            BeanDescription beanDesc)\n+            return new JdkDeserializers.AtomicReferenceDeserializer(referencedType);\n+        }\n+        return findOptionalStdDeserializer(ctxt, type, beanDesc);\n+    }\n+\n+    /**\n+     * Overridable method called after checking all other types.\n+     * \n+     * @since 2.2\n+     */\n+    protected JsonDeserializer<?> findOptionalStdDeserializer(DeserializationContext ctxt,\n+            JavaType type, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        return OptionalHandlerFactory.instance.findDeserializer(type, ctxt.getConfig(), beanDesc);\n+    }\n+    \n+    protected JavaType materializeAbstractType(DeserializationContext ctxt,\n+            JavaType type, BeanDescription beanDesc)\n         throws JsonMappingException\n     {\n         final JavaType abstractType = beanDesc.getType();\n-        \n-        /* [JACKSON-502] (1.8): Now it is possible to have multiple resolvers too,\n-         *   as they are registered via module interface.\n-         */\n+        // [JACKSON-502]: Now it is possible to have multiple resolvers too,\n+        //   as they are registered via module interface.\n         for (AbstractTypeResolver r : _factoryConfig.abstractTypeResolvers()) {\n-            JavaType concrete = r.resolveAbstractType(config, abstractType);\n+            JavaType concrete = r.resolveAbstractType(ctxt.getConfig(), abstractType);\n             if (concrete != null) {\n                 return concrete;\n             }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/SettableBeanProperty.java\n import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonObjectFormatVisitor;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+import com.fasterxml.jackson.databind.jsontype.impl.FailingDeserializer;\n import com.fasterxml.jackson.databind.util.Annotations;\n import com.fasterxml.jackson.databind.util.ViewMatcher;\n \n     private static final long serialVersionUID = -1026580169193933453L;\n \n     /**\n+     * To avoid nasty NPEs, let's use a placeholder for _valueDeserializer,\n+     * if real deserializer is not (yet) available.\n+     * \n+     * @since 2.2\n+     */\n+    protected static final JsonDeserializer<Object> MISSING_VALUE_DESERIALIZER = new FailingDeserializer(\n+            \"No _valueDeserializer assigned\");\n+    \n+    /**\n      * Logical name of the property (often but not always derived\n      * from the setter method name)\n      */\n             typeDeser = typeDeser.forProperty(this);\n         }\n         _valueTypeDeserializer = typeDeser;\n+        _valueDeserializer = MISSING_VALUE_DESERIALIZER;\n     }\n \n     /**\n         _managedReferenceName = src._managedReferenceName;\n         _propertyIndex = src._propertyIndex;\n \n-        _valueDeserializer = (JsonDeserializer<Object>) deser;\n         if (deser == null) {\n             _nullProvider = null;\n+            _valueDeserializer = MISSING_VALUE_DESERIALIZER;\n         } else {\n             Object nvl = deser.getNullValue();\n             _nullProvider = (nvl == null) ? null : new NullProvider(_type, nvl);\n+            _valueDeserializer = (JsonDeserializer<Object>) deser;\n         }\n         _viewMatcher = src._viewMatcher;\n     }\n \n     public String getManagedReferenceName() { return _managedReferenceName; }\n \n-    public boolean hasValueDeserializer() { return (_valueDeserializer != null); }\n+    public boolean hasValueDeserializer() {\n+        return (_valueDeserializer != null) && (_valueDeserializer != MISSING_VALUE_DESERIALIZER);\n+    }\n \n     public boolean hasValueTypeDeserializer() { return (_valueTypeDeserializer != null); }\n     \n-    public JsonDeserializer<Object> getValueDeserializer() { return _valueDeserializer; }\n+    public JsonDeserializer<Object> getValueDeserializer() {\n+        JsonDeserializer<Object> deser = _valueDeserializer;\n+        if (deser == MISSING_VALUE_DESERIALIZER) {\n+            return null;\n+        }\n+        return deser;\n+    }\n \n     public TypeDeserializer getValueTypeDeserializer() { return _valueTypeDeserializer; }\n \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n      */\n     public BeanPropertyMap withProperty(SettableBeanProperty newProperty)\n     {\n-    \t// first things first: can just copy hash area:\n-    \tfinal int bcount = _buckets.length;\n+        // first things first: can just copy hash area:\n+        final int bcount = _buckets.length;\n         Bucket[] newBuckets = new Bucket[bcount];\n         System.arraycopy(_buckets, 0, newBuckets, 0, bcount);\n         final String propName = newProperty.getName();\n         // and then see if it's add or replace:\n-    \tSettableBeanProperty oldProp = find(newProperty.getName());\n-    \tif (oldProp == null) { // add\n-    \t    // first things first: add or replace?\n-    \t    // can do a straight copy, since all additions are at the front\n-    \t    // and then insert the new property:\n-    \t    int index = propName.hashCode() & _hashMask;\n-    \t    newBuckets[index] = new Bucket(newBuckets[index],\n-    \t            propName, newProperty, _nextBucketIndex++);\n-    \t    return new BeanPropertyMap(newBuckets, _size+1, _nextBucketIndex);\n-    \t}\n-    \t// replace: easy, close + replace\n-    \tBeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex);\n-    \tnewMap.replace(newProperty);\n-    \treturn newMap;\n-    }\n-    \n+        SettableBeanProperty oldProp = find(newProperty.getName());\n+        if (oldProp == null) { // add\n+            // first things first: add or replace?\n+    \t        // can do a straight copy, since all additions are at the front\n+    \t        // and then insert the new property:\n+    \t        int index = propName.hashCode() & _hashMask;\n+    \t        newBuckets[index] = new Bucket(newBuckets[index],\n+    \t                propName, newProperty, _nextBucketIndex++);\n+    \t        return new BeanPropertyMap(newBuckets, _size+1, _nextBucketIndex);\n+        }\n+        // replace: easy, close + replace\n+        BeanPropertyMap newMap = new BeanPropertyMap(newBuckets, bcount, _nextBucketIndex);\n+        newMap.replace(newProperty);\n+        return newMap;\n+    }\n+\n     /**\n      * Factory method for constructing a map where all entries use given\n      * prefix\n     /**********************************************************\n      */\n \n+    @Override\n+    public String toString()\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"Properties=[\");\n+        int count = 0;\n+        for (SettableBeanProperty prop : getPropertiesInInsertionOrder()) {\n+            if (prop == null) {\n+                continue;\n+            }\n+            if (count++ > 0) {\n+                sb.append(\", \");\n+            }\n+            sb.append(prop.getName());\n+            sb.append('(');\n+            sb.append(prop.getType());\n+            sb.append(')');\n+        }\n+        sb.append(']');\n+        return sb.toString();\n+    }\n+    \n     /**\n      * Accessor for traversing over all contained properties.\n      */\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/PrimitiveArrayDeserializers.java\n package com.fasterxml.jackson.databind.deser.std;\n \n import java.io.IOException;\n-import java.util.*;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.annotation.JacksonStdImpl;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n-import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ArrayBuilders;\n-\n \n /**\n  * Container for deserializers used for instantiating \"primitive arrays\",\n  * arrays that contain non-object java primitive types.\n  */\n-public class PrimitiveArrayDeserializers\n+@SuppressWarnings(\"serial\")\n+public abstract class PrimitiveArrayDeserializers<T> extends StdDeserializer<T>\n {\n-    HashMap<JavaType,JsonDeserializer<Object>> _allDeserializers;\n-\n-    final static PrimitiveArrayDeserializers instance = new PrimitiveArrayDeserializers();\n-\n-    protected PrimitiveArrayDeserializers()\n-    {\n-        _allDeserializers = new HashMap<JavaType,JsonDeserializer<Object>>();\n-        // note: we'll use component type as key, not array type\n-        add(boolean.class, new BooleanDeser());\n-\n-        /* ByteDeser is bit special, as it has 2 separate modes of operation;\n-         * one for String input (-> base64 input), the other for\n-         * numeric input\n-         */\n-        add(byte.class, new ByteDeser());\n-        add(short.class, new ShortDeser());\n-        add(int.class, new IntDeser());\n-        add(long.class, new LongDeser());\n-\n-        add(float.class, new FloatDeser());\n-        add(double.class, new DoubleDeser());\n-\n-        add(String.class, new StringArrayDeserializer());\n-        /* also: char[] is most likely only used with Strings; doesn't\n-         * seem to make sense to transfer as numbers\n-         */\n-        add(char.class, new CharDeser());\n-    }\n-\n-    public static HashMap<JavaType,JsonDeserializer<Object>> getAll()\n-    {\n-        return instance._allDeserializers;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private void add(Class<?> cls, JsonDeserializer<?> deser)\n-    {\n-        /* Not super clean to use default TypeFactory in general, but\n-         * since primitive array types can't be modified for anything\n-         * useful, this should be ok:\n-         */\n-        _allDeserializers.put(TypeFactory.defaultInstance().constructType(cls),\n-                (JsonDeserializer<Object>) deser);\n-    }\n-\n+    protected PrimitiveArrayDeserializers(Class<T> cls) {\n+        super(cls);\n+    }\n+\n+    public static JsonDeserializer<?> forType(Class<?> rawType)\n+    {\n+        // Start with more common types...\n+        if (rawType == Integer.TYPE) {\n+            return IntDeser.instance;\n+        }\n+        if (rawType == Long.TYPE) {\n+            return LongDeser.instance;\n+        }\n+        \n+        if (rawType == Byte.TYPE) {\n+            return new ByteDeser();\n+        }\n+        if (rawType == Short.TYPE) {\n+            return new ShortDeser();\n+        }\n+        if (rawType == Float.TYPE) {\n+            return new FloatDeser();\n+        }\n+        if (rawType == Double.TYPE) {\n+            return new DoubleDeser();\n+        }\n+        if (rawType == Boolean.TYPE) {\n+            return new BooleanDeser();\n+        }\n+        if (rawType == Character.TYPE) {\n+            return new CharDeser();\n+        }\n+        throw new IllegalStateException();\n+    }\n+\n+    @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n         throws IOException, JsonProcessingException\n          * for now this should be enough:\n          */\n         return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n-    }\n-\n-    /*\n-    /********************************************************\n-    /* Intermediate base class\n-    /********************************************************\n-     */\n-    \n-    /**\n-     * Intermediate base class for primitive array deserializers\n-     */\n-    static abstract class Base<T> extends StdDeserializer<T>\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n-        protected Base(Class<T> cls) {\n-            super(cls);\n-        }\n-\n-        @Override\n-        public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-            throws IOException, JsonProcessingException\n-        {\n-            return typeDeserializer.deserializeTypedFromArray(jp, ctxt);\n-        }\n     }\n     \n     /*\n \n     @JacksonStdImpl\n     final static class CharDeser\n-        extends Base<char[]>\n+        extends PrimitiveArrayDeserializers<char[]>\n     {\n         private static final long serialVersionUID = 1L;\n \n \n     @JacksonStdImpl\n     final static class BooleanDeser\n-        extends Base<boolean[]>\n+        extends PrimitiveArrayDeserializers<boolean[]>\n     {\n         private static final long serialVersionUID = 1L;\n \n      */\n     @JacksonStdImpl\n     final static class ByteDeser\n-        extends Base<byte[]>\n+        extends PrimitiveArrayDeserializers<byte[]>\n     {\n         private static final long serialVersionUID = 1L;\n \n \n     @JacksonStdImpl\n     final static class ShortDeser\n-        extends Base<short[]>\n+        extends PrimitiveArrayDeserializers<short[]>\n     {\n         private static final long serialVersionUID = 1L;\n \n \n     @JacksonStdImpl\n     final static class IntDeser\n-        extends Base<int[]>\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n+        extends PrimitiveArrayDeserializers<int[]>\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        public final static IntDeser instance = new IntDeser();\n+        \n         public IntDeser() { super(int[].class); }\n \n         @Override\n \n     @JacksonStdImpl\n     final static class LongDeser\n-        extends Base<long[]>\n-    {\n-        private static final long serialVersionUID = 1L;\n-\n+        extends PrimitiveArrayDeserializers<long[]>\n+    {\n+        private static final long serialVersionUID = 1L;\n+\n+        public final static LongDeser instance = new LongDeser();\n+        \n         public LongDeser() { super(long[].class); }\n \n         @Override\n \n     @JacksonStdImpl\n     final static class FloatDeser\n-        extends Base<float[]>\n+        extends PrimitiveArrayDeserializers<float[]>\n     {\n         private static final long serialVersionUID = 1L;\n \n \n     @JacksonStdImpl\n     final static class DoubleDeser\n-        extends Base<double[]>\n+        extends PrimitiveArrayDeserializers<double[]>\n     {\n         private static final long serialVersionUID = 1L;\n         \n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\n             throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation: \"+re.getMessage());\n         }\n         if (_keyClass.isEnum() && ctxt.getConfig().isEnabled(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL)) {\n-        \treturn null;\n+            return null;\n         }\n         throw ctxt.weirdKeyException(_keyClass, key, \"not a valid representation\");\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializers.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.KeyDeserializers;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\n-import com.fasterxml.jackson.databind.type.*;\n import com.fasterxml.jackson.databind.util.ClassUtil;\n import com.fasterxml.jackson.databind.util.EnumResolver;\n \n  *</ul>\n  */\n public class StdKeyDeserializers\n+    implements KeyDeserializers, java.io.Serializable\n {\n-    protected final HashMap<JavaType, KeyDeserializer> _keyDeserializers = new HashMap<JavaType, KeyDeserializer>();\n+    private static final long serialVersionUID = 923268084968181479L;\n \n-    protected StdKeyDeserializers()\n-    {\n-        add(new StdKeyDeserializer.BoolKD());\n-        add(new StdKeyDeserializer.ByteKD());\n-        add(new StdKeyDeserializer.CharKD());\n-        add(new StdKeyDeserializer.ShortKD());\n-        add(new StdKeyDeserializer.IntKD());\n-        add(new StdKeyDeserializer.LongKD());\n-        add(new StdKeyDeserializer.FloatKD());\n-        add(new StdKeyDeserializer.DoubleKD());\n-        add(new StdKeyDeserializer.DateKD());\n-        add(new StdKeyDeserializer.CalendarKD());\n-        add(new StdKeyDeserializer.UuidKD());\n-        add(new StdKeyDeserializer.LocaleKD());\n-    }\n-\n-    private void add(StdKeyDeserializer kdeser)\n-    {\n-        Class<?> keyClass = kdeser.getKeyClass();\n-        /* As with other cases involving primitive types, we can use\n-         * default TypeFactory ok, even if it's not our first choice:\n-         */\n-        _keyDeserializers.put(TypeFactory.defaultInstance().constructType(keyClass), kdeser);\n-    }\n-\n-    public static HashMap<JavaType, KeyDeserializer> constructAll()\n-    {\n-        return new StdKeyDeserializers()._keyDeserializers;\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Dynamic factory methods\n-    /**********************************************************\n+    /**\n+     * @deprecated Since 2.2, just call <code>StdKeyDeserializer.StringKD</code> directly\n      */\n-\n-    public static KeyDeserializer constructStringKeyDeserializer(DeserializationConfig config, JavaType type) {\n+    @Deprecated\n+    public static KeyDeserializer constructStringKeyDeserializer(DeserializationConfig config,\n+            JavaType type) {\n         return StdKeyDeserializer.StringKD.forType(type.getRawClass());\n     }\n     \n         return new StdKeyDeserializer.DelegatingKD(type.getRawClass(), deser);\n     }\n     \n-    public static KeyDeserializer findStringBasedKeyDeserializer(DeserializationConfig config, JavaType type)\n+    public static KeyDeserializer findStringBasedKeyDeserializer(DeserializationConfig config,\n+            JavaType type)\n     {\n         /* We don't need full deserialization information, just need to\n          * know creators.\n         // nope, no such luck...\n         return null;\n     }\n+    \n+    /*\n+    /**********************************************************\n+    /* KeyDeserializers implementation\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public KeyDeserializer findKeyDeserializer(JavaType type,\n+            DeserializationConfig config, BeanDescription beanDesc)\n+        throws JsonMappingException\n+    {\n+        Class<?> raw = type.getRawClass();\n+        // First, common types; String/Object/UUID, Int/Long, Dates\n+        if (raw == String.class || raw == Object.class) {\n+            return StdKeyDeserializer.StringKD.forType(raw);\n+        }\n+        if (raw == UUID.class) {\n+            return new StdKeyDeserializer.UuidKD();\n+        }\n+        if (raw == Integer.class) {\n+            return new StdKeyDeserializer.IntKD();\n+        }\n+        if (raw == Long.class) {\n+            return new StdKeyDeserializer.LongKD();\n+        }\n+        if (raw == Date.class) {\n+            return new StdKeyDeserializer.DateKD();\n+        }\n+        if (raw == Calendar.class) {\n+            return new StdKeyDeserializer.CalendarKD();\n+        }\n+        \n+        // then less common ones...\n+        if (raw == Boolean.class) {\n+            return new StdKeyDeserializer.BoolKD();\n+        }\n+        if (raw == Byte.class) {\n+            return new StdKeyDeserializer.ByteKD();\n+        }\n+        if (raw == Character.class) {\n+            return new StdKeyDeserializer.CharKD();\n+        }\n+        if (raw == Short.class) {\n+            return new StdKeyDeserializer.ShortKD();\n+        }\n+        if (raw == Float.class) {\n+            return new StdKeyDeserializer.FloatKD();\n+        }\n+        if (raw == Double.class) {\n+            return new StdKeyDeserializer.DoubleKD();\n+        }\n+        if (raw == Locale.class) {\n+            return new StdKeyDeserializer.LocaleKD();\n+        }\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StringArrayDeserializer.java\n \n /**\n  * Separate implementation for serializing String arrays (instead of\n- * using {@link ObjectArraySerializer}. Used if (and only if) no custom\n- * value deserializers are used.\n+ * using {@link ObjectArrayDeserializer}.\n+ * Used if (and only if) no custom value deserializers are used.\n  */\n @JacksonStdImpl\n-final class StringArrayDeserializer\n+public final class StringArrayDeserializer\n     extends StdDeserializer<String[]>\n     implements ContextualDeserializer\n {\n-    private static final long serialVersionUID = -4286917407100819199L;\n+    private static final long serialVersionUID = -7589512013334920693L;\n \n+    public final static StringArrayDeserializer instance = new StringArrayDeserializer();\n+    \n     /**\n      * Value serializer to use, if not the standard one (which is inlined)\n      */\n         return this;\n     }\n }\n-    \n--- a/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLDeserializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLDeserializers.java\n \n import com.fasterxml.jackson.core.*;\n \n-import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.Deserializers;\n import com.fasterxml.jackson.databind.deser.std.FromStringDeserializer;\n-import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n import com.fasterxml.jackson.databind.deser.std.StdScalarDeserializer;\n-import com.fasterxml.jackson.databind.util.Provider;\n \n /**\n  * Container deserializers that handle \"core\" XML types: ones included in standard\n- * JDK 1.5. Types are directly needed by JAXB, and are thus supported within core\n- * mapper package, not in \"xc\" package.\n+ * JDK 1.5. Types are directly needed by JAXB, but may be unavailable on some\n+ * limited platforms; hence separate out from basic deserializer factory.\n  */\n public class CoreXMLDeserializers\n-    implements Provider<StdDeserializer<?>>\n+    extends Deserializers.Base\n {\n     /**\n      * Data type factories are thread-safe after instantiation (and\n             throw new RuntimeException(e);\n         }\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Provider implementation\n-    /**********************************************************\n-     */\n \n-    /**\n-     * Method called by {@link com.fasterxml.jackson.databind.deser.BasicDeserializerFactory}\n-     * to register deserializers this class provides.\n-     */\n     @Override\n-    public Collection<StdDeserializer<?>> provide()\n+    public JsonDeserializer<?> findBeanDeserializer(JavaType type,\n+        DeserializationConfig config, BeanDescription beanDesc)\n     {\n-        return Arrays.asList(new StdDeserializer<?>[] {\n-            new DurationDeserializer()\n-            ,new GregorianCalendarDeserializer()\n-            ,new QNameDeserializer()\n-        });\n+        Class<?> raw = type.getRawClass();\n+        if (raw == QName.class) {\n+            return QNameDeserializer.instance;\n+        }\n+        if (raw == XMLGregorianCalendar.class) {\n+            return GregorianCalendarDeserializer.instance;\n+        }\n+        if (raw == Duration.class) {\n+            return DurationDeserializer.instance;\n+        }\n+        return null;\n     }\n-    \n+\n     /*\n     /**********************************************************\n     /* Concrete deserializers\n         extends FromStringDeserializer<Duration>\n     {\n         private static final long serialVersionUID = 1L;\n+        public final static DurationDeserializer instance = new DurationDeserializer();\n         public DurationDeserializer() { super(Duration.class); }\n     \n         @Override\n         extends StdScalarDeserializer<XMLGregorianCalendar>\n     {\n         private static final long serialVersionUID = 1L;\n+        public final static GregorianCalendarDeserializer instance = new GregorianCalendarDeserializer();\n         public GregorianCalendarDeserializer() { super(XMLGregorianCalendar.class); }\n         \n         @Override\n         extends FromStringDeserializer<QName>\n     {\n         private static final long serialVersionUID = 1L;\n+        public final static QNameDeserializer instance = new QNameDeserializer();\n+        \n+        \n         public QNameDeserializer() { super(QName.class); }\n         \n         @Override\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/CoreXMLSerializers.java\n \n import java.io.IOException;\n import java.lang.reflect.Type;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Map;\n \n import javax.xml.datatype.Duration;\n import javax.xml.datatype.XMLGregorianCalendar;\n \n import com.fasterxml.jackson.core.*;\n \n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.JsonMappingException;\n-import com.fasterxml.jackson.databind.JsonNode;\n-import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n+import com.fasterxml.jackson.databind.ser.Serializers;\n import com.fasterxml.jackson.databind.ser.std.CalendarSerializer;\n import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n import com.fasterxml.jackson.databind.ser.std.ToStringSerializer;\n-import com.fasterxml.jackson.databind.util.Provider;\n \n /**\n  * Provider for serializers of XML types that are part of full JDK 1.5, but\n  * care not to just use straight equivalency check but rather consider\n  * subclassing as well.\n  */\n-public class CoreXMLSerializers\n-    implements Provider<Map.Entry<Class<?>,JsonSerializer<?>>>\n+public class CoreXMLSerializers extends Serializers.Base\n {\n-    final static HashMap<Class<?>,JsonSerializer<?>> _serializers = new HashMap<Class<?>,JsonSerializer<?>>();\n-    /**\n-     * We will construct instances statically, during class loading, to try to\n-     * make things fail-fast, i.e. to catch problems as soon as possible.\n-     */\n-    static {\n-        ToStringSerializer tss = ToStringSerializer.instance;\n-        _serializers.put(Duration.class, tss);\n-        _serializers.put(XMLGregorianCalendar.class, new XMLGregorianCalendarSerializer());\n-        _serializers.put(QName.class, tss);\n-    }\n-\n     @Override\n-    public Collection<Map.Entry<Class<?>,JsonSerializer<?>>> provide() {\n-        return _serializers.entrySet();\n+    public JsonSerializer<?> findSerializer(SerializationConfig config,\n+            JavaType type, BeanDescription beanDesc)\n+    {\n+        Class<?> raw = type.getRawClass();\n+        if (Duration.class.isAssignableFrom(raw) || QName.class.isAssignableFrom(raw)) {\n+            return ToStringSerializer.instance;\n+        }\n+        if (XMLGregorianCalendar.class.isAssignableFrom(raw)) {\n+            return XMLGregorianCalendarSerializer.instance;\n+        }\n+        return null;\n     }\n \n     public static class XMLGregorianCalendarSerializer extends StdSerializer<XMLGregorianCalendar>\n     {\n+        public final static XMLGregorianCalendarSerializer instance = new XMLGregorianCalendarSerializer();\n+        \n         public XMLGregorianCalendarSerializer() {\n             super(XMLGregorianCalendar.class);\n         }\n--- a/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ext/OptionalHandlerFactory.java\n package com.fasterxml.jackson.databind.ext;\n \n-import java.util.Collection;\n-import java.util.Map;\n-\n import com.fasterxml.jackson.databind.*;\n-import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n-import com.fasterxml.jackson.databind.util.Provider;\n+import com.fasterxml.jackson.databind.deser.Deserializers;\n+import com.fasterxml.jackson.databind.ser.Serializers;\n \n /**\n  * Helper class used for isolating details of handling optional+external types\n public class OptionalHandlerFactory\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = -7103336512296456640L;\n+    private static final long serialVersionUID = 1;\n \n     /* 1.6.1+ To make 2 main \"optional\" handler groups (javax.xml.stream)\n      * more dynamic, we better only figure out handlers completely dynamically, if and\n     /**********************************************************\n      */\n     \n-    public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type)\n+    public JsonSerializer<?> findSerializer(SerializationConfig config, JavaType type,\n+            BeanDescription beanDesc)\n     {\n         Class<?> rawType = type.getRawClass();\n         String className = rawType.getName();\n         if (ob == null) { // could warn, if we had logging system (j.u.l?)\n             return null;\n         }\n-        @SuppressWarnings(\"unchecked\")\n-        Provider<Map.Entry<Class<?>,JsonSerializer<?>>> prov = (Provider<Map.Entry<Class<?>,JsonSerializer<?>>>) ob;\n-        Collection<Map.Entry<Class<?>,JsonSerializer<?>>> entries = prov.provide();\n-\n-        // first, check for exact match (concrete)\n-        for (Map.Entry<Class<?>,JsonSerializer<?>> entry : entries) {\n-            if (rawType == entry.getKey()) {\n-                return entry.getValue();\n-            }\n-        }\n-        // if no match, check super-type match\n-        for (Map.Entry<Class<?>,JsonSerializer<?>> entry : entries) {\n-            if (entry.getKey().isAssignableFrom(rawType)) {\n-                return entry.getValue();\n-            }\n-        }\n-        // but maybe there's just no match to be found?\n-        return null;\n+        return ((Serializers) ob).findSerializer(config, type, beanDesc);\n     }\n \n-    public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config)\n+    public JsonDeserializer<?> findDeserializer(JavaType type, DeserializationConfig config,\n+            BeanDescription beanDesc)\n+        throws JsonMappingException\n     {\n         Class<?> rawType = type.getRawClass();\n         String className = rawType.getName();\n         if (ob == null) { // could warn, if we had logging system (j.u.l?)\n             return null;\n         }\n-        @SuppressWarnings(\"unchecked\")\n-        Provider<StdDeserializer<?>> prov = (Provider<StdDeserializer<?>>) ob;\n-        Collection<StdDeserializer<?>> entries = prov.provide();\n-\n-        // first, check for exact match (concrete)\n-        for (StdDeserializer<?> deser : entries) {\n-            if (rawType == deser.getValueClass()) {\n-                return deser;\n-            }\n-        }\n-        // if no match, check super-type match\n-        for (StdDeserializer<?> deser : entries) {\n-            if (deser.getValueClass().isAssignableFrom(rawType)) {\n-                return deser;\n-            }\n-        }\n-        // but maybe there's just no match to be found?\n-        return null;\n+        return ((Deserializers) ob).findBeanDeserializer(type, config, beanDesc);\n     }\n     \n     /*\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/FailingDeserializer.java\n+package com.fasterxml.jackson.databind.jsontype.impl;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+\n+/**\n+ * Special bogus \"serializer\" that will throw\n+ * {@link JsonMappingException} if an attempt is made to deserialize\n+ * a value. This is used as placeholder to avoid NPEs for uninitialized\n+ * structured serializers or handlers.\n+ */\n+public class FailingDeserializer extends StdDeserializer<Object>\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    protected final String _message;\n+\n+    public FailingDeserializer(String m) {\n+        super(Object.class);\n+        _message = m;\n+    }\n+    \n+    @Override\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n+        throws JsonMappingException\n+    {\n+        throw ctxt.mappingException(_message);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/BasicSerializerFactory.java\n  * no additional introspection or customizability of these types,\n  * this factory is essentially stateless.\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class BasicSerializerFactory\n     extends SerializerFactory\n     implements java.io.Serializable\n {\n-    private static final long serialVersionUID = -1416617628045738132L;\n-\n     /*\n     /**********************************************************\n     /* Configuration, lookup tables/maps\n         final JsonSerializer<?> ns = new NumberSerializers.NumberSerializer();\n         _concrete.put(BigInteger.class.getName(), ns);\n         _concrete.put(BigDecimal.class.getName(), ns);\n-        \n+\n         // Other discrete non-container types:\n         // First, Date/Time zoo:\n         _concrete.put(Calendar.class.getName(), CalendarSerializer.instance);\n         _concrete.put(java.util.Date.class.getName(), dateSer);\n         // note: timestamps are very similar to java.util.Date, thus serialized as such\n         _concrete.put(java.sql.Timestamp.class.getName(), dateSer);\n-        _concrete.put(java.sql.Date.class.getName(), new SqlDateSerializer());\n-        _concrete.put(java.sql.Time.class.getName(), new SqlTimeSerializer());\n+        \n+        // leave some of less commonly used ones as lazy, no point in proactive construction\n+        _concreteLazy.put(java.sql.Date.class.getName(), SqlDateSerializer.class);\n+        _concreteLazy.put(java.sql.Time.class.getName(), SqlTimeSerializer.class);\n \n         // And then other standard non-structured JDK types\n-        for (Map.Entry<Class<?>,Object> en : new StdJdkSerializers().provide()) {\n+        for (Map.Entry<Class<?>,Object> en : StdJdkSerializers.all()) {\n             Object value = en.getValue();\n             if (value instanceof JsonSerializer<?>) {\n                 _concrete.put(en.getKey().getName(), (JsonSerializer<?>) value);\n      * factory), new version created via copy-constructor (fluent-style)\n      */\n     protected final SerializerFactoryConfig _factoryConfig;\n-    \n-    /**\n-     * Helper object used to deal with serializers for optional JDK types (like ones\n-     * omitted from GAE, Android)\n-     */\n-    protected OptionalHandlerFactory optionalHandlers = OptionalHandlerFactory.instance;\n \n     /*\n     /**********************************************************\n         Class<?> raw = type.getRawClass();\n         String clsName = raw.getName();\n         JsonSerializer<?> ser = _concrete.get(clsName);\n-        if (ser != null) {\n-            return ser;\n-        }\n-        Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName);\n-        if (serClass != null) {\n-            try {\n-                return serClass.newInstance();\n-            } catch (Exception e) {\n-                throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \"\n-                        +e.getMessage(), e);\n-            }\n-        }\n-        return null;\n+        if (ser == null) {\n+            Class<? extends JsonSerializer<?>> serClass = _concreteLazy.get(clsName);\n+            if (serClass != null) {\n+                try {\n+                    return serClass.newInstance();\n+                } catch (Exception e) {\n+                    throw new IllegalStateException(\"Failed to instantiate standard serializer (of type \"+serClass.getName()+\"): \"\n+                            +e.getMessage(), e);\n+                }\n+            }\n+        }\n+        return ser;\n     }\n \n     /**\n         }\n         \n         // Then check for optional/external serializers [JACKSON-386]\n-        JsonSerializer<?> ser = optionalHandlers.findSerializer(prov.getConfig(), type);\n+        JsonSerializer<?> ser = findOptionalStdSerializer(prov, type, beanDesc, staticTyping);\n         if (ser != null) {\n             return ser;\n         }\n             return DateSerializer.instance;\n         }\n         return null;\n+    }\n+\n+    /**\n+     * Overridable method called after checking all other types.\n+     * \n+     * @since 2.2\n+     */\n+    protected JsonSerializer<?> findOptionalStdSerializer(SerializerProvider prov, \n+            JavaType type, BeanDescription beanDesc, boolean staticTyping)\n+        throws JsonMappingException\n+    {\n+        return OptionalHandlerFactory.instance.findSerializer(prov.getConfig(), type, beanDesc);\n     }\n         \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/StdJdkSerializers.java\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonFormatVisitorWrapper;\n import com.fasterxml.jackson.databind.jsonFormatVisitors.JsonIntegerFormatVisitor;\n import com.fasterxml.jackson.databind.ser.BasicSerializerFactory;\n-import com.fasterxml.jackson.databind.util.Provider;\n \n /**\n  * Class that providers access to serializers user for non-structured JDK types that\n  * others explicit serializers.\n  */\n public class StdJdkSerializers\n-    implements Provider<Map.Entry<Class<?>,Object>>\n {\n     /**\n      * Method called by {@link BasicSerializerFactory} to access\n      * all serializers this class provides.\n      */\n-    @Override\n-    public Collection<Map.Entry<Class<?>, Object>> provide()\n+    public static Collection<Map.Entry<Class<?>, Object>> all()\n     {\n         HashMap<Class<?>,Object> sers = new HashMap<Class<?>,Object>();\n \n     }\n \n     /*\n-     ********************************************************\n-     * Serializers for atomic types\n-     ********************************************************\n+    /**********************************************************\n+    /* Serializers for atomic types\n+    /**********************************************************\n      */\n \n     public final static class AtomicBooleanSerializer\n--- a/src/main/java/com/fasterxml/jackson/databind/util/Provider.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/Provider.java\n  * @author tatu\n  *\n  * @param <T> Type of objects provided\n+ * \n+ * @since 2.2 Not really needed that much, will be eventually removed\n  */\n+@Deprecated\n public interface Provider<T>\n {\n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/util/SimpleBeanPropertyDefinition.java\n      */\n     public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n     \t\tAnnotatedMember member) {\n-    \treturn new SimpleBeanPropertyDefinition(member, member.getName(),\n-    \t\t\tconfig.getAnnotationIntrospector());\n+        return new SimpleBeanPropertyDefinition(member, member.getName(),\n+                (config == null) ? null : config.getAnnotationIntrospector());\n     }\n     \n     /**\n      */\n     public static SimpleBeanPropertyDefinition construct(MapperConfig<?> config,\n     \t\tAnnotatedMember member, String name) {\n-    \treturn new SimpleBeanPropertyDefinition(member, name, config.getAnnotationIntrospector());\n+        return new SimpleBeanPropertyDefinition(member, name,\n+                (config == null) ? null : config.getAnnotationIntrospector());\n     }\n     \n     /*\n--- a/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestFormatSchema.java\n     \n     static class FactoryWithSchema extends JsonFactory\n     {\n+        @Override\n+        public String getFormatName() { return \"test\"; }\n+\n+        @Override\n+        public boolean canUseSchema(FormatSchema schema) {\n+            return (schema instanceof MySchema);\n+        }\n+        \n         private static final long serialVersionUID = 1L;\n         @Override\n         protected JsonParser _createParser(Reader r, IOContext ctxt)\n--- a/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/TestObjectMapper.java\n import java.io.*;\n \n import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonParser;\n \n import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;\n import com.fasterxml.jackson.databind.node.*;\n import com.fasterxml.jackson.databind.type.TypeFactory;\n \n         public void setX(int v) { value = v; }\n     }\n \n+    // for [Issue#206]\n+    @SuppressWarnings(\"serial\")\n+    static class CustomMapper extends ObjectMapper {\n+        @Override\n+        protected DefaultDeserializationContext createDeserializationContext(JsonParser jp,\n+                DeserializationConfig cfg) {\n+            return super.createDeserializationContext(jp, cfg);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Test methods\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestCollectionDeserialization.java\n \n     static class XBean {\n         public int x;\n+    }\n+\n+    // [Issue#199]\n+    static class ListAsIterable {\n+        public Iterable<String> values;\n+    }\n+\n+    static class ListAsIterableX {\n+        public Iterable<XBean> nums;\n     }\n     \n     /*\n         assertEquals(Integer.valueOf(2), q.take());\n         assertEquals(Integer.valueOf(3), q.take());\n     }\n+\n+    // [Issue#199]\n+    public void testIterableWithStrings() throws Exception\n+    {\n+        String JSON = \"{ \\\"values\\\":[\\\"a\\\",\\\"b\\\"]}\";\n+        ListAsIterable w = MAPPER.readValue(JSON, ListAsIterable.class);\n+        assertNotNull(w);\n+        assertNotNull(w.values);\n+        Iterator<String> it = w.values.iterator();\n+        assertTrue(it.hasNext());\n+        assertEquals(\"a\", it.next());\n+        assertEquals(\"b\", it.next());\n+        assertFalse(it.hasNext());\n+    }\n+\n+    public void testIterableWithBeans() throws Exception\n+    {\n+        String JSON = \"{ \\\"nums\\\":[{\\\"x\\\":1},{\\\"x\\\":2}]}\";\n+        ListAsIterableX w = MAPPER.readValue(JSON, ListAsIterableX.class);\n+        assertNotNull(w);\n+        assertNotNull(w.nums);\n+        Iterator<XBean> it = w.nums.iterator();\n+        assertTrue(it.hasNext());\n+        XBean xb = it.next();\n+        assertNotNull(xb);\n+        assertEquals(1, xb.x);\n+        xb = it.next();\n+        assertEquals(2, xb.x);\n+        assertFalse(it.hasNext());\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/type/TestJavaType.java\n \n     static class SubType extends BaseType { }\n     \n+    static enum MyEnum { A, B; }\n+    static enum MyEnum2 {\n+        A(1), B(2);\n+        \n+        private MyEnum2(int value) { }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Test methods\n         }\n     }\n \n+    public void testEnumType()\n+    {\n+        TypeFactory tf = TypeFactory.defaultInstance();\n+        assertTrue(tf.constructType(MyEnum.class).isEnumType());\n+        assertTrue(tf.constructType(MyEnum2.class).isEnumType());\n+        assertTrue(tf.constructType(MyEnum.A.getClass()).isEnumType());\n+        assertTrue(tf.constructType(MyEnum2.A.getClass()).isEnumType());\n+    }\n+\n     public void testClassKey()\n     {\n         ClassKey key = new ClassKey(String.class);", "timestamp": 1366167305, "metainfo": ""}