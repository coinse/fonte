{"sha": "bf355caa0821e58968df3bf6c12f612639224e47", "log": "Yet more refactoring, trying to remove back-refs from DeserializerFactory to context/cache", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n     \n     @Override\n     public JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config,\n-            ArrayType type, BeanProperty property)\n+            ArrayType type, final BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n         JavaType elemType = type.getContentType();\n     \n     @Override\n     public JsonDeserializer<?> createCollectionDeserializer(DeserializationConfig config,\n-            CollectionType type, BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        // First: global defaulting:\n-        type = (CollectionType) mapAbstractType(config, type);\n-\n-        Class<?> collectionClass = type.getRawClass();\n-        BeanDescription beanDesc = config.introspectForCreation(type);\n-        // Explicit deserializer to use? (@JsonDeserialize.using)\n-        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n-        if (deser != null) {\n-            return deser;\n-        }\n-        // If not, any type modifiers? (@JsonDeserialize.as)\n-        type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), type, null);\n-\n+            CollectionType type, BeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n         JavaType contentType = type.getContentType();\n         // Very first thing: is deserializer hard-coded for elements?\n         JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n             return custom;\n         }\n         \n+        Class<?> collectionClass = type.getRawClass();\n         if (contentDeser == null) { // not defined by annotation\n             // One special type: EnumSet:\n             if (EnumSet.class.isAssignableFrom(collectionClass)) {\n-                return new EnumSetDeserializer(contentType.getRawClass(),\n-                        createEnumDeserializer(config, contentType, property));\n+                return new EnumSetDeserializer(contentType, property, null);\n             }\n         }\n         \n     // Copied almost verbatim from \"createCollectionDeserializer\" -- should try to share more code\n     @Override\n     public JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationConfig config,\n-            CollectionLikeType type, BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        // First: global defaulting:\n-        type = (CollectionLikeType) mapAbstractType(config, type);\n-\n-        Class<?> collectionClass = type.getRawClass();\n-        BeanDescription beanDesc = config.introspectClassAnnotations(collectionClass);\n-        // Explicit deserializer to use? (@JsonDeserialize.using)\n-        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n-        if (deser != null) {\n-            return deser;\n-        }\n-        // If not, any type modifiers? (@JsonDeserialize.as)\n-        type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), type, null);\n-\n+            CollectionLikeType type, final BeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n         JavaType contentType = type.getContentType();\n         // Very first thing: is deserializer hard-coded for elements?\n         JsonDeserializer<Object> contentDeser = contentType.getValueHandler();\n     \n     @Override\n     public JsonDeserializer<?> createMapDeserializer(DeserializationConfig config,\n-            MapType type, BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        // First: global defaulting:\n-        type = (MapType) mapAbstractType(config, type);\n-\n-        BeanDescription beanDesc = config.introspectForCreation(type);\n-        // Explicit deserializer to use? (@JsonDeserialize.using)\n-        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n-        if (deser != null) {\n-            return deser;\n-        }\n-        // If not, any type modifiers? (@JsonDeserialize.as)\n-        type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), type, null);        \n+            MapType type, BeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n         JavaType keyType = type.getKeyType();\n         JavaType contentType = type.getContentType();\n         \n             if (kt == null || !kt.isEnum()) {\n                 throw new IllegalArgumentException(\"Can not construct EnumMap; generic (key) type not available\");\n             }\n-            return new EnumMapDeserializer(type, property,\n-                    createEnumDeserializer(config, keyType, property),\n-                    contentDeser);\n+            return new EnumMapDeserializer(type, property, null, contentDeser);\n         }\n \n         // Otherwise, generic handler works ok.\n     // Copied almost verbatim from \"createMapDeserializer\" -- should try to share more code\n     @Override\n     public JsonDeserializer<?> createMapLikeDeserializer(DeserializationConfig config,\n-            MapLikeType type, BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        // First: global defaulting:\n-        type = (MapLikeType) mapAbstractType(config, type);\n-        BeanDescription beanDesc = config.introspectForCreation(type);\n-        // Explicit deserializer to use? (@JsonDeserialize.using)\n-        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n-        if (deser != null) {\n-            return deser;\n-        }\n-        // If not, any type modifiers? (@JsonDeserialize.as)\n-        type = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), type, null);        \n+            MapLikeType type, final BeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n         JavaType keyType = type.getKeyType();\n         JavaType contentType = type.getContentType();\n         \n      */\n     @Override\n     public JsonDeserializer<?> createEnumDeserializer(DeserializationConfig config,\n-            JavaType type, BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        BeanDescription beanDesc = config.introspect(type);\n-        JsonDeserializer<?> des = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n-        if (des != null) {\n-            return des;\n-        }\n+            JavaType type, BeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n         Class<?> enumClass = type.getRawClass();\n         // 23-Nov-2010, tatu: Custom deserializer?\n         JsonDeserializer<?> custom = _findCustomEnumDeserializer(enumClass, config, beanDesc, property);\n \n     @Override\n     public JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config,\n-            JavaType nodeType, BeanProperty property)\n+            JavaType nodeType, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException\n     {\n         @SuppressWarnings(\"unchecked\")\n         return kdes;\n     }\n \n-    private KeyDeserializer _createEnumKeyDeserializer(DeserializationConfig config, JavaType type,\n-            BeanProperty property)\n+    private KeyDeserializer _createEnumKeyDeserializer(DeserializationConfig config,\n+            JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n         BeanDescription beanDesc = config.introspect(type);\n      * has annotation that tells which class to use for deserialization.\n      * Returns null if no such annotation found.\n      */\n+    @SuppressWarnings(\"unchecked\")\n     protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationConfig config,\n             Annotated ann, BeanProperty property)\n         throws JsonMappingException\n     {\n         Object deserDef = config.getAnnotationIntrospector().findDeserializer(ann);\n-        if (deserDef != null) {\n-            return _constructDeserializer(config, ann, property, deserDef);\n-        }\n-        return null;\n-    }\n-    \n-    @SuppressWarnings(\"unchecked\")\n-    JsonDeserializer<Object> _constructDeserializer(DeserializationConfig config, Annotated ann, BeanProperty property,\n-            Object deserDef)\n-        throws JsonMappingException\n-    {\n+        if (deserDef == null) {\n+            return null;\n+        }\n         if (deserDef instanceof JsonDeserializer) {\n             JsonDeserializer<Object> deser = (JsonDeserializer<Object>) deserDef;\n             // related to [JACKSON-569], need contextualization:\n             deser = (JsonDeserializer<Object>)((ContextualDeserializer<?>) deser).createContextual(config, property);\n         }\n         return deser;\n-    }\n-\n-    /**\n-     * Method called to see if given method has annotations that indicate\n-     * a more specific type than what the argument specifies.\n-     * If annotations are present, they must specify compatible Class;\n-     * instance of which can be assigned using the method. This means\n-     * that the Class has to be raw class of type, or its sub-class\n-     * (or, implementing class if original Class instance is an interface).\n-     *\n-     * @param a Method or field that the type is associated with\n-     * @param type Type derived from the setter argument\n-     * @param propName Name of property that refers to type, if any; null\n-     *   if no property information available (when modify type declaration\n-     *   of a class, for example)\n-     *\n-     * @return Original type if no annotations are present; or a more\n-     *   specific type derived from it if type annotation(s) was found\n-     *\n-     * @throws JsonMappingException if invalid annotation is found\n-     */\n-    @SuppressWarnings({ \"unchecked\" })\n-    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationConfig config,\n-            Annotated a, T type, String propName)\n-        throws JsonMappingException\n-    {\n-        // first: let's check class for the instance itself:\n-        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-        Class<?> subclass = intr.findDeserializationType(a, type, propName);\n-        if (subclass != null) {\n-            try {\n-                type = (T) type.narrowBy(subclass);\n-            } catch (IllegalArgumentException iae) {\n-                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n-            }\n-        }\n-\n-        // then key class\n-        if (type.isContainerType()) {\n-            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n-            if (keyClass != null) {\n-                // illegal to use on non-Maps\n-                if (!(type instanceof MapLikeType)) {\n-                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n-                }\n-                try {\n-                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n-                }\n-            }\n-            JavaType keyType = type.getKeyType();\n-            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n-             *   (not 100% why or how, but this does seem to get called more than once, which\n-             *   is not good: for now, let's just avoid errors)\n-             */\n-            if (keyType != null && keyType.getValueHandler() == null) {\n-                Object kdDef = intr.findKeyDeserializer(a);\n-                if (kdDef != null) {\n-                    KeyDeserializer kd = null;\n-                    if (kdDef instanceof KeyDeserializer) {\n-                        kd = (KeyDeserializer) kdDef;\n-                    } else {\n-                        Class<?> kdClass = _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n-                        if (kdClass != null) {\n-                            kd = config.keyDeserializerInstance(a, kdClass);\n-                        }\n-                    }\n-                    if (kd != null) {\n-                        type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n-                        keyType = type.getKeyType(); // just in case it's used below\n-                    }\n-                }\n-            }            \n-            \n-            // and finally content class; only applicable to structured types\n-            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType(), propName);\n-            if (cc != null) {\n-                try {\n-                    type = (T) type.narrowContentsBy(cc);\n-                } catch (IllegalArgumentException iae) {\n-                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n-                }\n-            }\n-            // ... as well as deserializer for contents:\n-            JavaType contentType = type.getContentType();\n-            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n-                Object cdDef = intr.findContentDeserializer(a);\n-                if (cdDef != null) {\n-                    JsonDeserializer<?> cd = null;\n-                    if (cdDef instanceof JsonDeserializer<?>) {\n-                        cdDef = (JsonDeserializer<?>) cdDef;\n-                    } else {\n-                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n-                        if (cdClass != null) {\n-                            cd = config.deserializerInstance(a, cdClass);\n-                        }\n-                    }\n-                    if (cd != null) {\n-                        type = (T) type.withContentValueHandler(cd);\n-                    }\n-                }\n-            }\n-        }\n-        return type;\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n     public JavaType mapAbstractType(DeserializationConfig config, JavaType type)\n         throws JsonMappingException\n     {\n+        // first, general mappings\n         while (true) {\n             JavaType next = _mapAbstractType2(config, type);\n             if (next == null) {\n      */\n     @Override\n     public JsonDeserializer<Object> createBeanDeserializer(DeserializationConfig config,\n-            JavaType type, BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        // First things first: abstract types may use defaulting:\n-        if (type.isAbstract()) {\n-            type = mapAbstractType(config, type);\n-        }\n-        \n-        // First things first: maybe explicit definition via annotations?\n-        BeanDescription beanDesc = config.introspect(type);\n-        JsonDeserializer<Object> ad = findDeserializerFromAnnotation(config, beanDesc.getClassInfo(), property);\n-        if (ad != null) {\n-            return ad;\n-        }\n-        // Or value annotation that indicates more specific type to use:\n-        JavaType newType =  modifyTypeByAnnotation(config, beanDesc.getClassInfo(), type, null);\n-        if (newType.getRawClass() != type.getRawClass()) {\n-            type = newType;\n-            beanDesc = config.introspect(type);\n-        }\n+            JavaType type, BeanDescription beanDesc, BeanProperty property)\n+        throws JsonMappingException\n+    {\n         // We may also have custom overrides:\n         JsonDeserializer<Object> custom = _findCustomBeanDeserializer(type, config, beanDesc, property);\n         if (custom != null) {\n         }\n         return status;\n     }\n+\n+    /**\n+     * Method called to see if given method has annotations that indicate\n+     * a more specific type than what the argument specifies.\n+     * If annotations are present, they must specify compatible Class;\n+     * instance of which can be assigned using the method. This means\n+     * that the Class has to be raw class of type, or its sub-class\n+     * (or, implementing class if original Class instance is an interface).\n+     *\n+     * @param a Method or field that the type is associated with\n+     * @param type Type derived from the setter argument\n+     * @param propName Name of property that refers to type, if any; null\n+     *   if no property information available (when modify type declaration\n+     *   of a class, for example)\n+     *\n+     * @return Original type if no annotations are present; or a more\n+     *   specific type derived from it if type annotation(s) was found\n+     *\n+     * @throws JsonMappingException if invalid annotation is found\n+     */\n+    @SuppressWarnings({ \"unchecked\" })\n+    protected <T extends JavaType> T modifyTypeByAnnotation(DeserializationConfig config,\n+            Annotated a, T type, String propName)\n+        throws JsonMappingException\n+    {\n+        // first: let's check class for the instance itself:\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        Class<?> subclass = intr.findDeserializationType(a, type, propName);\n+        if (subclass != null) {\n+            try {\n+                type = (T) type.narrowBy(subclass);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n+            }\n+        }\n+\n+        // then key class\n+        if (type.isContainerType()) {\n+            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n+            if (keyClass != null) {\n+                // illegal to use on non-Maps\n+                if (!(type instanceof MapLikeType)) {\n+                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n+                }\n+                try {\n+                    type = (T) ((MapLikeType) type).narrowKey(keyClass);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n+                }\n+            }\n+            JavaType keyType = type.getKeyType();\n+            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n+             *   (not 100% why or how, but this does seem to get called more than once, which\n+             *   is not good: for now, let's just avoid errors)\n+             */\n+            if (keyType != null && keyType.getValueHandler() == null) {\n+                Object kdDef = intr.findKeyDeserializer(a);\n+                if (kdDef != null) {\n+                    KeyDeserializer kd = null;\n+                    if (kdDef instanceof KeyDeserializer) {\n+                        kd = (KeyDeserializer) kdDef;\n+                    } else {\n+                        Class<?> kdClass = _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n+                        if (kdClass != null) {\n+                            kd = config.keyDeserializerInstance(a, kdClass);\n+                        }\n+                    }\n+                    if (kd != null) {\n+                        type = (T) ((MapLikeType) type).withKeyValueHandler(kd);\n+                        keyType = type.getKeyType(); // just in case it's used below\n+                    }\n+                }\n+            }            \n+           \n+           // and finally content class; only applicable to structured types\n+           Class<?> cc = intr.findDeserializationContentType(a, type.getContentType(), propName);\n+           if (cc != null) {\n+               try {\n+                   type = (T) type.narrowContentsBy(cc);\n+               } catch (IllegalArgumentException iae) {\n+                   throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n+               }\n+           }\n+           // ... as well as deserializer for contents:\n+           JavaType contentType = type.getContentType();\n+           if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n+               Object cdDef = intr.findContentDeserializer(a);\n+                if (cdDef != null) {\n+                    JsonDeserializer<?> cd = null;\n+                    if (cdDef instanceof JsonDeserializer<?>) {\n+                        cdDef = (JsonDeserializer<?>) cdDef;\n+                    } else {\n+                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n+                        if (cdClass != null) {\n+                            cd = config.deserializerInstance(a, cdClass);\n+                        }\n+                    }\n+                    if (cd != null) {\n+                        type = (T) type.withContentValueHandler(cd);\n+                    }\n+                }\n+            }\n+        }\n+        return type;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.annotation.NoClass;\n+import com.fasterxml.jackson.databind.introspect.Annotated;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n import com.fasterxml.jackson.databind.type.ArrayType;\n import com.fasterxml.jackson.databind.type.CollectionLikeType;\n \n     /*\n     /**********************************************************\n-    /* Overridable helper methods\n+    /* Helper methods that handle cache lookups\n     /**********************************************************\n      */\n \n     {\n         JsonDeserializer<Object> deser;\n         try {\n-            deser = _createDeserializer(ctxt.getConfig(), type, property);\n+            deser = _createDeserializer(ctxt, type, property);\n         } catch (IllegalArgumentException iae) {\n             /* We better only expose checked exceptions, since those\n              * are what caller is expected to handle\n          */\n         if (isResolvable) {\n             _incompleteDeserializers.put(type, deser);\n-            _resolveDeserializer(ctxt, (ResolvableDeserializer)deser);\n+            ((ResolvableDeserializer)deser).resolve(ctxt);\n             _incompleteDeserializers.remove(type);\n         }\n         if (addToCache) {\n         return deser;\n     }\n \n-    /* Refactored so we can isolate the casts that require suppression\n-     * of type-safety warnings.\n+    /*\n+    /**********************************************************\n+    /* Helper methods for actual construction of deserializers\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that does the heavy lifting of checking for per-type annotations,\n+     * find out full type, and figure out which actual factory method\n+     * to call.\n      */\n     @SuppressWarnings(\"unchecked\")\n-    protected JsonDeserializer<Object> _createDeserializer(DeserializationConfig config, \n+    protected JsonDeserializer<Object> _createDeserializer(DeserializationContext ctxt,\n             JavaType type, BeanProperty property)\n         throws JsonMappingException\n     {\n+        final DeserializationConfig config = ctxt.getConfig();\n+\n+        // First things first: do we need to use abstract type mapping?\n+        if (type.isAbstract() || type.isMapLikeType() || type.isCollectionLikeType()) {\n+            type = _factory.mapAbstractType(config, type);\n+        }\n+        BeanDescription beanDesc = config.introspect(type);\n+        // Then: does type define explicit deserializer to use, with annotation(s)?\n+        JsonDeserializer<Object> deser = findDeserializerFromAnnotation(ctxt,\n+                beanDesc.getClassInfo(), property);\n+        if (deser != null) {\n+            return deser;\n+        }\n+\n+        // If not, may have further type-modification annotations to check:\n+        JavaType newType = modifyTypeByAnnotation(config, beanDesc.getClassInfo(), type, property);\n+        if (newType != type) {\n+            type = newType;\n+            beanDesc = config.introspect(newType);\n+        }\n+\n+        // If not, let's see which factory method to use:\n         if (type.isEnumType()) {\n-            return (JsonDeserializer<Object>) _factory.createEnumDeserializer(config, type, property);\n+            return (JsonDeserializer<Object>) _factory.createEnumDeserializer(config, type,\n+                    beanDesc, property);\n         }\n         if (type.isContainerType()) {\n             if (type.isArrayType()) {\n                 return (JsonDeserializer<Object>)_factory.createArrayDeserializer(config,\n-                        (ArrayType) type, property);\n+                        (ArrayType) type, beanDesc, property);\n             }\n             if (type.isMapLikeType()) {\n                 MapLikeType mlt = (MapLikeType) type;\n                 if (mlt.isTrueMapType()) {\n                     return (JsonDeserializer<Object>)_factory.createMapDeserializer(config,\n-                            (MapType) mlt, property);\n+                            (MapType) mlt, beanDesc, property);\n                 }\n                 return (JsonDeserializer<Object>)_factory.createMapLikeDeserializer(config,\n-                        mlt, property);\n+                        mlt, beanDesc, property);\n             }\n             if (type.isCollectionLikeType()) {\n                 CollectionLikeType clt = (CollectionLikeType) type;\n                 if (clt.isTrueCollectionType()) {\n                     return (JsonDeserializer<Object>)_factory.createCollectionDeserializer(config,\n-                            (CollectionType) clt, property);\n+                            (CollectionType) clt, beanDesc, property);\n                 }\n                 return (JsonDeserializer<Object>)_factory.createCollectionLikeDeserializer(config,\n-                        clt, property);\n+                        clt, beanDesc, property);\n             }\n         }\n \n         // 02-Mar-2009, tatu: Let's consider JsonNode to be a type of its own\n         if (JsonNode.class.isAssignableFrom(type.getRawClass())) {\n-            return (JsonDeserializer<Object>)_factory.createTreeDeserializer(config, type, property);\n-        }\n-        return (JsonDeserializer<Object>)_factory.createBeanDeserializer(config, type, property);\n-    }\n-\n-    protected void _resolveDeserializer(DeserializationContext ctxt, ResolvableDeserializer ser)\n-        throws JsonMappingException\n-    {\n-        ser.resolve(ctxt);\n-    }\n-\n+            return (JsonDeserializer<Object>)_factory.createTreeDeserializer(config, type, beanDesc, property);\n+        }\n+        return (JsonDeserializer<Object>)_factory.createBeanDeserializer(config, type, beanDesc, property);\n+    }\n+\n+    /**\n+     * Helper method called to check if a class or method\n+     * has annotation that tells which class to use for deserialization.\n+     * Returns null if no such annotation found.\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected JsonDeserializer<Object> findDeserializerFromAnnotation(DeserializationContext ctxt,\n+            Annotated ann, BeanProperty property)\n+        throws JsonMappingException\n+    {\n+        Object deserDef = ctxt.getAnnotationIntrospector().findDeserializer(ann);\n+        if (deserDef == null) {\n+            return null;\n+        }\n+        if (deserDef instanceof JsonDeserializer) {\n+            JsonDeserializer<Object> deser = (JsonDeserializer<Object>) deserDef;\n+            // related to [JACKSON-569], need contextualization:\n+            if (deser instanceof ContextualDeserializer<?>) {\n+                deser = (JsonDeserializer<Object>)((ContextualDeserializer<?>) deser).createContextual(ctxt.getConfig(), property);\n+            }\n+            return deser;\n+        }\n+        /* Alas, there's no way to force return type of \"either class\n+         * X or Y\" -- need to throw an exception after the fact\n+         */\n+        if (!(deserDef instanceof Class)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector returned deserializer definition of type \"+deserDef.getClass().getName()+\"; expected type JsonDeserializer or Class<JsonDeserializer> instead\");\n+        }\n+        Class<? extends JsonDeserializer<?>> deserClass = (Class<? extends JsonDeserializer<?>>) deserDef;\n+        if (!JsonDeserializer.class.isAssignableFrom(deserClass)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector returned Class \"+deserClass.getName()+\"; expected Class<JsonDeserializer>\");\n+        }\n+        JsonDeserializer<Object> deser = ctxt.getConfig().deserializerInstance(ann, deserClass);\n+        // related to [JACKSON-569], need contextualization:\n+        if (deser instanceof ContextualDeserializer<?>) {\n+            deser = (JsonDeserializer<Object>)((ContextualDeserializer<?>) deser).createContextual(ctxt.getConfig(), property);\n+        }\n+        return deser;\n+    }\n+    \n+    private JavaType modifyTypeByAnnotation(DeserializationConfig config,\n+            Annotated a, JavaType type, BeanProperty prop)\n+        throws JsonMappingException\n+    {\n+        return modifyTypeByAnnotation(config, a, type,\n+                (prop == null)  ? null : prop.getName());\n+    }\n+\n+    /**\n+     * Method called to see if given method has annotations that indicate\n+     * a more specific type than what the argument specifies.\n+     * If annotations are present, they must specify compatible Class;\n+     * instance of which can be assigned using the method. This means\n+     * that the Class has to be raw class of type, or its sub-class\n+     * (or, implementing class if original Class instance is an interface).\n+     *\n+     * @param a Method or field that the type is associated with\n+     * @param type Type derived from the setter argument\n+     * @param propName Name of property that refers to type, if any; null\n+     *   if no property information available (when modify type declaration\n+     *   of a class, for example)\n+     *\n+     * @return Original type if no annotations are present; or a more\n+     *   specific type derived from it if type annotation(s) was found\n+     *\n+     * @throws JsonMappingException if invalid annotation is found\n+     */\n+    private JavaType modifyTypeByAnnotation(DeserializationConfig config,\n+            Annotated a, JavaType type, String propName)\n+        throws JsonMappingException\n+    {\n+        // first: let's check class for the instance itself:\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        Class<?> subclass = intr.findDeserializationType(a, type, propName);\n+        if (subclass != null) {\n+            try {\n+                type = type.narrowBy(subclass);\n+            } catch (IllegalArgumentException iae) {\n+                throw new JsonMappingException(\"Failed to narrow type \"+type+\" with concrete-type annotation (value \"+subclass.getName()+\"), method '\"+a.getName()+\"': \"+iae.getMessage(), null, iae);\n+            }\n+        }\n+\n+        // then key class\n+        if (type.isContainerType()) {\n+            Class<?> keyClass = intr.findDeserializationKeyType(a, type.getKeyType(), propName);\n+            if (keyClass != null) {\n+                // illegal to use on non-Maps\n+                if (!(type instanceof MapLikeType)) {\n+                    throw new JsonMappingException(\"Illegal key-type annotation: type \"+type+\" is not a Map(-like) type\");\n+                }\n+                try {\n+                    type = ((MapLikeType) type).narrowKey(keyClass);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(\"Failed to narrow key type \"+type+\" with key-type annotation (\"+keyClass.getName()+\"): \"+iae.getMessage(), null, iae);\n+                }\n+            }\n+            JavaType keyType = type.getKeyType();\n+            /* 21-Mar-2011, tatu: ... and associated deserializer too (unless already assigned)\n+             *   (not 100% why or how, but this does seem to get called more than once, which\n+             *   is not good: for now, let's just avoid errors)\n+             */\n+            if (keyType != null && keyType.getValueHandler() == null) {\n+                Object kdDef = intr.findKeyDeserializer(a);\n+                if (kdDef != null) {\n+                    KeyDeserializer kd = null;\n+                    if (kdDef instanceof KeyDeserializer) {\n+                        kd = (KeyDeserializer) kdDef;\n+                    } else {\n+                        Class<?> kdClass = _verifyAsClass(kdDef, \"findKeyDeserializer\", KeyDeserializer.None.class);\n+                        if (kdClass != null) {\n+                            kd = config.keyDeserializerInstance(a, kdClass);\n+                        }\n+                    }\n+                    if (kd != null) {\n+                        type = ((MapLikeType) type).withKeyValueHandler(kd);\n+                        keyType = type.getKeyType(); // just in case it's used below\n+                    }\n+                }\n+            }            \n+            \n+            // and finally content class; only applicable to structured types\n+            Class<?> cc = intr.findDeserializationContentType(a, type.getContentType(), propName);\n+            if (cc != null) {\n+                try {\n+                    type = type.narrowContentsBy(cc);\n+                } catch (IllegalArgumentException iae) {\n+                    throw new JsonMappingException(\"Failed to narrow content type \"+type+\" with content-type annotation (\"+cc.getName()+\"): \"+iae.getMessage(), null, iae);\n+                }\n+            }\n+            // ... as well as deserializer for contents:\n+            JavaType contentType = type.getContentType();\n+            if (contentType.getValueHandler() == null) { // as with above, avoid resetting (which would trigger exception)\n+                Object cdDef = intr.findContentDeserializer(a);\n+                if (cdDef != null) {\n+                    JsonDeserializer<?> cd = null;\n+                    if (cdDef instanceof JsonDeserializer<?>) {\n+                        cdDef = (JsonDeserializer<?>) cdDef;\n+                    } else {\n+                        Class<?> cdClass = _verifyAsClass(cdDef, \"findContentDeserializer\", JsonDeserializer.None.class);\n+                        if (cdClass != null) {\n+                            cd = config.deserializerInstance(a, cdClass);\n+                        }\n+                    }\n+                    if (cd != null) {\n+                        type = type.withContentValueHandler(cd);\n+                    }\n+                }\n+            }\n+        }\n+        return type;\n+    }\n+\n+    private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n+    {\n+        if (src == null) {\n+            return null;\n+        }\n+        if (!(src instanceof Class)) {\n+            throw new IllegalStateException(\"AnnotationIntrospector.\"+methodName+\"() returned value of type \"+src.getClass().getName()+\": expected type JsonSerializer or Class<JsonSerializer> instead\");\n+        }\n+        Class<?> cls = (Class<?>) src;\n+        if (cls == noneClass || cls == NoClass.class) {\n+            return null;\n+        }\n+        return cls;\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Overridable error reporting methods\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerFactory.java\n      * @param type Type to be deserialized\n      */\n     public abstract JsonDeserializer<Object> createBeanDeserializer(DeserializationConfig config,\n-            JavaType type, BeanProperty property)\n+            JavaType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n \n     /**\n      * @param type Type to be deserialized\n      */\n     public abstract JsonDeserializer<?> createArrayDeserializer(DeserializationConfig config,\n-            ArrayType type, BeanProperty property)\n+            ArrayType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n \n     public abstract JsonDeserializer<?> createCollectionDeserializer(DeserializationConfig config,\n-            CollectionType type, BeanProperty property)\n+            CollectionType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n \n     public abstract JsonDeserializer<?> createCollectionLikeDeserializer(DeserializationConfig config,\n-            CollectionLikeType type, BeanProperty property)\n+            CollectionLikeType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n     \n     public abstract JsonDeserializer<?> createEnumDeserializer(DeserializationConfig config,\n-            JavaType type, BeanProperty property)\n+            JavaType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n \n     public abstract JsonDeserializer<?> createMapDeserializer(DeserializationConfig config,\n-            MapType type, BeanProperty property)\n+            MapType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n \n     public abstract JsonDeserializer<?> createMapLikeDeserializer(DeserializationConfig config,\n-            MapLikeType type, BeanProperty property)\n+            MapLikeType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n \n     /**\n      * JsonNode(s) from JSON content.\n      */\n     public abstract JsonDeserializer<?> createTreeDeserializer(DeserializationConfig config,\n-            JavaType type, BeanProperty property)\n+            JavaType type, BeanDescription beanDesc, BeanProperty property)\n         throws JsonMappingException;\n \n     /**\n      * @return Key deserializer to use for specified type, if one found; null if not\n      *   (and default key deserializer should be used)\n      */\n-    public KeyDeserializer createKeyDeserializer(DeserializationConfig config,\n+    public abstract KeyDeserializer createKeyDeserializer(DeserializationConfig config,\n             JavaType type, BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        // Default implementation returns null for backwards compatibility reasons\n-        return null;\n-    }\n+        throws JsonMappingException;\n     \n     /**\n      * Method called to find and create a type information deserializer for given base type,\n      * \n      * @return Type deserializer to use for given base type, if one is needed; null if not.\n      */\n-    public TypeDeserializer findTypeDeserializer(DeserializationConfig config, JavaType baseType,\n-            BeanProperty property)\n-        throws JsonMappingException\n-    {\n-        // Default implementation returns null for backwards compatibility reasons\n-        return null;\n-    }\n+    public abstract TypeDeserializer findTypeDeserializer(DeserializationConfig config,\n+            JavaType baseType, BeanProperty property)\n+        throws JsonMappingException;\n }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumMapDeserializer.java\n     \n     protected final Class<?> _enumClass;\n \n-    protected final JsonDeserializer<Enum<?>> _keyDeserializer;\n+    protected JsonDeserializer<Enum<?>> _keyDeserializer;\n \n     protected JsonDeserializer<Object> _valueDeserializer;\n \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n     public EnumMapDeserializer(JavaType mapType, BeanProperty prop,\n             JsonDeserializer<?> keyDeserializer, JsonDeserializer<Object> valueDeser)\n     {\n         _valueDeserializer = valueDeser;\n     }\n \n+    @Override\n+    public void resolve(DeserializationContext ctxt) throws JsonMappingException\n+    {\n+        if (_keyDeserializer == null) {\n+            // note: instead of finding key deserializer, with enums we actually\n+            // work with regular deserializers (less code duplication; but not\n+            // quite as clean as it ought to be)\n+            _keyDeserializer = (JsonDeserializer<Enum<?>>)(JsonDeserializer<?>)\n+                ctxt.findValueDeserializer(_mapType.getKeyType(), _property);\n+        }\n+        if (_valueDeserializer == null) {\n+            // 'null' -> arrays have no referring fields\n+            _valueDeserializer = ctxt.findValueDeserializer(_mapType.getContentType(), _property);\n+        }\n+    }\n+    \n     /**\n      * Because of costs associated with constructing Enum resolvers,\n      * let's cache instances by default.\n     @Override\n     public boolean isCachable() { return true; }\n     \n+    /*\n+    /**********************************************************\n+    /* Actual deserialization\n+    /**********************************************************\n+     */\n+\n     @Override\n     public EnumMap<?,?> deserialize(JsonParser jp, DeserializationContext ctxt)\n         throws IOException, JsonProcessingException\n         // In future could check current token... for now this should be enough:\n         return typeDeserializer.deserializeTypedFromObject(jp, ctxt);\n     }\n-\n-    @Override\n-    public void resolve(DeserializationContext ctxt) throws JsonMappingException\n-    {\n-        if (_valueDeserializer == null) {\n-            // 'null' -> arrays have no referring fields\n-            _valueDeserializer = ctxt.findValueDeserializer(_mapType.getContentType(), _property);\n-        }\n-    }\n     \n     private EnumMap<?,?> constructMap() {\n         return new EnumMap(_enumClass);\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/EnumSetDeserializer.java\n import com.fasterxml.jackson.core.*;\n \n import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.databind.deser.ResolvableDeserializer;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n \n /**\n @SuppressWarnings(\"rawtypes\")\n public class EnumSetDeserializer\n     extends StdDeserializer<EnumSet<?>>\n+    implements ResolvableDeserializer\n {\n+    protected final JavaType _enumType;\n+\n+    protected final BeanProperty _property;\n+\n     protected final Class<Enum> _enumClass;\n \n-    protected final JsonDeserializer<Enum<?>> _enumDeserializer;\n+    protected JsonDeserializer<Enum<?>> _enumDeserializer;\n \n     @SuppressWarnings(\"unchecked\" )\n-    public EnumSetDeserializer(Class<?> enumClass, JsonDeserializer<?> deser)\n+    public EnumSetDeserializer(JavaType enumType, BeanProperty prop,\n+            JsonDeserializer<?> deser)\n     {\n         super(EnumSet.class);\n-        _enumClass = (Class<Enum>) enumClass;\n+        _enumType = enumType;\n+        _property = prop;\n+        _enumClass = (Class<Enum>) enumType.getRawClass();\n         _enumDeserializer = (JsonDeserializer<Enum<?>>) deser;\n     }\n \n      */\n     @Override\n     public boolean isCachable() { return true; }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public void resolve(DeserializationContext ctxt) throws JsonMappingException\n+    {\n+        if (_enumDeserializer == null) {\n+            _enumDeserializer = (JsonDeserializer<Enum<?>>)(JsonDeserializer<?>)\n+                ctxt.findValueDeserializer(_enumType, _property);\n+        }\n+    }\n     \n     @SuppressWarnings(\"unchecked\") \n     @Override", "timestamp": 1327445185, "metainfo": ""}