{"sha": "05fce93ce799a3fa402c269ed04ca32ec957d665", "log": "Minor improvement to UnrecognizedPropertyException: list name of known properties to help user see what might be going wrong", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/DeserializationContext.java\n      * @param instanceOrClass Either value being populated (if one has been\n      *   instantiated), or Class that indicates type that would be (or\n      *   have been) instantiated\n-     */\n-    public void reportUnknownProperty(Object instanceOrClass, String fieldName)\n+     * @param deser Deserializer that had the problem, if called by deserializer\n+     *   (or on behalf of one)\n+     */\n+    public void reportUnknownProperty(Object instanceOrClass, String fieldName,\n+            JsonDeserializer<?> deser)\n         throws JsonMappingException\n     {\n-        if (isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n-            throw UnrecognizedPropertyException.from(_parser, instanceOrClass, fieldName);\n-        }\n+        if (!isEnabled(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)) {\n+            return;\n+        }\n+        // Do we know properties that are expected instead?\n+        Collection<Object> propIds = (deser == null) ? null : deser.getKnownPropertyNames();\n+        throw UnrecognizedPropertyException.from(_parser,\n+                instanceOrClass, fieldName, propIds);\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonDeserializer.java\n package com.fasterxml.jackson.databind;\n \n import java.io.IOException;\n+import java.util.Collection;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.deser.impl.ObjectIdReader;\n     public T getEmptyValue() { return getNullValue(); }\n \n     /**\n+     * Method that will\n+     * either return null to indicate that type being deserializers\n+     * has no concept of properties; or a collection of identifiers\n+     * for which <code>toString</code> will give external property\n+     * name.\n+     * This is only to be used for error reporting and diagnostics\n+     * purposes (most commonly, to accompany \"unknown property\"\n+     * exception).\n+     * \n+     * @since 2.0\n+     */\n+    public Collection<Object> getKnownPropertyNames() {\n+        return null;\n+    }\n+    \n+    /**\n      * Method called to see if deserializer instance is cachable and\n      * usable for other properties of same type (type for which instance\n      * was created).\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n     /**********************************************************\n      */\n \n+    /**\n+     * Method for accessing full structural path within type hierarchy\n+     * down to problematic property.\n+     */\n     public List<Reference> getPath()\n     {\n         if (_path == null) {\n         return Collections.unmodifiableList(_path);\n     }\n \n+    /**\n+     * Method for accesing description of path that lead to the\n+     * problem that triggered this exception\n+     */\n+    public String getPathReference()\n+    {\n+        return getPathReference(new StringBuilder()).toString();\n+    }\n+\n+    public StringBuilder getPathReference(StringBuilder sb)\n+    {\n+        _appendPathDesc(sb);\n+        return sb;\n+    }\n+    \n     /**\n      * Method called to prepend a reference information in front of\n      * current path\n             _path.addFirst(r);\n         }\n     }\n-\n+    \n     /*\n     /**********************************************************\n     /* Overridden methods\n     /**********************************************************\n      */\n \n+    @Override\n+    public String getLocalizedMessage() {\n+        return _buildMessage();\n+    }\n+    \n     /**\n      * Method is overridden so that we can properly inject description\n      * of problem path, if such is defined.\n      */\n     @Override\n-    public String getMessage()\n+    public String getMessage() {\n+        return _buildMessage();\n+    }\n+\n+    protected String _buildMessage()\n     {\n         /* First: if we have no path info, let's just use parent's\n          * definition as is\n         if (_path == null) {\n             return msg;\n         }\n-        /* 19-Feb-2009, tatu: Null and empty messages are not very\n-         *   useful (plus nulls would lead to NPEs), so let's\n-         *   use something else\n-         */\n         StringBuilder sb = (msg == null) ? new StringBuilder() : new StringBuilder(msg);\n         /* 18-Feb-2009, tatu: initially there was a linefeed between\n          *    message and path reference; but unfortunately many systems\n          *   separate stack trace.\n          */\n         sb.append(\" (through reference chain: \");\n-        _appendPathDesc(sb);\n+        sb = getPathReference(sb);\n         sb.append(')');\n         return sb.toString();\n     }\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerBase.java\n             }\n         }\n \n-        Iterator<SettableBeanProperty> it = _beanProperties.allProperties();\n         UnwrappedPropertyHandler unwrapped = null;\n \n-        while (it.hasNext()) {\n-            SettableBeanProperty origProp = it.next();\n+        for (SettableBeanProperty origProp : _beanProperties) {\n             SettableBeanProperty prop = origProp;\n             // May already have deserializer from annotations, if so, skip:\n             if (!prop.hasValueDeserializer()) {\n         return _beanProperties.size();\n     }\n \n+    @Override\n+    public Collection<Object> getKnownPropertyNames() {\n+        ArrayList<Object> names = new ArrayList<Object>();\n+        for (SettableBeanProperty prop : _beanProperties) {\n+            names.add(prop.getName());\n+        }\n+        return names;\n+    }\n+    \n     public final Class<?> getBeanClass() { return _beanType.getRawClass(); }\n \n     @Override public JavaType getValueType() { return _beanType; }\n         if (_beanProperties == null) {\n             throw new IllegalStateException(\"Can only call after BeanDeserializer has been resolved\");\n         }\n-        return _beanProperties.allProperties();\n+        return _beanProperties.iterator();\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n  * as it is done for each and every POJO property deserialized.\n  */\n public final class BeanPropertyMap\n+    implements Iterable<SettableBeanProperty>\n {\n     private final Bucket[] _buckets;\n     \n         if (transformer == null || (transformer == NameTransformer.NOP)) {\n             return this;\n         }\n-        Iterator<SettableBeanProperty> it = allProperties();\n+        Iterator<SettableBeanProperty> it = iterator();\n         ArrayList<SettableBeanProperty> newProps = new ArrayList<SettableBeanProperty>();\n         while (it.hasNext()) {\n             SettableBeanProperty prop = it.next();\n         }\n         return result;\n     }\n-    \n+\n     /*\n     /**********************************************************\n+    /* Iterable, for convenient iterating over all properties\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Accessor for traversing over all contained properties.\n+     */\n+    @Override\n+    public Iterator<SettableBeanProperty> iterator() {\n+        return new IteratorImpl(_buckets);\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Public API\n     /**********************************************************\n      */\n \n     public int size() { return _size; }\n-\n-    /**\n-     * Accessor for traversing over all contained properties.\n-     */\n-    public Iterator<SettableBeanProperty> allProperties() {\n-        return new IteratorImpl(_buckets);\n-    }\n     \n     public SettableBeanProperty find(String key)\n     {\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/StdDeserializer.java\n             return;\n         }\n         // Nope, not handled. Potentially that's a problem...\n-        ctxt.reportUnknownProperty(instanceOrClass, propName);\n+        ctxt.reportUnknownProperty(instanceOrClass, propName, this);\n \n         /* But if we do get this far, need to skip whatever value we\n          * are pointing to now.\n--- a/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/exc/UnrecognizedPropertyException.java\n package com.fasterxml.jackson.databind.exc;\n+\n+import java.util.*;\n \n import com.fasterxml.jackson.core.JsonLocation;\n import com.fasterxml.jackson.core.JsonParser;\n      */\n     protected final String _unrecognizedPropertyName;\n     \n+    /**\n+     * Set of ids of properties that are known for the type, if this\n+     * can be statically determined.\n+     */\n+    protected final Collection<Object> _propertyIds;\n+\n+    /**\n+     * Lazily constructed description of known properties, used for\n+     * constructing actual message if and as needed.\n+     */\n+    protected transient String _propertiesAsString;\n+    \n     public UnrecognizedPropertyException(String msg, JsonLocation loc,\n-            Class<?> referringClass, String propName)\n+            Class<?> referringClass, String propName,\n+            Collection<Object> propertyIds)\n     {\n         \n         super(msg, loc);\n         _referringClass = referringClass;\n         _unrecognizedPropertyName = propName;\n+        _propertyIds = propertyIds;\n     }\n \n-    public static UnrecognizedPropertyException from(JsonParser jp, Object fromObjectOrClass, String propertyName)\n+    /**\n+     * Factory method used for constructing instances of this exception type.\n+     * \n+     * @param jp Underlying parser used for reading input being used for data-binding\n+     * @param fromObjectOrClass Reference to either instance of problematic type (\n+     *    if available), or if not, type itself\n+     * @param propertyName Name of unrecognized property\n+     * @param propertyIds (optional, null if not available) Set of properties that\n+     *    type would recognize, if completely known: null if set can not be determined.\n+     */\n+    public static UnrecognizedPropertyException from(JsonParser jp,\n+            Object fromObjectOrClass, String propertyName,\n+            Collection<Object> propertyIds)\n     {\n         if (fromObjectOrClass == null) {\n             throw new IllegalArgumentException();\n         } else {\n             ref = fromObjectOrClass.getClass();\n         }\n-        String msg = \"Unrecognized field \\\"\"+propertyName+\"\\\" (Class \"+ref.getName()+\"), not marked as ignorable\";\n-        UnrecognizedPropertyException e = new UnrecognizedPropertyException(msg, jp.getCurrentLocation(), ref, propertyName);\n+        String msg = \"Unrecognized field \\\"\"+propertyName+\"\\\" (class \"+ref.getName()+\"), not marked as ignorable\";\n+        UnrecognizedPropertyException e = new UnrecognizedPropertyException(msg,\n+                jp.getCurrentLocation(), ref, propertyName, propertyIds);\n         // but let's also ensure path includes this last (missing) segment\n         e.prependPath(fromObjectOrClass, propertyName);\n         return e;\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Overrides\n+    /**********************************************************\n+     */\n+\n+    private final static int MAX_DESC_LENGTH = 200;\n+    \n+    @Override\n+    public String getMessageSuffix()\n+    {\n+        String suffix = _propertiesAsString;\n+        if (suffix == null && _propertyIds != null) {\n+            StringBuilder sb = new StringBuilder(100);\n+            int len = _propertyIds.size();\n+            if (len == 1) {\n+                sb.append(\" (one known property: \\\"\");\n+                sb.append(String.valueOf(_propertyIds.iterator().next()));\n+                sb.append('\"');\n+            } else {\n+                sb.append(\" (\").append(len).append(\" known properties: \");\n+                Iterator<Object> it = _propertyIds.iterator();\n+                while (it.hasNext()) {\n+                    sb.append(\", \\\"\");\n+                    sb.append(String.valueOf(it.next()));\n+                    sb.append('\"');\n+                    // one other thing: limit max length\n+                    if (sb.length() > MAX_DESC_LENGTH) {\n+                        sb.append(\" [truncated]\");\n+                        break;\n+                    }\n+                }\n+            }\n+            sb.append(\"])\");\n+            _propertiesAsString = suffix = sb.toString();\n+        }\n+        return suffix;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Method for accessing type (class) that is missing definition to allow\n      * binding of the unrecognized property.\n      */\n     public String getUnrecognizedPropertyName() {\n         return _unrecognizedPropertyName;\n+    }    \n+    \n+    public Collection<Object> getKnownPropertyIds()\n+    {\n+        if (_propertyIds == null) {\n+            return null;\n+        }\n+        return Collections.unmodifiableCollection(_propertyIds);\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java\n+++ b/src/test/java/com/fasterxml/jackson/databind/deser/TestExceptionHandling.java\n     extends BaseMapTest\n {\n     static class Bean {\n-        String x;\n+        public String propX;\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Verification of [JACKSON-301]\n      */\n     public void testHandlingOfUnrecognized() throws Exception\n     {\n+        UnrecognizedPropertyException exc = null;\n         try {\n             new ObjectMapper().readValue(\"{\\\"bar\\\":3}\", Bean.class);\n+        } catch (UnrecognizedPropertyException e) {\n+            exc = e;\n+        }\n+        if (exc == null) {\n             fail(\"Should have failed binding\");\n-        } catch (UnrecognizedPropertyException e) {\n-            assertEquals(\"bar\", e.getUnrecognizedPropertyName());\n-            assertEquals(Bean.class, e.getReferringClass());\n         }\n+        assertEquals(\"bar\", exc.getUnrecognizedPropertyName());\n+        assertEquals(Bean.class, exc.getReferringClass());\n+        // also: should get list of known properties\n+        verifyException(exc, \"propX\");\n     }\n-    \n-    /*\n-    /**********************************************************\n-    /* Test methods\n-    /**********************************************************\n-     */\n \n     /**\n      * Simple test to check behavior when end-of-stream is encountered", "timestamp": 1332202445, "metainfo": ""}