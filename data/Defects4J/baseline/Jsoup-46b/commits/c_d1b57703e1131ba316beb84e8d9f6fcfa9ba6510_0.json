{"sha": "d1b57703e1131ba316beb84e8d9f6fcfa9ba6510", "log": "Speed improvements  Android focussed speed improvements. Reduced GC load with a flywheel on short strings. Optimized core consumeTo methods.", "commit": "\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n \n import org.jsoup.helper.Validate;\n \n+import java.util.Arrays;\n import java.util.Locale;\n \n /**\n  CharacterReader consumes tokens off a string. To replace the old TokenQueue.\n  */\n-class CharacterReader {\n+final class CharacterReader {\n     static final char EOF = (char) -1;\n+    private static final int maxCacheLen = 12;\n \n     private final char[] input;\n     private final int length;\n     private int pos = 0;\n     private int mark = 0;\n+    private final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n \n     CharacterReader(String input) {\n         Validate.notNull(input);\n     String consumeTo(char c) {\n         int offset = nextIndexOf(c);\n         if (offset != -1) {\n-            String consumed = new String(input, pos, offset);\n+            String consumed = cacheString(pos, offset);\n             pos += offset;\n             return consumed;\n         } else {\n     String consumeTo(String seq) {\n         int offset = nextIndexOf(seq);\n         if (offset != -1) {\n-            String consumed = new String(input, pos, offset);\n+            String consumed = cacheString(pos, offset);\n             pos += offset;\n             return consumed;\n         } else {\n     }\n \n     String consumeToAny(final char... chars) {\n-        int start = pos;\n-\n-        OUTER: while (pos < length) {\n-            for (int i = 0; i < chars.length; i++) {\n-                if (input[pos] == chars[i])\n+        final int start = pos;\n+        final int remaining = length;\n+\n+        OUTER: while (pos < remaining) {\n+            for (char c : chars) {\n+                if (input[pos] == c)\n                     break OUTER;\n             }\n             pos++;\n         }\n \n-        return pos > start ? new String(input, start, pos-start) : \"\";\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n+    }\n+\n+    String consumeToAnySorted(final char... chars) {\n+        final int start = pos;\n+        final int remaining = length;\n+        final char[] val = input;\n+\n+        while (pos < remaining) {\n+            if (Arrays.binarySearch(chars, val[pos]) >= 0)\n+                break;\n+            pos++;\n+        }\n+\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n+    }\n+\n+    String consumeData() {\n+        // &, <, null\n+        final int start = pos;\n+        final int remaining = length;\n+        final char[] val = input;\n+\n+        while (pos < remaining) {\n+            final char c = val[pos];\n+            if (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\n+                break;\n+            pos++;\n+        }\n+\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n+    }\n+\n+    String consumeTagName() {\n+        // '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\n+        final int start = pos;\n+        final int remaining = length;\n+        final char[] val = input;\n+\n+        while (pos < remaining) {\n+            final char c = val[pos];\n+            if (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\n+                break;\n+            pos++;\n+        }\n+\n+        return pos > start ? cacheString(start, pos-start) : \"\";\n     }\n \n     String consumeToEnd() {\n-        String data = new String(input, pos, length-pos);\n+        String data = cacheString(pos, length-pos);\n         pos = length;\n         return data;\n     }\n                 break;\n         }\n \n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     String consumeLetterThenDigitSequence() {\n                 break;\n         }\n \n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     String consumeHexSequence() {\n             else\n                 break;\n         }\n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     String consumeDigitSequence() {\n             else\n                 break;\n         }\n-        return new String(input, start, pos - start);\n+        return cacheString(start, pos - start);\n     }\n \n     boolean matches(char c) {\n         return false;\n     }\n \n+    boolean matchesAnySorted(char[] seq) {\n+        return !isEmpty() && Arrays.binarySearch(seq, input[pos]) >= 0;\n+    }\n+\n     boolean matchesLetter() {\n         if (isEmpty())\n             return false;\n     public String toString() {\n         return new String(input, pos, length - pos);\n     }\n+\n+    /**\n+     * Caches short strings, as a flywheel pattern, to reduce GC load. Just for this doc, to prevent leaks.\n+     * <p />\n+     * Simplistic, and on hash collisions just falls back to creating a new string, vs a full HashMap with Entry list.\n+     * That saves both having to create objects as hash keys, and running through the entry list, at the expense of\n+     * some more duplicates.\n+     */\n+    private String cacheString(final int start, final int count) {\n+        final char[] val = input;\n+        final String[] cache = stringCache;\n+\n+        // limit (no cache):\n+        if (count > maxCacheLen)\n+            return new String(val, start, count);\n+\n+        // calculate hash:\n+        int hash = 0;\n+        int offset = start;\n+        for (int i = 0; i < count; i++) {\n+            hash = 31 * hash + val[offset++];\n+        }\n+\n+        // get from cache\n+        final int index = hash & cache.length - 1;\n+        String cached = cache[index];\n+\n+        if (cached == null) { // miss, add\n+            cached = new String(val, start, count);\n+            cache[index] = cached;\n+        } else { // hashcode hit, check equality\n+            if (rangeEquals(start, count, cached)) {\n+                // hit\n+                return cached;\n+            } else { // hashcode conflict\n+                cached = new String(val, start, count);\n+            }\n+        }\n+        return cached;\n+    }\n+\n+    /**\n+     * Check if the value of the provided range equals the string.\n+     */\n+    boolean rangeEquals(final int start, int count, final String cached) {\n+        if (count == cached.length()) {\n+            char one[] = input;\n+            char two[] = cached.toCharArray();\n+            int i = start;\n+            int j = 0;\n+            while (count-- != 0) {\n+                if (one[i++] != two[j++])\n+                    return false;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n }\n--- a/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n+++ b/src/test/java/org/jsoup/parser/CharacterReaderTest.java\n         assertFalse(r.matchesAny(scan));\n     }\n \n+    @Test public void cachesStrings() {\n+        CharacterReader r = new CharacterReader(\"Check\\tCheck\\tCheck\\tCHOKE\\tA string that is longer than 16 chars\");\n+        String one = r.consumeTo('\\t');\n+        r.consume();\n+        String two = r.consumeTo('\\t');\n+        r.consume();\n+        String three = r.consumeTo('\\t');\n+        r.consume();\n+        String four = r.consumeTo('\\t');\n+        r.consume();\n+        String five = r.consumeTo('\\t');\n+\n+        assertEquals(\"Check\", one);\n+        assertEquals(\"Check\", two);\n+        assertEquals(\"Check\", three);\n+        assertEquals(\"CHOKE\", four);\n+        assertTrue(one == two);\n+        assertTrue(two == three);\n+        assertTrue(three != four);\n+        assertTrue(four != five);\n+        assertEquals(five, \"A string that is longer than 16 chars\");\n+    }\n+\n+    @Test\n+    public void rangeEquals() {\n+        CharacterReader r = new CharacterReader(\"Check\\tCheck\\tCheck\\tCHOKE\");\n+        assertTrue(r.rangeEquals(0, 5, \"Check\"));\n+        assertFalse(r.rangeEquals(0, 5, \"CHOKE\"));\n+        assertFalse(r.rangeEquals(0, 5, \"Chec\"));\n+\n+        assertTrue(r.rangeEquals(6, 5, \"Check\"));\n+        assertFalse(r.rangeEquals(6, 5, \"Chuck\"));\n+\n+        assertTrue(r.rangeEquals(12, 5, \"Check\"));\n+        assertFalse(r.rangeEquals(12, 5, \"Cheeky\"));\n+\n+        assertTrue(r.rangeEquals(18, 5, \"CHOKE\"));\n+        assertFalse(r.rangeEquals(18, 5, \"CHIKE\"));\n+    }\n+\n+\n }", "timestamp": 1414363818, "metainfo": ""}