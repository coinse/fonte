{"sha": "00aa39e3faef106f8fbb3068fa65991b1001a7c8", "log": "Tidied up Connection and Jsoup use", "commit": "\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n         public String charset();\n \n         /**\n+         * Get the response content type (e.g. \"text/html\");\n+         * @return the response content type\n+         */\n+        public String contentType();\n+\n+        /**\n          * Parse the body of the response as a Document.\n          * @return a parsed Document\n-         */\n-        public Document parse();\n+         * @throws IOException on error\n+         */\n+        public Document parse() throws IOException;\n \n         /**\n          * Get the body of the response as a plain string.\n--- a/src/main/java/org/jsoup/Jsoup.java\n+++ b/src/main/java/org/jsoup/Jsoup.java\n     }\n \n     /**\n-     Fetch a URL, and parse it as HTML.\n-     <p>\n-     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n-\n-     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n-     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n-     @return The parsed HTML.\n-\n-     @throws IOException If the final server response != 200 OK (redirects are followed), or if there's an error reading\n-     the response stream.\n+     * Creates a new {@link Connection} to a URL. Use to fetch and parse a HTML page.\n+     * <p>\n+     * Use examples:\n+     * <ul>\n+     *  <li><code>Document doc = Jsoup.connect(\"http://example.com\").userAgent(\"Mozilla\").data(\"name\", \"jsoup\").get();</code></li>\n+     *  <li><code>Document doc = Jsoup.connect(\"http://example.com\").cookie(\"auth\", \"token\").post();\n+     * </ul>\n+     * @param url URL to connect to. The protocol must be {@code http} or {@code https}.\n+     * @return the connection. You can add data, cookies, and headers; set the user-agent, referrer, method; and then execute.\n      */\n-    public static Document parse(URL url, int timeoutMillis) throws IOException {\n-        Connection con = HttpConnection.connect(url);\n-        con.timeout(timeoutMillis);\n-        return con.get();\n-    }\n-\n     public static Connection connect(String url) {\n         return HttpConnection.connect(url);\n     }\n      Parse the contents of a file as HTML.\n \n      @param in          file to load HTML from\n-     @param charsetName (optional) character set of file contents. Set to null to determine from http-equiv meta tag, if\n+     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n      present, or fall back to {@code UTF-8} (which is often safe to do).\n      @param baseUri     The URL where the HTML was retrieved from, to generate absolute URLs relative to.\n      @return sane HTML\n      Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.\n \n      @param in          file to load HTML from\n-     @param charsetName (optional) character set of file contents. Set to null to determine from http-equiv meta tag, if\n+     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n      present, or fall back to {@code UTF-8} (which is often safe to do).\n      @return sane HTML\n \n      */\n     public static Document parseBodyFragment(String bodyHtml) {\n         return Parser.parseBodyFragment(bodyHtml, \"\");\n+    }\n+\n+    /**\n+     Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use {@link #connect(String)} instead.\n+     <p>\n+     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.\n+\n+     @param url           URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.\n+     @param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.\n+     @return The parsed HTML.\n+\n+     @throws IOException If the final server response != 200 OK (redirects are followed), or if there's an error reading\n+     the response stream.\n+\n+     @see #connect(String)\n+     */\n+    public static Document parse(URL url, int timeoutMillis) throws IOException {\n+        Connection con = HttpConnection.connect(url);\n+        con.timeout(timeoutMillis);\n+        return con.get();\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.TokenQueue;\n \n-/** DRAFT implementation of Connection. */\n+/**\n+ * Implementation of {@link Connection}.\n+ * @see org.jsoup.Jsoup#connect(String) \n+ */\n public class HttpConnection implements Connection {\n     private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=([^\\\\s;]*)\");\n \n         private String statusMessage;\n         private ByteBuffer byteData;\n         private String charset;\n+        private String contentType;\n \n         static Response execute(Connection.Request req) throws IOException {\n             URL url = req.url();\n             Validate\n                 .isTrue(protocol.equals(\"http\") || protocol.equals(\"https\"), \"Only http & https protocols supported\");\n \n+            // set up the request for execution\n             if (req.method() == Connection.Method.GET && req.data().size() > 0)\n                 url = getRequestUrl(req); // appends query string\n-            \n             HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n             conn.setRequestMethod(req.method().name());\n             conn.setInstanceFollowRedirects(true);\n             conn.setReadTimeout(req.timeout());\n             if (req.method() == Connection.Method.POST)\n                 conn.setDoOutput(true);\n-            \n             if (req.cookies().size() > 0)\n                 conn.addRequestProperty(\"Cookie\", getRequestCookieString(req));\n-            \n             for (Map.Entry<String, String> header : req.headers().entrySet()) {\n                 conn.addRequestProperty(header.getKey(), header.getValue());\n             }\n-                \n-            // todo: handle get params not in url\n             conn.connect();\n-            \n             if (req.method() == Connection.Method.POST)\n                 writePost(req.data(), conn.getOutputStream());          \n \n             Response res = new Response();\n             res.setupFromConnection(conn);\n \n-            // todo: move to parse\n-            String contentType = conn.getContentType();\n-            if (contentType == null || !contentType.startsWith(\"text/\"))\n-                throw new IOException(String.format(\"Unhandled content type \\\"%s\\\" on URL %s. Must be text/*\",\n-                    contentType, url.toString()));\n-\n             InputStream inStream =\n                 (res.hasHeader(\"Content-Encoding\") && res.header(\"Content-Encoding\").equals(\"gzip\")) ?\n                     new BufferedInputStream(new GZIPInputStream(conn.getInputStream())) :\n                     new BufferedInputStream(conn.getInputStream());\n             res.byteData = DataUtil.readToByteBuffer(inStream);\n-            res.charset = getCharsetFromContentType(contentType); // may be null, readInputStream deals with it\n+            res.charset = getCharsetFromContentType(res.contentType); // may be null, readInputStream deals with it\n             inStream.close();\n \n             return res;\n             return charset;\n         }\n \n-        public Document parse() {\n+        public String contentType() {\n+            return contentType;\n+        }\n+\n+        public Document parse() throws IOException {\n+            if (contentType == null || !contentType.startsWith(\"text/\"))\n+                throw new IOException(String.format(\"Unhandled content type \\\"%s\\\" on URL %s. Must be text/*\",\n+                    contentType, url.toString()));\n             Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm());\n             byteData.rewind();\n             charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n             url = conn.getURL();\n             statusCode = conn.getResponseCode();\n             statusMessage = conn.getResponseMessage();\n+            contentType = conn.getContentType();\n \n             Map<String, List<String>> resHeaders = conn.getHeaderFields();\n             for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {", "timestamp": 1309605119, "metainfo": ""}