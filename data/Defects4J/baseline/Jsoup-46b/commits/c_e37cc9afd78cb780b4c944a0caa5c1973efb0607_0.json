{"sha": "e37cc9afd78cb780b4c944a0caa5c1973efb0607", "log": "Merge remote-tracking branch 'upstream/master'", "commit": "\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n import org.jsoup.nodes.Document;\n import org.jsoup.parser.Parser;\n \n+import java.io.IOException;\n+import java.io.InputStream;\n import java.net.URL;\n+import java.util.Collection;\n import java.util.Map;\n-import java.util.Collection;\n-import java.io.IOException;\n \n /**\n  * A Connection provides a convenient interface to fetch content from the web, and parse them into Documents.\n- * <p>\n+ * <p/>\n  * To get a new Connection, use {@link org.jsoup.Jsoup#connect(String)}. Connections contain {@link Connection.Request}\n  * and {@link Connection.Response} objects. The request objects are reusable as prototype requests.\n- * <p>\n+ * <p/>\n  * Request configuration can be made using either the shortcut methods in Connection (e.g. {@link #userAgent(String)}),\n- * or by methods in the Connection.Request object directly. All request configuration must be made before the request\n- * is executed.\n+ * or by methods in the Connection.Request object directly. All request configuration must be made before the request is\n+ * executed.\n  */\n public interface Connection {\n \n     public Connection ignoreContentType(boolean ignoreContentType);\n \n     /**\n-     * Add a request data parameter. Request parameters are sent in the request query string for GETs, and in the request\n-     * body for POSTs. A request may have multiple values of the same name.\n+     * Add a request data parameter. Request parameters are sent in the request query string for GETs, and in the\n+     * request body for POSTs. A request may have multiple values of the same name.\n      * @param key data key\n      * @param value data value\n      * @return this Connection, for chaining\n     public Connection data(String key, String value);\n \n     /**\n+     * Add an input stream as a request data paramater. For GETs, has no effect, but for POSTS this will upload the\n+     * input stream.\n+     * @param key data key (form item name)\n+     * @param filename the name of the file to present to the remove server. Typically just the name, not path,\n+     * component.\n+     * @param inputStream the input stream to upload, that you probably obtained from a {@link java.io.FileInputStream}.\n+     * You must close the InputStream in a {@code finally} block.\n+     * @return this Connections, for chaining\n+     */\n+    public Connection data(String key, String filename, InputStream inputStream);\n+\n+    /**\n      * Adds all of the supplied data to the request data parameters\n      * @param data collection of data parameters\n      * @return this Connection, for chaining\n     public Connection data(Map<String, String> data);\n \n     /**\n-     * Add a number of request data parameters. Multiple parameters may be set at once, e.g.:\n-     * <code>.data(\"name\", \"jsoup\", \"language\", \"Java\", \"language\", \"English\");</code> creates a query string like:\n+     * Add a number of request data parameters. Multiple parameters may be set at once, e.g.: <code>.data(\"name\",\n+     * \"jsoup\", \"language\", \"Java\", \"language\", \"English\");</code> creates a query string like:\n      * <code>?name=jsoup&language=Java&language=English</code>\n      * @param keyvals a set of key value pairs.\n      * @return this Connection, for chaining\n      */\n     public Connection response(Response response);\n \n-\n     /**\n      * Common methods for Requests and Responses\n      * @param <T> Type of Base, either Request or Response\n \n         /**\n          * Get the value of a header. This is a simplified header model, where a header may only have one value.\n-         * <p>\n+         * <p/>\n          * Header names are case insensitive.\n          * @param name name of header (case insensitive)\n          * @return value of header, or null if not set.\n         public String header(String name);\n \n         /**\n-         * Set a header. This method will overwrite any existing header with the same case insensitive name. \n+         * Set a header. This method will overwrite any existing header with the same case insensitive name.\n          * @param name Name of header\n          * @param value Value of header\n          * @return this, for chaining\n         public boolean hasHeader(String name);\n \n         /**\n+         * Check if a header is present, with the given value\n+         * @param name header name (case insensitive)\n+         * @param value value (case insensitive)\n+         * @return if the header and value pair are set in this req/res\n+         */\n+        public boolean hasHeaderWithValue(String name, String value);\n+\n+        /**\n          * Remove a header by name\n          * @param name name of header to remove (case insensitive)\n          * @return this, for chaining\n \n         /**\n          * Get a cookie value by name from this request/response.\n-         * <p>\n+         * <p/>\n          * Response objects have a simplified cookie model. Each cookie set in the response is added to the response\n          * object's cookie key=value map. The cookie's path, domain, and expiry date are ignored.\n          * @param name name of cookie to retrieve.\n          * @return cookies\n          */\n         public Map<String, String> cookies();\n-\n     }\n \n     /**\n \n         /**\n          * Configures the request to (not) follow server redirects. By default this is <b>true</b>.\n-         *\n          * @param followRedirects true if server redirects should be followed.\n          * @return this Request, for chaining\n          */\n \n         /**\n          * Get the current ignoreHttpErrors configuration.\n-         * @return true if errors will be ignored; false (default) if HTTP errors will cause an IOException to be thrown.\n+         * @return true if errors will be ignored; false (default) if HTTP errors will cause an IOException to be\n+         * thrown.\n          */\n         public boolean ignoreHttpErrors();\n \n-    \t/**\n-    \t * Configures the request to ignore HTTP errors in the response.\n-    \t * @param ignoreHttpErrors set to true to ignore HTTP errors.\n-         * @return this Request, for chaining\n-    \t */\n+        /**\n+         * Configures the request to ignore HTTP errors in the response.\n+         * @param ignoreHttpErrors set to true to ignore HTTP errors.\n+         * @return this Request, for chaining\n+         */\n         public Request ignoreHttpErrors(boolean ignoreHttpErrors);\n \n         /**\n          * Get the current ignoreContentType configuration.\n-         * @return true if invalid content-types will be ignored; false (default) if they will cause an IOException to be thrown.\n+         * @return true if invalid content-types will be ignored; false (default) if they will cause an IOException to\n+         * be thrown.\n          */\n         public boolean ignoreContentType();\n \n         /**\n-    \t * Configures the request to ignore the Content-Type of the response.\n-    \t * @param ignoreContentType set to true to ignore the content type.\n-         * @return this Request, for chaining\n-    \t */\n+         * Configures the request to ignore the Content-Type of the response.\n+         * @param ignoreContentType set to true to ignore the content type.\n+         * @return this Request, for chaining\n+         */\n         public Request ignoreContentType(boolean ignoreContentType);\n \n         /**\n      * Represents a HTTP response.\n      */\n     public interface Response extends Base<Response> {\n-    \t\n-    \t/**\n+\n+        /**\n          * Get the status code of the response.\n          * @return status code\n          */\n          * @return the value\n          */\n         public String value();\n+\n+        /**\n+         * Add or update an input stream to this keyVal\n+         * @param inputStream new input stream\n+         * @return this KeyVal, for chaining\n+         */\n+        public KeyVal inputStream(InputStream inputStream);\n+\n+        /**\n+         * Get the input stream associated with this keyval, if any\n+         * @return input stream if set, or null\n+         */\n+        public InputStream inputStream();\n+\n+        /**\n+         * Does this keyval have an input stream?\n+         * @return true if this keyval does indeed have an input stream\n+         */\n+        public boolean hasInputStream();\n     }\n }\n-\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n import java.nio.charset.IllegalCharsetNameException;\n+import java.util.Random;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n import java.util.Locale;\n  * Internal static utilities for handling data.\n  *\n  */\n-public class DataUtil {\n+public final class DataUtil {\n     private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\");\n     static final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\n     private static final int bufferSize = 0x20000; // ~130K.\n+    private static final char[] mimeBoundaryChars =\n+            \"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\n+    static final int boundaryLength = 32;\n \n     private DataUtil() {}\n \n     public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n         ByteBuffer byteData = readToByteBuffer(in);\n         return parseByteData(byteData, charsetName, baseUri, parser);\n+    }\n+\n+    /**\n+     * Writes the input stream to the output stream. Doesn't close them.\n+     * @param in input stream to read from\n+     * @param out output stream to write to\n+     * @throws IOException on IO error\n+     */\n+    static void crossStreams(final InputStream in, final OutputStream out) throws IOException {\n+        final byte[] buffer = new byte[bufferSize];\n+        int len;\n+        while ((len = in.read(buffer)) != -1) {\n+            out.write(buffer, 0, len);\n+        }\n     }\n \n     // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n         }\n         return null;\n     }\n-    \n-    \n+\n+    /**\n+     * Creates a random string, suitable for use as a mime boundary\n+     */\n+    static String mimeBoundary() {\n+        final StringBuilder mime = new StringBuilder(boundaryLength);\n+        final Random rand = new Random();\n+        for (int i = 0; i < boundaryLength; i++) {\n+            mime.append(mimeBoundaryChars[rand.nextInt(mimeBoundaryChars.length)]);\n+        }\n+        return mime.toString();\n+    }\n }\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n  */\n public class HttpConnection implements Connection {\n     private static final int HTTP_TEMP_REDIR = 307; // http/1.1 temporary redirect, not in Java's set.\n+    public static final String  CONTENT_ENCODING = \"Content-Encoding\";\n+    private static final String CONTENT_TYPE = \"Content-Type\";\n+    private static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n \n     public static Connection connect(String url) {\n         Connection con = new HttpConnection();\n \t\t\treturn null;\n     \treturn url.replaceAll(\" \", \"%20\");\n \t}\n+\n+    private static String encodeMimeName(String val) {\n+        if (val == null)\n+            return null;\n+        return val.replaceAll(\"\\\"\", \"%22\");\n+    }\n \n     private Connection.Request req;\n     private Connection.Response res;\n \n     public Connection data(String key, String value) {\n         req.data(KeyVal.create(key, value));\n+        return this;\n+    }\n+\n+    public Connection data(String key, String filename, InputStream inputStream) {\n+        req.data(KeyVal.create(key, filename, inputStream));\n         return this;\n     }\n \n         public boolean hasHeader(String name) {\n             Validate.notEmpty(name, \"Header name must not be empty\");\n             return getHeaderCaseInsensitive(name) != null;\n+        }\n+\n+        /**\n+         * Test if the request has a header with this value (case insensitive).\n+         */\n+        public boolean hasHeaderWithValue(String name, String value) {\n+            return hasHeader(name) && header(name).equalsIgnoreCase(value);\n         }\n \n         public T removeHeader(String name) {\n         }\n \n         public String cookie(String name) {\n-            Validate.notNull(name, \"Cookie name must not be null\");\n+            Validate.notEmpty(name, \"Cookie name must not be empty\");\n             return cookies.get(name);\n         }\n \n         }\n \n         public boolean hasCookie(String name) {\n-            Validate.notEmpty(\"Cookie name must not be empty\");\n+            Validate.notEmpty(name, \"Cookie name must not be empty\");\n             return cookies.containsKey(name);\n         }\n \n         public T removeCookie(String name) {\n-            Validate.notEmpty(\"Cookie name must not be empty\");\n+            Validate.notEmpty(name, \"Cookie name must not be empty\");\n             cookies.remove(name);\n             return (T) this;\n         }\n         }\n     }\n \n-    public static class Request extends Base<Connection.Request> implements Connection.Request {\n+    public static class Request extends HttpConnection.Base<Connection.Request> implements Connection.Request {\n         private int timeoutMilliseconds;\n         private int maxBodySizeBytes;\n         private boolean followRedirects;\n         }\n     }\n \n-    public static class Response extends Base<Connection.Response> implements Connection.Response {\n+    public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response {\n         private static final int MAX_REDIRECTS = 20;\n         private static SSLSocketFactory sslSocketFactory;\n         private int statusCode;\n                 throw new MalformedURLException(\"Only http & https protocols supported\");\n \n             // set up the request for execution\n-            if (req.method() == Connection.Method.GET && req.data().size() > 0)\n+            String mimeBoundary = null;\n+            if (req.method() == Connection.Method.GET && req.data().size() > 0) {\n                 serialiseRequestUrl(req); // appends query string\n+            } else {\n+                mimeBoundary = setupMultipartModeIfNeeded(req);\n+            }\n             HttpURLConnection conn = createConnection(req);\n             Response res;\n             try {\n                 conn.connect();\n                 if (req.method() == Connection.Method.POST)\n-                    writePost(req.data(), conn.getOutputStream());\n+                    writePost(req, conn.getOutputStream(), mimeBoundary);\n \n                 int status = conn.getResponseCode();\n                 boolean needsRedirect = false;\n                 InputStream dataStream = null;\n                 try {\n                     dataStream = conn.getErrorStream() != null ? conn.getErrorStream() : conn.getInputStream();\n-                    bodyStream = res.hasHeader(\"Content-Encoding\") && res.header(\"Content-Encoding\").equalsIgnoreCase(\"gzip\") ?\n+                    bodyStream = res.hasHeaderWithValue(CONTENT_ENCODING, \"gzip\") ?\n                             new BufferedInputStream(new GZIPInputStream(dataStream)) :\n                             new BufferedInputStream(dataStream);\n \n             }\n         }\n \n-        private static void writePost(Collection<Connection.KeyVal> data, OutputStream outputStream) throws IOException {\n-            OutputStreamWriter w = new OutputStreamWriter(outputStream, DataUtil.defaultCharset);\n-            boolean first = true;\n-            for (Connection.KeyVal keyVal : data) {\n-                if (!first)\n-                    w.append('&');\n-                else\n-                    first = false;\n-\n-                w.write(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset));\n-                w.write('=');\n-                w.write(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n+        private static String setupMultipartModeIfNeeded(final Connection.Request req) {\n+            // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n+            boolean needsMulti = false;\n+            for (Connection.KeyVal keyVal : req.data()) {\n+                if (keyVal.hasInputStream()) {\n+                    needsMulti = true;\n+                    break;\n+                }\n+            }\n+            if (needsMulti) {\n+                final String bound = DataUtil.mimeBoundary();\n+                req.header(CONTENT_TYPE, MULTIPART_FORM_DATA + \"; boundary=\" + bound);\n+                return bound;\n+            }\n+            return null;\n+        }\n+\n+        private static void writePost(final Connection.Request req, final OutputStream outputStream, final String bound) throws IOException {\n+            final Collection<Connection.KeyVal> data = req.data();\n+            final BufferedWriter w = new BufferedWriter(new OutputStreamWriter(outputStream, DataUtil.defaultCharset));\n+\n+            if (bound != null) {\n+                // boundary will be set if we're in multipart mode\n+                for (Connection.KeyVal keyVal : data) {\n+                    w.write(\"--\");\n+                    w.write(bound);\n+                    w.write(\"\\r\\n\");\n+                    w.write(\"Content-Disposition: form-data; name=\\\"\");\n+                    w.write(encodeMimeName(keyVal.key())); // encodes \" to %22\n+                    w.write(\"\\\"\");\n+                    if (keyVal.hasInputStream()) {\n+                        w.write(\"; filename=\\\"\");\n+                        w.write(encodeMimeName(keyVal.value()));\n+                        w.write(\"\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\");\n+                        w.flush(); // flush\n+                        DataUtil.crossStreams(keyVal.inputStream(), outputStream);\n+                        outputStream.flush();\n+                    } else {\n+                        w.write(\"\\r\\n\\r\\n\");\n+                        w.write(keyVal.value());\n+                    }\n+                    w.write(\"\\r\\n\");\n+                }\n+                w.write(\"--\");\n+                w.write(bound);\n+                w.write(\"--\");\n+            } else {\n+                // regular form data (application/x-www-form-urlencoded)\n+                boolean first = true;\n+                for (Connection.KeyVal keyVal : data) {\n+                    if (!first)\n+                        w.append('&');\n+                    else\n+                        first = false;\n+\n+                    w.write(URLEncoder.encode(keyVal.key(), DataUtil.defaultCharset));\n+                    w.write('=');\n+                    w.write(URLEncoder.encode(keyVal.value(), DataUtil.defaultCharset));\n+                }\n             }\n             w.close();\n         }\n     public static class KeyVal implements Connection.KeyVal {\n         private String key;\n         private String value;\n+        private InputStream stream;\n \n         public static KeyVal create(String key, String value) {\n-            Validate.notEmpty(key, \"Data key must not be empty\");\n-            Validate.notNull(value, \"Data value must not be null\");\n-            return new KeyVal(key, value);\n-        }\n-\n-        private KeyVal(String key, String value) {\n-            this.key = key;\n-            this.value = value;\n-        }\n+            return new KeyVal().key(key).value(value);\n+        }\n+\n+        public static KeyVal create(String key, String filename, InputStream stream) {\n+            return new KeyVal().key(key).value(filename).inputStream(stream);\n+        }\n+\n+        private KeyVal() {}\n \n         public KeyVal key(String key) {\n             Validate.notEmpty(key, \"Data key must not be empty\");\n             return value;\n         }\n \n+        public KeyVal inputStream(InputStream inputStream) {\n+            Validate.notNull(value, \"Data input stream must not be null\");\n+            this.stream = inputStream;\n+            return this;\n+        }\n+\n+        public InputStream inputStream() {\n+            return stream;\n+        }\n+\n+        public boolean hasInputStream() {\n+            return stream != null;\n+        }\n+\n         @Override\n         public String toString() {\n             return key + \"=\" + value;\n--- a/src/main/java/org/jsoup/helper/StringUtil.java\n+++ b/src/main/java/org/jsoup/helper/StringUtil.java\n      * @param accum builder to append to\n      * @param string string to normalize whitespace within\n      * @param stripLeading set to true if you wish to remove any leading whitespace\n-     * @return\n      */\n     public static void appendNormalisedWhitespace(StringBuilder accum, String string, boolean stripLeading) {\n         boolean lastWasWhite = false;\n--- a/src/main/java/org/jsoup/nodes/FormElement.java\n+++ b/src/main/java/org/jsoup/nodes/FormElement.java\n \n             if (\"select\".equals(el.tagName())) {\n                 Elements options = el.select(\"option[selected]\");\n+                boolean set = false;\n                 for (Element option: options) {\n                     data.add(HttpConnection.KeyVal.create(name, option.val()));\n+                    set = true;\n+                }\n+                if (!set) {\n+                    Element option = el.select(\"option\").first();\n+                    if (option != null)\n+                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                 }\n             } else {\n                 data.add(HttpConnection.KeyVal.create(name, el.val()));\n--- a/src/main/java/org/jsoup/safety/Whitelist.java\n+++ b/src/main/java/org/jsoup/safety/Whitelist.java\n  <li>{@link #addProtocols}\n  </ul>\n  <p/>\n+ You can remove any setting from an existing whitelist with:\n+ <ul>\n+ <li>{@link #removeTags}\n+ <li>{@link #removeAttributes}\n+ <li>{@link #removeEnforcedAttribute}\n+ <li>{@link #removeProtocols}\n+ </ul>\n+ <p/>\n  The cleaner and these whitelists assume that you want to clean a <code>body</code> fragment of HTML (to add user\n  supplied HTML into a templated page), and not to clean a full HTML document. If the latter is the case, either wrap the\n  document HTML around the cleaned body HTML, or create a whitelist that allows <code>html</code> and <code>head</code>\n     }\n \n     /**\n+     Remove a list of allowed elements from a whitelist. (If a tag is not allowed, it will be removed from the HTML.)\n+\n+     @param tags tag names to disallow\n+     @return this (for chaining)\n+     */\n+    public Whitelist removeTags(String... tags) {\n+        Validate.notNull(tags);\n+\n+        for(String tag: tags) {\n+            Validate.notEmpty(tag);\n+            TagName tagName = TagName.valueOf(tag);\n+\n+            if(tagNames.remove(tagName)) { // Only look in sub-maps if tag was allowed\n+                attributes.remove(tagName);\n+                enforcedAttributes.remove(tagName);\n+                protocols.remove(tagName);\n+            }\n+        }\n+        return this;\n+    }\n+\n+    /**\n      Add a list of allowed attributes to a tag. (If an attribute is not allowed on an element, it will be removed.)\n      <p/>\n      E.g.: <code>addAttributes(\"a\", \"href\", \"class\")</code> allows <code>href</code> and <code>class</code> attributes\n     }\n \n     /**\n+     Remove a list of allowed attributes from a tag. (If an attribute is not allowed on an element, it will be removed.)\n+     <p/>\n+     E.g.: <code>removeAttributes(\"a\", \"href\", \"class\")</code> disallows <code>href</code> and <code>class</code>\n+     attributes on <code>a</code> tags.\n+     <p/>\n+     To make an attribute invalid for <b>all tags</b>, use the pseudo tag <code>:all</code>, e.g.\n+     <code>removeAttributes(\":all\", \"class\")</code>.\n+\n+     @param tag  The tag the attributes are for.\n+     @param keys List of invalid attributes for the tag\n+     @return this (for chaining)\n+     */\n+    public Whitelist removeAttributes(String tag, String... keys) {\n+        Validate.notEmpty(tag);\n+        Validate.notNull(keys);\n+        Validate.isTrue(keys.length > 0, \"No attributes supplied.\");\n+\n+        TagName tagName = TagName.valueOf(tag);\n+        Set<AttributeKey> attributeSet = new HashSet<AttributeKey>();\n+        for (String key : keys) {\n+            Validate.notEmpty(key);\n+            attributeSet.add(AttributeKey.valueOf(key));\n+        }\n+        if(tagNames.contains(tagName) && attributes.containsKey(tagName)) { // Only look in sub-maps if tag was allowed\n+            Set<AttributeKey> currentSet = attributes.get(tagName);\n+            currentSet.removeAll(attributeSet);\n+\n+            if(currentSet.isEmpty()) // Remove tag from attribute map if no attributes are allowed for tag\n+                attributes.remove(tagName);\n+        }\n+        if(tag.equals(\":all\")) // Attribute needs to be removed from all individually set tags\n+            for(TagName name: attributes.keySet()) {\n+                Set<AttributeKey> currentSet = attributes.get(name);\n+                currentSet.removeAll(attributeSet);\n+\n+                if(currentSet.isEmpty()) // Remove tag from attribute map if no attributes are allowed for tag\n+                    attributes.remove(name);\n+            }\n+        return this;\n+    }\n+\n+    /**\n      Add an enforced attribute to a tag. An enforced attribute will always be added to the element. If the element\n      already has the attribute set, it will be overridden.\n      <p/>\n             Map<AttributeKey, AttributeValue> attrMap = new HashMap<AttributeKey, AttributeValue>();\n             attrMap.put(attrKey, attrVal);\n             enforcedAttributes.put(tagName, attrMap);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     Remove a previously configured enforced attribute from a tag.\n+\n+     @param tag   The tag the enforced attribute is for.\n+     @param key   The attribute key\n+     @return this (for chaining)\n+     */\n+    public Whitelist removeEnforcedAttribute(String tag, String key) {\n+        Validate.notEmpty(tag);\n+        Validate.notEmpty(key);\n+\n+        TagName tagName = TagName.valueOf(tag);\n+        if(tagNames.contains(tagName) && enforcedAttributes.containsKey(tagName)) {\n+            AttributeKey attrKey = AttributeKey.valueOf(key);\n+            Map<AttributeKey, AttributeValue> attrMap = enforcedAttributes.get(tagName);\n+            attrMap.remove(attrKey);\n+\n+            if(attrMap.isEmpty()) // Remove tag from enforced attribute map if no enforced attributes are present\n+                enforcedAttributes.remove(tagName);\n         }\n         return this;\n     }\n      URLs with the defined protocol.\n      <p/>\n      E.g.: <code>addProtocols(\"a\", \"href\", \"ftp\", \"http\", \"https\")</code>\n+     <p/>\n+     To allow a link to an in-page URL anchor (i.e. <code>&lt;a href=\"#anchor\"&gt;</code>, add a <code>#</code>:<br>\n+     E.g.: <code>addProtocols(\"a\", \"href\", \"#\")</code>\n \n      @param tag       Tag the URL protocol is for\n      @param key       Attribute key\n             Validate.notEmpty(protocol);\n             Protocol prot = Protocol.valueOf(protocol);\n             protSet.add(prot);\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     Remove allowed URL protocols for an element's URL attribute.\n+     <p/>\n+     E.g.: <code>removeProtocols(\"a\", \"href\", \"ftp\")</code>\n+\n+     @param tag       Tag the URL protocol is for\n+     @param key       Attribute key\n+     @param protocols List of invalid protocols\n+     @return this, for chaining\n+     */\n+    public Whitelist removeProtocols(String tag, String key, String... protocols) {\n+        Validate.notEmpty(tag);\n+        Validate.notEmpty(key);\n+        Validate.notNull(protocols);\n+\n+        TagName tagName = TagName.valueOf(tag);\n+        AttributeKey attrKey = AttributeKey.valueOf(key);\n+\n+        if(this.protocols.containsKey(tagName)) {\n+            Map<AttributeKey, Set<Protocol>> attrMap = this.protocols.get(tagName);\n+            if(attrMap.containsKey(attrKey)) {\n+                Set<Protocol> protSet = attrMap.get(attrKey);\n+                for (String protocol : protocols) {\n+                    Validate.notEmpty(protocol);\n+                    Protocol prot = Protocol.valueOf(protocol);\n+                    protSet.remove(prot);\n+                }\n+\n+                if(protSet.isEmpty()) { // Remove protocol set if empty\n+                    attrMap.remove(attrKey);\n+                    if(attrMap.isEmpty()) // Remove entry for tag if empty\n+                        this.protocols.remove(tagName);\n+                }\n+            }\n         }\n         return this;\n     }\n             attr.setValue(value);\n         \n         for (Protocol protocol : protocols) {\n-            String prot = protocol.toString() + \":\";\n+            String prot = protocol.toString();\n+\n+            if (prot.equals(\"#\")) { // allows anchor links\n+                if (isValidAnchor(value)) {\n+                    return true;\n+                } else {\n+                    continue;\n+                }\n+            }\n+\n+            prot += \":\";\n+\n             if (value.toLowerCase().startsWith(prot)) {\n                 return true;\n             }\n         }\n         return false;\n+    }\n+\n+    private boolean isValidAnchor(String value) {\n+        return value.startsWith(\"#\") && !value.matches(\".*\\\\s.*\");\n     }\n \n     Attributes getEnforcedAttributes(String tagName) {\n--- a/src/test/java/org/jsoup/helper/DataUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/DataUtilTest.java\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n \n-import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.*;\n \n public class DataUtilTest {\n     @Test\n         assertEquals(null, DataUtil.getCharsetFromContentType(\"text/html; charset=$HJKDF\u00a7$/(\"));\n     }\n \n+    @Test\n+    public void generatesMimeBoundaries() {\n+        String m1 = DataUtil.mimeBoundary();\n+        String m2 = DataUtil.mimeBoundary();\n+\n+        assertEquals(DataUtil.boundaryLength, m1.length());\n+        assertEquals(DataUtil.boundaryLength, m2.length());\n+        assertNotSame(m1, m2);\n+    }\n+\n }\n--- a/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n+++ b/src/test/java/org/jsoup/helper/HttpConnectionTest.java\n package org.jsoup.helper;\n \n import static org.junit.Assert.*;\n+\n+import org.jsoup.integration.ParseTest;\n import org.junit.Test;\n import org.jsoup.Connection;\n \n         con.cookie(\"Name\", \"Val\");\n         assertEquals(\"Val\", con.request().cookie(\"Name\"));\n     }\n-}\n+\n+    @Test public void inputStream() {\n+        Connection.KeyVal kv = HttpConnection.KeyVal.create(\"file\", \"thumb.jpg\", ParseTest.inputStreamFrom(\"Check\"));\n+        assertEquals(\"file\", kv.key());\n+        assertEquals(\"thumb.jpg\", kv.value());\n+        assertTrue(kv.hasInputStream());\n+\n+        kv = HttpConnection.KeyVal.create(\"one\", \"two\");\n+        assertEquals(\"one\", kv.key());\n+        assertEquals(\"two\", kv.value());\n+        assertFalse(kv.hasInputStream());\n+    }\n+}\n--- a/src/test/java/org/jsoup/integration/ParseTest.java\n+++ b/src/test/java/org/jsoup/integration/ParseTest.java\n         assertEquals(\"In July, GM said its electric Chevrolet Volt will be sold in the United States at $41,000 -- $8,000 more than its nearest competitor, the Nissan Leaf.\", p.text());\n     }\n \n-    public File getFile(String resourceName) {\n+    public static File getFile(String resourceName) {\n         try {\n             File file = new File(ParseTest.class.getResource(resourceName).toURI());\n             return file;\n         }\n     }\n \n-    private InputStream inputStreamFrom(String s) {\n+    public static InputStream inputStreamFrom(String s) {\n         try {\n             return new ByteArrayInputStream(s.getBytes(\"UTF-8\"));\n         } catch (UnsupportedEncodingException e) {\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n import org.jsoup.Jsoup;\n import org.jsoup.UnsupportedMimeTypeException;\n import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.FormElement;\n import org.junit.Ignore;\n import org.junit.Test;\n \n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.net.MalformedURLException;\n import java.net.URL;\n         assertEquals(\"http://example.com/foo.jpg\", doc.select(\"img\").first().absUrl(\"src\"));\n     }\n \n+    /**\n+     * Test fetching a form, and submitting it with a file attached.\n+     */\n+    @Test\n+    public void postHtmlFile() throws IOException {\n+        Document index = Jsoup.connect(\"http://direct.infohound.net/tidy/\").get();\n+        FormElement form = index.select(\"[name=tidy]\").forms().get(0);\n+        Connection post = form.submit();\n+\n+        File uploadFile = ParseTest.getFile(\"/htmltests/google-ipod.html\");\n+        FileInputStream stream = new FileInputStream(uploadFile);\n+\n+        // todo: need to add a better way to get an existing data field\n+        for (Connection.KeyVal keyVal : post.request().data()) {\n+            if (keyVal.key().equals(\"_file\")) {\n+                keyVal.value(\"check.html\");\n+                keyVal.inputStream(stream);\n+            }\n+        }\n+\n+        Connection.Response res;\n+        try {\n+            res = post.execute();\n+        } finally {\n+            stream.close();\n+        }\n+\n+        Document out = res.parse();\n+        assertTrue(out.text().contains(\"HTML Tidy Complete\"));\n+    }\n+\n+    /**\n+     * Tests upload of binary content to a remote service.\n+     */\n+    @Test\n+    public void postJpeg() throws IOException {\n+        File thumb = ParseTest.getFile(\"/htmltests/thumb.jpg\");\n+        Document result = Jsoup\n+                .connect(\"http://regex.info/exif.cgi\")\n+                .data(\"f\", thumb.getName(), new FileInputStream(thumb))\n+                .post();\n+\n+        assertEquals(\"Baseline DCT, Huffman coding\", result.select(\"td:contains(Process) + td\").text());\n+\n+    }\n+\n }\n--- a/src/test/java/org/jsoup/safety/CleanerTest.java\n+++ b/src/test/java/org/jsoup/safety/CleanerTest.java\n         String cleanHtml = Jsoup.clean(h, Whitelist.relaxed());\n         assertEquals(\"<h1>Head</h1><table><tbody><tr><td>One</td><td>Two</td></tr></tbody></table>\", TextUtil.stripNewlines(cleanHtml));\n     }\n+\n+    @Test public void testRemoveTags() {\n+        String h = \"<div><p><A HREF='HTTP://nice.com'>Nice</a></p><blockquote>Hello</blockquote>\";\n+        String cleanHtml = Jsoup.clean(h, Whitelist.basic().removeTags(\"a\"));\n+\n+        assertEquals(\"<p>Nice</p><blockquote>Hello</blockquote>\", TextUtil.stripNewlines(cleanHtml));\n+    }\n+\n+    @Test public void testRemoveAttributes() {\n+        String h = \"<div><p>Nice</p><blockquote cite='http://example.com/quotations'>Hello</blockquote>\";\n+        String cleanHtml = Jsoup.clean(h, Whitelist.basic().removeAttributes(\"blockquote\", \"cite\"));\n+\n+        assertEquals(\"<p>Nice</p><blockquote>Hello</blockquote>\", TextUtil.stripNewlines(cleanHtml));\n+    }\n+\n+    @Test public void testRemoveEnforcedAttributes() {\n+        String h = \"<div><p><A HREF='HTTP://nice.com'>Nice</a></p><blockquote>Hello</blockquote>\";\n+        String cleanHtml = Jsoup.clean(h, Whitelist.basic().removeEnforcedAttribute(\"a\", \"rel\"));\n+\n+        assertEquals(\"<p><a href=\\\"http://nice.com\\\">Nice</a></p><blockquote>Hello</blockquote>\",\n+                TextUtil.stripNewlines(cleanHtml));\n+    }\n+\n+    @Test public void testRemoveProtocols() {\n+        String h = \"<p>Contact me <a href='mailto:info@example.com'>here</a></p>\";\n+        String cleanHtml = Jsoup.clean(h, Whitelist.basic().removeProtocols(\"a\", \"href\", \"ftp\", \"mailto\"));\n+\n+        assertEquals(\"<p>Contact me <a rel=\\\"nofollow\\\">here</a></p>\",\n+                TextUtil.stripNewlines(cleanHtml));\n+    }\n     \n     @Test public void testDropComments() {\n         String h = \"<p>Hello<!-- no --></p>\";\n         String h = \"<A HREF=\\\"javascript:document.location='http://www.google.com/'\\\">XSS</A>\";\n         String cleanHtml = Jsoup.clean(h, Whitelist.relaxed());\n         assertEquals(\"<a>XSS</a>\", cleanHtml);\n+    }\n+\n+    @Test public void testCleanAnchorProtocol() {\n+        String validAnchor = \"<a href=\\\"#valid\\\">Valid anchor</a>\";\n+        String invalidAnchor = \"<a href=\\\"#anchor with spaces\\\">Invalid anchor</a>\";\n+\n+        // A Whitelist that does not allow anchors will strip them out.\n+        String cleanHtml = Jsoup.clean(validAnchor, Whitelist.relaxed());\n+        assertEquals(\"<a>Valid anchor</a>\", cleanHtml);\n+\n+        cleanHtml = Jsoup.clean(invalidAnchor, Whitelist.relaxed());\n+        assertEquals(\"<a>Invalid anchor</a>\", cleanHtml);\n+\n+        // A Whitelist that allows them will keep them.\n+        Whitelist relaxedWithAnchor = Whitelist.relaxed().addProtocols(\"a\", \"href\", \"#\");\n+\n+        cleanHtml = Jsoup.clean(validAnchor, relaxedWithAnchor);\n+        assertEquals(validAnchor, cleanHtml);\n+\n+        // An invalid anchor is never valid.\n+        cleanHtml = Jsoup.clean(invalidAnchor, relaxedWithAnchor);\n+        assertEquals(\"<a>Invalid anchor</a>\", cleanHtml);\n     }\n \n     @Test public void testDropsUnknownTags() {\n--- a/src/test/java/org/jsoup/select/ElementsTest.java\n+++ b/src/test/java/org/jsoup/select/ElementsTest.java\n         assertEquals(\"1\", forms.get(0).id());\n         assertEquals(\"2\", forms.get(1).id());\n     }\n+\n+    @Test public void classWithHyphen() {\n+        Document doc = Jsoup.parse(\"<p class='tab-nav'>Check</p>\");\n+        Elements els = doc.getElementsByClass(\"tab-nav\");\n+        assertEquals(1, els.size());\n+        assertEquals(\"Check\", els.text());\n+    }\n }\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n     }\n \n     /**\n+     * Setter to disable\\enable SSL certificates checks during https connection\n+     * @param value\n+     */\n+    Connection setSecure (boolean value);\n+\n+    /**\n      * Set the request URL to fetch. The protocol must be HTTP or HTTPS.\n      * @param url URL to connect to\n      * @return this Connection, for chaining\n      * Represents a HTTP request.\n      */\n     public interface Request extends Base<Request> {\n+\n+\n         /**\n          * Get the request timeout, in milliseconds.\n          * @return the timeout in milliseconds.\n          * @return current Parser\n          */\n         public Parser parser();\n+\n+        /**\n+         * get current state of security enabling\\disabling feature\n+         *\n+         * @return\n+         */\n+        boolean isSecure();\n+\n+        /**\n+         * Disable SSL certificates checks.\n+         * @param value\n+         */\n+        void setSecure(boolean value);\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n \n+import javax.net.ssl.*;\n import java.io.*;\n import java.net.HttpURLConnection;\n import java.net.MalformedURLException;\n import java.net.URLEncoder;\n import java.nio.ByteBuffer;\n import java.nio.charset.Charset;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.X509Certificate;\n import java.util.*;\n import java.util.regex.Pattern;\n import java.util.zip.GZIPInputStream;\n \tprivate HttpConnection() {\n         req = new Request();\n         res = new Response();\n+    }\n+\n+    public Connection setSecure(boolean value) {\n+        req.setSecure(value);\n+        return this;\n     }\n \n     public Connection url(URL url) {\n         private boolean ignoreHttpErrors = false;\n         private boolean ignoreContentType = false;\n         private Parser parser;\n-\n-      \tprivate Request() {\n+//      always default to secure connections in https\n+        private boolean secure = true;\n+\n+        private Request() {\n             timeoutMilliseconds = 3000;\n             maxBodySizeBytes = 1024 * 1024; // 1MB\n             followRedirects = true;\n         public Parser parser() {\n             return parser;\n         }\n+\n+        public boolean isSecure() {\n+            return secure;\n+        }\n+\n+        public void setSecure(boolean value) {\n+            secure = value;\n+        }\n     }\n \n     public static class Response extends HttpConnection.Base<Connection.Response> implements Connection.Response {\n         private static final int MAX_REDIRECTS = 20;\n+        private static SSLSocketFactory sslSocketFactory;\n         private int statusCode;\n         private String statusMessage;\n         private ByteBuffer byteData;\n         // set up connection defaults, and details from request\n         private static HttpURLConnection createConnection(Connection.Request req) throws IOException {\n             HttpURLConnection conn = (HttpURLConnection) req.url().openConnection();\n+\n             conn.setRequestMethod(req.method().name());\n             conn.setInstanceFollowRedirects(false); // don't rely on native redirection support\n             conn.setConnectTimeout(req.timeout());\n             conn.setReadTimeout(req.timeout());\n+            if (!req.isSecure()) {\n+                initUnSecureSSL();\n+                if (conn instanceof HttpsURLConnection) {\n+                    ((HttpsURLConnection)conn).setSSLSocketFactory(sslSocketFactory);\n+                }\n+            }\n             if (req.method() == Method.POST)\n                 conn.setDoOutput(true);\n             if (req.cookies().size() > 0)\n                 conn.addRequestProperty(header.getKey(), header.getValue());\n             }\n             return conn;\n+        }\n+\n+        /**\n+         * Initialise Trust manager that does not validate certificate chains and\n+         * add it to current SSLContext.\n+         *\n+         * @throws IOException\n+         */\n+        private static void initUnSecureSSL() throws IOException {\n+            if ( sslSocketFactory == null) {\n+                // Create a trust manager that does not validate certificate chains\n+                final TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() {\n+\n+                    public void checkClientTrusted( final X509Certificate[] chain, final String authType ) {\n+                    }\n+\n+                    public void checkServerTrusted( final X509Certificate[] chain, final String authType ) {\n+                    }\n+\n+                    public X509Certificate[] getAcceptedIssuers() {\n+                        return null;\n+                    }\n+                } };\n+\n+                // Install the all-trusting trust manager\n+                final SSLContext sslContext;\n+                try {\n+                    sslContext = SSLContext.getInstance(\"SSL\");\n+                    sslContext.init( null, trustAllCerts, new java.security.SecureRandom() );\n+                    // Create an ssl socket factory with our all-trusting manager\n+                    sslSocketFactory = sslContext.getSocketFactory();\n+                } catch (NoSuchAlgorithmException e) {\n+                    throw new IOException(\"Can't create unsecure trust manager\");\n+                } catch (KeyManagementException e) {\n+                    throw new IOException(\"Can't create unsecure trust manager\");\n+                }\n+            }\n+\n         }\n \n         // set up url, method, header, cookies\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n import java.net.URL;\n import java.util.Map;\n \n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n+import static org.hamcrest.core.Is.is;\n+import static org.junit.Assert.*;\n \n /**\n  Tests the URL connection. Not enabled by default, so tests don't require network connection.\n         assertEquals(actualDocText, unlimitedRes.parse().text().length());\n     }\n \n+    /**\n+     * Verify that security disabling feature works properly.\n+     *\n+     * 1. try to hit url with invalid certificate and evaluate that exception is thrown\n+     * 2. disable security checks and call the same url to verify that content is consumed correctly\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testUnsafe() throws Exception {\n+        String url = \"https://certs.cac.washington.edu/CAtest/\";\n+\n+        try {\n+            Jsoup.connect(url).execute();\n+        } catch (IOException e) {\n+//          that's expected exception\n+        }\n+        Connection.Response  defaultRes = Jsoup.connect(url).setSecure(false).execute();\n+        assertThat(defaultRes.statusCode(),is(200));\n+    }\n+\n     @Test\n     public void shouldWorkForCharsetInExtraAttribute() throws IOException {\n         Connection.Response res = Jsoup.connect(\"https://www.creditmutuel.com/groupe/fr/\").execute();", "timestamp": 1412750173, "metainfo": ""}