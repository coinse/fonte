{"sha": "6d6ee1cc96d6f17f547fd9f39a38966da35ab159", "log": "Merge remote-tracking branch 'upstream/master' into update_meta_charset", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n  */\n public class Element extends Node {\n     private Tag tag;\n+\n+    private static final Pattern classSplit = Pattern.compile(\"\\\\s+\");\n+\n     /**\n      * Create a new, standalone Element. (Standalone in that is has no parent.)\n      * \n      * @return The id attribute, if present, or an empty string if not.\n      */\n     public String id() {\n-        String id = attr(\"id\");\n-        return id == null ? \"\" : id;\n+        return attributes.get(\"id\");\n     }\n \n     /**\n      * @return set of classnames, empty if no class attribute\n      */\n     public Set<String> classNames() {\n-    \tString[] names = className().split(\"\\\\s+\");\n+    \tString[] names = classSplit.split(className());\n     \tSet<String> classNames = new LinkedHashSet<String>(Arrays.asList(names));\n     \tclassNames.remove(\"\"); // if classNames() was empty, would include an empty class\n \n      * @param className name of class to check for\n      * @return true if it does, false if not\n      */\n+    /*\n+    Used by common .class selector, so perf tweaked to reduce object creation vs hitting classnames().\n+\n+    Wiki: 71, 13 (5.4x)\n+    CNN: 227, 91 (2.5x)\n+    Alterslash: 59, 4 (14.8x)\n+    Jsoup: 14, 1 (14x)\n+    */\n     public boolean hasClass(String className) {\n-        Set<String> classNames = classNames();\n-        for (String name : classNames) {\n+        String classAttr = attributes.get(\"class\");\n+        if (classAttr.equals(\"\") || classAttr.length() < className.length())\n+            return false;\n+\n+        final String[] classes = classSplit.split(classAttr);\n+        for (String name : classes) {\n             if (className.equalsIgnoreCase(name))\n                 return true;\n         }\n+\n         return false;\n     }\n \n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n \n         boolean lastWasWhite = false;\n         boolean reachedNonWhite = false;\n-        EscapeMode escapeMode = out.escapeMode();\n-        CharsetEncoder encoder = out.encoder();\n-        Map<Character, String> map = escapeMode.getMap();\n+        final EscapeMode escapeMode = out.escapeMode();\n+        final CharsetEncoder encoder = out.encoder();\n+        final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n+        final Map<Character, String> map = escapeMode.getMap();\n         final int length = string.length();\n \n         int codePoint;\n                             accum.append(c);\n                         break;\n                     default:\n-                        if (encoder.canEncode(c))\n+                        if (canEncode(coreCharset, c, encoder))\n                             accum.append(c);\n                         else if (map.containsKey(c))\n                             accum.append('&').append(map.get(c)).append(';');\n                 }\n             } else {\n                 final String c = new String(Character.toChars(codePoint));\n-                if (encoder.canEncode(c))\n+                if (encoder.canEncode(c)) // uses fallback encoder for simplicity\n                     accum.append(c);\n                 else\n                     accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';');\n \n     /**\n      * Unescape the input string.\n-     * @param string\n+     * @param string to un-HTML-escape\n      * @param strict if \"strict\" (that is, requires trailing ';' char, otherwise that's optional)\n-     * @return\n+     * @return unescaped string\n      */\n     static String unescape(String string, boolean strict) {\n         return Parser.unescapeEntities(string, strict);\n+    }\n+\n+    /*\n+     * Provides a fast-path for Encoder.canEncode, which drastically improves performance on Android post JellyBean.\n+     * After KitKat, the implementation of canEncode degrades to the point of being useless. For non ASCII or UTF,\n+     * performance may be bad. We can add more encoders for common character sets that are impacted by performance\n+     * issues on Android if required.\n+     *\n+     * Benchmarks:     *\n+     * OLD toHtml() impl v New (fastpath) in millis\n+     * Wiki: 1895, 16\n+     * CNN: 6378, 55\n+     * Alterslash: 3013, 28\n+     * Jsoup: 167, 2\n+     */\n+\n+    private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {\n+        // todo add more charset tests if impacted by Android's bad perf in canEncode\n+        switch (charset) {\n+            case ascii:\n+                return c < 0x80;\n+            case utf:\n+                return true; // real is:!(Character.isLowSurrogate(c) || Character.isHighSurrogate(c)); - but already check above\n+            default:\n+                return fallback.canEncode(c);\n+        }\n+    }\n+\n+    private enum CoreCharset {\n+        ascii, utf, fallback;\n+\n+        private static CoreCharset byName(String name) {\n+            if (name.equals(\"US-ASCII\"))\n+                return ascii;\n+            if (name.startsWith(\"UTF-\")) // covers UTF-8, UTF-16, et al\n+                return utf;\n+            return fallback;\n+        }\n     }\n \n \n--- a/src/main/java/org/jsoup/nodes/FormElement.java\n+++ b/src/main/java/org/jsoup/nodes/FormElement.java\n         // iterate the form control elements and accumulate their values\n         for (Element el: elements) {\n             if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n+            if (el.hasAttr(\"disabled\")) continue; // skip disabled form inputs\n             String name = el.attr(\"name\");\n             if (name.length() == 0) continue;\n             String type = el.attr(\"type\");\n                 }\n             } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                 // only add checkbox or radio if they have the checked attribute\n-                if (el.hasAttr(\"checked\"))\n-                    data.add(HttpConnection.KeyVal.create(name, el.val()));\n+                if (el.hasAttr(\"checked\")) {\n+                    final String val = el.val().length() >  0 ? el.val() : \"on\";\n+                    data.add(HttpConnection.KeyVal.create(name, val));\n+                }\n             } else {\n                 data.add(HttpConnection.KeyVal.create(name, el.val()));\n             }\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n      * @see #after(String)\n      */\n     public Node before(String html) {\n-        addSiblingHtml(siblingIndex(), html);\n+        addSiblingHtml(siblingIndex, html);\n         return this;\n     }\n \n         Validate.notNull(node);\n         Validate.notNull(parentNode);\n \n-        parentNode.addChildren(siblingIndex(), node);\n+        parentNode.addChildren(siblingIndex, node);\n         return this;\n     }\n \n      * @see #before(String)\n      */\n     public Node after(String html) {\n-        addSiblingHtml(siblingIndex() + 1, html);\n+        addSiblingHtml(siblingIndex + 1, html);\n         return this;\n     }\n \n         Validate.notNull(node);\n         Validate.notNull(parentNode);\n \n-        parentNode.addChildren(siblingIndex() + 1, node);\n+        parentNode.addChildren(siblingIndex + 1, node);\n         return this;\n     }\n \n     public Node unwrap() {\n         Validate.notNull(parentNode);\n \n-        int index = siblingIndex;\n         Node firstChild = childNodes.size() > 0 ? childNodes.get(0) : null;\n-        parentNode.addChildren(index, this.childNodesAsArray());\n+        parentNode.addChildren(siblingIndex, this.childNodesAsArray());\n         this.remove();\n \n         return firstChild;\n         if (in.parentNode != null)\n             in.parentNode.removeChild(in);\n         \n-        Integer index = out.siblingIndex();\n+        final int index = out.siblingIndex;\n         childNodes.set(index, in);\n         in.parentNode = this;\n         in.setSiblingIndex(index);\n \n     protected void removeChild(Node out) {\n         Validate.isTrue(out.parentNode == this);\n-        int index = out.siblingIndex();\n+        final int index = out.siblingIndex;\n         childNodes.remove(index);\n         reindexChildren(index);\n         out.parentNode = null;\n         if (parentNode == null)\n             return null; // root\n         \n-        List<Node> siblings = parentNode.childNodes;\n-        Integer index = siblingIndex();\n-        Validate.notNull(index);\n-        if (siblings.size() > index+1)\n-            return siblings.get(index+1);\n+        final List<Node> siblings = parentNode.childNodes;\n+        final int index = siblingIndex+1;\n+        if (siblings.size() > index)\n+            return siblings.get(index);\n         else\n             return null;\n     }\n         if (parentNode == null)\n             return null; // root\n \n-        List<Node> siblings = parentNode.childNodes;\n-        Integer index = siblingIndex();\n-        Validate.notNull(index);\n-        if (index > 0)\n-            return siblings.get(index-1);\n+        if (siblingIndex > 0)\n+            return parentNode.childNodes.get(siblingIndex-1);\n         else\n             return null;\n     }\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n import java.io.File;\n import java.io.IOException;\n import java.nio.charset.Charset;\n-\n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.jsoup.integration.ParseTest;\n+import org.jsoup.nodes.Document.OutputSettings.Syntax;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import org.junit.Ignore;\n import org.junit.Test;\n-import org.junit.Ignore;\n-\n-import static org.jsoup.nodes.Document.OutputSettings.Syntax;\n-import static org.junit.Assert.*;\n \n /**\n  Tests for Document.\n         Document doc = Jsoup.parse(builder.toString());\n         doc.clone();\n     }\n+\n+    @Test public void DocumentsWithSameContentAreEqual() throws Exception {\n+        Document docA = Jsoup.parse(\"<div/>One\");\n+        Document docB = Jsoup.parse(\"<div/>One\");\n+        Document docC = Jsoup.parse(\"<div/>Two\");\n+\n+        assertEquals(docA, docB);\n+        assertFalse(docA.equals(docC));\n+        assertEquals(docA.hashCode(), docB.hashCode());\n+        assertFalse(docA.hashCode() == docC.hashCode());\n+    }\n     \n     @Test\n     public void testMetaCharsetUpdateUtf8() {\n--- a/src/test/java/org/jsoup/nodes/FormElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/FormElementTest.java\n                 \"<option value='four' selected><option value='five' selected><textarea name=six>seven</textarea>\" +\n                 \"<input name='seven' type='radio' value='on' checked><input name='seven' type='radio' value='off'>\" +\n                 \"<input name='eight' type='checkbox' checked><input name='nine' type='checkbox' value='unset'>\" +\n+                \"<input name='ten' value='text' disabled>\" +\n                 \"</form>\";\n         Document doc = Jsoup.parse(html);\n         FormElement form = (FormElement) doc.select(\"form\").first();\n         assertEquals(\"three=four\", data.get(1).toString());\n         assertEquals(\"three=five\", data.get(2).toString());\n         assertEquals(\"six=seven\", data.get(3).toString());\n-        assertEquals(\"seven=on\", data.get(4).toString());\n-        assertEquals(\"eight=\", data.get(5).toString());\n+        assertEquals(\"seven=on\", data.get(4).toString()); // set\n+        assertEquals(\"eight=on\", data.get(5).toString()); // default\n+        // nine should not appear, not checked checkbox\n+        // ten should not appear, disabled\n     }\n \n     @Test public void createsSubmitableConnection() {\n         List<Connection.KeyVal> data = form.formData();\n         assertEquals(\"foo=bar\", data.get(0).toString());\n     }\n+\n+    @Test public void usesOnForCheckboxValueIfNoValueSet() {\n+        Document doc = Jsoup.parse(\"<form><input type=checkbox checked name=foo></form>\");\n+        FormElement form = (FormElement) doc.select(\"form\").first();\n+        List<Connection.KeyVal> data = form.formData();\n+        assertEquals(\"on\", data.get(0).value());\n+        assertEquals(\"foo\", data.get(0).key());\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/NodeTest.java\n+++ b/src/test/java/org/jsoup/nodes/NodeTest.java\n         assertEquals(\"<div id=\\\"1\\\">Text 1 <p>One</p> Text 2 <p>Two</p><p>Three</p></div><div id=\\\"2\\\">Text 1 updated\"\n             +\"<p>One</p> Text 2 <p>Two</p><p>Three</p></div>\", TextUtil.stripNewlines(doc.body().html()));\n     }\n+\n+    @Test public void supportsClone() {\n+        Document doc = org.jsoup.Jsoup.parse(\"<div class=foo>Text</div>\");\n+        Element el = doc.select(\"div\").first();\n+        assertTrue(el.hasClass(\"foo\"));\n+\n+        Element elClone = doc.clone().select(\"div\").first();\n+        assertTrue(elClone.hasClass(\"foo\"));\n+        assertTrue(elClone.text().equals(\"Text\"));\n+\n+        el.removeClass(\"foo\");\n+        el.text(\"None\");\n+        assertFalse(el.hasClass(\"foo\"));\n+        assertTrue(elClone.hasClass(\"foo\"));\n+        assertTrue(el.text().equals(\"None\"));\n+        assertTrue(elClone.text().equals(\"Text\"));\n+    }\n }\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n     private OutputSettings outputSettings = new OutputSettings();\n     private QuirksMode quirksMode = QuirksMode.noQuirks;\n     private String location;\n+    private boolean updateMetaCharset = false;\n \n     /**\n      Create a new, empty Document.\n \n         normaliseStructure(\"head\", htmlEl);\n         normaliseStructure(\"body\", htmlEl);\n+        \n+        ensureMetaCharset();\n         \n         return this;\n     }\n     public String nodeName() {\n         return \"#document\";\n     }\n+    \n+    /**\n+     * Sets the charset used in this document. This method is equivalent\n+     * to {@link OutputSettings#charset(java.nio.charset.Charset)\n+     * OutputSettings.charset(Charset)} but in addition it updates the\n+     * charset / encoding element within the document.\n+     * \n+     * <p>This only applies if {@link #updateMetaCharset(boolean)\n+     * updateMetaCharset} set to <tt>true</tt>; otherwise there are no elements\n+     * changed and the new value is delegated to\n+     * {@link OutputSettings#charset(java.nio.charset.Charset) \n+     * OutputSettings.charset(Charset)} only.</p>\n+     * \n+     * <p>If there's no element with charset / encoding information yet it will\n+     * be created. Obsolete charset / encoding definitions are removed!</p>\n+     * \n+     * <p><b>Elements used:</b></p>\n+     * \n+     * <ul>\n+     * <li><b>Html:</b> <i>&lt;meta charset=\"CHARSET\"&gt;</i></li>\n+     * <li><b>Xml:</b> <i>&lt;?xml version=\"1.0\" encoding=\"CHARSET\"&gt;</i></li>\n+     * </ul>\n+     * \n+     * @param charset Charset\n+     * \n+     * @see #updateMetaCharset(boolean) \n+     * @see OutputSettings#charset(java.nio.charset.Charset) \n+     */\n+    public void charset(Charset charset) {\n+        outputSettings.charset(charset);\n+        ensureMetaCharset();\n+    }\n+    \n+    /**\n+     * Returns the charset used in this document. This method is equivalent\n+     * to {@link OutputSettings#charset()}.\n+     * \n+     * @return Current Charset\n+     * \n+     * @see OutputSettings#charset() \n+     */\n+    public Charset charset() {\n+        return outputSettings.charset();\n+    }\n+    \n+    /**\n+     * Sets whether the element with charset information in this document is\n+     * updated on changes through {@link #charset(java.nio.charset.Charset)\n+     * Document.charset(Charset)} or not.\n+     * \n+     * <p>If set to <tt>false</tt> <i>(default)</i> there are no elements\n+     * modified.</p>\n+     * \n+     * @param update If <tt>true</tt> the element updated on charset\n+     * changes, <tt>false</tt> if not\n+     * \n+     * @see #charset(java.nio.charset.Charset) \n+     */\n+    public void updateMetaCharset(boolean update) {\n+        this.updateMetaCharset = true;\n+    }\n+    \n+    /**\n+     * Returns whether the element with charset information in this document is\n+     * updated on changes through {@link #charset(java.nio.charset.Charset)\n+     * Document.charset(Charset)} or not.\n+     * \n+     * @return Returns <tt>true</tt> if the element is updated on charset\n+     * changes, <tt>false</tt> if not\n+     */\n+    public boolean updateMetaCharset() {\n+        return updateMetaCharset;\n+    }\n \n     @Override\n     public Document clone() {\n         clone.outputSettings = this.outputSettings.clone();\n         return clone;\n     }\n+    \n+    /**\n+     * Ensures a meta charset (html) or xml declaration (xml) with the current\n+     * encoding used. This only applies with {@link #updateMetaCharset(boolean)\n+     * updateMetaCharset} set to <tt>true</tt>, otherwise this method does\n+     * nothing.\n+     * \n+     * <ul>\n+     * <li>An exsiting element gets updated with the current charset</li>\n+     * <li>If there's no element yet it will be inserted</li>\n+     * <li>Obsolete elements are removed</li>\n+     * </ul>\n+     * \n+     * <p><b>Elements used:</b></p>\n+     * \n+     * <ul>\n+     * <li><b>Html:</b> <i>&lt;meta charset=\"CHARSET\"&gt;</i></li>\n+     * <li><b>Xml:</b> <i>&lt;?xml version=\"1.0\" encoding=\"CHARSET\"&gt;</i></li>\n+     * </ul>\n+     */\n+    private void ensureMetaCharset() {\n+        if( updateMetaCharset == true ) {\n+            OutputSettings.Syntax syntax = outputSettings().syntax();\n+            \n+            if( syntax == OutputSettings.Syntax.html ) {\n+                Element metaCharset = select(\"meta[charset]\").first();\n+\n+                if( metaCharset != null ) {\n+                    metaCharset.attr(\"charset\", charset().displayName());\n+                }\n+                else {\n+                    Element head = head();\n+\n+                    if( head != null ) {\n+                        head.appendElement(\"meta\").attr(\"charset\", charset().displayName());\n+                    }\n+                }\n+\n+                // Remove obsolete elements\n+                select(\"meta[name=charset]\").remove();\n+            }\n+            else if( syntax == OutputSettings.Syntax.xml ) {\n+                Node node = childNodes().get(0);\n+                \n+                if( node instanceof XmlDeclaration ) {\n+                    XmlDeclaration decl = (XmlDeclaration) node;\n+                    \n+                    if( decl.attr(XmlDeclaration.DECL_KEY).equals(\"xml\") ) {\n+                        decl.attr(\"encoding\", charset().displayName());\n+\n+                        final String version = decl.attr(\"version\");\n+\n+                        if( version != null ) {\n+                            decl.attr(\"version\", \"1.0\");\n+                        }\n+                    }\n+                    else {\n+                        decl = new XmlDeclaration(\"xml\", baseUri, false);\n+                        decl.attr(\"version\", \"1.0\");\n+                        decl.attr(\"encoding\", charset().displayName());\n+                        \n+                        prependChild(decl);\n+                    }\n+                }\n+                else {\n+                    XmlDeclaration decl = new XmlDeclaration(\"xml\", baseUri, false);\n+                    decl.attr(\"version\", \"1.0\");\n+                    decl.attr(\"encoding\", charset().displayName());\n+                    \n+                    prependChild(decl);\n+                }\n+            }\n+            else {\n+                // Unsupported syntax - nothing to do yet\n+            }\n+        }\n+    }\n+    \n \n     /**\n      * A Document's output settings control the form of the text() and html() methods.\n         private Syntax syntax = Syntax.html;\n \n         public OutputSettings() {}\n-\n+        \n         /**\n          * Get the document's current HTML escape mode: <code>base</code>, which provides a limited set of named HTML\n          * entities and escapes other characters as numbered entities for maximum compatibility; or <code>extended</code>,\n          * @return the document's output settings, for chaining\n          */\n         public OutputSettings charset(Charset charset) {\n-            // todo: this should probably update the doc's meta charset\n             this.charset = charset;\n             charsetEncoder = charset.newEncoder();\n             return this;\n--- a/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n+++ b/src/main/java/org/jsoup/nodes/XmlDeclaration.java\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class XmlDeclaration extends Node {\n-    private static final String DECL_KEY = \"declaration\";\n+    static final String DECL_KEY = \"declaration\";\n     private final boolean isProcessingInstruction; // <! if true, <? if false, declaration (and last data char should be ?)\n \n     /**\n      @return XML declaration\n      */\n     public String getWholeDeclaration() {\n-        return attributes.get(DECL_KEY);\n+        final String decl = attributes.get(DECL_KEY);\n+        \n+        if( decl.equals(\"xml\") == true && attributes.size() > 1 ) {\n+            StringBuilder sb = new StringBuilder(decl);\n+            final String version = attributes.get(\"version\");\n+            \n+            if( version != null ) {\n+                sb.append(\" version=\\\"\").append(version).append(\"\\\"\");\n+            }\n+            \n+            final String encoding = attributes.get(\"encoding\");\n+            \n+            if( encoding != null ) {\n+                sb.append(\" encoding=\\\"\").append(encoding).append(\"\\\"\");\n+            }\n+            \n+            return sb.toString();\n+        }\n+        else {\n+            return attributes.get(DECL_KEY);\n+        }\n     }\n-\n+    \n     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n         accum\n                 .append(\"<\")\n--- a/src/test/java/org/jsoup/nodes/DocumentTest.java\n+++ b/src/test/java/org/jsoup/nodes/DocumentTest.java\n package org.jsoup.nodes;\n \n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.jsoup.integration.ParseTest;\n+import org.jsoup.nodes.Document.OutputSettings.Syntax;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n import org.junit.Ignore;\n import org.junit.Test;\n \n-import java.io.File;\n-import java.io.IOException;\n-\n-import static org.jsoup.nodes.Document.OutputSettings.Syntax;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-\n /**\n  Tests for Document.\n \n  @author Jonathan Hedley, jonathan@hedley.net */\n public class DocumentTest {\n+    private static final String charsetUtf8 = \"UTF-8\";\n+    private static final String charsetIso8859 = \"ISO-8859-1\";\n+    \n+    \n     @Test public void setTextPreservesDocumentStructure() {\n         Document doc = Jsoup.parse(\"<p>Hello</p>\");\n         doc.text(\"Replaced\");\n         assertEquals(docA.hashCode(), docB.hashCode());\n         assertFalse(docA.hashCode() == docC.hashCode());\n     }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateUtf8() {\n+        final Document doc = createHtmlDocument(\"changeThis\");\n+        doc.updateMetaCharset(true);\n+        doc.charset(Charset.forName(charsetUtf8));\n+        \n+        final String htmlCharsetUTF8 = \"<html>\\n\" +\n+                                        \" <head>\\n\" +\n+                                        \"  <meta charset=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+                                        \" </head>\\n\" +\n+                                        \" <body></body>\\n\" +\n+                                        \"</html>\";\n+        assertEquals(htmlCharsetUTF8, doc.toString());\n+        \n+        Element selectedElement = doc.select(\"meta[charset]\").first();\n+        assertEquals(charsetUtf8, doc.charset().displayName());\n+        assertEquals(charsetUtf8, selectedElement.attr(\"charset\"));\n+        assertEquals(doc.charset(), doc.outputSettings().charset());\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateIso8859() {\n+        final Document doc = createHtmlDocument(\"changeThis\");\n+        doc.updateMetaCharset(true);\n+        doc.charset(Charset.forName(charsetIso8859));\n+        \n+        final String htmlCharsetISO = \"<html>\\n\" +\n+                                        \" <head>\\n\" +\n+                                        \"  <meta charset=\\\"\" + charsetIso8859 + \"\\\">\\n\" +\n+                                        \" </head>\\n\" +\n+                                        \" <body></body>\\n\" +\n+                                        \"</html>\";\n+        assertEquals(htmlCharsetISO, doc.toString());\n+        \n+        Element selectedElement = doc.select(\"meta[charset]\").first();\n+        assertEquals(charsetIso8859, doc.charset().displayName());\n+        assertEquals(charsetIso8859, selectedElement.attr(\"charset\"));\n+        assertEquals(doc.charset(), doc.outputSettings().charset());\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateNoCharset() {\n+        final Document docNoCharset = Document.createShell(\"\");\n+        docNoCharset.updateMetaCharset(true);\n+        docNoCharset.charset(Charset.forName(charsetUtf8));\n+        \n+        assertEquals(charsetUtf8, docNoCharset.select(\"meta[charset]\").first().attr(\"charset\"));\n+        \n+        final String htmlCharsetUTF8 = \"<html>\\n\" +\n+                                        \" <head>\\n\" +\n+                                        \"  <meta charset=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+                                        \" </head>\\n\" +\n+                                        \" <body></body>\\n\" +\n+                                        \"</html>\";\n+        assertEquals(htmlCharsetUTF8, docNoCharset.toString()); \n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateDisabled() {\n+        final Document docDisabled = Document.createShell(\"\");\n+        \n+        final String htmlNoCharset = \"<html>\\n\" +\n+                                        \" <head></head>\\n\" +\n+                                        \" <body></body>\\n\" +\n+                                        \"</html>\";\n+        assertEquals(htmlNoCharset, docDisabled.toString());\n+        assertNull(docDisabled.select(\"meta[charset]\").first());\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateDisabledNoChanges() {\n+        final Document doc = createHtmlDocument(\"dontTouch\");\n+        \n+        final String htmlCharset = \"<html>\\n\" +\n+                                    \" <head>\\n\" +\n+                                    \"  <meta charset=\\\"dontTouch\\\">\\n\" +\n+                                    \"  <meta name=\\\"charset\\\" content=\\\"dontTouch\\\">\\n\" +\n+                                    \" </head>\\n\" +\n+                                    \" <body></body>\\n\" +\n+                                    \"</html>\";\n+        assertEquals(htmlCharset, doc.toString());\n+        \n+        Element selectedElement = doc.select(\"meta[charset]\").first();\n+        assertNotNull(selectedElement);\n+        assertEquals(\"dontTouch\", selectedElement.attr(\"charset\"));\n+        \n+        selectedElement = doc.select(\"meta[name=charset]\").first();\n+        assertNotNull(selectedElement);\n+        assertEquals(\"dontTouch\", selectedElement.attr(\"content\"));\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateDisabledNoChangesAfterUpdate() {\n+        final Document doc = createHtmlDocument(\"dontTouch\");\n+        doc.charset(Charset.forName(charsetUtf8));\n+        \n+        Element selectedElement = doc.select(\"meta[charset]\").first();\n+        assertEquals(\"dontTouch\", selectedElement.attr(\"charset\"));\n+        \n+        selectedElement = doc.select(\"meta[name=charset]\").first();\n+        assertEquals(\"dontTouch\", selectedElement.attr(\"content\"));\n+    }\n+            \n+    @Test\n+    public void testMetaCharsetUpdateCleanup() {\n+        final Document doc = createHtmlDocument(\"dontTouch\");\n+        doc.updateMetaCharset(true);\n+        doc.charset(Charset.forName(charsetUtf8));\n+        \n+        final String htmlCharsetUTF8 = \"<html>\\n\" +\n+                                        \" <head>\\n\" +\n+                                        \"  <meta charset=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+                                        \" </head>\\n\" +\n+                                        \" <body></body>\\n\" +\n+                                        \"</html>\";\n+        \n+        assertEquals(htmlCharsetUTF8, doc.toString());\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateXmlUtf8() {\n+        final Document doc = createXmlDocument(\"1.0\", \"changeThis\", true);\n+        doc.updateMetaCharset(true);\n+        doc.charset(Charset.forName(charsetUtf8));\n+        \n+        final String xmlCharsetUTF8 = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+                                        \"<root>\\n\" +\n+                                        \" node\\n\" +\n+                                        \"</root>\";\n+        assertEquals(xmlCharsetUTF8, doc.toString());\n+\n+        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);\n+        assertEquals(charsetUtf8, doc.charset().displayName());\n+        assertEquals(charsetUtf8, selectedNode.attr(\"encoding\"));\n+        assertEquals(doc.charset(), doc.outputSettings().charset());\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateXmlIso8859() {\n+        final Document doc = createXmlDocument(\"1.0\", \"changeThis\", true);\n+        doc.updateMetaCharset(true);\n+        doc.charset(Charset.forName(charsetIso8859));\n+        \n+        final String xmlCharsetISO = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetIso8859 + \"\\\">\\n\" +\n+                                        \"<root>\\n\" +\n+                                        \" node\\n\" +\n+                                        \"</root>\";\n+        assertEquals(xmlCharsetISO, doc.toString());\n+        \n+        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);\n+        assertEquals(charsetIso8859, doc.charset().displayName());\n+        assertEquals(charsetIso8859, selectedNode.attr(\"encoding\"));\n+        assertEquals(doc.charset(), doc.outputSettings().charset());\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateXmlNoCharset() {\n+        final Document doc = createXmlDocument(\"1.0\", \"none\", false);\n+        doc.updateMetaCharset(true);\n+        doc.charset(Charset.forName(charsetUtf8));\n+        \n+        final String xmlCharsetUTF8 = \"<?xml version=\\\"1.0\\\" encoding=\\\"\" + charsetUtf8 + \"\\\">\\n\" +\n+                                        \"<root>\\n\" +\n+                                        \" node\\n\" +\n+                                        \"</root>\";\n+        assertEquals(xmlCharsetUTF8, doc.toString());\n+        \n+        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);\n+        assertEquals(charsetUtf8, selectedNode.attr(\"encoding\"));\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdateXmlDisabled() {\n+        final Document doc = createXmlDocument(\"none\", \"none\", false);\n+        \n+        final String xmlNoCharset = \"<root>\\n\" +\n+                                    \" node\\n\" +\n+                                    \"</root>\";\n+        assertEquals(xmlNoCharset, doc.toString());\n+    }\n+\n+    @Test\n+    public void testMetaCharsetUpdateXmlDisabledNoChanges() {\n+        final Document doc = createXmlDocument(\"dontTouch\", \"dontTouch\", true);\n+        \n+        final String xmlCharset = \"<?xml version=\\\"dontTouch\\\" encoding=\\\"dontTouch\\\">\\n\" +\n+                                    \"<root>\\n\" +\n+                                    \" node\\n\" +\n+                                    \"</root>\";\n+        assertEquals(xmlCharset, doc.toString());\n+        \n+        XmlDeclaration selectedNode = (XmlDeclaration) doc.childNode(0);\n+        assertEquals(\"dontTouch\", selectedNode.attr(\"encoding\"));\n+        assertEquals(\"dontTouch\", selectedNode.attr(\"version\"));\n+    }\n+    \n+    @Test\n+    public void testMetaCharsetUpdatedDisabledPerDefault() {\n+        final Document doc = createHtmlDocument(\"none\");\n+        assertFalse(doc.updateMetaCharset());\n+    }\n+    \n+    private Document createHtmlDocument(String charset) {\n+        final Document doc = Document.createShell(\"\");\n+        doc.head().appendElement(\"meta\").attr(\"charset\", charset);\n+        doc.head().appendElement(\"meta\").attr(\"name\", \"charset\").attr(\"content\", charset);\n+        \n+        return doc;\n+    }\n+    \n+    private Document createXmlDocument(String version, String charset, boolean addDecl) {\n+        final Document doc = new Document(\"\");\n+        doc.appendElement(\"root\").text(\"node\");\n+        doc.outputSettings().syntax(Syntax.xml);\n+        \n+        if( addDecl == true ) {\n+            XmlDeclaration decl = new XmlDeclaration(\"xml\", \"\", false);\n+            decl.attr(\"version\", version);\n+            decl.attr(\"encoding\", charset);\n+            doc.prependChild(decl);\n+        }\n+        \n+        return doc;\n+    }\n }", "timestamp": 1428410898, "metainfo": ""}