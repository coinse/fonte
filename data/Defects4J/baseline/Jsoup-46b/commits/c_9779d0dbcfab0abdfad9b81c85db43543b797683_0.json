{"sha": "9779d0dbcfab0abdfad9b81c85db43543b797683", "log": "Merge branch 'master' of https://github.com/mingfai/jsoup into mingfai-master", "commit": "\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n                     t.transition(AfterAttributeValue_quoted);\n                     break;\n                 case '&':\n-                    char[] ref = t.consumeCharacterReference('\"', true);\n+                    char[] ref = t.consumeCharacterReference('\\'', true);\n                     if (ref != null && ref.length>0)\n                         t.tagPending.appendAttributeValue(new String(ref));\n                     else\n                     t.transition(BeforeAttributeName);\n                     break;\n                 case '&':\n-                    char[] ref = t.consumeCharacterReference('\"', true);\n+                    char[] ref = t.consumeCharacterReference('>', true);\n                     if (ref != null && ref.length>0)\n                         t.tagPending.appendAttributeValue(new String(ref));\n                     else\n--- a/src/main/java/org/jsoup/nodes/Document.java\n+++ b/src/main/java/org/jsoup/nodes/Document.java\n         private Charset charset = Charset.forName(\"UTF-8\");\n         private CharsetEncoder charsetEncoder = charset.newEncoder();\n         private boolean prettyPrint = true;\n+        private boolean outline = false;\n         private int indentAmount = 1;\n \n         public OutputSettings() {}\n          */\n         public OutputSettings prettyPrint(boolean pretty) {\n             prettyPrint = pretty;\n+            return this;\n+        }\n+        \n+        /**\n+         * Get if outline mode is enabled. Default is false. If enabled, the HTML output methods will consider\n+         * all tags as block.\n+         * @return if outline mode is enabled.\n+         */\n+        public boolean outline() {\n+            return outline;\n+        }\n+        \n+        /**\n+         * Enable or disable HTML outline mode.\n+         * @param outlineMode new outline setting\n+         * @return this, for chaining\n+         */\n+        public OutputSettings outline(boolean outlineMode) {\n+            outline = outlineMode;\n             return this;\n         }\n \n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n     }\n \n     void outerHtmlHead(StringBuilder accum, int depth, Document.OutputSettings out) {\n-        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock())))\n+        if (accum.length() > 0 && out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline()) )\n             indent(accum, depth, out);\n         accum\n                 .append(\"<\")\n \n     void outerHtmlTail(StringBuilder accum, int depth, Document.OutputSettings out) {\n         if (!(childNodes.isEmpty() && tag.isSelfClosing())) {\n-            if (out.prettyPrint() && !childNodes.isEmpty() && tag.formatAsBlock())\n+            if (out.prettyPrint() && (!childNodes.isEmpty() && (\n+                    tag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n+            )))\n                 indent(accum, depth, out);\n             accum.append(\"</\").append(tagName()).append(\">\");\n         }\n--- a/src/main/java/org/jsoup/nodes/TextNode.java\n+++ b/src/main/java/org/jsoup/nodes/TextNode.java\n             html = normaliseWhitespace(html);\n         }\n \n-        if (out.prettyPrint() && siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank())\n+        if (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank()) || (out.outline() && siblingNodes().size()>0 && !isBlank()) ))\n             indent(accum, depth, out);\n         accum.append(html);\n     }\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n \n     Element insert(Token.StartTag startTag) {\n         // handle empty unknown tags\n-        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate fake end tag.\n-        if (startTag.isSelfClosing() && !Tag.isKnownTag(startTag.name())) {\n+        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\n+        if (startTag.isSelfClosing()) {\n             Element el = insertEmpty(startTag);\n-            process(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in\n+            stack.add(el);\n+            tokeniser.emit(new Token.EndTag(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\n             return el;\n         }\n         \n         Element el = new Element(tag, baseUri, startTag.attributes);\n         insertNode(el);\n         if (startTag.isSelfClosing()) {\n-            tokeniser.acknowledgeSelfClosingFlag();\n-            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output\n+            if (tag.isKnownTag()) {\n+                if (tag.isSelfClosing()) tokeniser.acknowledgeSelfClosingFlag(); // if not acked, promulagates error\n+            } else {\n+                // unknown tag, remember this is self closing for output\n                 tag.setSelfClosing();\n+                tokeniser.acknowledgeSelfClosingFlag(); // not an distinct error\n+            }\n         }\n         return el;\n     }\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n     }\n \n     /**\n+     * Parse a fragment of XML into a list of nodes.\n+     *\n+     * @param fragmentXml the fragment of XML to parse\n+     * @param baseUri base URI of document (i.e. original fetch location), for resolving relative URLs.\n+     * @return list of nodes parsed from the input XML.\n+     */\n+    public static List<Node> parseXmlFragment(String fragmentXml, String baseUri) {\n+        XmlTreeBuilder treeBuilder = new XmlTreeBuilder();\n+        return treeBuilder.parseFragment(fragmentXml, baseUri, ParseErrorList.noTracking());\n+    }\n+\n+    /**\n      * Parse a fragment of HTML into the {@code body} of a Document.\n      *\n      * @param bodyHtml fragment of HTML\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n             \"html\", \"head\", \"body\", \"frameset\", \"script\", \"noscript\", \"style\", \"meta\", \"link\", \"title\", \"frame\",\n             \"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n             \"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\",\n-            \"del\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n+            \"del\", \"s\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n             \"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\"\n     };\n     private static final String[] inlineTags = {\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n-            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n+            \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\",\n+            \"ins\", \"del\", \"s\"\n     };\n     private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};\n \n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n import org.jsoup.nodes.*;\n \n import java.util.Iterator;\n+import java.util.List;\n \n /**\n  * @author Jonathan Hedley\n             }\n         }\n     }\n+\n+    List<Node> parseFragment(String inputFragment, String baseUri, ParseErrorList errors) {\n+        initialiseParse(inputFragment, baseUri, errors);\n+        runParser();\n+        return doc.childNodes();\n+    }\n }\n--- a/src/test/java/org/jsoup/nodes/ElementTest.java\n+++ b/src/test/java/org/jsoup/nodes/ElementTest.java\n         Document doc = Jsoup.parse(\"<title>Format test</title><div><p>Hello <span>jsoup <span>users</span></span></p><p>Good.</p></div>\");\n         assertEquals(\"<html>\\n <head>\\n  <title>Format test</title>\\n </head>\\n <body>\\n  <div>\\n   <p>Hello <span>jsoup <span>users</span></span></p>\\n   <p>Good.</p>\\n  </div>\\n </body>\\n</html>\", doc.html());\n     }\n+    \n+    @Test public void testFormatOutline() {\n+        Document doc = Jsoup.parse(\"<title>Format test</title><div><p>Hello <span>jsoup <span>users</span></span></p><p>Good.</p></div>\");\n+        doc.outputSettings().outline(true);\n+        assertEquals(\"<html>\\n <head>\\n  <title>Format test</title>\\n </head>\\n <body>\\n  <div>\\n   <p>\\n    Hello \\n    <span>\\n     jsoup \\n     <span>users</span>\\n    </span>\\n   </p>\\n   <p>Good.</p>\\n  </div>\\n </body>\\n</html>\", doc.html());\n+    }\n \n     @Test public void testSetIndent() {\n         Document doc = Jsoup.parse(\"<div><p>Hello\\nthere</p></div>\");\n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n     }\n \n     @Test public void handlesKnownEmptyBlocks() {\n-        // if known tag, must be defined as self closing to allow as self closing. unkown tags can be self closing.\n-        String h = \"<div id='1' /><div id=2><img /><img></div> <hr /> hr text <hr> hr text two\";\n-        Document doc = Jsoup.parse(h);\n-        Element div1 = doc.getElementById(\"1\");\n-        assertTrue(!div1.children().isEmpty()); // <div /> is treated as <div>...\n-        assertTrue(doc.select(\"hr\").first().children().isEmpty());\n-        assertTrue(doc.select(\"hr\").last().children().isEmpty());\n-        assertTrue(doc.select(\"img\").first().children().isEmpty());\n-        assertTrue(doc.select(\"img\").last().children().isEmpty());\n+        // if a known tag, allow self closing outside of spec, but force an end tag. unknown tags can be self closing.\n+        String h = \"<div id='1' /><div id=2><img /><img></div><a id=3 /><i /><foo /><foo>One</foo> <hr /> hr text <hr> hr text two\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<div id=\\\"1\\\"></div><div id=\\\"2\\\"><img /><img /></div><a id=\\\"3\\\"></a><i></i><foo /><foo>One</foo> <hr /> hr text <hr /> hr text two\", TextUtil.stripNewlines(doc.body().html()));\n     }\n \n     @Test public void handlesSolidusAtAttributeEnd() {\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n import org.jsoup.TextUtil;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.Node;\n+import org.jsoup.nodes.TextNode;\n import org.junit.Ignore;\n import org.junit.Test;\n \n import java.io.IOException;\n import java.io.InputStream;\n import java.net.URISyntaxException;\n+import java.util.List;\n \n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertNotSame;\n         assertEquals(\"#declaration\", doc.childNode(0).nodeName());\n         assertEquals(\"#comment\", doc.childNode(2).nodeName());\n     }\n+\n+    @Test public void xmlFragment() {\n+        String xml = \"<one src='/foo/' />Two<three><four /></three>\";\n+        List<Node> nodes = Parser.parseXmlFragment(xml, \"http://example.com/\");\n+        assertEquals(3, nodes.size());\n+\n+        assertEquals(\"http://example.com/foo/\", nodes.get(0).absUrl(\"src\"));\n+        assertEquals(\"one\", nodes.get(0).nodeName());\n+        assertEquals(\"Two\", ((TextNode)nodes.get(1)).text());\n+    }\n }", "timestamp": 1359317379, "metainfo": ""}