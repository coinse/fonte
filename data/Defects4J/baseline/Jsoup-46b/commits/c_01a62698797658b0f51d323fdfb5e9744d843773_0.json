{"sha": "01a62698797658b0f51d323fdfb5e9744d843773", "log": "Use ArrayList instead of LinkedList  Much less GC - less iterators, lest next items, etc.", "commit": "\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n import org.jsoup.select.Elements;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n import java.util.List;\n \n /**\n     private Element headElement; // the current head element\n     private FormElement formElement; // the current form element\n     private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n-    private DescendableLinkedList<Element> formattingElements = new DescendableLinkedList<Element>(); // active (open) formatting elements\n+    private ArrayList<Element> formattingElements = new ArrayList<Element>(); // active (open) formatting elements\n     private List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); // chars in table to be shifted out\n \n     private boolean framesetOk = true; // if ok to go into frameset\n \n             root = new Element(Tag.valueOf(\"html\"), baseUri);\n             doc.appendChild(root);\n-            stack.push(root);\n+            stack.add(root);\n             resetInsertionMode();\n \n             // setup form element to nearest form on context (up ancestor chain). ensures form controls are associated\n     }\n \n     Element pop() {\n-        // todo - dev, remove validation check\n-        if (stack.peekLast().nodeName().equals(\"td\") && !state.name().equals(\"InCell\"))\n-            Validate.isFalse(true, \"pop td not in cell\");\n-        if (stack.peekLast().nodeName().equals(\"html\"))\n-            Validate.isFalse(true, \"popping html!\");\n-        return stack.pollLast();\n+        int size = stack.size();\n+        return stack.remove(size-1);\n     }\n \n     void push(Element element) {\n         stack.add(element);\n     }\n \n-    DescendableLinkedList<Element> getStack() {\n+    ArrayList<Element> getStack() {\n         return stack;\n     }\n \n         return isElementInQueue(stack, el);\n     }\n \n-    private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element) {\n-        Iterator<Element> it = queue.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+    private boolean isElementInQueue(ArrayList<Element> queue, Element element) {\n+        for (int pos = queue.size() -1; pos >= 0; pos--) {\n+            Element next = queue.get(pos);\n             if (next == element) {\n                 return true;\n             }\n     }\n \n     Element getFromStack(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next.nodeName().equals(elName)) {\n                 return next;\n             }\n     }\n \n     boolean removeFromStack(Element el) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next == el) {\n-                it.remove();\n+                stack.remove(pos);\n                 return true;\n             }\n         }\n     }\n \n     void popStackToClose(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n+            stack.remove(pos);\n+            if (next.nodeName().equals(elName))\n+                break;\n+        }\n+    }\n+\n+    void popStackToClose(String... elNames) {\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n+            stack.remove(pos);\n+            if (StringUtil.in(next.nodeName(), elNames))\n+                break;\n+        }\n+    }\n+\n+    void popStackToBefore(String elName) {\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next.nodeName().equals(elName)) {\n-                it.remove();\n                 break;\n             } else {\n-                it.remove();\n-            }\n-        }\n-    }\n-\n-    void popStackToClose(String... elNames) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (StringUtil.in(next.nodeName(), elNames)) {\n-                it.remove();\n-                break;\n-            } else {\n-                it.remove();\n-            }\n-        }\n-    }\n-\n-    void popStackToBefore(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next.nodeName().equals(elName)) {\n-                break;\n-            } else {\n-                it.remove();\n+                stack.remove(pos);\n             }\n         }\n     }\n     }\n \n     private void clearStackToContext(String... nodeNames) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n                 break;\n             else\n-                it.remove();\n+                stack.remove(pos);\n         }\n     }\n \n     Element aboveOnStack(Element el) {\n         assert onStack(el);\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next == el) {\n-                return it.next();\n+                return stack.get(pos-1);\n             }\n         }\n         return null;\n         replaceInQueue(stack, out, in);\n     }\n \n-    private void replaceInQueue(LinkedList<Element> queue, Element out, Element in) {\n+    private void replaceInQueue(ArrayList<Element> queue, Element out, Element in) {\n         int i = queue.lastIndexOf(out);\n         Validate.isTrue(i != -1);\n-        queue.remove(i);\n-        queue.add(i, in);\n+        queue.set(i, in);\n     }\n \n     void resetInsertionMode() {\n         boolean last = false;\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element node = it.next();\n-            if (!it.hasNext()) {\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element node = stack.get(pos);\n+            if (pos == 0) {\n                 last = true;\n                 node = contextElement;\n             }\n     }\n \n     private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element el = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element el = stack.get(pos);\n             String elName = el.nodeName();\n             if (StringUtil.in(elName, targetNames))\n                 return true;\n     }\n \n     boolean inSelectScope(String targetName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element el = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element el = stack.get(pos);\n             String elName = el.nodeName();\n             if (elName.equals(targetName))\n                 return true;\n         return StringUtil.in(name, TagSearchSpecial);\n     }\n \n+    Element lastFormattingElement() {\n+        return formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n+    }\n+\n+    Element removeLastFormattingElement() {\n+        int size = formattingElements.size();\n+        if (size > 0)\n+            return formattingElements.remove(size-1);\n+        else\n+            return null;\n+    }\n+\n     // active formatting elements\n     void pushActiveFormattingElements(Element in) {\n         int numSeen = 0;\n-        Iterator<Element> iter = formattingElements.descendingIterator();\n-        while (iter.hasNext()) {\n-            Element el =  iter.next();\n+        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n+            Element el = formattingElements.get(pos);\n             if (el == null) // marker\n                 break;\n \n                 numSeen++;\n \n             if (numSeen == 3) {\n-                iter.remove();\n+                formattingElements.remove(pos);\n                 break;\n             }\n         }\n     }\n \n     void reconstructFormattingElements() {\n+        Element last = lastFormattingElement();\n+        if (last == null || onStack(last))\n+            return;\n+\n+        Element entry = last;\n         int size = formattingElements.size();\n-        if (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\n-            return;\n-\n-        Element entry = formattingElements.getLast();\n         int pos = size - 1;\n         boolean skip = false;\n         while (true) {\n             newEl.attributes().addAll(entry.attributes());\n \n             // 10. replace entry with new entry\n-            formattingElements.add(pos, newEl);\n-            formattingElements.remove(pos + 1);\n+            formattingElements.set(pos, newEl);\n \n             // 11\n             if (pos == size-1) // if not last entry in list, jump to 7\n \n     void clearFormattingElementsToLastMarker() {\n         while (!formattingElements.isEmpty()) {\n-            Element el = formattingElements.peekLast();\n-            formattingElements.removeLast();\n+            Element el = removeLastFormattingElement();\n             if (el == null)\n                 break;\n         }\n     }\n \n     void removeFromActiveFormattingElements(Element el) {\n-        Iterator<Element> it = formattingElements.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n+            Element next = formattingElements.get(pos);\n             if (next == el) {\n-                it.remove();\n+                formattingElements.remove(pos);\n                 break;\n             }\n         }\n     }\n \n     Element getActiveFormattingElement(String nodeName) {\n-        Iterator<Element> it = formattingElements.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = formattingElements.size() -1; pos >= 0; pos--) {\n+            Element next = formattingElements.get(pos);\n             if (next == null) // scope marker\n                 break;\n             else if (next.nodeName().equals(nodeName))\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.*;\n \n-import java.util.Iterator;\n-import java.util.LinkedList;\n+import java.util.ArrayList;\n \n /**\n  * The Tree Builder's current state. Each state embodies the processing for the state, and transitions to other states.\n                     if (name.equals(\"html\")) {\n                         tb.error(this);\n                         // merge attributes onto real html\n-                        Element html = tb.getStack().getFirst();\n+                        Element html = tb.getStack().get(0);\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                             // only in fragment case\n                             return false; // ignore\n                         }\n                     } else if (name.equals(\"frameset\")) {\n                         tb.error(this);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n                             // only in fragment case\n                             return false; // ignore\n                                 second.remove();\n                             // pop up to html element\n                             while (stack.size() > 1)\n-                                stack.removeLast();\n+                                stack.remove(stack.size()-1);\n                             tb.insert(startTag);\n                             tb.transition(InFrameset);\n                         }\n                         tb.insertForm(startTag, true);\n                     } else if (name.equals(\"li\")) {\n                         tb.framesetOk(false);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         for (int i = stack.size() - 1; i > 0; i--) {\n                             Element el = stack.get(i);\n                             if (el.nodeName().equals(\"li\")) {\n                         tb.insert(startTag);\n                     } else if (StringUtil.in(name, Constants.DdDt)) {\n                         tb.framesetOk(false);\n-                        LinkedList<Element> stack = tb.getStack();\n+                        ArrayList<Element> stack = tb.getStack();\n                         for (int i = stack.size() - 1; i > 0; i--) {\n                             Element el = stack.get(i);\n                             if (StringUtil.in(el.nodeName(), Constants.DdDt)) {\n                             Element furthestBlock = null;\n                             Element commonAncestor = null;\n                             boolean seenFormattingElement = false;\n-                            LinkedList<Element> stack = tb.getStack();\n+                            ArrayList<Element> stack = tb.getStack();\n                             // the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n                             // run-aways\n                             final int stackSize = stack.size();\n \n         boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n             String name = t.asEndTag().name();\n-            DescendableLinkedList<Element> stack = tb.getStack();\n-            Iterator<Element> it = stack.descendingIterator();\n-            while (it.hasNext()) {\n-                Element node = it.next();\n+            ArrayList<Element> stack = tb.getStack();\n+            for (int pos = stack.size() -1; pos >= 0; pos--) {\n+                Element node = stack.get(pos);\n                 if (node.nodeName().equals(name)) {\n                     tb.generateImpliedEndTags(name);\n                     if (!name.equals(tb.currentElement().nodeName()))\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n package org.jsoup.parser;\n \n-import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n \n+import java.util.ArrayList;\n \n /**\n  * @author Jonathan Hedley\n     CharacterReader reader;\n     Tokeniser tokeniser;\n     protected Document doc; // current doc we are building into\n-    protected DescendableLinkedList<Element> stack; // the stack of open elements\n+    protected ArrayList<Element> stack; // the stack of open elements\n     protected String baseUri; // current base uri, for creating new elements\n     protected Token currentToken; // currentToken is used only for error tracking.\n     protected ParseErrorList errors; // null when not tracking errors\n         reader = new CharacterReader(input);\n         this.errors = errors;\n         tokeniser = new Tokeniser(reader, errors);\n-        stack = new DescendableLinkedList<Element>();\n+        stack = new ArrayList<Element>(32);\n         this.baseUri = baseUri;\n     }\n \n     protected abstract boolean process(Token token);\n \n     protected Element currentElement() {\n-        return stack.getLast();\n+        int size = stack.size();\n+        return size > 0 ? stack.get(size-1) : null;\n     }\n }\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n \n-import java.util.Iterator;\n import java.util.List;\n \n /**\n         String elName = endTag.name();\n         Element firstFound = null;\n \n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n             if (next.nodeName().equals(elName)) {\n                 firstFound = next;\n                 break;\n         if (firstFound == null)\n             return; // not found, skip\n \n-        it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next == firstFound) {\n-                it.remove();\n+        for (int pos = stack.size() -1; pos >= 0; pos--) {\n+            Element next = stack.get(pos);\n+            stack.remove(pos);\n+            if (next == firstFound)\n                 break;\n-            } else {\n-                it.remove();\n-            }\n         }\n     }\n ", "timestamp": 1414370406, "metainfo": ""}