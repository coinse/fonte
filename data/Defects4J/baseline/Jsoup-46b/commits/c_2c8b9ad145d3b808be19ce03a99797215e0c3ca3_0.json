{"sha": "2c8b9ad145d3b808be19ce03a99797215e0c3ca3", "log": "Performance: CPU and memory improvements for Selectors  Reduced CPU load and GC load for common selector use", "commit": "\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n     public boolean hasAttr(String attributeKey) {\n         Validate.notNull(attributeKey);\n \n-        if (attributeKey.toLowerCase().startsWith(\"abs:\")) {\n+        if (attributeKey.startsWith(\"abs:\")) {\n             String key = attributeKey.substring(\"abs:\".length());\n             if (attributes.hasKey(key) && !absUrl(key).equals(\"\"))\n                 return true;\n     public Node parent() {\n         return parentNode;\n     }\n+\n+    /**\n+     Gets this node's parent node. Node overridable by extending classes, so useful if you really just need the Node type.\n+     @return parent node; or null if no parent.\n+     */\n+    public final Node parentNode() {\n+        return parentNode;\n+    }\n     \n     /**\n      * Gets the Document associated with this Node. \n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n      * @return data matched from the queue\n      */\n     public String chompBalanced(char open, char close) {\n-        StringBuilder accum = new StringBuilder();\n+        int start = -1;\n+        int end = -1;\n         int depth = 0;\n         char last = 0;\n \n             if (isEmpty()) break;\n             Character c = consume();\n             if (last == 0 || last != ESC) {\n-                if (c.equals(open))\n+                if (c.equals(open)) {\n                     depth++;\n+                    if (start == -1)\n+                        start = pos;\n+                }\n                 else if (c.equals(close))\n                     depth--;\n             }\n \n             if (depth > 0 && last != 0)\n-                accum.append(c); // don't include the outer match pair in the return\n+                end = pos; // don't include the outer match pair in the return\n             last = c;\n         } while (depth > 0);\n-        return accum.toString();\n+        return (end >= 0) ? queue.substring(start, end) : \"\";\n     }\n     \n     /**\n      @return remained of queue.\n      */\n     public String remainder() {\n-        StringBuilder accum = new StringBuilder();\n-        while (!isEmpty()) {\n-            accum.append(consume());\n-        }\n-        return accum.toString();\n+        final String remainder = queue.substring(pos, queue.length());\n+        pos = queue.length();\n+        return remainder;\n     }\n     \n     public String toString() {\n--- a/src/main/java/org/jsoup/select/CombiningEvaluator.java\n+++ b/src/main/java/org/jsoup/select/CombiningEvaluator.java\n  * Base combining (and, or) evaluator.\n  */\n abstract class CombiningEvaluator extends Evaluator {\n-    final List<Evaluator> evaluators;\n+    final ArrayList<Evaluator> evaluators;\n+    int num = 0;\n \n     CombiningEvaluator() {\n         super();\n     CombiningEvaluator(Collection<Evaluator> evaluators) {\n         this();\n         this.evaluators.addAll(evaluators);\n+        updateNumEvaluators();\n     }\n \n     Evaluator rightMostEvaluator() {\n-        return evaluators.size() > 0 ? evaluators.get(evaluators.size() - 1) : null;\n+        return num > 0 ? evaluators.get(num - 1) : null;\n     }\n     \n     void replaceRightMostEvaluator(Evaluator replacement) {\n-        evaluators.set(evaluators.size() - 1, replacement);\n+        evaluators.set(num - 1, replacement);\n+    }\n+\n+    void updateNumEvaluators() {\n+        // used so we don't need to bash on size() for every match test\n+        num = evaluators.size();\n     }\n \n     static final class And extends CombiningEvaluator {\n \n         @Override\n         public boolean matches(Element root, Element node) {\n-            for (int i = 0; i < evaluators.size(); i++) {\n+            for (int i = 0; i < num; i++) {\n                 Evaluator s = evaluators.get(i);\n                 if (!s.matches(root, node))\n                     return false;\n          */\n         Or(Collection<Evaluator> evaluators) {\n             super();\n-            if (evaluators.size() > 1)\n+            if (num > 1)\n                 this.evaluators.add(new And(evaluators));\n             else // 0 or 1\n                 this.evaluators.addAll(evaluators);\n+            updateNumEvaluators();\n         }\n \n         Or() {\n \n         public void add(Evaluator e) {\n             evaluators.add(e);\n+            updateNumEvaluators();\n         }\n \n         @Override\n         public boolean matches(Element root, Element node) {\n-            for (int i = 0; i < evaluators.size(); i++) {\n+            for (int i = 0; i < num; i++) {\n                 Evaluator s = evaluators.get(i);\n                 if (s.matches(root, node))\n                     return true;\n--- a/src/main/java/org/jsoup/select/NodeTraversor.java\n+++ b/src/main/java/org/jsoup/select/NodeTraversor.java\n             } else {\n                 while (node.nextSibling() == null && depth > 0) {\n                     visitor.tail(node, depth);\n-                    node = node.parent();\n+                    node = node.parentNode();\n                     depth--;\n                 }\n                 visitor.tail(node, depth);\n--- a/src/main/java/org/jsoup/select/QueryParser.java\n+++ b/src/main/java/org/jsoup/select/QueryParser.java\n  */\n class QueryParser {\n     private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\n+    private static final String[] AttributeEvals = new String[]{\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"};\n \n     private TokenQueue tq;\n     private String query;\n \n     private void byAttribute() {\n         TokenQueue cq = new TokenQueue(tq.chompBalanced('[', ']')); // content queue\n-        String key = cq.consumeToAny(\"=\", \"!=\", \"^=\", \"$=\", \"*=\", \"~=\"); // eq, not, start, end, contain, match, (no val)\n+        String key = cq.consumeToAny(AttributeEvals); // eq, not, start, end, contain, match, (no val)\n         Validate.notEmpty(key);\n         cq.consumeWhitespace();\n ", "timestamp": 1384124389, "metainfo": ""}