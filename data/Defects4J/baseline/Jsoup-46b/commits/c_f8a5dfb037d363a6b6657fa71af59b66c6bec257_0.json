{"sha": "f8a5dfb037d363a6b6657fa71af59b66c6bec257", "log": "Updated parser error tracking to cap the max size of errors tracked. Defaults to 0 (disabled).", "commit": "\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n     HtmlTreeBuilder() {}\n \n     @Override\n-    Document parse(String input, String baseUri, boolean trackErrors) {\n+    Document parse(String input, String baseUri, ParseErrorList errors) {\n         state = HtmlTreeBuilderState.Initial;\n-        return super.parse(input, baseUri, trackErrors);\n-    }\n-\n-    List<Node> parseFragment(String inputFragment, Element context, String baseUri, boolean trackErrors) {\n+        return super.parse(input, baseUri, errors);\n+    }\n+\n+    List<Node> parseFragment(String inputFragment, Element context, String baseUri, ParseErrorList errors) {\n         // context may be null\n-        initialiseParse(inputFragment, baseUri, trackErrors);\n+        initialiseParse(inputFragment, baseUri, errors);\n         contextElement = context;\n         fragmentParsing = true;\n         Element root = null;\n     }\n \n     void error(HtmlTreeBuilderState state) {\n-        if (trackErrors)\n+        if (errors.canAddError())\n             errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n     }\n \n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/ParseErrorList.java\n+package org.jsoup.parser;\n+\n+import java.util.ArrayList;\n+\n+/**\n+ * A container for ParseErrors.\n+ * \n+ * @author Jonathan Hedley\n+ */\n+class ParseErrorList extends ArrayList<ParseError>{\n+    private static final int INITIAL_CAPACITY = 16;\n+    private final int maxSize;\n+    \n+    ParseErrorList(int initialCapacity, int maxSize) {\n+        super(initialCapacity);\n+        this.maxSize = maxSize;\n+    }\n+    \n+    boolean canAddError() {\n+        return size() < maxSize;\n+    }\n+\n+    int getMaxSize() {\n+        return maxSize;\n+    }\n+\n+    static ParseErrorList noTracking() {\n+        return new ParseErrorList(0, 0);\n+    }\n+    \n+    static ParseErrorList tracking(int maxSize) {\n+        return new ParseErrorList(INITIAL_CAPACITY, maxSize);\n+    }\n+}\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n  * in {@link org.jsoup.Jsoup}.\n  */\n public class Parser {\n+    private static final int DEFAULT_MAX_ERRORS = 0; // by default, error tracking is disabled.\n+    \n     private TreeBuilder treeBuilder;\n-    private boolean trackErrors = false;\n-    private List<ParseError> errors;\n+    private int maxErrors = DEFAULT_MAX_ERRORS;\n+    private ParseErrorList errors;\n \n     /**\n      * Create a new Parser, using the specified TreeBuilder\n     }\n     \n     public Document parseInput(String html, String baseUri) {\n-        Document doc = treeBuilder.parse(html, baseUri, trackErrors);\n-        errors = treeBuilder.getErrors();\n+        errors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\n+        Document doc = treeBuilder.parse(html, baseUri, errors);\n         return doc;\n     }\n \n      * @return current track error state.\n      */\n     public boolean isTrackErrors() {\n-        return trackErrors;\n+        return maxErrors > 0;\n     }\n \n     /**\n-     * Enable or disable parse error tracking for the next parse/\n-     * @param trackErrors on/off\n+     * Enable or disable parse error tracking for the next parse.\n+     * @param maxErrors the maximum number of errors to track. Set to 0 to disable.\n      * @return this, for chaining\n      */\n-    public Parser setTrackErrors(boolean trackErrors) {\n-        this.trackErrors = trackErrors;\n+    public Parser setTrackErrors(int maxErrors) {\n+        this.maxErrors = maxErrors;\n         return this;\n     }\n \n     /**\n      * Retrieve the parse errors, if any, from the last parse.\n-     * @return list of parse errors, if error tracking was enabled and errors occurred. If not enabled, returns null.\n+     * @return list of parse errors, up to the size of the maximum errors tracked.\n      */\n     public List<ParseError> getErrors() {\n         return errors;\n      */\n     public static Document parse(String html, String baseUri) {\n         TreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parse(html, baseUri, false);\n+        return treeBuilder.parse(html, baseUri, ParseErrorList.noTracking());\n     }\n \n     /**\n      */\n     public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n         HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, false);\n+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, ParseErrorList.noTracking());\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n     static final char replacementChar = '\\uFFFD'; // replaces null character\n \n     private CharacterReader reader; // html input\n-    private boolean trackErrors;\n-    private List<ParseError> errors; // errors found while tokenising\n+    private ParseErrorList errors; // errors found while tokenising\n \n     private TokeniserState state = TokeniserState.Data; // current tokenisation state\n     private Token emitPending; // the token we are about to emit on next read\n     private Token.StartTag lastStartTag; // the last start tag emitted, to test appropriate end tag\n     private boolean selfClosingFlagAcknowledged = true;\n \n-    Tokeniser(CharacterReader reader, List<ParseError> errors) {\n+    Tokeniser(CharacterReader reader, ParseErrorList errors) {\n         this.reader = reader;\n         this.errors = errors;\n-        this.trackErrors = errors != null;\n     }\n \n     Token read() {\n     }\n \n     void error(TokeniserState state) {\n-        if (trackErrors)\n+        if (errors.canAddError())\n             errors.add(new ParseError(reader.pos(), \"Unexpected character '%s' in input state [%s]\", reader.current(), state));\n     }\n \n     void eofError(TokeniserState state) {\n-        if (trackErrors)\n+        if (errors.canAddError())\n             errors.add(new ParseError(reader.pos(), \"Unexpectedly reached end of file (EOF) in input state [%s]\", state));\n     }\n \n     private void characterReferenceError(String message) {\n-        if (trackErrors)\n+        if (errors.canAddError())\n             errors.add(new ParseError(reader.pos(), \"Invalid character reference: %s\", message));\n     }\n \n     private void error(String errorMsg) {\n-        if (trackErrors)\n+        if (errors.canAddError())\n             errors.add(new ParseError(reader.pos(), errorMsg));\n     }\n \n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n     protected DescendableLinkedList<Element> stack; // the stack of open elements\n     protected String baseUri; // current base uri, for creating new elements\n     protected Token currentToken; // currentToken is used only for error tracking.\n-    protected boolean trackErrors = false;\n-    protected List<ParseError> errors; // null when not tracking errors\n+    protected ParseErrorList errors; // null when not tracking errors\n \n-    protected void initialiseParse(String input, String baseUri, boolean trackErrors) {\n+    protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n         Validate.notNull(input, \"String input must not be null\");\n         Validate.notNull(baseUri, \"BaseURI must not be null\");\n \n         doc = new Document(baseUri);\n         reader = new CharacterReader(input);\n-        this.trackErrors = trackErrors;\n-        errors = trackErrors ? new ArrayList<ParseError>() : null;\n+        this.errors = errors;\n         tokeniser = new Tokeniser(reader, errors);\n         stack = new DescendableLinkedList<Element>();\n         this.baseUri = baseUri;\n     }\n \n     Document parse(String input, String baseUri) {\n-        return parse(input, baseUri, false);\n+        return parse(input, baseUri, ParseErrorList.noTracking());\n     }\n \n-    Document parse(String input, String baseUri, boolean trackErrors) {\n-        initialiseParse(input, baseUri, trackErrors);\n+    Document parse(String input, String baseUri, ParseErrorList errors) {\n+        initialiseParse(input, baseUri, errors);\n         runParser();\n         return doc;\n-    }\n-    \n-    List<ParseError> getErrors() {\n-        return errors;\n     }\n \n     protected void runParser() {\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n  */\n public class XmlTreeBuilder extends TreeBuilder {\n     @Override\n-    protected void initialiseParse(String input, String baseUri, boolean trackErrors) {\n-        super.initialiseParse(input, baseUri, trackErrors);\n+    protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\n+        super.initialiseParse(input, baseUri, errors);\n         stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n     }\n \n--- a/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n     \n     @Test public void tracksErrorsWhenRequested() {\n         String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n-        Parser parser = Parser.htmlParser().setTrackErrors(true);\n-        Document doc = parser.parseInput(html, \"http://example.com\");\n+        Parser parser = Parser.htmlParser().setTrackErrors(500);\n+        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n         \n         List<ParseError> errors = parser.getErrors();\n         assertEquals(5, errors.size());\n         assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());\n     }\n \n+    @Test public void tracksLimitedErrorsWhenRequested() {\n+        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n+        Parser parser = Parser.htmlParser().setTrackErrors(3);\n+        Document doc = parser.parseInput(html, \"http://example.com\");\n+\n+        List<ParseError> errors = parser.getErrors();\n+        assertEquals(3, errors.size());\n+        assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());\n+        assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());\n+        assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());\n+    }\n+\n     @Test public void noErrorsByDefault() {\n         String html = \"<p>One</p href='no'>&arrgh;<font /><br /><foo\";\n         Parser parser = Parser.htmlParser();\n-        Document doc = parser.parseInput(html, \"http://example.com\");\n+        Document doc = Jsoup.parse(html, \"http://example.com\", parser);\n \n         List<ParseError> errors = parser.getErrors();\n-        assertNull(errors);\n+        assertEquals(0, errors.size());\n     }\n     \n     @Test public void handlesCommentsInTable() {", "timestamp": 1332305757, "metainfo": ""}