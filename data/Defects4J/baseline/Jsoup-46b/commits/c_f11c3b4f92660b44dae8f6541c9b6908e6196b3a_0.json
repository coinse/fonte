{"sha": "f11c3b4f92660b44dae8f6541c9b6908e6196b3a", "log": "small optimizations", "commit": "\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n      * @return true if the next characters match.\n      */\n     public boolean matches(String seq) {\n-        int count = seq.length();\n+        /*int count = seq.length();\n         if (count > remainingLength())\n             return false;\n \n             if (Character.toLowerCase(seq.charAt(count)) != Character.toLowerCase(queue.charAt(pos+count)))\n                 return false;\n         }\n-        return true;\n+        return true;*/\n+    \t\n+    \treturn queue.regionMatches(true, pos, seq, 0, seq.length());\n     }\n \n     /**\n \n     public boolean matchesStartTag() {\n         // micro opt for matching \"<x\"\n-        return (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetterOrDigit(queue.charAt(pos+1)));\n+        return (remainingLength() > 1 && queue.charAt(pos) == '<' && Character.isLetterOrDigit(queue.charAt(pos + 1)));\n     }\n \n     /**\n      * @return first character on queue.\n      */\n     public char consume() {\n-        char c = queue.charAt(pos);\n-        pos++;\n-        return c;\n+        return queue.charAt(pos++);\n     }\n \n     /**\n      * @param close closer\n      * @return data matched from the queue\n      */\n-    public String chompBalanced(Character open, Character close) {\n+    public String chompBalanced(char open, char close) {\n         StringBuilder accum = new StringBuilder();\n         int depth = 0;\n-        Character last = null;\n+        char last = 0;\n \n         do {\n             if (isEmpty()) break;\n             Character c = consume();\n-            if (last == null || !last.equals(ESC)) {\n+            if (last == 0 || last != ESC) {\n                 if (c.equals(open))\n                     depth++;\n                 else if (c.equals(close))\n                     depth--;\n             }\n \n-            if (depth > 0 && last != null)\n+            if (depth > 0 && last != 0)\n                 accum.append(c); // don't include the outer match pair in the return\n             last = c;\n         } while (depth > 0);\n      */\n     public static String unescape(String in) {\n         StringBuilder out = new StringBuilder();\n-        Character last = null;\n-        for (Character c : in.toCharArray()) {\n-            if (c.equals(ESC)) {\n-                if (last != null && last.equals(ESC))\n+        char last = 0;\n+        for (char c : in.toCharArray()) {\n+            if (c == ESC) {\n+                if (last != 0 && last == ESC)\n                     out.append(c);\n             }\n             else ", "timestamp": 1309605125, "metainfo": ""}