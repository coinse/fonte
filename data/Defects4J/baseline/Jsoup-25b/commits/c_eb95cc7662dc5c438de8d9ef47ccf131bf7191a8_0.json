{"sha": "eb95cc7662dc5c438de8d9ef47ccf131bf7191a8", "log": "Fixed selector so that \"parent child\" doesn't contain parent, and \"element.class\" is an AND on parent element, and doesn't match .class in child element (i.e. I re-read the CSS3 selector doc, which is clearer than jquery doc).", "commit": "\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n     /**\n      * Pulls the next run of whitespace characters of the queue.\n      */\n-    public void consumeWhitespace() {\n+    public boolean consumeWhitespace() {\n+        boolean seen = false;\n         while (!queue.isEmpty() && Character.isWhitespace(queue.peekFirst())) {\n             consume();\n-        }\n+            seen = true;\n+        }\n+        return seen;\n     }\n \n     /**\n \n     public String remainder() {\n         StringBuilder accum = new StringBuilder();\n-        for (Character character : queue) {\n-            accum.append(character);\n+        while (!queue.isEmpty()) {\n+            accum.append(consume());\n         }\n         return accum.toString();\n     }\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n         } else { // unhandled\n             throw new SelectorParseException(\"Could not parse query \" + query);\n         }\n-        tq.consumeWhitespace();\n \n-        // hierarchy (todo: implement >, +, ~)\n-        if (!tq.isEmpty()) {\n+        // hierarchy (todo: implement +, ~)\n+        boolean seenWhite = tq.consumeWhitespace();\n+        if (!tq.isEmpty()) { \n             if (tq.matchChomp(\",\")) { // group or\n                 while (!tq.isEmpty()) {\n                     String subQuery = tq.chompTo(\",\");\n                 }\n                 return new Elements(elements);\n             } else if (tq.matchChomp(\">\")) { // parent > child\n-                Elements candidateChildren = new Elements(select(tq.remainder(), elements));\n-                return filterForChildren(elements, candidateChildren);\n-            } else { // ancestor descendant (AND, really)\n-                return new Elements(select(tq.remainder(), elements));\n+                Elements candidates = new Elements(select(tq.remainder(), elements));\n+                return filterForChildren(elements, candidates);\n+            } else if (seenWhite) { // ancestor descendant\n+                Elements candidates = new Elements(select(tq.remainder(), elements));\n+                return filterForDescendants(elements, candidates);\n+            } else { // E.class, E#id, E[attr] etc. AND\n+                Elements candidates = new Elements(select(tq.remainder(), elements));\n+                return filterForSelf(elements, candidates);\n             }\n         } else {\n             return new Elements(elements);\n         // no-op; just append uniques\n     }\n \n-    private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidateChildren) {\n+    // direct child descendants\n+    private static Elements filterForChildren(Collection<Element> parents, Collection<Element> candidates) {\n         Elements children = new Elements();\n-        CHILDREN: for (Element c : candidateChildren) {\n+        CHILD: for (Element c : candidates) {\n             for (Element p : parents) {\n                 if (c.parent().equals(p)) {\n                     children.add(c);\n-                    continue CHILDREN;\n+                    continue CHILD;\n                 }\n             }\n+        }\n+        return children;\n+    }\n+    \n+    // children or lower descendants. input candidates stemmed from found elements, so are either a descendant \n+    // or the original element; so check that parent is not child\n+    private static Elements filterForDescendants(Collection<Element> parents, Collection<Element> candidates) {\n+        Elements children = new Elements();\n+        CHILD: for (Element c : candidates) {\n+            boolean found = false;\n+            for (Element p : parents) {\n+                if (c.equals(p)) {\n+                    found = true;\n+                    continue CHILD;\n+                }\n+            }\n+            if (!found)\n+                children.add(c);\n+        }\n+        return children;\n+    }\n+    \n+    // union of both sets, for e.class type selectors\n+    private static Elements filterForSelf(Collection<Element> parents, Collection<Element> candidates) {\n+        Elements children = new Elements();\n+        CHILD: for (Element c : candidates) {\n+            for (Element p : parents) {\n+                if (c.equals(p)) {\n+                    children.add(c);\n+                    continue CHILD;\n+                }\n+            }   \n         }\n         return children;\n     }\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n         String h = \"<div><p>Hello</p><p><b>there</b></p></div>\";\n         Document doc = Jsoup.parse(h);\n         Elements allDoc = doc.select(\"*\");\n-        Elements allDiv = doc.select(\"div *\");\n+        Elements allUnderDiv = doc.select(\"div *\");\n         assertEquals(8, allDoc.size());\n-        assertEquals(4, allDiv.size());\n-        assertEquals(\"div\", allDiv.get(0).tagName());\n+        assertEquals(3, allUnderDiv.size());\n+        assertEquals(\"p\", allUnderDiv.first().tagName());\n+    }\n+    \n+    @Test public void testAllWithClass() {\n+        String h = \"<p class=first>One<p class=first>Two<p>Three\";\n+        Document doc = Jsoup.parse(h);\n+        Elements ps = doc.select(\"*.first\");\n+        assertEquals(2, ps.size());\n     }\n \n     @Test public void testGroupOr() {\n         assertEquals(1, p.size());\n         assertEquals(\"Hello\", p.get(0).text());\n     }\n+    \n+    @Test public void and() {\n+        String h = \"<div id=1 class=foo title=bar><p class=foo title=bar>Hello</p></div\";\n+        Document doc = Jsoup.parse(h);\n+        \n+        Elements div = doc.select(\"div.foo\");\n+        assertEquals(1, div.size());\n+        assertEquals(\"div\", div.first().tagName());\n+        \n+        Elements p = doc.select(\"div .foo\"); // space indicates like \"div *.foo\"\n+        assertEquals(1, p.size());\n+        assertEquals(\"p\", p.first().tagName());\n+        \n+        Elements div2 = doc.select(\"div#1.foo[title=bar]\"); // very specific!\n+        assertEquals(1, div2.size());\n+        assertEquals(\"div\", div2.first().tagName());\n+        \n+        Elements p2 = doc.select(\"div *.foo\"); // space indicates like \"div *.foo\"\n+        assertEquals(1, p2.size());\n+        assertEquals(\"p\", p2.first().tagName());\n+    }\n \n     @Test public void deeperDescendant() {\n-        String h = \"<div class=head><p class=first>Hello</div><div class=head><h1 class=first>Another</h1><p>Again</div>\";\n+        String h = \"<div class=head><p><span class=first>Hello</div><div class=head><p class=first><span>Another</span><p>Again</div>\";\n         Elements els = Jsoup.parse(h).select(\"div p .first\");\n         assertEquals(1, els.size());\n-        assertEquals(\"Hello\", els.get(0).text());\n+        assertEquals(\"Hello\", els.first().text());\n+        assertEquals(\"span\", els.first().tagName());\n     }\n \n     @Test public void parentChildElement() {", "timestamp": 1309605103, "metainfo": ""}