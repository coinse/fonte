{"sha": "d8c3f9cbc6a562a7d23711d4c0f97f4e4758444e", "log": "Fixed invocation of alternative parser in Jsoup.Connection. Updated test to confirm.", "commit": "\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n          * Configures the request to (not) follow server redirects. By default this is <b>true</b>.\n          *\n          * @param followRedirects true if server redirects should be followed.\n-         * @return this Connection, for chaining\n+         * @return this Request, for chaining\n          */\n         public Request followRedirects(boolean followRedirects);\n \n     \t/**\n     \t * Configures the request to ignore HTTP errors in the response.\n     \t * @param ignoreHttpErrors set to true to ignore HTTP errors.\n+         * @return this Request, for chaining\n     \t */\n-        public void ignoreHttpErrors(boolean ignoreHttpErrors);\n+        public Request ignoreHttpErrors(boolean ignoreHttpErrors);\n \n         /**\n          * Get the current ignoreContentType configuration.\n         /**\n     \t * Configures the request to ignore the Content-Type of the response.\n     \t * @param ignoreContentType set to true to ignore the contenet type.\n+         * @return this Request, for chaining\n     \t */\n-        public void ignoreContentType(boolean ignoreContentType);\n+        public Request ignoreContentType(boolean ignoreContentType);\n \n         /**\n          * Add a data parameter to the request\n          */\n         public Collection<KeyVal> data();\n \n+        /**\n+         * Specify the parser to use when parsing the document.\n+         * @param parser parser to use.\n+         * @return this Request, for chaining\n+         */\n+        public Request parser(Parser parser);\n+\n+        /**\n+         * Get the current parser to use when parsing the document.\n+         * @return current Parser\n+         */\n+        public Parser parser();\n     }\n \n     /**\n         public Document parse() throws IOException;\n \n         /**\n-         * Specify the parser to use when parsing the document.\n-         * @param parser parser to use.\n-         */\n-        public void parser(Parser parser);\n-\n-        /**\n          * Get the body of the response as a plain string.\n          * @return body\n          */\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n     }\n \n     public Connection parser(Parser parser) {\n-        res.parser(parser);\n+        req.parser(parser);\n         return this;\n     }\n \n         private Collection<Connection.KeyVal> data;\n         private boolean ignoreHttpErrors = false;\n         private boolean ignoreContentType = false;\n+        private Parser parser;\n \n       \tprivate Request() {\n             timeoutMilliseconds = 3000;\n             data = new ArrayList<Connection.KeyVal>();\n             method = Connection.Method.GET;\n             headers.put(\"Accept-Encoding\", \"gzip\");\n+            parser = Parser.htmlParser();\n         }\n \n         public int timeout() {\n             return ignoreHttpErrors;\n         }\n \n-        public void ignoreHttpErrors(boolean ignoreHttpErrors) {\n+        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n             this.ignoreHttpErrors = ignoreHttpErrors;\n+            return this;\n         }\n \n         public boolean ignoreContentType() {\n             return ignoreContentType;\n         }\n \n-        public void ignoreContentType(boolean ignoreContentType) {\n+        public Connection.Request ignoreContentType(boolean ignoreContentType) {\n             this.ignoreContentType = ignoreContentType;\n+            return this;\n         }\n \n         public Request data(Connection.KeyVal keyval) {\n         public Collection<Connection.KeyVal> data() {\n             return data;\n         }\n+        \n+        public Request parser(Parser parser) {\n+            this.parser = parser;\n+            return this;\n+        }\n+        \n+        public Parser parser() {\n+            return parser;\n+        }\n     }\n \n     public static class Response extends Base<Connection.Response> implements Connection.Response {\n         private static final int MAX_REDIRECTS = 20;\n-        private Parser parser = Parser.htmlParser();\n         private int statusCode;\n         private String statusMessage;\n         private ByteBuffer byteData;\n             if (!req.ignoreContentType() && (contentType == null || !(contentType.startsWith(\"text/\") || contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))))\n                 throw new IOException(String.format(\"Unhandled content type \\\"%s\\\" on URL %s. Must be text/*, application/xml, or application/xhtml+xml\",\n                     contentType, url.toString()));\n-            Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm(), parser);\n+            Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm(), req.parser());\n             byteData.rewind();\n             charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n             return doc;\n-        }\n-\n-        public void parser(Parser parser) {\n-            Validate.notNull(parser);\n-            this.parser = parser;\n         }\n \n         public String body() {\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n package org.jsoup.parser;\n \n import org.jsoup.helper.DescendableLinkedList;\n+import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n \n     protected List<ParseError> errors;\n \n     protected void initialiseParse(String input, String baseUri, boolean trackErrors) {\n+        Validate.notNull(input, \"String input must not be null\");\n+        Validate.notNull(baseUri, \"BaseURI must not be null\");\n+\n         doc = new Document(baseUri);\n         reader = new CharacterReader(input);\n         tokeniser = new Tokeniser(reader);\n--- a/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n package org.jsoup.parser;\n \n+import org.jsoup.Jsoup;\n import org.jsoup.TextUtil;\n import org.jsoup.nodes.Document;\n import org.junit.Test;\n \n+import java.io.IOException;\n+\n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n \n /**\n  * Tests XmlTreeBuilder.\n         assertEquals(\"<!DOCTYPE html><!-- a comment -->One <qux />Two\",\n                 TextUtil.stripNewlines(doc.html()));\n     }\n+    \n+    @Test\n+    public void testSupplyParserToJsoupClass() {\n+        String xml = \"<doc><val>One<val>Two</val></bar>Three</doc>\";\n+        Document doc = Jsoup.parse(xml, \"http://foo.com/\", Parser.xmlParser());\n+        assertEquals(\"<doc><val>One<val>Two</val>Three</val></doc>\",\n+                TextUtil.stripNewlines(doc.html()));\n+    }\n+    \n+    @Test\n+    public void testSupplyParserToConnection() throws IOException {\n+        String xmlUrl = \"http://direct.infohound.net/tools/jsoup-xml-test.xml\";\n+        \n+        // parse with both xml and html parser, ensure different\n+        Document xmlDoc = Jsoup.connect(xmlUrl).parser(Parser.xmlParser()).get();\n+        Document htmlDoc = Jsoup.connect(xmlUrl).get();\n+\n+        assertEquals(\"<doc><val>One<val>Two</val>Three</val></doc>\",\n+                TextUtil.stripNewlines(xmlDoc.html()));\n+        assertNotSame(htmlDoc, xmlDoc);\n+        assertEquals(1, htmlDoc.select(\"head\").size()); // html parser normalises\n+        assertEquals(0, xmlDoc.select(\"head\").size()); // xml parser does not\n+    }\n }", "timestamp": 1330910310, "metainfo": ""}