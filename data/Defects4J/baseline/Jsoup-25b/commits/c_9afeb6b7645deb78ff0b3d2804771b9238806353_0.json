{"sha": "9afeb6b7645deb78ff0b3d2804771b9238806353", "log": "Merge branch 'master' of https://github.com/bsampath/jsoup into bsampath-master", "commit": "\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n                 return tb.process(t);\n             } else if (t.isComment()) {\n                 tb.insert(t.asComment());\n+                return true;\n             } else if (t.isDoctype()) {\n                 tb.error(this);\n                 return false;\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n package org.jsoup;\n \n import org.jsoup.nodes.Document;\n+import org.jsoup.parser.Parser;\n \n import java.net.URL;\n import java.util.Map;\n     public Connection cookies(Map<String, String> cookies);\n \n     /**\n+     * Provide an alternate parser to use when parsing the response to a Document.\n+     * @param parser alternate parser\n+     * @return this Connection, for chaining\n+     */\n+    public Connection parser(Parser parser);\n+\n+    /**\n      * Execute the request as a GET, and parse the result.\n      * @return parsed Document\n      * @throws IOException on error\n          * Configures the request to (not) follow server redirects. By default this is <b>true</b>.\n          *\n          * @param followRedirects true if server redirects should be followed.\n-         * @return this Connection, for chaining\n+         * @return this Request, for chaining\n          */\n         public Request followRedirects(boolean followRedirects);\n \n     \t/**\n     \t * Configures the request to ignore HTTP errors in the response.\n     \t * @param ignoreHttpErrors set to true to ignore HTTP errors.\n+         * @return this Request, for chaining\n     \t */\n-        public void ignoreHttpErrors(boolean ignoreHttpErrors);\n+        public Request ignoreHttpErrors(boolean ignoreHttpErrors);\n \n         /**\n          * Get the current ignoreContentType configuration.\n         /**\n     \t * Configures the request to ignore the Content-Type of the response.\n     \t * @param ignoreContentType set to true to ignore the contenet type.\n+         * @return this Request, for chaining\n     \t */\n-        public void ignoreContentType(boolean ignoreContentType);\n+        public Request ignoreContentType(boolean ignoreContentType);\n \n         /**\n          * Add a data parameter to the request\n          */\n         public Collection<KeyVal> data();\n \n+        /**\n+         * Specify the parser to use when parsing the document.\n+         * @param parser parser to use.\n+         * @return this Request, for chaining\n+         */\n+        public Request parser(Parser parser);\n+\n+        /**\n+         * Get the current parser to use when parsing the document.\n+         * @return current Parser\n+         */\n+        public Parser parser();\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/Jsoup.java\n+++ b/src/main/java/org/jsoup/Jsoup.java\n      */\n     public static Document parse(String html, String baseUri) {\n         return Parser.parse(html, baseUri);\n+    }\n+\n+    /**\n+     Parse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML\n+     (non-HTML) parser.\n+\n+     @param html    HTML to parse\n+     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur\n+     before the HTML declares a {@code <base href>} tag.\n+     @param parser alternate {@link Parser#xmlParser() parser} to use.\n+     @return sane HTML\n+     */\n+    public static Document parse(String html, String baseUri, Parser parser) {\n+        return parser.parseInput(html, baseUri);\n     }\n \n     /**\n     }\n \n     /**\n+     Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n+     (non-HTML) parser.\n+\n+     @param in          input stream to read. Make sure to close it after parsing.\n+     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n+     present, or fall back to {@code UTF-8} (which is often safe to do).\n+     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n+     @param parser alternate {@link Parser#xmlParser() parser} to use.\n+     @return sane HTML\n+\n+     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n+     */\n+    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n+        return DataUtil.load(in, charsetName, baseUri, parser);\n+    }\n+\n+    /**\n      Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n \n      @param bodyHtml body HTML fragment\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n package org.jsoup.helper;\n \n-import org.jsoup.Jsoup;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n+import org.jsoup.parser.Parser;\n \n import java.io.*;\n import java.nio.ByteBuffer;\n         try {\n             inStream = new FileInputStream(in);\n             ByteBuffer byteData = readToByteBuffer(inStream);\n-            return parseByteData(byteData, charsetName, baseUri);\n+            return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n         } finally {\n             if (inStream != null)\n                 inStream.close();\n      */\n     public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n         ByteBuffer byteData = readToByteBuffer(in);\n-        return parseByteData(byteData, charsetName, baseUri);\n+        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n+    }\n+\n+    /**\n+     * Parses a Document from an input steam, using the provided Parser.\n+     * @param in input stream to parse. You will need to close it.\n+     * @param charsetName character set of input\n+     * @param baseUri base URI of document, to resolve relative links against\n+     * @param parser alternate {@link Parser#xmlParser() parser} to use.\n+     * @return Document\n+     * @throws IOException on IO error\n+     */\n+    public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n+        ByteBuffer byteData = readToByteBuffer(in);\n+        return parseByteData(byteData, charsetName, baseUri, parser);\n     }\n \n     // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n     // switching the chartset midstream when a meta http-equiv tag defines the charset.\n-    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n+    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n         String docData;\n         Document doc = null;\n         if (charsetName == null) { // determine from meta. safe parse as UTF-8\n             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n-            doc = Jsoup.parse(docData, baseUri);\n+            doc = parser.parseInput(docData, baseUri);\n             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n             if (meta != null) { // if not found, will keep utf-8 as best attempt\n                 String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n             docData = Charset.forName(charsetName).decode(byteData).toString();\n         }\n         if (doc == null) {\n-            doc = Jsoup.parse(docData, baseUri);\n+            doc = parser.parseInput(docData, baseUri);\n             doc.outputSettings().charset(charsetName);\n         }\n         return doc;\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n \n import org.jsoup.Connection;\n import org.jsoup.nodes.Document;\n+import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n \n import java.io.*;\n         for (Map.Entry<String, String> entry : cookies.entrySet()) {\n             req.cookie(entry.getKey(), entry.getValue());\n         }\n+        return this;\n+    }\n+\n+    public Connection parser(Parser parser) {\n+        req.parser(parser);\n         return this;\n     }\n \n         private Collection<Connection.KeyVal> data;\n         private boolean ignoreHttpErrors = false;\n         private boolean ignoreContentType = false;\n+        private Parser parser;\n \n       \tprivate Request() {\n             timeoutMilliseconds = 3000;\n             data = new ArrayList<Connection.KeyVal>();\n             method = Connection.Method.GET;\n             headers.put(\"Accept-Encoding\", \"gzip\");\n+            parser = Parser.htmlParser();\n         }\n \n         public int timeout() {\n             return ignoreHttpErrors;\n         }\n \n-        public void ignoreHttpErrors(boolean ignoreHttpErrors) {\n+        public Connection.Request ignoreHttpErrors(boolean ignoreHttpErrors) {\n             this.ignoreHttpErrors = ignoreHttpErrors;\n+            return this;\n         }\n \n         public boolean ignoreContentType() {\n             return ignoreContentType;\n         }\n \n-        public void ignoreContentType(boolean ignoreContentType) {\n+        public Connection.Request ignoreContentType(boolean ignoreContentType) {\n             this.ignoreContentType = ignoreContentType;\n+            return this;\n         }\n \n         public Request data(Connection.KeyVal keyval) {\n \n         public Collection<Connection.KeyVal> data() {\n             return data;\n+        }\n+        \n+        public Request parser(Parser parser) {\n+            this.parser = parser;\n+            return this;\n+        }\n+        \n+        public Parser parser() {\n+            return parser;\n         }\n     }\n \n                     throw new IOException(String.format(\"Too many redirects occurred trying to load URL %s\", previousResponse.url()));\n             }\n         }\n-\n+        \n         static Response execute(Connection.Request req) throws IOException {\n             return execute(req, null);\n         }\n             if (!req.ignoreContentType() && (contentType == null || !(contentType.startsWith(\"text/\") || contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))))\n                 throw new IOException(String.format(\"Unhandled content type \\\"%s\\\" on URL %s. Must be text/*, application/xml, or application/xhtml+xml\",\n                     contentType, url.toString()));\n-            Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm());\n+            Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm(), req.parser());\n             byteData.rewind();\n             charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n             return doc;\n--- a/src/main/java/org/jsoup/helper/StringUtil.java\n+++ b/src/main/java/org/jsoup/helper/StringUtil.java\n \n         int l = string.length();\n         for (int i = 0; i < l; i++) {\n-            if (!Character.isWhitespace(string.codePointAt(i)))\n+            if (!StringUtil.isWhitespace(string.codePointAt(i)))\n                 return false;\n         }\n         return true;\n         return true;\n     }\n \n+    /**\n+     * Tests if a code point is \"whitespace\" as defined in the HTML spec.\n+     * @param c code point to test\n+     * @return true if code point is whitespace, false otherwise\n+     */\n+    public static boolean isWhitespace(int c){\n+        return c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r';\n+    }\n+\n     public static String normaliseWhitespace(String string) {\n         StringBuilder sb = new StringBuilder(string.length());\n \n         int l = string.length();\n         for (int i = 0; i < l; i++) {\n             int c = string.codePointAt(i);\n-            if (Character.isWhitespace(c)) {\n+            if (isWhitespace(c)) {\n                 if (lastWasWhite) {\n                     modified = true;\n                     continue;\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+package org.jsoup.parser;\n+\n+import org.jsoup.helper.DescendableLinkedList;\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.*;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * HTML Tree Builder; creates a DOM from Tokens.\n+ */\n+class HtmlTreeBuilder extends TreeBuilder {\n+\n+    private HtmlTreeBuilderState state; // the current state\n+    private HtmlTreeBuilderState originalState; // original / marked state\n+\n+    private boolean baseUriSetFromDoc = false;\n+    private Element headElement; // the current head element\n+    private Element formElement; // the current form element\n+    private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n+    private DescendableLinkedList<Element> formattingElements = new DescendableLinkedList<Element>(); // active (open) formatting elements\n+    private List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); // chars in table to be shifted out\n+\n+    private boolean framesetOk = true; // if ok to go into frameset\n+    private boolean fosterInserts = false; // if next inserts should be fostered\n+    private boolean fragmentParsing = false; // if parsing a fragment of html\n+\n+    HtmlTreeBuilder() {}\n+\n+    @Override\n+    Document parse(String input, String baseUri, boolean trackErrors) {\n+        state = HtmlTreeBuilderState.Initial;\n+        return super.parse(input, baseUri, trackErrors);\n+    }\n+\n+    List<Node> parseFragment(String inputFragment, Element context, String baseUri, boolean trackErrors) {\n+        // context may be null\n+        initialiseParse(inputFragment, baseUri, trackErrors);\n+        contextElement = context;\n+        fragmentParsing = true;\n+        Element root = null;\n+\n+        if (context != null) {\n+            if (context.ownerDocument() != null) // quirks setup:\n+                doc.quirksMode(context.ownerDocument().quirksMode());\n+\n+            // initialise the tokeniser state:\n+            String contextTag = context.tagName();\n+            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n+                tokeniser.transition(TokeniserState.Rcdata);\n+            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n+                tokeniser.transition(TokeniserState.Rawtext);\n+            else if (contextTag.equals(\"script\"))\n+                tokeniser.transition(TokeniserState.ScriptData);\n+            else if (contextTag.equals((\"noscript\")))\n+                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n+            else if (contextTag.equals(\"plaintext\"))\n+                tokeniser.transition(TokeniserState.Data);\n+            else\n+                tokeniser.transition(TokeniserState.Data); // default\n+\n+            root = new Element(Tag.valueOf(\"html\"), baseUri);\n+            doc.appendChild(root);\n+            stack.push(root);\n+            resetInsertionMode();\n+            // todo: setup form element to nearest form on context (up ancestor chain)\n+        }\n+\n+        runParser();\n+        if (context != null)\n+            return root.childNodes();\n+        else\n+            return doc.childNodes();\n+    }\n+\n+    @Override\n+    protected boolean process(Token token) {\n+        currentToken = token;\n+        return this.state.process(token, this);\n+    }\n+\n+    boolean process(Token token, HtmlTreeBuilderState state) {\n+        currentToken = token;\n+        return state.process(token, this);\n+    }\n+\n+    void transition(HtmlTreeBuilderState state) {\n+        this.state = state;\n+    }\n+\n+    HtmlTreeBuilderState state() {\n+        return state;\n+    }\n+\n+    void markInsertionMode() {\n+        originalState = state;\n+    }\n+\n+    HtmlTreeBuilderState originalState() {\n+        return originalState;\n+    }\n+\n+    void framesetOk(boolean framesetOk) {\n+        this.framesetOk = framesetOk;\n+    }\n+\n+    boolean framesetOk() {\n+        return framesetOk;\n+    }\n+\n+    Document getDocument() {\n+        return doc;\n+    }\n+\n+    String getBaseUri() {\n+        return baseUri;\n+    }\n+\n+    void maybeSetBaseUri(Element base) {\n+        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n+            return;\n+\n+        String href = base.absUrl(\"href\");\n+        if (href.length() != 0) { // ignore <base target> etc\n+            baseUri = href;\n+            baseUriSetFromDoc = true;\n+            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n+        }\n+    }\n+\n+    boolean isFragmentParsing() {\n+        return fragmentParsing;\n+    }\n+\n+    void error(HtmlTreeBuilderState state) {\n+        if (trackErrors)\n+            errors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n+    }\n+\n+    Element insert(Token.StartTag startTag) {\n+        // handle empty unknown tags\n+        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate fake end tag.\n+        if (startTag.isSelfClosing() && !Tag.isKnownTag(startTag.name())) {\n+            Element el = insertEmpty(startTag);\n+            process(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in\n+            return el;\n+        }\n+        \n+        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n+        insert(el);\n+        return el;\n+    }\n+\n+    Element insert(String startTagName) {\n+        Element el = new Element(Tag.valueOf(startTagName), baseUri);\n+        insert(el);\n+        return el;\n+    }\n+\n+    void insert(Element el) {\n+        insertNode(el);\n+        stack.add(el);\n+    }\n+\n+    Element insertEmpty(Token.StartTag startTag) {\n+        Tag tag = Tag.valueOf(startTag.name());\n+        Element el = new Element(tag, baseUri, startTag.attributes);\n+        insertNode(el);\n+        if (startTag.isSelfClosing()) {\n+            tokeniser.acknowledgeSelfClosingFlag();\n+            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output\n+                tag.setSelfClosing();\n+        }\n+        return el;\n+    }\n+\n+    void insert(Token.Comment commentToken) {\n+        Comment comment = new Comment(commentToken.getData(), baseUri);\n+        insertNode(comment);\n+    }\n+\n+    void insert(Token.Character characterToken) {\n+        Node node;\n+        // characters in script and style go in as datanodes, not text nodes\n+        if (StringUtil.in(currentElement().tagName(), \"script\", \"style\"))\n+            node = new DataNode(characterToken.getData(), baseUri);\n+        else\n+            node = new TextNode(characterToken.getData(), baseUri);\n+        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n+    }\n+\n+    private void insertNode(Node node) {\n+        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n+        if (stack.size() == 0)\n+            doc.appendChild(node);\n+        else if (isFosterInserts())\n+            insertInFosterParent(node);\n+        else\n+            currentElement().appendChild(node);\n+    }\n+\n+    Element pop() {\n+        // todo - dev, remove validation check\n+        if (stack.peekLast().nodeName().equals(\"td\") && !state.name().equals(\"InCell\"))\n+            Validate.isFalse(true, \"pop td not in cell\");\n+        if (stack.peekLast().nodeName().equals(\"html\"))\n+            Validate.isFalse(true, \"popping html!\");\n+        return stack.pollLast();\n+    }\n+\n+    void push(Element element) {\n+        stack.add(element);\n+    }\n+\n+    DescendableLinkedList<Element> getStack() {\n+        return stack;\n+    }\n+\n+    boolean onStack(Element el) {\n+        return isElementInQueue(stack, el);\n+    }\n+\n+    private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element) {\n+        Iterator<Element> it = queue.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == element) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    Element getFromStack(String elName) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next.nodeName().equals(elName)) {\n+                return next;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    boolean removeFromStack(Element el) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == el) {\n+                it.remove();\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    void popStackToClose(String elName) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next.nodeName().equals(elName)) {\n+                it.remove();\n+                break;\n+            } else {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    void popStackToClose(String... elNames) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (StringUtil.in(next.nodeName(), elNames)) {\n+                it.remove();\n+                break;\n+            } else {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    void popStackToBefore(String elName) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next.nodeName().equals(elName)) {\n+                break;\n+            } else {\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    void clearStackToTableContext() {\n+        clearStackToContext(\"table\");\n+    }\n+\n+    void clearStackToTableBodyContext() {\n+        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n+    }\n+\n+    void clearStackToTableRowContext() {\n+        clearStackToContext(\"tr\");\n+    }\n+\n+    private void clearStackToContext(String... nodeNames) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n+                break;\n+            else\n+                it.remove();\n+        }\n+    }\n+\n+    Element aboveOnStack(Element el) {\n+        assert onStack(el);\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == el) {\n+                return it.next();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    void insertOnStackAfter(Element after, Element in) {\n+        int i = stack.lastIndexOf(after);\n+        Validate.isTrue(i != -1);\n+        stack.add(i+1, in);\n+    }\n+\n+    void replaceOnStack(Element out, Element in) {\n+        replaceInQueue(stack, out, in);\n+    }\n+\n+    private void replaceInQueue(LinkedList<Element> queue, Element out, Element in) {\n+        int i = queue.lastIndexOf(out);\n+        Validate.isTrue(i != -1);\n+        queue.remove(i);\n+        queue.add(i, in);\n+    }\n+\n+    void resetInsertionMode() {\n+        boolean last = false;\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element node = it.next();\n+            if (!it.hasNext()) {\n+                last = true;\n+                node = contextElement;\n+            }\n+            String name = node.nodeName();\n+            if (\"select\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InSelect);\n+                break; // frag\n+            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+                transition(HtmlTreeBuilderState.InCell);\n+                break;\n+            } else if (\"tr\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InRow);\n+                break;\n+            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InTableBody);\n+                break;\n+            } else if (\"caption\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InCaption);\n+                break;\n+            } else if (\"colgroup\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InColumnGroup);\n+                break; // frag\n+            } else if (\"table\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InTable);\n+                break;\n+            } else if (\"head\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InBody);\n+                break; // frag\n+            } else if (\"body\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InBody);\n+                break;\n+            } else if (\"frameset\".equals(name)) {\n+                transition(HtmlTreeBuilderState.InFrameset);\n+                break; // frag\n+            } else if (\"html\".equals(name)) {\n+                transition(HtmlTreeBuilderState.BeforeHead);\n+                break; // frag\n+            } else if (last) {\n+                transition(HtmlTreeBuilderState.InBody);\n+                break; // frag\n+            }\n+        }\n+    }\n+\n+    // todo: tidy up in specific scope methods\n+    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n+        return inSpecificScope(new String[]{targetName}, baseTypes, extraTypes);\n+    }\n+\n+    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element el = it.next();\n+            String elName = el.nodeName();\n+            if (StringUtil.in(elName, targetNames))\n+                return true;\n+            if (StringUtil.in(elName, baseTypes))\n+                return false;\n+            if (extraTypes != null && StringUtil.in(elName, extraTypes))\n+                return false;\n+        }\n+        Validate.fail(\"Should not be reachable\");\n+        return false;\n+    }\n+\n+    boolean inScope(String[] targetNames) {\n+        return inSpecificScope(targetNames, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, null);\n+    }\n+\n+    boolean inScope(String targetName) {\n+        return inScope(targetName, null);\n+    }\n+\n+    boolean inScope(String targetName, String[] extras) {\n+        return inSpecificScope(targetName, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, extras);\n+        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n+        // todo: in svg namespace: forignOjbect, desc, title\n+    }\n+\n+    boolean inListItemScope(String targetName) {\n+        return inScope(targetName, new String[]{\"ol\", \"ul\"});\n+    }\n+\n+    boolean inButtonScope(String targetName) {\n+        return inScope(targetName, new String[]{\"button\"});\n+    }\n+\n+    boolean inTableScope(String targetName) {\n+        return inSpecificScope(targetName, new String[]{\"html\", \"table\"}, null);\n+    }\n+\n+    boolean inSelectScope(String targetName) {\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element el = it.next();\n+            String elName = el.nodeName();\n+            if (elName.equals(targetName))\n+                return true;\n+            if (!StringUtil.in(elName, \"optgroup\", \"option\")) // all elements except\n+                return false;\n+        }\n+        Validate.fail(\"Should not be reachable\");\n+        return false;\n+    }\n+\n+    void setHeadElement(Element headElement) {\n+        this.headElement = headElement;\n+    }\n+\n+    Element getHeadElement() {\n+        return headElement;\n+    }\n+\n+    boolean isFosterInserts() {\n+        return fosterInserts;\n+    }\n+\n+    void setFosterInserts(boolean fosterInserts) {\n+        this.fosterInserts = fosterInserts;\n+    }\n+\n+    Element getFormElement() {\n+        return formElement;\n+    }\n+\n+    void setFormElement(Element formElement) {\n+        this.formElement = formElement;\n+    }\n+\n+    void newPendingTableCharacters() {\n+        pendingTableCharacters = new ArrayList<Token.Character>();\n+    }\n+\n+    List<Token.Character> getPendingTableCharacters() {\n+        return pendingTableCharacters;\n+    }\n+\n+    void setPendingTableCharacters(List<Token.Character> pendingTableCharacters) {\n+        this.pendingTableCharacters = pendingTableCharacters;\n+    }\n+\n+    /**\n+     11.2.5.2 Closing elements that have implied end tags<p/>\n+     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n+     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n+     the UA must pop the current node off the stack of open elements.\n+\n+     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n+     process, then the UA must perform the above steps as if that element was not in the above list.\n+     */\n+    void generateImpliedEndTags(String excludeTag) {\n+        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n+                StringUtil.in(currentElement().nodeName(), \"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"))\n+            pop();\n+    }\n+\n+    void generateImpliedEndTags() {\n+        generateImpliedEndTags(null);\n+    }\n+\n+    boolean isSpecial(Element el) {\n+        // todo: mathml's mi, mo, mn\n+        // todo: svg's foreigObject, desc, title\n+        String name = el.nodeName();\n+        return StringUtil.in(name, \"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n+                \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n+                \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n+                \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n+                \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n+                \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n+                \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n+                \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\");\n+    }\n+\n+    // active formatting elements\n+    void pushActiveFormattingElements(Element in) {\n+        int numSeen = 0;\n+        Iterator<Element> iter = formattingElements.descendingIterator();\n+        while (iter.hasNext()) {\n+            Element el =  iter.next();\n+            if (el == null) // marker\n+                break;\n+\n+            if (isSameFormattingElement(in, el))\n+                numSeen++;\n+\n+            if (numSeen == 3) {\n+                iter.remove();\n+                break;\n+            }\n+        }\n+        formattingElements.add(in);\n+    }\n+\n+    private boolean isSameFormattingElement(Element a, Element b) {\n+        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n+        return a.nodeName().equals(b.nodeName()) &&\n+                // a.namespace().equals(b.namespace()) &&\n+                a.attributes().equals(b.attributes());\n+        // todo: namespaces\n+    }\n+\n+    void reconstructFormattingElements() {\n+        int size = formattingElements.size();\n+        if (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\n+            return;\n+\n+        Element entry = formattingElements.getLast();\n+        int pos = size - 1;\n+        boolean skip = false;\n+        while (true) {\n+            if (pos == 0) { // step 4. if none before, skip to 8\n+                skip = true;\n+                break;\n+            }\n+            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n+            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n+                break; // jump to 8, else continue back to 4\n+        }\n+        while(true) {\n+            if (!skip) // step 7: on later than entry\n+                entry = formattingElements.get(++pos);\n+            Validate.notNull(entry); // should not occur, as we break at last element\n+\n+            // 8. create new element from element, 9 insert into current node, onto stack\n+            skip = false; // can only skip increment from 4.\n+            Element newEl = insert(entry.nodeName()); // todo: avoid fostering here?\n+            // newEl.namespace(entry.namespace()); // todo: namespaces\n+            newEl.attributes().addAll(entry.attributes());\n+\n+            // 10. replace entry with new entry\n+            formattingElements.add(pos, newEl);\n+            formattingElements.remove(pos + 1);\n+\n+            // 11\n+            if (pos == size-1) // if not last entry in list, jump to 7\n+                break;\n+        }\n+    }\n+\n+    void clearFormattingElementsToLastMarker() {\n+        while (!formattingElements.isEmpty()) {\n+            Element el = formattingElements.peekLast();\n+            formattingElements.removeLast();\n+            if (el == null)\n+                break;\n+        }\n+    }\n+\n+    void removeFromActiveFormattingElements(Element el) {\n+        Iterator<Element> it = formattingElements.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == el) {\n+                it.remove();\n+                break;\n+            }\n+        }\n+    }\n+\n+    boolean isInActiveFormattingElements(Element el) {\n+        return isElementInQueue(formattingElements, el);\n+    }\n+\n+    Element getActiveFormattingElement(String nodeName) {\n+        Iterator<Element> it = formattingElements.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == null) // scope marker\n+                break;\n+            else if (next.nodeName().equals(nodeName))\n+                return next;\n+        }\n+        return null;\n+    }\n+\n+    void replaceActiveFormattingElement(Element out, Element in) {\n+        replaceInQueue(formattingElements, out, in);\n+    }\n+\n+    void insertMarkerToFormattingElements() {\n+        formattingElements.add(null);\n+    }\n+\n+    void insertInFosterParent(Node in) {\n+        Element fosterParent = null;\n+        Element lastTable = getFromStack(\"table\");\n+        boolean isLastTableParent = false;\n+        if (lastTable != null) {\n+            if (lastTable.parent() != null) {\n+                fosterParent = lastTable.parent();\n+                isLastTableParent = true;\n+            } else\n+                fosterParent = aboveOnStack(lastTable);\n+        } else { // no table == frag\n+            fosterParent = stack.get(0);\n+        }\n+\n+        if (isLastTableParent) {\n+            Validate.notNull(lastTable); // last table cannot be null by this point.\n+            lastTable.before(in);\n+        }\n+        else\n+            fosterParent.appendChild(in);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"TreeBuilder{\" +\n+                \"currentToken=\" + currentToken +\n+                \", state=\" + state +\n+                \", currentElement=\" + currentElement() +\n+                '}';\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilderState.java\n+package org.jsoup.parser;\n+\n+import org.jsoup.helper.DescendableLinkedList;\n+import org.jsoup.helper.StringUtil;\n+import org.jsoup.nodes.*;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+\n+/**\n+ * The Tree Builder's current state. Each state embodies the processing for the state, and transitions to other states.\n+ */\n+enum HtmlTreeBuilderState {\n+    Initial {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                return true; // ignore whitespace\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype()) {\n+                // todo: parse error check on expected doctypes\n+                // todo: quirk state check on doctype ids\n+                Token.Doctype d = t.asDoctype();\n+                DocumentType doctype = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\n+                tb.getDocument().appendChild(doctype);\n+                if (d.isForceQuirks())\n+                    tb.getDocument().quirksMode(Document.QuirksMode.quirks);\n+                tb.transition(BeforeHtml);\n+            } else {\n+                // todo: check not iframe srcdoc\n+                tb.transition(BeforeHtml);\n+                return tb.process(t); // re-process token\n+            }\n+            return true;\n+        }\n+    },\n+    BeforeHtml {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (t.isDoctype()) {\n+                tb.error(this);\n+                return false;\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (isWhitespace(t)) {\n+                return true; // ignore whitespace\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+                tb.insert(t.asStartTag());\n+                tb.transition(BeforeHead);\n+            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\n+                return anythingElse(t, tb);\n+            } else if (t.isEndTag()) {\n+                tb.error(this);\n+                return false;\n+            } else {\n+                return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n+            tb.insert(\"html\");\n+            tb.transition(BeforeHead);\n+            return tb.process(t);\n+        }\n+    },\n+    BeforeHead {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                return true;\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype()) {\n+                tb.error(this);\n+                return false;\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+                return InBody.process(t, tb); // does not transition\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"head\")) {\n+                Element head = tb.insert(t.asStartTag());\n+                tb.setHeadElement(head);\n+                tb.transition(InHead);\n+            } else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\n+                tb.process(new Token.StartTag(\"head\"));\n+                return tb.process(t);\n+            } else if (t.isEndTag()) {\n+                tb.error(this);\n+                return false;\n+            } else {\n+                tb.process(new Token.StartTag(\"head\"));\n+                return tb.process(t);\n+            }\n+            return true;\n+        }\n+    },\n+    InHead {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                tb.insert(t.asCharacter());\n+                return true;\n+            }\n+            switch (t.type) {\n+                case Comment:\n+                    tb.insert(t.asComment());\n+                    break;\n+                case Doctype:\n+                    tb.error(this);\n+                    return false;\n+                case StartTag:\n+                    Token.StartTag start = t.asStartTag();\n+                    String name = start.name();\n+                    if (name.equals(\"html\")) {\n+                        return InBody.process(t, tb);\n+                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\n+                        Element el = tb.insertEmpty(start);\n+                        // jsoup special: update base the frist time it is seen\n+                        if (name.equals(\"base\") && el.hasAttr(\"href\"))\n+                            tb.maybeSetBaseUri(el);\n+                    } else if (name.equals(\"meta\")) {\n+                        Element meta = tb.insertEmpty(start);\n+                        // todo: charset switches\n+                    } else if (name.equals(\"title\")) {\n+                        handleRcData(start, tb);\n+                    } else if (StringUtil.in(name, \"noframes\", \"style\")) {\n+                        handleRawtext(start, tb);\n+                    } else if (name.equals(\"noscript\")) {\n+                        // else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)\n+                        tb.insert(start);\n+                        tb.transition(InHeadNoscript);\n+                    } else if (name.equals(\"script\")) {\n+                        // skips some script rules as won't execute them\n+                        tb.insert(start);\n+                        tb.tokeniser.transition(TokeniserState.ScriptData);\n+                        tb.markInsertionMode();\n+                        tb.transition(Text);\n+                    } else if (name.equals(\"head\")) {\n+                        tb.error(this);\n+                        return false;\n+                    } else {\n+                        return anythingElse(t, tb);\n+                    }\n+                    break;\n+                case EndTag:\n+                    Token.EndTag end = t.asEndTag();\n+                    name = end.name();\n+                    if (name.equals(\"head\")) {\n+                        tb.pop();\n+                        tb.transition(AfterHead);\n+                    } else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\n+                        return anythingElse(t, tb);\n+                    } else {\n+                        tb.error(this);\n+                        return false;\n+                    }\n+                    break;\n+                default:\n+                    return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, TreeBuilder tb) {\n+            tb.process(new Token.EndTag(\"head\"));\n+            return tb.process(t);\n+        }\n+    },\n+    InHeadNoscript {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (t.isDoctype()) {\n+                tb.error(this);\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+                return tb.process(t, InBody);\n+            } else if (t.isEndTag() && t.asEndTag().name().equals(\"noscript\")) {\n+                tb.pop();\n+                tb.transition(InHead);\n+            } else if (isWhitespace(t) || t.isComment() || (t.isStartTag() && StringUtil.in(t.asStartTag().name(),\n+                    \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"style\"))) {\n+                return tb.process(t, InHead);\n+            } else if (t.isEndTag() && t.asEndTag().name().equals(\"br\")) {\n+                return anythingElse(t, tb);\n+            } else if ((t.isStartTag() && StringUtil.in(t.asStartTag().name(), \"head\", \"noscript\")) || t.isEndTag()) {\n+                tb.error(this);\n+                return false;\n+            } else {\n+                return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n+            tb.error(this);\n+            tb.process(new Token.EndTag(\"noscript\"));\n+            return tb.process(t);\n+        }\n+    },\n+    AfterHead {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                tb.insert(t.asCharacter());\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype()) {\n+                tb.error(this);\n+            } else if (t.isStartTag()) {\n+                Token.StartTag startTag = t.asStartTag();\n+                String name = startTag.name();\n+                if (name.equals(\"html\")) {\n+                    return tb.process(t, InBody);\n+                } else if (name.equals(\"body\")) {\n+                    tb.insert(startTag);\n+                    tb.framesetOk(false);\n+                    tb.transition(InBody);\n+                } else if (name.equals(\"frameset\")) {\n+                    tb.insert(startTag);\n+                    tb.transition(InFrameset);\n+                } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n+                    tb.error(this);\n+                    Element head = tb.getHeadElement();\n+                    tb.push(head);\n+                    tb.process(t, InHead);\n+                    tb.removeFromStack(head);\n+                } else if (name.equals(\"head\")) {\n+                    tb.error(this);\n+                    return false;\n+                } else {\n+                    anythingElse(t, tb);\n+                }\n+            } else if (t.isEndTag()) {\n+                if (StringUtil.in(t.asEndTag().name(), \"body\", \"html\")) {\n+                    anythingElse(t, tb);\n+                } else {\n+                    tb.error(this);\n+                    return false;\n+                }\n+            } else {\n+                anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n+            tb.process(new Token.StartTag(\"body\"));\n+            tb.framesetOk(true);\n+            return tb.process(t);\n+        }\n+    },\n+    InBody {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            switch (t.type) {\n+                case Character: {\n+                    Token.Character c = t.asCharacter();\n+                    if (c.getData().equals(nullString)) {\n+                        // todo confirm that check\n+                        tb.error(this);\n+                        return false;\n+                    } else if (isWhitespace(c)) {\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(c);\n+                    } else {\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(c);\n+                        tb.framesetOk(false);\n+                    }\n+                    break;\n+                }\n+                case Comment: {\n+                    tb.insert(t.asComment());\n+                    break;\n+                }\n+                case Doctype: {\n+                    tb.error(this);\n+                    return false;\n+                }\n+                case StartTag:\n+                    Token.StartTag startTag = t.asStartTag();\n+                    String name = startTag.name();\n+                    if (name.equals(\"html\")) {\n+                        tb.error(this);\n+                        // merge attributes onto real html\n+                        Element html = tb.getStack().getFirst();\n+                        for (Attribute attribute : startTag.getAttributes()) {\n+                            if (!html.hasAttr(attribute.getKey()))\n+                                html.attributes().put(attribute);\n+                        }\n+                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\n+                        return tb.process(t, InHead);\n+                    } else if (name.equals(\"body\")) {\n+                        tb.error(this);\n+                        LinkedList<Element> stack = tb.getStack();\n+                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n+                            // only in fragment case\n+                            return false; // ignore\n+                        } else {\n+                            tb.framesetOk(false);\n+                            Element body = stack.get(1);\n+                            for (Attribute attribute : startTag.getAttributes()) {\n+                                if (!body.hasAttr(attribute.getKey()))\n+                                    body.attributes().put(attribute);\n+                            }\n+                        }\n+                    } else if (name.equals(\"frameset\")) {\n+                        tb.error(this);\n+                        LinkedList<Element> stack = tb.getStack();\n+                        if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n+                            // only in fragment case\n+                            return false; // ignore\n+                        } else if (!tb.framesetOk()) {\n+                            return false; // ignore frameset\n+                        } else {\n+                            Element second = stack.get(1);\n+                            if (second.parent() != null)\n+                                second.remove();\n+                            // pop up to html element\n+                            while (stack.size() > 1)\n+                                stack.removeLast();\n+                            tb.insert(startTag);\n+                            tb.transition(InFrameset);\n+                        }\n+                    } else if (StringUtil.in(name,\n+                            \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\",\n+                            \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\",\n+                            \"p\", \"section\", \"summary\", \"ul\")) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insert(startTag);\n+                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n+                            tb.error(this);\n+                            tb.pop();\n+                        }\n+                        tb.insert(startTag);\n+                    } else if (StringUtil.in(name, \"pre\", \"listing\")) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insert(startTag);\n+                        // todo: ignore LF if next token\n+                        tb.framesetOk(false);\n+                    } else if (name.equals(\"form\")) {\n+                        if (tb.getFormElement() != null) {\n+                            tb.error(this);\n+                            return false;\n+                        }\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        Element form = tb.insert(startTag);\n+                        tb.setFormElement(form);\n+                    } else if (name.equals(\"li\")) {\n+                        tb.framesetOk(false);\n+                        LinkedList<Element> stack = tb.getStack();\n+                        for (int i = stack.size() - 1; i > 0; i--) {\n+                            Element el = stack.get(i);\n+                            if (el.nodeName().equals(\"li\")) {\n+                                tb.process(new Token.EndTag(\"li\"));\n+                                break;\n+                            }\n+                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n+                                break;\n+                        }\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insert(startTag);\n+                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n+                        tb.framesetOk(false);\n+                        LinkedList<Element> stack = tb.getStack();\n+                        for (int i = stack.size() - 1; i > 0; i--) {\n+                            Element el = stack.get(i);\n+                            if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) {\n+                                tb.process(new Token.EndTag(el.nodeName()));\n+                                break;\n+                            }\n+                            if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\"))\n+                                break;\n+                        }\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insert(startTag);\n+                    } else if (name.equals(\"plaintext\")) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insert(startTag);\n+                        tb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n+                    } else if (name.equals(\"button\")) {\n+                        if (tb.inButtonScope(\"button\")) {\n+                            // close and reprocess\n+                            tb.error(this);\n+                            tb.process(new Token.EndTag(\"button\"));\n+                            tb.process(startTag);\n+                        } else {\n+                            tb.reconstructFormattingElements();\n+                            tb.insert(startTag);\n+                            tb.framesetOk(false);\n+                        }\n+                    } else if (name.equals(\"a\")) {\n+                        if (tb.getActiveFormattingElement(\"a\") != null) {\n+                            tb.error(this);\n+                            tb.process(new Token.EndTag(\"a\"));\n+\n+                            // still on stack?\n+                            Element remainingA = tb.getFromStack(\"a\");\n+                            if (remainingA != null) {\n+                                tb.removeFromActiveFormattingElements(remainingA);\n+                                tb.removeFromStack(remainingA);\n+                            }\n+                        }\n+                        tb.reconstructFormattingElements();\n+                        Element a = tb.insert(startTag);\n+                        tb.pushActiveFormattingElements(a);\n+                    } else if (StringUtil.in(name,\n+                            \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n+                        tb.reconstructFormattingElements();\n+                        Element el = tb.insert(startTag);\n+                        tb.pushActiveFormattingElements(el);\n+                    } else if (name.equals(\"nobr\")) {\n+                        tb.reconstructFormattingElements();\n+                        if (tb.inScope(\"nobr\")) {\n+                            tb.error(this);\n+                            tb.process(new Token.EndTag(\"nobr\"));\n+                            tb.reconstructFormattingElements();\n+                        }\n+                        Element el = tb.insert(startTag);\n+                        tb.pushActiveFormattingElements(el);\n+                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(startTag);\n+                        tb.insertMarkerToFormattingElements();\n+                        tb.framesetOk(false);\n+                    } else if (name.equals(\"table\")) {\n+                        if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insert(startTag);\n+                        tb.framesetOk(false);\n+                        tb.transition(InTable);\n+                    } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) {\n+                        tb.reconstructFormattingElements();\n+                        tb.insertEmpty(startTag);\n+                        tb.framesetOk(false);\n+                    } else if (name.equals(\"input\")) {\n+                        tb.reconstructFormattingElements();\n+                        Element el = tb.insertEmpty(startTag);\n+                        if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\n+                            tb.framesetOk(false);\n+                    } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) {\n+                        tb.insertEmpty(startTag);\n+                    } else if (name.equals(\"hr\")) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.insertEmpty(startTag);\n+                        tb.framesetOk(false);\n+                    } else if (name.equals(\"image\")) {\n+                        // we're not supposed to ask.\n+                        startTag.name(\"img\");\n+                        return tb.process(startTag);\n+                    } else if (name.equals(\"isindex\")) {\n+                        // how much do we care about the early 90s?\n+                        tb.error(this);\n+                        if (tb.getFormElement() != null)\n+                            return false;\n+\n+                        tb.tokeniser.acknowledgeSelfClosingFlag();\n+                        tb.process(new Token.StartTag(\"form\"));\n+                        if (startTag.attributes.hasKey(\"action\")) {\n+                            Element form = tb.getFormElement();\n+                            form.attr(\"action\", startTag.attributes.get(\"action\"));\n+                        }\n+                        tb.process(new Token.StartTag(\"hr\"));\n+                        tb.process(new Token.StartTag(\"label\"));\n+                        // hope you like english.\n+                        String prompt = startTag.attributes.hasKey(\"prompt\") ?\n+                                startTag.attributes.get(\"prompt\") :\n+                                \"This is a searchable index. Enter search keywords: \";\n+\n+                        tb.process(new Token.Character(prompt));\n+\n+                        // input\n+                        Attributes inputAttribs = new Attributes();\n+                        for (Attribute attr : startTag.attributes) {\n+                            if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\"))\n+                                inputAttribs.put(attr);\n+                        }\n+                        inputAttribs.put(\"name\", \"isindex\");\n+                        tb.process(new Token.StartTag(\"input\", inputAttribs));\n+                        tb.process(new Token.EndTag(\"label\"));\n+                        tb.process(new Token.StartTag(\"hr\"));\n+                        tb.process(new Token.EndTag(\"form\"));\n+                    } else if (name.equals(\"textarea\")) {\n+                        tb.insert(startTag);\n+                        // todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n+                        tb.tokeniser.transition(TokeniserState.Rcdata);\n+                        tb.markInsertionMode();\n+                        tb.framesetOk(false);\n+                        tb.transition(Text);\n+                    } else if (name.equals(\"xmp\")) {\n+                        if (tb.inButtonScope(\"p\")) {\n+                            tb.process(new Token.EndTag(\"p\"));\n+                        }\n+                        tb.reconstructFormattingElements();\n+                        tb.framesetOk(false);\n+                        handleRawtext(startTag, tb);\n+                    } else if (name.equals(\"iframe\")) {\n+                        tb.framesetOk(false);\n+                        handleRawtext(startTag, tb);\n+                    } else if (name.equals(\"noembed\")) {\n+                        // also handle noscript if script enabled\n+                        handleRawtext(startTag, tb);\n+                    } else if (name.equals(\"select\")) {\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(startTag);\n+                        tb.framesetOk(false);\n+\n+                        HtmlTreeBuilderState state = tb.state();\n+                        if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\n+                            tb.transition(InSelectInTable);\n+                        else\n+                            tb.transition(InSelect);\n+                    } else if (StringUtil.in(\"optgroup\", \"option\")) {\n+                        if (tb.currentElement().nodeName().equals(\"option\"))\n+                            tb.process(new Token.EndTag(\"option\"));\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(startTag);\n+                    } else if (StringUtil.in(\"rp\", \"rt\")) {\n+                        if (tb.inScope(\"ruby\")) {\n+                            tb.generateImpliedEndTags();\n+                            if (!tb.currentElement().nodeName().equals(\"ruby\")) {\n+                                tb.error(this);\n+                                tb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n+                            }\n+                            tb.insert(startTag);\n+                        }\n+                    } else if (name.equals(\"math\")) {\n+                        tb.reconstructFormattingElements();\n+                        // todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\n+                        tb.insert(startTag);\n+                        tb.tokeniser.acknowledgeSelfClosingFlag();\n+                    } else if (name.equals(\"svg\")) {\n+                        tb.reconstructFormattingElements();\n+                        // todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\n+                        tb.insert(startTag);\n+                        tb.tokeniser.acknowledgeSelfClosingFlag();\n+                    } else if (StringUtil.in(name,\n+                            \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n+                        tb.error(this);\n+                        return false;\n+                    } else {\n+                        tb.reconstructFormattingElements();\n+                        tb.insert(startTag);\n+                    }\n+                    break;\n+\n+                case EndTag:\n+                    Token.EndTag endTag = t.asEndTag();\n+                    name = endTag.name();\n+                    if (name.equals(\"body\")) {\n+                        if (!tb.inScope(\"body\")) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            // todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\n+                            tb.transition(AfterBody);\n+                        }\n+                    } else if (name.equals(\"html\")) {\n+                        boolean notIgnored = tb.process(new Token.EndTag(\"body\"));\n+                        if (notIgnored)\n+                            return tb.process(endTag);\n+                    } else if (StringUtil.in(name,\n+                            \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\",\n+                            \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\",\n+                            \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) {\n+                        // todo: refactor these lookups\n+                        if (!tb.inScope(name)) {\n+                            // nothing to close\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags();\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (name.equals(\"form\")) {\n+                        Element currentForm = tb.getFormElement();\n+                        tb.setFormElement(null);\n+                        if (currentForm == null || !tb.inScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags();\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            // remove currentForm from stack. will shift anything under up.\n+                            tb.removeFromStack(currentForm);\n+                        }\n+                    } else if (name.equals(\"p\")) {\n+                        if (!tb.inButtonScope(name)) {\n+                            tb.error(this);\n+                            tb.process(new Token.StartTag(name)); // if no p to close, creates an empty <p></p>\n+                            return tb.process(endTag);\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (name.equals(\"li\")) {\n+                        if (!tb.inListItemScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (StringUtil.in(name, \"dd\", \"dt\")) {\n+                        if (!tb.inScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                        }\n+                    } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) {\n+                        if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.generateImpliedEndTags(name);\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\");\n+                        }\n+                    } else if (name.equals(\"sarcasm\")) {\n+                        // *sigh*\n+                        return anyOtherEndTag(t, tb);\n+                    } else if (StringUtil.in(name,\n+                            \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) {\n+                        // Adoption Agency Algorithm.\n+                        OUTER:\n+                        for (int i = 0; i < 8; i++) {\n+                            Element formatEl = tb.getActiveFormattingElement(name);\n+                            if (formatEl == null)\n+                                return anyOtherEndTag(t, tb);\n+                            else if (!tb.onStack(formatEl)) {\n+                                tb.error(this);\n+                                tb.removeFromActiveFormattingElements(formatEl);\n+                                return true;\n+                            } else if (!tb.inScope(formatEl.nodeName())) {\n+                                tb.error(this);\n+                                return false;\n+                            } else if (tb.currentElement() != formatEl)\n+                                tb.error(this);\n+\n+                            Element furthestBlock = null;\n+                            Element commonAncestor = null;\n+                            boolean seenFormattingElement = false;\n+                            LinkedList<Element> stack = tb.getStack();\n+                            for (int si = 0; si < stack.size(); si++) {\n+                                Element el = stack.get(si);\n+                                if (el == formatEl) {\n+                                    commonAncestor = stack.get(si - 1);\n+                                    seenFormattingElement = true;\n+                                } else if (seenFormattingElement && tb.isSpecial(el)) {\n+                                    furthestBlock = el;\n+                                    break;\n+                                }\n+                            }\n+                            if (furthestBlock == null) {\n+                                tb.popStackToClose(formatEl.nodeName());\n+                                tb.removeFromActiveFormattingElements(formatEl);\n+                                return true;\n+                            }\n+\n+                            // todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n+                            // does that mean: int pos of format el in list?\n+                            Element node = furthestBlock;\n+                            Element lastNode = furthestBlock;\n+                            INNER:\n+                            for (int j = 0; j < 3; j++) {\n+                                if (tb.onStack(node))\n+                                    node = tb.aboveOnStack(node);\n+                                if (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\n+                                    tb.removeFromStack(node);\n+                                    continue INNER;\n+                                } else if (node == formatEl)\n+                                    break INNER;\n+\n+                                Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\n+                                tb.replaceActiveFormattingElement(node, replacement);\n+                                tb.replaceOnStack(node, replacement);\n+                                node = replacement;\n+\n+                                if (lastNode == furthestBlock) {\n+                                    // todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n+                                    // not getting how this bookmark both straddles the element above, but is inbetween here...\n+                                }\n+                                if (lastNode.parent() != null)\n+                                    lastNode.remove();\n+                                node.appendChild(lastNode);\n+\n+                                lastNode = node;\n+                            }\n+\n+                            if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n+                                if (lastNode.parent() != null)\n+                                    lastNode.remove();\n+                                tb.insertInFosterParent(lastNode);\n+                            } else {\n+                                if (lastNode.parent() != null)\n+                                    lastNode.remove();\n+                                commonAncestor.appendChild(lastNode);\n+                            }\n+\n+                            Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri());\n+                            Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]);\n+                            for (Node childNode : childNodes) {\n+                                adopter.appendChild(childNode); // append will reparent. thus the clone to avvoid concurrent mod.\n+                            }\n+                            furthestBlock.appendChild(adopter);\n+                            tb.removeFromActiveFormattingElements(formatEl);\n+                            // todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\n+                            tb.removeFromStack(formatEl);\n+                            tb.insertOnStackAfter(furthestBlock, adopter);\n+                        }\n+                    } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) {\n+                        if (!tb.inScope(\"name\")) {\n+                            if (!tb.inScope(name)) {\n+                                tb.error(this);\n+                                return false;\n+                            }\n+                            tb.generateImpliedEndTags();\n+                            if (!tb.currentElement().nodeName().equals(name))\n+                                tb.error(this);\n+                            tb.popStackToClose(name);\n+                            tb.clearFormattingElementsToLastMarker();\n+                        }\n+                    } else if (name.equals(\"br\")) {\n+                        tb.error(this);\n+                        tb.process(new Token.StartTag(\"br\"));\n+                        return false;\n+                    } else {\n+                        return anyOtherEndTag(t, tb);\n+                    }\n+\n+                    break;\n+                case EOF:\n+                    // todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n+                    // stop parsing\n+                    break;\n+            }\n+            return true;\n+        }\n+\n+        boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\n+            String name = t.asEndTag().name();\n+            DescendableLinkedList<Element> stack = tb.getStack();\n+            Iterator<Element> it = stack.descendingIterator();\n+            while (it.hasNext()) {\n+                Element node = it.next();\n+                if (node.nodeName().equals(name)) {\n+                    tb.generateImpliedEndTags(name);\n+                    if (!name.equals(tb.currentElement().nodeName()))\n+                        tb.error(this);\n+                    tb.popStackToClose(name);\n+                    break;\n+                } else {\n+                    if (tb.isSpecial(node)) {\n+                        tb.error(this);\n+                        return false;\n+                    }\n+                }\n+            }\n+            return true;\n+        }\n+    },\n+    Text {\n+        // in script, style etc. normally treated as data tags\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (t.isCharacter()) {\n+                tb.insert(t.asCharacter());\n+            } else if (t.isEOF()) {\n+                tb.error(this);\n+                // if current node is script: already started\n+                tb.pop();\n+                tb.transition(tb.originalState());\n+                return tb.process(t);\n+            } else if (t.isEndTag()) {\n+                // if: An end tag whose tag name is \"script\" -- scripting nesting level, if evaluating scripts\n+                tb.pop();\n+                tb.transition(tb.originalState());\n+            }\n+            return true;\n+        }\n+    },\n+    InTable {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (t.isCharacter()) {\n+                tb.newPendingTableCharacters();\n+                tb.markInsertionMode();\n+                tb.transition(InTableText);\n+                return tb.process(t);\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+                return true;\n+            } else if (t.isDoctype()) {\n+                tb.error(this);\n+                return false;\n+            } else if (t.isStartTag()) {\n+                Token.StartTag startTag = t.asStartTag();\n+                String name = startTag.name();\n+                if (name.equals(\"caption\")) {\n+                    tb.clearStackToTableContext();\n+                    tb.insertMarkerToFormattingElements();\n+                    tb.insert(startTag);\n+                    tb.transition(InCaption);\n+                } else if (name.equals(\"colgroup\")) {\n+                    tb.clearStackToTableContext();\n+                    tb.insert(startTag);\n+                    tb.transition(InColumnGroup);\n+                } else if (name.equals(\"col\")) {\n+                    tb.process(new Token.StartTag(\"colgroup\"));\n+                    return tb.process(t);\n+                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n+                    tb.clearStackToTableContext();\n+                    tb.insert(startTag);\n+                    tb.transition(InTableBody);\n+                } else if (StringUtil.in(name, \"td\", \"th\", \"tr\")) {\n+                    tb.process(new Token.StartTag(\"tbody\"));\n+                    return tb.process(t);\n+                } else if (name.equals(\"table\")) {\n+                    tb.error(this);\n+                    boolean processed = tb.process(new Token.EndTag(\"table\"));\n+                    if (processed) // only ignored if in fragment\n+                        return tb.process(t);\n+                } else if (StringUtil.in(name, \"style\", \"script\")) {\n+                    return tb.process(t, InHead);\n+                } else if (name.equals(\"input\")) {\n+                    if (!startTag.attributes.get(\"type\").equalsIgnoreCase(\"hidden\")) {\n+                        return anythingElse(t, tb);\n+                    } else {\n+                        tb.insertEmpty(startTag);\n+                    }\n+                } else if (name.equals(\"form\")) {\n+                    tb.error(this);\n+                    if (tb.getFormElement() != null)\n+                        return false;\n+                    else {\n+                        Element form = tb.insertEmpty(startTag);\n+                        tb.setFormElement(form);\n+                    }\n+                } else {\n+                    return anythingElse(t, tb);\n+                }\n+            } else if (t.isEndTag()) {\n+                Token.EndTag endTag = t.asEndTag();\n+                String name = endTag.name();\n+\n+                if (name.equals(\"table\")) {\n+                    if (!tb.inTableScope(name)) {\n+                        tb.error(this);\n+                        return false;\n+                    } else {\n+                        tb.popStackToClose(\"table\");\n+                    }\n+                    tb.resetInsertionMode();\n+                } else if (StringUtil.in(name,\n+                        \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n+                    tb.error(this);\n+                    return false;\n+                } else {\n+                    return anythingElse(t, tb);\n+                }\n+            } else if (t.isEOF()) {\n+                if (tb.currentElement().nodeName().equals(\"html\"))\n+                    tb.error(this);\n+                return true; // stops parsing\n+            }\n+            return anythingElse(t, tb);\n+        }\n+\n+        boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n+            tb.error(this);\n+            boolean processed = true;\n+            if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n+                tb.setFosterInserts(true);\n+                processed = tb.process(t, InBody);\n+                tb.setFosterInserts(false);\n+            } else {\n+                processed = tb.process(t, InBody);\n+            }\n+            return processed;\n+        }\n+    },\n+    InTableText {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            switch (t.type) {\n+                case Character:\n+                    Token.Character c = t.asCharacter();\n+                    if (c.getData().equals(nullString)) {\n+                        tb.error(this);\n+                        return false;\n+                    } else {\n+                        tb.getPendingTableCharacters().add(c);\n+                    }\n+                    break;\n+                default:\n+                    if (tb.getPendingTableCharacters().size() > 0) {\n+                        for (Token.Character character : tb.getPendingTableCharacters()) {\n+                            if (!isWhitespace(character)) {\n+                                // InTable anything else section:\n+                                tb.error(this);\n+                                if (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n+                                    tb.setFosterInserts(true);\n+                                    tb.process(character, InBody);\n+                                    tb.setFosterInserts(false);\n+                                } else {\n+                                    tb.process(character, InBody);\n+                                }\n+                            } else\n+                                tb.insert(character);\n+                        }\n+                        tb.newPendingTableCharacters();\n+                    }\n+                    tb.transition(tb.originalState());\n+                    return tb.process(t);\n+            }\n+            return true;\n+        }\n+    },\n+    InCaption {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (t.isEndTag() && t.asEndTag().name().equals(\"caption\")) {\n+                Token.EndTag endTag = t.asEndTag();\n+                String name = endTag.name();\n+                if (!tb.inTableScope(name)) {\n+                    tb.error(this);\n+                    return false;\n+                } else {\n+                    tb.generateImpliedEndTags();\n+                    if (!tb.currentElement().nodeName().equals(\"caption\"))\n+                        tb.error(this);\n+                    tb.popStackToClose(\"caption\");\n+                    tb.clearFormattingElementsToLastMarker();\n+                    tb.transition(InTable);\n+                }\n+            } else if ((\n+                    t.isStartTag() && StringUtil.in(t.asStartTag().name(),\n+                            \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\") ||\n+                            t.isEndTag() && t.asEndTag().name().equals(\"table\"))\n+                    ) {\n+                tb.error(this);\n+                boolean processed = tb.process(new Token.EndTag(\"caption\"));\n+                if (processed)\n+                    return tb.process(t);\n+            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(),\n+                    \"body\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n+                tb.error(this);\n+                return false;\n+            } else {\n+                return tb.process(t, InBody);\n+            }\n+            return true;\n+        }\n+    },\n+    InColumnGroup {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                tb.insert(t.asCharacter());\n+                return true;\n+            }\n+            switch (t.type) {\n+                case Comment:\n+                    tb.insert(t.asComment());\n+                    break;\n+                case Doctype:\n+                    tb.error(this);\n+                    break;\n+                case StartTag:\n+                    Token.StartTag startTag = t.asStartTag();\n+                    String name = startTag.name();\n+                    if (name.equals(\"html\"))\n+                        return tb.process(t, InBody);\n+                    else if (name.equals(\"col\"))\n+                        tb.insertEmpty(startTag);\n+                    else\n+                        return anythingElse(t, tb);\n+                    break;\n+                case EndTag:\n+                    Token.EndTag endTag = t.asEndTag();\n+                    name = endTag.name();\n+                    if (name.equals(\"colgroup\")) {\n+                        if (tb.currentElement().nodeName().equals(\"html\")) { // frag case\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.pop();\n+                            tb.transition(InTable);\n+                        }\n+                    } else\n+                        return anythingElse(t, tb);\n+                    break;\n+                case EOF:\n+                    if (tb.currentElement().nodeName().equals(\"html\"))\n+                        return true; // stop parsing; frag case\n+                    else\n+                        return anythingElse(t, tb);\n+                default:\n+                    return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, TreeBuilder tb) {\n+            boolean processed = tb.process(new Token.EndTag(\"colgroup\"));\n+            if (processed) // only ignored in frag case\n+                return tb.process(t);\n+            return true;\n+        }\n+    },\n+    InTableBody {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            switch (t.type) {\n+                case StartTag:\n+                    Token.StartTag startTag = t.asStartTag();\n+                    String name = startTag.name();\n+                    if (name.equals(\"tr\")) {\n+                        tb.clearStackToTableBodyContext();\n+                        tb.insert(startTag);\n+                        tb.transition(InRow);\n+                    } else if (StringUtil.in(name, \"th\", \"td\")) {\n+                        tb.error(this);\n+                        tb.process(new Token.StartTag(\"tr\"));\n+                        return tb.process(startTag);\n+                    } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\n+                        return exitTableBody(t, tb);\n+                    } else\n+                        return anythingElse(t, tb);\n+                    break;\n+                case EndTag:\n+                    Token.EndTag endTag = t.asEndTag();\n+                    name = endTag.name();\n+                    if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n+                        if (!tb.inTableScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.clearStackToTableBodyContext();\n+                            tb.pop();\n+                            tb.transition(InTable);\n+                        }\n+                    } else if (name.equals(\"table\")) {\n+                        return exitTableBody(t, tb);\n+                    } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\")) {\n+                        tb.error(this);\n+                        return false;\n+                    } else\n+                        return anythingElse(t, tb);\n+                    break;\n+                default:\n+                    return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {\n+            if (!(tb.inTableScope(\"tbody\") || tb.inTableScope(\"thead\") || tb.inScope(\"tfoot\"))) {\n+                // frag case\n+                tb.error(this);\n+                return false;\n+            }\n+            tb.clearStackToTableBodyContext();\n+            tb.process(new Token.EndTag(tb.currentElement().nodeName())); // tbody, tfoot, thead\n+            return tb.process(t);\n+        }\n+\n+        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n+            return tb.process(t, InTable);\n+        }\n+    },\n+    InRow {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (t.isStartTag()) {\n+                Token.StartTag startTag = t.asStartTag();\n+                String name = startTag.name();\n+\n+                if (StringUtil.in(name, \"th\", \"td\")) {\n+                    tb.clearStackToTableRowContext();\n+                    tb.insert(startTag);\n+                    tb.transition(InCell);\n+                    tb.insertMarkerToFormattingElements();\n+                } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n+                    return handleMissingTr(t, tb);\n+                } else {\n+                    return anythingElse(t, tb);\n+                }\n+            } else if (t.isEndTag()) {\n+                Token.EndTag endTag = t.asEndTag();\n+                String name = endTag.name();\n+\n+                if (name.equals(\"tr\")) {\n+                    if (!tb.inTableScope(name)) {\n+                        tb.error(this); // frag\n+                        return false;\n+                    }\n+                    tb.clearStackToTableRowContext();\n+                    tb.pop(); // tr\n+                    tb.transition(InTableBody);\n+                } else if (name.equals(\"table\")) {\n+                    return handleMissingTr(t, tb);\n+                } else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\n+                    if (!tb.inTableScope(name)) {\n+                        tb.error(this);\n+                        return false;\n+                    }\n+                    tb.process(new Token.EndTag(\"tr\"));\n+                    return tb.process(t);\n+                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\n+                    tb.error(this);\n+                    return false;\n+                } else {\n+                    return anythingElse(t, tb);\n+                }\n+            } else {\n+                return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n+            return tb.process(t, InTable);\n+        }\n+\n+        private boolean handleMissingTr(Token t, TreeBuilder tb) {\n+            boolean processed = tb.process(new Token.EndTag(\"tr\"));\n+            if (processed)\n+                return tb.process(t);\n+            else\n+                return false;\n+        }\n+    },\n+    InCell {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (t.isEndTag()) {\n+                Token.EndTag endTag = t.asEndTag();\n+                String name = endTag.name();\n+\n+                if (StringUtil.in(name, \"td\", \"th\")) {\n+                    if (!tb.inTableScope(name)) {\n+                        tb.error(this);\n+                        tb.transition(InRow); // might not be in scope if empty: <td /> and processing fake end tag\n+                        return false;\n+                    }\n+                    tb.generateImpliedEndTags();\n+                    if (!tb.currentElement().nodeName().equals(name))\n+                        tb.error(this);\n+                    tb.popStackToClose(name);\n+                    tb.clearFormattingElementsToLastMarker();\n+                    tb.transition(InRow);\n+                } else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\")) {\n+                    tb.error(this);\n+                    return false;\n+                } else if (StringUtil.in(name, \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\n+                    if (!tb.inTableScope(name)) {\n+                        tb.error(this);\n+                        return false;\n+                    }\n+                    closeCell(tb);\n+                    return tb.process(t);\n+                } else {\n+                    return anythingElse(t, tb);\n+                }\n+            } else if (t.isStartTag() &&\n+                    StringUtil.in(t.asStartTag().name(),\n+                            \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\n+                if (!(tb.inTableScope(\"td\") || tb.inTableScope(\"th\"))) {\n+                    tb.error(this);\n+                    return false;\n+                }\n+                closeCell(tb);\n+                return tb.process(t);\n+            } else {\n+                return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n+            return tb.process(t, InBody);\n+        }\n+\n+        private void closeCell(HtmlTreeBuilder tb) {\n+            if (tb.inTableScope(\"td\"))\n+                tb.process(new Token.EndTag(\"td\"));\n+            else\n+                tb.process(new Token.EndTag(\"th\")); // only here if th or td in scope\n+        }\n+    },\n+    InSelect {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            switch (t.type) {\n+                case Character:\n+                    Token.Character c = t.asCharacter();\n+                    if (c.getData().equals(nullString)) {\n+                        tb.error(this);\n+                        return false;\n+                    } else {\n+                        tb.insert(c);\n+                    }\n+                    break;\n+                case Comment:\n+                    tb.insert(t.asComment());\n+                    break;\n+                case Doctype:\n+                    tb.error(this);\n+                    return false;\n+                case StartTag:\n+                    Token.StartTag start = t.asStartTag();\n+                    String name = start.name();\n+                    if (name.equals(\"html\"))\n+                        return tb.process(start, InBody);\n+                    else if (name.equals(\"option\")) {\n+                        tb.process(new Token.EndTag(\"option\"));\n+                        tb.insert(start);\n+                    } else if (name.equals(\"optgroup\")) {\n+                        if (tb.currentElement().nodeName().equals(\"option\"))\n+                            tb.process(new Token.EndTag(\"option\"));\n+                        else if (tb.currentElement().nodeName().equals(\"optgroup\"))\n+                            tb.process(new Token.EndTag(\"optgroup\"));\n+                        tb.insert(start);\n+                    } else if (name.equals(\"select\")) {\n+                        tb.error(this);\n+                        return tb.process(new Token.EndTag(\"select\"));\n+                    } else if (StringUtil.in(name, \"input\", \"keygen\", \"textarea\")) {\n+                        tb.error(this);\n+                        if (!tb.inSelectScope(\"select\"))\n+                            return false; // frag\n+                        tb.process(new Token.EndTag(\"select\"));\n+                        return tb.process(start);\n+                    } else if (name.equals(\"script\")) {\n+                        return tb.process(t, InHead);\n+                    } else {\n+                        return anythingElse(t, tb);\n+                    }\n+                    break;\n+                case EndTag:\n+                    Token.EndTag end = t.asEndTag();\n+                    name = end.name();\n+                    if (name.equals(\"optgroup\")) {\n+                        if (tb.currentElement().nodeName().equals(\"option\") && tb.aboveOnStack(tb.currentElement()) != null && tb.aboveOnStack(tb.currentElement()).nodeName().equals(\"optgroup\"))\n+                            tb.process(new Token.EndTag(\"option\"));\n+                        if (tb.currentElement().nodeName().equals(\"optgroup\"))\n+                            tb.pop();\n+                        else\n+                            tb.error(this);\n+                    } else if (name.equals(\"option\")) {\n+                        if (tb.currentElement().nodeName().equals(\"option\"))\n+                            tb.pop();\n+                        else\n+                            tb.error(this);\n+                    } else if (name.equals(\"select\")) {\n+                        if (!tb.inSelectScope(name)) {\n+                            tb.error(this);\n+                            return false;\n+                        } else {\n+                            tb.popStackToClose(name);\n+                            tb.resetInsertionMode();\n+                        }\n+                    } else\n+                        return anythingElse(t, tb);\n+                    break;\n+                case EOF:\n+                    if (!tb.currentElement().nodeName().equals(\"html\"))\n+                        tb.error(this);\n+                    break;\n+                default:\n+                    return anythingElse(t, tb);\n+            }\n+            return true;\n+        }\n+\n+        private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\n+            tb.error(this);\n+            return false;\n+        }\n+    },\n+    InSelectInTable {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (t.isStartTag() && StringUtil.in(t.asStartTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n+                tb.error(this);\n+                tb.process(new Token.EndTag(\"select\"));\n+                return tb.process(t);\n+            } else if (t.isEndTag() && StringUtil.in(t.asEndTag().name(), \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\")) {\n+                tb.error(this);\n+                if (tb.inTableScope(t.asEndTag().name())) {\n+                    tb.process(new Token.EndTag(\"select\"));\n+                    return (tb.process(t));\n+                } else\n+                    return false;\n+            } else {\n+                return tb.process(t, InSelect);\n+            }\n+        }\n+    },\n+    AfterBody {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                return tb.process(t, InBody);\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment()); // into html node\n+            } else if (t.isDoctype()) {\n+                tb.error(this);\n+                return false;\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+                return tb.process(t, InBody);\n+            } else if (t.isEndTag() && t.asEndTag().name().equals(\"html\")) {\n+                if (tb.isFragmentParsing()) {\n+                    tb.error(this);\n+                    return false;\n+                } else {\n+                    tb.transition(AfterAfterBody);\n+                }\n+            } else if (t.isEOF()) {\n+                // chillax! we're done\n+            } else {\n+                tb.error(this);\n+                tb.transition(InBody);\n+                return tb.process(t);\n+            }\n+            return true;\n+        }\n+    },\n+    InFrameset {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                tb.insert(t.asCharacter());\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype()) {\n+                tb.error(this);\n+                return false;\n+            } else if (t.isStartTag()) {\n+                Token.StartTag start = t.asStartTag();\n+                String name = start.name();\n+                if (name.equals(\"html\")) {\n+                    return tb.process(start, InBody);\n+                } else if (name.equals(\"frameset\")) {\n+                    tb.insert(start);\n+                } else if (name.equals(\"frame\")) {\n+                    tb.insertEmpty(start);\n+                } else if (name.equals(\"noframes\")) {\n+                    return tb.process(start, InHead);\n+                } else {\n+                    tb.error(this);\n+                    return false;\n+                }\n+            } else if (t.isEndTag() && t.asEndTag().name().equals(\"frameset\")) {\n+                if (tb.currentElement().nodeName().equals(\"html\")) { // frag\n+                    tb.error(this);\n+                    return false;\n+                } else {\n+                    tb.pop();\n+                    if (!tb.isFragmentParsing() && !tb.currentElement().nodeName().equals(\"frameset\")) {\n+                        tb.transition(AfterFrameset);\n+                    }\n+                }\n+            } else if (t.isEOF()) {\n+                if (!tb.currentElement().nodeName().equals(\"html\")) {\n+                    tb.error(this);\n+                    return true;\n+                }\n+            } else {\n+                tb.error(this);\n+                return false;\n+            }\n+            return true;\n+        }\n+    },\n+    AfterFrameset {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (isWhitespace(t)) {\n+                tb.insert(t.asCharacter());\n+            } else if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype()) {\n+                tb.error(this);\n+                return false;\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\n+                return tb.process(t, InBody);\n+            } else if (t.isEndTag() && t.asEndTag().name().equals(\"html\")) {\n+                tb.transition(AfterAfterFrameset);\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"noframes\")) {\n+                return tb.process(t, InHead);\n+            } else if (t.isEOF()) {\n+                // cool your heels, we're complete\n+            } else {\n+                tb.error(this);\n+                return false;\n+            }\n+            return true;\n+        }\n+    },\n+    AfterAfterBody {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals(\"html\"))) {\n+                return tb.process(t, InBody);\n+            } else if (t.isEOF()) {\n+                // nice work chuck\n+            } else {\n+                tb.error(this);\n+                tb.transition(InBody);\n+                return tb.process(t);\n+            }\n+            return true;\n+        }\n+    },\n+    AfterAfterFrameset {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            if (t.isComment()) {\n+                tb.insert(t.asComment());\n+            } else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().name().equals(\"html\"))) {\n+                return tb.process(t, InBody);\n+            } else if (t.isEOF()) {\n+                // nice work chuck\n+            } else if (t.isStartTag() && t.asStartTag().name().equals(\"nofrmes\")) {\n+                return tb.process(t, InHead);\n+            } else {\n+                tb.error(this);\n+                tb.transition(InBody);\n+                return tb.process(t);\n+            }\n+            return true;\n+        }\n+    },\n+    ForeignContent {\n+        boolean process(Token t, HtmlTreeBuilder tb) {\n+            return true;\n+            // todo: implement. Also; how do we get here?\n+        }\n+    };\n+\n+    private static String nullString = String.valueOf('\\u0000');\n+\n+    abstract boolean process(Token t, HtmlTreeBuilder tb);\n+\n+    private static boolean isWhitespace(Token t) {\n+        if (t.isCharacter()) {\n+            String data = t.asCharacter().getData();\n+            // todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\n+            for (int i = 0; i < data.length(); i++) {\n+                char c = data.charAt(i);\n+                if (!StringUtil.isWhitespace(c))\n+                    return false;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {\n+        tb.insert(startTag);\n+        tb.tokeniser.transition(TokeniserState.Rcdata);\n+        tb.markInsertionMode();\n+        tb.transition(Text);\n+    }\n+\n+    private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\n+        tb.insert(startTag);\n+        tb.tokeniser.transition(TokeniserState.Rawtext);\n+        tb.markInsertionMode();\n+        tb.transition(Text);\n+    }\n+}\n--- a/src/main/java/org/jsoup/parser/ParseError.java\n+++ b/src/main/java/org/jsoup/parser/ParseError.java\n /**\n  * A Parse Error records an error in the input HTML that occurs in either the tokenisation or the tree building phase.\n  */\n-// todo: currently not ready for public consumption. revisit api, and exposure methods\n class ParseError {\n+    private int pos;\n     private String errorMsg;\n-    private int pos;\n-    private char c;\n-    private TokeniserState tokeniserState;\n-    private TreeBuilderState treeBuilderState;\n-    private Token token;\n \n-    ParseError(String errorMsg, char c, TokeniserState tokeniserState, int pos) {\n+    ParseError(int pos, String errorMsg) {\n+        this.pos = pos;\n         this.errorMsg = errorMsg;\n-        this.c = c;\n-        this.tokeniserState = tokeniserState;\n+    }\n+\n+    ParseError(int pos, String errorFormat, Object... args) {\n+        this.errorMsg = String.format(errorFormat, args);\n         this.pos = pos;\n     }\n \n-    ParseError(String errorMsg, TokeniserState tokeniserState, int pos) {\n-        this.errorMsg = errorMsg;\n-        this.tokeniserState = tokeniserState;\n-        this.pos = pos;\n-    }\n-\n-    ParseError(String errorMsg, int pos) {\n-        this.errorMsg = errorMsg;\n-        this.pos = pos;\n-    }\n-\n-    ParseError(String errorMsg, TreeBuilderState treeBuilderState, Token token, int pos) {\n-        this.errorMsg = errorMsg;\n-        this.treeBuilderState = treeBuilderState;\n-        this.token = token;\n-        this.pos = pos;\n-    }\n-\n-    String getErrorMsg() {\n+    public String getErrorMessage() {\n         return errorMsg;\n     }\n \n-    int getPos() {\n+    public int getPosition() {\n         return pos;\n     }\n+\n+    @Override\n+    public String toString() {\n+        return pos + \": \" + errorMsg;\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n  * in {@link org.jsoup.Jsoup}.\n  */\n public class Parser {\n+    private TreeBuilder treeBuilder;\n+    private boolean trackErrors = false;\n+    private List<ParseError> errors;\n+\n+    /**\n+     * Create a new Parser, using the specified TreeBuilder\n+     * @param treeBuilder TreeBuilder to use to parse input into Documents.\n+     */\n+    public Parser(TreeBuilder treeBuilder) {\n+        this.treeBuilder = treeBuilder;\n+    }\n+    \n+    public Document parseInput(String html, String baseUri) {\n+        Document doc = treeBuilder.parse(html, baseUri, trackErrors);\n+        errors = treeBuilder.getErrors();\n+        return doc;\n+    }\n+\n+    // gets & sets\n+    /**\n+     * Get the TreeBuilder currently in use.\n+     * @return current TreeBuilder.\n+     */\n+    public TreeBuilder getTreeBuilder() {\n+        return treeBuilder;\n+    }\n+\n+    /**\n+     * Update the TreeBuilder used when parsing content.\n+     * @param treeBuilder current TreeBuilder\n+     * @return this, for chaining\n+     */\n+    public Parser setTreeBuilder(TreeBuilder treeBuilder) {\n+        this.treeBuilder = treeBuilder;\n+        return this;\n+    }\n+\n+    /**\n+     * Check if parse error tracking is enabled.\n+     * @return current track error state.\n+     */\n+    public boolean isTrackErrors() {\n+        return trackErrors;\n+    }\n+\n+    /**\n+     * Enable or disable parse error tracking for the next parse/\n+     * @param trackErrors on/off\n+     * @return this, for chaining\n+     */\n+    public Parser setTrackErrors(boolean trackErrors) {\n+        this.trackErrors = trackErrors;\n+        return this;\n+    }\n+\n+    /**\n+     * Retrieve the parse errors, if any, from the last parse.\n+     * @return list of parse errors, if error tracking was enabled and errors occurred. If not enabled, returns null.\n+     */\n+    public List<ParseError> getErrors() {\n+        return errors;\n+    }\n+\n+    // static parse functions below\n     /**\n      * Parse HTML into a Document.\n      *\n      * @return parsed Document\n      */\n     public static Document parse(String html, String baseUri) {\n-        TreeBuilder treeBuilder = new TreeBuilder();\n-        return treeBuilder.parse(html, baseUri);\n+        TreeBuilder treeBuilder = new HtmlTreeBuilder();\n+        return treeBuilder.parse(html, baseUri, false);\n     }\n \n     /**\n      * @return list of nodes parsed from the input HTML. Note that the context element, if supplied, is not modified.\n      */\n     public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n-        TreeBuilder treeBuilder = new TreeBuilder();\n-        return treeBuilder.parseFragment(fragmentHtml, context, baseUri);\n+        HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, false);\n     }\n \n     /**\n     public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) {\n         return parse(bodyHtml, baseUri);\n     }\n+    \n+    // builders\n+\n+    /**\n+     * Create a new HTML parser. This parser treats input as HTML5, and enforces the creation of a normalised document,\n+     * based on a knowledge of the semantics of the incoming tags.\n+     * @return a new HTML parser.\n+     */\n+    public static Parser htmlParser() {\n+        return new Parser(new HtmlTreeBuilder());\n+    }\n+\n+    /**\n+     * Create a new XML parser. This parser assumes no knowledge of the incoming tags and does not treat it as HTML,\n+     * rather creates a simple tree directly from the input.\n+     * @return a new simple XML parser.\n+     */\n+    public static Parser xmlParser() {\n+        return new Parser(new XmlTreeBuilder());\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n     TokenType type;\n \n     private Token() {\n+    }\n+    \n+    String tokenType() {\n+        return this.getClass().getSimpleName();\n     }\n \n     static class Doctype extends Token {\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n package org.jsoup.parser;\n \n+import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n \n /**\n      @return if starts with whitespace\n      */\n     public boolean matchesWhitespace() {\n-        return !isEmpty() && Character.isWhitespace(queue.charAt(pos));\n+        return !isEmpty() && StringUtil.isWhitespace(queue.charAt(pos));\n     }\n \n     /**\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n     static final char replacementChar = '\\uFFFD'; // replaces null character\n \n     private CharacterReader reader; // html input\n-    private boolean trackErrors = true;\n-    private List<ParseError> errors = new ArrayList<ParseError>(); // errors found while tokenising\n+    private boolean trackErrors;\n+    private List<ParseError> errors; // errors found while tokenising\n \n     private TokeniserState state = TokeniserState.Data; // current tokenisation state\n     private Token emitPending; // the token we are about to emit on next read\n     private Token.StartTag lastStartTag; // the last start tag emitted, to test appropriate end tag\n     private boolean selfClosingFlagAcknowledged = true;\n \n-    Tokeniser(CharacterReader reader) {\n+    Tokeniser(CharacterReader reader, List<ParseError> errors) {\n         this.reader = reader;\n+        this.errors = errors;\n+        this.trackErrors = errors != null;\n     }\n \n     Token read() {\n             boolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\n             String numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\n             if (numRef.length() == 0) { // didn't match anything\n-                characterReferenceError();\n+                characterReferenceError(\"numeric reference with no numerals\");\n                 reader.rewindToMark();\n                 return null;\n             }\n             if (!reader.matchConsume(\";\"))\n-                characterReferenceError(); // missing semi\n+                characterReferenceError(\"missing semicolon\"); // missing semi\n             int charval = -1;\n             try {\n                 int base = isHexMode ? 16 : 10;\n             } catch (NumberFormatException e) {\n             } // skip\n             if (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\n-                characterReferenceError();\n+                characterReferenceError(\"character outside of valid range\");\n                 return replacementChar;\n             } else {\n                 // todo: implement number replacement table\n         } else { // named\n             // get as many letters as possible, and look for matching entities. unconsume backwards till a match is found\n             String nameRef = reader.consumeLetterSequence();\n+            String origNameRef = new String(nameRef); // for error reporting. nameRef gets chomped looking for matches\n             boolean looksLegit = reader.matches(';');\n             boolean found = false;\n             while (nameRef.length() > 0 && !found) {\n             }\n             if (!found) {\n                 if (looksLegit) // named with semicolon\n-                    characterReferenceError();\n+                    characterReferenceError(String.format(\"invalid named referenece '%s'\", origNameRef));\n                 reader.rewindToMark();\n                 return null;\n             }\n                 return null;\n             }\n             if (!reader.matchConsume(\";\"))\n-                characterReferenceError(); // missing semi\n+                characterReferenceError(\"missing semicolon\"); // missing semi\n             return Entities.getCharacterByName(nameRef);\n         }\n     }\n         return lastStartTag.tagName;\n     }\n \n-    boolean isTrackErrors() {\n-        return trackErrors;\n-    }\n-\n-    void setTrackErrors(boolean trackErrors) {\n-        this.trackErrors = trackErrors;\n-    }\n-\n     void error(TokeniserState state) {\n         if (trackErrors)\n-            errors.add(new ParseError(\"Unexpected character in input\", reader.current(), state, reader.pos()));\n+            errors.add(new ParseError(reader.pos(), \"Unexpected character '%s' in input state [%s]\", reader.current(), state));\n     }\n \n     void eofError(TokeniserState state) {\n         if (trackErrors)\n-            errors.add(new ParseError(\"Unexpectedly reached end of file (EOF)\", state, reader.pos()));\n-    }\n-\n-    private void characterReferenceError() {\n-        if (trackErrors)\n-            errors.add(new ParseError(\"Invalid character reference\", reader.pos()));\n+            errors.add(new ParseError(reader.pos(), \"Unexpectedly reached end of file (EOF) in input state [%s]\", state));\n+    }\n+\n+    private void characterReferenceError(String message) {\n+        if (trackErrors)\n+            errors.add(new ParseError(reader.pos(), \"Invalid character reference: %s\", message));\n     }\n \n     private void error(String errorMsg) {\n         if (trackErrors)\n-            errors.add(new ParseError(errorMsg, reader.pos()));\n+            errors.add(new ParseError(reader.pos(), errorMsg));\n     }\n \n     boolean currentNodeInHtmlNS() {\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n package org.jsoup.parser;\n \n import org.jsoup.helper.DescendableLinkedList;\n-import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n-import org.jsoup.nodes.*;\n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.util.LinkedList;\n import java.util.List;\n \n /**\n- * HTML Tree Builder; creates a DOM from Tokens.\n+ * @author Jonathan Hedley\n  */\n-class TreeBuilder {\n+abstract class TreeBuilder {\n     CharacterReader reader;\n     Tokeniser tokeniser;\n+    protected Document doc; // current doc we are building into\n+    protected DescendableLinkedList<Element> stack; // the stack of open elements\n+    protected String baseUri; // current base uri, for creating new elements\n+    protected Token currentToken; // currentToken is used only for error tracking.\n+    protected boolean trackErrors = false;\n+    protected List<ParseError> errors; // null when not tracking errors\n \n-    private TreeBuilderState state; // the current state\n-    private TreeBuilderState originalState; // original / marked state\n-    private Document doc; // current doc we are building into\n-    private DescendableLinkedList<Element> stack; // the stack of open elements\n+    protected void initialiseParse(String input, String baseUri, boolean trackErrors) {\n+        Validate.notNull(input, \"String input must not be null\");\n+        Validate.notNull(baseUri, \"BaseURI must not be null\");\n \n-    private String baseUri; // current base uri, for creating new elements\n-    private boolean baseUriSetFromDoc = false;\n-    private Token currentToken; // currentToken is used only for error tracking.\n-    private Element headElement; // the current head element\n-    private Element formElement; // the current form element\n-    private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n-    private DescendableLinkedList<Element> formattingElements = new DescendableLinkedList<Element>(); // active (open) formatting elements\n-    private List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); // chars in table to be shifted out\n-\n-    private boolean framesetOk = true; // if ok to go into frameset\n-    private boolean fosterInserts = false; // if next inserts should be fostered\n-    private boolean fragmentParsing = false; // if parsing a fragment of html\n-\n-    private boolean trackErrors = false;\n-    private List<ParseError> errors = new ArrayList<ParseError>();\n-\n-    TreeBuilder() {}\n-\n-    private void initialiseParse(String input, String baseUri) {\n         doc = new Document(baseUri);\n         reader = new CharacterReader(input);\n-        tokeniser = new Tokeniser(reader);\n+        this.trackErrors = trackErrors;\n+        errors = trackErrors ? new ArrayList<ParseError>() : null;\n+        tokeniser = new Tokeniser(reader, errors);\n         stack = new DescendableLinkedList<Element>();\n         this.baseUri = baseUri;\n     }\n \n     Document parse(String input, String baseUri) {\n-        state = TreeBuilderState.Initial;\n-        initialiseParse(input, baseUri);\n+        return parse(input, baseUri, false);\n+    }\n+\n+    Document parse(String input, String baseUri, boolean trackErrors) {\n+        initialiseParse(input, baseUri, trackErrors);\n         runParser();\n         return doc;\n     }\n-\n-    List<Node> parseFragment(String inputFragment, Element context, String baseUri) {\n-        // context may be null\n-        initialiseParse(inputFragment, baseUri);\n-        contextElement = context;\n-        fragmentParsing = true;\n-        Element root = null;\n-\n-        if (context != null) {\n-            if (context.ownerDocument() != null) // quirks setup:\n-                doc.quirksMode(context.ownerDocument().quirksMode());\n-\n-            // initialise the tokeniser state:\n-            String contextTag = context.tagName();\n-            if (StringUtil.in(contextTag, \"title\", \"textarea\"))\n-                tokeniser.transition(TokeniserState.Rcdata);\n-            else if (StringUtil.in(contextTag, \"iframe\", \"noembed\", \"noframes\", \"style\", \"xmp\"))\n-                tokeniser.transition(TokeniserState.Rawtext);\n-            else if (contextTag.equals(\"script\"))\n-                tokeniser.transition(TokeniserState.ScriptData);\n-            else if (contextTag.equals((\"noscript\")))\n-                tokeniser.transition(TokeniserState.Data); // if scripting enabled, rawtext\n-            else if (contextTag.equals(\"plaintext\"))\n-                tokeniser.transition(TokeniserState.Data);\n-            else\n-                tokeniser.transition(TokeniserState.Data); // default\n-\n-            root = new Element(Tag.valueOf(\"html\"), baseUri);\n-            doc.appendChild(root);\n-            stack.push(root);\n-            resetInsertionMode();\n-            // todo: setup form element to nearest form on context (up ancestor chain)\n-        }\n-\n-        runParser();\n-        if (context != null)\n-            return root.childNodes();\n-        else\n-            return doc.childNodes();\n+    \n+    List<ParseError> getErrors() {\n+        return errors;\n     }\n \n-    private void runParser() {\n+    protected void runParser() {\n         while (true) {\n-            // todo: handle foreign content checks\n-\n             Token token = tokeniser.read();\n             process(token);\n \n         }\n     }\n \n-    boolean process(Token token) {\n-        currentToken = token;\n-        return this.state.process(token, this);\n-    }\n+    protected abstract boolean process(Token token);\n \n-    boolean process(Token token, TreeBuilderState state) {\n-        currentToken = token;\n-        return state.process(token, this);\n-    }\n-\n-    void transition(TreeBuilderState state) {\n-        this.state = state;\n-    }\n-\n-    TreeBuilderState state() {\n-        return state;\n-    }\n-\n-    void markInsertionMode() {\n-        originalState = state;\n-    }\n-\n-    TreeBuilderState originalState() {\n-        return originalState;\n-    }\n-\n-    void framesetOk(boolean framesetOk) {\n-        this.framesetOk = framesetOk;\n-    }\n-\n-    boolean framesetOk() {\n-        return framesetOk;\n-    }\n-\n-    Element currentElement() {\n+    protected Element currentElement() {\n         return stack.getLast();\n     }\n-\n-    Document getDocument() {\n-        return doc;\n-    }\n-\n-    String getBaseUri() {\n-        return baseUri;\n-    }\n-\n-    void maybeSetBaseUri(Element base) {\n-        if (baseUriSetFromDoc) // only listen to the first <base href> in parse\n-            return;\n-\n-        String href = base.absUrl(\"href\");\n-        if (href.length() != 0) { // ignore <base target> etc\n-            baseUri = href;\n-            baseUriSetFromDoc = true;\n-            doc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base, and to update all descendants\n-        }\n-    }\n-\n-    boolean isFragmentParsing() {\n-        return fragmentParsing;\n-    }\n-\n-    void error(TreeBuilderState state) {\n-        if (trackErrors)\n-            errors.add(new ParseError(\"Unexpected token\", state, currentToken, reader.pos()));\n-    }\n-\n-    Element insert(Token.StartTag startTag) {\n-        // handle empty unknown tags\n-        // when the spec expects an empty tag, will directly hit insertEmpty, so won't generate fake end tag.\n-        if (startTag.isSelfClosing() && !Tag.isKnownTag(startTag.name())) {\n-            Element el = insertEmpty(startTag);\n-            process(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in\n-            return el;\n-        }\n-        \n-        Element el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\n-        insert(el);\n-        return el;\n-    }\n-\n-    Element insert(String startTagName) {\n-        Element el = new Element(Tag.valueOf(startTagName), baseUri);\n-        insert(el);\n-        return el;\n-    }\n-\n-    void insert(Element el) {\n-        insertNode(el);\n-        stack.add(el);\n-    }\n-\n-    Element insertEmpty(Token.StartTag startTag) {\n-        Tag tag = Tag.valueOf(startTag.name());\n-        Element el = new Element(tag, baseUri, startTag.attributes);\n-        insertNode(el);\n-        if (startTag.isSelfClosing()) {\n-            tokeniser.acknowledgeSelfClosingFlag();\n-            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output\n-                tag.setSelfClosing();\n-        }\n-        return el;\n-    }\n-\n-    void insert(Token.Comment commentToken) {\n-        Comment comment = new Comment(commentToken.getData(), baseUri);\n-        insertNode(comment);\n-    }\n-\n-    void insert(Token.Character characterToken) {\n-        Node node;\n-        // characters in script and style go in as datanodes, not text nodes\n-        if (StringUtil.in(currentElement().tagName(), \"script\", \"style\"))\n-            node = new DataNode(characterToken.getData(), baseUri);\n-        else\n-            node = new TextNode(characterToken.getData(), baseUri);\n-        currentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n-    }\n-\n-    private void insertNode(Node node) {\n-        // if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\n-        if (stack.size() == 0)\n-            doc.appendChild(node);\n-        else if (isFosterInserts())\n-            insertInFosterParent(node);\n-        else\n-            currentElement().appendChild(node);\n-    }\n-\n-    Element pop() {\n-        // todo - dev, remove validation check\n-        if (stack.peekLast().nodeName().equals(\"td\") && !state.name().equals(\"InCell\"))\n-            Validate.isFalse(true, \"pop td not in cell\");\n-        if (stack.peekLast().nodeName().equals(\"html\"))\n-            Validate.isFalse(true, \"popping html!\");\n-        return stack.pollLast();\n-    }\n-\n-    void push(Element element) {\n-        stack.add(element);\n-    }\n-\n-    DescendableLinkedList<Element> getStack() {\n-        return stack;\n-    }\n-\n-    boolean onStack(Element el) {\n-        return isElementInQueue(stack, el);\n-    }\n-\n-    private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element) {\n-        Iterator<Element> it = queue.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next == element) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    Element getFromStack(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next.nodeName().equals(elName)) {\n-                return next;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    boolean removeFromStack(Element el) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next == el) {\n-                it.remove();\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    void popStackToClose(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next.nodeName().equals(elName)) {\n-                it.remove();\n-                break;\n-            } else {\n-                it.remove();\n-            }\n-        }\n-    }\n-\n-    void popStackToClose(String... elNames) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (StringUtil.in(next.nodeName(), elNames)) {\n-                it.remove();\n-                break;\n-            } else {\n-                it.remove();\n-            }\n-        }\n-    }\n-\n-    void popStackToBefore(String elName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next.nodeName().equals(elName)) {\n-                break;\n-            } else {\n-                it.remove();\n-            }\n-        }\n-    }\n-\n-    void clearStackToTableContext() {\n-        clearStackToContext(\"table\");\n-    }\n-\n-    void clearStackToTableBodyContext() {\n-        clearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n-    }\n-\n-    void clearStackToTableRowContext() {\n-        clearStackToContext(\"tr\");\n-    }\n-\n-    private void clearStackToContext(String... nodeNames) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\n-                break;\n-            else\n-                it.remove();\n-        }\n-    }\n-\n-    Element aboveOnStack(Element el) {\n-        assert onStack(el);\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next == el) {\n-                return it.next();\n-            }\n-        }\n-        return null;\n-    }\n-\n-    void insertOnStackAfter(Element after, Element in) {\n-        int i = stack.lastIndexOf(after);\n-        Validate.isTrue(i != -1);\n-        stack.add(i+1, in);\n-    }\n-\n-    void replaceOnStack(Element out, Element in) {\n-        replaceInQueue(stack, out, in);\n-    }\n-\n-    private void replaceInQueue(LinkedList<Element> queue, Element out, Element in) {\n-        int i = queue.lastIndexOf(out);\n-        Validate.isTrue(i != -1);\n-        queue.remove(i);\n-        queue.add(i, in);\n-    }\n-\n-    void resetInsertionMode() {\n-        boolean last = false;\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element node = it.next();\n-            if (!it.hasNext()) {\n-                last = true;\n-                node = contextElement;\n-            }\n-            String name = node.nodeName();\n-            if (\"select\".equals(name)) {\n-                transition(TreeBuilderState.InSelect);\n-                break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n-                transition(TreeBuilderState.InCell);\n-                break;\n-            } else if (\"tr\".equals(name)) {\n-                transition(TreeBuilderState.InRow);\n-                break;\n-            } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n-                transition(TreeBuilderState.InTableBody);\n-                break;\n-            } else if (\"caption\".equals(name)) {\n-                transition(TreeBuilderState.InCaption);\n-                break;\n-            } else if (\"colgroup\".equals(name)) {\n-                transition(TreeBuilderState.InColumnGroup);\n-                break; // frag\n-            } else if (\"table\".equals(name)) {\n-                transition(TreeBuilderState.InTable);\n-                break;\n-            } else if (\"head\".equals(name)) {\n-                transition(TreeBuilderState.InBody);\n-                break; // frag\n-            } else if (\"body\".equals(name)) {\n-                transition(TreeBuilderState.InBody);\n-                break;\n-            } else if (\"frameset\".equals(name)) {\n-                transition(TreeBuilderState.InFrameset);\n-                break; // frag\n-            } else if (\"html\".equals(name)) {\n-                transition(TreeBuilderState.BeforeHead);\n-                break; // frag\n-            } else if (last) {\n-                transition(TreeBuilderState.InBody);\n-                break; // frag\n-            }\n-        }\n-    }\n-\n-    // todo: tidy up in specific scope methods\n-    private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\n-        return inSpecificScope(new String[]{targetName}, baseTypes, extraTypes);\n-    }\n-\n-    private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element el = it.next();\n-            String elName = el.nodeName();\n-            if (StringUtil.in(elName, targetNames))\n-                return true;\n-            if (StringUtil.in(elName, baseTypes))\n-                return false;\n-            if (extraTypes != null && StringUtil.in(elName, extraTypes))\n-                return false;\n-        }\n-        Validate.fail(\"Should not be reachable\");\n-        return false;\n-    }\n-\n-    boolean inScope(String[] targetNames) {\n-        return inSpecificScope(targetNames, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, null);\n-    }\n-\n-    boolean inScope(String targetName) {\n-        return inScope(targetName, null);\n-    }\n-\n-    boolean inScope(String targetName, String[] extras) {\n-        return inSpecificScope(targetName, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, extras);\n-        // todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n-        // todo: in svg namespace: forignOjbect, desc, title\n-    }\n-\n-    boolean inListItemScope(String targetName) {\n-        return inScope(targetName, new String[]{\"ol\", \"ul\"});\n-    }\n-\n-    boolean inButtonScope(String targetName) {\n-        return inScope(targetName, new String[]{\"button\"});\n-    }\n-\n-    boolean inTableScope(String targetName) {\n-        return inSpecificScope(targetName, new String[]{\"html\", \"table\"}, null);\n-    }\n-\n-    boolean inSelectScope(String targetName) {\n-        Iterator<Element> it = stack.descendingIterator();\n-        while (it.hasNext()) {\n-            Element el = it.next();\n-            String elName = el.nodeName();\n-            if (elName.equals(targetName))\n-                return true;\n-            if (!StringUtil.in(elName, \"optgroup\", \"option\")) // all elements except\n-                return false;\n-        }\n-        Validate.fail(\"Should not be reachable\");\n-        return false;\n-    }\n-\n-    void setHeadElement(Element headElement) {\n-        this.headElement = headElement;\n-    }\n-\n-    Element getHeadElement() {\n-        return headElement;\n-    }\n-\n-    boolean isFosterInserts() {\n-        return fosterInserts;\n-    }\n-\n-    void setFosterInserts(boolean fosterInserts) {\n-        this.fosterInserts = fosterInserts;\n-    }\n-\n-    Element getFormElement() {\n-        return formElement;\n-    }\n-\n-    void setFormElement(Element formElement) {\n-        this.formElement = formElement;\n-    }\n-\n-    void newPendingTableCharacters() {\n-        pendingTableCharacters = new ArrayList<Token.Character>();\n-    }\n-\n-    List<Token.Character> getPendingTableCharacters() {\n-        return pendingTableCharacters;\n-    }\n-\n-    void setPendingTableCharacters(List<Token.Character> pendingTableCharacters) {\n-        this.pendingTableCharacters = pendingTableCharacters;\n-    }\n-\n-    /**\n-     11.2.5.2 Closing elements that have implied end tags<p/>\n-     When the steps below require the UA to generate implied end tags, then, while the current node is a dd element, a\n-     dt element, an li element, an option element, an optgroup element, a p element, an rp element, or an rt element,\n-     the UA must pop the current node off the stack of open elements.\n-\n-     @param excludeTag If a step requires the UA to generate implied end tags but lists an element to exclude from the\n-     process, then the UA must perform the above steps as if that element was not in the above list.\n-     */\n-    void generateImpliedEndTags(String excludeTag) {\n-        while ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\n-                StringUtil.in(currentElement().nodeName(), \"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"))\n-            pop();\n-    }\n-\n-    void generateImpliedEndTags() {\n-        generateImpliedEndTags(null);\n-    }\n-\n-    boolean isSpecial(Element el) {\n-        // todo: mathml's mi, mo, mn\n-        // todo: svg's foreigObject, desc, title\n-        String name = el.nodeName();\n-        return StringUtil.in(name, \"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\",\n-                \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"command\", \"dd\",\n-                \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\",\n-                \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\",\n-                \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"marquee\", \"menu\", \"meta\", \"nav\",\n-                \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\",\n-                \"section\", \"select\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"textarea\", \"tfoot\", \"th\", \"thead\",\n-                \"title\", \"tr\", \"ul\", \"wbr\", \"xmp\");\n-    }\n-\n-    // active formatting elements\n-    void pushActiveFormattingElements(Element in) {\n-        int numSeen = 0;\n-        Iterator<Element> iter = formattingElements.descendingIterator();\n-        while (iter.hasNext()) {\n-            Element el =  iter.next();\n-            if (el == null) // marker\n-                break;\n-\n-            if (isSameFormattingElement(in, el))\n-                numSeen++;\n-\n-            if (numSeen == 3) {\n-                iter.remove();\n-                break;\n-            }\n-        }\n-        formattingElements.add(in);\n-    }\n-\n-    private boolean isSameFormattingElement(Element a, Element b) {\n-        // same if: same namespace, tag, and attributes. Element.equals only checks tag, might in future check children\n-        return a.nodeName().equals(b.nodeName()) &&\n-                // a.namespace().equals(b.namespace()) &&\n-                a.attributes().equals(b.attributes());\n-        // todo: namespaces\n-    }\n-\n-    void reconstructFormattingElements() {\n-        int size = formattingElements.size();\n-        if (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\n-            return;\n-\n-        Element entry = formattingElements.getLast();\n-        int pos = size - 1;\n-        boolean skip = false;\n-        while (true) {\n-            if (pos == 0) { // step 4. if none before, skip to 8\n-                skip = true;\n-                break;\n-            }\n-            entry = formattingElements.get(--pos); // step 5. one earlier than entry\n-            if (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\n-                break; // jump to 8, else continue back to 4\n-        }\n-        while(true) {\n-            if (!skip) // step 7: on later than entry\n-                entry = formattingElements.get(++pos);\n-            Validate.notNull(entry); // should not occur, as we break at last element\n-\n-            // 8. create new element from element, 9 insert into current node, onto stack\n-            skip = false; // can only skip increment from 4.\n-            Element newEl = insert(entry.nodeName()); // todo: avoid fostering here?\n-            // newEl.namespace(entry.namespace()); // todo: namespaces\n-            newEl.attributes().addAll(entry.attributes());\n-\n-            // 10. replace entry with new entry\n-            formattingElements.add(pos, newEl);\n-            formattingElements.remove(pos + 1);\n-\n-            // 11\n-            if (pos == size-1) // if not last entry in list, jump to 7\n-                break;\n-        }\n-    }\n-\n-    void clearFormattingElementsToLastMarker() {\n-        while (!formattingElements.isEmpty()) {\n-            Element el = formattingElements.peekLast();\n-            formattingElements.removeLast();\n-            if (el == null)\n-                break;\n-        }\n-    }\n-\n-    void removeFromActiveFormattingElements(Element el) {\n-        Iterator<Element> it = formattingElements.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next == el) {\n-                it.remove();\n-                break;\n-            }\n-        }\n-    }\n-\n-    boolean isInActiveFormattingElements(Element el) {\n-        return isElementInQueue(formattingElements, el);\n-    }\n-\n-    Element getActiveFormattingElement(String nodeName) {\n-        Iterator<Element> it = formattingElements.descendingIterator();\n-        while (it.hasNext()) {\n-            Element next = it.next();\n-            if (next == null) // scope marker\n-                break;\n-            else if (next.nodeName().equals(nodeName))\n-                return next;\n-        }\n-        return null;\n-    }\n-\n-    void replaceActiveFormattingElement(Element out, Element in) {\n-        replaceInQueue(formattingElements, out, in);\n-    }\n-\n-    void insertMarkerToFormattingElements() {\n-        formattingElements.add(null);\n-    }\n-\n-    void insertInFosterParent(Node in) {\n-        Element fosterParent = null;\n-        Element lastTable = getFromStack(\"table\");\n-        boolean isLastTableParent = false;\n-        if (lastTable != null) {\n-            if (lastTable.parent() != null) {\n-                fosterParent = lastTable.parent();\n-                isLastTableParent = true;\n-            } else\n-                fosterParent = aboveOnStack(lastTable);\n-        } else { // no table == frag\n-            fosterParent = stack.get(0);\n-        }\n-\n-        if (isLastTableParent) {\n-            Validate.notNull(lastTable); // last table cannot be null by this point.\n-            lastTable.before(in);\n-        }\n-        else\n-            fosterParent.appendChild(in);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return \"TreeBuilder{\" +\n-                \"currentToken=\" + currentToken +\n-                \", state=\" + state +\n-                \", currentElement=\" + currentElement() +\n-                '}';\n-    }\n }\n--- /dev/null\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+package org.jsoup.parser;\n+\n+import org.jsoup.helper.Validate;\n+import org.jsoup.nodes.*;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * @author Jonathan Hedley\n+ */\n+public class XmlTreeBuilder extends TreeBuilder {\n+    @Override\n+    protected void initialiseParse(String input, String baseUri, boolean trackErrors) {\n+        super.initialiseParse(input, baseUri, trackErrors);\n+        stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n+    }\n+\n+    @Override\n+    protected boolean process(Token token) {\n+        // start tag, end tag, doctype, comment, character, eof\n+        switch (token.type) {\n+            case StartTag:\n+                insert(token.asStartTag());\n+                break;\n+            case EndTag:\n+                popStackToClose(token.asEndTag());\n+                break;\n+            case Comment:\n+                insert(token.asComment());\n+                break;\n+            case Character:\n+                insert(token.asCharacter());\n+                break;\n+            case Doctype:\n+                insert(token.asDoctype());\n+                break;\n+            case EOF: // could put some normalisation here if desired\n+                break;\n+            default:\n+                Validate.fail(\"Unexpected token type: \" + token.type);\n+        }\n+        return true;\n+    }\n+\n+    private void insertNode(Node node) {\n+        currentElement().appendChild(node);\n+    }\n+\n+    Element insert(Token.StartTag startTag) {\n+        Tag tag = Tag.valueOf(startTag.name());\n+        // todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\n+        Element el = new Element(tag, baseUri, startTag.attributes);\n+        insertNode(el);\n+        if (startTag.isSelfClosing()) {\n+            tokeniser.acknowledgeSelfClosingFlag();\n+            if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.\n+                tag.setSelfClosing();\n+        } else {\n+            stack.add(el);\n+        }\n+        return el;\n+    }\n+\n+    void insert(Token.Comment commentToken) {\n+        Comment comment = new Comment(commentToken.getData(), baseUri);\n+        insertNode(comment);\n+    }\n+\n+    void insert(Token.Character characterToken) {\n+        Node node = new TextNode(characterToken.getData(), baseUri);\n+        insertNode(node);\n+    }\n+\n+    void insert(Token.Doctype d) {\n+        DocumentType doctypeNode = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\n+        insertNode(doctypeNode);\n+    }\n+\n+    /**\n+     * If the stack contains an element with this tag's name, pop up the stack to remove the first occurrence. If not\n+     * found, skips.\n+     *\n+     * @param endTag\n+     */\n+    private void popStackToClose(Token.EndTag endTag) {\n+        String elName = endTag.name();\n+        Element firstFound = null;\n+\n+        Iterator<Element> it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next.nodeName().equals(elName)) {\n+                firstFound = next;\n+                break;\n+            }\n+        }\n+        if (firstFound == null)\n+            return; // not found, skip\n+\n+        it = stack.descendingIterator();\n+        while (it.hasNext()) {\n+            Element next = it.next();\n+            if (next == firstFound) {\n+                it.remove();\n+                break;\n+            } else {\n+                it.remove();\n+            }\n+        }\n+    }\n+}\n--- a/src/test/java/org/jsoup/helper/StringUtilTest.java\n+++ b/src/test/java/org/jsoup/helper/StringUtilTest.java\n \n import org.junit.Test;\n \n-import static org.junit.Assert.*;\n+import java.util.Arrays;\n \n-import java.util.Arrays;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n \n public class StringUtilTest {\n \n         assertTrue(StringUtil.isNumeric(\"1234\"));\n     }\n \n+    @Test public void isWhitespace() {\n+        assertTrue(StringUtil.isWhitespace('\\t'));\n+        assertTrue(StringUtil.isWhitespace('\\n'));\n+        assertTrue(StringUtil.isWhitespace('\\r'));\n+        assertTrue(StringUtil.isWhitespace('\\f'));\n+        assertTrue(StringUtil.isWhitespace(' '));\n+        \n+        assertFalse(StringUtil.isWhitespace('\\u00a0'));\n+        assertFalse(StringUtil.isWhitespace('\\u2000'));\n+        assertFalse(StringUtil.isWhitespace('\\u3000'));\n+    }\n+\n     @Test public void normaliseWhiteSpace() {\n         assertEquals(\" \", StringUtil.normaliseWhitespace(\"    \\r \\n \\r\\n\"));\n         assertEquals(\" hello there \", StringUtil.normaliseWhitespace(\"   hello   \\r \\n  there    \\n\"));\n--- a/src/test/java/org/jsoup/integration/UrlConnectTest.java\n+++ b/src/test/java/org/jsoup/integration/UrlConnectTest.java\n  @author Jonathan Hedley, jonathan@hedley.net */\n @Ignore // ignored by default so tests don't require network access. comment out to enable.\n public class UrlConnectTest {\n-    private static String echoURL = \"http://infohound.net/tools/q.pl\";\n+    private static String echoURL = \"http://direct.infohound.net/tools/q.pl\";\n \n     @Test\n     public void fetchURl() throws IOException {\n \n     @Test\n     public void followsTempRedirect() throws IOException {\n-        Connection con = Jsoup.connect(\"http://infohound.net/tools/302.pl\"); // http://jsoup.org\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302.pl\"); // http://jsoup.org\n         Document doc = con.get();\n         assertTrue(doc.title().contains(\"jsoup\"));\n     }\n \n     @Test\n     public void postRedirectsFetchWithGet() throws IOException {\n-        Connection con = Jsoup.connect(\"http://infohound.net/tools/302.pl\")\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302.pl\")\n                 .data(\"Argument\", \"Riposte\")\n                 .method(Connection.Method.POST);\n         Connection.Response res = con.execute();\n \n     @Test\n     public void followsRedirectToHttps() throws IOException {\n-        Connection con = Jsoup.connect(\"http://infohound.net/tools/302-secure.pl\"); // https://www.google.com\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302-secure.pl\"); // https://www.google.com\n         con.data(\"id\", \"5\");\n         Document doc = con.get();\n         assertTrue(doc.title().contains(\"Google\"));\n \n     @Test\n     public void followsRelativeRedirect() throws IOException {\n-        Connection con = Jsoup.connect(\"http://infohound.net/tools/302-rel.pl\"); // to ./ - /tools/\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302-rel.pl\"); // to ./ - /tools/\n         Document doc = con.post();\n         assertTrue(doc.title().contains(\"HTML Tidy Online\"));\n     }\n \n     @Test\n     public void ignoresExceptionIfSoConfigured() throws IOException {\n-        Connection con = Jsoup.connect(\"http://infohound.net/tools/404\").ignoreHttpErrors(true);\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/404\").ignoreHttpErrors(true);\n         Connection.Response res = con.execute();\n         Document doc = res.parse();\n         assertEquals(404, res.statusCode());\n \n     @Test\n     public void doesntRedirectIfSoConfigured() throws IOException {\n-        Connection con = Jsoup.connect(\"http://infohound.net/tools/302.pl\").followRedirects(false);\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302.pl\").followRedirects(false);\n         Connection.Response res = con.execute();\n         assertEquals(302, res.statusCode());\n         assertEquals(\"http://jsoup.org\", res.header(\"Location\"));\n \n     @Test\n     public void redirectsResponseCookieToNextResponse() throws IOException {\n-        Connection con = Jsoup.connect(\"http://infohound.net/tools/302-cookie.pl\");\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302-cookie.pl\");\n         Connection.Response res = con.execute();\n         assertEquals(\"asdfg123\", res.cookie(\"token\")); // confirms that cookies set on 1st hit are presented in final result\n         Document doc = res.parse();\n-        assertEquals(\"token=asdfg123\", ihVal(\"HTTP_COOKIE\", doc)); // confirms that redirected hit saw cookie\n+        assertEquals(\"uid=jhy; token=asdfg123\", ihVal(\"HTTP_COOKIE\", doc)); // confirms that redirected hit saw cookie\n     }\n \n     @Test\n     public void maximumRedirects() {\n         boolean threw = false;\n         try {\n-            Document doc = Jsoup.connect(\"http://infohound.net/tools/loop.pl\").get();\n+            Document doc = Jsoup.connect(\"http://direct.infohound.net/tools/loop.pl\").get();\n         } catch (IOException e) {\n             assertTrue(e.getMessage().contains(\"Too many redirects\"));\n             threw = true;\n \n     @Test\n     public void multiCookieSet() throws IOException {\n-        Connection con = Jsoup.connect(\"http://infohound.net/tools/302-cookie.pl\");\n+        Connection con = Jsoup.connect(\"http://direct.infohound.net/tools/302-cookie.pl\");\n         Connection.Response res = con.execute();\n \n         // test cookies set by redirect:\n--- /dev/null\n+++ b/src/test/java/org/jsoup/parser/HtmlParserTest.java\n+package org.jsoup.parser;\n+\n+import org.jsoup.Jsoup;\n+import org.jsoup.TextUtil;\n+import org.jsoup.nodes.Comment;\n+import org.jsoup.nodes.Document;\n+import org.jsoup.nodes.Element;\n+import org.jsoup.nodes.TextNode;\n+import org.jsoup.select.Elements;\n+import org.junit.Test;\n+\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ Tests for the Parser\n+\n+ @author Jonathan Hedley, jonathan@hedley.net */\n+public class HtmlParserTest {\n+\n+    @Test public void parsesSimpleDocument() {\n+        String html = \"<html><head><title>First!</title></head><body><p>First post! <img src=\\\"foo.png\\\" /></p></body></html>\";\n+        Document doc = Jsoup.parse(html);\n+        // need a better way to verify these:\n+        Element p = doc.body().child(0);\n+        assertEquals(\"p\", p.tagName());\n+        Element img = p.child(0);\n+        assertEquals(\"foo.png\", img.attr(\"src\"));\n+        assertEquals(\"img\", img.tagName());\n+    }\n+\n+    @Test public void parsesRoughAttributes() {\n+        String html = \"<html><head><title>First!</title></head><body><p class=\\\"foo > bar\\\">First post! <img src=\\\"foo.png\\\" /></p></body></html>\";\n+        Document doc = Jsoup.parse(html);\n+\n+        // need a better way to verify these:\n+        Element p = doc.body().child(0);\n+        assertEquals(\"p\", p.tagName());\n+        assertEquals(\"foo > bar\", p.attr(\"class\"));\n+    }\n+\n+    @Test public void parsesQuiteRoughAttributes() {\n+        String html = \"<p =a>One<a <p>Something</p>Else\";\n+        // this gets a <p> with attr '=a' and an <a tag with an attribue named '<p'; and then auto-recreated\n+        Document doc = Jsoup.parse(html);\n+        assertEquals(\"<p =a=\\\"\\\">One<a <p=\\\"\\\">Something</a></p>\\n\" +\n+                \"<a <p=\\\"\\\">Else</a>\", doc.body().html());\n+\n+        doc = Jsoup.parse(\"<p .....>\");\n+        assertEquals(\"<p .....=\\\"\\\"></p>\", doc.body().html());\n+    }\n+\n+    @Test public void parsesComments() {\n+        String html = \"<html><head></head><body><img src=foo><!-- <table><tr><td></table> --><p>Hello</p></body></html>\";\n+        Document doc = Jsoup.parse(html);\n+\n+        Element body = doc.body();\n+        Comment comment = (Comment) body.childNode(1); // comment should not be sub of img, as it's an empty tag\n+        assertEquals(\" <table><tr><td></table> \", comment.getData());\n+        Element p = body.child(1);\n+        TextNode text = (TextNode) p.childNode(0);\n+        assertEquals(\"Hello\", text.getWholeText());\n+    }\n+\n+    @Test public void parsesUnterminatedComments() {\n+        String html = \"<p>Hello<!-- <tr><td>\";\n+        Document doc = Jsoup.parse(html);\n+        Element p = doc.getElementsByTag(\"p\").get(0);\n+        assertEquals(\"Hello\", p.text());\n+        TextNode text = (TextNode) p.childNode(0);\n+        assertEquals(\"Hello\", text.getWholeText());\n+        Comment comment = (Comment) p.childNode(1);\n+        assertEquals(\" <tr><td>\", comment.getData());\n+    }\n+\n+    @Test public void dropsUnterminatedTag() {\n+        // jsoup used to parse this to <p>, but whatwg, webkit will drop.\n+        String h1 = \"<p\";\n+        Document doc = Jsoup.parse(h1);\n+        assertEquals(0, doc.getElementsByTag(\"p\").size());\n+        assertEquals(\"\", doc.text());\n+\n+        String h2 = \"<div id=1<p id='2'\";\n+        doc = Jsoup.parse(h2);\n+        assertEquals(\"\", doc.text());\n+    }\n+\n+    @Test public void dropsUnterminatedAttribute() {\n+        // jsoup used to parse this to <p id=\"foo\">, but whatwg, webkit will drop.\n+        String h1 = \"<p id=\\\"foo\";\n+        Document doc = Jsoup.parse(h1);\n+        assertEquals(\"\", doc.text());\n+    }\n+\n+    @Test public void parsesUnterminatedTextarea() {\n+        // don't parse right to end, but break on <p>\n+        Document doc = Jsoup.parse(\"<body><p><textarea>one<p>two\");\n+        Element t = doc.select(\"textarea\").first();\n+        assertEquals(\"one\", t.text());\n+        assertEquals(\"two\", doc.select(\"p\").get(1).text());\n+    }\n+\n+    @Test public void parsesUnterminatedOption() {\n+        // bit weird this -- browsers and spec get stuck in select until there's a </select>\n+        Document doc = Jsoup.parse(\"<body><p><select><option>One<option>Two</p><p>Three</p>\");\n+        Elements options = doc.select(\"option\");\n+        assertEquals(2, options.size());\n+        assertEquals(\"One\", options.first().text());\n+        assertEquals(\"TwoThree\", options.last().text());\n+    }\n+\n+    @Test public void testSpaceAfterTag() {\n+        Document doc = Jsoup.parse(\"<div > <a name=\\\"top\\\"></a ><p id=1 >Hello</p></div>\");\n+        assertEquals(\"<div> <a name=\\\"top\\\"></a><p id=\\\"1\\\">Hello</p></div>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void createsDocumentStructure() {\n+        String html = \"<meta name=keywords /><link rel=stylesheet /><title>jsoup</title><p>Hello world</p>\";\n+        Document doc = Jsoup.parse(html);\n+        Element head = doc.head();\n+        Element body = doc.body();\n+\n+        assertEquals(1, doc.children().size()); // root node: contains html node\n+        assertEquals(2, doc.child(0).children().size()); // html node: head and body\n+        assertEquals(3, head.children().size());\n+        assertEquals(1, body.children().size());\n+\n+        assertEquals(\"keywords\", head.getElementsByTag(\"meta\").get(0).attr(\"name\"));\n+        assertEquals(0, body.getElementsByTag(\"meta\").size());\n+        assertEquals(\"jsoup\", doc.title());\n+        assertEquals(\"Hello world\", body.text());\n+        assertEquals(\"Hello world\", body.children().get(0).text());\n+    }\n+\n+    @Test public void createsStructureFromBodySnippet() {\n+        // the bar baz stuff naturally goes into the body, but the 'foo' goes into root, and the normalisation routine\n+        // needs to move into the start of the body\n+        String html = \"foo <b>bar</b> baz\";\n+        Document doc = Jsoup.parse(html);\n+        assertEquals(\"foo bar baz\", doc.text());\n+\n+    }\n+\n+    @Test public void handlesEscapedData() {\n+        String html = \"<div title='Surf &amp; Turf'>Reef &amp; Beef</div>\";\n+        Document doc = Jsoup.parse(html);\n+        Element div = doc.getElementsByTag(\"div\").get(0);\n+\n+        assertEquals(\"Surf & Turf\", div.attr(\"title\"));\n+        assertEquals(\"Reef & Beef\", div.text());\n+    }\n+\n+    @Test public void handlesDataOnlyTags() {\n+        String t = \"<style>font-family: bold</style>\";\n+        List<Element> tels = Jsoup.parse(t).getElementsByTag(\"style\");\n+        assertEquals(\"font-family: bold\", tels.get(0).data());\n+        assertEquals(\"\", tels.get(0).text());\n+\n+        String s = \"<p>Hello</p><script>obj.insert('<a rel=\\\"none\\\" />');\\ni++;</script><p>There</p>\";\n+        Document doc = Jsoup.parse(s);\n+        assertEquals(\"Hello There\", doc.text());\n+        assertEquals(\"obj.insert('<a rel=\\\"none\\\" />');\\ni++;\", doc.data());\n+    }\n+\n+    @Test public void handlesTextAfterData() {\n+        String h = \"<html><body>pre <script>inner</script> aft</body></html>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<html><head></head><body>pre <script>inner</script> aft</body></html>\", TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test public void handlesTextArea() {\n+        Document doc = Jsoup.parse(\"<textarea>Hello</textarea>\");\n+        Elements els = doc.select(\"textarea\");\n+        assertEquals(\"Hello\", els.text());\n+        assertEquals(\"Hello\", els.val());\n+    }\n+\n+    @Test public void doesNotCreateImplicitLists() {\n+        // old jsoup used to wrap this in <ul>, but that's not to spec\n+        String h = \"<li>Point one<li>Point two\";\n+        Document doc = Jsoup.parse(h);\n+        Elements ol = doc.select(\"ul\"); // should NOT have created a default ul.\n+        assertEquals(0, ol.size());\n+        Elements lis = doc.select(\"li\");\n+        assertEquals(2, lis.size());\n+        assertEquals(\"body\", lis.first().parent().tagName());\n+\n+        // no fiddling with non-implicit lists\n+        String h2 = \"<ol><li><p>Point the first<li><p>Point the second\";\n+        Document doc2 = Jsoup.parse(h2);\n+\n+        assertEquals(0, doc2.select(\"ul\").size());\n+        assertEquals(1, doc2.select(\"ol\").size());\n+        assertEquals(2, doc2.select(\"ol li\").size());\n+        assertEquals(2, doc2.select(\"ol li p\").size());\n+        assertEquals(1, doc2.select(\"ol li\").get(0).children().size()); // one p in first li\n+    }\n+\n+    @Test public void discardsNakedTds() {\n+        // jsoup used to make this into an implicit table; but browsers make it into a text run\n+        String h = \"<td>Hello<td><p>There<p>now\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"Hello<p>There</p><p>now</p>\", TextUtil.stripNewlines(doc.body().html()));\n+        // <tbody> is introduced if no implicitly creating table, but allows tr to be directly under table\n+    }\n+\n+    @Test public void handlesNestedImplicitTable() {\n+        Document doc = Jsoup.parse(\"<table><td>1</td></tr> <td>2</td></tr> <td> <table><td>3</td> <td>4</td></table> <tr><td>5</table>\");\n+        assertEquals(\"<table><tbody><tr><td>1</td></tr> <tr><td>2</td></tr> <tr><td> <table><tbody><tr><td>3</td> <td>4</td></tr></tbody></table> </td></tr><tr><td>5</td></tr></tbody></table>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void handlesWhatWgExpensesTableExample() {\n+        // http://www.whatwg.org/specs/web-apps/current-work/multipage/tabular-data.html#examples-0\n+        Document doc = Jsoup.parse(\"<table> <colgroup> <col> <colgroup> <col> <col> <col> <thead> <tr> <th> <th>2008 <th>2007 <th>2006 <tbody> <tr> <th scope=rowgroup> Research and development <td> $ 1,109 <td> $ 782 <td> $ 712 <tr> <th scope=row> Percentage of net sales <td> 3.4% <td> 3.3% <td> 3.7% <tbody> <tr> <th scope=rowgroup> Selling, general, and administrative <td> $ 3,761 <td> $ 2,963 <td> $ 2,433 <tr> <th scope=row> Percentage of net sales <td> 11.6% <td> 12.3% <td> 12.6% </table>\");\n+        assertEquals(\"<table> <colgroup> <col /> </colgroup><colgroup> <col /> <col /> <col /> </colgroup><thead> <tr> <th> </th><th>2008 </th><th>2007 </th><th>2006 </th></tr></thead><tbody> <tr> <th scope=\\\"rowgroup\\\"> Research and development </th><td> $ 1,109 </td><td> $ 782 </td><td> $ 712 </td></tr><tr> <th scope=\\\"row\\\"> Percentage of net sales </th><td> 3.4% </td><td> 3.3% </td><td> 3.7% </td></tr></tbody><tbody> <tr> <th scope=\\\"rowgroup\\\"> Selling, general, and administrative </th><td> $ 3,761 </td><td> $ 2,963 </td><td> $ 2,433 </td></tr><tr> <th scope=\\\"row\\\"> Percentage of net sales </th><td> 11.6% </td><td> 12.3% </td><td> 12.6% </td></tr></tbody></table>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void handlesTbodyTable() {\n+        Document doc = Jsoup.parse(\"<html><head></head><body><table><tbody><tr><td>aaa</td><td>bbb</td></tr></tbody></table></body></html>\");\n+        assertEquals(\"<table><tbody><tr><td>aaa</td><td>bbb</td></tr></tbody></table>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void handlesImplicitCaptionClose() {\n+        Document doc = Jsoup.parse(\"<table><caption>A caption<td>One<td>Two\");\n+        assertEquals(\"<table><caption>A caption</caption><tbody><tr><td>One</td><td>Two</td></tr></tbody></table>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void noTableDirectInTable() {\n+        Document doc = Jsoup.parse(\"<table> <td>One <td><table><td>Two</table> <table><td>Three\");\n+        assertEquals(\"<table> <tbody><tr><td>One </td><td><table><tbody><tr><td>Two</td></tr></tbody></table> <table><tbody><tr><td>Three</td></tr></tbody></table></td></tr></tbody></table>\",\n+                TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void ignoresDupeEndTrTag() {\n+        Document doc = Jsoup.parse(\"<table><tr><td>One</td><td><table><tr><td>Two</td></tr></tr></table></td><td>Three</td></tr></table>\"); // two </tr></tr>, must ignore or will close table\n+        assertEquals(\"<table><tbody><tr><td>One</td><td><table><tbody><tr><td>Two</td></tr></tbody></table></td><td>Three</td></tr></tbody></table>\",\n+                TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void handlesBaseTags() {\n+        // only listen to the first base href\n+        String h = \"<a href=1>#</a><base href='/2/'><a href='3'>#</a><base href='http://bar'><a href=/4>#</a>\";\n+        Document doc = Jsoup.parse(h, \"http://foo/\");\n+        assertEquals(\"http://foo/2/\", doc.baseUri()); // gets set once, so doc and descendants have first only\n+\n+        Elements anchors = doc.getElementsByTag(\"a\");\n+        assertEquals(3, anchors.size());\n+\n+        assertEquals(\"http://foo/2/\", anchors.get(0).baseUri());\n+        assertEquals(\"http://foo/2/\", anchors.get(1).baseUri());\n+        assertEquals(\"http://foo/2/\", anchors.get(2).baseUri());\n+\n+        assertEquals(\"http://foo/2/1\", anchors.get(0).absUrl(\"href\"));\n+        assertEquals(\"http://foo/2/3\", anchors.get(1).absUrl(\"href\"));\n+        assertEquals(\"http://foo/4\", anchors.get(2).absUrl(\"href\"));\n+    }\n+\n+    @Test public void handlesCdata() {\n+        // todo: as this is html namespace, should actually treat as bogus comment, not cdata. keep as cdata for now\n+        String h = \"<div id=1><![CDATA[<html>\\n<foo><&amp;]]></div>\"; // the &amp; in there should remain literal\n+        Document doc = Jsoup.parse(h);\n+        Element div = doc.getElementById(\"1\");\n+        assertEquals(\"<html> <foo><&amp;\", div.text());\n+        assertEquals(0, div.children().size());\n+        assertEquals(1, div.childNodes().size()); // no elements, one text node\n+    }\n+\n+    @Test public void handlesInvalidStartTags() {\n+        String h = \"<div>Hello < There <&amp;></div>\"; // parse to <div {#text=Hello < There <&>}>\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"Hello < There <&>\", doc.select(\"div\").first().text());\n+    }\n+\n+    @Test public void handlesUnknownTags() {\n+        String h = \"<div><foo title=bar>Hello<foo title=qux>there</foo></div>\";\n+        Document doc = Jsoup.parse(h);\n+        Elements foos = doc.select(\"foo\");\n+        assertEquals(2, foos.size());\n+        assertEquals(\"bar\", foos.first().attr(\"title\"));\n+        assertEquals(\"qux\", foos.last().attr(\"title\"));\n+        assertEquals(\"there\", foos.last().text());\n+    }\n+\n+    @Test public void handlesUnknownInlineTags() {\n+        String h = \"<p><cust>Test</cust></p><p><cust><cust>Test</cust></cust></p>\";\n+        Document doc = Jsoup.parseBodyFragment(h);\n+        String out = doc.body().html();\n+        assertEquals(h, TextUtil.stripNewlines(out));\n+    }\n+\n+    @Test public void parsesBodyFragment() {\n+        String h = \"<!-- comment --><p><a href='foo'>One</a></p>\";\n+        Document doc = Jsoup.parseBodyFragment(h, \"http://example.com\");\n+        assertEquals(\"<body><!-- comment --><p><a href=\\\"foo\\\">One</a></p></body>\", TextUtil.stripNewlines(doc.body().outerHtml()));\n+        assertEquals(\"http://example.com/foo\", doc.select(\"a\").first().absUrl(\"href\"));\n+    }\n+\n+    @Test public void handlesUnknownNamespaceTags() {\n+        // note that the first foo:bar should not really be allowed to be self closing, if parsed in html mode.\n+        String h = \"<foo:bar id='1' /><abc:def id=2>Foo<p>Hello</p></abc:def><foo:bar>There</foo:bar>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<foo:bar id=\\\"1\\\" /><abc:def id=\\\"2\\\">Foo<p>Hello</p></abc:def><foo:bar>There</foo:bar>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void handlesKnownEmptyBlocks() {\n+        // if known tag, must be defined as self closing to allow as self closing. unkown tags can be self closing.\n+        String h = \"<div id='1' /><div id=2><img /><img></div> <hr /> hr text <hr> hr text two\";\n+        Document doc = Jsoup.parse(h);\n+        Element div1 = doc.getElementById(\"1\");\n+        assertTrue(!div1.children().isEmpty()); // <div /> is treated as <div>...\n+        assertTrue(doc.select(\"hr\").first().children().isEmpty());\n+        assertTrue(doc.select(\"hr\").last().children().isEmpty());\n+        assertTrue(doc.select(\"img\").first().children().isEmpty());\n+        assertTrue(doc.select(\"img\").last().children().isEmpty());\n+    }\n+\n+    @Test public void handlesSolidusAtAttributeEnd() {\n+        // this test makes sure [<a href=/>link</a>] is parsed as [<a href=\"/\">link</a>], not [<a href=\"\" /><a>link</a>]\n+        String h = \"<a href=/>link</a>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<a href=\\\"/\\\">link</a>\", doc.body().html());\n+    }\n+\n+    @Test public void handlesMultiClosingBody() {\n+        String h = \"<body><p>Hello</body><p>there</p></body></body></html><p>now\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(3, doc.select(\"p\").size());\n+        assertEquals(3, doc.body().children().size());\n+    }\n+\n+    @Test public void handlesUnclosedDefinitionLists() {\n+        // jsoup used to create a <dl>, but that's not to spec\n+        String h = \"<dt>Foo<dd>Bar<dt>Qux<dd>Zug\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(0, doc.select(\"dl\").size()); // no auto dl\n+        assertEquals(4, doc.select(\"dt, dd\").size());\n+        Elements dts = doc.select(\"dt\");\n+        assertEquals(2, dts.size());\n+        assertEquals(\"Zug\", dts.get(1).nextElementSibling().text());\n+    }\n+\n+    @Test public void handlesBlocksInDefinitions() {\n+        // per the spec, dt and dd are inline, but in practise are block\n+        String h = \"<dl><dt><div id=1>Term</div></dt><dd><div id=2>Def</div></dd></dl>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"dt\", doc.select(\"#1\").first().parent().tagName());\n+        assertEquals(\"dd\", doc.select(\"#2\").first().parent().tagName());\n+        assertEquals(\"<dl><dt><div id=\\\"1\\\">Term</div></dt><dd><div id=\\\"2\\\">Def</div></dd></dl>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void handlesFrames() {\n+        String h = \"<html><head><script></script><noscript></noscript></head><frameset><frame src=foo></frame><frame src=foo></frameset></html>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<html><head><script></script><noscript></noscript></head><frameset><frame src=\\\"foo\\\" /><frame src=\\\"foo\\\" /></frameset></html>\",\n+                TextUtil.stripNewlines(doc.html()));\n+        // no body auto vivification\n+    }\n+\n+    @Test public void handlesJavadocFont() {\n+        String h = \"<TD BGCOLOR=\\\"#EEEEFF\\\" CLASS=\\\"NavBarCell1\\\">    <A HREF=\\\"deprecated-list.html\\\"><FONT CLASS=\\\"NavBarFont1\\\"><B>Deprecated</B></FONT></A>&nbsp;</TD>\";\n+        Document doc = Jsoup.parse(h);\n+        Element a = doc.select(\"a\").first();\n+        assertEquals(\"Deprecated\", a.text());\n+        assertEquals(\"font\", a.child(0).tagName());\n+        assertEquals(\"b\", a.child(0).child(0).tagName());\n+    }\n+\n+    @Test public void handlesBaseWithoutHref() {\n+        String h = \"<head><base target='_blank'></head><body><a href=/foo>Test</a></body>\";\n+        Document doc = Jsoup.parse(h, \"http://example.com/\");\n+        Element a = doc.select(\"a\").first();\n+        assertEquals(\"/foo\", a.attr(\"href\"));\n+        assertEquals(\"http://example.com/foo\", a.attr(\"abs:href\"));\n+    }\n+\n+    @Test public void normalisesDocument() {\n+        String h = \"<!doctype html>One<html>Two<head>Three<link></head>Four<body>Five </body>Six </html>Seven \";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<!DOCTYPE html><html><head></head><body>OneTwoThree<link />FourFive Six Seven </body></html>\",\n+                TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test public void normalisesEmptyDocument() {\n+        Document doc = Jsoup.parse(\"\");\n+        assertEquals(\"<html><head></head><body></body></html>\", TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test public void normalisesHeadlessBody() {\n+        Document doc = Jsoup.parse(\"<html><body><span class=\\\"foo\\\">bar</span>\");\n+        assertEquals(\"<html><head></head><body><span class=\\\"foo\\\">bar</span></body></html>\",\n+                TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test public void normalisedBodyAfterContent() {\n+        Document doc = Jsoup.parse(\"<font face=Arial><body class=name><div>One</div></body></font>\");\n+        assertEquals(\"<html><head></head><body class=\\\"name\\\"><font face=\\\"Arial\\\"><div>One</div></font></body></html>\",\n+                TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test public void findsCharsetInMalformedMeta() {\n+        String h = \"<meta http-equiv=Content-Type content=text/html; charset=gb2312>\";\n+        // example cited for reason of html5's <meta charset> element\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"gb2312\", doc.select(\"meta\").attr(\"charset\"));\n+    }\n+\n+    @Test public void testHgroup() {\n+        // jsoup used to not allow hroup in h{n}, but that's not in spec, and browsers are OK\n+        Document doc = Jsoup.parse(\"<h1>Hello <h2>There <hgroup><h1>Another<h2>headline</hgroup> <hgroup><h1>More</h1><p>stuff</p></hgroup>\");\n+        assertEquals(\"<h1>Hello </h1><h2>There <hgroup><h1>Another</h1><h2>headline</h2></hgroup> <hgroup><h1>More</h1><p>stuff</p></hgroup></h2>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void testRelaxedTags() {\n+        Document doc = Jsoup.parse(\"<abc_def id=1>Hello</abc_def> <abc-def>There</abc-def>\");\n+        assertEquals(\"<abc_def id=\\\"1\\\">Hello</abc_def> <abc-def>There</abc-def>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void testHeaderContents() {\n+        // h* tags (h1 .. h9) in browsers can handle any internal content other than other h*. which is not per any\n+        // spec, which defines them as containing phrasing content only. so, reality over theory.\n+        Document doc = Jsoup.parse(\"<h1>Hello <div>There</div> now</h1> <h2>More <h3>Content</h3></h2>\");\n+        assertEquals(\"<h1>Hello <div>There</div> now</h1> <h2>More </h2><h3>Content</h3>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void testSpanContents() {\n+        // like h1 tags, the spec says SPAN is phrasing only, but browsers and publisher treat span as a block tag\n+        Document doc = Jsoup.parse(\"<span>Hello <div>there</div> <span>now</span></span>\");\n+        assertEquals(\"<span>Hello <div>there</div> <span>now</span></span>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void testNoImagesInNoScriptInHead() {\n+        // jsoup used to allow, but against spec if parsing with noscript\n+        Document doc = Jsoup.parse(\"<html><head><noscript><img src='foo'></noscript></head><body><p>Hello</p></body></html>\");\n+        assertEquals(\"<html><head><noscript></noscript></head><body><img src=\\\"foo\\\" /><p>Hello</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test public void testAFlowContents() {\n+        // html5 has <a> as either phrasing or block\n+        Document doc = Jsoup.parse(\"<a>Hello <div>there</div> <span>now</span></a>\");\n+        assertEquals(\"<a>Hello <div>there</div> <span>now</span></a>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void testFontFlowContents() {\n+        // html5 has no definition of <font>; often used as flow\n+        Document doc = Jsoup.parse(\"<font>Hello <div>there</div> <span>now</span></font>\");\n+        assertEquals(\"<font>Hello <div>there</div> <span>now</span></font>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void handlesMisnestedTagsBI() {\n+        // whatwg: <b><i></b></i>\n+        String h = \"<p>1<b>2<i>3</b>4</i>5</p>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<p>1<b>2<i>3</i></b><i>4</i>5</p>\", doc.body().html());\n+        // adoption agency on </b>, reconstruction of formatters on 4.\n+    }\n+\n+    @Test public void handlesMisnestedTagsBP() {\n+        //  whatwg: <b><p></b></p>\n+        String h = \"<b>1<p>2</b>3</p>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<b>1</b>\\n<p><b>2</b>3</p>\", doc.body().html());\n+    }\n+\n+    @Test public void handlesUnexpectedMarkupInTables() {\n+        // whatwg - tests markers in active formatting (if they didn't work, would get in in table)\n+        // also tests foster parenting\n+        String h = \"<table><b><tr><td>aaa</td></tr>bbb</table>ccc\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<b></b><b>bbb</b><table><tbody><tr><td>aaa</td></tr></tbody></table><b>ccc</b>\", TextUtil.stripNewlines(doc.body().html()));\n+    }\n+\n+    @Test public void handlesUnclosedFormattingElements() {\n+        // whatwg: formatting elements get collected and applied, but excess elements are thrown away\n+        String h = \"<!DOCTYPE html>\\n\" +\n+                \"<p><b class=x><b class=x><b><b class=x><b class=x><b>X\\n\" +\n+                \"<p>X\\n\" +\n+                \"<p><b><b class=x><b>X\\n\" +\n+                \"<p></b></b></b></b></b></b>X\";\n+        Document doc = Jsoup.parse(h);\n+        doc.outputSettings().indentAmount(0);\n+        String want = \"<!DOCTYPE html>\\n\" +\n+                \"<html>\\n\" +\n+                \"<head></head>\\n\" +\n+                \"<body>\\n\" +\n+                \"<p><b class=\\\"x\\\"><b class=\\\"x\\\"><b><b class=\\\"x\\\"><b class=\\\"x\\\"><b>X </b></b></b></b></b></b></p>\\n\" +\n+                \"<p><b class=\\\"x\\\"><b><b class=\\\"x\\\"><b class=\\\"x\\\"><b>X </b></b></b></b></b></p>\\n\" +\n+                \"<p><b class=\\\"x\\\"><b><b class=\\\"x\\\"><b class=\\\"x\\\"><b><b><b class=\\\"x\\\"><b>X </b></b></b></b></b></b></b></b></p>\\n\" +\n+                \"<p>X</p>\\n\" +\n+                \"</body>\\n\" +\n+                \"</html>\";\n+        assertEquals(want, doc.html());\n+    }\n+\n+    @Test public void reconstructFormattingElements() {\n+        // tests attributes and multi b\n+        String h = \"<p><b class=one>One <i>Two <b>Three</p><p>Hello</p>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<p><b class=\\\"one\\\">One <i>Two <b>Three</b></i></b></p>\\n<p><b class=\\\"one\\\"><i><b>Hello</b></i></b></p>\", doc.body().html());\n+    }\n+\n+    @Test public void reconstructFormattingElementsInTable() {\n+        // tests that tables get formatting markers -- the <b> applies outside the table and does not leak in,\n+        // and the <i> inside the table and does not leak out.\n+        String h = \"<p><b>One</p> <table><tr><td><p><i>Three<p>Four</i></td></tr></table> <p>Five</p>\";\n+        Document doc = Jsoup.parse(h);\n+        String want = \"<p><b>One</b></p>\\n\" +\n+                \"<b> \\n\" +\n+                \" <table>\\n\" +\n+                \"  <tbody>\\n\" +\n+                \"   <tr>\\n\" +\n+                \"    <td><p><i>Three</i></p><p><i>Four</i></p></td>\\n\" +\n+                \"   </tr>\\n\" +\n+                \"  </tbody>\\n\" +\n+                \" </table> <p>Five</p></b>\";\n+        assertEquals(want, doc.body().html());\n+    }\n+\n+    @Test public void commentBeforeHtml() {\n+        String h = \"<!-- comment --><!-- comment 2 --><p>One</p>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<!-- comment --><!-- comment 2 --><html><head></head><body><p>One</p></body></html>\", TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test public void emptyTdTag() {\n+        String h = \"<table><tr><td>One</td><td id='2' /></tr></table>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(\"<td>One</td>\\n<td id=\\\"2\\\"></td>\", doc.select(\"tr\").first().html());\n+    }\n+\n+    @Test public void handlesSolidusInA() {\n+        // test for bug #66\n+        String h = \"<a class=lp href=/lib/14160711/>link text</a>\";\n+        Document doc = Jsoup.parse(h);\n+        Element a = doc.select(\"a\").first();\n+        assertEquals(\"link text\", a.text());\n+        assertEquals(\"/lib/14160711/\", a.attr(\"href\"));\n+    }\n+\n+    @Test public void handlesSpanInTbody() {\n+        // test for bug 64\n+        String h = \"<table><tbody><span class='1'><tr><td>One</td></tr><tr><td>Two</td></tr></span></tbody></table>\";\n+        Document doc = Jsoup.parse(h);\n+        assertEquals(doc.select(\"span\").first().children().size(), 0); // the span gets closed\n+        assertEquals(doc.select(\"table\").size(), 1); // only one table\n+    }\n+\n+    @Test public void handlesUnclosedTitleAtEof() {\n+        assertEquals(\"Data\", Jsoup.parse(\"<title>Data\").title());\n+        assertEquals(\"Data<\", Jsoup.parse(\"<title>Data<\").title());\n+        assertEquals(\"Data</\", Jsoup.parse(\"<title>Data</\").title());\n+        assertEquals(\"Data</t\", Jsoup.parse(\"<title>Data</t\").title());\n+        assertEquals(\"Data</ti\", Jsoup.parse(\"<title>Data</ti\").title());\n+        assertEquals(\"Data\", Jsoup.parse(\"<title>Data</title>\").title());\n+        assertEquals(\"Data\", Jsoup.parse(\"<title>Data</title >\").title());\n+    }\n+\n+    @Test public void handlesUnclosedTitle() {\n+        Document one = Jsoup.parse(\"<title>One <b>Two <b>Three</TITLE><p>Test</p>\"); // has title, so <b> is plain text\n+        assertEquals(\"One <b>Two <b>Three\", one.title());\n+        assertEquals(\"Test\", one.select(\"p\").first().text());\n+\n+        Document two = Jsoup.parse(\"<title>One<b>Two <p>Test</p>\"); // no title, so <b> causes </title> breakout\n+        assertEquals(\"One\", two.title());\n+        assertEquals(\"<b>Two <p>Test</p></b>\", two.body().html());\n+    }\n+\n+    @Test public void handlesUnclosedScriptAtEof() {\n+        assertEquals(\"Data\", Jsoup.parse(\"<script>Data\").select(\"script\").first().data());\n+        assertEquals(\"Data<\", Jsoup.parse(\"<script>Data<\").select(\"script\").first().data());\n+        assertEquals(\"Data</sc\", Jsoup.parse(\"<script>Data</sc\").select(\"script\").first().data());\n+        assertEquals(\"Data</-sc\", Jsoup.parse(\"<script>Data</-sc\").select(\"script\").first().data());\n+        assertEquals(\"Data</sc-\", Jsoup.parse(\"<script>Data</sc-\").select(\"script\").first().data());\n+        assertEquals(\"Data</sc--\", Jsoup.parse(\"<script>Data</sc--\").select(\"script\").first().data());\n+        assertEquals(\"Data\", Jsoup.parse(\"<script>Data</script>\").select(\"script\").first().data());\n+        assertEquals(\"Data</script\", Jsoup.parse(\"<script>Data</script\").select(\"script\").first().data());\n+        assertEquals(\"Data\", Jsoup.parse(\"<script>Data</script \").select(\"script\").first().data());\n+        assertEquals(\"Data\", Jsoup.parse(\"<script>Data</script n\").select(\"script\").first().data());\n+        assertEquals(\"Data\", Jsoup.parse(\"<script>Data</script n=\").select(\"script\").first().data());\n+        assertEquals(\"Data\", Jsoup.parse(\"<script>Data</script n=\\\"\").select(\"script\").first().data());\n+        assertEquals(\"Data\", Jsoup.parse(\"<script>Data</script n=\\\"p\").select(\"script\").first().data());\n+    }\n+\n+    @Test public void handlesUnclosedRawtextAtEof() {\n+        assertEquals(\"Data\", Jsoup.parse(\"<style>Data\").select(\"style\").first().data());\n+        assertEquals(\"Data</st\", Jsoup.parse(\"<style>Data</st\").select(\"style\").first().data());\n+        assertEquals(\"Data\", Jsoup.parse(\"<style>Data</style>\").select(\"style\").first().data());\n+        assertEquals(\"Data</style\", Jsoup.parse(\"<style>Data</style\").select(\"style\").first().data());\n+        assertEquals(\"Data</-style\", Jsoup.parse(\"<style>Data</-style\").select(\"style\").first().data());\n+        assertEquals(\"Data</style-\", Jsoup.parse(\"<style>Data</style-\").select(\"style\").first().data());\n+        assertEquals(\"Data</style--\", Jsoup.parse(\"<style>Data</style--\").select(\"style\").first().data());\n+    }\n+\n+    @Test public void noImplicitFormForTextAreas() {\n+        // old jsoup parser would create implicit forms for form children like <textarea>, but no more\n+        Document doc = Jsoup.parse(\"<textarea>One</textarea>\");\n+        assertEquals(\"<textarea>One</textarea>\", doc.body().html());\n+    }\n+\n+    @Test public void handlesEscapedScript() {\n+        Document doc = Jsoup.parse(\"<script><!-- one <script>Blah</script> --></script>\");\n+        assertEquals(\"<!-- one <script>Blah</script> -->\", doc.select(\"script\").first().data());\n+    }\n+\n+    @Test public void handles0CharacterAsText() {\n+        Document doc = Jsoup.parse(\"0<p>0</p>\");\n+        assertEquals(\"0\\n<p>0</p>\", doc.body().html());\n+    }\n+\n+    @Test public void handlesNullInData() {\n+        Document doc = Jsoup.parse(\"<p id=\\u0000>Blah \\u0000</p>\");\n+        assertEquals(\"<p id=\\\"\\uFFFD\\\">Blah \\u0000</p>\", doc.body().html()); // replaced in attr, NOT replaced in data\n+    }\n+\n+    @Test public void handlesNullInComments() {\n+        Document doc = Jsoup.parse(\"<body><!-- \\u0000 \\u0000 -->\");\n+        assertEquals(\"<!-- \\uFFFD \\uFFFD -->\", doc.body().html());\n+    }\n+\n+    @Test public void handlesNewlinesAndWhitespaceInTag() {\n+        Document doc = Jsoup.parse(\"<a \\n href=\\\"one\\\" \\r\\n id=\\\"two\\\" \\f >\");\n+        assertEquals(\"<a href=\\\"one\\\" id=\\\"two\\\"></a>\", doc.body().html());\n+    }\n+\n+    @Test public void handlesWhitespaceInoDocType() {\n+        String html = \"<!DOCTYPE html\\n\" +\n+                \"      PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\"\\n\" +\n+                \"      \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\";\n+        Document doc = Jsoup.parse(html);\n+        assertEquals(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\", doc.childNode(0).outerHtml());\n+    }\n+    \n+    @Test public void tracksErrorsWhenRequested() {\n+        String html = \"<p>One</p href='no'><!DOCTYPE html>&arrgh;<font /><br /><foo\";\n+        Parser parser = Parser.htmlParser().setTrackErrors(true);\n+        Document doc = parser.parseInput(html, \"http://example.com\");\n+        \n+        List<ParseError> errors = parser.getErrors();\n+        assertEquals(5, errors.size());\n+        assertEquals(\"20: Attributes incorrectly present on end tag\", errors.get(0).toString());\n+        assertEquals(\"35: Unexpected token [Doctype] when in state [InBody]\", errors.get(1).toString());\n+        assertEquals(\"36: Invalid character reference: invalid named referenece 'arrgh'\", errors.get(2).toString());\n+        assertEquals(\"50: Self closing flag not acknowledged\", errors.get(3).toString());\n+        assertEquals(\"61: Unexpectedly reached end of file (EOF) in input state [TagName]\", errors.get(4).toString());\n+    }\n+\n+    @Test public void noErrorsByDefault() {\n+        String html = \"<p>One</p href='no'>&arrgh;<font /><br /><foo\";\n+        Parser parser = Parser.htmlParser();\n+        Document doc = parser.parseInput(html, \"http://example.com\");\n+\n+        List<ParseError> errors = parser.getErrors();\n+        assertNull(errors);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java\n+package org.jsoup.parser;\n+\n+import org.jsoup.Jsoup;\n+import org.jsoup.TextUtil;\n+import org.jsoup.nodes.Document;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URISyntaxException;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotSame;\n+\n+/**\n+ * Tests XmlTreeBuilder.\n+ *\n+ * @author Jonathan Hedley\n+ */\n+public class XmlTreeBuilderTest {\n+    @Test\n+    public void testSimpleXmlParse() {\n+        String xml = \"<doc id=2 href='/bar'>Foo <br /><link>One</link><link>Two</link></doc>\";\n+        XmlTreeBuilder tb = new XmlTreeBuilder();\n+        Document doc = tb.parse(xml, \"http://foo.com/\");\n+        assertEquals(\"<doc id=\\\"2\\\" href=\\\"/bar\\\">Foo <br /><link>One</link><link>Two</link></doc>\",\n+                TextUtil.stripNewlines(doc.html()));\n+        assertEquals(doc.getElementById(\"2\").absUrl(\"href\"), \"http://foo.com/bar\");\n+    }\n+\n+    @Test\n+    public void testPopToClose() {\n+        // test: </val> closes Two, </bar> ignored\n+        String xml = \"<doc><val>One<val>Two</val></bar>Three</doc>\";\n+        XmlTreeBuilder tb = new XmlTreeBuilder();\n+        Document doc = tb.parse(xml, \"http://foo.com/\");\n+        assertEquals(\"<doc><val>One<val>Two</val>Three</val></doc>\",\n+                TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test\n+    public void testCommentAndDocType() {\n+        String xml = \"<!DOCTYPE html><!-- a comment -->One <qux />Two\";\n+        XmlTreeBuilder tb = new XmlTreeBuilder();\n+        Document doc = tb.parse(xml, \"http://foo.com/\");\n+        assertEquals(\"<!DOCTYPE html><!-- a comment -->One <qux />Two\",\n+                TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test\n+    public void testSupplyParserToJsoupClass() {\n+        String xml = \"<doc><val>One<val>Two</val></bar>Three</doc>\";\n+        Document doc = Jsoup.parse(xml, \"http://foo.com/\", Parser.xmlParser());\n+        assertEquals(\"<doc><val>One<val>Two</val>Three</val></doc>\",\n+                TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Ignore\n+    @Test\n+    public void testSupplyParserToConnection() throws IOException {\n+        String xmlUrl = \"http://direct.infohound.net/tools/jsoup-xml-test.xml\";\n+\n+        // parse with both xml and html parser, ensure different\n+        Document xmlDoc = Jsoup.connect(xmlUrl).parser(Parser.xmlParser()).get();\n+        Document htmlDoc = Jsoup.connect(xmlUrl).get();\n+\n+        assertEquals(\"<doc><val>One<val>Two</val>Three</val></doc>\",\n+                TextUtil.stripNewlines(xmlDoc.html()));\n+        assertNotSame(htmlDoc, xmlDoc);\n+        assertEquals(1, htmlDoc.select(\"head\").size()); // html parser normalises\n+        assertEquals(0, xmlDoc.select(\"head\").size()); // xml parser does not\n+    }\n+\n+    @Test\n+    public void testSupplyParserToDataStream() throws IOException, URISyntaxException {\n+        File xmlFile = new File(XmlTreeBuilder.class.getResource(\"/htmltests/xml-test.xml\").toURI());\n+        InputStream inStream = new FileInputStream(xmlFile);\n+        Document doc = Jsoup.parse(inStream, null, \"http://foo.com\", Parser.xmlParser());\n+        assertEquals(\"<doc><val>One<val>Two</val>Three</val></doc>\",\n+                TextUtil.stripNewlines(doc.html()));\n+    }\n+\n+    @Test\n+    public void testDoesNotForceSelfClosingKnownTags() {\n+        // html will force \"<br>one</br>\" to \"<br />One<br />\". XML should be stay \"<br>one</br> -- don't recognise tag.\n+        Document htmlDoc = Jsoup.parse(\"<br>one</br>\");\n+        assertEquals(\"<br />one\\n<br />\", htmlDoc.body().html());\n+\n+        Document xmlDoc = Jsoup.parse(\"<br>one</br>\", \"\", Parser.xmlParser());\n+        assertEquals(\"<br>one</br>\", xmlDoc.html());\n+    }\n+}", "timestamp": 1332297949, "metainfo": ""}