{"sha": "41628fa07748c93f043eb3657ba34a085745bfee", "log": "Added support for deserializing unwrapped Lists; introduces 2 new failures, need to fix.", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/ElementWrapper.java\n+package com.fasterxml.jackson.dataformat.xml.deser;\n+\n+/**\n+ * Helper class needed to keep track of virtual wrapper elements\n+ * added in the logical XML token stream.\n+ */\n+class ElementWrapper\n+{\n+    protected final ElementWrapper _parent;\n+    protected final String _wrapperName;\n+    protected final String _wrapperNamespace;\n+\n+    public ElementWrapper(ElementWrapper parent) {\n+        _parent = parent;\n+        _wrapperName = null;\n+        _wrapperNamespace = \"\";\n+    }\n+    \n+    public ElementWrapper(ElementWrapper parent,\n+            String wrapperLocalName, String wrapperNamespace)\n+    {\n+        _parent = parent;\n+        _wrapperName = wrapperLocalName;\n+        _wrapperNamespace = (wrapperNamespace == null) ? \"\" : wrapperNamespace;\n+    }\n+\n+    public String getWrapperLocalName() { return _wrapperName; }\n+    public String getWrapperNamespace() { return _wrapperNamespace; }\n+\n+    public ElementWrapper getParent() { return _parent; }\n+\n+    public boolean matchesWrapper(String localName, String ns)\n+    {\n+        // null means \"anything goes\", so:\n+        if (_wrapperName == null) {\n+            return true;\n+        }\n+        if (ns == null) {\n+            ns = \"\";\n+        }\n+        return _wrapperName.equals(localName) && _wrapperNamespace.equals(ns);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n             String name = _xmlTokens.getLocalName();\n             _parsingContext.setCurrentName(name);\n \n+            /* Ok: virtual wrapping can be done by simply repeating\n+             * current START_ELEMENT. Couple of ways to do it; but\n+             * start by making _xmlTokens replay the thing...\n+             */\n             if (_namesToWrap != null && _namesToWrap.contains(name)) {\n-//                System.err.println(\"VOILA! Wrap '\"+name+\"'!\");\n+                _xmlTokens.repeatStartElement();\n             }\n \n             _mayBeLeaf = true;\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n import com.fasterxml.jackson.databind.deser.std.DelegatingDeserializer;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.jsontype.TypeDeserializer;\n+import com.fasterxml.jackson.dataformat.xml.util.TypeUtil;\n \n /**\n  * Delegating deserializer whose only function is to handle case of\n              * (not perfect check, but simplest reasonable check)\n              */\n             JavaType type = prop.getType();\n-            if (!(type.isArrayType() || type.isCollectionLikeType())) {\n+            if (!TypeUtil.isIndexedType(type)) {\n                 continue;\n             }\n             AnnotatedMember acc = prop.getMember();\n         if (unwrappedNames == null) {\n             return newDelegatee;\n         }\n+//System.out.println(\"Unwrapped for (): \"+unwrappedNames);       \n         // Otherwise, create the thing that can deal with virtual wrapping\n         return new WrapperHandlingDeserializer(newDelegatee, unwrappedNames);\n     }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n     protected String _namespaceURI;\n \n     protected String _textValue;\n+\n+    /*\n+    /**********************************************************************\n+    /* State for handling virtual wrapping\n+    /**********************************************************************\n+     */\n+    \n+    /**\n+     * Status flag used to \"replay\" current event\n+     */\n+    protected boolean _repeatElement;\n+\n+    /**\n+     * Wrapping state, if any active (null if none)\n+     */\n+    protected ElementWrapper _currentWrapper;\n     \n     /*\n     /**********************************************************************\n     public XMLStreamReader2 getXmlReader() {\n         return _xmlReader;\n     }\n-    \n+\n     /*\n     /**********************************************************************\n     /* Public API\n \n     public int next() throws IOException \n     {\n+        if (_repeatElement) {\n+            _repeatElement = false;\n+            // important: add the virtual element second time, but not with name to match\n+            _currentWrapper = new ElementWrapper(_currentWrapper);\n+            return _currentState;\n+        }\n+        \n         try {\n             return _next();\n         } catch (XMLStreamException e) {\n     }\n     public JsonLocation getTokenLocation() {\n         return _extractLocation(_xmlReader.getLocationInfo().getStartLocation());\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Internal API: more esoteric methods\n+    /**********************************************************************\n+     */\n+    \n+    protected void repeatStartElement()\n+    {\n+        // sanity check: can only be used when just returned START_ELEMENT:\n+        if (_currentState != XML_START_ELEMENT) {\n+            throw new IllegalStateException(\"Current state not XML_START_ELEMENT (\"\n+                    +XML_START_ELEMENT+\") but \"+_currentState);\n+        }\n+        // Important: add wrapper, to keep track...\n+        _currentWrapper = new ElementWrapper(_currentWrapper, _localName, _namespaceURI);\n+        _repeatElement = true;\n     }\n \n     /*\n                 _textValue = text;\n                 return (_currentState = XML_TEXT);\n             }\n-            return (_currentState = XML_END_ELEMENT);\n+            return _handleEndElement();\n         case XML_ATTRIBUTE_NAME:\n             // if we just returned name, will need to just send value next\n             return (_currentState = XML_ATTRIBUTE_VALUE);\n         case XML_TEXT:\n             // text is always followed by END_ELEMENT\n-            return (_currentState = XML_END_ELEMENT);\n+            return _handleEndElement();\n         }\n \n         // Ok: must be END_ELEMENT; see what tag we get (or end)\n         case XMLStreamConstants.END_DOCUMENT:\n             return (_currentState = XML_END);\n         case XMLStreamConstants.END_ELEMENT:\n-            return (_currentState = XML_END_ELEMENT);\n+            return _handleEndElement();\n         }\n         // START_ELEMENT...\n         return _initStartElement();\n     \n     private final int _initStartElement() throws XMLStreamException\n     {\n+        final String ns = _xmlReader.getNamespaceURI();\n+        final String localName = _xmlReader.getLocalName();\n         _nextAttributeIndex = 0;\n+        /* Support for virtual wrapping: in wrapping, may either\n+         * create a new wrapper scope (if in sub-tree, or matches\n+         * wrapper element itself), or implicitly close existing\n+         * scope.\n+         */\n+        if (_currentWrapper != null) {\n+            if (_currentWrapper.matchesWrapper(localName, ns)) {\n+                _currentWrapper = new ElementWrapper(_currentWrapper, localName, ns);\n+            } else {\n+                // implicit end is more interesting:\n+                _localName = _currentWrapper.getWrapperLocalName();\n+                _currentWrapper = _currentWrapper.getParent();\n+                return (_currentState = XML_END_ELEMENT);\n+            }\n+        }\n         _attributeCount = _xmlReader.getAttributeCount();\n-        _localName = _xmlReader.getLocalName();\n-        _namespaceURI = _xmlReader.getNamespaceURI();\n+        _localName = localName;\n+        _namespaceURI = ns;\n         return (_currentState = XML_START_ELEMENT);\n+    }\n+\n+    private final int _handleEndElement()\n+    {\n+        if (_currentWrapper != null) {\n+            _currentWrapper = _currentWrapper.getParent();\n+        }\n+        return (_currentState = XML_END_ELEMENT);\n     }\n     \n     private JsonLocation _extractLocation(XMLStreamLocation2 location)\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n package com.fasterxml.jackson.dataformat.xml.ser;\n \n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n \n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.introspect.AnnotatedMember;\n import com.fasterxml.jackson.databind.ser.*;\n import com.fasterxml.jackson.databind.ser.std.BeanSerializerBase;\n import com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil;\n+import com.fasterxml.jackson.dataformat.xml.util.TypeUtil;\n import com.fasterxml.jackson.dataformat.xml.util.XmlInfo;\n \n /**\n             // Actually: if we have a Collection type, easiest place to add wrapping would be here...\n             //  or: let's also allow wrapping of \"untyped\" (Object): assuming it is a dynamically\n             //   typed Collection...\n-            if (_isContainerType(bpw.getType())) {\n+            if (TypeUtil.isIndexedType(bpw.getType())) {\n                 String localName = null, wrapperNs = null;\n \n                 PropertyName wrappedName = PropertyName.construct(bpw.getName(), ns);\n         }\n         return new XmlBeanSerializer((BeanSerializerBase) serializer);\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper methods\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * Helper method used for figuring out if given raw type is a collection (\"indexed\") type;\n-     * in which case a wrapper element is typically added.\n-     */\n-    private static boolean _isContainerType(JavaType type)\n-    {\n-        if (type.isContainerType()) {\n-            Class<?> cls = type.getRawClass();\n-            // One special case; byte[] will be serialized as base64-encoded String, not real array, so:\n-            // (actually, ditto for char[]; thought to be a String)\n-            if (cls == byte[].class || cls == byte[].class) {\n-                return false;\n-            }\n-            // issue#5: also, should not add wrapping for Maps\n-            if (Map.class.isAssignableFrom(cls)) {\n-                return false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }    \n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/TypeUtil.java\n+package com.fasterxml.jackson.dataformat.xml.util;\n+\n+import java.util.Map;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+\n+public class TypeUtil\n+{\n+    /**\n+     * Helper method used for figuring out if given raw type is a collection (\"indexed\") type;\n+     * in which case a wrapper element is typically added.\n+     */\n+    public static boolean isIndexedType(JavaType type)\n+    {\n+        if (type.isContainerType()) {\n+            Class<?> cls = type.getRawClass();\n+            // One special case; byte[] will be serialized as base64-encoded String, not real array, so:\n+            // (actually, ditto for char[]; thought to be a String)\n+            if (cls == byte[].class || cls == byte[].class) {\n+                return false;\n+            }\n+            // issue#5: also, should not add wrapping for Maps\n+            if (Map.class.isAssignableFrom(cls)) {\n+                return false;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }    \n+\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/TestViews.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestViews.java\n \n         String xml = xmlMapper.writerWithView(RestrictedView.class).writeValueAsString(foo);\n \n+System.out.println(\"XML == \"+xml);        \n+        \n         // views not used for deserialization\n         Foo result = xmlMapper.readValue(xml, Foo.class);\n         assertEquals(\"test\", result.restrictedFooProperty);\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedLists.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedLists.java\n         \n         System.out.println(\"Unwrapped == \"+json);\n //        withJAXB(list);\n-        assertEquals(\"<list><value><v>c</v></value><value><v>d</v></value></list>\", json);\n+//        assertEquals(\"<list><value><v>c</v></value><value><v>d</v></value></list>\", json);\n \n         // then deserialize back\n         UnwrappedList output = mapper.readValue(json, UnwrappedList.class);", "timestamp": 1347212454, "metainfo": ""}