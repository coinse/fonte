{"sha": "e22ace62764f7ee5ebe908922b6ac2f82432f154", "log": "refactoring", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n import com.fasterxml.jackson.core.io.IOContext;\n import com.fasterxml.jackson.core.util.ByteArrayBuilder;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n-import com.fasterxml.jackson.dataformat.xml.util.XmlTokenStream;\n \n /**\n  * {@link JsonParser} implementation that exposes XML structure as\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n+package com.fasterxml.jackson.dataformat.xml.deser;\n+\n+import java.io.IOException;\n+import javax.xml.stream.*;\n+\n+import org.codehaus.stax2.XMLStreamLocation2;\n+import org.codehaus.stax2.XMLStreamReader2;\n+import org.codehaus.stax2.ri.Stax2ReaderAdapter;\n+\n+import com.fasterxml.jackson.core.JsonLocation;\n+import com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n+\n+/**\n+ * Simple helper class used on top of STAX {@link XMLStreamReader} to further\n+ * abstract out all irrelevant details, and to expose equivalent of flat token\n+ * stream with no \"fluff\" tokens (comments, processing instructions, mixed\n+ * content) all of which is just to simplify\n+ * actual higher-level conversion to JSON tokens\n+ */\n+public class XmlTokenStream\n+{\n+    public final static int XML_START_ELEMENT = 1;\n+    public final static int XML_END_ELEMENT = 2;\n+    public final static int XML_ATTRIBUTE_NAME = 3;\n+    public final static int XML_ATTRIBUTE_VALUE = 4;\n+    public final static int XML_TEXT = 5;\n+    public final static int XML_END = 6;\n+\n+    /*\n+    /**********************************************************************\n+    /* Configuration\n+    /**********************************************************************\n+     */\n+\n+    final protected XMLStreamReader2 _xmlReader;\n+\n+    final protected Object _sourceReference;\n+    \n+    /*\n+    /**********************************************************************\n+    /* Parsing state\n+    /**********************************************************************\n+     */\n+\n+    protected int _currentState;\n+\n+    protected int _attributeCount;\n+    \n+    /**\n+     * Index of the next attribute of the current START_ELEMENT\n+     * to return (as field name and value pair), if any; -1\n+     * when no attributes to return\n+     */\n+    protected int _nextAttributeIndex = 0;\n+\n+    protected String _localName;\n+\n+    protected String _namespaceURI;\n+\n+    protected String _textValue;\n+    \n+    /*\n+    /**********************************************************************\n+    /* Life-cycle\n+    /**********************************************************************\n+     */\n+\n+    public XmlTokenStream(XMLStreamReader xmlReader, Object sourceRef)\n+    {\n+        _sourceReference = sourceRef;\n+        // Let's ensure we point to START_ELEMENT...\n+        if (xmlReader.getEventType() != XMLStreamConstants.START_ELEMENT) {\n+            throw new IllegalArgumentException(\"Invalid XMLStreamReader passed: should be pointing to START_ELEMENT (\"\n+                    +XMLStreamConstants.START_ELEMENT+\"), instead got \"+xmlReader.getEventType());\n+        }\n+        _xmlReader = Stax2ReaderAdapter.wrapIfNecessary(xmlReader);\n+        _currentState = XML_START_ELEMENT;\n+        _localName = _xmlReader.getLocalName();\n+        _namespaceURI = _xmlReader.getNamespaceURI();\n+        _attributeCount = _xmlReader.getAttributeCount();\n+    }\n+\n+    public XMLStreamReader2 getXmlReader() {\n+        return _xmlReader;\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Public API\n+    /**********************************************************************\n+     */\n+\n+    public int next() throws IOException \n+    {\n+        try {\n+            return _next();\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+            return -1;\n+        }\n+    }\n+\n+    public void skipEndElement() throws IOException\n+    {\n+        try {\n+            int type = _next();\n+            if (type != XML_END_ELEMENT) {\n+                throw new IOException(\"Expected END_ELEMENT, got event of type \"+type);\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    public int getCurrentToken() { return _currentState; }\n+\n+    public String getText() { return _textValue; }\n+    public String getLocalName() { return _localName; }\n+    public String getNamespaceURI() { return _namespaceURI; }\n+    public boolean hasAttributes() {\n+        return (_currentState == XML_START_ELEMENT) && (_attributeCount > 0);\n+    }\n+    \n+    public void closeCompletely() throws IOException\n+    {\n+        try {\n+            _xmlReader.closeCompletely();\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    public void close() throws IOException\n+    {\n+        try {\n+            _xmlReader.close();\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    public JsonLocation getCurrentLocation() {\n+        return _extractLocation(_xmlReader.getLocationInfo().getCurrentLocation());\n+    }\n+    public JsonLocation getTokenLocation() {\n+        return _extractLocation(_xmlReader.getLocationInfo().getStartLocation());\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Internal methods, parsing\n+    /**********************************************************************\n+     */\n+\n+    private final int _next() throws XMLStreamException\n+    {\n+        switch (_currentState) {\n+        case XML_ATTRIBUTE_VALUE:\n+            ++_nextAttributeIndex;\n+            // fall through\n+        case XML_START_ELEMENT: // attributes to return?\n+            if (_nextAttributeIndex < _attributeCount) {\n+                _localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n+                _namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n+                _textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\n+                return (_currentState = XML_ATTRIBUTE_NAME);\n+            }\n+            // otherwise need to find START/END_ELEMENT or text\n+            String text = _collectUntilTag();\n+            // If it's START_ELEMENT, ignore any text\n+            if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\n+                return _initStartElement();\n+            }\n+            // For END_ELEMENT we will return text, if any\n+            if (text != null) {\n+                _textValue = text;\n+                return (_currentState = XML_TEXT);\n+            }\n+            return (_currentState = XML_END_ELEMENT);\n+        case XML_ATTRIBUTE_NAME:\n+            // if we just returned name, will need to just send value next\n+            return (_currentState = XML_ATTRIBUTE_VALUE);\n+        case XML_TEXT:\n+            // text is always followed by END_ELEMENT\n+            return (_currentState = XML_END_ELEMENT);\n+        }\n+\n+        // Ok: must be END_ELEMENT; see what tag we get (or end)\n+        switch (_skipUntilTag()) {\n+        case XMLStreamConstants.END_DOCUMENT:\n+            return (_currentState = XML_END);\n+        case XMLStreamConstants.END_ELEMENT:\n+            return (_currentState = XML_END_ELEMENT);\n+        }\n+        // START_ELEMENT...\n+        return _initStartElement();\n+    }\n+    \n+    private final String _collectUntilTag() throws XMLStreamException\n+    {\n+        String text = null;\n+        while (true) {\n+            switch (_xmlReader.next()) {\n+            case XMLStreamConstants.START_ELEMENT:\n+            case XMLStreamConstants.END_ELEMENT:\n+            case XMLStreamConstants.END_DOCUMENT:\n+                return text;\n+                // note: SPACE is ignorable (and seldom seen), not to be included\n+            case XMLStreamConstants.CHARACTERS:\n+            case XMLStreamConstants.CDATA:\n+                if (text == null) {\n+                    text = _xmlReader.getText();\n+                } else { // can be optimized in future, if need be:\n+                    text += _xmlReader.getText();\n+                }\n+                break;\n+            default:\n+                // any other type (proc instr, comment etc) is just ignored\n+            }\n+        }\n+    }\n+\n+    private final int _skipUntilTag() throws XMLStreamException\n+    {\n+        while (true) {\n+            int type;\n+            switch (type = _xmlReader.next()) {\n+            case XMLStreamConstants.START_ELEMENT:\n+            case XMLStreamConstants.END_ELEMENT:\n+            case XMLStreamConstants.END_DOCUMENT:\n+                return type;\n+            default:\n+                // any other type (proc instr, comment etc) is just ignored\n+            }\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Internal methods, other\n+    /**********************************************************************\n+     */\n+    \n+    private final int _initStartElement() throws XMLStreamException\n+    {\n+        _nextAttributeIndex = 0;\n+        _attributeCount = _xmlReader.getAttributeCount();\n+        _localName = _xmlReader.getLocalName();\n+        _namespaceURI = _xmlReader.getNamespaceURI();\n+        return (_currentState = XML_START_ELEMENT);\n+    }\n+    \n+    private JsonLocation _extractLocation(XMLStreamLocation2 location)\n+    {\n+        if (location == null) { // just for impls that might pass null...\n+            return new JsonLocation(_sourceReference, -1, -1, -1);\n+        }\n+        return new JsonLocation(_sourceReference,\n+                location.getCharacterOffset(),\n+                location.getLineNumber(),\n+                location.getColumnNumber());\n+    }\n+    \n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/TestXmlTokenStream.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestXmlTokenStream.java\n \n import javax.xml.stream.*;\n \n-import com.fasterxml.jackson.dataformat.xml.util.XmlTokenStream;\n+import com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream;\n \n public class TestXmlTokenStream extends XmlTestBase\n {", "timestamp": 1347161968, "metainfo": ""}