{"sha": "abd4666e7534698ced93f5484683b6dcdceb08ff", "log": "Merge branch '2.7'", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n     /**********************************************************\n      */\n \n-    /**\n-     * XML indentation differs from JSON indentation, thereby\n-     * need to change default pretty-printer\n-     */\n+    // 09-May-2016, tatu: Was removed from `jackson-databind` in 2.8; remove from\n+    //    here in 2.9.\n     @Deprecated // since 2.6\n-    @Override\n+//    @Override\n     protected PrettyPrinter _defaultPrettyPrinter() {\n         return new DefaultXmlPrettyPrinter();\n     }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlTypeResolverBuilder.java\n package com.fasterxml.jackson.dataformat.xml;\n \n+import java.io.IOException;\n import java.util.Collection;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n             return encodeXmlClassName(super.idFromValue(value));\n         }\n \n-        @SuppressWarnings(\"deprecation\")\n         @Override\n-        public JavaType typeFromId(String id) {\n-            return super.typeFromId(decodeXmlClassName(id));\n-        }\n-\n-        @Override\n-        public JavaType typeFromId(DatabindContext context, String id) {\n+        public JavaType typeFromId(DatabindContext context, String id) throws IOException {\n             return super.typeFromId(context, decodeXmlClassName(id));\n         }\n     }\n             return encodeXmlClassName(super.idFromValue(value));\n         }\n \n-        @SuppressWarnings(\"deprecation\")\n         @Override\n-        public JavaType typeFromId(String id) {\n-            return super.typeFromId(decodeXmlClassName(id));\n-        }\n-\n-        @Override\n-        public JavaType typeFromId(DatabindContext context, String id) {\n+        public JavaType typeFromId(DatabindContext context, String id) throws IOException {\n             return super.typeFromId(context, decodeXmlClassName(id));\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n package com.fasterxml.jackson.dataformat.xml.deser;\n \n import java.io.IOException;\n+import java.io.Writer;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.util.Set;\n         return false;\n     }\n \n+    @Override // since 2.8\n+    public int getText(Writer writer) throws IOException\n+    {\n+        String str = getText();\n+        if (str == null) {\n+            return 0;\n+        }\n+        writer.write(str);\n+        return str.length();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public API, access to token information, binary\n     protected void _handleEOF() throws JsonParseException\n     {\n         if (!_parsingContext.inRoot()) {\n-            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n-        }\n-    }\n-    \n+            String marker = _parsingContext.inArray() ? \"Array\" : \"Object\";\n+            _reportInvalidEOF(String.format(\n+                    \": expected close marker for %s (start marker at %s)\",\n+                    marker,\n+                    _parsingContext.getStartLocation(_ioContext.getSourceReference())),\n+                    null);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Internal methods\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n     protected int _currentState;\n \n     protected int _attributeCount;\n-    \n+\n+    /**\n+     * If true we have a START_ELEMENT with mixed text\n+     *\n+     * @since 2.8\n+     */\n+    protected boolean _mixedText;\n+\n     /**\n      * Index of the next attribute of the current START_ELEMENT\n      * to return (as field name and value pair), if any; -1\n         // Anything to do in failed case? Roll back whatever we found or.. ?\n         return null;\n     }\n-    \n+\n     /*\n     /**********************************************************************\n     /* Internal methods, parsing\n             }\n             // otherwise need to find START/END_ELEMENT or text\n             String text = _collectUntilTag();\n-            // If it's START_ELEMENT, ignore any text\n-            if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\n-                return _initStartElement();\n+            final boolean startElementNext = _xmlReader.getEventType() == XMLStreamReader.START_ELEMENT;\n+            // If we have no/all-whitespace text followed by START_ELEMENT, ignore text\n+            if (startElementNext) {\n+                if (text == null || _allWs(text)) {\n+                    _mixedText = false;\n+                    return _initStartElement();\n+                }\n+                _mixedText = true;\n+                _textValue = text;\n+                return (_currentState = XML_TEXT);\n             }\n             // For END_ELEMENT we will return text, if any\n             if (text != null) {\n+                _mixedText = false;\n                 _textValue = text;\n                 return (_currentState = XML_TEXT);\n             }\n+            _mixedText = false;\n             return _handleEndElement();\n+\n         case XML_ATTRIBUTE_NAME:\n             // if we just returned name, will need to just send value next\n             return (_currentState = XML_ATTRIBUTE_VALUE);\n         case XML_TEXT:\n-            // text is always followed by END_ELEMENT\n+            // mixed text with other elements\n+            if (_mixedText){\n+                _mixedText = false;\n+                return _initStartElement();\n+            }\n+            // text followed by END_ELEMENT\n             return _handleEndElement();\n         case XML_END:\n             return XML_END;\n                 location.getColumnNumber());\n     }\n \n+\n+    protected boolean _allWs(String str)\n+    {\n+        final int len = (str == null) ? 0 : str.length();\n+        if (len > 0) {\n+            for (int i = 0; i < len; ++i) {\n+                if (str.charAt(i) > ' ') {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+    \n     // for DEBUGGING\n     @Override\n     public String toString()\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n     /**********************************************************\n      */\n \n-    /**\n-     * Standard JSON indenter does not work well with XML, use\n-     * default XML indenter instead.\n-     *<p>\n-     * !!! TODO: same as implementation in core 2.6; override may be\n-     * removed from 2.8\n-     */\n-    @Override\n-    public final JsonGenerator useDefaultPrettyPrinter()\n-    {\n-        // related to [dataformat-xml#136], need to verify:\n-        if (_cfgPrettyPrinter != null) {\n-            return this;\n-        }\n-        return setPrettyPrinter(_constructDefaultPrettyPrinter());\n-    }\n-\n     @Override\n     protected PrettyPrinter _constructDefaultPrettyPrinter() {\n         return new DefaultXmlPrettyPrinter();\n         }\n         return this;\n     }\n+\n+    @Override\n+    public boolean canWriteFormattedNumbers() { return true; }\n \n     // @since 2.7.5\n     public boolean inRoot() {\n     public final void writeEndArray() throws IOException\n     {\n         if (!_writeContext.inArray()) {\n-            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n+            _reportError(\"Current context not Array but \"+_writeContext.typeDesc());\n         }\n         if (_cfgPrettyPrinter != null) {\n             _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n     public final void writeEndObject() throws IOException\n     {\n         if (!_writeContext.inObject()) {\n-            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n+            _reportError(\"Current context not Object but \"+_writeContext.typeDesc());\n         }\n         _writeContext = _writeContext.getParent();\n         if (_cfgPrettyPrinter != null) {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/UnwrappingXmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/UnwrappingXmlBeanSerializer.java\n package com.fasterxml.jackson.dataformat.xml.ser;\n \n import java.io.IOException;\n+import java.util.Set;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n         _nameTransformer = src._nameTransformer;\n     }\n \n-    protected UnwrappingXmlBeanSerializer(UnwrappingXmlBeanSerializer src, String[] toIgnore)\n+    protected UnwrappingXmlBeanSerializer(UnwrappingXmlBeanSerializer src, Set<String> toIgnore)\n     {\n         super(src, toIgnore);\n         _nameTransformer = src._nameTransformer;\n         return new UnwrappingXmlBeanSerializer(this, _objectIdWriter, filterId);\n     }\n \n-    @Override\n-    protected BeanSerializerBase withIgnorals(String[] toIgnore)\n-    {\n+    @Override // since 2.8\n+    protected BeanSerializerBase withIgnorals(Set<String> toIgnore) {\n         return new UnwrappingXmlBeanSerializer(this, toIgnore);\n     }\n \n      * so implementation will simply return 'this'.\n      */\n     @Override\n-    protected BeanSerializerBase asArraySerializer()\n-    {\n+    protected BeanSerializerBase asArraySerializer() {\n         return this;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n package com.fasterxml.jackson.dataformat.xml.ser;\n \n import java.io.IOException;\n+import java.util.Set;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n         super(src, objectIdWriter);\n     }\n \n-    public XmlBeanSerializer(XmlBeanSerializerBase src, String[] toIgnore) {\n+    public XmlBeanSerializer(XmlBeanSerializerBase src, Set<String> toIgnore) {\n         super(src, toIgnore);\n     }\n \n     /* Life-cycle: factory methods, fluent factories\n     /**********************************************************\n      */\n-\n \n     @Override\n     public JsonSerializer<Object> unwrappingSerializer(NameTransformer unwrapper) {\n     }\n \n     @Override\n-    protected BeanSerializerBase withIgnorals(String[] toIgnore) {\n+    protected BeanSerializerBase withIgnorals(Set<String> toIgnore) {\n         return new XmlBeanSerializer(this, toIgnore);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n \n import java.io.IOException;\n import java.util.BitSet;\n+import java.util.Set;\n \n import javax.xml.namespace.QName;\n \n         _cdata = src._cdata;\n     }\n \n-    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, String[] toIgnore)\n+    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, Set<String> toIgnore)\n     {\n         super(src, toIgnore);\n         _attributeCount = src._attributeCount;\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/EmptyListDeser124Test.java\n+package com.fasterxml.jackson.dataformat.xml.failing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.dataformat.xml.*;\n+\n+// for [dataformat-xml#124]\n+public class EmptyListDeser124Test extends XmlTestBase\n+{\n+    public static class TestList {\n+        @JsonProperty(\"list\")\n+        public List<Object> list;\n+    }\n+\n+    // [dataformat-xml#124]\n+    public  void test124() throws Exception {\n+        final XmlMapper xmlMapper = new XmlMapper();\n+        TestList originalObject = new TestList();\n+        originalObject.list = new ArrayList<Object>();\n+        String xml = xmlMapper.writeValueAsString(originalObject);\n+//System.err.println(xml); // print <TestList><list/>></TestList>\n+\n+        TestList result = xmlMapper.readValue(xml, TestList.class);\n+\n+        assertNotNull(result.list);\n+        assertEquals(0, result.list.size());\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedDeserIssue86.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedDeserIssue86.java\n package com.fasterxml.jackson.dataformat.xml.failing;\n \n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n \n import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n         final Issue86 after = mapper.readValue(xml, Issue86.class);\n         assertEquals(before, after);\n     }\n+\n+\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/UnwrappingWithXMLTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/UnwrappingWithXMLTest.java\n      */\n \n     /**\n-   * Simple test to verify that explicit schema mapping works fine\n+     * Simple test to verify that explicit schema mapping works fine\n      * with unwrapped entities\n      */\n     public void testSimpleUnwrappingRoundtrip()\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/XmlTextTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/XmlTextTest.java\n import com.fasterxml.jackson.annotation.JsonInclude.Include;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText;\n \n public class XmlTextTest extends XmlTestBase\n {\n     @JsonPropertyOrder({\"first\",\"second\"})\n-    class Data{\n+    static class Data{\n         @JacksonXmlText\n         public String first;\n         public String second;\n         }\n     }\n \n+    static class Phone\n+    {\n+        @JacksonXmlProperty(isAttribute = true)\n+        public String phoneType = \"mobile\";\n+\n+        @JacksonXmlText\n+        public String phoneNumber = \"555-1234\";\n+    }\n+\n+    static class WindSpeed {\n+        @JacksonXmlProperty(isAttribute = true)\n+        public String units;\n+\n+        @JacksonXmlText\n+        public int value;\n+\n+        public Radius radius;\n+    }\n+\n+    static class Radius {\n+        @JacksonXmlText\n+        public int value;\n+    }\n+\n+        \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = xmlMapper(true);\n+    \n     public void testXmlTextWithSuppressedValue() throws Exception\n     {\n         final XmlMapper mapper = new XmlMapper();\n         String expectedXml = \"<Data><second>second</second></Data>\";\n         assertEquals(expectedXml, xml);\n     }\n+\n+    // for [dataformat-xml#196]\n+    public void testMixedContent() throws Exception\n+    {\n+        WindSpeed result = MAPPER.readValue(\"<windSpeed units='kt'> 27 <radius>20</radius></windSpeed>\",\n+                WindSpeed.class);\n+        assertEquals(27, result.value);\n+        assertNotNull(result.radius);\n+        assertEquals(20, result.radius.value);\n+    }\n+\n+    // for [dataformat-xml#198]\n+    public void testSimple198() throws Exception\n+    {\n+        String xml = MAPPER.writeValueAsString(new Phone());\n+        Phone result = MAPPER.readValue(xml, Phone.class);\n+        assertNotNull(result);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/stream/XmlParserTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/stream/XmlParserTest.java\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n import com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\n \n-\n public class XmlParserTest extends XmlTestBase\n {\n     /*\n         // Former could be worked around; latter less so at this point.\n \n         // So, for now, let's just do sort of minimal verification, manually\n-        JsonParser jp = _xmlMapper.getFactory().createParser(xml);\n-        \n-        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // main object\n-\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Image'\n-        verifyFieldName(jp, \"Image\");\n-        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'image' object\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n-        verifyFieldName(jp, \"Width\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_WIDTH), jp.getText());\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n-        verifyFieldName(jp, \"Height\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), jp.getText());\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Title'\n-        verifyFieldName(jp, \"Title\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Thumbnail'\n-        verifyFieldName(jp, \"Thumbnail\");\n-        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'thumbnail' object\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Url'\n-        verifyFieldName(jp, \"Url\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n-        verifyFieldName(jp, \"Height\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), jp.getText());\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n-        verifyFieldName(jp, \"Width\");\n+        JsonParser p = _xmlMapper.getFactory().createParser(xml);\n+        \n+        assertToken(JsonToken.START_OBJECT, p.nextToken()); // main object\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Image'\n+        verifyFieldName(p, \"Image\");\n+        assertToken(JsonToken.START_OBJECT, p.nextToken()); // 'image' object\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Width'\n+        verifyFieldName(p, \"Width\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_WIDTH), p.getText());\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Height'\n+        verifyFieldName(p, \"Height\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), p.getText());\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Title'\n+        verifyFieldName(p, \"Title\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Thumbnail'\n+        verifyFieldName(p, \"Thumbnail\");\n+        assertToken(JsonToken.START_OBJECT, p.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Url'\n+        verifyFieldName(p, \"Url\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Height'\n+        verifyFieldName(p, \"Height\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), p.getText());\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Width'\n+        verifyFieldName(p, \"Width\");\n         // Width value is actually a String in the example\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(jp));\n-\n-        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(p));\n+\n+        assertToken(JsonToken.END_OBJECT, p.nextToken()); // 'thumbnail' object\n \n         // Note: arrays are \"eaten\"; wrapping is done using BeanPropertyWriter, so:\n-        //assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'IDs'\n-        //verifyFieldName(jp, \"IDs\");\n-        //assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'ids' array\n-\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n-        verifyFieldName(jp, \"IDs\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); \n-        verifyFieldName(jp, \"IDs\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n-        verifyFieldName(jp, \"IDs\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); \n-        verifyFieldName(jp, \"IDs\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), getAndVerifyText(jp));\n+        //assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'IDs'\n+        //verifyFieldName(p, \"IDs\");\n+        //assertToken(JsonToken.START_OBJECT, p.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        verifyFieldName(p, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); \n+        verifyFieldName(p, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        verifyFieldName(p, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); \n+        verifyFieldName(p, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), getAndVerifyText(p));\n \n         // no matching entry for array:\n-        //assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'ids' array\n-\n-        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'image' object\n-\n-        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // main object\n-        \n-        jp.close();\n+        //assertToken(JsonToken.END_OBJECT, p.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.END_OBJECT, p.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.END_OBJECT, p.nextToken()); // main object\n+        \n+        p.close();\n     }\n \n     /**\n         assertEquals(\"property\", xp.getCurrentName());\n         assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n         assertEquals(\"123\", xp.getText());\n+\n+        StringWriter w = new StringWriter();\n+        assertEquals(3, xp.getText(w));\n+        assertEquals(\"123\", w.toString());\n+        \n         assertTrue(xp.getParsingContext().inObject());\n         assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </property>\n         assertTrue(xp.getParsingContext().inArray());\n \n         assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <offset>\n         assertEquals(\"offset\", xp.getCurrentName());\n+\n+        StringWriter w = new StringWriter();\n+        assertEquals(6, xp.getText(w));\n+        assertEquals(\"offset\", w.toString());\n+        \n         assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n         assertEquals(\"9\", xp.getText());\n \n+        w = new StringWriter();\n+        assertEquals(1, xp.getText(w));\n+        assertEquals(\"9\", w.toString());\n+        \n         assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </data>\n         xp.close();\n     }\n     {\n         StringWriter w = new StringWriter();\n \n-        JsonParser jp = _xmlFactory.createParser(xml);\n+        JsonParser p = _xmlFactory.createParser(xml);\n         JsonGenerator jg = _jsonFactory.createGenerator(w);\n-        while (jp.nextToken() != null) {\n-            jg.copyCurrentEvent(jp);\n+        while (p.nextToken() != null) {\n+            jg.copyCurrentEvent(p);\n         }\n-        jp.close();\n+        p.close();\n         jg.close();\n         return w.toString();\n     }", "timestamp": 1465613686, "metainfo": ""}