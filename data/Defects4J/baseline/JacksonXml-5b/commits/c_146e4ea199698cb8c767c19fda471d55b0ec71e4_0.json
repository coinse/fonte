{"sha": "146e4ea199698cb8c767c19fda471d55b0ec71e4", "log": "Implemented rudimentary indentation for XML output", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlPrettyPrinter.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.codehaus.stax2.XMLStreamWriter2;\n+\n+import com.fasterxml.jackson.core.PrettyPrinter;\n+\n+/**\n+ * There are some XML-specific quirks that need extra TLC when\n+ * indenting: so we will use a refinement of general purpose one.\n+ */\n+public interface XmlPrettyPrinter extends PrettyPrinter\n+{\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, String text)\n+        throws XMLStreamException;\n+\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName,\n+    \t\tchar[] buffer, int offset, int len)\n+        throws XMLStreamException;\n+    \n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, boolean value)\n+  \t\tthrows XMLStreamException;\n+\n+    // Lots of numbers...\n+    \n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, int value)\n+\t\tthrows XMLStreamException;\n+\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, long value)\n+  \t\tthrows XMLStreamException;\n+\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, double value)\n+  \t\tthrows XMLStreamException;\n+\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, float value)\n+  \t\tthrows XMLStreamException;\n+\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, BigInteger value)\n+  \t\tthrows XMLStreamException;\n+\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, BigDecimal value)\n+  \t\tthrows XMLStreamException;\n+    \n+    // binary element\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName,\n+    \t\tbyte[] data, int offset, int len)\n+        throws XMLStreamException;\n+\n+    // empty element to represent null\n+    public void writeLeafNullElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName)\n+        throws XMLStreamException;\n+}\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n import com.fasterxml.jackson.core.base.GeneratorBase;\n import com.fasterxml.jackson.core.io.IOContext;\n import com.fasterxml.jackson.core.json.JsonWriteContext;\n+import com.fasterxml.jackson.dataformat.xml.XmlPrettyPrinter;\n import com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter;\n import com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n \n      */\n     protected int _xmlFeatures;\n \n+    /**\n+     * We may need to use XML-specific indentation as well\n+     */\n+    protected XmlPrettyPrinter _xmlPrettyPrinter;\n+    \n     /*\n     /**********************************************************\n     /* XML Output state\n         _xmlFeatures = xmlFeatures;\n         _ioContext = ctxt;\n         _xmlWriter = Stax2WriterAdapter.wrapIfNecessary(sw);\n+        _xmlPrettyPrinter = (_cfgPrettyPrinter instanceof XmlPrettyPrinter) ?\n+        \t\t(XmlPrettyPrinter) _cfgPrettyPrinter : null;\n     }\n \n     /**\n             if (_nextIsAttribute) { // must write attribute name and value with one call\n                 _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\n             } else {\n-                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeCharacters(text);\n-                _xmlWriter.writeEndElement();\n+                if (_xmlPrettyPrinter != null) {\n+                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n+                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n+                \t\t\ttext);\n+                } else {\n+\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+\t                _xmlWriter.writeCharacters(text);\n+\t                _xmlWriter.writeEndElement();\n+                }\n             } \n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\n             } else {\n-                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeCharacters(text, offset, len);\n-                _xmlWriter.writeEndElement();\n+                if (_xmlPrettyPrinter != null) {\n+                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n+                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n+                \t\t\ttext, offset, len);\n+                } else {\n+\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+\t                _xmlWriter.writeCharacters(text, offset, len);\n+\t                _xmlWriter.writeEndElement();\n+                }\n             }\n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n      */\n \n     @Override\n-    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException\n+    public void writeBinary(Base64Variant b64variant,\n+    \t\tbyte[] data, int offset, int len)\n+        throws IOException, JsonGenerationException\n     {\n         if (data == null) {\n             writeNull();\n                 byte[] fullBuffer = toFullBuffer(data, offset, len);\n                 _xmlWriter.writeBinaryAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);\n             } else {\n-                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeBinary(data, offset, len);\n-                _xmlWriter.writeEndElement();\n+                if (_xmlPrettyPrinter != null) {\n+                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n+                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n+                \t\t\tdata, offset, len);\n+                } else {\n+\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+\t                _xmlWriter.writeBinary(data, offset, len);\n+\t                _xmlWriter.writeEndElement();\n+                }\n             }\n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n      */\n \n     @Override\n-    public void writeBoolean(boolean state) throws IOException, JsonGenerationException\n+    public void writeBoolean(boolean value) throws IOException, JsonGenerationException\n     {\n         _verifyValueWrite(\"write boolean value\");\n         if (_nextName == null) {\n         }\n         try {\n             if (_nextIsAttribute) {\n-                _xmlWriter.writeBooleanAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), state);\n-            } else {\n-                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeBoolean(state);\n-                _xmlWriter.writeEndElement();\n+                _xmlWriter.writeBooleanAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), value);\n+            } else {\n+                if (_xmlPrettyPrinter != null) {\n+                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n+                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n+                \t\t\tvalue);\n+                } else {\n+\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+\t                _xmlWriter.writeBoolean(value);\n+\t                _xmlWriter.writeEndElement();\n+                }\n             }\n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n         if (_nextName == null) {\n             handleMissingName();\n         }\n-        // !!! TODO: proper use of 'xsd:isNil'\n+        // !!! TODO: proper use of 'xsd:isNil' ?\n         try {\n             if (_nextIsAttribute) {\n                 /* With attributes, best just leave it out, right? (since there's no way\n                  * to use 'xsi:nil')\n                  */\n             } else {\n-                _xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                if (_xmlPrettyPrinter != null) {\n+                \t_xmlPrettyPrinter.writeLeafNullElement(_xmlWriter,\n+                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                } else {\n+\t            \t_xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                }\n             }\n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeIntAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\n             } else {\n-                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeInt(i);\n-                _xmlWriter.writeEndElement();\n+                if (_xmlPrettyPrinter != null) {\n+                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n+                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n+                \t\t\ti);\n+                } else {\n+\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+\t                _xmlWriter.writeInt(i);\n+\t                _xmlWriter.writeEndElement();\n+                }\n             }\n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeLongAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), l);\n             } else {\n-                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeLong(l);\n-                _xmlWriter.writeEndElement();\n+                if (_xmlPrettyPrinter != null) {\n+                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n+                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n+                \t\t\tl);\n+                } else {\n+\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+\t                _xmlWriter.writeLong(l);\n+\t                _xmlWriter.writeEndElement();\n+                }\n             }\n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeDoubleAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), d);\n             } else {\n-                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeDouble(d);\n-                _xmlWriter.writeEndElement();\n+                if (_xmlPrettyPrinter != null) {\n+                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n+                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n+                \t\t\td);\n+                } else {\n+\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+\t                _xmlWriter.writeDouble(d);\n+\t                _xmlWriter.writeEndElement();\n+                }\n             }\n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeFloatAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), f);\n             } else {\n-                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeFloat(f);\n-                _xmlWriter.writeEndElement();\n+                if (_xmlPrettyPrinter != null) {\n+                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n+                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n+                \t\t\tf);\n+                } else {\n+\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+\t                _xmlWriter.writeFloat(f);\n+\t                _xmlWriter.writeEndElement();\n+                }\n             }\n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeDecimalAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), dec);\n             } else {\n-                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeDecimal(dec);\n-                _xmlWriter.writeEndElement();\n-            }\n-        } catch (XMLStreamException e) {\n-            StaxUtil.throwXmlAsIOException(e);\n-        }\n-    }\n-\n-    @Override\n-    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException\n-    {\n-        if (v == null) {\n+                if (_xmlPrettyPrinter != null) {\n+                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n+                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n+                \t\t\tdec);\n+                } else {\n+\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+\t                _xmlWriter.writeDecimal(dec);\n+\t                _xmlWriter.writeEndElement();\n+                }\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger value)\n+\t\tthrows IOException, JsonGenerationException\n+    {\n+        if (value == null) {\n             writeNull();\n             return;\n         }\n         }\n         try {\n             if (_nextIsAttribute) {\n-                _xmlWriter.writeIntegerAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), v);\n-            } else {\n-                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeInteger(v);\n-                _xmlWriter.writeEndElement();\n+                _xmlWriter.writeIntegerAttribute(null,\n+                \t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(), value);\n+            } else {\n+                if (_xmlPrettyPrinter != null) {\n+                \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n+                \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n+                \t\t\tvalue);\n+                } else {\n+\t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+\t                _xmlWriter.writeInteger(value);\n+\t                _xmlWriter.writeEndElement();\n+                }\n             }\n         } catch (XMLStreamException e) {\n             StaxUtil.throwXmlAsIOException(e);\n     public final JsonGenerator useDefaultPrettyPrinter()\n     {\n         return setPrettyPrinter(new DefaultXmlPrettyPrinter());\n+    }\n+\n+    @Override\n+    public JsonGenerator setPrettyPrinter(PrettyPrinter pp) {\n+        _cfgPrettyPrinter = pp;\n+        _xmlPrettyPrinter = (pp instanceof XmlPrettyPrinter) ?\n+        \t\t(XmlPrettyPrinter) pp : null;\n+        return this;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n package com.fasterxml.jackson.dataformat.xml.util;\n \n import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+\n+import javax.xml.stream.XMLStreamException;\n+\n+import org.codehaus.stax2.XMLStreamWriter2;\n \n import com.fasterxml.jackson.core.*;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlPrettyPrinter;\n import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n-\n \n /**\n  * Indentation to use with XML is different from JSON, because JSON\n  * requires use of separator characters and XML just basic whitespace.\n+ *<p>\n+ * Note that only a subset of methods of {@link PrettyPrinter} actually\n+ * get called by {@link ToXmlGenerator}; because of this, implementation\n+ * is bit briefer (and uglier...).\n  */\n public class DefaultXmlPrettyPrinter\n-    implements PrettyPrinter\n+    implements XmlPrettyPrinter\n {\n-    /*\n-    /**********************************************************\n-    /* Root-level values\n-    /**********************************************************\n-     */\n-\n-    //@Override\n+    /**\n+     * Interface that defines objects that can produce indentation used\n+     * to separate object entries and array values. Indentation in this\n+     * context just means insertion of white space, independent of whether\n+     * linefeeds are output.\n+     */\n+    public interface Indenter\n+    {\n+        public void writeIndentation(JsonGenerator jg, int level)\n+            throws IOException, JsonGenerationException;\n+\n+        public void writeIndentation(XMLStreamWriter2 sw, int level)\n+            throws XMLStreamException;\n+        \n+        /**\n+         * @return True if indenter is considered inline (does not add linefeeds),\n+         *   false otherwise\n+         */\n+        public boolean isInline();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * By default, let's use only spaces to separate array values.\n+     */\n+    protected Indenter _arrayIndenter = new FixedSpaceIndenter();\n+\n+    /**\n+     * By default, let's use linefeed-adding indenter for separate\n+     * object entries. We'll further configure indenter to use\n+     * system-specific linefeeds, and 2 spaces per level (as opposed to,\n+     * say, single tabs)\n+     */\n+    protected Indenter _objectIndenter = new Lf2SpacesIndenter();\n+\n+    // // // Config, other white space configuration\n+\n+    /**\n+     * By default we will add spaces around colons used to\n+     * separate object fields and values.\n+     * If disabled, will not use spaces around colon.\n+     */\n+    protected boolean _spacesInObjectEntries = true;\n+\n+    /*\n+    /**********************************************************\n+    /* State\n+    /**********************************************************\n+    */\n+    \n+    /**\n+     * Number of open levels of nesting. Used to determine amount of\n+     * indentation to use.\n+     */\n+    protected int _nesting = 0;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle (construct, configure)\n+    /**********************************************************\n+    */\n+\n+    public DefaultXmlPrettyPrinter() { }\n+\n+    public void indentArraysWith(Indenter i)\n+    {\n+        _arrayIndenter = (i == null) ? new NopIndenter() : i;\n+    }\n+\n+    public void indentObjectsWith(Indenter i)\n+    {\n+        _objectIndenter = (i == null) ? new NopIndenter() : i;\n+    }\n+\n+    public void spacesInObjectEntries(boolean b) { _spacesInObjectEntries = b; }\n+\n+    /*\n+    /**********************************************************\n+    /* PrettyPrinter impl\n+    /**********************************************************\n+     */\n+\n+\t@Override\n     public void writeRootValueSeparator(JsonGenerator jgen) throws IOException, JsonGenerationException {\n         // Not sure if this should ever be applicable; but if multiple roots were allowed, we'd use linefeed\n         jgen.writeRaw('\\n');\n     /**********************************************************\n      */\n     \n-    //@Override\n+\t@Override\n     public void beforeArrayValues(JsonGenerator jgen) throws IOException, JsonGenerationException {\n-        // anything to do here?\n-    }\n-\n-    //@Override\n-    public void writeStartArray(JsonGenerator jgen) throws IOException, JsonGenerationException {\n-        // anything to do here?\n-    }\n-\n-    //@Override\n+\t\t// never called for ToXmlGenerator\n+    }\n+\n+\t@Override\n+    public void writeStartArray(JsonGenerator jgen)\n+    \t\tthrows IOException, JsonGenerationException\n+    {\n+\t\t// anything to do here?\n+    }\n+\n+\t@Override\n     public void writeArrayValueSeparator(JsonGenerator jgen)  throws IOException, JsonGenerationException {\n-        // all markup by elements, no separators; nothing to do here\n-    }\n-\n-    //@Override\n-    public void writeEndArray(JsonGenerator jgen, int nrOfValues) throws IOException, JsonGenerationException {\n-        // anything to do here?\n+\t\t// never called for ToXmlGenerator\n+    }\n+\n+\t@Override\n+    public void writeEndArray(JsonGenerator jgen, int nrOfValues)\n+    \t\tthrows IOException, JsonGenerationException\n+    {\n+\t\t// anything to do here?\n     }\n     \n     /*\n     /**********************************************************\n      */\n     \n-    //@Override\n-    public void beforeObjectEntries(JsonGenerator jg)  throws IOException, JsonGenerationException {\n-        // TODO Auto-generated method stub\n-    }\n-\n-    //@Override\n-    public void writeStartObject(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+\t@Override\n+    public void beforeObjectEntries(JsonGenerator jgen)\n+        throws IOException, JsonGenerationException\n+    {\n+\t\t// never called for ToXmlGenerator\n+    }\n+\n+\t@Override\n+    public void writeStartObject(JsonGenerator jgen) throws IOException, JsonGenerationException\n+    {\n+\t\tif (!_objectIndenter.isInline()) {\n+\t\t\tif (_nesting > 0) {\n+\t        \t_objectIndenter.writeIndentation(jgen, _nesting);\n+\t\t\t}\n+            ++_nesting;\n+        }\n         ((ToXmlGenerator) jgen)._handleStartObject();\n     }\n \n-    //@Override\n-    public void writeObjectEntrySeparator(JsonGenerator jg) throws IOException, JsonGenerationException {\n-        // all markup by elements, no separators; nothing to do here\n-    }\n-\n-    //@Override\n-    public void writeObjectFieldValueSeparator(JsonGenerator jg) throws IOException, JsonGenerationException {\n-        // all markup by elements, no separators; nothing to do here\n-    }\n-    \n-    //@Override\n-    public void writeEndObject(JsonGenerator jgen, int nrOfEntries) throws IOException, JsonGenerationException {\n+\t@Override\n+    public void writeObjectEntrySeparator(JsonGenerator jgen)\n+    \t\tthrows IOException, JsonGenerationException\n+    {\n+\t\t// never called for ToXmlGenerator\n+    }\n+\n+\t@Override\n+    public void writeObjectFieldValueSeparator(JsonGenerator jgen) throws IOException, JsonGenerationException {\n+\t\t// never called for ToXmlGenerator\n+    }\n+    \n+\t@Override\n+    public void writeEndObject(JsonGenerator jgen, int nrOfEntries) throws IOException, JsonGenerationException\n+    {\n+        if (!_objectIndenter.isInline()) {\n+            --_nesting;\n+        }\n+        // for empty elements, no need for linefeeds etc:\n+        if (nrOfEntries > 0) {\n+        \t_objectIndenter.writeIndentation(jgen, _nesting);\n+        }\n         ((ToXmlGenerator) jgen)._handleEndObject();\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* XML-specific additions\n+    /**********************************************************\n+     */\n+\n+\t@Override\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, String text)\n+  \t\tthrows XMLStreamException\n+    {\n+\t\tif (!_objectIndenter.isInline()) {\n+\t\t\t_objectIndenter.writeIndentation(sw, _nesting);\n+        }\n+\t\tsw.writeStartElement(nsURI, localName);\n+\t\tsw.writeCharacters(text);\n+\t\tsw.writeEndElement();\n+    }\n+\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName,\n+    \t\tchar[] buffer, int offset, int len)\n+        throws XMLStreamException\n+    {\n+\t\tif (!_objectIndenter.isInline()) {\n+\t\t\t_objectIndenter.writeIndentation(sw, _nesting);\n+        }\n+\t\tsw.writeStartElement(nsURI, localName);\n+\t\tsw.writeCharacters(buffer, offset, len);\n+\t\tsw.writeEndElement();\n+    }\n+\t\n+\t@Override\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, boolean value)\n+  \t\tthrows XMLStreamException\n+    {\n+\t\tif (!_objectIndenter.isInline()) {\n+\t\t\t_objectIndenter.writeIndentation(sw, _nesting);\n+        }\n+\t\tsw.writeStartElement(nsURI, localName);\n+\t\tsw.writeBoolean(value);\n+\t\tsw.writeEndElement();\n+    }\n+\n+\t@Override\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, int value)\n+  \t\tthrows XMLStreamException\n+    {\n+\t\tif (!_objectIndenter.isInline()) {\n+\t\t\t_objectIndenter.writeIndentation(sw, _nesting);\n+        }\n+\t\tsw.writeStartElement(nsURI, localName);\n+\t\tsw.writeInt(value);\n+\t\tsw.writeEndElement();\n+    }\n+\n+\t@Override\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, long value)\n+  \t\tthrows XMLStreamException\n+    {\n+\t\tif (!_objectIndenter.isInline()) {\n+\t\t\t_objectIndenter.writeIndentation(sw, _nesting);\n+        }\n+\t\tsw.writeStartElement(nsURI, localName);\n+\t\tsw.writeLong(value);\n+\t\tsw.writeEndElement();\n+    }\n+\n+\t@Override\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, double value)\n+  \t\tthrows XMLStreamException\n+    {\n+\t\tif (!_objectIndenter.isInline()) {\n+\t\t\t_objectIndenter.writeIndentation(sw, _nesting);\n+        }\n+\t\tsw.writeStartElement(nsURI, localName);\n+\t\tsw.writeDouble(value);\n+\t\tsw.writeEndElement();\n+    }\n+\n+\t@Override\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, float value)\n+  \t\tthrows XMLStreamException\n+    {\n+\t\tif (!_objectIndenter.isInline()) {\n+\t\t\t_objectIndenter.writeIndentation(sw, _nesting);\n+        }\n+\t\tsw.writeStartElement(nsURI, localName);\n+\t\tsw.writeFloat(value);\n+\t\tsw.writeEndElement();\n+    }\n+\t\n+\t@Override\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, BigInteger value)\n+  \t\tthrows XMLStreamException\n+    {\n+\t\tif (!_objectIndenter.isInline()) {\n+\t\t\t_objectIndenter.writeIndentation(sw, _nesting);\n+        }\n+\t\tsw.writeStartElement(nsURI, localName);\n+\t\tsw.writeInteger(value);\n+\t\tsw.writeEndElement();\n+    }\n+\n+\t@Override\n+    public void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName, BigDecimal value)\n+  \t\tthrows XMLStreamException\n+    {\n+\t\tif (!_objectIndenter.isInline()) {\n+\t\t\t_objectIndenter.writeIndentation(sw, _nesting);\n+        }\n+\t\tsw.writeStartElement(nsURI, localName);\n+\t\tsw.writeDecimal(value);\n+\t\tsw.writeEndElement();\n+    }\n+\n+\t@Override\n+\tpublic void writeLeafElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName,\n+    \t\tbyte[] data, int offset, int len)\n+        throws XMLStreamException\n+    {\n+\t\tif (!_objectIndenter.isInline()) {\n+\t\t\t_objectIndenter.writeIndentation(sw, _nesting);\n+        }\n+\t\tsw.writeStartElement(nsURI, localName);\n+\t\tsw.writeBinary(data, offset, len);\n+\t\tsw.writeEndElement();\n+    }\n+\n+    public void writeLeafNullElement(XMLStreamWriter2 sw,\n+    \t\tString nsURI, String localName)\n+        throws XMLStreamException\n+    {\n+\t\tif (!_objectIndenter.isInline()) {\n+\t\t\t_objectIndenter.writeIndentation(sw, _nesting);\n+        }\n+\t\tsw.writeEmptyElement(nsURI, localName);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /* (note: copied from jackson-core to avoid dependency;\n+    /* allow local changes)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Dummy implementation that adds no indentation whatsoever\n+     */\n+    protected static class NopIndenter\n+        implements Indenter\n+    {\n+        public NopIndenter() { }\n+        @Override public void writeIndentation(JsonGenerator jg, int level) { }\n+        @Override public boolean isInline() { return true; }\n+        @Override public void writeIndentation(XMLStreamWriter2 sw, int level) { }\n+    }\n+\n+    /**\n+     * This is a very simple indenter that only every adds a\n+     * single space for indentation. It is used as the default\n+     * indenter for array values.\n+     */\n+    protected static class FixedSpaceIndenter\n+        implements Indenter\n+    {\n+        public FixedSpaceIndenter() { }\n+\n+        @Override\n+        public void writeIndentation(XMLStreamWriter2 sw, int level)\n+            throws XMLStreamException\n+        {\n+            sw.writeRaw(\" \");\n+        }\n+        \n+        @Override\n+        public void writeIndentation(JsonGenerator jg, int level)\n+            throws IOException, JsonGenerationException\n+        {\n+            jg.writeRaw(' ');\n+        }\n+\n+        @Override\n+        public boolean isInline() { return true; }\n+    }\n+\n+    /**\n+     * Default linefeed-based indenter uses system-specific linefeeds and\n+     * 2 spaces for indentation per level.\n+     */\n+    protected static class Lf2SpacesIndenter\n+        implements Indenter\n+    {\n+        final static String SYSTEM_LINE_SEPARATOR;\n+        static {\n+            String lf = null;\n+            try {\n+                lf = System.getProperty(\"line.separator\");\n+            } catch (Throwable t) { } // access exception?\n+            SYSTEM_LINE_SEPARATOR = (lf == null) ? \"\\n\" : lf;\n+        }\n+\n+        final static int SPACE_COUNT = 64;\n+        final static char[] SPACES = new char[SPACE_COUNT];\n+        static {\n+            Arrays.fill(SPACES, ' ');\n+        }\n+\n+        public Lf2SpacesIndenter() { }\n+\n+        @Override\n+        public boolean isInline() { return false; }\n+\n+        @Override\n+        public void writeIndentation(XMLStreamWriter2 sw, int level)\n+            throws XMLStreamException\n+        {\n+        \tsw.writeRaw(SYSTEM_LINE_SEPARATOR);\n+            level += level; // 2 spaces per level\n+            while (level > SPACE_COUNT) { // should never happen but...\n+            \tsw.writeRaw(SPACES, 0, SPACE_COUNT); \n+                level -= SPACES.length;\n+            }\n+            sw.writeRaw(SPACES, 0, level);\n+        }\n+        \n+        @Override\n+        public void writeIndentation(JsonGenerator jg, int level)\n+            throws IOException, JsonGenerationException\n+        {\n+            jg.writeRaw(SYSTEM_LINE_SEPARATOR);\n+            level += level; // 2 spaces per level\n+            while (level > SPACE_COUNT) { // should never happen but...\n+                jg.writeRaw(SPACES, 0, SPACE_COUNT); \n+                level -= SPACES.length;\n+            }\n+            jg.writeRaw(SPACES, 0, level);\n+        }\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/TestIndentation.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestIndentation.java\n \n import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n-\n \n public class TestIndentation extends XmlTestBase\n {\n     /**********************************************************\n      */\n \n-    static class Bean {\n+    static class StringWrapperBean {\n         public StringWrapper string;\n         \n-        public Bean() { }\n-        public Bean(String s) { string = new StringWrapper(s); }\n+        public StringWrapperBean() { }\n+        public StringWrapperBean(String s) { string = new StringWrapper(s); }\n+    }\n+\n+    static class IntWrapperBean {\n+        public IntWrapper wrapped;\n+        \n+        public IntWrapperBean() { }\n+        public IntWrapperBean(int i) { wrapped = new IntWrapper(i); }\n     }\n     \n     /*\n     /**********************************************************\n      */\n \n-    // Verify [JACKSON-444]\n-    public void testSimpleBean() throws Exception\n+    // Verify [JACKSON-444], Issue #1\n+    public void testSimpleStringBean() throws Exception\n     {\n-        String xml = _xmlMapper.writeValueAsString(new Bean(\"abc\")); \n-//System.out.println(\"XML = \"+xml);\n-\n+        String xml = _xmlMapper.writeValueAsString(new StringWrapperBean(\"abc\")); \n+        // should have at least one linefeed, space...\n+        if (xml.indexOf('\\n') < 0 || xml.indexOf(' ') < 0) {\n+        \tfail(\"No indentation: XML == \"+xml);\n+        }\n         // Let's verify we get similar stuff back, first:\n-        Bean result = _xmlMapper.readValue(xml, Bean.class);\n+        StringWrapperBean result = _xmlMapper.readValue(xml, StringWrapperBean.class);\n         assertNotNull(result);\n         assertEquals(\"abc\", result.string.str);\n \n     }\n \n+    public void testSimpleIntBean() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new IntWrapperBean(42)); \n+        // should have at least one linefeed, space...\n+        if (xml.indexOf('\\n') < 0 || xml.indexOf(' ') < 0) {\n+        \tfail(\"No indentation: XML == \"+xml);\n+        }\n+        // Let's verify we get similar stuff back, first:\n+        IntWrapperBean result = _xmlMapper.readValue(xml, IntWrapperBean.class);\n+        assertNotNull(result);\n+        assertEquals(42, result.wrapped.i);\n+    }\n+    \n     public void testSimpleMap() throws Exception\n     {\n         Map<String,String> map = new HashMap<String,String>();\n         map.put(\"a\", \"b\");\n         String xml = _xmlMapper.writeValueAsString(map);\n \n+        // should have at least one linefeed, space...\n+        if (xml.indexOf('\\n') < 0 || xml.indexOf(' ') < 0) {\n+        \tfail(\"No indentation: XML == \"+xml);\n+        }\n+        \n         // Let's verify we get similar stuff back, first:\n         Map<?,?> result = _xmlMapper.readValue(xml, Map.class);\n         assertNotNull(result);\n         assertEquals(1, result.size());\n         assertEquals(\"b\", map.get(\"a\"));\n     }\n-\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n         public StringBean() { this(\"foobar\"); }\n         public StringBean(String s) { text = s; }\n     }\n-\n+    \n     /**\n      * Simple wrapper around String type, usually to test value\n      * conversions or wrapping\n             str = value;\n         }\n     }\n-\n+    \n+    protected static class IntWrapper {\n+        public int i;\n+\n+        public IntWrapper() { }\n+        public IntWrapper(int value) {\n+            i = value;\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Some sample documents:", "timestamp": 1331095844, "metainfo": ""}