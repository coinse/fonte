{"sha": "6521078ce436b5e2bd969df94f09f6732891307d", "log": "Merge branch '2.8'", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n      * is encountered. Used for suppressing indentation to allow empty\n      * elements.\n      * \n-     * @since 2.3.0\n+     * @since 2.3\n      */\n     protected transient boolean _justHadStartElement;\n     \n \n     public DefaultXmlPrettyPrinter() { }\n \n+    protected DefaultXmlPrettyPrinter(DefaultXmlPrettyPrinter base)\n+    {\n+        _arrayIndenter = base._arrayIndenter;\n+        _objectIndenter = base._objectIndenter;\n+        _spacesInObjectEntries = base._spacesInObjectEntries;\n+        _nesting = base._nesting;\n+    }\n+\n     public void indentArraysWith(Indenter i)\n     {\n         _arrayIndenter = (i == null) ? new NopIndenter() : i;\n     \n     @Override\n     public DefaultXmlPrettyPrinter createInstance() {\n-        return new DefaultXmlPrettyPrinter();\n+        return new DefaultXmlPrettyPrinter(this);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n         final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n         try {\n             ser.serialize(value, gen, this);\n-        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n-            throw ioe;\n         } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n-            String msg = e.getMessage();\n-            if (msg == null) {\n-                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n-            }\n-            throw JsonMappingException.from(gen, msg, e);\n+            throw _wrapAsIOE(gen, e);\n         }\n         // end of super-class implementation\n \n         }\n     }\n \n+    // @since 2.1\n     @SuppressWarnings(\"resource\")\n     @Override\n-    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType)\n-        throws IOException\n+    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType,\n+            JsonSerializer<Object> ser) throws IOException\n     {\n         if (value == null) {\n             _serializeXmlNull(gen);\n                 _startRootArray(xgen, rootName);\n             }\n         }\n-\n-        final JsonSerializer<Object> ser = findTypedValueSerializer(rootType, true, null);\n+        if (ser == null) {\n+            ser = findTypedValueSerializer(rootType, true, null);\n+        }\n         // From super-class implementation\n         try {\n             ser.serialize(value, gen, this);\n-        } catch (IOException ioe) { // no wrapping for IO (and derived)\n-            throw ioe;\n         } catch (Exception e) { // but others do need to be, to get path etc\n-            String msg = e.getMessage();\n-            if (msg == null) {\n-                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n-            }\n-            throw JsonMappingException.from(gen, msg, e);\n-        }\n-        // end of super-class implementation\n-\n-        if (asArray) {\n-            gen.writeEndObject();\n-        }\n-    }\n-    \n-    // @since 2.1\n-    @SuppressWarnings(\"resource\")\n-    @Override\n-    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType,\n-            JsonSerializer<Object> ser) throws IOException\n-    {\n-        if (value == null) {\n-            _serializeXmlNull(gen);\n-            return;\n-        }\n-        final boolean asArray;\n-        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n-        if (xgen == null) { // called by convertValue()\n-            asArray = false;\n-        } else {\n-            QName rootName = _rootNameFromConfig();\n-            if (rootName == null) {\n-                rootName = _rootNameLookup.findRootName(rootType, _config);\n-            }\n-            _initWithRootName(xgen, rootName);\n-            asArray = TypeUtil.isIndexedType(rootType);\n-            if (asArray) {\n-                _startRootArray(xgen, rootName);\n-            }\n-        }\n-        if (ser == null) {\n-            ser = findTypedValueSerializer(rootType, true, null);\n-        }\n-        // From super-class implementation\n-        try {\n-            ser.serialize(value, gen, this);\n-        } catch (IOException ioe) { // no wrapping for IO (and derived)\n-            throw ioe;\n-        } catch (Exception e) { // but others do need to be, to get path etc\n-            String msg = e.getMessage();\n-            if (msg == null) {\n-                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n-            }\n-            throw JsonMappingException.from(gen, msg, e);\n+            throw _wrapAsIOE(gen, e);\n         }\n         // end of super-class implementation\n         if (asArray) {\n         }\n         return (ToXmlGenerator) gen;\n     }    \n+\n+    protected IOException _wrapAsIOE(JsonGenerator g, Exception e) {\n+        if (e instanceof IOException) {\n+            return (IOException) e;\n+        }\n+        String msg = e.getMessage();\n+        if (msg == null) {\n+            msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+        }\n+        return new JsonMappingException(g, msg, e);\n+    }\n }", "timestamp": 1487128377, "metainfo": ""}