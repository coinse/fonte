{"sha": "f4c7bb0fa6525e6143d7de21028690addd75e170", "log": "Implemented #156", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n import com.fasterxml.jackson.databind.PropertyName;\n import com.fasterxml.jackson.databind.introspect.*;\n import com.fasterxml.jackson.databind.jsontype.impl.StdTypeResolverBuilder;\n-\n import com.fasterxml.jackson.dataformat.xml.annotation.*;\n \n /**\n      */\n     public final static boolean DEFAULT_USE_WRAPPER = true;\n \n-    protected final boolean _cfgDefaultUseWrapper;\n+    // non-final from 2.7 on, to allow mapper to change\n+    protected boolean _cfgDefaultUseWrapper;\n     \n     public JacksonXmlAnnotationIntrospector() {\n         this(DEFAULT_USE_WRAPPER);\n         }\n         return null;\n     }\n-    \n+\n+    @Override\n+    public void setDefaultUseWrapper(boolean b) {\n+        _cfgDefaultUseWrapper = b;\n+    }\n+\n     /*\n     /**********************************************************************\n     /* Overrides for name, property detection\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n      */\n     public Boolean isOutputAsCData(Annotated ann);\n \n+    /**\n+     * @since 2.7\n+     */\n+    public void setDefaultUseWrapper(boolean b);\n+    \n     /*\n     /**********************************************************************\n     /* Replacement of 'AnnotationIntrospector.Pair' to use when combining\n         public String findNamespace(Annotated ann)\n         {\n             String value = (_xmlPrimary == null) ? null : _xmlPrimary.findNamespace(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.findNamespace(ann);\n             }\n             return value;\n         public Boolean isOutputAsAttribute(Annotated ann)\n         {\n             Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsAttribute(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.isOutputAsAttribute(ann);\n             }\n             return value;\n         public Boolean isOutputAsText(Annotated ann)\n         {\n             Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsText(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.isOutputAsText(ann);\n             }\n             return value;\n         @Override\n         public Boolean isOutputAsCData(Annotated ann) {\n             Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsCData(ann);\n-            if (value == null && _xmlSecondary != null) {\n+            if ((value == null) && (_xmlSecondary != null)) {\n                 value = _xmlSecondary.isOutputAsCData(ann);\n             }\n             return value;\n+        }\n+\n+        @Override\n+        public void setDefaultUseWrapper(boolean b) {\n+            if (_xmlPrimary != null) {\n+                _xmlPrimary.setDefaultUseWrapper(b);\n+            }\n+            if (_xmlSecondary != null) {\n+                _xmlSecondary.setDefaultUseWrapper(b);\n+            }\n         }\n     }\n \n             //There is no CData annotation in JAXB\n             return null;\n         }\n+\n+        @Override\n+        public void setDefaultUseWrapper(boolean b) {\n+            // not used with JAXB\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n         _serializationConfig = _serializationConfig.withDefaultPrettyPrinter(DEFAULT_XML_PRETTY_PRINTER);\n     }\n \n-    // @since 2.1\n     @Override\n     public XmlMapper copy()\n     {\n     protected void setXMLTextElementName(String name) {\n         ((XmlFactory) _jsonFactory).setXMLTextElementName(name);\n     }\n+    /**\n+     * Since 2.7\n+     */\n+    public XmlMapper setDefaultUseWrapper(boolean state) {\n+        // ser and deser configs should usually have the same introspector, so:\n+        AnnotationIntrospector ai0 = getDeserializationConfig().getAnnotationIntrospector();\n+        for (AnnotationIntrospector ai : ai0.allIntrospectors()) {\n+            if (ai instanceof XmlAnnotationIntrospector) {\n+                ((XmlAnnotationIntrospector) ai).setDefaultUseWrapper(state);\n+            }\n+        }\n+        return this;\n+    }\n \n     /*\n     /**********************************************************\n     /* Access to configuration settings\n     /**********************************************************\n      */\n-\n-    /**\n-     * @deprecated Since 2.1, use {@link #getFactory} instead\n-     */\n-    @Override\n-    @Deprecated\n-    public XmlFactory getJsonFactory() {\n-        return (XmlFactory) _jsonFactory;\n-    }\n \n     @Override\n     public XmlFactory getFactory() {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n  * implementation that\n  * builds on {@link JaxbAnnotationIntrospector}.\n  *<p>\n- * NOTE: since version 2.4, it should NOT be necessary to use this class;\n+ * NOTE: since version 2.4, it may NOT be necessary to use this class;\n  * instead, plain {@link JaxbAnnotationIntrospector} should fully work.\n  * With previous versions some aspects were not fully working and this\n  * class was necessary.\n     extends JaxbAnnotationIntrospector\n     implements XmlAnnotationIntrospector\n {\n-    private static final long serialVersionUID = 6477843393758275877L;\n+    private static final long serialVersionUID = 1L; // since 2.7\n \n     @Deprecated\n     public XmlJaxbAnnotationIntrospector() {\n     /**********************************************************************\n      */\n     \n-    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n     public String findNamespace(Annotated ann) {\n         return super.findNamespace(ann);\n     }\n \n-    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n     public Boolean isOutputAsAttribute(Annotated ann) {\n         return super.isOutputAsAttribute(ann);\n     }\n     \n-    // Since 2.4.0, JaxbAnnotationIntrospector has implementation, so delegate\n     @Override\n     public Boolean isOutputAsText(Annotated ann) {\n         return super.isOutputAsText(ann);\n     public Boolean isOutputAsCData(Annotated ann) {\n         //There is no CData annotation in JAXB\n         return null;\n+    }\n+\n+    @Override\n+    public void setDefaultUseWrapper(boolean b) {\n+        // nothing to do with JAXB\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             wrapAndThrow(provider, e, bean, name);\n         } catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            JsonMappingException mapE = JsonMappingException.from(gen0,\n+                    \"Infinite recursion (StackOverflowError)\");\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             mapE.prependPath(new JsonMappingException.Reference(bean, name));\n             throw mapE;\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             wrapAndThrow(provider, e, bean, name);\n         } catch (StackOverflowError e) {\n-            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\", e);\n+            JsonMappingException mapE = JsonMappingException.from(gen0, \"Infinite recursion (StackOverflowError)\", e);\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             mapE.prependPath(new JsonMappingException.Reference(bean, name));\n             throw mapE;\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n     \n     @SuppressWarnings(\"resource\")\n     @Override\n-    public void serializeValue(JsonGenerator jgen, Object value)\n+    public void serializeValue(JsonGenerator gen, Object value)\n         throws IOException\n     {\n         if (value == null) {\n-            _serializeXmlNull(jgen);\n+            _serializeXmlNull(gen);\n             return;\n         }\n         final Class<?> cls = value.getClass();\n         final boolean asArray;\n-        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n+        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n         if (xgen == null) { // called by convertValue()\n             asArray = false;\n         } else {\n         // From super-class implementation\n         final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n         } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n             throw ioe;\n         } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n             }\n-            throw new JsonMappingException(msg, e);\n+            throw JsonMappingException.from(gen, msg, e);\n         }\n         // end of super-class implementation\n \n         if (asArray) {\n-            jgen.writeEndObject();\n+            gen.writeEndObject();\n         }\n     }\n \n     @SuppressWarnings(\"resource\")\n     @Override\n-    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n+    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType)\n         throws IOException\n     {\n         if (value == null) {\n-            _serializeXmlNull(jgen);\n+            _serializeXmlNull(gen);\n             return;\n         }\n         final boolean asArray;\n-        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n+        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n         if (xgen == null) { // called by convertValue()\n             asArray = false;\n         } else {\n         final JsonSerializer<Object> ser = findTypedValueSerializer(rootType, true, null);\n         // From super-class implementation\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n         } catch (Exception e) { // but others do need to be, to get path etc\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n             }\n-            throw new JsonMappingException(msg, e);\n+            throw JsonMappingException.from(gen, msg, e);\n         }\n         // end of super-class implementation\n \n         if (asArray) {\n-            jgen.writeEndObject();\n+            gen.writeEndObject();\n         }\n     }\n     \n     // @since 2.1\n     @SuppressWarnings(\"resource\")\n     @Override\n-    public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType,\n+    public void serializeValue(JsonGenerator gen, Object value, JavaType rootType,\n             JsonSerializer<Object> ser) throws IOException\n     {\n         if (value == null) {\n-            _serializeXmlNull(jgen);\n+            _serializeXmlNull(gen);\n             return;\n         }\n         final boolean asArray;\n-        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n+        final ToXmlGenerator xgen = _asXmlGenerator(gen);\n         if (xgen == null) { // called by convertValue()\n             asArray = false;\n         } else {\n         }\n         // From super-class implementation\n         try {\n-            ser.serialize(value, jgen, this);\n+            ser.serialize(value, gen, this);\n         } catch (IOException ioe) { // no wrapping for IO (and derived)\n             throw ioe;\n         } catch (Exception e) { // but others do need to be, to get path etc\n             if (msg == null) {\n                 msg = \"[no message for \"+e.getClass().getName()+\"]\";\n             }\n-            throw new JsonMappingException(msg, e);\n+            throw JsonMappingException.from(gen, msg, e);\n         }\n         // end of super-class implementation\n         if (asArray) {\n-            jgen.writeEndObject();\n+            gen.writeEndObject();\n         }\n     }\n \n         return new QName(ns, name.getSimpleName());\n     }\n \n-    protected ToXmlGenerator _asXmlGenerator(JsonGenerator jgen)\n+    protected ToXmlGenerator _asXmlGenerator(JsonGenerator gen)\n         throws JsonMappingException\n     {\n         // [Issue#71]: When converting, we actually get TokenBuffer, which is fine\n-        if (!(jgen instanceof ToXmlGenerator)) {\n+        if (!(gen instanceof ToXmlGenerator)) {\n             // but verify\n-            if (!(jgen instanceof TokenBuffer)) {\n-                throw new JsonMappingException(\"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"\n-                            +jgen.getClass().getName());\n-                }\n-                return null;\n-        }\n-        return (ToXmlGenerator) jgen;\n+            if (!(gen instanceof TokenBuffer)) {\n+                throw JsonMappingException.from(gen,\n+                        \"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"+gen.getClass().getName());\n+            }\n+            return null;\n+        }\n+        return (ToXmlGenerator) gen;\n     }    \n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedListsTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/NestedUnwrappedListsTest.java\n     public void setUp() throws Exception\n     {\n         super.setUp();\n-        JacksonXmlModule module = new JacksonXmlModule();\n-        module.setDefaultUseWrapper(false);\n-        _xmlMapper = new XmlMapper(module);\n+        _xmlMapper = new XmlMapper()\n+            .setDefaultUseWrapper(false);\n         _xmlMapper.setPropertyNamingStrategy(new PropertyNamingStrategy.PascalCaseStrategy());\n         _xmlMapper.enable(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY);\n     }", "timestamp": 1443755800, "metainfo": ""}