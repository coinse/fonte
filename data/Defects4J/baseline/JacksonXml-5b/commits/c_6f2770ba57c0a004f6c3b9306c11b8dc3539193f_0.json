{"sha": "6f2770ba57c0a004f6c3b9306c11b8dc3539193f", "log": "minor clean up", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n             BeanProperty property)\n         throws JsonMappingException\n     {\n-        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n-        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n-        /*\n         JavaType vt = _type;\n         if (vt == null) {\n             vt = ctxt.constructType(_delegatee.handledType());\n         }\n         JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n-        */\n-\n-        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, _type);\n         BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n         \n         // Let's go through the properties now...\n         HashSet<String> unwrappedNames = null;\n         while (it.hasNext()) {\n             SettableBeanProperty prop = it.next();\n-            /* First things first: only consider array/Collection types\n-             * (not perfect check, but simplest reasonable check)\n-             */\n+            // First things first: only consider array/Collection types\n+            // (not perfect check, but simplest reasonable check)\n             JavaType type = prop.getType();\n             if (!TypeUtil.isIndexedType(type)) {\n                 continue;\n             }\n             PropertyName wrapperName = prop.getWrapperName();\n             // skip anything with wrapper (should work as is)\n-            if (wrapperName != null && wrapperName != PropertyName.NO_NAME) {\n+            if ((wrapperName != null) && (wrapperName != PropertyName.NO_NAME)) {\n                 continue;\n             }\n             if (unwrappedNames == null) {\n      */\n \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n-        _configureParser(jp);\n-        return _delegatee.deserialize(jp,  ctxt);\n+        _configureParser(p);\n+        return _delegatee.deserialize(p,  ctxt);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt,\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt,\n             Object intoValue) throws IOException\n     {\n-        _configureParser(jp);\n-        return ((JsonDeserializer<Object>)_delegatee).deserialize(jp, ctxt, intoValue);\n+        _configureParser(p);\n+        return ((JsonDeserializer<Object>)_delegatee).deserialize(p, ctxt, intoValue);\n     }\n \n     @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer) throws IOException\n     {\n-        _configureParser(jp);\n-        return _delegatee.deserializeWithType(jp, ctxt, typeDeserializer);\n+        _configureParser(p);\n+        return _delegatee.deserializeWithType(p, ctxt, typeDeserializer);\n     }\n     \n     /*\n     /**********************************************************************\n      */\n \n-    protected final void _configureParser(JsonParser jp) throws IOException\n+    protected final void _configureParser(JsonParser p) throws IOException\n     {\n-        /* 19-Aug-2013, tatu: Although we should not usually get called with\n-         *   parser of other types, there are some cases where this may happen:\n-         *   specifically, during structural value conversions.\n-         */\n-        if (jp instanceof FromXmlParser) {\n-            ((FromXmlParser) jp).addVirtualWrapping(_namesToWrap);\n+        // 19-Aug-2013, tatu: Although we should not usually get called with\n+        //   parser of other types, there are some cases where this may happen:\n+        //   specifically, during structural value conversions.\n+        if (p instanceof FromXmlParser) {\n+            ((FromXmlParser) p).addVirtualWrapping(_namesToWrap);\n         }\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlBeanDeserializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlBeanDeserializerModifier.java\n \n         // Heuristics are bit tricky; but for now let's assume that if POJO\n         // can already work with VALUE_STRING, it's ok and doesn't need extra support\n-        if (!deser.getValueInstantiator().canCreateFromString()) {\n+        ValueInstantiator inst = deser.getValueInstantiator();\n+        // 03-Aug-2017, tatu: [dataformat-xml#254] suggests we also should\n+        //    allow passing `int`/`Integer`/`long`/`Long` cases, BUT\n+        //    unfortunately we can not simple use default handling. Would need\n+        //    coercion.\n+        if (!inst.canCreateFromString()) {\n             SettableBeanProperty textProp = _findSoleTextProp(config, deser.properties());\n             if (textProp != null) {\n                 return new XmlTextDeserializer(deser, textProp);\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTextDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTextDeserializer.java\n      * may change, but index will remain constant.\n      */\n     protected final int _xmlTextPropertyIndex;\n-    \n+\n     /**\n      * Actual property that is indicated to be of type \"XML Text\" (and\n      * is the only element-valued property)\n     protected final SettableBeanProperty _xmlTextProperty;\n \n     protected final ValueInstantiator _valueInstantiator;\n-    \n+\n     /*\n     /**********************************************************************\n     /* Construction\n         _xmlTextPropertyIndex = prop.getPropertyIndex();\n         _valueInstantiator = delegate.getValueInstantiator();\n     }\n-    \n+\n     public XmlTextDeserializer(BeanDeserializerBase delegate, int textPropIndex)\n     {\n         super(delegate);\n      */\n \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt)\n+        throws IOException\n     {\n-        if (jp.getCurrentToken() == JsonToken.VALUE_STRING) {\n+        if (p.getCurrentToken() == JsonToken.VALUE_STRING) {\n             Object bean = _valueInstantiator.createUsingDefault(ctxt);\n-            _xmlTextProperty.deserializeAndSet(jp, ctxt, bean);\n+            _xmlTextProperty.deserializeAndSet(p, ctxt, bean);\n             return bean;\n         }\n-        return _delegatee.deserialize(jp,  ctxt);\n+        return _delegatee.deserialize(p,  ctxt);\n     }\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt,\n-            Object bean)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser p, DeserializationContext ctxt,\n+            Object bean) throws IOException\n     {\n-        if (jp.getCurrentToken() == JsonToken.VALUE_STRING) {\n-            _xmlTextProperty.deserializeAndSet(jp, ctxt, bean);\n+        if (p.getCurrentToken() == JsonToken.VALUE_STRING) {\n+            _xmlTextProperty.deserializeAndSet(p, ctxt, bean);\n             return bean;\n         }\n-        return ((JsonDeserializer<Object>)_delegatee).deserialize(jp, ctxt, bean);\n+        return ((JsonDeserializer<Object>)_delegatee).deserialize(p, ctxt, bean);\n     }\n \n     @Override\n-    public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n+    public Object deserializeWithType(JsonParser p, DeserializationContext ctxt,\n             TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n-        return _delegatee.deserializeWithType(jp, ctxt, typeDeserializer);\n+        return _delegatee.deserializeWithType(p, ctxt, typeDeserializer);\n     }\n     \n     /*", "timestamp": 1501799223, "metainfo": ""}