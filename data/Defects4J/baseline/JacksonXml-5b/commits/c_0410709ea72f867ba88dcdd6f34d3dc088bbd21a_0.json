{"sha": "0410709ea72f867ba88dcdd6f34d3dc088bbd21a", "log": "Merge branch '2.7' into 2.8", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n      * is encountered. Used for suppressing indentation to allow empty\n      * elements.\n      * \n-     * @since 2.3.0\n+     * @since 2.3\n      */\n     protected transient boolean _justHadStartElement;\n     \n \n     public DefaultXmlPrettyPrinter() { }\n \n+    protected DefaultXmlPrettyPrinter(DefaultXmlPrettyPrinter base)\n+    {\n+        _arrayIndenter = base._arrayIndenter;\n+        _objectIndenter = base._objectIndenter;\n+        _spacesInObjectEntries = base._spacesInObjectEntries;\n+        _nesting = base._nesting;\n+    }\n+\n     public void indentArraysWith(Indenter i)\n     {\n         _arrayIndenter = (i == null) ? new NopIndenter() : i;\n     \n     @Override\n     public DefaultXmlPrettyPrinter createInstance() {\n-        return new DefaultXmlPrettyPrinter();\n+        return new DefaultXmlPrettyPrinter(this);\n     }\n \n     /*\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlModule.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlModule.java\n     \n     public JacksonXmlModule()\n     {\n-        super(\"JackxonXmlModule\", PackageVersion.VERSION);\n+        super(\"JacksonXmlModule\", PackageVersion.VERSION);\n     }\n     \n     @Override\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n     /**********************************************************\n      */\n \n-    /**\n-     * XML indentation differs from JSON indentation, thereby\n-     * need to change default pretty-printer\n-     */\n+    // 09-May-2016, tatu: Was removed from `jackson-databind` in 2.8; remove from\n+    //    here in 2.9.\n     @Deprecated // since 2.6\n-    @Override\n+//    @Override\n     protected PrettyPrinter _defaultPrettyPrinter() {\n         return new DefaultXmlPrettyPrinter();\n     }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlTypeResolverBuilder.java\n package com.fasterxml.jackson.dataformat.xml;\n \n+import java.io.IOException;\n import java.util.Collection;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n             return encodeXmlClassName(super.idFromValue(value));\n         }\n \n-        @SuppressWarnings(\"deprecation\")\n         @Override\n-        public JavaType typeFromId(String id) {\n-            return super.typeFromId(decodeXmlClassName(id));\n-        }\n-\n-        @Override\n-        public JavaType typeFromId(DatabindContext context, String id) {\n+        public JavaType typeFromId(DatabindContext context, String id) throws IOException {\n             return super.typeFromId(context, decodeXmlClassName(id));\n         }\n     }\n             return encodeXmlClassName(super.idFromValue(value));\n         }\n \n-        @SuppressWarnings(\"deprecation\")\n         @Override\n-        public JavaType typeFromId(String id) {\n-            return super.typeFromId(decodeXmlClassName(id));\n-        }\n-\n-        @Override\n-        public JavaType typeFromId(DatabindContext context, String id) {\n+        public JavaType typeFromId(DatabindContext context, String id) throws IOException {\n             return super.typeFromId(context, decodeXmlClassName(id));\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n package com.fasterxml.jackson.dataformat.xml.deser;\n \n import java.io.IOException;\n+import java.io.Writer;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.util.Set;\n         return false;\n     }\n \n+    @Override // since 2.8\n+    public int getText(Writer writer) throws IOException\n+    {\n+        String str = getText();\n+        if (str == null) {\n+            return 0;\n+        }\n+        writer.write(str);\n+        return str.length();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public API, access to token information, binary\n     protected void _handleEOF() throws JsonParseException\n     {\n         if (!_parsingContext.inRoot()) {\n-            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n-        }\n-    }\n-    \n+            String marker = _parsingContext.inArray() ? \"Array\" : \"Object\";\n+            _reportInvalidEOF(String.format(\n+                    \": expected close marker for %s (start marker at %s)\",\n+                    marker,\n+                    _parsingContext.getStartLocation(_ioContext.getSourceReference())),\n+                    null);\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Internal methods\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n     protected int _currentState;\n \n     protected int _attributeCount;\n-    \n+\n+    /**\n+     * If true we have a START_ELEMENT with mixed text\n+     *\n+     * @since 2.8\n+     */\n+    protected boolean _mixedText;\n+\n     /**\n      * Index of the next attribute of the current START_ELEMENT\n      * to return (as field name and value pair), if any; -1\n         // Anything to do in failed case? Roll back whatever we found or.. ?\n         return null;\n     }\n-    \n+\n     /*\n     /**********************************************************************\n     /* Internal methods, parsing\n             }\n             // otherwise need to find START/END_ELEMENT or text\n             String text = _collectUntilTag();\n-            // If it's START_ELEMENT, ignore any text\n-            if (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\n-                return _initStartElement();\n+            final boolean startElementNext = _xmlReader.getEventType() == XMLStreamReader.START_ELEMENT;\n+            // If we have no/all-whitespace text followed by START_ELEMENT, ignore text\n+            if (startElementNext) {\n+                if (text == null || _allWs(text)) {\n+                    _mixedText = false;\n+                    return _initStartElement();\n+                }\n+                _mixedText = true;\n+                _textValue = text;\n+                return (_currentState = XML_TEXT);\n             }\n             // For END_ELEMENT we will return text, if any\n             if (text != null) {\n+                _mixedText = false;\n                 _textValue = text;\n                 return (_currentState = XML_TEXT);\n             }\n+            _mixedText = false;\n             return _handleEndElement();\n+\n         case XML_ATTRIBUTE_NAME:\n             // if we just returned name, will need to just send value next\n             return (_currentState = XML_ATTRIBUTE_VALUE);\n         case XML_TEXT:\n-            // text is always followed by END_ELEMENT\n+            // mixed text with other elements\n+            if (_mixedText){\n+                _mixedText = false;\n+                return _initStartElement();\n+            }\n+            // text followed by END_ELEMENT\n             return _handleEndElement();\n         case XML_END:\n             return XML_END;\n                 location.getColumnNumber());\n     }\n \n+\n+    protected boolean _allWs(String str)\n+    {\n+        final int len = (str == null) ? 0 : str.length();\n+        if (len > 0) {\n+            for (int i = 0; i < len; ++i) {\n+                if (str.charAt(i) > ' ') {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+    \n     // for DEBUGGING\n     @Override\n     public String toString()\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n     /**********************************************************\n      */\n \n-    /**\n-     * Standard JSON indenter does not work well with XML, use\n-     * default XML indenter instead.\n-     *<p>\n-     * !!! TODO: same as implementation in core 2.6; override may be\n-     * removed from 2.8\n-     */\n-    @Override\n-    public final JsonGenerator useDefaultPrettyPrinter()\n-    {\n-        // related to [dataformat-xml#136], need to verify:\n-        if (_cfgPrettyPrinter != null) {\n-            return this;\n-        }\n-        return setPrettyPrinter(_constructDefaultPrettyPrinter());\n-    }\n-\n     @Override\n     protected PrettyPrinter _constructDefaultPrettyPrinter() {\n         return new DefaultXmlPrettyPrinter();\n         }\n         return this;\n     }\n+\n+    @Override\n+    public boolean canWriteFormattedNumbers() { return true; }\n \n     // @since 2.7.5\n     public boolean inRoot() {\n     public final void writeEndArray() throws IOException\n     {\n         if (!_writeContext.inArray()) {\n-            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n+            _reportError(\"Current context not Array but \"+_writeContext.typeDesc());\n         }\n         if (_cfgPrettyPrinter != null) {\n             _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n     public final void writeEndObject() throws IOException\n     {\n         if (!_writeContext.inObject()) {\n-            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n+            _reportError(\"Current context not Object but \"+_writeContext.typeDesc());\n         }\n         _writeContext = _writeContext.getParent();\n         if (_cfgPrettyPrinter != null) {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/UnwrappingXmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/UnwrappingXmlBeanSerializer.java\n package com.fasterxml.jackson.dataformat.xml.ser;\n \n import java.io.IOException;\n+import java.util.Set;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n         _nameTransformer = src._nameTransformer;\n     }\n \n-    protected UnwrappingXmlBeanSerializer(UnwrappingXmlBeanSerializer src, String[] toIgnore)\n+    protected UnwrappingXmlBeanSerializer(UnwrappingXmlBeanSerializer src, Set<String> toIgnore)\n     {\n         super(src, toIgnore);\n         _nameTransformer = src._nameTransformer;\n         return new UnwrappingXmlBeanSerializer(this, _objectIdWriter, filterId);\n     }\n \n-    @Override\n-    protected BeanSerializerBase withIgnorals(String[] toIgnore)\n-    {\n+    @Override // since 2.8\n+    protected BeanSerializerBase withIgnorals(Set<String> toIgnore) {\n         return new UnwrappingXmlBeanSerializer(this, toIgnore);\n     }\n \n      * so implementation will simply return 'this'.\n      */\n     @Override\n-    protected BeanSerializerBase asArraySerializer()\n-    {\n+    protected BeanSerializerBase asArraySerializer() {\n         return this;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n package com.fasterxml.jackson.dataformat.xml.ser;\n \n import java.io.IOException;\n+import java.util.Set;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n         super(src, objectIdWriter);\n     }\n \n-    public XmlBeanSerializer(XmlBeanSerializerBase src, String[] toIgnore) {\n+    public XmlBeanSerializer(XmlBeanSerializerBase src, Set<String> toIgnore) {\n         super(src, toIgnore);\n     }\n \n     /* Life-cycle: factory methods, fluent factories\n     /**********************************************************\n      */\n-\n \n     @Override\n     public JsonSerializer<Object> unwrappingSerializer(NameTransformer unwrapper) {\n     }\n \n     @Override\n-    protected BeanSerializerBase withIgnorals(String[] toIgnore) {\n+    protected BeanSerializerBase withIgnorals(Set<String> toIgnore) {\n         return new XmlBeanSerializer(this, toIgnore);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n \n import java.io.IOException;\n import java.util.BitSet;\n+import java.util.Set;\n \n import javax.xml.namespace.QName;\n \n         _cdata = src._cdata;\n     }\n \n-    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, String[] toIgnore)\n+    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, Set<String> toIgnore)\n     {\n         super(src, toIgnore);\n         _attributeCount = src._attributeCount;\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n \n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n-        if (jgen instanceof ToXmlGenerator)\n-        _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+        // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n+        //    configured root name...\n+        QName rootName = _rootNameFromConfig();\n+        if (rootName == null) {\n+            rootName = ROOT_NAME_FOR_NULL;\n+        }\n+        if (jgen instanceof ToXmlGenerator) {\n+            _initWithRootName((ToXmlGenerator) jgen, rootName);\n+        }\n         super.serializeValue(jgen, null);\n     }\n     \n         }\n         xgen.initGenerator();\n         String ns = rootName.getNamespaceURI();\n-        /* [Issue#26] If we just try writing root element with namespace,\n+        /* [dataformat-xml#26] If we just try writing root element with namespace,\n          * we will get an explicit prefix. But we'd rather use the default\n          * namespace, so let's try to force that.\n          */\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/TypeUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/TypeUtil.java\n package com.fasterxml.jackson.dataformat.xml.util;\n \n import java.util.Collection;\n-import java.util.Map;\n \n import com.fasterxml.jackson.databind.JavaType;\n \n             if (cls == byte[].class || cls == char[].class) {\n                 return false;\n             }\n-            // issue#5: also, should not add wrapping for Maps\n-            if (Map.class.isAssignableFrom(cls)) {\n+            // Also, should not add wrapping for Maps\n+            // [dataformat-xml#220]: nor map-like (Scala Map) types\n+            if (type.isMapLikeType()) {\n                 return false;\n             }\n             return true;\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/EmptyListDeser124Test.java\n+package com.fasterxml.jackson.dataformat.xml.failing;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.dataformat.xml.*;\n+\n+// for [dataformat-xml#124]\n+public class EmptyListDeser124Test extends XmlTestBase\n+{\n+    public static class TestList {\n+        @JsonProperty(\"list\")\n+        public List<Object> list;\n+    }\n+\n+    // [dataformat-xml#124]\n+    public  void test124() throws Exception {\n+        final XmlMapper xmlMapper = new XmlMapper();\n+        TestList originalObject = new TestList();\n+        originalObject.list = new ArrayList<Object>();\n+        String xml = xmlMapper.writeValueAsString(originalObject);\n+//System.err.println(xml); // print <TestList><list/>></TestList>\n+\n+        TestList result = xmlMapper.readValue(xml, TestList.class);\n+\n+        assertNotNull(result.list);\n+        assertEquals(0, result.list.size());\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedDeserIssue86.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedDeserIssue86.java\n package com.fasterxml.jackson.dataformat.xml.failing;\n \n+import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n \n import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n         final Issue86 after = mapper.readValue(xml, Issue86.class);\n         assertEquals(before, after);\n     }\n+\n+\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/RootNameTest.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.databind.ObjectWriter;\n+import com.fasterxml.jackson.dataformat.xml.*;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n+\n+public class RootNameTest extends XmlTestBase\n+{\n+    static class RootBeanBase\n+    {\n+        public String value;\n+\n+        protected RootBeanBase() { this(\"123\"); }\n+        public RootBeanBase(String v) {\n+            value = v;\n+        }\n+    }\n+\n+    @JacksonXmlRootElement(localName=\"root\")\n+    static class RootBean extends RootBeanBase\n+    {\n+        protected RootBean() { super(); }\n+    }\n+\n+    @JacksonXmlRootElement(localName=\"nsRoot\", namespace=\"http://foo\")\n+    static class NsRootBean\n+    {\n+        public String value = \"abc\";\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    protected XmlMapper _xmlMapper = new XmlMapper();\n+\n+    // Unit test to verify that root name is properly set\n+    public void testRootNameAnnotation() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new StringBean());\n+        \n+        // Hmmh. Looks like JDK Stax may adds bogus ns declaration. As such,\n+        // let's just check that name starts ok...\n+        if (!xml.startsWith(\"<StringBean\")) {\n+            fail(\"Expected root name of 'StringBean'; but XML document is [\"+xml+\"]\");\n+        }\n+\n+        // and then see that basic non-namespace root is ok\n+        xml = _xmlMapper.writeValueAsString(new RootBean());\n+        assertEquals(\"<root><value>123</value></root>\", xml);\n+\n+        // and namespace one too\n+        xml = _xmlMapper.writeValueAsString(new NsRootBean());\n+        if (xml.indexOf(\"nsRoot\") < 0) { // verify localName\n+            fail(\"Expected root name of 'nsRoot'; but XML document is [\"+xml+\"]\");\n+        }\n+        // and NS declaration\n+        if (xml.indexOf(\"http://foo\") < 0) {\n+            fail(\"Expected NS declaration for 'http://foo', not found, XML document is [\"+xml+\"]\");\n+        }\n+    }\n+\n+    public void testDynamicRootName() throws IOException\n+    {\n+        String xml;\n+\n+        ObjectWriter w = _xmlMapper.writer().withRootName(\"rudy\");\n+\n+        xml = w.writeValueAsString(new StringBean(\"foo\"));\n+        assertEquals(\"<rudy><text>foo</text></rudy>\", xml);\n+\n+        xml = w.writeValueAsString(new StringBean(null));\n+        assertEquals(\"<rudy><text/></rudy>\", xml);\n+\n+        // and even with null will respect configured root name\n+        xml = w.writeValueAsString(null);\n+        assertEquals(\"<rudy/>\", xml);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/UnwrappingWithXMLTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/UnwrappingWithXMLTest.java\n      */\n \n     /**\n-   * Simple test to verify that explicit schema mapping works fine\n+     * Simple test to verify that explicit schema mapping works fine\n      * with unwrapped entities\n      */\n     public void testSimpleUnwrappingRoundtrip()\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/XmlTextTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/XmlTextTest.java\n import com.fasterxml.jackson.annotation.JsonInclude.Include;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText;\n \n public class XmlTextTest extends XmlTestBase\n {\n     @JsonPropertyOrder({\"first\",\"second\"})\n-    class Data{\n+    static class Data{\n         @JacksonXmlText\n         public String first;\n         public String second;\n         }\n     }\n \n+    static class Phone\n+    {\n+        @JacksonXmlProperty(isAttribute = true)\n+        public String phoneType = \"mobile\";\n+\n+        @JacksonXmlText\n+        public String phoneNumber = \"555-1234\";\n+    }\n+\n+    static class WindSpeed {\n+        @JacksonXmlProperty(isAttribute = true)\n+        public String units;\n+\n+        @JacksonXmlText\n+        public int value;\n+\n+        public Radius radius;\n+    }\n+\n+    static class Radius {\n+        @JacksonXmlText\n+        public int value;\n+    }\n+\n+        \n+    /*\n+    /**********************************************************\n+    /* Test methods\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = xmlMapper(true);\n+    \n     public void testXmlTextWithSuppressedValue() throws Exception\n     {\n         final XmlMapper mapper = new XmlMapper();\n         String expectedXml = \"<Data><second>second</second></Data>\";\n         assertEquals(expectedXml, xml);\n     }\n+\n+    // for [dataformat-xml#196]\n+    public void testMixedContent() throws Exception\n+    {\n+        WindSpeed result = MAPPER.readValue(\"<windSpeed units='kt'> 27 <radius>20</radius></windSpeed>\",\n+                WindSpeed.class);\n+        assertEquals(27, result.value);\n+        assertNotNull(result.radius);\n+        assertEquals(20, result.radius.value);\n+    }\n+\n+    // for [dataformat-xml#198]\n+    public void testSimple198() throws Exception\n+    {\n+        String xml = MAPPER.writeValueAsString(new Phone());\n+        Phone result = MAPPER.readValue(xml, Phone.class);\n+        assertNotNull(result);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestSerialization.java\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlCData;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n-import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n \n @SuppressWarnings(\"serial\")\n public class TestSerialization extends XmlTestBase\n {\n-    /*\n-    /**********************************************************\n-    /* Helper types\n-    /**********************************************************\n-     */\n-\n     static class StringBean2\n     {\n         public String text = \"foobar\";\n         public MapBean() { }\n         public MapBean(Map<String,Integer> v) { map = v; }\n     }\n-    \n+\n     static class NsElemBean\n     {\n         @JacksonXmlProperty(namespace=\"http://foo\")\n         public String text = \"blah\";\n-    }\n-\n-    @JacksonXmlRootElement(localName=\"root\")\n-    static class RootBean\n-    {\n-        public String value = \"123\";\n-    }\n-\n-    @JacksonXmlRootElement(localName=\"nsRoot\", namespace=\"http://foo\")\n-    static class NsRootBean\n-    {\n-        public String value = \"abc\";\n     }\n \n     static class CDataStringBean\n     }\n \n     static class CustomMap extends LinkedHashMap<String, Integer> { }\n-    \n-    /*\n-    /**********************************************************\n-    /* Set up\n-    /**********************************************************\n-     */\n \n-    protected XmlMapper _xmlMapper;\n-\n-    // let's actually reuse XmlMapper to make things bit faster\n-    @Override\n-    public void setUp() throws Exception {\n-        super.setUp();\n-        _xmlMapper = new XmlMapper();\n-    }\n-    \n     /*\n     /**********************************************************\n     /* Unit tests\n     /**********************************************************\n      */\n \n-    // Unit test to verify that root name is properly set\n-    public void testRootName() throws IOException\n-    {\n-        String xml = _xmlMapper.writeValueAsString(new StringBean());\n-        \n-        // Hmmh. Looks like JDK Stax may adds bogus ns declaration. As such,\n-        // let's just check that name starts ok...\n-        if (!xml.startsWith(\"<StringBean\")) {\n-            fail(\"Expected root name of 'StringBean'; but XML document is [\"+xml+\"]\");\n-        }\n+    protected XmlMapper _xmlMapper = new XmlMapper();\n \n-        // and then see that basic non-namespace root is ok\n-        xml = _xmlMapper.writeValueAsString(new RootBean());\n-        assertEquals(\"<root><value>123</value></root>\", xml);\n-\n-        // and namespace one too\n-        xml = _xmlMapper.writeValueAsString(new NsRootBean());\n-        if (xml.indexOf(\"nsRoot\") < 0) { // verify localName\n-            fail(\"Expected root name of 'nsRoot'; but XML document is [\"+xml+\"]\");\n-        }\n-        // and NS declaration\n-        if (xml.indexOf(\"http://foo\") < 0) {\n-            fail(\"Expected NS declaration for 'http://foo', not found, XML document is [\"+xml+\"]\");\n-        }\n-    }\n-    \n     public void testSimpleAttribute() throws IOException\n     {\n         String xml = _xmlMapper.writeValueAsString(new AttributeBean());\n         xml = removeSjsxpNamespace(xml);\n         assertEquals(\"<AttributeBean attr=\\\"something\\\"/>\", xml);\n-    }\n-\n-    public void testSimpleAttrAndElem() throws IOException\n-    {\n-        String xml = _xmlMapper.writeValueAsString(new AttrAndElem());\n-        xml = removeSjsxpNamespace(xml);\n-        assertEquals(\"<AttrAndElem id=\\\"42\\\"><elem>whatever</elem></AttrAndElem>\", xml);\n     }\n \n     public void testSimpleNsElem() throws IOException\n         xml = removeSjsxpNamespace(xml);\n         // here we assume woodstox automatic prefixes, not very robust but:\n         assertEquals(\"<NsElemBean><wstxns1:text xmlns:wstxns1=\\\"http://foo\\\">blah</wstxns1:text></NsElemBean>\", xml);\n+    }\n+    \n+    public void testSimpleAttrAndElem() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new AttrAndElem());\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<AttrAndElem id=\\\"42\\\"><elem>whatever</elem></AttrAndElem>\", xml);\n     }\n \n     @SuppressWarnings(\"boxing\")\n         assertEquals(\"<CDataStringArrayBean><value><value><![CDATA[<some<data\\\"]]></value><value><![CDATA[abc]]></value></value></CDataStringArrayBean>\", xml);\n     }\n     \n-    // for [Issue#41]\n+    // for [dataformat-xml#41]\n     public void testCustomSerializer() throws Exception\n     {\n         JacksonXmlModule module = new JacksonXmlModule();\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/stream/XmlParserTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/stream/XmlParserTest.java\n         // Former could be worked around; latter less so at this point.\n \n         // So, for now, let's just do sort of minimal verification, manually\n-        JsonParser jp = _xmlMapper.getFactory().createParser(xml);\n-        \n-        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // main object\n-\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Image'\n-        verifyFieldName(jp, \"Image\");\n-        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'image' object\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n-        verifyFieldName(jp, \"Width\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_WIDTH), jp.getText());\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n-        verifyFieldName(jp, \"Height\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), jp.getText());\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Title'\n-        verifyFieldName(jp, \"Title\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Thumbnail'\n-        verifyFieldName(jp, \"Thumbnail\");\n-        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'thumbnail' object\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Url'\n-        verifyFieldName(jp, \"Url\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n-        verifyFieldName(jp, \"Height\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), jp.getText());\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n-        verifyFieldName(jp, \"Width\");\n+        JsonParser p = _xmlMapper.getFactory().createParser(xml);\n+        \n+        assertToken(JsonToken.START_OBJECT, p.nextToken()); // main object\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Image'\n+        verifyFieldName(p, \"Image\");\n+        assertToken(JsonToken.START_OBJECT, p.nextToken()); // 'image' object\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Width'\n+        verifyFieldName(p, \"Width\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_WIDTH), p.getText());\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Height'\n+        verifyFieldName(p, \"Height\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), p.getText());\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Title'\n+        verifyFieldName(p, \"Title\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Thumbnail'\n+        verifyFieldName(p, \"Thumbnail\");\n+        assertToken(JsonToken.START_OBJECT, p.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Url'\n+        verifyFieldName(p, \"Url\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Height'\n+        verifyFieldName(p, \"Height\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), p.getText());\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Width'\n+        verifyFieldName(p, \"Width\");\n         // Width value is actually a String in the example\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(jp));\n-\n-        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(p));\n+\n+        assertToken(JsonToken.END_OBJECT, p.nextToken()); // 'thumbnail' object\n \n         // Note: arrays are \"eaten\"; wrapping is done using BeanPropertyWriter, so:\n-        //assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'IDs'\n-        //verifyFieldName(jp, \"IDs\");\n-        //assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'ids' array\n-\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n-        verifyFieldName(jp, \"IDs\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); \n-        verifyFieldName(jp, \"IDs\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n-        verifyFieldName(jp, \"IDs\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); \n-        verifyFieldName(jp, \"IDs\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), getAndVerifyText(jp));\n+        //assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'IDs'\n+        //verifyFieldName(p, \"IDs\");\n+        //assertToken(JsonToken.START_OBJECT, p.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        verifyFieldName(p, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); \n+        verifyFieldName(p, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        verifyFieldName(p, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); \n+        verifyFieldName(p, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), getAndVerifyText(p));\n \n         // no matching entry for array:\n-        //assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'ids' array\n-\n-        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'image' object\n-\n-        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // main object\n-        \n-        jp.close();\n+        //assertToken(JsonToken.END_OBJECT, p.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.END_OBJECT, p.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.END_OBJECT, p.nextToken()); // main object\n+        \n+        p.close();\n     }\n \n     /**\n         assertEquals(\"property\", xp.getCurrentName());\n         assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n         assertEquals(\"123\", xp.getText());\n+\n+        StringWriter w = new StringWriter();\n+        assertEquals(3, xp.getText(w));\n+        assertEquals(\"123\", w.toString());\n+        \n         assertTrue(xp.getParsingContext().inObject());\n         assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </property>\n         assertTrue(xp.getParsingContext().inArray());\n \n         assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <offset>\n         assertEquals(\"offset\", xp.getCurrentName());\n+\n+        StringWriter w = new StringWriter();\n+        assertEquals(6, xp.getText(w));\n+        assertEquals(\"offset\", w.toString());\n+        \n         assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n         assertEquals(\"9\", xp.getText());\n \n+        w = new StringWriter();\n+        assertEquals(1, xp.getText(w));\n+        assertEquals(\"9\", w.toString());\n+        \n         assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </data>\n         xp.close();\n     }\n     {\n         StringWriter w = new StringWriter();\n \n-        JsonParser jp = _xmlFactory.createParser(xml);\n+        JsonParser p = _xmlFactory.createParser(xml);\n         JsonGenerator jg = _jsonFactory.createGenerator(w);\n-        while (jp.nextToken() != null) {\n-            jg.copyCurrentEvent(jp);\n+        while (p.nextToken() != null) {\n+            jg.copyCurrentEvent(p);\n         }\n-        jp.close();\n+        p.close();\n         jg.close();\n         return w.toString();\n     }", "timestamp": 1487127523, "metainfo": ""}