{"sha": "22a1a66cbf14ecdb99685876980286d9288edc41", "log": "Merge branch '2.4' into 2.5  Conflicts: \tpom.xml \trelease-notes/VERSION", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n     @Override\n     public final JsonGenerator useDefaultPrettyPrinter()\n     {\n+        // related to [dataformat-xml#136], need to verify:\n+        if (_cfgPrettyPrinter != null) {\n+            return this;\n+        }\n         return setPrettyPrinter(new DefaultXmlPrettyPrinter());\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n         }\n         return null;\n     }\n+\n+    @Override\n+    public Boolean isOutputAsCData(Annotated ann) {\n+        JacksonXmlCData prop = ann.getAnnotation(JacksonXmlCData.class);\n+        if (prop != null) {\n+            return prop.value() ? Boolean.TRUE : Boolean.FALSE;\n+        }\n+        return null;\n+    }\n     \n     /*\n     /**********************************************************************\n      * that cleans up type id property name to be a valid xml name.\n      */\n     @Override\n-    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder()\n-    {\n+    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder() {\n         return new XmlTypeResolverBuilder();\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlModule.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlModule.java\n     /* Internal methods\n     /**********************************************************************\n      */\n-    \n-    protected AnnotationIntrospector _constructIntrospector()\n-    {\n+\n+    protected AnnotationIntrospector _constructIntrospector() {\n         return new JacksonXmlAnnotationIntrospector(_cfgDefaultUseWrapper);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n      * it should be serialized as text, without element wrapper.\n      */\n     public Boolean isOutputAsText(Annotated ann);\n+\n+    /**\n+     * Method used to check whether given annotated element\n+     * (field, method, constructor parameter) has indicator that suggests\n+     * it should be wrapped in a CDATA tag.\n+     */\n+    public Boolean isOutputAsCData(Annotated ann);\n \n     /*\n     /**********************************************************************\n             }\n             return value;\n         }\n+\n+        @Override\n+        public Boolean isOutputAsCData(Annotated ann) {\n+            Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsCData(ann);\n+            if (value == null && _xmlSecondary != null) {\n+                value = _xmlSecondary.isOutputAsCData(ann);\n+            }\n+            return value;\n+        }\n     }\n \n     /*\n         public Boolean isOutputAsText(Annotated ann) {\n             return _intr.isOutputAsText(ann);\n         }\n-        \n+\n+        @Override\n+        public Boolean isOutputAsCData(Annotated ann) {\n+            //There is no CData annotation in JAXB\n+            return null;\n+        }\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlFactory.java\n */\n public class XmlFactory extends JsonFactory\n {\n-    private static final long serialVersionUID = -2793875812715996133L;\n+    // For 2.5:\n+    private static final long serialVersionUID = 1897624416641000209L;\n \n     /**\n      * Name used to identify XML format\n     public ToXmlGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException\n     {\n         // false -> we won't manage the stream unless explicitly directed to\n-        return new ToXmlGenerator(_createContext(out, false),\n+        IOContext ctxt = _createContext(out, false);\n+        ctxt.setEncoding(enc);\n+        return new ToXmlGenerator(ctxt,\n                 _generatorFeatures, _xmlGeneratorFeatures,\n                 _objectCodec, _createXmlWriter(out));\n     }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n  */\n public class XmlMapper extends ObjectMapper\n {\n-    private static final long serialVersionUID = -724333029147285918L;\n+    // as of 2.5\n+    private static final long serialVersionUID = -1212805483143619605L;\n \n     protected final static JacksonXmlModule DEFAULT_XML_MODULE = new JacksonXmlModule();\n     \n      * \n      * @since 2.1\n      */\n-    protected void setXMLTextElementName(String name)\n-    {\n+    protected void setXMLTextElementName(String name) {\n         ((XmlFactory) _jsonFactory).setXMLTextElementName(name);\n     }\n \n     protected PrettyPrinter _defaultPrettyPrinter() {\n         return new DefaultXmlPrettyPrinter();\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper methods\n-    /**********************************************************\n-     */\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlPrettyPrinter.java\n     public void writeEndElement(XMLStreamWriter2 sw, int nrOfEntries) throws XMLStreamException;\n \n     public void writeLeafElement(XMLStreamWriter2 sw,\n-    \t\tString nsURI, String localName, String text)\n+    \t\tString nsURI, String localName, String text, boolean isCData)\n         throws XMLStreamException;\n \n     public void writeLeafElement(XMLStreamWriter2 sw,\n     \t\tString nsURI, String localName,\n-    \t\tchar[] buffer, int offset, int len)\n+    \t\tchar[] buffer, int offset, int len, boolean isCData)\n         throws XMLStreamException;\n     \n     public void writeLeafElement(XMLStreamWriter2 sw,\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/annotation/JacksonXmlCData.java\n+package com.fasterxml.jackson.dataformat.xml.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Adding this annotation will result in value of the property to be serialized\n+ * within a CData tag.  Only use on String properties and String collections.\n+ */\n+@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface JacksonXmlCData\n+{\n+    /**\n+     * Whether the property text should always be within a CData block\n+     * when serialized.\n+     */\n+    public boolean value() default true;\n+}\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n      * Enumeration that defines all togglable features for XML parsers\n      */\n     public enum Feature {\n-        DUMMY_PLACEHOLDER(false)\n         ;\n \n         final boolean _defaultState;\n     /* Parsing state\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * Information about parser context, context in which\n      * the next token is to be parsed (root, array, object).\n      */\n     protected XmlReadContext _parsingContext;\n-    \n+\n     protected final XmlTokenStream _xmlTokens;\n-\n-    /**\n+    /**\n+     * \n      * We need special handling to keep track of whether a value\n      * may be exposed as simple leaf value.\n      */\n     protected String _currText;\n \n     protected Set<String> _namesToWrap;\n-    \n+\n     /*\n     /**********************************************************\n     /* Parsing state, parsed values\n     /**********************************************************\n      */\n-    \n+\n     /**\n      * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n      * we better reuse it for remainder of content.\n     /* Life-cycle\n     /**********************************************************\n      */\n-    \n+\n     public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\n             ObjectCodec codec, XMLStreamReader xmlReader)\n     {\n         _xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n     }\n \n+    @Override\n+    public Version version() {\n+        return PackageVersion.VERSION;\n+    }\n+    \n     @Override\n     public ObjectCodec getCodec() {\n         return _objectCodec;\n     public boolean isClosed() { return _closed; }\n \n     @Override\n-    public XmlReadContext getParsingContext()\n-    {\n+    public XmlReadContext getParsingContext() {\n         return _parsingContext;\n     }\n \n      * that starts the current token.\n      */\n     @Override\n-    public JsonLocation getTokenLocation()\n-    {\n+    public JsonLocation getTokenLocation() {\n         return _xmlTokens.getTokenLocation();\n     }\n \n      * usually for error reporting purposes\n      */\n     @Override\n-    public JsonLocation getCurrentLocation()\n-    {\n+    public JsonLocation getCurrentLocation() {\n         return _xmlTokens.getCurrentLocation();\n     }\n \n     */\n \n     @Override\n-    public JsonToken nextToken() throws IOException, JsonParseException\n+    public JsonToken nextToken() throws IOException\n     {\n         _binaryValue = null; // to fix [Issue-29]\n         if (_nextToken != null) {\n             return t;\n         }\n         int token = _xmlTokens.next();\n-        \n+\n         /* Need to have a loop just because we may have to eat/convert\n          * a start-element that indicates an array element.\n          */\n         return null;\n     }\n     \n+    /*\n+    /**********************************************************\n+    /* Overrides of specialized nextXxx() methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method overridden to support more reliable deserialization of\n+     * String collections.\n+     */\n+    @Override\n+    public String nextTextValue() throws IOException\n+    {\n+        _binaryValue = null;\n+        if (_nextToken != null) {\n+            JsonToken t = _nextToken;\n+            _currToken = t;\n+            _nextToken = null;\n+\n+            // expected case; yes, got a String\n+            if (t == JsonToken.VALUE_STRING) {\n+                return _currText;\n+            }\n+            _updateState(t);\n+            return null;\n+        }\n+\n+        int token = _xmlTokens.next();\n+\n+        // mostly copied from 'nextToken()'\n+        while (token == XmlTokenStream.XML_START_ELEMENT) {\n+            if (_mayBeLeaf) {\n+                _nextToken = JsonToken.FIELD_NAME;\n+                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                _currToken = JsonToken.START_OBJECT;\n+                return null;\n+            }\n+            if (_parsingContext.inArray()) {\n+                token = _xmlTokens.next();\n+                _mayBeLeaf = true;\n+                continue;\n+            }\n+            String name = _xmlTokens.getLocalName();\n+            _parsingContext.setCurrentName(name);\n+            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n+                _xmlTokens.repeatStartElement();\n+            }\n+            _mayBeLeaf = true;\n+            _currToken = JsonToken.FIELD_NAME;\n+            return null;\n+        }\n+\n+        // Ok; beyond start element, what do we get?\n+        switch (token) {\n+        case XmlTokenStream.XML_END_ELEMENT:\n+            if (_mayBeLeaf) {\n+                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n+                _mayBeLeaf = false;\n+                _currToken = JsonToken.VALUE_STRING;\n+                return (_currText = \"\");\n+            }\n+            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n+            _parsingContext = _parsingContext.getParent();\n+            _namesToWrap = _parsingContext.getNamesToWrap();\n+            break;\n+            \n+        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n+            // If there was a chance of leaf node, no more...\n+            if (_mayBeLeaf) {\n+                _mayBeLeaf = false;\n+                _nextToken = JsonToken.FIELD_NAME;\n+                _currText = _xmlTokens.getText();\n+                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                _currToken = JsonToken.START_OBJECT;\n+            } else {\n+                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+                _currToken = JsonToken.FIELD_NAME;\n+            }\n+            break;\n+        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n+            _currText = _xmlTokens.getText();\n+            _currToken = JsonToken.VALUE_STRING;\n+            break;\n+        case XmlTokenStream.XML_TEXT:\n+            _currText = _xmlTokens.getText();\n+            if (_mayBeLeaf) {\n+                _mayBeLeaf = false;\n+                // Also: must skip following END_ELEMENT\n+                _xmlTokens.skipEndElement();\n+\n+                // NOTE: this is different from nextToken() -- NO work-around\n+                // for otherwise empty List/array\n+                _currToken = JsonToken.VALUE_STRING;\n+                return _currText;\n+            }\n+            // If not a leaf, need to transform into property...\n+            _parsingContext.setCurrentName(_cfgNameForTextElement);\n+            _nextToken = JsonToken.VALUE_STRING;\n+            _currToken = JsonToken.FIELD_NAME;\n+            break;\n+        case XmlTokenStream.XML_END:\n+            _currToken = null;\n+        }\n+        return null;\n+    }\n+\n+\n+    private void _updateState(JsonToken t)\n+    {\n+        switch (t) {\n+        case START_OBJECT:\n+            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+            break;\n+        case START_ARRAY:\n+            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n+            break;\n+        case END_OBJECT:\n+        case END_ARRAY:\n+            _parsingContext = _parsingContext.getParent();\n+            _namesToWrap = _parsingContext.getNamesToWrap();\n+            break;\n+        case FIELD_NAME:\n+            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+            break;\n+        default:\n+        }\n+    }\n+\n     /*\n     /**********************************************************\n     /* Public API, access to token information, text\n         }        \n         return _binaryValue;\n     }\n-    \n-    @SuppressWarnings(\"resource\")\n-    protected byte[] _decodeBase64(Base64Variant b64variant)\n-        throws IOException, JsonParseException\n+\n+    protected byte[] _decodeBase64(Base64Variant b64variant) throws IOException\n     {\n         ByteArrayBuilder builder = _getByteArrayBuilder();\n         final String str = getText();\n      */\n \n     @Override\n-    public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n-    {\n+    public BigInteger getBigIntegerValue() throws IOException {\n         // TODO Auto-generated method stub\n         return null;\n     }\n \n     @Override\n-    public BigDecimal getDecimalValue() throws IOException, JsonParseException\n-    {\n+    public BigDecimal getDecimalValue() throws IOException {\n         // TODO Auto-generated method stub\n         return null;\n     }\n \n     @Override\n-    public double getDoubleValue() throws IOException, JsonParseException\n-    {\n+    public double getDoubleValue() throws IOException {\n         // TODO Auto-generated method stub\n         return 0;\n     }\n \n     @Override\n-    public float getFloatValue() throws IOException, JsonParseException\n-    {\n+    public float getFloatValue() throws IOException {\n         // TODO Auto-generated method stub\n         return 0;\n     }\n \n     @Override\n-    public int getIntValue() throws IOException, JsonParseException\n-    {\n+    public int getIntValue() throws IOException {\n         // TODO Auto-generated method stub\n         return 0;\n     }\n \n     @Override\n-    public long getLongValue() throws IOException, JsonParseException\n-    {\n+    public long getLongValue() throws IOException {\n         // TODO Auto-generated method stub\n         return 0;\n     }\n \n     @Override\n-    public NumberType getNumberType() throws IOException, JsonParseException\n-    {\n+    public NumberType getNumberType() throws IOException {\n         // TODO Auto-generated method stub\n         return null;\n     }\n \n     @Override\n-    public Number getNumberValue() throws IOException, JsonParseException\n-    {\n+    public Number getNumberValue() throws IOException {\n         // TODO Auto-generated method stub\n         return null;\n     }\n      * Method called to release internal buffers owned by the base\n      * parser.\n      */\n-    protected void _releaseBuffers() throws IOException\n-    {\n+    protected void _releaseBuffers() throws IOException {\n         // anything we can/must release? Underlying parser should do all of it, for now?\n     }\n \n         }\n         return true;\n     }\n-\n-    @Override\n-    public Version version()\n-    {\n-        return PackageVersion.VERSION;\n-    }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/WrapperHandlingDeserializer.java\n import java.util.*;\n \n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.databind.*;\n import com.fasterxml.jackson.databind.deser.*;\n import com.fasterxml.jackson.databind.deser.std.DelegatingDeserializer;\n      */\n     protected final Set<String> _namesToWrap;\n \n+    protected final JavaType _type;\n+    \n     /*\n     /**********************************************************************\n     /* Construction\n     {\n         super(delegate);\n         _namesToWrap = namesToWrap;\n+        _type = delegate.getValueType();\n     }\n \n     /*\n             BeanProperty property)\n         throws JsonMappingException\n     {\n+        // !!! 16-Jan-2015, tatu: TODO: change to be like so in 2.6.0 -- leaving\n+        //    out for 2.5 just to increase compatibility slightly with 2.4 databind\n+        /*\n+        JavaType vt = _type;\n+        if (vt == null) {\n+            vt = ctxt.constructType(_delegatee.handledType());\n+        }\n+        JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property, vt);\n+        */\n+\n         JsonDeserializer<?> del = ctxt.handleSecondaryContextualization(_delegatee, property);\n         BeanDeserializerBase newDelegatee = _verifyDeserType(del);\n         \n      */\n \n     @Override\n-    public Object deserialize(JsonParser jp, DeserializationContext ctxt)\n-        throws IOException, JsonProcessingException\n+    public Object deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException\n     {\n         _configureParser(jp);\n         return _delegatee.deserialize(jp,  ctxt);\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public Object deserialize(JsonParser jp, DeserializationContext ctxt,\n-            Object intoValue)\n-        throws IOException, JsonProcessingException\n+            Object intoValue) throws IOException\n     {\n         _configureParser(jp);\n         return ((JsonDeserializer<Object>)_delegatee).deserialize(jp, ctxt, intoValue);\n \n     @Override\n     public Object deserializeWithType(JsonParser jp, DeserializationContext ctxt,\n-            TypeDeserializer typeDeserializer)\n-        throws IOException, JsonProcessingException\n+            TypeDeserializer typeDeserializer) throws IOException\n     {\n         _configureParser(jp);\n         return _delegatee.deserializeWithType(jp, ctxt, typeDeserializer);\n     /**********************************************************************\n      */\n \n-    protected final void _configureParser(JsonParser jp)\n-        throws IOException, JsonProcessingException\n+    protected final void _configureParser(JsonParser jp) throws IOException\n     {\n         /* 19-Aug-2013, tatu: Although we should not usually get called with\n          *   parser of other types, there are some cases where this may happen:\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlReadContext.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlReadContext.java\n  * state data we need.\n  *<p>\n  * Almost same as standard <code>JsonReaderContext</code>, but\n- * cut'n pasted since the impl is final for performance reasons;\n- * this class is one of hot spots in profiling.\n+ * custom version needed to be able to keep track of names\n+ * of properties that need wrapping; this is needed to\n+ * support wrapped/unwrapped Collection/array values.\n  */\n public final class XmlReadContext\n     extends JsonStreamContext\n     \n     // // // Factory methods\n \n-    public static XmlReadContext createRootContext(int lineNr, int colNr)\n-    {\n+    public static XmlReadContext createRootContext(int lineNr, int colNr) {\n         return new XmlReadContext(null, TYPE_ROOT, lineNr, colNr);\n     }\n \n-    public static XmlReadContext createRootContext()\n-    {\n+    public static XmlReadContext createRootContext() {\n         return new XmlReadContext(null, TYPE_ROOT, 1, 0);\n     }\n     \n         throw new UnsupportedOperationException();\n     }\n \n-    public void setCurrentName(String name)\n-    {\n+    public void setCurrentName(String name) {\n         _currentName = name;\n     }\n \n      * @return Location pointing to the point where the context\n      *   start marker was found\n      */\n-    public final JsonLocation getStartLocation(Object srcRef)\n-    {\n-        /* We don't keep track of offsets at this level (only\n-         * reader does)\n-         */\n+    public final JsonLocation getStartLocation(Object srcRef) {\n+        // We don't keep track of offsets at this level (only reader does)\n         long totalChars = -1L;\n \n         return new JsonLocation(srcRef, totalChars, _lineNr, _columnNr);\n         return _namesToWrap;\n     }\n \n-    protected void convertToArray()\n-    {\n+    protected void convertToArray() {\n         _type = TYPE_ARRAY;\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n     public Boolean isOutputAsText(Annotated ann) {\n         return super.isOutputAsText(ann);\n     }\n-    \n+\n+    @Override\n+    public Boolean isOutputAsCData(Annotated ann) {\n+        //There is no CData annotation in JAXB\n+        return null;\n+    }\n+\n     /*\n     /**********************************************************************\n     /* Helper methods\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n      * once.\n      */\n     protected boolean _nextIsUnwrapped = false;\n+\n+    /**\n+     * Marker flag used to indicate that the next write of a (property)\n+     * value should be as CData\n+     */\n+    protected boolean _nextIsCData = false;\n     \n     /**\n      * To support proper serialization of arrays it is necessary to keep\n     {\n         _nextIsUnwrapped = isUnwrapped;\n     }\n+\n+    public void setNextIsCData(boolean isCData)\n+    {\n+        _nextIsCData = isCData;\n+    }\n     \n     public final void setNextName(QName name)\n     {\n                 // [Issue#56] Should figure out how to prevent indentation for end element\n                 //   but for now, let's just make sure structure is correct\n                 //if (_xmlPrettyPrinter != null) { ... }\n-                _xmlWriter.writeCharacters(text);\n+                if(_nextIsCData) {\n+                    _xmlWriter.writeCData(text);\n+                } else {\n+                    _xmlWriter.writeCharacters(text);\n+                }\n             } else if (_xmlPrettyPrinter != null) {\n                 _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                         _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n-                        text);\n+                        text, _nextIsCData);\n             } else {\n                 _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeCharacters(text);\n+                if(_nextIsCData) {\n+                    _xmlWriter.writeCData(text);\n+                } else {\n+                    _xmlWriter.writeCharacters(text);\n+                }\n                 _xmlWriter.writeEndElement();\n             } \n         } catch (XMLStreamException e) {\n                 _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\n             } else if (checkNextIsUnwrapped()) {\n             \t// should we consider pretty-printing or not?\n-                _xmlWriter.writeCharacters(text, offset, len);\n+                if(_nextIsCData) {\n+                    _xmlWriter.writeCData(text, offset, len);\n+                } else {\n+                    _xmlWriter.writeCharacters(text, offset, len);\n+                }\n             } else if (_xmlPrettyPrinter != null) {\n                 _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                         _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n-                        text, offset, len);\n+                        text, offset, len, _nextIsCData);\n             } else {\n                 _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeCharacters(text, offset, len);\n+                if(_nextIsCData) {\n+                    _xmlWriter.writeCData(text, offset, len);\n+                } else {\n+                    _xmlWriter.writeCharacters(text, offset, len);\n+                }\n                 _xmlWriter.writeEndElement();\n             }\n         } catch (XMLStreamException e) {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/UnwrappingXmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/UnwrappingXmlBeanSerializer.java\n  * @author Pascal G\u00e9linas\n  * \n  */\n-public class UnwrappingXmlBeanSerializer extends XmlBeanSerializerBase {\n+public class UnwrappingXmlBeanSerializer extends XmlBeanSerializerBase\n+{\n+    private static final long serialVersionUID = 1L;\n+ \n     /**\n      * Transformer used to add prefix and/or suffix for properties of unwrapped\n      * POJO.\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanPropertyWriter.java\n         // and then see if we must suppress certain values (default, empty)\n         if (_suppressableValue != null) {\n             if (MARKER_FOR_EMPTY == _suppressableValue) {\n-                if (ser.isEmpty(value)) {\n+                if (ser.isEmpty(prov, value)) {\n                     return;\n                 }\n             } else if (_suppressableValue.equals(value)) {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n  */\n public class XmlBeanSerializer extends XmlBeanSerializerBase\n {\n+    private static final long serialVersionUID = 1L;\n+\n     /*\n     /**********************************************************\n     /* Life-cycle: constructors\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n package com.fasterxml.jackson.dataformat.xml.ser;\n \n import java.io.IOException;\n+import java.util.BitSet;\n \n import javax.xml.namespace.QName;\n \n  * of some xml-specific aspects, such as distinction between attributes\n  * and elements.\n  */\n+@SuppressWarnings(\"serial\")\n public abstract class XmlBeanSerializerBase extends BeanSerializerBase\n {\n     /**\n      */\n     protected final QName[] _xmlNames;\n \n+    /**\n+     * Optional set of indexes of properties that should be serialized as CDATA,\n+     * instead of regular XML text segment. Left as null in cases where none of\n+     * element values are to be written in such a way.\n+     */\n+    protected final BitSet _cdata;\n+    \n     public XmlBeanSerializerBase(BeanSerializerBase src)\n     {\n         super(src);\n-        \n+\n         /* Then make sure attributes are sorted before elements, keep track\n          * of how many there are altogether\n          */\n         }\n         _attributeCount = attrCount;\n \n+        // also: pre-compute need, if any, for CDATA handling:\n+        BitSet cdata = null;\n+        for (int i = 0, len = _props.length; i < len; ++i) {\n+            BeanPropertyWriter bpw = _props[i];\n+            if (_isCData(bpw)) {\n+                if (cdata == null) {\n+                    cdata = new BitSet(len);\n+                }\n+                cdata.set(i);\n+            }\n+        }\n+        _cdata = cdata;\n+        \n         // And then collect namespace information\n         _xmlNames = new QName[_props.length];\n         int textIndex = -1;\n         _attributeCount = src._attributeCount;\n         _textPropertyIndex = src._textPropertyIndex;\n         _xmlNames = src._xmlNames;\n+        _cdata = src._cdata;\n     }\n \n     protected XmlBeanSerializerBase(XmlBeanSerializerBase src, ObjectIdWriter objectIdWriter, Object filterId)\n         _attributeCount = src._attributeCount;\n         _textPropertyIndex = src._textPropertyIndex;\n         _xmlNames = src._xmlNames;\n+        _cdata = src._cdata;\n     }\n \n     protected XmlBeanSerializerBase(XmlBeanSerializerBase src, String[] toIgnore)\n         _attributeCount = src._attributeCount;\n         _textPropertyIndex = src._textPropertyIndex;\n         _xmlNames = src._xmlNames;\n+        _cdata = src._cdata;\n     }\n     \n     public XmlBeanSerializerBase(XmlBeanSerializerBase src, NameTransformer transformer)\n         _attributeCount = src._attributeCount;\n         _textPropertyIndex = src._textPropertyIndex;\n         _xmlNames = src._xmlNames;\n+        _cdata = src._cdata;\n     }\n \n     /*\n      * elements.\n      */\n     @Override\n-    protected void serializeFields(Object bean, JsonGenerator jgen0, SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+    protected void serializeFields(Object bean, JsonGenerator gen0, SerializerProvider provider)\n+        throws IOException\n     {\n         // 19-Aug-2013, tatu: During 'convertValue()', need to skip\n-        if (!(jgen0 instanceof ToXmlGenerator)) {\n-            super.serializeFields(bean, jgen0, provider);\n+        if (!(gen0 instanceof ToXmlGenerator)) {\n+            super.serializeFields(bean, gen0, provider);\n             return;\n         }\n         \n-        final ToXmlGenerator xgen = (ToXmlGenerator) jgen0;\n+        final ToXmlGenerator xgen = (ToXmlGenerator) gen0;\n         final BeanPropertyWriter[] props;\n         if (_filteredProps != null && provider.getActiveView() != null) {\n             props = _filteredProps;\n         final int textIndex = _textPropertyIndex;\n         final QName[] xmlNames = _xmlNames;\n         int i = 0;\n+        final BitSet cdata = _cdata;\n \n         try {\n             for (final int len = props.length; i < len; ++i) {\n                 xgen.setNextName(xmlNames[i]);\n                 BeanPropertyWriter prop = props[i];\n                 if (prop != null) { // can have nulls in filtered list\n-                    prop.serializeAsField(bean, xgen, provider);\n+                    if ((cdata != null) && cdata.get(i)) {\n+                        xgen.setNextIsCData(true);\n+                        prop.serializeAsField(bean, xgen, provider);\n+                        xgen.setNextIsCData(false);\n+                    } else {\n+                        prop.serializeAsField(bean, xgen, provider);\n+                    }\n                 }\n                 // Reset to avoid next value being written as unwrapped, \n                 // for example when property is suppressed\n     }\n \n     @Override\n-    protected void serializeFieldsFiltered(Object bean, JsonGenerator jgen0,\n+    protected void serializeFieldsFiltered(Object bean, JsonGenerator gen0,\n             SerializerProvider provider)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         // 19-Aug-2013, tatu: During 'convertValue()', need to skip\n-        if (!(jgen0 instanceof ToXmlGenerator)) {\n-            super.serializeFieldsFiltered(bean, jgen0, provider);\n+        if (!(gen0 instanceof ToXmlGenerator)) {\n+            super.serializeFieldsFiltered(bean, gen0, provider);\n             return;\n         }\n         \n-        final ToXmlGenerator xgen = (ToXmlGenerator) jgen0;\n+        final ToXmlGenerator xgen = (ToXmlGenerator) gen0;\n         \n         final BeanPropertyWriter[] props;\n         if (_filteredProps != null && provider.getActiveView() != null) {\n         final PropertyFilter filter = findPropertyFilter(provider, _propertyFilterId, bean);\n         // better also allow missing filter actually..\n         if (filter == null) {\n-            serializeFields(bean, jgen0, provider);\n+            serializeFields(bean, gen0, provider);\n             return;\n         }\n \n         }\n         final int textIndex = _textPropertyIndex;\n         final QName[] xmlNames = _xmlNames;\n+        final BitSet cdata = _cdata;\n \n         int i = 0;\n         try {\n                 xgen.setNextName(xmlNames[i]);\n                 BeanPropertyWriter prop = props[i];\n                 if (prop != null) { // can have nulls in filtered list\n-                    filter.serializeAsField(bean, xgen, provider, prop);\n+                    if ((cdata != null) && cdata.get(i)) {\n+                        xgen.setNextIsCData(true);\n+                        filter.serializeAsField(bean, xgen, provider, prop);\n+                        xgen.setNextIsCData(false);\n+                    } else {\n+                        filter.serializeAsField(bean, xgen, provider, prop);\n+                    }\n                 }\n             }\n             if (_anyGetterWriter != null) {\n     }\n     \n     @Override\n-    public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n+    public void serializeWithType(Object bean, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer)\n-        throws IOException, JsonGenerationException\n+        throws IOException\n     {\n         if (_objectIdWriter != null) {\n-            _serializeWithObjectId(bean, jgen, provider, typeSer);\n+            _serializeWithObjectId(bean, gen, provider, typeSer);\n             return;\n         }\n         /* Ok: let's serialize type id as attribute, but if (and only if!)\n          * we are using AS_PROPERTY\n          */\n         if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {\n-            ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n+            ToXmlGenerator xgen = (ToXmlGenerator)gen;\n             xgen.setNextIsAttribute(true);\n-            super.serializeWithType(bean, jgen, provider, typeSer);\n+            super.serializeWithType(bean, gen, provider, typeSer);\n             if (_attributeCount == 0) { // if no attributes, need to reset\n                 xgen.setNextIsAttribute(false);\n             }\n         } else {\n-            super.serializeWithType(bean, jgen, provider, typeSer);\n+            super.serializeWithType(bean, gen, provider, typeSer);\n         }\n     }\n     \n     @Override\n-    protected void _serializeObjectId(Object bean, JsonGenerator jgen, SerializerProvider provider,\n+    protected void _serializeObjectId(Object bean, JsonGenerator gen, SerializerProvider provider,\n             TypeSerializer typeSer, WritableObjectId objectId) throws IOException\n     {\n         // Ok: let's serialize type id as attribute, but if (and only if!) we are using AS_PROPERTY\n         if (typeSer.getTypeInclusion() == JsonTypeInfo.As.PROPERTY) {\n-            ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n+            ToXmlGenerator xgen = (ToXmlGenerator)gen;\n             xgen.setNextIsAttribute(true);\n-            super._serializeObjectId(bean, jgen, provider, typeSer, objectId);\n+            super._serializeObjectId(bean, gen, provider, typeSer, objectId);\n             if (_attributeCount == 0) { // if no attributes, need to reset\n                 xgen.setNextIsAttribute(false);\n             }\n         } else {\n-            super._serializeObjectId(bean, jgen, provider, typeSer, objectId);\n+            super._serializeObjectId(bean, gen, provider, typeSer, objectId);\n         }\n     }\n \n     {\n         XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n         return (info != null) && info.isAttribute();\n+    }\n+\n+    protected static boolean _isCData(BeanPropertyWriter bpw)\n+    {\n+        XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+        return (info != null) && info.isCData();\n     }\n \n     /**\n                 continue;\n             }\n             \n-            // Move attribute a few places done as necessary\n+            // Move attribute a few places down as necessary\n             int moveBy = i - attrCount;\n             if (moveBy > 0) {\n                 System.arraycopy(properties, attrCount, properties, attrCount + 1, moveBy);\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n             String ns = AnnotationUtil.findNamespaceAnnotation(intr, member);\n             Boolean isAttribute = AnnotationUtil.findIsAttributeAnnotation(intr, member);\n             Boolean isText = AnnotationUtil.findIsTextAnnotation(intr, member);\n+            Boolean isCData = AnnotationUtil.findIsCDataAnnotation(intr, member);\n             bpw.setInternalSetting(XmlBeanSerializerBase.KEY_XML_INFO,\n-            \t\tnew XmlInfo(isAttribute, ns, isText));\n+            \t\tnew XmlInfo(isAttribute, ns, isText, isCData));\n \n             // Actually: if we have a Collection type, easiest place to add wrapping would be here...\n             //  or: let's also allow wrapping of \"untyped\" (Object): assuming it is a dynamically\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n  */\n public class XmlSerializerProvider extends DefaultSerializerProvider\n {\n-    private static final long serialVersionUID = -141838337907252911L;\n+    // As of 2.5\n+    private static final long serialVersionUID = -4138605166320336475L;\n \n     /**\n      * If all we get to serialize is a null, there's no way to figure out\n \n     @Override\n     public DefaultSerializerProvider createInstance(SerializationConfig config,\n-            SerializerFactory jsf)\n-    {\n+            SerializerFactory jsf) {\n         return new XmlSerializerProvider(this, config, jsf);\n     }\n     \n     @SuppressWarnings(\"resource\")\n     @Override\n     public void serializeValue(JsonGenerator jgen, Object value)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         if (value == null) {\n             _serializeXmlNull(jgen);\n     @SuppressWarnings(\"resource\")\n     @Override\n     public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         if (value == null) {\n             _serializeXmlNull(jgen);\n     @SuppressWarnings(\"resource\")\n     @Override\n     public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType,\n-            JsonSerializer<Object> ser)\n-        throws IOException, JsonGenerationException\n+            JsonSerializer<Object> ser) throws IOException\n     {\n         if (value == null) {\n             _serializeXmlNull(jgen);\n         }\n     }\n \n-    protected void _serializeXmlNull(JsonGenerator jgen)\n-            throws IOException, JsonProcessingException\n+    protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         if (jgen instanceof ToXmlGenerator)\n         _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n         super.serializeValue(jgen, null);\n     }\n     \n-    protected void _startRootArray(ToXmlGenerator xgen, QName rootName)\n-        throws IOException, JsonProcessingException\n+    protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n     {\n         xgen.writeStartObject();\n         // Could repeat root name, but what's the point? How to customize?\n         xgen.writeFieldName(\"item\");\n     }    \n \n-    protected void _initWithRootName(ToXmlGenerator xgen, QName rootName)\n-            throws IOException, JsonProcessingException\n+    protected void _initWithRootName(ToXmlGenerator xgen, QName rootName) throws IOException\n     {\n         /* 28-Nov-2012, tatu: We should only initialize the root\n          *  name if no name has been set, as per [Issue#42],\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/AnnotationUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/AnnotationUtil.java\n         }\n         return null;\n     }\n+\n+    public static Boolean findIsCDataAnnotation(AnnotationIntrospector ai,\n+                                               AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                Boolean b = ((XmlAnnotationIntrospector) intr).isOutputAsCData(prop);\n+                if (b != null) {\n+                    return b;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n     \n     @Override\n     public void writeLeafElement(XMLStreamWriter2 sw,\n-    \t\tString nsURI, String localName, String text)\n+    \t\tString nsURI, String localName, String text, boolean isCData)\n   \t\tthrows XMLStreamException\n     {\n         if (!_objectIndenter.isInline()) {\n             _objectIndenter.writeIndentation(sw, _nesting);\n         }\n         sw.writeStartElement(nsURI, localName);\n-        sw.writeCharacters(text);\n+        if(isCData) {\n+            sw.writeCData(text);\n+        } else {\n+            sw.writeCharacters(text);\n+        }\n         sw.writeEndElement();\n         _justHadStartElement = false;\n     }\n     @Override\n     public void writeLeafElement(XMLStreamWriter2 sw,\n     \t\tString nsURI, String localName,\n-    \t\tchar[] buffer, int offset, int len)\n+    \t\tchar[] buffer, int offset, int len, boolean isCData)\n         throws XMLStreamException\n     {\n         if (!_objectIndenter.isInline()) {\n             _objectIndenter.writeIndentation(sw, _nesting);\n         }\n         sw.writeStartElement(nsURI, localName);\n-        sw.writeCharacters(buffer, offset, len);\n+        if(isCData) {\n+            sw.writeCData(buffer, offset, len);\n+        } else {\n+            sw.writeCharacters(buffer, offset, len);\n+        }\n         sw.writeEndElement();\n         _justHadStartElement = false;\n     }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/TypeUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/TypeUtil.java\n             Class<?> cls = type.getRawClass();\n             // One special case; byte[] will be serialized as base64-encoded String, not real array, so:\n             // (actually, ditto for char[]; thought to be a String)\n-            if (cls == byte[].class || cls == byte[].class) {\n+            if (cls == byte[].class || cls == char[].class) {\n                 return false;\n             }\n             // issue#5: also, should not add wrapping for Maps\n \n     public static boolean isIndexedType(Class<?> cls)\n     {\n-        return (cls.isArray() && cls != byte[].class) || Collection.class.isAssignableFrom(cls);\n+        return (cls.isArray() && cls != byte[].class && cls != char[].class)\n+                || Collection.class.isAssignableFrom(cls);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlInfo.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlInfo.java\n     protected final String _namespace;\n     protected final boolean _isAttribute;\n     protected final boolean _isText;\n+    protected final boolean _isCData;\n     \n-    public XmlInfo(Boolean isAttribute, String ns, Boolean isText)\n+    public XmlInfo(Boolean isAttribute, String ns, Boolean isText, Boolean isCData)\n     {\n         _isAttribute = (isAttribute == null) ? false : isAttribute.booleanValue();\n         _namespace = (ns == null) ? \"\" : ns;\n         _isText = (isText == null) ? false : isText.booleanValue();\n+        _isCData = (isCData == null) ? false : isCData.booleanValue();\n     }\n \n     public String getNamespace() { return _namespace; }\n     public boolean isAttribute() { return _isAttribute; }\n     public boolean isText() { return _isText; }\n+    public boolean isCData() { return _isCData; }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/RoundtripContentTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/RoundtripContentTest.java\n         input.addPhoto(new MediaItem.Photo(\"http://a\", \"title1\", 200, 100, MediaItem.Size.LARGE));\n         input.addPhoto(new MediaItem.Photo(\"http://b\", \"title2\", 640, 480, MediaItem.Size.SMALL));\n \n-        ObjectWriter w = MAPPER.writerWithType(MediaItem.class);\n+        ObjectWriter w = MAPPER.writerFor(MediaItem.class);\n \n         /*\n         StringWriter sw = new StringWriter();\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/Issue97Test.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/Issue97Test.java\n import java.util.*;\n \n import org.junit.*;\n-import org.junit.runner.*;\n-import org.junit.runners.*;\n \n import com.fasterxml.jackson.annotation.*;\n import com.fasterxml.jackson.annotation.JsonTypeInfo.*;\n /**\n  * @author Nu Echo Inc.\n  */\n-@RunWith(JUnit4.class)\n public class Issue97Test extends XmlTestBase\n {\n     @JsonTypeInfo(property = \"type\", use = Id.NAME)\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedDeserIssue86.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedDeserIssue86.java\n import java.util.Arrays;\n import java.util.List;\n \n-import junit.framework.Assert;\n-\n import org.junit.Test;\n \n import com.fasterxml.jackson.annotation.JsonInclude.Include;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n \n-public class TestUnwrappedDeserIssue86\n+public class TestUnwrappedDeserIssue86 extends XmlTestBase\n {\n     @JacksonXmlRootElement(localName = \"test\")\n     public static class Issue86 {\n             \"</test>\" +\n         \"</test>\";\n \n-    final Issue86 before = new Issue86(\n-        \"0\",\n-        Arrays.asList(\n-            new Issue86(\n-                \"0.1\",\n+    final Issue86 before = new Issue86(\"0\",\n+        Arrays.asList(new Issue86(\"0.1\",\n+                Arrays.asList(new Issue86(\"0.1.1\", null))),\n+            new Issue86(\"0.2\", null),\n+            new Issue86(\"0.3\",\n                 Arrays.asList(\n-                    new Issue86(\n-                        \"0.1.1\",\n-                        null))),\n-            new Issue86(\n-                \"0.2\",\n-                null),\n-            new Issue86(\n-                \"0.3\",\n-                Arrays.asList(\n-                    new Issue86(\n-                        \"0.3.1\",\n-                        null)))));\n+                    new Issue86(\"0.3.1\", null)))));\n \n     final XmlMapper mapper = new XmlMapper();\n     mapper.setSerializationInclusion(Include.NON_NULL);\n \n     final String xml = mapper.writeValueAsString(before);\n-    Assert.assertEquals(source, xml);\n+    assertEquals(source, xml);\n \n     final Issue86 after = mapper.readValue(xml, Issue86.class);\n-    Assert.assertEquals(before, after);\n+    assertEquals(before, after);\n   }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListAnnotationSharingTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListAnnotationSharingTest.java\n     static class Wrapper {\n         @JacksonXmlElementWrapper(localName = \"Points\", useWrapping = true)\n         @JsonProperty(\"Point\")\n-        private List<Point> points = new ArrayList<Point>();\n+        List<Point> points = new ArrayList<Point>();\n \n         public List<Point> getPoints() {\n             return points;\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/UnwrappedListWithEmptyCData129Test.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.List;\n+\n+import javax.xml.bind.annotation.XmlElement;\n+\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n+\n+public class UnwrappedListWithEmptyCData129Test extends XmlTestBase\n+{\n+    static class ListValues {\n+        @XmlElement(name = \"value\", required = true)\n+        @JacksonXmlElementWrapper(useWrapping=false)\n+        public List<String> value;\n+    }\n+\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+    {\n+        // easier for eye:\n+        MAPPER.enable(SerializationFeature.INDENT_OUTPUT);\n+    }\n+\n+    // for [#129]\n+    public void testListWithEmptyCData() throws Exception\n+    {\n+        _testListWithEmptyCData(\" \");\n+        _testListWithEmptyCData(\"\");\n+    }\n+        \n+    private void _testListWithEmptyCData(String cdata) throws Exception\n+    {\n+        ListValues result = MAPPER.readValue(\"<root>\\n\"\n+                + \"<value>A</value>\\n\"\n+//                + \"<value><![CDATA[\"+SECOND+\"]]></value>\\n\"\n+                + \"<value>\"+cdata+\"</value>\\n\"\n+                + \"<value>C</value>\\n\"\n+                + \"</root>\", ListValues.class);\n+\n+        List<String> values = result.value;\n+\n+        assertEquals(3, values.size()); // expecting 3 values, getting only 1\n+        assertEquals(\"A\", values.get(0));\n+        assertEquals(cdata, values.get(1)); // expecting empty string in second position\n+        assertEquals(\"C\", values.get(2));\n+    }    \n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/NodeTest.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class NodeTest extends XmlTestBase\n+{\n+    public void testMixed() throws Exception\n+    {\n+        final XmlMapper xmlMapper = new XmlMapper();\n+        final ObjectMapper jsonMapper = new ObjectMapper();\n+\n+        JsonNode root = xmlMapper.readTree(\"<root>first<child>4</child>second</root>\");\n+        String json = jsonMapper.writeValueAsString(root);\n+\n+        System.out.println(\"-> \"+json);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/UnwrappingWithXMLTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/UnwrappingWithXMLTest.java\n         assertEquals(27, wrapper.location.y);\n \n         // should also write out the same way\n-        assertEquals(XML, mapper.writerWithType(Unwrapping.class).writeValueAsString(wrapper));\n+        assertEquals(XML, mapper.writerFor(Unwrapping.class).writeValueAsString(wrapper));\n     }\n \n     public void testUnwrappingWithAttribute()\n         assertEquals(27, wrapper.location.y);\n \n         // should also write out the same way\n-        assertEquals(XML, mapper.writerWithType(UnwrappingWithAttributes.class).writeValueAsString(wrapper));\n+        assertEquals(XML, mapper.writerFor(UnwrappingWithAttributes.class).writeValueAsString(wrapper));\n     }\n \n     public void testUnwrappingSubWithAttribute()\n         assertEquals(27, wrapper.location.y);\n \n         // should also write out the same way\n-        assertEquals(XML, mapper.writerWithType(UnwrappingSubWithAttributes.class).writeValueAsString(wrapper));\n+        assertEquals(XML, mapper.writerFor(UnwrappingSubWithAttributes.class).writeValueAsString(wrapper));\n     }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestJDKSerializability.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestJDKSerializability.java\n     @JacksonXmlRootElement(localName=\"MyPojo\")\n     static class MyPojo {\n         public int x;\n-        private int y;\n+        int y;\n         \n         public MyPojo() { }\n         public MyPojo(int x0, int y0) {\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestSerialization.java\n import com.fasterxml.jackson.dataformat.xml.JacksonXmlModule;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlCData;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n \n     static class NsRootBean\n     {\n         public String value = \"abc\";\n+    }\n+\n+    static class CDataStringBean\n+    {\n+        @JacksonXmlCData\n+        public String value = \"<some<data\\\"\";\n+    }\n+\n+    static class CDataStringArrayBean\n+    {\n+        @JacksonXmlCData\n+        public String[] value = {\"<some<data\\\"\", \"abc\"};\n     }\n \n     static class CustomSerializer extends StdScalarSerializer<String>\n \n         assertEquals(Integer.valueOf(456), result.get(\"b\"));\n     }\n+\n+    public void testCDataString() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new CDataStringBean());\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<CDataStringBean><value><![CDATA[<some<data\\\"]]></value></CDataStringBean>\", xml);\n+    }\n+\n+    public void testCDataStringArray() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new CDataStringArrayBean());\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<CDataStringArrayBean><value><value><![CDATA[<some<data\\\"]]></value><value><![CDATA[abc]]></value></value></CDataStringArrayBean>\", xml);\n+    }\n     \n     // for [Issue#41]\n     public void testCustomSerializer() throws Exception", "timestamp": 1423165679, "metainfo": ""}