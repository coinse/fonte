{"sha": "933d8cb389e09cdfbfb8cc856a9eacfd4c862ecb", "log": "Merge branch 'master' of github.com:FasterXML/jackson-dataformat-xml", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlFactory.java\n */\n public class XmlFactory extends JsonFactory\n {\n+    private static final long serialVersionUID = -1885780678226335519L;\n+\n     /**\n      * Name used to identify XML format\n      * (and returned by {@link #getFormatName()}\n \n     protected int _xmlGeneratorFeatures = DEFAULT_XML_GENERATOR_FEATURE_FLAGS;\n \n-    protected XMLInputFactory _xmlInputFactory;\n-\n-    protected XMLOutputFactory _xmlOutputFactory;\n+    // non-final for setters (why are they needed again?)\n+    protected transient XMLInputFactory _xmlInputFactory;\n+\n+    protected transient XMLOutputFactory _xmlOutputFactory;\n \n     protected String _cfgNameForTextElement = null;\n     \n         this(null, xmlIn, xmlOut);\n     }\n     \n-    public XmlFactory(ObjectCodec oc,\n-            XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n+    public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n     {\n         super(oc);\n         if (xmlIn == null) {\n-            /* 24-Jun-2010, tatu: Ugh. JDK authors seem to waffle on what the name of\n-             *   factory constructor method is...\n-             */\n-            //xmlIn = XMLInputFactory.newFactory();\n             xmlIn = XMLInputFactory.newInstance();\n         }\n         if (xmlOut == null) {\n-            //xmlOut = XMLOutputFactory.newFactory();\n             xmlOut = XMLOutputFactory.newInstance();\n         }\n+        _initFactories(xmlIn, xmlOut);\n+        _xmlInputFactory = xmlIn;\n+        _xmlOutputFactory = xmlOut;\n+    }\n+    \n+    protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n+    {\n         // Better ensure namespaces get built properly, so:\n         xmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n         // and for parser, force coalescing as well (much simpler to use)\n         xmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n-        _xmlInputFactory = xmlIn;\n-        _xmlOutputFactory = xmlOut;\n     }\n \n     /**\n \n     /*\n     /**********************************************************\n+    /* Serializable overrides\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Hiding place for JDK-serialization unthawed factories...\n+     */\n+    protected transient String _jdkXmlInFactory;\n+\n+    /**\n+     * Hiding place for JDK-serialization unthawed factories...\n+     */\n+    protected transient String _jdkXmlOutFactory;\n+\n+    /**\n+     * Method that we need to override to actually make restoration go\n+     * through constructors etc.\n+     */\n+    @Override // since JsonFactory already implemented it\n+    protected Object readResolve() {\n+        if (_jdkXmlInFactory == null) {\n+            throw new IllegalStateException(\"No XMLInputFactory class name read during JDK deserialization\");\n+        }\n+        if (_jdkXmlOutFactory == null) {\n+            throw new IllegalStateException(\"No XMLOutputFactory class name read during JDK deserialization\");\n+        }\n+        try {\n+            XMLInputFactory inf = (XMLInputFactory) Class.forName(_jdkXmlInFactory).newInstance();\n+            XMLOutputFactory outf = (XMLOutputFactory) Class.forName(_jdkXmlOutFactory).newInstance();\n+            return new XmlFactory(_objectCodec, inf, outf);\n+        } catch (ClassNotFoundException e) {\n+            throw new IllegalArgumentException(e);\n+        } catch (InstantiationException e) {\n+            throw new IllegalArgumentException(e);\n+        } catch (IllegalAccessException e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    /**\n+     * In addition to default serialization, which mostly works, need\n+     * to handle case of XML factories, hence override.\n+     */\n+    private void readObject(ObjectInputStream in)\n+            throws IOException, ClassNotFoundException\n+    {\n+        in.defaultReadObject();\n+        _jdkXmlInFactory = in.readUTF();\n+        _jdkXmlOutFactory = in.readUTF();\n+    }\n+\n+    /**\n+     * In addition to default serialization, which mostly works, need\n+     * to handle case of XML factories, hence override.\n+     */\n+    private void writeObject(ObjectOutputStream out) throws IOException {\n+        out.defaultWriteObject();\n+        out.writeUTF(_xmlInputFactory.getClass().getName());\n+        out.writeUTF(_xmlOutputFactory.getClass().getName());\n+    }\n+    \n+    /*\n+    /**********************************************************\n     /* Configuration, XML-specific\n     /**********************************************************\n      */\n     /**********************************************************\n      */\n \n+    @Override\n+    public ToXmlGenerator createGenerator(OutputStream out) throws IOException\n+    {\n+        return createGenerator(out, JsonEncoding.UTF8);\n+    }\n+    \n     @Override\n     public ToXmlGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException\n     {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestJDKSerializability.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import java.io.*;\n+\n+import javax.xml.namespace.QName;\n+\n+import com.fasterxml.jackson.core.*;\n+import com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\n+\n+/**\n+ * Unit test related to core [Issue#31] (https://github.com/FasterXML/jackson-core/issues/31)\n+ * as it relates to XmlFactory.\n+ */\n+public class TestJDKSerializability extends XmlTestBase\n+{\n+    public void testJsonFactorySerializable() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        String origXml = \"<root><a>text</a></root>\";\n+        assertEquals(origXml, _writeXml(f, false));\n+\n+        // Ok: freeze dry factory, thaw, and try to use again:\n+        byte[] frozen = jdkSerialize(f);\n+        XmlFactory f2 = jdkDeserialize(frozen);\n+        assertNotNull(f2);\n+        assertEquals(origXml, _writeXml(f2, false));\n+\n+        // Let's also try byte-based variant, for fun...\n+        assertEquals(origXml, _writeXml(f2, true));\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    protected byte[] jdkSerialize(Object o) throws IOException\n+    {\n+        ByteArrayOutputStream bytes = new ByteArrayOutputStream(1000);\n+        ObjectOutputStream obOut = new ObjectOutputStream(bytes);\n+        obOut.writeObject(o);\n+        obOut.close();\n+        return bytes.toByteArray();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    protected <T> T jdkDeserialize(byte[] raw) throws IOException\n+    {\n+        ObjectInputStream objIn = new ObjectInputStream(new ByteArrayInputStream(raw));\n+        try {\n+            return (T) objIn.readObject();\n+        } catch (ClassNotFoundException e) {\n+            fail(\"Missing class: \"+e.getMessage());\n+            return null;\n+        } finally {\n+            objIn.close();\n+        }\n+    }\n+    \n+    protected String _writeXml(XmlFactory f, boolean useBytes) throws IOException\n+    {\n+        if (useBytes) {\n+            ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n+            ToXmlGenerator jg = f.createGenerator(bytes);\n+            _write(f, jg);\n+            return bytes.toString(\"UTF-8\");\n+        }\n+        StringWriter sw = new StringWriter();\n+        ToXmlGenerator jg = f.createGenerator(sw);\n+        _write(f, jg);\n+        return sw.toString();\n+    }\n+        \n+    protected void _write(JsonFactory f, ToXmlGenerator jg) throws IOException\n+    {\n+        jg.setNextName(new QName(\"root\"));\n+        jg.writeStartObject();\n+        jg.writeFieldName(\"a\");\n+        jg.writeString(\"text\");\n+        jg.writeEndObject();\n+        jg.close();\n+    }\n+}", "timestamp": 1349496707, "metainfo": ""}