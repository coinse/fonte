{"sha": "1dff4683a6e66f1bc12fe3171ecb31c7cac5a6ca", "log": "First part of [Issue-23] implemented: @JacksonXmlText now added, works for serialization", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n      * implies an attribute (true) or element (false)\n      */\n     protected boolean _nextIsAttribute = false;\n+\n+    /**\n+     * Marker flag used to indicate that the next write of a (property)\n+     * value should be done without using surrounding start/end\n+     * elements. Flag is to be cleared once unwrapping has been triggered\n+     * once.\n+     */\n+    protected boolean _nextIsUnwrapped = false;\n     \n     /**\n      * To support proper serialization of arrays it is necessary to keep\n         _nextIsAttribute = isAttribute;\n     }\n \n+    public void setNextIsUnwrapped(boolean isUnwrapped)\n+    {\n+    \t_nextIsUnwrapped = isUnwrapped;\n+    }\n+    \n     public final void setNextName(QName name)\n     {\n         _nextName = name;\n                 \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                 \t\t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(),\n                 \t\t\ttext);\n+                } else if (checkNextIsUnwrapped()) {\n+\t                _xmlWriter.writeCharacters(text);\n                 } else {\n \t                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n \t                _xmlWriter.writeCharacters(text);\n         try {\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\n+            } else if (checkNextIsUnwrapped()) {\n+            \t// should we consider pretty-printing or not?\n+                _xmlWriter.writeCharacters(text, offset, len);\n             } else {\n                 if (_xmlPrettyPrinter != null) {\n                 \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                 // Stax2 API only has 'full buffer' write method:\n                 byte[] fullBuffer = toFullBuffer(data, offset, len);\n                 _xmlWriter.writeBinaryAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);\n+            } else if (checkNextIsUnwrapped()) {\n+            \t// should we consider pretty-printing or not?\n+                _xmlWriter.writeBinary(data, offset, len);\n             } else {\n                 if (_xmlPrettyPrinter != null) {\n                 \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n         try {\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeBooleanAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), value);\n+            } else if (checkNextIsUnwrapped()) {\n+            \t// should we consider pretty-printing or not?\n+                _xmlWriter.writeBoolean(value);\n             } else {\n                 if (_xmlPrettyPrinter != null) {\n                 \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                 /* With attributes, best just leave it out, right? (since there's no way\n                  * to use 'xsi:nil')\n                  */\n+            } else if (checkNextIsUnwrapped()) {\n+            \t// as with above, best left unwritten?\n             } else {\n                 if (_xmlPrettyPrinter != null) {\n                 \t_xmlPrettyPrinter.writeLeafNullElement(_xmlWriter,\n         try {\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeIntAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\n+            } else if (checkNextIsUnwrapped()) {\n+            \t// should we consider pretty-printing or not?\n+                _xmlWriter.writeInt(i);\n             } else {\n                 if (_xmlPrettyPrinter != null) {\n                 \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n         try {\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeLongAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), l);\n+            } else if (checkNextIsUnwrapped()) {\n+                _xmlWriter.writeLong(l);\n             } else {\n                 if (_xmlPrettyPrinter != null) {\n                 \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n         try {\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeDoubleAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), d);\n+            } else if (checkNextIsUnwrapped()) {\n+                _xmlWriter.writeDouble(d);\n             } else {\n                 if (_xmlPrettyPrinter != null) {\n                 \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n         try {\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeFloatAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), f);\n+            } else if (checkNextIsUnwrapped()) {\n+                _xmlWriter.writeFloat(f);\n             } else {\n                 if (_xmlPrettyPrinter != null) {\n                 \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n         try {\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeDecimalAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), dec);\n+            } else if (checkNextIsUnwrapped()) {\n+                _xmlWriter.writeDecimal(dec);\n             } else {\n                 if (_xmlPrettyPrinter != null) {\n                 \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n             if (_nextIsAttribute) {\n                 _xmlWriter.writeIntegerAttribute(null,\n                 \t\t_nextName.getNamespaceURI(), _nextName.getLocalPart(), value);\n+            } else if (checkNextIsUnwrapped()) {\n+                _xmlWriter.writeInteger(value);\n             } else {\n                 if (_xmlPrettyPrinter != null) {\n                 \t_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n     /**********************************************************\n      */\n \n+    /**\n+     * Method called to see if unwrapping is required; and if so,\n+     * clear the flag (so further calls will return 'false' unless\n+     * state is re-set)\n+     */\n+    protected boolean checkNextIsUnwrapped()\n+    {\n+    \tif (_nextIsUnwrapped) {\n+    \t\t_nextIsUnwrapped = false;\n+    \t\treturn true;\n+    \t}\n+    \treturn false;\n+    }\n+    \n     protected void handleMissingName()\n     {\n         throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n      * properties to write.\n      */\n     protected final int _attributeCount;\n+\n+    /**\n+     * Index of \"text value\" property we have, if any; can have at most\n+     * one such property.\n+     */\n+    protected final int _textPropertyIndex;\n \n     /**\n      * Array that contains namespace URIs associated with properties, if any;\n \n         // And then collect namespace information\n         _xmlNames = new QName[_props.length];\n+        int textIndex = -1;\n         for (int i = 0, len = _props.length; i < len; ++i) {\n             BeanPropertyWriter bpw = _props[i];\n             XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n             String ns = null;\n             if (info != null) {\n                 ns = info.getNamespace();\n+                if (textIndex < 0 && info.isText()) {\n+                \ttextIndex = i;\n+                }\n             }\n             _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n-        }      \n-    \n+        }\n+        _textPropertyIndex = textIndex;\n     }\n \n     protected XmlBeanSerializer(XmlBeanSerializer src, ObjectIdWriter objectIdWriter)\n     {\n         super(src, objectIdWriter);\n         _attributeCount = src._attributeCount;\n+        _textPropertyIndex = src._textPropertyIndex;\n         _xmlNames = src._xmlNames;\n     }\n \n     protected void serializeFields(Object bean, JsonGenerator jgen0, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n     {\n-        final ToXmlGenerator jgen = (ToXmlGenerator) jgen0;\n+        final ToXmlGenerator xgen = (ToXmlGenerator) jgen0;\n         final BeanPropertyWriter[] props;\n         if (_filteredProps != null && provider.getSerializationView() != null) {\n             props = _filteredProps;\n         } else {\n             props = _props;\n         }\n-        \n-        final int attrCount = _attributeCount;\n+\n+\t\tfinal int attrCount = _attributeCount;\n         if (attrCount > 0) {\n-            jgen.setNextIsAttribute(true);\n-        }\n+        \txgen.setNextIsAttribute(true);\n+        }\n+        final int textIndex = _textPropertyIndex;\n         final QName[] xmlNames = _xmlNames;\n         \n         int i = 0;\n         try {\n             for (final int len = props.length; i < len; ++i) {\n                 if (i == attrCount) {\n-                    jgen.setNextIsAttribute(false);\n-                }\n-                jgen.setNextName(xmlNames[i]);\n+                \txgen.setNextIsAttribute(false);\n+                }\n+                // also: if this is property to write as text (\"unwrap\"), need to:\n+                if (i == textIndex) {\n+\t\t\t\t\txgen.setNextIsUnwrapped(true);\n+                }\n+                xgen.setNextName(xmlNames[i]);\n                 BeanPropertyWriter prop = props[i];\n                 if (prop != null) { // can have nulls in filtered list\n-                    prop.serializeAsField(bean, jgen, provider);\n+                    prop.serializeAsField(bean, xgen, provider);\n                 }\n             }\n             if (_anyGetterWriter != null) {\n-                _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+                _anyGetterWriter.getAndSerialize(bean, xgen, provider);\n             }\n         } catch (Exception e) {\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n             final AnnotatedMember member = bpw.getMember();\n             String ns = AnnotationUtil.findNamespaceAnnotation(intr, member);\n             Boolean isAttribute = AnnotationUtil.findIsAttributeAnnotation(intr, member);\n-            bpw.setInternalSetting(XmlBeanSerializer.KEY_XML_INFO, new XmlInfo(isAttribute, ns));\n+            Boolean isText = AnnotationUtil.findIsTextAnnotation(intr, member);\n+            bpw.setInternalSetting(XmlBeanSerializer.KEY_XML_INFO,\n+            \t\tnew XmlInfo(isAttribute, ns, isText));\n \n             // Actually: if we have a Collection type, easiest place to add wrapping would be here...\n             //  or: let's also allow wrapping of \"untyped\" (Object): assuming it is a dynamically\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/AnnotationUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/AnnotationUtil.java\n         return null;\n     }\n \n+    public static Boolean findIsTextAnnotation(AnnotationIntrospector ai,\n+            AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                Boolean b = ((XmlAnnotationIntrospector) intr).isOutputAsText(prop);\n+                if (b != null) {\n+                    return b;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n     public static QName findWrapperName(AnnotationIntrospector ai, AnnotatedMember prop)\n     {\n         for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlInfo.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlInfo.java\n {\n     protected final String _namespace;\n     protected final boolean _isAttribute;\n+    protected final boolean _isText;\n     \n-    public XmlInfo(Boolean isAttribute, String ns)\n+    public XmlInfo(Boolean isAttribute, String ns, Boolean isText)\n     {\n         _isAttribute = (isAttribute == null) ? false : isAttribute.booleanValue();\n         _namespace = (ns == null) ? \"\" : ns;\n+        _isText = (isText == null) ? false : isText.booleanValue();\n     }\n \n     public String getNamespace() { return _namespace; }\n     public boolean isAttribute() { return _isAttribute; }\n+    public boolean isText() { return _isText; }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/TestTextValue.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestTextValue.java\n     /**********************************************************\n      */\n \n-    public void testSimpleSerialize() throws IOException\n+    public void testSimpleAsText() throws IOException\n     {\n     \tXmlMapper mapper = new XmlMapper();\n     \tString xml = mapper.writeValueAsString(new Simple());\n     \tassertEquals(\"<Simple a=\\\"13\\\">something</Simple>\", xml);\n     }\n-\n+    \n     /* // Uncomment to see how JAXB works here:\n     public void testJAXB() throws Exception\n     {\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/jaxb/TestWithJAXBAnnotations.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/jaxb/TestWithJAXBAnnotations.java\n package com.fasterxml.jackson.dataformat.xml.jaxb;\n+\n+import java.io.IOException;\n \n import javax.xml.bind.annotation.*;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+\n import com.fasterxml.jackson.dataformat.xml.XmlAnnotationIntrospector;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n         public String attr = \"3\";\n     }\n \n+\t@javax.xml.bind.annotation.XmlRootElement(name=\"Simple\")\n+\tstatic class WithXmlValue\n+\t{\n+\t\t@javax.xml.bind.annotation.XmlAttribute\n+\t\tpublic int a = 13;\n+\n+\t\t@javax.xml.bind.annotation.XmlValue\n+\t\tpublic String text = \"something\";\n+\t}\n+\t\n     /*\n     /**********************************************************************\n     /* Set up\n \n     /**\n      * Unit test for verifying that root element name can be overridden\n-     * with <code>@XmlRootElement</code> annotation.\n+     * with {@link XmlRootElement} annotation.\n      */\n     public void testRootName() throws Exception\n     {\n     }\n \n     /**\n-     * Unit test for verifying that a propery defaults to being written as\n-     * element, but can be redefined with <code>@XmlAttribute</code> annotation.\n+     * Unit test for verifying that a property defaults to being written as\n+     * element, but can be redefined with {@link XmlAttribute} annotation.\n      */\n     public void testSerializeAsAttr() throws Exception\n     {\n         assertEquals(\"<AttrBean><attr>3</attr></AttrBean>\", _nonJaxbMapper.writeValueAsString(bean));\n         assertEquals(\"<AttrBean attr=\\\"3\\\"/>\", _jaxbMapper.writeValueAsString(bean));\n     }\n+\n+    /**\n+     * Unit test for verifying correct handling of\n+     * {@link XmlValue} annotation.\n+     */\n+    public void testAsTextWithJAXB() throws IOException\n+    {\n+    \tString xml = _jaxbMapper.writeValueAsString(new WithXmlValue());\n+    \tassertEquals(\"<Simple a=\\\"13\\\">something</Simple>\", xml);\n+    }\n }", "timestamp": 1333584130, "metainfo": ""}