{"sha": "479522112267a0448223d38870bf5d63e77a5c33", "log": "Implement #38", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n         }\n     }\n \n+    /**\n+     * Trivial helper method called when to add a replicated wrapper name\n+     * \n+     * @since 2.2\n+     */\n+    public void writeRepeatedFieldName() throws IOException, JsonGenerationException\n+    {\n+        if (_writeContext.writeFieldName(_nextName.getLocalPart()) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n+            _reportError(\"Can not write a field name, expecting a value\");\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* JsonGenerator method overrides\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n      * extra handling, such as indication of whether to write attributes or\n      * elements.\n      */\n-    @SuppressWarnings(\"deprecation\")\n     @Override\n     protected void serializeFields(Object bean, JsonGenerator jgen0, SerializerProvider provider)\n         throws IOException, JsonGenerationException\n         final ToXmlGenerator xgen = (ToXmlGenerator) jgen0;\n         final BeanPropertyWriter[] props;\n         // !!! TODO: change to use non-deprecated version in 2.3\n-        if (_filteredProps != null && provider.getSerializationView() != null) {\n+        if (_filteredProps != null && provider.getActiveView() != null) {\n             props = _filteredProps;\n         } else {\n             props = _props;\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n package com.fasterxml.jackson.dataformat.xml.ser;\n \n import java.io.IOException;\n+import java.util.Collection;\n+\n import javax.xml.namespace.QName;\n import javax.xml.stream.XMLStreamException;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializationConfig;\n import com.fasterxml.jackson.databind.ser.SerializerFactory;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n import com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n+import com.fasterxml.jackson.dataformat.xml.util.TypeUtil;\n import com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup;\n \n \n     {\n         return new XmlSerializerProvider(this, config, jsf);\n     }\n-    \n+\n     @Override\n     public void serializeValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonProcessingException\n     {\n-        QName rootName = (value == null) ? ROOT_NAME_FOR_NULL\n-                : _rootNameLookup.findRootName(value.getClass(), _config);\n+        if (value == null) {\n+            _serializeNull(jgen);\n+            return;\n+        }\n+        Class<?> cls = value.getClass();\n+        QName rootName = _rootNameFromConfig();\n+        if (rootName == null) {\n+            rootName = _rootNameLookup.findRootName(cls, _config);\n+        }\n         _initWithRootName(jgen, rootName);\n-        super.serializeValue(jgen, value);\n-    }\n-\n+        final boolean asArray = Collection.class.isAssignableFrom(cls) ||\n+                (cls.isArray() && cls != byte[].class);\n+        if (asArray) {\n+            _startRootArray(jgen, rootName);\n+        }\n+        \n+        // From super-class implementation\n+        final JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\n+        try {\n+            ser.serialize(value, jgen, this);\n+        } catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\n+            throw ioe;\n+        } catch (Exception e) { // but wrap RuntimeExceptions, to get path information\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+        // end of super-class implementation\n+\n+        if (asArray) {\n+            jgen.writeEndObject();\n+        }\n+    }\n+    \n     @Override\n     public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n         throws IOException, JsonProcessingException\n     {\n-        QName rootName = _rootNameLookup.findRootName(rootType, _config);\n+        if (value == null) {\n+            _serializeNull(jgen);\n+            return;\n+        }\n+        QName rootName = _rootNameFromConfig();\n+        if (rootName == null) {\n+            rootName = _rootNameLookup.findRootName(rootType, _config);\n+        }\n         _initWithRootName(jgen, rootName);\n-        super.serializeValue(jgen, value, rootType);\n-    }\n-\n+        final boolean asArray = TypeUtil.isIndexedType(rootType);\n+        if (asArray) {\n+            _startRootArray(jgen, rootName);\n+        }\n+\n+        final JsonSerializer<Object> ser = findTypedValueSerializer(rootType, true, null);\n+        // From super-class implementation\n+        try {\n+            ser.serialize(value, jgen, this);\n+        } catch (IOException ioe) { // no wrapping for IO (and derived)\n+            throw ioe;\n+        } catch (Exception e) { // but others do need to be, to get path etc\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+        // end of super-class implementation\n+\n+        if (asArray) {\n+            jgen.writeEndObject();\n+        }\n+    }\n+    \n     // @since 2.1\n     @Override\n     public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType,\n             JsonSerializer<Object> ser)\n         throws IOException, JsonGenerationException\n     {\n-        QName rootName = _rootNameLookup.findRootName(rootType, _config);\n+        if (value == null) {\n+            _serializeNull(jgen);\n+            return;\n+        }\n+        QName rootName = _rootNameFromConfig();\n+        if (rootName == null) {\n+            rootName = _rootNameLookup.findRootName(rootType, _config);\n+        }\n         _initWithRootName(jgen, rootName);\n-        super.serializeValue(jgen, value, rootType, ser);\n-    }\n-    \n+        final boolean asArray = TypeUtil.isIndexedType(rootType);\n+        if (asArray) {\n+            _startRootArray(jgen, rootName);\n+        }\n+        if (ser == null) {\n+            ser = findTypedValueSerializer(rootType, true, null);\n+        }\n+        // From super-class implementation\n+        try {\n+            ser.serialize(value, jgen, this);\n+        } catch (IOException ioe) { // no wrapping for IO (and derived)\n+            throw ioe;\n+        } catch (Exception e) { // but others do need to be, to get path etc\n+            String msg = e.getMessage();\n+            if (msg == null) {\n+                msg = \"[no message for \"+e.getClass().getName()+\"]\";\n+            }\n+            throw new JsonMappingException(msg, e);\n+        }\n+        // end of super-class implementation\n+        if (asArray) {\n+            jgen.writeEndObject();\n+        }\n+    }\n+\n+    protected void _startRootArray(JsonGenerator jgen, QName rootName)\n+        throws IOException, JsonProcessingException\n+    {\n+        jgen.writeStartObject();\n+        // Could repeat root name, but what's the point? How to customize?\n+        ((ToXmlGenerator) jgen).writeFieldName(\"item\");\n+    }    \n+\n+    @Override\n+    protected void _serializeNull(JsonGenerator jgen)\n+            throws IOException, JsonProcessingException\n+    {\n+        _initWithRootName(jgen, ROOT_NAME_FOR_NULL);\n+        super.serializeValue(jgen, null);\n+    }\n+\n     protected void _initWithRootName(JsonGenerator jgen, QName rootName)\n             throws IOException, JsonProcessingException\n     {\n         }\n         xgen.initGenerator();\n         String ns = rootName.getNamespaceURI();\n-        /* [Issue-26] If we just try writing root element with namespace,\n+        /* [Issue#26] If we just try writing root element with namespace,\n          * we will get an explicit prefix. But we'd rather use the default\n          * namespace, so let's try to force that.\n          */\n             }\n         }\n     }\n+\n+    protected QName _rootNameFromConfig()\n+    {\n+        String name = _config.getRootName();\n+        return (name == null) ? null : new QName(name);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n         return sb.toString();\n     }\n \n-    public String jaxbSerialized(Object ob) throws Exception\n+    public String jaxbSerialized(Object ob, Class<?>... classes) throws Exception\n     {\n         StringWriter sw = new StringWriter();\n-        javax.xml.bind.JAXB.marshal(ob, sw);\n+        if (classes.length == 0) {\n+            javax.xml.bind.JAXB.marshal(ob, sw);\n+        } else {\n+            javax.xml.bind.JAXBContext.newInstance(classes).createMarshaller().marshal(ob, sw);\n+        }\n         sw.close();\n         return sw.toString();\n     }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedRootList.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedRootList.java\n import java.util.*;\n \n import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.JavaType;\n import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n import com.fasterxml.jackson.dataformat.xml.*;\n \n         l.add(r2);\n \n         // to see what JAXB might do, uncomment:\n-//        System.out.println(\"By JAXB: \"+jaxbSerialized(l));\n+//System.out.println(\"By JAXB: \"+jaxbSerialized(l)); //  ArrayList.class, SampleResource.class));\n         \n-        String result = xmlMapper.writeValueAsString(l);\n-        assertNotNull(result);\n+        String xml = xmlMapper\n+            .writerWithDefaultPrettyPrinter()\n+            .withRootName(\"RootList\")\n+            .writeValueAsString(l)\n+            .trim();\n \n-        // TODO: verify actual contents\n+        // first trivial sanity checks\n+        assertNotNull(xml);\n+        if (xml.indexOf(\"<RootList>\") < 0) {\n+            fail(\"Unexpected output: should have <RootList> as root element, got: \"+xml);\n+        }\n+\n+        // and then try reading back\n+        JavaType resListType = xmlMapper.getTypeFactory()\n+                .constructCollectionType(List.class, SampleResource.class);\n+        Object ob = xmlMapper.reader(resListType).readValue(xml);\n+        assertNotNull(ob);\n+\n+//      System.err.println(\"XML -> \"+xmlMapper.writerWithDefaultPrettyPrinter().writeValueAsString(ob));\n         \n-//        assertEquals(\"<x></x>\", result);\n+        assertTrue(ob instanceof List);\n+        List<?> resultList = (List<?>) ob;\n+        assertEquals(2, resultList.size());\n+        assertEquals(SampleResource.class, resultList.get(0).getClass());\n+        assertEquals(SampleResource.class, resultList.get(1).getClass());\n+        SampleResource rr = (SampleResource) resultList.get(1);\n+        assertEquals(\"William\", rr.getName());\n+\n     }\n }", "timestamp": 1376544684, "metainfo": ""}