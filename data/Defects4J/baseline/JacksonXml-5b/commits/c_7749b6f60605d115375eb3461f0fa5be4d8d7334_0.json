{"sha": "7749b6f60605d115375eb3461f0fa5be4d8d7334", "log": "Fixed #191", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n     }\n \n     // DEBUGGING\n-/*\n+    /*\n     @Override\n     public JsonToken nextToken() throws IOException\n     {\n         }\n         return t;\n     }\n-*/\n-\n+\n+//    public JsonToken nextToken0() throws IOException\n+ */\n+\n+    \n     @Override\n     public JsonToken nextToken() throws IOException\n     {\n         }\n \n         // Ok; beyond start element, what do we get?\n-        switch (token) {\n-        case XmlTokenStream.XML_END_ELEMENT:\n-            // Simple, except that if this is a leaf, need to suppress end:\n-            if (_mayBeLeaf) {\n-                _mayBeLeaf = false;\n-                if (_parsingContext.inArray()) {\n-                    // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n-                    //    expose as empty Object, not null\n-                    _nextToken = JsonToken.END_OBJECT;\n-                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n-                    return (_currToken = JsonToken.START_OBJECT);\n-                }\n-                return (_currToken = JsonToken.VALUE_NULL);\n-            }\n-            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n-            _parsingContext = _parsingContext.getParent();\n-            _namesToWrap = _parsingContext.getNamesToWrap();\n-            return _currToken;\n-            \n-        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n-            // If there was a chance of leaf node, no more...\n-            if (_mayBeLeaf) {\n-                _mayBeLeaf = false;\n-                _nextToken = JsonToken.FIELD_NAME;\n-                _currText = _xmlTokens.getText();\n-                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n-                return (_currToken = JsonToken.START_OBJECT);\n-            }\n-            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n-            return (_currToken = JsonToken.FIELD_NAME);\n-        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            return (_currToken = JsonToken.VALUE_STRING);\n-        case XmlTokenStream.XML_TEXT:\n-            _currText = _xmlTokens.getText();\n-            if (_mayBeLeaf) {\n-                _mayBeLeaf = false;\n-                /* One more refinement (pronunced like \"hack\") is that if\n-                 * we had an empty String (or all white space), and we are\n-                 * deserializing an array, we better hide the empty text.\n-                 */\n-                // Also: must skip following END_ELEMENT\n-                _xmlTokens.skipEndElement();\n-                if (_parsingContext.inArray()) {\n-                    if (_isEmpty(_currText)) {\n+        while (true) {\n+            switch (token) {\n+            case XmlTokenStream.XML_END_ELEMENT:\n+                // Simple, except that if this is a leaf, need to suppress end:\n+                if (_mayBeLeaf) {\n+                    _mayBeLeaf = false;\n+                    if (_parsingContext.inArray()) {\n                         // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n-                        //    expose as empty Object, not null (or, worse, as used to\n-                        //    be done, by swallowing the token)\n+                        //    expose as empty Object, not null\n                         _nextToken = JsonToken.END_OBJECT;\n                         _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                         return (_currToken = JsonToken.START_OBJECT);\n                     }\n+                    return (_currToken = JsonToken.VALUE_NULL);\n                 }\n+                _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n+                _parsingContext = _parsingContext.getParent();\n+                _namesToWrap = _parsingContext.getNamesToWrap();\n+                return _currToken;\n+                \n+            case XmlTokenStream.XML_ATTRIBUTE_NAME:\n+                // If there was a chance of leaf node, no more...\n+                if (_mayBeLeaf) {\n+                    _mayBeLeaf = false;\n+                    _nextToken = JsonToken.FIELD_NAME;\n+                    _currText = _xmlTokens.getText();\n+                    _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                    return (_currToken = JsonToken.START_OBJECT);\n+                }\n+                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+                return (_currToken = JsonToken.FIELD_NAME);\n+            case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n+                _currText = _xmlTokens.getText();\n                 return (_currToken = JsonToken.VALUE_STRING);\n-            } else {\n-                // [dataformat-xml#177]: empty text may also need to be skipped\n-                if (_parsingContext.inObject()\n-                        && (_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n-                    _currToken = JsonToken.END_OBJECT;\n-                    _parsingContext = _parsingContext.getParent();\n-                    _namesToWrap = _parsingContext.getNamesToWrap();\n-                    return _currToken;\n+            case XmlTokenStream.XML_TEXT:\n+                _currText = _xmlTokens.getText();\n+                if (_mayBeLeaf) {\n+                    _mayBeLeaf = false;\n+                    // One more refinement (pronunced like \"hack\") is that if\n+                    // we had an empty String (or all white space), and we are\n+                    // deserializing an array, we better hide the empty text.\n+                    // Also: must skip following END_ELEMENT\n+                    _xmlTokens.skipEndElement();\n+                    if (_parsingContext.inArray()) {\n+                        if (_isEmpty(_currText)) {\n+                            // 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n+                            //    expose as empty Object, not null (or, worse, as used to\n+                            //    be done, by swallowing the token)\n+                            _nextToken = JsonToken.END_OBJECT;\n+                            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                            return (_currToken = JsonToken.START_OBJECT);\n+                        }\n+                    }\n+                    return (_currToken = JsonToken.VALUE_STRING);\n+                } else {\n+                    // [dataformat-xml#177]: empty text may also need to be skipped\n+                    // but... [dataformat-xml#191]: looks like we can't short-cut, must\n+                    // loop over again\n+                    if (_parsingContext.inObject()) {\n+                        if ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\n+                            token = _xmlTokens.next();\n+                            continue;\n+                        }\n+                    }\n                 }\n-            }\n-            // If not a leaf (or otherwise ignorable), need to transform into property...\n-            _parsingContext.setCurrentName(_cfgNameForTextElement);\n-            _nextToken = JsonToken.VALUE_STRING;\n-            return (_currToken = JsonToken.FIELD_NAME);\n-        case XmlTokenStream.XML_END:\n-            return (_currToken = null);\n-        }\n-        \n-        // should never get here\n-        _throwInternal();\n-        return null;\n+                // If not a leaf (or otherwise ignorable), need to transform into property...\n+                _parsingContext.setCurrentName(_cfgNameForTextElement);\n+                _nextToken = JsonToken.VALUE_STRING;\n+                return (_currToken = JsonToken.FIELD_NAME);\n+            case XmlTokenStream.XML_END:\n+                return (_currToken = null);\n+            }\n+        }\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlTokenStream.java\n         return n;\n     }\n     */\n-    \n+\n     public int next() throws IOException \n     {\n         if (_repeatElement != 0) {\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/DeserializePolyList178Test.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class DeserializePolyList178Test extends XmlTestBase\n+{\n+    static class Company {\n+        public List<Computer> computers;\n+\n+        public Company() {\n+            computers = new ArrayList<Computer>();\n+        }\n+\n+        public Company add(Computer computer) {\n+            if (computers == null) {\n+                computers = new ArrayList<Computer>();\n+            }\n+            computers.add(computer);\n+            return this;\n+        }\n+    }\n+\n+// 02-Jan-2015, tatu: Does not seem to matter; was included in the original reproduction\n+//    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME,\n+            include = JsonTypeInfo.As.WRAPPER_OBJECT,\n+            property = \"type\")\n+    @JsonSubTypes({\n+            @JsonSubTypes.Type(value = DesktopComputer.class, name = \"desktop\"),\n+            @JsonSubTypes.Type(value = LaptopComputer.class, name = \"laptop\")\n+    })\n+    static class Computer {\n+        public String id;\n+    }\n+\n+    @JsonTypeName(\"desktop\")\n+    static class DesktopComputer extends Computer {\n+        public String location;\n+\n+        protected DesktopComputer() { }\n+        public DesktopComputer with(String id0, String l) {\n+            id = id0;\n+            location = l;\n+            return this;\n+        }\n+    }\n+\n+    @JsonTypeName(\"laptop\")\n+    static class LaptopComputer extends Computer {\n+        public String vendor;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+    \n+    // for [dataformat-xml#178]\n+    public void testPolyIdList178() throws Exception\n+    {\n+        Company input = new Company();\n+        input.add(new DesktopComputer().with(\"1\", \"http://foo.com\"));\n+        final String LOC2 = \"http://bar.com\";\n+        input.add(new DesktopComputer().with(\"2\", LOC2));\n+        String xml = MAPPER.writerWithDefaultPrettyPrinter()\n+                .writeValueAsString(input);\n+//System.out.println(\"XML:\\n\"+xml);\n+\n+        Company result = MAPPER.readValue(xml, Company.class);\n+        assertNotNull(result.computers);\n+        assertEquals(2, result.computers.size());\n+        Computer comp = result.computers.get(1);\n+        assertNotNull(comp);\n+        assertEquals(DesktopComputer.class, comp.getClass());\n+        DesktopComputer dt = (DesktopComputer) comp;\n+        assertEquals(LOC2, dt.location);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/ListDeser191Test.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.ArrayList;\n+\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.dataformat.xml.*;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+\n+public class ListDeser191Test extends XmlTestBase\n+{\n+    static class TestList {\n+        @JacksonXmlElementWrapper(useWrapping = true, localName = \"items\")\n+        @JacksonXmlProperty(localName = \"item\")\n+        public ArrayList<ListItem> items;\n+    }    \n+\n+    static class ListItem {\n+        @JacksonXmlProperty(isAttribute = true)\n+        public String name;\n+    }    \n+\n+    public void testListDeser() throws Exception\n+    {\n+        ObjectMapper mapper = new XmlMapper();\n+        final String XML =\n+\"<TestList>\\n\"+\n+\"    <items>\\n\"+\n+\"        <item name='Item1'/>\\n\"+\n+\"        <item name='Item2'> </item>\\n\"+ // important: at least one ws char between start/end\n+\"        <item name='Item3'/>\\n\"+\n+\"    </items>\\n\"+\n+\"</TestList>\"\n+                ;\n+        TestList testList = mapper.readValue(XML, TestList.class);\n+        assertNotNull(testList);\n+        assertNotNull(testList.items);\n+        assertEquals(3, testList.items.size());\n+    }\n+}", "timestamp": 1461290829, "metainfo": ""}