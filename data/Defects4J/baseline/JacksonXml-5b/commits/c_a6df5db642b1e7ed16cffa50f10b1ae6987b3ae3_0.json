{"sha": "a6df5db642b1e7ed16cffa50f10b1ae6987b3ae3", "log": "Fix #71, problems with XmlMapper.convertValue()", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n import com.fasterxml.jackson.databind.SerializationConfig;\n import com.fasterxml.jackson.databind.ser.SerializerFactory;\n import com.fasterxml.jackson.databind.ser.DefaultSerializerProvider;\n+import com.fasterxml.jackson.databind.util.TokenBuffer;\n import com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n import com.fasterxml.jackson.dataformat.xml.util.TypeUtil;\n import com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup;\n     {\n         return new XmlSerializerProvider(this, config, jsf);\n     }\n-\n+    \n+    @SuppressWarnings(\"resource\")\n     @Override\n     public void serializeValue(JsonGenerator jgen, Object value)\n         throws IOException, JsonProcessingException\n     {\n+        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n         if (value == null) {\n-            _serializeNull(jgen);\n+            _serializeXmlNull(xgen);\n             return;\n         }\n-        Class<?> cls = value.getClass();\n-        QName rootName = _rootNameFromConfig();\n-        if (rootName == null) {\n-            rootName = _rootNameLookup.findRootName(cls, _config);\n-        }\n-        _initWithRootName(jgen, rootName);\n-        final boolean asArray = Collection.class.isAssignableFrom(cls) ||\n-                (cls.isArray() && cls != byte[].class);\n-        if (asArray) {\n-            _startRootArray(jgen, rootName);\n+        final Class<?> cls = value.getClass();\n+        final boolean asArray;\n+        if (xgen == null) { // called by convertValue()\n+            asArray = false;\n+        } else {\n+            QName rootName = _rootNameFromConfig();\n+            if (rootName == null) {\n+                rootName = _rootNameLookup.findRootName(cls, _config);\n+            }\n+            _initWithRootName(xgen, rootName);\n+            asArray = TypeUtil.isIndexedType(cls);\n+            if (asArray) {\n+                _startRootArray(jgen, rootName);\n+            }\n         }\n         \n         // From super-class implementation\n             jgen.writeEndObject();\n         }\n     }\n-    \n+\n+    @SuppressWarnings(\"resource\")\n     @Override\n     public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n         throws IOException, JsonProcessingException\n     {\n+        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n         if (value == null) {\n-            _serializeNull(jgen);\n+            _serializeXmlNull(xgen);\n             return;\n         }\n-        QName rootName = _rootNameFromConfig();\n-        if (rootName == null) {\n-            rootName = _rootNameLookup.findRootName(rootType, _config);\n-        }\n-        _initWithRootName(jgen, rootName);\n-        final boolean asArray = TypeUtil.isIndexedType(rootType);\n-        if (asArray) {\n-            _startRootArray(jgen, rootName);\n+        final boolean asArray;\n+        if (xgen == null) { // called by convertValue()\n+            asArray = false;\n+        } else {\n+            QName rootName = _rootNameFromConfig();\n+            if (rootName == null) {\n+                rootName = _rootNameLookup.findRootName(rootType, _config);\n+            }\n+            _initWithRootName(xgen, rootName);\n+            asArray = TypeUtil.isIndexedType(rootType);\n+            if (asArray) {\n+                _startRootArray(jgen, rootName);\n+            }\n         }\n \n         final JsonSerializer<Object> ser = findTypedValueSerializer(rootType, true, null);\n     }\n     \n     // @since 2.1\n+    @SuppressWarnings(\"resource\")\n     @Override\n     public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType,\n             JsonSerializer<Object> ser)\n         throws IOException, JsonGenerationException\n     {\n+        final ToXmlGenerator xgen = _asXmlGenerator(jgen);\n         if (value == null) {\n-            _serializeNull(jgen);\n+            _serializeXmlNull(xgen);\n             return;\n         }\n-        QName rootName = _rootNameFromConfig();\n-        if (rootName == null) {\n-            rootName = _rootNameLookup.findRootName(rootType, _config);\n-        }\n-        _initWithRootName(jgen, rootName);\n-        final boolean asArray = TypeUtil.isIndexedType(rootType);\n-        if (asArray) {\n-            _startRootArray(jgen, rootName);\n+        final boolean asArray;\n+        if (xgen == null) { // called by convertValue()\n+            asArray = false;\n+        } else {\n+            QName rootName = _rootNameFromConfig();\n+            if (rootName == null) {\n+                rootName = _rootNameLookup.findRootName(rootType, _config);\n+            }\n+            _initWithRootName(xgen, rootName);\n+            asArray = TypeUtil.isIndexedType(rootType);\n+            if (asArray) {\n+                _startRootArray(jgen, rootName);\n+            }\n         }\n         if (ser == null) {\n             ser = findTypedValueSerializer(rootType, true, null);\n         ((ToXmlGenerator) jgen).writeFieldName(\"item\");\n     }    \n \n-    @Override\n-    protected void _serializeNull(JsonGenerator jgen)\n+    protected void _serializeXmlNull(ToXmlGenerator jgen)\n             throws IOException, JsonProcessingException\n     {\n         _initWithRootName(jgen, ROOT_NAME_FOR_NULL);\n         super.serializeValue(jgen, null);\n     }\n \n-    protected void _initWithRootName(JsonGenerator jgen, QName rootName)\n+    protected void _initWithRootName(ToXmlGenerator xgen, QName rootName)\n             throws IOException, JsonProcessingException\n     {\n-        ToXmlGenerator xgen = (ToXmlGenerator) jgen;\n         /* 28-Nov-2012, tatu: We should only initialize the root\n          *  name if no name has been set, as per [Issue#42],\n          *  to allow for custom serializers to work.\n         String name = _config.getRootName();\n         return (name == null) ? null : new QName(name);\n     }\n+\n+    protected ToXmlGenerator _asXmlGenerator(JsonGenerator jgen)\n+        throws JsonMappingException\n+    {\n+        // [Issue#71]: When converting, we actually get TokenBuffer, which is fine\n+        if (!(jgen instanceof ToXmlGenerator)) {\n+            // but verify\n+            if (!(jgen instanceof TokenBuffer)) {\n+                throw new JsonMappingException(\"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"\n+                            +jgen.getClass().getName());\n+                }\n+                return null;\n+        }\n+        return (ToXmlGenerator) jgen;\n+    }    \n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/TypeUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/TypeUtil.java\n package com.fasterxml.jackson.dataformat.xml.util;\n \n+import java.util.Collection;\n import java.util.Map;\n \n import com.fasterxml.jackson.databind.JavaType;\n         return false;\n     }    \n \n+    public static boolean isIndexedType(Class<?> cls)\n+    {\n+        return (cls.isArray() && cls != byte[].class) || Collection.class.isAssignableFrom(cls);\n+    }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n     \n     /*\n     /**********************************************************\n-    /* Construction\n+    /* Construction, factory methods\n     /**********************************************************\n      */\n \n         super();\n     }\n \n+    protected XmlMapper xmlMapper(boolean useListWrapping)\n+    {\n+        JacksonXmlModule module = new JacksonXmlModule();\n+        module.setDefaultUseWrapper(useListWrapping);\n+        return new XmlMapper(module);\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Additional assertion methods\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/convert/TestArrayConversions.java\n+package com.fasterxml.jackson.dataformat.xml.convert;\n+\n+import java.util.*;\n+import java.lang.reflect.Array;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+/* NOTE: copied from jackson-databind (with some pruning)\n+ */\n+\n+/**\n+ * Conversion tests to ensure that standard ObjectMapper conversions\n+ * work despite XmlMapper having to add XML-specific work-arounds.\n+ */\n+public class TestArrayConversions extends XmlTestBase\n+{\n+    public void testNullXform() throws Exception {\n+        _testNullXform(xmlMapper(true));\n+        _testNullXform(xmlMapper(false));\n+    }\n+    \n+    private void _testNullXform(ObjectMapper mapper) throws Exception\n+    {\n+        // when given null, null should be returned without conversion (Java null has no type)\n+        assertNull(mapper.convertValue(null, Integer.class));\n+        assertNull(mapper.convertValue(null, String.class));\n+        assertNull(mapper.convertValue(null, byte[].class));\n+    }\n+\n+    /**\n+     * Tests to verify that primitive number arrays round-trip\n+     * correctly, i.e. type -> type gives equal (although\n+     * not necessarily same) output\n+     */\n+    public void testArrayIdentityTransforms() throws Exception {\n+        _testArrayIdentityTransforms(xmlMapper(true));\n+        _testArrayIdentityTransforms(xmlMapper(false));\n+    }\n+\n+    private void _testArrayIdentityTransforms(ObjectMapper mapper) throws Exception\n+    {\n+        // first integral types\n+        // (note: byte[] is ok, even if it goes to base64 and back)\n+        verifyByteArrayConversion(mapper, bytes(), byte[].class);\n+        verifyShortArrayConversion(mapper, shorts(), short[].class);\n+        verifyIntArrayConversion(mapper, ints(), int[].class);\n+        verifyLongArrayConversion(mapper, longs(), long[].class);\n+        // then primitive decimal types\n+        verifyFloatArrayConversion(mapper, floats(), float[].class);\n+        verifyDoubleArrayConversion(mapper, doubles(), float[].class);\n+    }\n+\n+    public void testByteArrayFrom() throws Exception {\n+        _testByteArrayFrom(xmlMapper(true));\n+        _testByteArrayFrom(xmlMapper(false));\n+    }\n+\n+    private void _testByteArrayFrom(ObjectMapper mapper) throws Exception\n+    {\n+        /* Note: byte arrays are tricky, since they are considered\n+         * binary data primarily, not as array of numbers. Hence\n+         * output will be base64 encoded...\n+         */\n+        byte[] data = _convert(mapper, \"c3VyZS4=\", byte[].class);\n+        byte[] exp = \"sure.\".getBytes(\"Ascii\");\n+        verifyIntegralArrays(exp, data, exp.length);\n+    }\n+    \n+    public void testShortArrayToX() throws Exception\n+    {\n+        final XmlMapper mapper = new XmlMapper();\n+        short[] data = shorts();\n+        verifyShortArrayConversion(mapper, data, byte[].class);\n+        verifyShortArrayConversion(mapper, data, int[].class);\n+        verifyShortArrayConversion(mapper, data, long[].class);\n+    }\n+\n+    public void testIntArrayToX() throws Exception\n+    {\n+        final XmlMapper mapper = new XmlMapper();\n+\n+        int[] data = ints();\n+        verifyIntArrayConversion(mapper, data, byte[].class);\n+        verifyIntArrayConversion(mapper, data, short[].class);\n+        verifyIntArrayConversion(mapper, data, long[].class);\n+\n+        List<Number> expNums = _numberList(data, data.length);\n+        // Alas, due to type erasure, need to use TypeRef, not just class\n+        List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() {});\n+        assertEquals(expNums, actNums);\n+    }\n+\n+    public void testLongArrayToX() throws Exception\n+    {\n+        final XmlMapper mapper = new XmlMapper();\n+        long[] data = longs();\n+        verifyLongArrayConversion(mapper, data, byte[].class);\n+        verifyLongArrayConversion(mapper, data, short[].class);\n+        verifyLongArrayConversion(mapper, data, int[].class);\n+ \n+        List<Number> expNums = _numberList(data, data.length);\n+        List<Long> actNums = mapper.convertValue(data, new TypeReference<List<Long>>() {});\n+        assertEquals(expNums, actNums);        \n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Helper methods\n+    /********************************************************\n+     */\n+\n+    // note: all value need to be within byte range\n+    \n+    private byte[] bytes() { return new byte[] { 1, -1, 0, 98, 127 }; }\n+    private short[] shorts() { return new short[] { 1, -1, 0, 98, 127 }; }\n+    private int[] ints() { return new int[] { 1, -1, 0, 98, 127 }; }\n+    private long[] longs() { return new long[] { 1, -1, 0, 98, 127 }; }\n+\n+    // note: use values that are exact in binary\n+\n+    private double[] doubles() { return new double[] { 0.0, 0.25, -0.125, 10.5, 9875.0 }; }\n+    private float[] floats() { return new float[] {\n+            0.0f, 0.25f, -0.125f, 10.5f, 9875.0f };\n+    }\n+\n+    private <T> void verifyByteArrayConversion(ObjectMapper mapper, byte[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyShortArrayConversion(ObjectMapper mapper, short[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyIntArrayConversion(ObjectMapper mapper, int[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyLongArrayConversion(ObjectMapper mapper, long[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyFloatArrayConversion(ObjectMapper mapper, float[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyDoubleArrays(data, result, data.length);\n+    }\n+    private <T> void verifyDoubleArrayConversion(ObjectMapper mapper, double[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyDoubleArrays(data, result, data.length);\n+    }\n+    \n+    private <T> T _convert(ObjectMapper mapper, Object input, Class<T> outputType)\n+    {\n+        // must be a primitive array, like \"int[].class\"\n+        if (!outputType.isArray()) throw new IllegalArgumentException();\n+        if (!outputType.getComponentType().isPrimitive()) throw new IllegalArgumentException();\n+        T result = mapper.convertValue(input, outputType);\n+        // sanity check first:\n+        assertNotNull(result);\n+        assertEquals(outputType, result.getClass());\n+        return result;\n+    }\n+\n+    private List<Number> _numberList(Object numberArray, int size)\n+    {\n+        ArrayList<Number> result = new ArrayList<Number>(size);\n+        for (int i = 0; i < size; ++i) {\n+            result.add((Number) Array.get(numberArray, i));\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Helper method for checking that given collections contain integral Numbers\n+     * that essentially contain same values in same order\n+     */\n+    private void verifyIntegralArrays(Object inputArray, Object outputArray, int size)\n+    {\n+        for (int i = 0; i < size; ++i) {\n+            Number n1 = (Number) Array.get(inputArray, i);\n+            Number n2 = (Number) Array.get(outputArray, i);\n+            double value1 = ((Number) n1).longValue();\n+            double value2 = ((Number) n2).longValue();\n+            assertEquals(\"Entry #\"+i+\"/\"+size+\" not equal\", value1, value2);\n+        }        \n+    }\n+\n+    private void verifyDoubleArrays(Object inputArray, Object outputArray, int size)\n+    {\n+        for (int i = 0; i < size; ++i) {\n+            Number n1 = (Number) Array.get(inputArray, i);\n+            Number n2 = (Number) Array.get(outputArray, i);\n+            double value1 = ((Number) n1).doubleValue();\n+            double value2 = ((Number) n2).doubleValue();\n+            assertEquals(\"Entry #\"+i+\"/\"+size+\" not equal\", value1, value2);\n+        }        \n+    }\n+\n+}", "timestamp": 1376591290, "metainfo": ""}