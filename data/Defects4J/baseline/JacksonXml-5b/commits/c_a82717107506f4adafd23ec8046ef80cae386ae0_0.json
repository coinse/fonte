{"sha": "a82717107506f4adafd23ec8046ef80cae386ae0", "log": "yet more rearranging, mostly done.", "commit": "\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/jaxb/AttributesWithJAXBTest.java\n+package com.fasterxml.jackson.dataformat.xml.jaxb;\n+\n+import java.io.IOException;\n+\n+import javax.xml.bind.annotation.*;\n+\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class AttributesWithJAXBTest extends XmlTestBase\n+{\n+    @XmlAccessorType(value = XmlAccessType.FIELD)\n+    public class Jurisdiction {\n+        @XmlAttribute(name=\"name\",required=true)\n+        protected String name = \"Foo\";\n+        @XmlAttribute(name=\"value\",required=true)\n+        protected int value = 13;\n+    }\n+\n+    /*\n+    /**********************************************************************\n+    /* Set up\n+    /**********************************************************************\n+     */\n+\n+    protected XmlMapper _jaxbMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _jaxbMapper = new XmlMapper();\n+        _jaxbMapper.setAnnotationIntrospector(new XmlJaxbAnnotationIntrospector(TypeFactory.defaultInstance()));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testIssue6() throws IOException\n+    {\n+        assertEquals(\"<Jurisdiction name=\\\"Foo\\\" value=\\\"13\\\"/>\",\n+                _jaxbMapper.writeValueAsString(new Jurisdiction()));\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/jaxb/ElementWrapperTest.java\n+package com.fasterxml.jackson.dataformat.xml.jaxb;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlAnnotationIntrospector;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class ElementWrapperTest extends XmlTestBase\n+{\n+    @XmlRootElement(name = \"Individual\")\n+    static class MyPerson {\n+          public String name;\n+\n+          @XmlElementWrapper(name = \"offspring\")\n+          @XmlElement(name = \"kid\")\n+          public List<MyPerson> children = new ArrayList<MyPerson>();\n+    }\n+\n+    @XmlRootElement(name=\"p\")\n+    static class MyPerson2 {\n+        public String name;\n+\n+        public List<MyPerson2> child = new ArrayList<MyPerson2>();\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Unit tests\n+    /**********************************************************************\n+     */\n+\n+    public void testElementWrapper() throws Exception\n+    {\n+        XmlMapper _jaxbMapper = new XmlMapper();\n+        // Use JAXB-then-Jackson annotation introspector\n+        AnnotationIntrospector intr = XmlAnnotationIntrospector.Pair.instance\n+            (new XmlJaxbAnnotationIntrospector(TypeFactory.defaultInstance()),\n+                    new JacksonAnnotationIntrospector());\n+        _jaxbMapper.setAnnotationIntrospector(intr);\n+\n+        MyPerson person = new MyPerson();\n+        person.name = \"Jay\";\n+\n+        MyPerson child = new MyPerson();\n+        child.name = \"Junior\";\n+        \n+        person.children.add(child);\n+\n+        String xml = _jaxbMapper.writer().writeValueAsString(person);\n+        \n+        String expected = \"<Individual><name>Jay</name>\"\n+                + \"<offspring><kid><name>Junior</name><offspring/></kid></offspring></Individual>\";\n+        assertEquals(expected, xml);\n+    }\n+\n+    // And with JAXB, default should be \"no wrapper\"\n+    public void testNoElementWrapper() throws Exception\n+    {\n+        XmlMapper jaxbMapper = new XmlMapper();\n+        jaxbMapper.setAnnotationIntrospector(new XmlJaxbAnnotationIntrospector(TypeFactory.defaultInstance()));\n+\n+        MyPerson2 person = new MyPerson2();\n+        person.name = \"Jay\";\n+\n+        MyPerson2 child = new MyPerson2();\n+        child.name = \"Junior\";\n+        \n+        person.child.add(child);\n+\n+        String xml = jaxbMapper.writeValueAsString(person);\n+        \n+        String expected = \"<p><name>Jay</name><child><name>Junior</name></child></p>\";\n+        assertEquals(expected, xml);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/jaxb/WithJAXBAnnotationsTest.java\n+package com.fasterxml.jackson.dataformat.xml.jaxb;\n+\n+import java.io.IOException;\n+\n+import javax.xml.bind.annotation.*;\n+\n+import com.fasterxml.jackson.databind.AnnotationIntrospector;\n+import com.fasterxml.jackson.databind.introspect.JacksonAnnotationIntrospector;\n+import com.fasterxml.jackson.databind.type.TypeFactory;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlAnnotationIntrospector;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.jaxb.XmlJaxbAnnotationIntrospector;\n+\n+/**\n+ * Although XML-backed data binding does not rely (or directly build) on JAXB\n+ * annotations, it should be possible to use them similar to how they are used\n+ * with default Jackson JSON data binding. Let's verify this is the case.\n+ */\n+public class WithJAXBAnnotationsTest extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************************\n+    /* Helper types\n+    /**********************************************************************\n+     */\n+\n+    @XmlRootElement(name=\"bean\")\n+    public static class RootBean\n+    {\n+        public String value = \"text\";\n+    }\n+    \n+    public static class AttrBean\n+    {        \n+        @XmlAttribute\n+        public String attr = \"3\";\n+    }\n+\n+    @javax.xml.bind.annotation.XmlRootElement(name=\"Simple\")\n+    static class WithXmlValue\n+    {\n+        @javax.xml.bind.annotation.XmlAttribute\n+        public int a = 13;\n+\n+        @javax.xml.bind.annotation.XmlValue\n+        public String text = \"something\";\n+    }\n+\n+    @XmlRootElement(name = \"Individual\")\n+    static class MyPerson {\n+        @XmlAttribute(name = \"identifier\")\n+        public Long id;\n+\n+        @XmlElement(name = \"givenName\")\n+        public String firstName;\n+    \n+        @XmlElement(name = \"surName\")\n+        public String lastName;\n+\n+        public Long getId() {\n+            return id;\n+        }\n+        public void setId(final Long id) {\n+            this.id = id;\n+        }\n+\n+        public String getFirstName() {\n+            return firstName;\n+        }\n+        public void setFirstName(final String firstName) {\n+            this.firstName = firstName;\n+        }\n+\n+        public String getLastName() {\n+            return lastName;\n+        }\n+        public void setLastName(final String lastName) {\n+            this.lastName = lastName;\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Set up\n+    /**********************************************************************\n+     */\n+\n+    protected XmlMapper _jaxbMapper;\n+    protected XmlMapper _nonJaxbMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _jaxbMapper = new XmlMapper();\n+        _nonJaxbMapper = new XmlMapper();\n+        // Use JAXB-then-Jackson annotation introspector\n+        AnnotationIntrospector intr = XmlAnnotationIntrospector.Pair.instance\n+            (new XmlJaxbAnnotationIntrospector(TypeFactory.defaultInstance()), new JacksonAnnotationIntrospector());\n+        _jaxbMapper.setAnnotationIntrospector(intr);\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Unit tests\n+    /**********************************************************************\n+     */\n+\n+    /**\n+     * Unit test for verifying that root element name can be overridden\n+     * with {@link XmlRootElement} annotation.\n+     */\n+    public void testRootName() throws Exception\n+    {\n+        RootBean bean = new RootBean();\n+        // without JAXB annotations will use class simple name:\n+        assertEquals(\"<RootBean><value>text</value></RootBean>\", _nonJaxbMapper.writeValueAsString(bean));\n+        assertEquals(\"<bean><value>text</value></bean>\", _jaxbMapper.writeValueAsString(bean));\n+    }\n+\n+    /**\n+     * Unit test for verifying that a property defaults to being written as\n+     * element, but can be redefined with {@link XmlAttribute} annotation.\n+     */\n+    public void testSerializeAsAttr() throws Exception\n+    {\n+        AttrBean bean = new AttrBean();\n+        assertEquals(\"<AttrBean><attr>3</attr></AttrBean>\", _nonJaxbMapper.writeValueAsString(bean));\n+        assertEquals(\"<AttrBean attr=\\\"3\\\"/>\", _jaxbMapper.writeValueAsString(bean));\n+    }\n+\n+    /**\n+     * Unit test for verifying correct handling of\n+     * {@link XmlValue} annotation.\n+     */\n+    public void testAsTextWithJAXB() throws IOException\n+    {\n+    \t// first: serialize\n+    \tString xml = _jaxbMapper.writeValueAsString(new WithXmlValue());\n+    \tassertEquals(\"<Simple a=\\\"13\\\">something</Simple>\", xml);\n+\n+    \t// and then deserialize back...\n+    \tWithXmlValue result = _jaxbMapper.readValue(\"<Simple a='99'>else</Simple>\",\n+    \t\t\tWithXmlValue.class);\n+    \tassertEquals(99, result.a);\n+    \tassertEquals(\"else\", result.text);\n+    }\n+\n+    public void testPersonAsXml() throws Exception {\n+        MyPerson person = new MyPerson();\n+        person.id = Long.valueOf(1L);\n+        person.firstName = \"Jay\";\n+        person.lastName = \"Unit\";\n+    \n+        String json = _jaxbMapper.writeValueAsString(person);\n+// System.out.println(\"Person: \" + json);\n+    \n+        String expected = \"<Individual identifier=\\\"1\\\"><givenName>Jay</givenName>\"\n+                +\"<surName>Unit</surName></Individual>\";\n+        assertEquals(expected, json);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/ArrayConversionsTest.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import java.util.*;\n+import java.lang.reflect.Array;\n+\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.*;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+/* NOTE: copied from jackson-databind (with some pruning)\n+ */\n+\n+/**\n+ * Conversion tests to ensure that standard ObjectMapper conversions\n+ * work despite XmlMapper having to add XML-specific work-arounds.\n+ */\n+public class ArrayConversionsTest extends XmlTestBase\n+{\n+    static class IntListWrapper {\n+        public List<Integer> values;\n+    }\n+\n+    static class IntArrayWrapper {\n+        public int[] values;\n+\n+        public IntArrayWrapper() { }\n+        public IntArrayWrapper(int[] v) { values = v; }\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Test methods\n+    /********************************************************\n+     */\n+\n+    public void testNullXform() throws Exception {\n+        _testNullXform(xmlMapper(true));\n+        _testNullXform(xmlMapper(false));\n+    }\n+    \n+    private void _testNullXform(ObjectMapper mapper) throws Exception\n+    {\n+        // when given null, null should be returned without conversion (Java null has no type)\n+        assertNull(mapper.convertValue(null, Integer.class));\n+        assertNull(mapper.convertValue(null, String.class));\n+        assertNull(mapper.convertValue(null, byte[].class));\n+    }\n+\n+    /**\n+     * Tests to verify that primitive number arrays round-trip\n+     * correctly, i.e. type -> type gives equal (although\n+     * not necessarily same) output\n+     */\n+    public void testArrayIdentityTransforms() throws Exception {\n+        _testArrayIdentityTransforms(xmlMapper(true));\n+        _testArrayIdentityTransforms(xmlMapper(false));\n+    }\n+\n+    private void _testArrayIdentityTransforms(ObjectMapper mapper) throws Exception\n+    {\n+        // first integral types\n+        // (note: byte[] is ok, even if it goes to base64 and back)\n+        verifyByteArrayConversion(mapper, bytes(), byte[].class);\n+        verifyShortArrayConversion(mapper, shorts(), short[].class);\n+        verifyIntArrayConversion(mapper, ints(), int[].class);\n+        verifyLongArrayConversion(mapper, longs(), long[].class);\n+        // then primitive decimal types\n+        verifyFloatArrayConversion(mapper, floats(), float[].class);\n+        verifyDoubleArrayConversion(mapper, doubles(), float[].class);\n+    }\n+\n+    public void testByteArrayFrom() throws Exception {\n+        _testByteArrayFrom(xmlMapper(true));\n+        _testByteArrayFrom(xmlMapper(false));\n+    }\n+\n+    private void _testByteArrayFrom(ObjectMapper mapper) throws Exception\n+    {\n+        /* Note: byte arrays are tricky, since they are considered\n+         * binary data primarily, not as array of numbers. Hence\n+         * output will be base64 encoded...\n+         */\n+        byte[] data = _convert(mapper, \"c3VyZS4=\", byte[].class);\n+        byte[] exp = \"sure.\".getBytes(\"Ascii\");\n+        verifyIntegralArrays(exp, data, exp.length);\n+    }\n+    \n+    public void testShortArrayToX() throws Exception\n+    {\n+        final XmlMapper mapper = new XmlMapper();\n+        short[] data = shorts();\n+        verifyShortArrayConversion(mapper, data, byte[].class);\n+        verifyShortArrayConversion(mapper, data, int[].class);\n+        verifyShortArrayConversion(mapper, data, long[].class);\n+    }\n+\n+    public void testIntArrayToX() throws Exception\n+    {\n+        final XmlMapper mapper = new XmlMapper();\n+\n+        int[] data = ints();\n+        verifyIntArrayConversion(mapper, data, byte[].class);\n+        verifyIntArrayConversion(mapper, data, short[].class);\n+        verifyIntArrayConversion(mapper, data, long[].class);\n+\n+        List<Number> expNums = _numberList(data, data.length);\n+        // Alas, due to type erasure, need to use TypeRef, not just class\n+        List<Integer> actNums = mapper.convertValue(data, new TypeReference<List<Integer>>() {});\n+        assertEquals(expNums, actNums);\n+    }\n+\n+    public void testLongArrayToX() throws Exception\n+    {\n+        final XmlMapper mapper = new XmlMapper();\n+        long[] data = longs();\n+        verifyLongArrayConversion(mapper, data, byte[].class);\n+        verifyLongArrayConversion(mapper, data, short[].class);\n+        verifyLongArrayConversion(mapper, data, int[].class);\n+ \n+        List<Number> expNums = _numberList(data, data.length);\n+        List<Long> actNums = mapper.convertValue(data, new TypeReference<List<Long>>() {});\n+        assertEquals(expNums, actNums);        \n+    }\n+\n+    public void testListToIntArray() throws Exception\n+    {\n+        _testListToIntArray(true);\n+        _testListToIntArray(false);\n+    }\n+\n+    private void _testListToIntArray(boolean wrap) throws Exception\n+    {\n+        final XmlMapper mapper = xmlMapper(wrap);\n+        List<Integer> in = new ArrayList<Integer>();\n+        in.add(1);\n+        in.add(2);\n+        in.add(3);\n+        int[] out = mapper.convertValue(in, int[].class);\n+        assertEquals(3, out.length);\n+        for (int i = 0; i < out.length; ++i) {\n+            assertEquals(i+1, out[i]);\n+        }\n+    }\n+    \n+    public void testListAsProperty() throws Exception\n+    {\n+        _testListAsProperty(true);\n+        _testListAsProperty(false);\n+    }\n+\n+    private void _testListAsProperty(boolean wrap) throws Exception\n+    {\n+        final XmlMapper mapper = xmlMapper(wrap);\n+        IntListWrapper mid = mapper.convertValue(new IntArrayWrapper(new int[] { 1, 2, 3}),\n+                IntListWrapper.class);\n+        assertNotNull(mid);\n+        assertNotNull(mid.values);\n+        assertEquals(3, mid.values.size());\n+\n+        IntArrayWrapper output = mapper.convertValue(mid, IntArrayWrapper.class);\n+        assertEquals(3, output.values.length);\n+        assertEquals(3, output.values[2]);\n+    }\n+    \n+    /*\n+    /********************************************************\n+    /* Helper methods\n+    /********************************************************\n+     */\n+\n+    // note: all value need to be within byte range\n+    \n+    private byte[] bytes() { return new byte[] { 1, -1, 0, 98, 127 }; }\n+    private short[] shorts() { return new short[] { 1, -1, 0, 98, 127 }; }\n+    private int[] ints() { return new int[] { 1, -1, 0, 98, 127 }; }\n+    private long[] longs() { return new long[] { 1, -1, 0, 98, 127 }; }\n+\n+    // note: use values that are exact in binary\n+\n+    private double[] doubles() { return new double[] { 0.0, 0.25, -0.125, 10.5, 9875.0 }; }\n+    private float[] floats() { return new float[] {\n+            0.0f, 0.25f, -0.125f, 10.5f, 9875.0f };\n+    }\n+\n+    private <T> void verifyByteArrayConversion(ObjectMapper mapper, byte[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyShortArrayConversion(ObjectMapper mapper, short[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyIntArrayConversion(ObjectMapper mapper, int[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyLongArrayConversion(ObjectMapper mapper, long[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyIntegralArrays(data, result, data.length);\n+    }\n+    private <T> void verifyFloatArrayConversion(ObjectMapper mapper, float[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyDoubleArrays(data, result, data.length);\n+    }\n+    private <T> void verifyDoubleArrayConversion(ObjectMapper mapper, double[] data, Class<T> arrayType) {\n+        T result = _convert(mapper, data, arrayType);\n+        verifyDoubleArrays(data, result, data.length);\n+    }\n+    \n+    private <T> T _convert(ObjectMapper mapper, Object input, Class<T> outputType)\n+    {\n+        // must be a primitive array, like \"int[].class\"\n+        if (!outputType.isArray()) throw new IllegalArgumentException();\n+        if (!outputType.getComponentType().isPrimitive()) throw new IllegalArgumentException();\n+        T result = mapper.convertValue(input, outputType);\n+        // sanity check first:\n+        assertNotNull(result);\n+        assertEquals(outputType, result.getClass());\n+        return result;\n+    }\n+\n+    private List<Number> _numberList(Object numberArray, int size)\n+    {\n+        ArrayList<Number> result = new ArrayList<Number>(size);\n+        for (int i = 0; i < size; ++i) {\n+            result.add((Number) Array.get(numberArray, i));\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Helper method for checking that given collections contain integral Numbers\n+     * that essentially contain same values in same order\n+     */\n+    private void verifyIntegralArrays(Object inputArray, Object outputArray, int size)\n+    {\n+        for (int i = 0; i < size; ++i) {\n+            Number n1 = (Number) Array.get(inputArray, i);\n+            Number n2 = (Number) Array.get(outputArray, i);\n+            double value1 = ((Number) n1).longValue();\n+            double value2 = ((Number) n2).longValue();\n+            assertEquals(\"Entry #\"+i+\"/\"+size+\" not equal\", value1, value2);\n+        }        \n+    }\n+\n+    private void verifyDoubleArrays(Object inputArray, Object outputArray, int size)\n+    {\n+        for (int i = 0; i < size; ++i) {\n+            Number n1 = (Number) Array.get(inputArray, i);\n+            Number n2 = (Number) Array.get(outputArray, i);\n+            double value1 = ((Number) n1).doubleValue();\n+            double value2 = ((Number) n2).doubleValue();\n+            assertEquals(\"Entry #\"+i+\"/\"+size+\" not equal\", value1, value2);\n+        }        \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/ObjectId104Test.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+/**\n+ * Unit test to showcase issue #104, based on TestObjectIdDeserialization unit test in databind package.\n+ */\n+public class ObjectId104Test extends XmlTestBase {\n+    // // Classes for external id from property annotations:\n+    \n+    static class IdWrapper\n+    {\n+        @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"id\")\n+        public ValueNode node;\n+\n+        public IdWrapper() { }\n+        public IdWrapper(int v) {\n+            node = new ValueNode(v);\n+        }\n+    }\n+\n+    static class ValueNode {\n+        public List<Integer> value= new ArrayList<Integer>();\n+        public IdWrapper next;\n+        \n+        public ValueNode() { this(0); }\n+        public ValueNode(int v) { value.add(v); }\n+    }\n+    \n+    private final XmlMapper MAPPER = new XmlMapper();\n+    \n+    // Another test to ensure ordering is not required (i.e. can do front references)\n+    public void testSimpleCollectionDeserWithForwardRefs() throws Exception\n+    {\n+        IdWrapper result = MAPPER.readValue(\"<IdWrapper><node><value><value>7</value></value><next><node>1</node></next><id>1</id></node></IdWrapper>\"\n+                ,IdWrapper.class);\n+        assertEquals(7, (int)result.node.value.get(0));\n+        assertSame(result.node, result.node.next.node);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/PolymorphicTypesTest.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+\n+public class PolymorphicTypesTest extends XmlTestBase\n+{\n+    /*\n+    /**********************************************************\n+    /* Helper types\n+    /**********************************************************\n+     */\n+\n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)\n+    static class BaseTypeWithClassProperty { }\n+\n+    static class SubTypeWithClassProperty extends BaseTypeWithClassProperty {\n+        public String name;\n+\n+        public SubTypeWithClassProperty() { }\n+        public SubTypeWithClassProperty(String s) { name = s; }\n+    }\n+    \n+    @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.WRAPPER_OBJECT)\n+    protected static class BaseTypeWithClassObject { }\n+\n+    protected static class SubTypeWithClassObject extends BaseTypeWithClassObject {\n+        public String name;\n+    \n+        public SubTypeWithClassObject() { }\n+        public SubTypeWithClassObject(String s) { name = s; }\n+    }\n+\n+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY)\n+    @JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = \"id\")\n+    protected static class TypeWithClassPropertyAndObjectId {\n+        public String id;\n+\n+        public TypeWithClassPropertyAndObjectId() {}\n+        public TypeWithClassPropertyAndObjectId(String id) { this.id = id; }\n+    }\n+\n+    protected static class Wrapper {\n+        public List<TypeWithClassPropertyAndObjectId> data;\n+\n+        public Wrapper(){}\n+        public Wrapper(List<TypeWithClassPropertyAndObjectId> data) { this.data = data; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Set up\n+    /**********************************************************\n+     */\n+\n+    protected XmlMapper _xmlMapper;\n+\n+    // let's actually reuse XmlMapper to make things bit faster\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        _xmlMapper = new XmlMapper();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    public void testAsClassProperty() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new SubTypeWithClassProperty(\"Foobar\"));\n+\n+        // Type info should be written as an attribute, so:\n+        /* 13-Jan-2010, tatu: With Jackson 1.7.1, it is possible to override type information\n+         *   inclusion, which allows use of attribute over element, so:\n+         */\n+        final String exp = \n+            \"<SubTypeWithClassProperty _class=\\\"com.fasterxml.jackson.dataformat.xml.misc.PolymorphicTypesTest..SubTypeWithClassProperty\\\">\"\n+            //\"<SubTypeWithClassProperty><_class>com.fasterxml.jackson.xml.types.TestPolymorphic..SubTypeWithClassProperty</_class>\"\n+            +\"<name>Foobar</name></SubTypeWithClassProperty>\"\n+                ;\n+        assertEquals(exp, xml);\n+        \n+        Object result = _xmlMapper.readValue(xml, BaseTypeWithClassProperty.class);\n+        assertNotNull(result);\n+        assertEquals(SubTypeWithClassProperty.class, result.getClass());\n+        assertEquals(\"Foobar\", ((SubTypeWithClassProperty) result).name);\n+    }\n+        \n+    public void testAsClassObject() throws Exception\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new SubTypeWithClassObject(\"Foobar\"));\n+        Object result = _xmlMapper.readValue(xml, BaseTypeWithClassObject.class);\n+        assertNotNull(result);\n+        assertEquals(SubTypeWithClassObject.class, result.getClass());\n+        assertEquals(\"Foobar\", ((SubTypeWithClassObject) result).name);\n+    }\n+\n+    /**\n+     * Test for issue 81\n+     */\n+    public void testAsPropertyWithObjectId() throws Exception\n+    {\n+        List<TypeWithClassPropertyAndObjectId> data = new ArrayList<PolymorphicTypesTest.TypeWithClassPropertyAndObjectId>();\n+        TypeWithClassPropertyAndObjectId object = new TypeWithClassPropertyAndObjectId(\"Foobar\");\n+        data.add(object);\n+        // This will be written as an id reference instead of object; as such, no type info will be written.\n+        data.add(object);\n+        String xml = _xmlMapper.writeValueAsString(new Wrapper(data));\n+        Wrapper result = _xmlMapper.readValue(xml, Wrapper.class);\n+        assertNotNull(result);\n+        assertSame(result.data.get(0), result.data.get(1));\n+        assertEquals(\"Foobar\", result.data.get(0).id);\n+    }\n+}\n+   \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/TextValueTest.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import java.io.IOException;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.dataformat.xml.JacksonXmlModule;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.*;\n+\n+public class TextValueTest extends XmlTestBase\n+{\n+    static class Simple\n+    {\n+        @JacksonXmlProperty(isAttribute=true)\n+        // same as: @javax.xml.bind.annotation.XmlAttribute\n+        public int a = 13;\n+\n+        @JacksonXmlText\n+        // about same as: @javax.xml.bind.annotation.XmlValue\n+        public String text = \"something\";\n+    }\n+\t\n+    // [Issue#24]\n+\n+    static class Main {\n+        @JsonProperty(\"com.test.stack\") public Stack stack;\n+    }\n+    static class Stack {\n+        public String name;\n+\n+        @JsonProperty(\"com.test.stack.slot\")\n+        public Slot slot;\n+    }\n+    static class Slot {\n+        @JsonProperty(\"name\")\n+        public String name;\n+\n+        @JsonProperty(\"id\")\n+        public String id;\n+\n+        @JsonProperty(\"height\")\n+        public String height;\n+\n+        @JsonProperty(\"width\")\n+        public String width;\n+\n+        @JacksonXmlText\n+        public String value;\n+    }\n+\n+    static class JAXBStyle\n+    {\n+        public String value;\n+    }\n+\n+    // [Issue#66]\n+    static class Issue66Bean\n+    {\n+        @JacksonXmlProperty(isAttribute = true)\n+        protected String id;\n+\n+        @JacksonXmlText\n+        protected String textValue;\n+    }\n+\n+    // [Issue#72]\n+    \n+    static class TextOnlyBean\n+    {\n+        @JacksonXmlText\n+        protected String textValue;\n+\n+        public TextOnlyBean() { }\n+        public TextOnlyBean(String str, boolean foo) { textValue = str; }\n+    }\n+\n+    @JsonPropertyOrder({ \"a\", \"b\" })\n+    static class TextOnlyWrapper\n+    {\n+        public TextOnlyBean a, b;\n+\n+        public TextOnlyWrapper() { }\n+        public TextOnlyWrapper(String a, String b) {\n+            this.a = new TextOnlyBean(a, true);\n+            this.b = new TextOnlyBean(b, true);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = new XmlMapper();\n+    \n+    public void testSerializeAsText() throws IOException\n+    {\n+        String xml = MAPPER.writeValueAsString(new Simple());\n+        assertEquals(\"<Simple a=\\\"13\\\">something</Simple>\", xml);\n+        // [Issue#56]: should work with indentation as well\n+        xml = MAPPER.writerWithDefaultPrettyPrinter().writeValueAsString(new Simple());\n+        assertEquals(\"<Simple a=\\\"13\\\">something</Simple>\", xml);\n+    }\n+\n+    public void testDeserializeAsText() throws IOException\n+    {\n+        Simple result = MAPPER.readValue(\"<Simple a='99'>else</Simple>\", Simple.class);\n+        assertEquals(99, result.a);\n+        assertEquals(\"else\", result.text);\n+    }\n+    \n+    public void testIssue24() throws Exception\n+    {\n+        final String TEXT = \"+/null/this is a long string\";\n+        final String XML =\n+    \t\t\t\"<main>\\n\"\n+    \t\t\t+\"<com.test.stack name='stack1'>\\n\"\n+    \t\t\t+\"<com.test.stack.slot height='0' id='0' name='slot0' width='0'>\"\n+    \t\t\t+TEXT\n+    \t\t\t+\"</com.test.stack.slot>\\n\"\n+    \t\t\t+\"</com.test.stack>\\n\"\n+    \t\t\t+\"</main>\";\n+        Main main = MAPPER.readValue(XML, Main.class);\n+        assertNotNull(main.stack);\n+        assertNotNull(main.stack.slot);\n+        assertEquals(TEXT, main.stack.slot.value);\n+    }\n+\n+    // for [Issue#36]\n+    public void testAlternateTextElementName() throws IOException\n+    {\n+        final String XML = \"<JAXBStyle>foo</JAXBStyle>\";\n+        // first: verify that without change, POJO would not match:\n+        try {\n+            MAPPER.readValue(XML, JAXBStyle.class);\n+            fail(\"Should have failed\");\n+        } catch (JsonProcessingException e) {\n+            verifyException(e, \"Unrecognized\");\n+        }\n+        JacksonXmlModule module = new JacksonXmlModule();\n+        module.setXMLTextElementName(\"value\");\n+        XmlMapper mapper = new XmlMapper(module);\n+        JAXBStyle pojo = mapper.readValue(XML, JAXBStyle.class);\n+        assertEquals(\"foo\", pojo.value);\n+    }\n+\n+    // [Issue#66], implicit property from \"XmlText\"\n+    public void testIssue66() throws Exception\n+    {\n+        JacksonXmlModule module = new JacksonXmlModule();\n+        module.setDefaultUseWrapper(false);\n+        XmlMapper mapper = new XmlMapper(module);\n+        final String XML = \"<Issue66Bean id=\\\"id\\\">text</Issue66Bean>\";\n+\n+        // let's start with deserialization\n+        Issue66Bean node = mapper.readValue(XML, Issue66Bean.class);\n+        assertEquals(\"id\", node.id);\n+        assertEquals(\"text\", node.textValue);\n+\n+        // Let's serialize too\n+        String json = mapper.writeValueAsString(node);\n+        assertEquals(XML, json);\n+    }\n+\n+    // [Issue#72]\n+    public void testTextOnlyPojo() throws Exception\n+    {\n+        XmlMapper mapper = xmlMapper(true);\n+        TextOnlyWrapper input = new TextOnlyWrapper(\"foo\", \"bar\");\n+        // serialization should work fine\n+        String xml = mapper.writeValueAsString(input);\n+        assertEquals(\"<TextOnlyWrapper><a>foo</a><b>bar</b></TextOnlyWrapper>\", xml);\n+        // but how about deser?\n+        TextOnlyWrapper result = mapper.readValue(xml, TextOnlyWrapper.class);\n+        assertNotNull(result);\n+        assertEquals(\"foo\", result.a.textValue);\n+        assertEquals(\"bar\", result.b.textValue);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/misc/XmlTextTest.java\n+package com.fasterxml.jackson.dataformat.xml.misc;\n+\n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n+import com.fasterxml.jackson.annotation.JsonInclude.Include;\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlText;\n+\n+public class XmlTextTest extends XmlTestBase\n+{\n+    @JsonPropertyOrder({\"first\",\"second\"})\n+    class Data{\n+        @JacksonXmlText\n+        public String first;\n+        public String second;\n+        public Data(String first, String second) {\n+            this.first = first;\n+            this.second = second;\n+        }\n+    }\n+\n+    public void testXmlTextWithSuppressedValue() throws Exception\n+    {\n+        final XmlMapper mapper = new XmlMapper();\n+        mapper.setSerializationInclusion(Include.NON_EMPTY);\n+        String xml = mapper.writeValueAsString(new Data(\"\",\"second\"));\n+        String expectedXml = \"<Data><second>second</second></Data>\";\n+        assertEquals(expectedXml, xml);\n+    }\n+}", "timestamp": 1395431653, "metainfo": ""}