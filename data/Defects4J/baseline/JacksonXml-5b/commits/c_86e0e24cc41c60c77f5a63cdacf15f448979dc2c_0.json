{"sha": "86e0e24cc41c60c77f5a63cdacf15f448979dc2c", "log": "Merge branch '2.7'", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlTypeResolverBuilder.java\n package com.fasterxml.jackson.dataformat.xml;\n \n+import java.io.IOException;\n import java.util.Collection;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n         }\n \n         @Override\n-        public JavaType typeFromId(DatabindContext context, String id) {\n+        public JavaType typeFromId(DatabindContext context, String id) throws IOException {\n             return super.typeFromId(context, decodeXmlClassName(id));\n         }\n     }\n         }\n \n         @Override\n-        public JavaType typeFromId(DatabindContext context, String id) {\n+        public JavaType typeFromId(DatabindContext context, String id) throws IOException {\n             return super.typeFromId(context, decodeXmlClassName(id));\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n     @Override\n     public boolean canWriteFormattedNumbers() { return true; }\n \n+    // @since 2.7.5\n+    public boolean inRoot() {\n+        return _writeContext.inRoot();\n+    }\n+\n     /*\n     /**********************************************************\n     /* Extended API, access to some internal components\n         if (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)) {\n             try {\n                 while (true) {\n-                    JsonStreamContext ctxt = getOutputContext();\n+\t\t    /* 28-May-2016, tatu: To work around incompatibility introduced by\n+\t\t     *     `jackson-core` 2.8 where return type of `getOutputContext()`\n+\t\t     *     changed, let's do direct access here.\n+\t\t     */\n+//                    JsonStreamContext ctxt = getOutputContext();\n+\t\t    JsonStreamContext ctxt = _writeContext;\n                     if (ctxt.inArray()) {\n                         writeEndArray();\n                     } else if (ctxt.inObject()) {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n     protected void _initWithRootName(ToXmlGenerator xgen, QName rootName) throws IOException\n     {\n         /* 28-Nov-2012, tatu: We should only initialize the root\n-         *  name if no name has been set, as per [Issue#42],\n+         *  name if no name has been set, as per [dataformat-xml#42],\n          *  to allow for custom serializers to work.\n          */\n         if (!xgen.setNextNameIfMissing(rootName)) {\n             // however, if we are root, we... insist\n-            if (xgen.getOutputContext().inRoot()) {\n+            if (xgen.inRoot()) {\n                 xgen.setNextName(rootName);\n             }\n         }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n     /**********************************************************\n      */\n \n-    /**\n-     * XML indentation differs from JSON indentation, thereby\n-     * need to change default pretty-printer\n-     */\n+    // 09-May-2016, tatu: Was removed from `jackson-databind` in 2.8; remove from\n+    //    here in 2.9.\n     @Deprecated // since 2.6\n-    @Override\n+//    @Override\n     protected PrettyPrinter _defaultPrettyPrinter() {\n         return new DefaultXmlPrettyPrinter();\n     }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlTypeResolverBuilder.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlTypeResolverBuilder.java\n package com.fasterxml.jackson.dataformat.xml;\n \n+import java.io.IOException;\n import java.util.Collection;\n \n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n             return encodeXmlClassName(super.idFromValue(value));\n         }\n \n-        @SuppressWarnings(\"deprecation\")\n         @Override\n-        public JavaType typeFromId(String id) {\n-            return super.typeFromId(decodeXmlClassName(id));\n-        }\n-\n-        @Override\n-        public JavaType typeFromId(DatabindContext context, String id) {\n+        public JavaType typeFromId(DatabindContext context, String id) throws IOException {\n             return super.typeFromId(context, decodeXmlClassName(id));\n         }\n     }\n             return encodeXmlClassName(super.idFromValue(value));\n         }\n \n-        @SuppressWarnings(\"deprecation\")\n         @Override\n-        public JavaType typeFromId(String id) {\n-            return super.typeFromId(decodeXmlClassName(id));\n-        }\n-\n-        @Override\n-        public JavaType typeFromId(DatabindContext context, String id) {\n+        public JavaType typeFromId(DatabindContext context, String id) throws IOException {\n             return super.typeFromId(context, decodeXmlClassName(id));\n         }\n     }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n package com.fasterxml.jackson.dataformat.xml.deser;\n \n import java.io.IOException;\n+import java.io.Writer;\n import java.math.BigDecimal;\n import java.math.BigInteger;\n import java.util.Set;\n         return false;\n     }\n \n+    @Override // since 2.8\n+    public int getText(Writer writer) throws IOException\n+    {\n+        String str = getText();\n+        if (str == null) {\n+            return 0;\n+        }\n+        writer.write(str);\n+        return str.length();\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Public API, access to token information, binary\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n     /**********************************************************\n      */\n \n-    /**\n-     * Standard JSON indenter does not work well with XML, use\n-     * default XML indenter instead.\n-     *<p>\n-     * !!! TODO: same as implementation in core 2.6; override may be\n-     * removed from 2.8\n-     */\n-    @Override\n-    public final JsonGenerator useDefaultPrettyPrinter()\n-    {\n-        // related to [dataformat-xml#136], need to verify:\n-        if (_cfgPrettyPrinter != null) {\n-            return this;\n-        }\n-        return setPrettyPrinter(_constructDefaultPrettyPrinter());\n-    }\n-\n     @Override\n     protected PrettyPrinter _constructDefaultPrettyPrinter() {\n         return new DefaultXmlPrettyPrinter();\n         }\n         return this;\n     }\n+\n+    @Override\n+    public boolean canWriteFormattedNumbers() { return true; }\n \n     // @since 2.7.5\n     public boolean inRoot() {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/UnwrappingXmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/UnwrappingXmlBeanSerializer.java\n package com.fasterxml.jackson.dataformat.xml.ser;\n \n import java.io.IOException;\n+import java.util.Set;\n \n import com.fasterxml.jackson.core.*;\n import com.fasterxml.jackson.databind.*;\n         _nameTransformer = src._nameTransformer;\n     }\n \n-    protected UnwrappingXmlBeanSerializer(UnwrappingXmlBeanSerializer src, String[] toIgnore)\n+    protected UnwrappingXmlBeanSerializer(UnwrappingXmlBeanSerializer src, Set<String> toIgnore)\n     {\n         super(src, toIgnore);\n         _nameTransformer = src._nameTransformer;\n         return new UnwrappingXmlBeanSerializer(this, _objectIdWriter, filterId);\n     }\n \n-    @Override\n-    protected BeanSerializerBase withIgnorals(String[] toIgnore)\n-    {\n+    @Override // since 2.8\n+    protected BeanSerializerBase withIgnorals(Set<String> toIgnore) {\n         return new UnwrappingXmlBeanSerializer(this, toIgnore);\n     }\n \n      * so implementation will simply return 'this'.\n      */\n     @Override\n-    protected BeanSerializerBase asArraySerializer()\n-    {\n+    protected BeanSerializerBase asArraySerializer() {\n         return this;\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializer.java\n package com.fasterxml.jackson.dataformat.xml.ser;\n \n import java.io.IOException;\n+import java.util.Set;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n-\n import com.fasterxml.jackson.databind.JsonSerializer;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.ser.BeanPropertyWriter;\n         super(src, objectIdWriter);\n     }\n \n-    public XmlBeanSerializer(XmlBeanSerializerBase src, String[] toIgnore) {\n+    public XmlBeanSerializer(XmlBeanSerializerBase src, Set<String> toIgnore) {\n         super(src, toIgnore);\n     }\n \n     /* Life-cycle: factory methods, fluent factories\n     /**********************************************************\n      */\n-\n \n     @Override\n     public JsonSerializer<Object> unwrappingSerializer(NameTransformer unwrapper) {\n     }\n \n     @Override\n-    protected BeanSerializerBase withIgnorals(String[] toIgnore) {\n+    protected BeanSerializerBase withIgnorals(Set<String> toIgnore) {\n         return new XmlBeanSerializer(this, toIgnore);\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n \n import java.io.IOException;\n import java.util.BitSet;\n+import java.util.Set;\n \n import javax.xml.namespace.QName;\n \n         _cdata = src._cdata;\n     }\n \n-    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, String[] toIgnore)\n+    protected XmlBeanSerializerBase(XmlBeanSerializerBase src, Set<String> toIgnore)\n     {\n         super(src, toIgnore);\n         _attributeCount = src._attributeCount;\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/stream/XmlParserTest.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/stream/XmlParserTest.java\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n import com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\n \n-\n public class XmlParserTest extends XmlTestBase\n {\n     /*\n         // Former could be worked around; latter less so at this point.\n \n         // So, for now, let's just do sort of minimal verification, manually\n-        JsonParser jp = _xmlMapper.getFactory().createParser(xml);\n-        \n-        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // main object\n-\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Image'\n-        verifyFieldName(jp, \"Image\");\n-        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'image' object\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n-        verifyFieldName(jp, \"Width\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_WIDTH), jp.getText());\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n-        verifyFieldName(jp, \"Height\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), jp.getText());\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Title'\n-        verifyFieldName(jp, \"Title\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Thumbnail'\n-        verifyFieldName(jp, \"Thumbnail\");\n-        assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'thumbnail' object\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Url'\n-        verifyFieldName(jp, \"Url\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Height'\n-        verifyFieldName(jp, \"Height\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), jp.getText());\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'Width'\n-        verifyFieldName(jp, \"Width\");\n+        JsonParser p = _xmlMapper.getFactory().createParser(xml);\n+        \n+        assertToken(JsonToken.START_OBJECT, p.nextToken()); // main object\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Image'\n+        verifyFieldName(p, \"Image\");\n+        assertToken(JsonToken.START_OBJECT, p.nextToken()); // 'image' object\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Width'\n+        verifyFieldName(p, \"Width\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_WIDTH), p.getText());\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Height'\n+        verifyFieldName(p, \"Height\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_HEIGHT), p.getText());\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Title'\n+        verifyFieldName(p, \"Title\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TITLE, getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Thumbnail'\n+        verifyFieldName(p, \"Thumbnail\");\n+        assertToken(JsonToken.START_OBJECT, p.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Url'\n+        verifyFieldName(p, \"Url\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_URL, getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Height'\n+        verifyFieldName(p, \"Height\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_HEIGHT), p.getText());\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'Width'\n+        verifyFieldName(p, \"Width\");\n         // Width value is actually a String in the example\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(jp));\n-\n-        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'thumbnail' object\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(SAMPLE_SPEC_VALUE_TN_WIDTH, getAndVerifyText(p));\n+\n+        assertToken(JsonToken.END_OBJECT, p.nextToken()); // 'thumbnail' object\n \n         // Note: arrays are \"eaten\"; wrapping is done using BeanPropertyWriter, so:\n-        //assertToken(JsonToken.FIELD_NAME, jp.nextToken()); // 'IDs'\n-        //verifyFieldName(jp, \"IDs\");\n-        //assertToken(JsonToken.START_OBJECT, jp.nextToken()); // 'ids' array\n-\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n-        verifyFieldName(jp, \"IDs\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); \n-        verifyFieldName(jp, \"IDs\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken());\n-        verifyFieldName(jp, \"IDs\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), getAndVerifyText(jp));\n-        assertToken(JsonToken.FIELD_NAME, jp.nextToken()); \n-        verifyFieldName(jp, \"IDs\");\n-        assertToken(JsonToken.VALUE_STRING, jp.nextToken());\n-        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), getAndVerifyText(jp));\n+        //assertToken(JsonToken.FIELD_NAME, p.nextToken()); // 'IDs'\n+        //verifyFieldName(p, \"IDs\");\n+        //assertToken(JsonToken.START_OBJECT, p.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        verifyFieldName(p, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID1), getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); \n+        verifyFieldName(p, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID2), getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken());\n+        verifyFieldName(p, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID3), getAndVerifyText(p));\n+        assertToken(JsonToken.FIELD_NAME, p.nextToken()); \n+        verifyFieldName(p, \"IDs\");\n+        assertToken(JsonToken.VALUE_STRING, p.nextToken());\n+        assertEquals(String.valueOf(SAMPLE_SPEC_VALUE_TN_ID4), getAndVerifyText(p));\n \n         // no matching entry for array:\n-        //assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'ids' array\n-\n-        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // 'image' object\n-\n-        assertToken(JsonToken.END_OBJECT, jp.nextToken()); // main object\n-        \n-        jp.close();\n+        //assertToken(JsonToken.END_OBJECT, p.nextToken()); // 'ids' array\n+\n+        assertToken(JsonToken.END_OBJECT, p.nextToken()); // 'image' object\n+\n+        assertToken(JsonToken.END_OBJECT, p.nextToken()); // main object\n+        \n+        p.close();\n     }\n \n     /**\n         assertEquals(\"property\", xp.getCurrentName());\n         assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n         assertEquals(\"123\", xp.getText());\n+\n+        StringWriter w = new StringWriter();\n+        assertEquals(3, xp.getText(w));\n+        assertEquals(\"123\", w.toString());\n+        \n         assertTrue(xp.getParsingContext().inObject());\n         assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </property>\n         assertTrue(xp.getParsingContext().inArray());\n \n         assertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <offset>\n         assertEquals(\"offset\", xp.getCurrentName());\n+\n+        StringWriter w = new StringWriter();\n+        assertEquals(6, xp.getText(w));\n+        assertEquals(\"offset\", w.toString());\n+        \n         assertToken(JsonToken.VALUE_STRING, xp.nextToken());\n         assertEquals(\"9\", xp.getText());\n \n+        w = new StringWriter();\n+        assertEquals(1, xp.getText(w));\n+        assertEquals(\"9\", w.toString());\n+        \n         assertToken(JsonToken.END_OBJECT, xp.nextToken()); // </data>\n         xp.close();\n     }\n     {\n         StringWriter w = new StringWriter();\n \n-        JsonParser jp = _xmlFactory.createParser(xml);\n+        JsonParser p = _xmlFactory.createParser(xml);\n         JsonGenerator jg = _jsonFactory.createGenerator(w);\n-        while (jp.nextToken() != null) {\n-            jg.copyCurrentEvent(jp);\n+        while (p.nextToken() != null) {\n+            jg.copyCurrentEvent(p);\n         }\n-        jp.close();\n+        p.close();\n         jg.close();\n         return w.toString();\n     }", "timestamp": 1464473584, "metainfo": ""}