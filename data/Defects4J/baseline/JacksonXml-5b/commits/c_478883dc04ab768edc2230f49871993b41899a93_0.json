{"sha": "478883dc04ab768edc2230f49871993b41899a93", "log": "Adding XmlAnnotationIntrospector.Pair", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/xml/XmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/xml/XmlAnnotationIntrospector.java\n \n import javax.xml.namespace.QName;\n \n+import org.codehaus.jackson.map.AnnotationIntrospector;\n import org.codehaus.jackson.map.introspect.Annotated;\n \n /**\n      * to using name (local name and namespace) of property itself.\n      */\n     public QName findWrapperElement(Annotated ann);\n+\n+    /*\n+    /**********************************************************************\n+    /* Replacement of 'AnnotationIntrospector.Pair' to use when combining\n+    /* (potential) XMLAnnotationIntrospector instance\n+    /**********************************************************************\n+     */\n+\n+    /**\n+     * Extension of <code>AnnotationIntrospector.Pair</code> that can\n+     * also dispatch 'XmlAnnotationIntrospector' methods.\n+     */\n+    public static class Pair extends AnnotationIntrospector.Pair\n+        implements XmlAnnotationIntrospector\n+    {\n+        protected final XmlAnnotationIntrospector _xmlPrimary;\n+        protected final XmlAnnotationIntrospector _xmlSecondary;\n+        \n+        public Pair(AnnotationIntrospector p, AnnotationIntrospector s)\n+        {\n+            super(p, s);\n+            _xmlPrimary = (p instanceof XmlAnnotationIntrospector) ? (XmlAnnotationIntrospector) p : null;\n+            _xmlSecondary = (s instanceof XmlAnnotationIntrospector) ? (XmlAnnotationIntrospector) s : null;\n+        }\n+\n+        @Override\n+        public String findNamespace(Annotated ann)\n+        {\n+            String value = (_xmlPrimary == null) ? null : _xmlPrimary.findNamespace(ann);\n+            if (value == null && _xmlSecondary != null) {\n+                value = _xmlSecondary.findNamespace(ann);\n+            }\n+            return value;\n+        }\n+\n+        @Override\n+        public QName findWrapperElement(Annotated ann)\n+        {\n+            QName value = (_xmlPrimary == null) ? null : _xmlPrimary.findWrapperElement(ann);\n+            if (value == null && _xmlSecondary != null) {\n+                value = _xmlSecondary.findWrapperElement(ann);\n+            }\n+            return value;\n+        }\n+\n+        @Override\n+        public Boolean isOutputAsAttribute(Annotated ann)\n+        {\n+            Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsAttribute(ann);\n+            if (value == null && _xmlSecondary != null) {\n+                value = _xmlSecondary.isOutputAsAttribute(ann);\n+            }\n+            return value;\n+        }\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/xml/XmlFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/xml/XmlFactory.java\n import org.codehaus.jackson.*;\n import org.codehaus.jackson.io.IOContext;\n \n+import com.fasterxml.jackson.xml.deser.FromXmlParser;\n+import com.fasterxml.jackson.xml.ser.ToXmlGenerator;\n import com.fasterxml.jackson.xml.util.StaxUtil;\n \n /**\n--- a/src/main/java/com/fasterxml/jackson/xml/XmlMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/xml/XmlMapper.java\n import org.codehaus.jackson.map.*;\n import org.codehaus.jackson.util.VersionUtil;\n \n+import com.fasterxml.jackson.xml.deser.FromXmlParser;\n+import com.fasterxml.jackson.xml.ser.ToXmlGenerator;\n+import com.fasterxml.jackson.xml.ser.XmlBeanSerializerFactory;\n+import com.fasterxml.jackson.xml.ser.XmlSerializerProvider;\n import com.fasterxml.jackson.xml.util.XmlRootNameLookup;\n \n /**\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/deser/FromXmlParser.java\n+package com.fasterxml.jackson.xml.deser;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import javax.xml.stream.XMLStreamReader;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import org.codehaus.jackson.Base64Variant;\n+import org.codehaus.jackson.JsonLocation;\n+import org.codehaus.jackson.JsonParseException;\n+import org.codehaus.jackson.JsonParser;\n+import org.codehaus.jackson.JsonToken;\n+import org.codehaus.jackson.ObjectCodec;\n+import org.codehaus.jackson.impl.JsonParserMinimalBase;\n+import org.codehaus.jackson.impl.JsonReadContext;\n+import org.codehaus.jackson.io.IOContext;\n+import org.codehaus.jackson.util.ByteArrayBuilder;\n+\n+import com.fasterxml.jackson.xml.util.XmlTokenStream;\n+\n+/**\n+ * {@link JsonParser} implementation that exposes XML structure as\n+ * set of JSON events that can be used for data binding.\n+ * \n+ * @since 1.6\n+ */\n+public class FromXmlParser\n+    extends JsonParserMinimalBase\n+{\n+    /**\n+     * Enumeration that defines all togglable features for XML parsers\n+     */\n+    public enum Feature {\n+        DUMMY_PLACEHOLDER(false)\n+        ;\n+\n+        final boolean _defaultState;\n+        final int _mask;\n+        \n+        /**\n+         * Method that calculates bit set (flags) of all features that\n+         * are enabled by default.\n+         */\n+        public static int collectDefaults()\n+        {\n+            int flags = 0;\n+            for (Feature f : values()) {\n+                if (f.enabledByDefault()) {\n+                    flags |= f.getMask();\n+                }\n+            }\n+            return flags;\n+        }\n+        \n+        private Feature(boolean defaultState) {\n+            _defaultState = defaultState;\n+            _mask = (1 << ordinal());\n+        }\n+        \n+        public boolean enabledByDefault() { return _defaultState; }\n+        public int getMask() { return _mask; }\n+    }\n+\n+    /**\n+     * In cases where a start element has both attributes and non-empty textual\n+     * value, we have to create a bogus property; we will use this as\n+     * the property name.\n+     */\n+    protected final static String UNNAMED_TEXT_PROPERTY = \"\";\n+\n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Bit flag composed of bits that indicate which\n+     * {@link org.codehaus.jackson.smile.SmileGenerator.Feature}s\n+     * are enabled.\n+     */\n+    protected int _xmlFeatures;\n+    \n+    protected ObjectCodec _objectCodec;\n+\n+    /*\n+    /**********************************************************\n+    /* I/O state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Flag that indicates whether parser is closed or not. Gets\n+     * set when parser is either closed by explicit call\n+     * ({@link #close}) or when end-of-input is reached.\n+     */\n+    protected boolean _closed;\n+    \n+    final protected IOContext _ioContext;\n+\n+    /*\n+    /**********************************************************\n+    /* Parsing state\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Information about parser context, context in which\n+     * the next token is to be parsed (root, array, object).\n+     */\n+    protected JsonReadContext _parsingContext;\n+    \n+    protected final XmlTokenStream _xmlTokens;\n+\n+    /**\n+     * We need special handling to keep track of whether a value\n+     * may be exposed as simple leaf value.\n+     */\n+    protected boolean _mayBeLeaf;\n+\n+    protected JsonToken _nextToken;\n+\n+    protected String _currText;\n+    \n+    /*\n+    /**********************************************************\n+    /* Parsing state, parsed values\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * ByteArrayBuilder is needed if 'getBinaryValue' is called. If so,\n+     * we better reuse it for remainder of content.\n+     */\n+    protected ByteArrayBuilder _byteArrayBuilder = null;\n+\n+    /**\n+     * We will hold on to decoded binary data, for duration of\n+     * current event, so that multiple calls to\n+     * {@link #getBinaryValue} will not need to decode data more\n+     * than once.\n+     */\n+    protected byte[] _binaryValue;\n+\n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+    \n+    public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\n+            ObjectCodec codec, XMLStreamReader xmlReader)\n+    {\n+        super(genericParserFeatures);\n+        _xmlFeatures = xmlFeatures;\n+        _ioContext = ctxt;\n+        _objectCodec = codec;\n+        _parsingContext = JsonReadContext.createRootContext(-1, -1);\n+        // and thereby start a scope\n+        _nextToken = JsonToken.START_OBJECT;\n+        _xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n+    }\n+\n+    @Override\n+    public ObjectCodec getCodec() {\n+        return _objectCodec;\n+    }\n+\n+    @Override\n+    public void setCodec(ObjectCodec c) {\n+        _objectCodec = c;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API, configuration\n+    /**********************************************************\n+     */\n+\n+    public FromXmlParser enable(Feature f) {\n+        _xmlFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    public FromXmlParser disable(Feature f) {\n+        _xmlFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    public final boolean isEnabled(Feature f) {\n+        return (_xmlFeatures & f.getMask()) != 0;\n+    }\n+\n+    public FromXmlParser configure(Feature f, boolean state) {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API, access to some internal components\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that allows application direct access to underlying\n+     * Stax {@link XMLStreamWriter}. Note that use of writer is\n+     * discouraged, and may interfere with processing of this writer;\n+     * however, occasionally it may be necessary.\n+     *<p>\n+     * Note: writer instance will always be of type\n+     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n+     * Typed Access API) so upcasts are safe.\n+     * \n+     * @since 1.7\n+     */\n+    public XMLStreamReader getStaxReader() {\n+        return _xmlTokens.getXmlReader();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonParser impl\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Method that can be called to get the name associated with\n+     * the current event.\n+     */\n+    @Override\n+    public String getCurrentName()\n+        throws IOException, JsonParseException\n+    {\n+        // [JACKSON-395]: start markers require information from parent\n+        if (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\n+            JsonReadContext parent = _parsingContext.getParent();\n+            return parent.getCurrentName();\n+        }\n+        return _parsingContext.getCurrentName();\n+    }\n+\n+    @Override\n+    public void close() throws IOException\n+    {\n+        if (!_closed) {\n+            _closed = true;\n+            try {\n+                if (_ioContext.isResourceManaged() || isEnabled(JsonParser.Feature.AUTO_CLOSE_SOURCE)) {\n+                    _xmlTokens.closeCompletely();\n+                } else {\n+                    _xmlTokens.close();\n+                }\n+            } finally {\n+                // as per [JACKSON-324], do in finally block\n+                // Also, internal buffer(s) can now be released as well\n+                _releaseBuffers();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean isClosed() { return _closed; }\n+\n+    @Override\n+    public JsonReadContext getParsingContext()\n+    {\n+        return _parsingContext;\n+    }\n+\n+    /**\n+     * Method that return the <b>starting</b> location of the current\n+     * token; that is, position of the first character from input\n+     * that starts the current token.\n+     */\n+    @Override\n+    public JsonLocation getTokenLocation()\n+    {\n+        return _xmlTokens.getTokenLocation();\n+    }\n+\n+    /**\n+     * Method that returns location of the last processed character;\n+     * usually for error reporting purposes\n+     */\n+    @Override\n+    public JsonLocation getCurrentLocation()\n+    {\n+        return _xmlTokens.getCurrentLocation();\n+    }\n+\n+    /**\n+     * Since xml representation can not really distinguish between array\n+     * and object starts (both are represented with elements), this method\n+     * is overridden and taken to mean that expecation is that the current\n+     * start element is to mean 'start array', instead of default of\n+     * 'start object'.\n+     */\n+    @Override\n+    public boolean isExpectedStartArrayToken() {\n+        JsonToken t = _currToken;\n+        if (t == JsonToken.START_OBJECT) {\n+            _currToken = JsonToken.START_ARRAY;\n+            // Ok: must replace current context with array as well\n+            _parsingContext = _parsingContext.getParent();\n+            _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n+            // And just in case a field name was to be returned, wipe it\n+            _nextToken = null;\n+            return true;\n+        }\n+        return (t == JsonToken.START_ARRAY);\n+    }\n+    \n+    @Override\n+    public JsonToken nextToken() throws IOException, JsonParseException\n+    {\n+        if (_nextToken != null) {\n+            JsonToken t = _nextToken;\n+            _currToken = t;\n+            _nextToken = null;\n+            switch (t) {\n+            case START_OBJECT:\n+                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                break;\n+            case START_ARRAY:\n+                _parsingContext = _parsingContext.createChildArrayContext(-1, -1);\n+                break;\n+            case END_OBJECT:\n+            case END_ARRAY:\n+                _parsingContext = _parsingContext.getParent();\n+                break;\n+            case FIELD_NAME:\n+                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+                break;\n+            default: // VALUE_STRING, VALUE_NULL\n+                // should be fine as is?\n+            }\n+            return t;\n+        }\n+\n+        int token = _xmlTokens.next();\n+        \n+        /* Need to have a loop just because we may have to eat/convert\n+         * a start-element that indicates an array element.\n+         */\n+        while (token == XmlTokenStream.XML_START_ELEMENT) {\n+\n+            // If we thought we might get leaf, no such luck\n+            if (_mayBeLeaf) {\n+                // leave _mayBeLeaf set, as we start a new context\n+                _nextToken = JsonToken.FIELD_NAME;\n+                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                return (_currToken = JsonToken.START_OBJECT);\n+            }\n+            if (_parsingContext.inArray()) {\n+                /* Yup: in array, so this element could be verified; but it won't be reported\n+                 * anyway, and we need to process following event.\n+                 */\n+                token = _xmlTokens.next();\n+                _mayBeLeaf = true;\n+                continue;\n+            }\n+            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+            _mayBeLeaf = true;\n+            /* Ok: in array context we need to skip reporting field names. But what's the best way\n+             * to find next token?\n+             * \n+             */\n+            return (_currToken = JsonToken.FIELD_NAME);\n+        }\n+\n+        // Ok; beyond start element, what do we get?\n+        switch (token) {\n+        case XmlTokenStream.XML_END_ELEMENT:\n+            // Simple, except that if this is a leaf, need to suppress end:\n+            if (_mayBeLeaf) {\n+                _mayBeLeaf = false;\n+                return (_currToken = JsonToken.VALUE_NULL);\n+            }\n+            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n+            _parsingContext = _parsingContext.getParent();\n+            return _currToken;\n+            \n+        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n+            // If there was a chance of leaf node, no more...\n+            if (_mayBeLeaf) {\n+                _mayBeLeaf = false;\n+                _nextToken = JsonToken.FIELD_NAME;\n+                _currText = _xmlTokens.getText();\n+                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n+                return (_currToken = JsonToken.START_OBJECT);\n+            }\n+            _mayBeLeaf = false;\n+            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n+            return (_currToken = JsonToken.FIELD_NAME);\n+        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n+            _currText = _xmlTokens.getText();\n+            return (_currToken = JsonToken.VALUE_STRING);\n+        case XmlTokenStream.XML_TEXT:\n+            _currText = _xmlTokens.getText();\n+            if (_mayBeLeaf) {\n+                _mayBeLeaf = false;\n+                // Also: must skip following END_ELEMENT\n+                _xmlTokens.skipEndElement();\n+                return (_currToken = JsonToken.VALUE_STRING);\n+            }\n+            // If not a leaf, need to transform into property...\n+            _parsingContext.setCurrentName(UNNAMED_TEXT_PROPERTY);\n+            _nextToken = JsonToken.VALUE_STRING;\n+            return (_currToken = JsonToken.FIELD_NAME);\n+        case XmlTokenStream.XML_END:\n+            return (_currToken = null);\n+        }\n+        // should never get here\n+        _throwInternal();\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, text\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public String getText() throws IOException, JsonParseException\n+    {\n+        switch (_currToken) {\n+        case FIELD_NAME:\n+            return getCurrentName();\n+        case VALUE_STRING:\n+            return _currText;\n+        }\n+        return (_currToken == null) ? null : _currToken.asString();\n+    }\n+\n+    @Override\n+    public char[] getTextCharacters() throws IOException, JsonParseException {\n+        String text = getText();\n+        return (text == null)  ? null : text.toCharArray();\n+    }\n+\n+    @Override\n+    public int getTextLength() throws IOException, JsonParseException {\n+        String text = getText();\n+        return (text == null)  ? 0 : text.length();\n+    }\n+\n+    @Override\n+    public int getTextOffset() throws IOException, JsonParseException {\n+        return 0;\n+    }\n+\n+    /**\n+     * XML input actually would offer access to character arrays; but since\n+     * we must coalesce things it cannot really be exposed.\n+     */\n+    @Override\n+    public boolean hasTextCharacters()\n+    {\n+        return false;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Public API, access to token information, binary\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    public byte[] getBinaryValue(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        if (_currToken != JsonToken.VALUE_STRING &&\n+                (_currToken != JsonToken.VALUE_EMBEDDED_OBJECT || _binaryValue == null)) {\n+            _reportError(\"Current token (\"+_currToken+\") not VALUE_STRING or VALUE_EMBEDDED_OBJECT, can not access as binary\");\n+        }\n+        /* To ensure that we won't see inconsistent data, better clear up\n+         * state...\n+         */\n+        if (_binaryValue == null) {\n+            try {\n+                _binaryValue = _decodeBase64(b64variant);\n+            } catch (IllegalArgumentException iae) {\n+                throw _constructError(\"Failed to decode VALUE_STRING as base64 (\"+b64variant+\"): \"+iae.getMessage());\n+            }\n+        }        \n+        return _binaryValue;\n+    }\n+    \n+    protected byte[] _decodeBase64(Base64Variant b64variant)\n+        throws IOException, JsonParseException\n+    {\n+        ByteArrayBuilder builder = _getByteArrayBuilder();\n+    \n+        final String str = getText();\n+        int ptr = 0;\n+        int len = str.length();\n+\n+        main_loop:\n+        while (ptr < len) {\n+            // first, we'll skip preceding white space, if any\n+            char ch;\n+            do {\n+                ch = str.charAt(ptr++);\n+                if (ptr >= len) {\n+                    break main_loop;\n+                }\n+            } while (ch <= INT_SPACE);\n+            int bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(b64variant, ch, 0, null);\n+            }\n+            int decodedData = bits;\n+            // then second base64 char; can't get padding yet, nor ws\n+            if (ptr >= len) {\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                _reportInvalidBase64(b64variant, ch, 1, null);\n+            }\n+            decodedData = (decodedData << 6) | bits;\n+            // third base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+\n+            // First branch: can get padding (-> 1 byte)\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(b64variant, ch, 2, null);\n+                }\n+                // Ok, must get padding\n+                if (ptr >= len) {\n+                    _reportBase64EOF();\n+                }\n+                ch = str.charAt(ptr++);\n+                if (!b64variant.usesPaddingChar(ch)) {\n+                    _reportInvalidBase64(b64variant, ch, 3, \"expected padding character '\"+b64variant.getPaddingChar()+\"'\");\n+                }\n+                // Got 12 bits, only need 8, need to shift\n+                decodedData >>= 4;\n+                builder.append(decodedData);\n+                continue;\n+            }\n+            // Nope, 2 or 3 bytes\n+            decodedData = (decodedData << 6) | bits;\n+            // fourth and last base64 char; can be padding, but not ws\n+            if (ptr >= len) {\n+                _reportBase64EOF();\n+            }\n+            ch = str.charAt(ptr++);\n+            bits = b64variant.decodeBase64Char(ch);\n+            if (bits < 0) {\n+                if (bits != Base64Variant.BASE64_VALUE_PADDING) {\n+                    _reportInvalidBase64(b64variant, ch, 3, null);\n+                }\n+                decodedData >>= 2;\n+                builder.appendTwoBytes(decodedData);\n+            } else {\n+                // otherwise, our triple is now complete\n+                decodedData = (decodedData << 6) | bits;\n+                builder.appendThreeBytes(decodedData);\n+            }\n+        }\n+        return builder.toByteArray();\n+    }\n+\n+    /**\n+     * @param bindex Relative index within base64 character unit; between 0\n+     *   and 3 (as unit has exactly 4 characters)\n+     */\n+    protected void _reportInvalidBase64(Base64Variant b64variant, char ch, int bindex, String msg)\n+        throws JsonParseException\n+    {\n+        String base;\n+        if (ch <= INT_SPACE) {\n+            base = \"Illegal white space character (code 0x\"+Integer.toHexString(ch)+\") as character #\"+(bindex+1)+\" of 4-char base64 unit: can only used between units\";\n+        } else if (b64variant.usesPaddingChar(ch)) {\n+            base = \"Unexpected padding character ('\"+b64variant.getPaddingChar()+\"') as character #\"+(bindex+1)+\" of 4-char base64 unit: padding only legal as 3rd or 4th character\";\n+        } else if (!Character.isDefined(ch) || Character.isISOControl(ch)) {\n+            // Not sure if we can really get here... ? (most illegal xml chars are caught at lower level)\n+            base = \"Illegal character (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        } else {\n+            base = \"Illegal character '\"+ch+\"' (code 0x\"+Integer.toHexString(ch)+\") in base64 content\";\n+        }\n+        if (msg != null) {\n+            base = base + \": \" + msg;\n+        }\n+        throw new JsonParseException(base, JsonLocation.NA);\n+    }\n+\n+    protected void _reportBase64EOF()\n+        throws JsonParseException\n+    {\n+        throw new JsonParseException(\"Unexpected end-of-String when base64 content\", JsonLocation.NA);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Numeric accessors\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public BigInteger getBigIntegerValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public BigDecimal getDecimalValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public double getDoubleValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public float getFloatValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public int getIntValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public long getLongValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return 0;\n+    }\n+\n+    @Override\n+    public NumberType getNumberType() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    @Override\n+    public Number getNumberValue() throws IOException, JsonParseException\n+    {\n+        // TODO Auto-generated method stub\n+        return null;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Abstract method impls for stuff from JsonParser\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called when an EOF is encountered between tokens.\n+     * If so, it may be a legitimate EOF, but only iff there\n+     * is no open non-root context.\n+     */\n+    @Override\n+    protected void _handleEOF() throws JsonParseException\n+    {\n+        if (!_parsingContext.inRoot()) {\n+            _reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method called to release internal buffers owned by the base\n+     * reader. This may be called along with {@link #_closeInput} (for\n+     * example, when explicitly closing this reader instance), or\n+     * separately (if need be).\n+     */\n+    protected void _releaseBuffers() throws IOException\n+    {\n+        /*\n+        _textBuffer.releaseBuffers();\n+        char[] buf = _nameCopyBuffer;\n+        if (buf != null) {\n+            _nameCopyBuffer = null;\n+            _ioContext.releaseNameCopyBuffer(buf);\n+        }\n+        */\n+    }\n+\n+    protected ByteArrayBuilder _getByteArrayBuilder()\n+    {\n+        if (_byteArrayBuilder == null) {\n+            _byteArrayBuilder = new ByteArrayBuilder();\n+        } else {\n+            _byteArrayBuilder.reset();\n+        }\n+        return _byteArrayBuilder;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/ser/ToXmlGenerator.java\n+package com.fasterxml.jackson.xml.ser;\n+\n+import java.io.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.*;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+import org.codehaus.stax2.XMLStreamWriter2;\n+import org.codehaus.stax2.ri.Stax2WriterAdapter;\n+\n+import org.codehaus.jackson.*;\n+import org.codehaus.jackson.impl.JsonGeneratorBase;\n+import org.codehaus.jackson.impl.JsonWriteContext;\n+import org.codehaus.jackson.io.IOContext;\n+import org.codehaus.jackson.io.SerializedString;\n+\n+import com.fasterxml.jackson.xml.util.DefaultXmlPrettyPrinter;\n+import com.fasterxml.jackson.xml.util.StaxUtil;\n+\n+/**\n+ * {@link JsonGenerator} that outputs JAXB-style XML output instead of JSON content.\n+ * Operation requires calling code (usually either standard Jackson serializers,\n+ * or in some cases (like <code>BeanSerializer</code>) customised ones) to do\n+ * additional configuration calls beyond regular {@link JsonGenerator} API,\n+ * mostly to pass namespace information.\n+ * \n+ * @since 1.6\n+ */\n+public final class ToXmlGenerator\n+    extends JsonGeneratorBase\n+{\n+    /**\n+     * If we support optional definition of element names, this is the element\n+     * name to use...\n+     */\n+    protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n+    \n+    /**\n+     * Enumeration that defines all togglable extra XML-specific features\n+     */\n+    public enum Feature {\n+        /**\n+         * Feature that controls whether XML declaration should be written before\n+         * when generator is initialized (true) or not (false)\n+         */\n+        WRITE_XML_DECLARATION(false),\n+\n+        /**\n+         * Feature that controls whether output should be done as XML 1.1; if so,\n+         * certain aspects may differ from default (1.0) processing: for example,\n+         * XML declaration will be automatically added (regardless of setting\n+         * <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n+         * know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n+         * control characters (Ascii codes 0 through 31) as well as additional linefeeds\n+         * and name characters.\n+         */\n+        WRITE_XML_1_1(false)\n+        ;\n+\n+        final boolean _defaultState;\n+        final int _mask;\n+        \n+        /**\n+         * Method that calculates bit set (flags) of all features that\n+         * are enabled by default.\n+         */\n+        public static int collectDefaults()\n+        {\n+            int flags = 0;\n+            for (Feature f : values()) {\n+                if (f.enabledByDefault()) {\n+                    flags |= f.getMask();\n+                }\n+            }\n+            return flags;\n+        }\n+        \n+        private Feature(boolean defaultState) {\n+            _defaultState = defaultState;\n+            _mask = (1 << ordinal());\n+        }\n+        \n+        public boolean enabledByDefault() { return _defaultState; }\n+        public int getMask() { return _mask; }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Configuration\n+    /**********************************************************\n+     */\n+\n+    final protected XMLStreamWriter2 _xmlWriter;\n+    \n+    final protected IOContext _ioContext;\n+\n+    /**\n+     * Bit flag composed of bits that indicate which\n+     * {@link org.codehaus.jackson.smile.SmileGenerator.Feature}s\n+     * are enabled.\n+     */\n+    protected int _xmlFeatures;\n+\n+    /*\n+    /**********************************************************\n+    /* XML Output state\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Element or attribute name to use for next output call.\n+     * Assigned by either code that initiates serialization\n+     * or bean serializer.\n+     */\n+    protected QName _nextName = null;\n+\n+    /**\n+     * Marker flag that indicates whether next name to write\n+     * implies an attribute (true) or element (false)\n+     */\n+    protected boolean _nextIsAttribute = false;\n+    \n+    /**\n+     * To support proper serialization of arrays it is necessary to keep\n+     * stack of element names, so that we can \"revert\" to earlier \n+     */\n+    protected LinkedList<QName> _elementNameStack = new LinkedList<QName>();\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle\n+    /**********************************************************\n+     */\n+\n+    public ToXmlGenerator(IOContext ctxt, int genericGeneratorFeatures, int xmlFeatures,\n+            ObjectCodec codec, XMLStreamWriter sw)\n+    {\n+        super(genericGeneratorFeatures, codec);\n+        _xmlFeatures = xmlFeatures;\n+        _ioContext = ctxt;\n+        _xmlWriter = Stax2WriterAdapter.wrapIfNecessary(sw);\n+    }\n+\n+    /**\n+     * Method called before writing any other output, to optionally\n+     * output XML declaration.\n+     */\n+    public void initGenerator()  throws IOException, JsonGenerationException\n+    {\n+        try {\n+            if ((_xmlFeatures & Feature.WRITE_XML_1_1.getMask()) != 0) {\n+                _xmlWriter.writeStartDocument(\"UTF-8\", \"1.1\");\n+            } else if ((_xmlFeatures & Feature.WRITE_XML_DECLARATION.getMask()) != 0) {\n+                _xmlWriter.writeStartDocument(\"UTF-8\", \"1.0\");\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API, configuration\n+    /**********************************************************\n+     */\n+\n+    public ToXmlGenerator enable(Feature f) {\n+        _xmlFeatures |= f.getMask();\n+        return this;\n+    }\n+\n+    public ToXmlGenerator disable(Feature f) {\n+        _xmlFeatures &= ~f.getMask();\n+        return this;\n+    }\n+\n+    public final boolean isEnabled(Feature f) {\n+        return (_xmlFeatures & f.getMask()) != 0;\n+    }\n+\n+    public ToXmlGenerator configure(Feature f, boolean state) {\n+        if (state) {\n+            enable(f);\n+        } else {\n+            disable(f);\n+        }\n+        return this;\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Extended API, access to some internal components\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that allows application direct access to underlying\n+     * Stax {@link XMLStreamWriter}. Note that use of writer is\n+     * discouraged, and may interfere with processing of this writer;\n+     * however, occasionally it may be necessary.\n+     *<p>\n+     * Note: writer instance will always be of type\n+     * {@link org.codehaus.stax2.XMLStreamWriter2} (including\n+     * Typed Access API) so upcasts are safe.\n+     * \n+     * @since 1.7\n+     */\n+    public XMLStreamWriter getStaxWriter() {\n+        return _xmlWriter;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Extended API, passing XML specific settings\n+    /**********************************************************\n+     */\n+\n+    public void setNextIsAttribute(boolean isAttribute)\n+    {\n+        _nextIsAttribute = isAttribute;\n+    }\n+\n+    public final void setNextName(QName name)\n+    {\n+        _nextName = name;\n+    }\n+\n+    /**\n+     * Methdod called when a structured (collection, array, map) is being\n+     * output.\n+     * \n+     * @param wrapperName Element used as wrapper around elements, if any (null if none)\n+     * @param wrappedName Element used around individual content items (can not\n+     *   be null)\n+     */\n+    public void startWrappedValue(QName wrapperName, QName wrappedName) throws IOException, JsonGenerationException\n+    {\n+        if (wrapperName != null) {\n+            try {\n+                _xmlWriter.writeStartElement(wrapperName.getNamespaceURI(), wrapperName.getLocalPart());\n+            } catch (XMLStreamException e) {\n+                StaxUtil.throwXmlAsIOException(e);\n+            }\n+        }\n+        this.setNextName(wrappedName);\n+    }\n+\n+    /**\n+     * Method called after a structured collection output has completed\n+     */\n+    public void finishWrappedValue(QName wrapperName, QName wrappedName) throws IOException, JsonGenerationException\n+    {\n+        // First: wrapper to close?\n+        if (wrapperName != null) {\n+            try {\n+                _xmlWriter.writeEndElement();\n+            } catch (XMLStreamException e) {\n+                StaxUtil.throwXmlAsIOException(e);\n+            }\n+        }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* JsonGenerator method overrides\n+    /**********************************************************\n+     */\n+    \n+    /* Most overrides in this section are just to make methods final,\n+     * to allow better inlining...\n+     */\n+\n+    @Override\n+    public final void writeFieldName(String name)  throws IOException, JsonGenerationException\n+    {\n+        if (_writeContext.writeFieldName(name) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n+            _reportError(\"Can not write a field name, expecting a value\");\n+        }\n+        // Should this ever get called?\n+        String ns = (_nextName == null) ? \"\" : _nextName.getNamespaceURI();\n+        setNextName(new QName(ns, name));\n+    }\n+    \n+    @Override\n+    public final void writeStringField(String fieldName, String value)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(fieldName);\n+        writeString(value);\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* JsonGenerator output method implementations, structural\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void writeStartArray() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"start an array\");\n+        _writeContext = _writeContext.createChildArrayContext();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeStartArray(this);\n+        } else {\n+            // nothing to do here; no-operation\n+        }\n+    }\n+    \n+    @Override\n+    public final void writeEndArray() throws IOException, JsonGenerationException\n+    {\n+        if (!_writeContext.inArray()) {\n+            _reportError(\"Current context not an ARRAY but \"+_writeContext.getTypeDesc());\n+        }\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeEndArray(this, _writeContext.getEntryCount());\n+        } else {\n+            // nothing to do here; no-operation\n+        }\n+        _writeContext = _writeContext.getParent();\n+    }\n+\n+    @Override\n+    public final void writeStartObject() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"start an object\");\n+        _writeContext = _writeContext.createChildObjectContext();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeStartObject(this);\n+        } else {\n+            _handleStartObject();\n+        }\n+    }\n+\n+    @Override\n+    public final void writeEndObject() throws IOException, JsonGenerationException\n+    {\n+        if (!_writeContext.inObject()) {\n+            _reportError(\"Current context not an object but \"+_writeContext.getTypeDesc());\n+        }\n+        _writeContext = _writeContext.getParent();\n+        if (_cfgPrettyPrinter != null) {\n+            _cfgPrettyPrinter.writeEndObject(this, _writeContext.getEntryCount());\n+        } else {\n+            _handleEndObject();\n+        }\n+    }\n+\n+    // note: public just because pretty printer needs to make a callback\n+    public final void _handleStartObject() throws IOException, JsonGenerationException\n+    {\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        // Need to keep track of names to make Lists work correctly\n+        _elementNameStack.addLast(_nextName);\n+        try {\n+            _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+    \n+    // note: public just because pretty printer needs to make a callback\n+    public final void _handleEndObject() throws IOException, JsonGenerationException\n+    {\n+        // We may want to repeat same element, so:\n+        _nextName = _elementNameStack.removeLast();\n+        try {\n+            // note: since attributes don't nest, can only have one attribute active, so:\n+            _nextIsAttribute = false;\n+            _xmlWriter.writeEndElement();\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, textual\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeFieldName(SerializedString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(name.getValue());\n+    }\n+\n+    @Override\n+    public void writeFieldName(SerializableString name)\n+        throws IOException, JsonGenerationException\n+    {\n+        writeFieldName(name.getValue());\n+    }\n+    \n+    @Override\n+    public void writeString(String text) throws IOException,JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write String value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) { // must write attribute name and value with one call\n+                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeCharacters(text);\n+                _xmlWriter.writeEndElement();\n+            } \n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }    \n+    \n+    @Override\n+    public void writeString(char[] text, int offset, int len) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write String value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeCharacters(text, offset, len);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeString(SerializableString text) throws IOException, JsonGenerationException {\n+        writeString(text.getValue());\n+    }\n+    \n+    @Override\n+    public void writeRawUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        // could add support for this case if we really want it (and can make Stax2 support it)\n+        _reportUnsupportedOperation();\n+    }\n+\n+    @Override\n+    public void writeUTF8String(byte[] text, int offset, int length)\n+        throws IOException, JsonGenerationException\n+    {\n+        // could add support for this case if we really want it (and can make Stax2 support it)\n+        _reportUnsupportedOperation();\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Output method implementations, unprocessed (\"raw\")\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeRaw(String text) throws IOException, JsonGenerationException\n+    {\n+        try {\n+            _xmlWriter.writeRaw(text);\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(String text, int offset, int len) throws IOException, JsonGenerationException\n+    {\n+        try {\n+            _xmlWriter.writeRaw(text, offset, len);\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(char[] text, int offset, int len) throws IOException, JsonGenerationException\n+    {\n+        try {\n+            _xmlWriter.writeRaw(text, offset, len);\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeRaw(char c) throws IOException, JsonGenerationException\n+    {\n+        writeRaw(String.valueOf(c));\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, base64-encoded binary\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeBinary(Base64Variant b64variant, byte[] data, int offset, int len) throws IOException, JsonGenerationException\n+    {\n+        if (data == null) {\n+            writeNull();\n+            return;\n+        }\n+        _verifyValueWrite(\"write Binary value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                // Stax2 API only has 'full buffer' write method:\n+                byte[] fullBuffer = toFullBuffer(data, offset, len);\n+                _xmlWriter.writeBinaryAttribute(\"\", _nextName.getNamespaceURI(), _nextName.getLocalPart(), fullBuffer);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeBinary(data, offset, len);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    private byte[] toFullBuffer(byte[] data, int offset, int len)\n+    {\n+        // might already be ok:\n+        if (offset == 0 && len == data.length) {\n+            return data;\n+        }\n+        byte[] result = new byte[len];\n+        if (len > 0) {\n+            System.arraycopy(data, offset, result, 0, len);\n+        }\n+        return result;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Output method implementations, primitive\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public void writeBoolean(boolean state) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write boolean value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeBooleanAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), state);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeBoolean(state);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNull() throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write null value\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        // !!! TODO: proper use of 'xsd:isNil'\n+        try {\n+            if (_nextIsAttribute) {\n+                /* With attributes, best just leave it out, right? (since there's no way\n+                 * to use 'xsi:nil')\n+                 */\n+            } else {\n+                _xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(int i) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeIntAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), i);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeInt(i);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(long l) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeLongAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), l);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeLong(l);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(double d) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeDoubleAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), d);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeDouble(d);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(float f) throws IOException, JsonGenerationException\n+    {\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeFloatAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), f);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeFloat(f);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(BigDecimal dec) throws IOException, JsonGenerationException\n+    {\n+        if (dec == null) {\n+            writeNull();\n+            return;\n+        }\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeDecimalAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), dec);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeDecimal(dec);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(BigInteger v) throws IOException, JsonGenerationException\n+    {\n+        if (v == null) {\n+            writeNull();\n+            return;\n+        }\n+        _verifyValueWrite(\"write number\");\n+        if (_nextName == null) {\n+            handleMissingName();\n+        }\n+        try {\n+            if (_nextIsAttribute) {\n+                _xmlWriter.writeIntegerAttribute(null, _nextName.getNamespaceURI(), _nextName.getLocalPart(), v);\n+            } else {\n+                _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n+                _xmlWriter.writeInteger(v);\n+                _xmlWriter.writeEndElement();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void writeNumber(String encodedValue) throws IOException,JsonGenerationException, UnsupportedOperationException\n+    {\n+        writeString(encodedValue);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Implementations, overrides for other methods\n+    /**********************************************************\n+     */\n+    \n+    @Override\n+    protected final void _verifyValueWrite(String typeMsg)\n+        throws IOException, JsonGenerationException\n+    {\n+        int status = _writeContext.writeValue();\n+        if (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n+            _reportError(\"Can not \"+typeMsg+\", expecting field name\");\n+        }\n+    }\n+\n+    /**\n+     * Standard JSON indenter does not work well with XML, use\n+     * default XML indenter instead.\n+     */\n+    @Override\n+    public final JsonGenerator useDefaultPrettyPrinter()\n+    {\n+        return setPrettyPrinter(new DefaultXmlPrettyPrinter());\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Low-level output handling\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    public final void flush() throws IOException\n+    {\n+        if (isEnabled(JsonGenerator.Feature.FLUSH_PASSED_TO_STREAM)) {\n+            try {\n+                _xmlWriter.flush();\n+            } catch (XMLStreamException e) {\n+                StaxUtil.throwXmlAsIOException(e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void close()\n+        throws IOException\n+    {\n+//        boolean wasClosed = _closed;\n+        super.close();\n+\n+        /* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n+         *   scopes.\n+         */\n+        // First: let's see that we still have buffers...\n+        if (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)) {\n+            try {\n+                while (true) {\n+                    JsonStreamContext ctxt = getOutputContext();\n+                    if (ctxt.inArray()) {\n+                        writeEndArray();\n+                    } else if (ctxt.inObject()) {\n+                        writeEndObject();\n+                    } else {\n+                        break;\n+                    }\n+                }\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                /* 29-Nov-2010, tatu: Stupid, stupid SJSXP doesn't do array checks, so we get\n+                 *   hit by this as a collateral problem in some cases. Yuck.\n+                 */\n+                throw new JsonGenerationException(e);\n+            }\n+        }\n+        try {\n+            if (_ioContext.isResourceManaged() || isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)) {\n+                _xmlWriter.closeCompletely();\n+            } else {\n+                _xmlWriter.close();\n+            }\n+        } catch (XMLStreamException e) {\n+            StaxUtil.throwXmlAsIOException(e);\n+        }\n+    }\n+\n+    @Override\n+    protected void _releaseBuffers() {\n+        // Nothing to do here, as we have no buffers\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Internal methods\n+    /**********************************************************\n+     */\n+\n+    protected void handleMissingName()\n+    {\n+        throw new IllegalStateException(\"No element/attribute name specified when trying to output element\");\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/ser/XmlBeanPropertyWriter.java\n+package com.fasterxml.jackson.xml.ser;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.map.JsonSerializer;\n+import org.codehaus.jackson.map.SerializerProvider;\n+import org.codehaus.jackson.map.ser.BeanPropertyWriter;\n+import org.codehaus.jackson.map.ser.impl.PropertySerializerMap;\n+\n+\n+/**\n+ * Property writer sub-class used for handling element wrapping needed for serializing\n+ * collection (array, Collection; possibly Map) types.\n+ * \n+ * @since 1.7\n+ */\n+public class XmlBeanPropertyWriter\n+    extends BeanPropertyWriter\n+{\n+    /*\n+    /**********************************************************\n+    /* Config settings\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Element name used as wrapper for collection.\n+     */\n+    protected final QName _wrapperName;\n+\n+    /**\n+     * Element name used for items in the collection\n+     */\n+    protected final QName _wrappedName;\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: construction, configuration\n+    /**********************************************************\n+     */\n+\n+    public XmlBeanPropertyWriter(BeanPropertyWriter wrapped, QName wrapperName, QName wrappedName)\n+    {\n+        super(wrapped);\n+        _wrapperName = wrapperName;\n+        _wrappedName = wrappedName;\n+    }\n+\n+    public XmlBeanPropertyWriter(BeanPropertyWriter wrapped, QName wrapperName, QName wrappedName,\n+            JsonSerializer<Object> serializer)\n+    {\n+        super(wrapped, serializer);\n+        _wrapperName = wrapperName;\n+        _wrappedName = wrappedName;\n+    }\n+    \n+    @Override\n+    public BeanPropertyWriter withSerializer(JsonSerializer<Object> ser)\n+    {\n+        // sanity check to ensure sub-classes override...\n+        if (getClass() != XmlBeanPropertyWriter.class) {\n+            throw new IllegalStateException(\"Sub-class does not override 'withSerializer()'; needs to!\");\n+        }\n+        return new XmlBeanPropertyWriter(this, _wrapperName, _wrappedName, ser);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Overridden version so that we can wrap output within wrapper element if\n+     * and as necessary.\n+     */\n+    @Override\n+    public void serializeAsField(Object bean, JsonGenerator jgen, SerializerProvider prov)\n+        throws Exception\n+    {\n+        Object value = get(bean);\n+        /* Hmmh. Does the default null serialization work ok here? For now let's assume\n+         * it does; can change later if not.\n+         */\n+        if (value == null) {\n+            if (!_suppressNulls) {\n+                jgen.writeFieldName(_name);\n+                prov.defaultSerializeNull(jgen);\n+            }\n+            return;\n+        }\n+        // For non-nulls, first: simple check for direct cycles\n+        if (value == bean) {\n+            _reportSelfReference(bean);\n+        }\n+        if (_suppressableValue != null && _suppressableValue.equals(value)) {\n+            return;\n+        }\n+\n+        // Ok then; addition we want to do is to add wrapper element, and that's what happens here\n+        ToXmlGenerator xmlGen = (ToXmlGenerator) jgen;\n+        xmlGen.startWrappedValue(_wrapperName, _wrappedName);\n+        \n+        JsonSerializer<Object> ser = _serializer;\n+        if (ser == null) {\n+            Class<?> cls = value.getClass();\n+            PropertySerializerMap map = _dynamicSerializers;\n+            ser = map.serializerFor(cls);\n+            if (ser == null) {\n+                ser = _findAndAddDynamic(map, cls, prov);\n+            }\n+        }\n+        jgen.writeFieldName(_name);\n+        if (_typeSerializer == null) {\n+            ser.serialize(value, jgen, prov);\n+        } else {\n+            ser.serializeWithType(value, jgen, prov, _typeSerializer);\n+        }\n+\n+        xmlGen.finishWrappedValue(_wrapperName, _wrappedName);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/ser/XmlBeanSerializer.java\n+package com.fasterxml.jackson.xml.ser;\n+\n+import java.io.IOException;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.JsonGenerationException;\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.map.JsonMappingException;\n+import org.codehaus.jackson.map.SerializerProvider;\n+import org.codehaus.jackson.map.ser.BeanPropertyWriter;\n+import org.codehaus.jackson.map.ser.BeanSerializer;\n+\n+\n+/**\n+ * Specific sub-class of {@link BeanSerializer} needed to take care\n+ * of some xml-specific aspects, such as distinction between attributes\n+ * and elements.\n+ */\n+public class XmlBeanSerializer extends BeanSerializer\n+{\n+    /**\n+     * Number of attributes to write; these will have been ordered to be the first\n+     * properties to write.\n+     */\n+    protected final int _attributeCount;\n+\n+    /**\n+     * Array that contains namespace URIs associated with properties, if any;\n+     * null if no namespace definitions have been assigned\n+     */\n+    protected final QName[] _xmlNames;\n+    \n+    public XmlBeanSerializer(Class<?> type, BeanPropertyWriter[] props,\n+            BeanPropertyWriter[] filteredProps, Object filterId,\n+            int attrCount, QName[] xmlNames)\n+    {\n+        super(type, props, filteredProps, filterId);\n+        _attributeCount = attrCount;\n+        _xmlNames = xmlNames;\n+    }\n+\n+    protected XmlBeanSerializer(XmlBeanSerializer src, BeanPropertyWriter[] filtered)\n+    {\n+        super(src, filtered);\n+        _attributeCount = src._attributeCount;\n+        _xmlNames = src._xmlNames;\n+    }\n+    \n+    @Override\n+    public BeanSerializer withFiltered(BeanPropertyWriter[] filtered)\n+    {\n+        if (filtered == _filteredProps) {\n+            return this;\n+        }\n+        return new XmlBeanSerializer(this, filtered);\n+    }\n+\n+    /**\n+     * Main serialization method needs to be overridden to allow XML-specific\n+     * extra handling, such as indication of whether to write attributes or\n+     * elements.\n+     */\n+    @Override\n+    protected void serializeFields(Object bean, JsonGenerator jgen0, SerializerProvider provider)\n+        throws IOException, JsonGenerationException\n+    {\n+        final ToXmlGenerator jgen = (ToXmlGenerator) jgen0;\n+        final BeanPropertyWriter[] props;\n+        if (_filteredProps != null && provider.getSerializationView() != null) {\n+            props = _filteredProps;\n+        } else {\n+            props = _props;\n+        }\n+    \n+        final int attrCount = _attributeCount;\n+        if (attrCount > 0) {\n+            jgen.setNextIsAttribute(true);\n+        }\n+        final QName[] xmlNames = _xmlNames;\n+        \n+        int i = 0;\n+        try {\n+            for (final int len = props.length; i < len; ++i) {\n+                if (i == attrCount) {\n+                    jgen.setNextIsAttribute(false);\n+                }\n+                jgen.setNextName(xmlNames[i]);\n+                BeanPropertyWriter prop = props[i];\n+                if (prop != null) { // can have nulls in filtered list\n+                    prop.serializeAsField(bean, jgen, provider);\n+                }\n+            }\n+            if (_anyGetterWriter != null) {\n+                _anyGetterWriter.getAndSerialize(bean, jgen, provider);\n+            }\n+        } catch (Exception e) {\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            wrapAndThrow(provider, e, bean, name);\n+        } catch (StackOverflowError e) {\n+            /* 04-Sep-2009, tatu: Dealing with this is tricky, since we do not\n+             *   have many stack frames to spare... just one or two; can't\n+             *   make many calls.\n+             */\n+            JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n+            String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n+            mapE.prependPath(new JsonMappingException.Reference(bean, name));\n+            throw mapE;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/ser/XmlBeanSerializerFactory.java\n+package com.fasterxml.jackson.xml.ser;\n+\n+import java.util.*;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.map.AnnotationIntrospector;\n+import org.codehaus.jackson.map.SerializationConfig;\n+import org.codehaus.jackson.map.SerializerFactory;\n+import org.codehaus.jackson.map.introspect.AnnotatedMember;\n+import org.codehaus.jackson.map.introspect.BasicBeanDescription;\n+import org.codehaus.jackson.map.ser.BeanPropertyWriter;\n+import org.codehaus.jackson.map.ser.BeanSerializer;\n+import org.codehaus.jackson.map.ser.BeanSerializerFactory;\n+import org.codehaus.jackson.map.ser.PropertyBuilder;\n+import org.codehaus.jackson.map.type.TypeBindings;\n+\n+import com.fasterxml.jackson.xml.XmlAnnotationIntrospector;\n+\n+/**\n+ * Specialized version of {@link BeanSerializerFactory} which is used to\n+ * add specific overrides to handle XML-specific details such as\n+ * difference between attributes and elements.\n+ * \n+ * @since 1.7\n+ */\n+public class XmlBeanSerializerFactory extends BeanSerializerFactory\n+{\n+    /**\n+     * Marker used for storing associated internal data with {@link BeanPropertyWriter}\n+     * instances; to mark instances that are to be written out as attributes.\n+     * Created as separate non-interned String to ensure there are no collisions.\n+     */\n+    protected final static String KEY_XML_INFO = new String(\"xmlInfo\");\n+    \n+    /*\n+    /**********************************************************\n+    /* Life-cycle: creation, configuration\n+    /**********************************************************\n+     */\n+    \n+    public XmlBeanSerializerFactory(Config config)\n+    {\n+        super(config);\n+    }\n+\n+    @Override\n+    public SerializerFactory withConfig(Config config)\n+    {\n+        // Same as super-class, we require all sub-classes to override this method:\n+        if (getClass() != XmlBeanSerializerFactory.class) {\n+            throw new IllegalStateException(\"Subtype of XmlBeanSerializerFactory (\"+getClass().getName()\n+                    +\") has not properly overridden method 'withAdditionalSerializers': can not instantiate subtype with \"\n+                    +\"additional serializer definitions\");\n+        }\n+        return new XmlBeanSerializerFactory(config);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Overridden methods from standard bean serializer factory\n+    /**********************************************************\n+     */\n+\n+    @Override\n+    protected BeanSerializer instantiateBeanSerializer(SerializationConfig config,\n+            BasicBeanDescription beanDesc,\n+            List<BeanPropertyWriter> properties)\n+    {\n+        BeanPropertyWriter[] writers = properties.toArray(new BeanPropertyWriter[properties.size()]);\n+        // Ok: how many attributes do we have to write? namespaces?\n+        QName[] xmlNames = new QName[properties.size()];\n+        int attrCount = 0;\n+        int i = 0;\n+        for (BeanPropertyWriter bpw : properties) {\n+            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+            String ns = null;\n+            if (info != null) {\n+                if (info.isAttribute()) {\n+                    ++attrCount;\n+                }\n+                ns = info.getNamespace();\n+            }\n+            xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n+            ++i;\n+        }\n+        return new XmlBeanSerializer(beanDesc.getBeanClass(), writers, null,\n+                findFilterId(config, beanDesc),\n+                attrCount, xmlNames);\n+    }\n+\n+    /**\n+     * Need to override to sort properties so that we will always start with attributes (if any),\n+     * followed by elements.\n+     */\n+    @Override\n+    protected List<BeanPropertyWriter> sortBeanProperties(SerializationConfig config, BasicBeanDescription beanDesc,\n+            List<BeanPropertyWriter> props)\n+    {\n+        props = super.sortBeanProperties(config, beanDesc, props);\n+        // Ok: let's first see if we any attributes; if not, just return lists as is:\n+        for (BeanPropertyWriter bpw : props) {\n+            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n+                props = _orderAttributesFirst(props);\n+                break;\n+            }\n+        }\n+        return props;\n+    }\n+    \n+    /**\n+     * Need to override this specific method so that we can inject XML-specific information\n+     * into bean writer, so that it can be retrieved later on\n+     */\n+    @Override\n+    protected BeanPropertyWriter _constructWriter(SerializationConfig config, TypeBindings typeContext,\n+            PropertyBuilder pb, boolean staticTyping, String name, AnnotatedMember propertyMember)\n+    {\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        String ns = findNamespaceAnnotation(intr, propertyMember);\n+        Boolean isAttribute = findIsAttributeAnnotation(intr, propertyMember);\n+\n+        BeanPropertyWriter propertyWriter = super._constructWriter(config, typeContext, pb, staticTyping, name, propertyMember);\n+        propertyWriter.setInternalSetting(KEY_XML_INFO, new XmlInfo(isAttribute, ns));\n+\n+        // Actually: if we have a Collection type, easiest place to add wrapping would be here...\n+        Class<?> type = propertyMember.getRawType();\n+        if (_isContainerType(type)) {\n+            String localName = null, wrapperNs = null;\n+\n+            QName wrappedName = new QName(ns, propertyWriter.getName());\n+            QName wrapperName = findWrapperName(intr, propertyMember);\n+            if (wrapperName != null) {\n+                localName = wrapperName.getLocalPart();\n+                wrapperNs = wrapperName.getNamespaceURI();\n+            }\n+            /* Empty/missing localName means \"use property name as wrapper\"; later on\n+             * should probably make missing (null) mean \"don't add a wrapper\"\n+             */\n+            if (localName == null || localName.length() == 0) {\n+                wrapperName = wrappedName;\n+            } else {\n+                wrapperName = new QName((wrapperNs == null) ? \"\" : wrapperNs, localName);\n+            }\n+            return new XmlBeanPropertyWriter(propertyWriter, wrapperName, wrappedName);\n+        }\n+        \n+        return propertyWriter;\n+    }\n+    /*\n+    /**********************************************************\n+    /* Internal helper methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper method used for figuring out if given raw type is a collection (\"indexed\") type;\n+     * in which case a wrapper element is typically added.\n+     */\n+    private boolean _isContainerType(Class<?> rawType)\n+    {\n+        if (rawType.isArray()) {\n+            // Just one special case; byte[] will be serialized as base64-encoded String, not real array, so:\n+            if (rawType == byte[].class) {\n+                return false;\n+            }\n+            return true;\n+        }\n+        return Map.class.isAssignableFrom(rawType) || Collection.class.isAssignableFrom(rawType);\n+    }\n+    \n+    private String findNamespaceAnnotation(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                String ns = ((XmlAnnotationIntrospector) intr).findNamespace(prop);\n+                if (ns != null) {\n+                    return ns;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private Boolean findIsAttributeAnnotation(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                Boolean b = ((XmlAnnotationIntrospector) intr).isOutputAsAttribute(prop);\n+                if (b != null) {\n+                    return b;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private QName findWrapperName(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                QName n = ((XmlAnnotationIntrospector) intr).findWrapperElement(prop);\n+                if (n != null) {\n+                    return n;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /**\n+     * Method for re-sorting lists of bean properties such that attributes are strictly\n+     * written before elements.\n+     */\n+    private List<BeanPropertyWriter> _orderAttributesFirst(List<BeanPropertyWriter> props)\n+    {\n+        List<BeanPropertyWriter> attrs = new ArrayList<BeanPropertyWriter>();\n+        List<BeanPropertyWriter> elems = new ArrayList<BeanPropertyWriter>();\n+        for (BeanPropertyWriter bpw : props) {\n+            if (_isAttribute(bpw)) {\n+                attrs.add(bpw);\n+            } else {\n+                elems.add(bpw);\n+            }\n+        }\n+        if (elems.size() > 0) {\n+            attrs.addAll(elems);\n+        }\n+        return attrs;\n+    }    \n+\n+    private boolean _isAttribute(BeanPropertyWriter bpw)\n+    {\n+        XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+        return (info != null) && info.isAttribute();\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Internal helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Helper container class used to contain xml specific information\n+     * we need to retain to construct proper bean serializer\n+     */\n+    protected final static class XmlInfo\n+    {\n+        protected final String _namespace;\n+        protected final boolean _isAttribute;\n+        \n+        public XmlInfo(Boolean isAttribute, String ns)\n+        {\n+            _isAttribute = (isAttribute == null) ? false : isAttribute.booleanValue();\n+            _namespace = (ns == null) ? \"\" : ns;\n+        }\n+\n+        public String getNamespace() { return _namespace; }\n+        public boolean isAttribute() { return _isAttribute; }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/ser/XmlSerializerProvider.java\n+package com.fasterxml.jackson.xml.ser;\n+\n+import java.io.IOException;\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.JsonGenerator;\n+import org.codehaus.jackson.JsonProcessingException;\n+import org.codehaus.jackson.map.SerializationConfig;\n+import org.codehaus.jackson.map.SerializerFactory;\n+import org.codehaus.jackson.map.ser.StdSerializerProvider;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.xml.util.XmlRootNameLookup;\n+\n+/**\n+ * We need to override some parts of {@link org.codehaus.jackson.map.SerializerProvider}\n+ * implementation to handle oddities of XML output, like \"extra\" root element.\n+ * \n+ * @since 1.7\n+ */\n+public class XmlSerializerProvider extends StdSerializerProvider\n+{\n+    /**\n+     * If all we get to serialize is a null, there's no way to figure out\n+     * expected root name; so let's just default to something like \"<null>\"...\n+     */\n+    protected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n+    \n+    protected final XmlRootNameLookup _rootNameLookup;\n+    \n+    public XmlSerializerProvider(XmlRootNameLookup rootNames)\n+    {\n+        super();\n+        _rootNameLookup = rootNames;\n+    }\n+\n+    public XmlSerializerProvider(SerializationConfig config, XmlSerializerProvider src,\n+            SerializerFactory f)\n+    {\n+        super(config, src, f);\n+        _rootNameLookup  = src._rootNameLookup;\n+    }\n+    \n+    /*\n+    /**********************************************************************\n+    /* Overridden methods\n+    /**********************************************************************\n+     */\n+\n+    @Override\n+    protected StdSerializerProvider createInstance(SerializationConfig config, SerializerFactory jsf)\n+    {\n+        return new XmlSerializerProvider(config, this, jsf);\n+    }\n+    \n+    @Override\n+    protected  void _serializeValue(JsonGenerator jgen, Object value)\n+        throws IOException, JsonProcessingException\n+    {\n+        QName rootName = (value == null) ? ROOT_NAME_FOR_NULL\n+                : _rootNameLookup.findRootName(value.getClass(), _config);\n+        ToXmlGenerator xgen = (ToXmlGenerator) jgen;\n+        xgen.setNextName(rootName);\n+        xgen.initGenerator();\n+        super._serializeValue(jgen, value);\n+    }\n+\n+    @Override\n+    protected  void _serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n+        throws IOException, JsonProcessingException\n+    {\n+        QName rootName = _rootNameLookup.findRootName(rootType, _config);\n+        ToXmlGenerator xgen = (ToXmlGenerator) jgen;\n+        xgen.setNextName(rootName);\n+        xgen.initGenerator();\n+        super._serializeValue(jgen, value, rootType);\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/xml/util/DefaultXmlPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/xml/util/DefaultXmlPrettyPrinter.java\n import org.codehaus.jackson.JsonGenerator;\n import org.codehaus.jackson.PrettyPrinter;\n \n-import com.fasterxml.jackson.xml.ToXmlGenerator;\n+import com.fasterxml.jackson.xml.ser.ToXmlGenerator;\n \n /**\n  * Indentation to use with XML is different from JSON, because JSON\n--- a/src/test/java/com/fasterxml/jackson/xml/TestXmlDeclaration.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestXmlDeclaration.java\n package com.fasterxml.jackson.xml;\n \n-import com.fasterxml.jackson.xml.ToXmlGenerator;\n import com.fasterxml.jackson.xml.XmlMapper;\n+import com.fasterxml.jackson.xml.ser.ToXmlGenerator;\n \n public class TestXmlDeclaration extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestXmlGenerator.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestXmlGenerator.java\n \n import javax.xml.namespace.QName;\n \n-import com.fasterxml.jackson.xml.ToXmlGenerator;\n import com.fasterxml.jackson.xml.XmlFactory;\n+import com.fasterxml.jackson.xml.ser.ToXmlGenerator;\n \n public class TestXmlGenerator extends XmlTestBase\n {\n--- a/src/test/java/com/fasterxml/jackson/xml/TestXmlParser.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestXmlParser.java\n import org.codehaus.jackson.*;\n import org.codehaus.jackson.map.ObjectMapper;\n \n-import com.fasterxml.jackson.xml.FromXmlParser;\n import com.fasterxml.jackson.xml.XmlFactory;\n import com.fasterxml.jackson.xml.XmlMapper;\n+import com.fasterxml.jackson.xml.deser.FromXmlParser;\n \n public class TestXmlParser extends XmlTestBase\n {", "timestamp": 1293938692, "metainfo": ""}