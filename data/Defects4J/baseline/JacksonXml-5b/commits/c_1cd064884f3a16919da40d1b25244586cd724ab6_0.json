{"sha": "1cd064884f3a16919da40d1b25244586cd724ab6", "log": "Implement format auto-detection for XML as well.  There is minor issue of what to do with 1.8 dependency; will have to figure it out soon.", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/xml/XmlFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/xml/XmlFactory.java\n import org.codehaus.stax2.io.Stax2ByteArraySource;\n \n import org.codehaus.jackson.*;\n+import org.codehaus.jackson.format.InputAccessor;\n+import org.codehaus.jackson.format.MatchStrength;\n import org.codehaus.jackson.io.IOContext;\n \n import com.fasterxml.jackson.xml.deser.FromXmlParser;\n public class XmlFactory extends JsonFactory\n {\n     /**\n+     * Name used to identify JSON format\n+     * (and returned by {@link #getFormatName()}\n+     */\n+    public final static String FORMAT_NAME_XML = \"XML\";\n+\n+    /**\n      * Bitfield (set of flags) of all parser features that are enabled\n      * by default.\n      */\n     public void setXMLOutputFactory(XMLOutputFactory f) {\n         _xmlOutputFactory = f;\n     }\n+\n+    /*\n+    /**********************************************************\n+    /* Format detection functionality (since 1.8)\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * Method that returns short textual id identifying format\n+     * this factory supports.\n+     *<p>\n+     * Note: sub-classes should override this method; default\n+     * implementation will return null for all sub-classes\n+     * \n+     * @since 1.8\n+     */\n+    public String getFormatName()\n+    {\n+        return FORMAT_NAME_XML;\n+    }\n+\n+    public MatchStrength hasFormat(InputAccessor acc) throws IOException\n+    {\n+        return hasXMLFormat(acc);\n+    }\n     \n     /*\n     /**********************************************************\n     }\n \n     /*\n-    /**********************************************************\n-    /* Internal methods\n-    /**********************************************************\n+    /**********************************************************************\n+    /* Internal factory methods\n+    /**********************************************************************\n      */\n \n     protected XMLStreamWriter _createXmlWriter(OutputStream out) throws IOException\n         return sr;\n     }\n \n+    /*\n+    /**********************************************************************\n+    /* Internal methods, format auto-detection\n+    /**********************************************************************\n+     */\n+\n+    private final static byte UTF8_BOM_1 = (byte) 0xEF;\n+    private final static byte UTF8_BOM_2 = (byte) 0xBB;\n+    private final static byte UTF8_BOM_3 = (byte) 0xBF;\n+\n+    private final static byte BYTE_x = (byte) 'x';\n+    private final static byte BYTE_m = (byte) 'm';\n+    private final static byte BYTE_l = (byte) 'l';\n+    private final static byte BYTE_D = (byte) 'D';\n+\n+    private final static byte BYTE_LT = (byte) '<';\n+    private final static byte BYTE_QMARK = (byte) '?';\n+    private final static byte BYTE_EXCL = (byte) '!';\n+    private final static byte BYTE_HYPHEN = (byte) '-';\n+    \n+    /**\n+     * Method that tries to figure out if content seems to be in some kind\n+     * of XML format.\n+     * Note that implementation here is not nearly as robust as what underlying\n+     * Stax parser will do; the idea is to first support common encodings,\n+     * then expand as needed (for example, it is not all that hard to support\n+     * UTF-16; but it is some work and not needed quite yet)\n+     */\n+    public static MatchStrength hasXMLFormat(InputAccessor acc) throws IOException\n+    {\n+        /* Basically we just need to find \"<!\", \"<?\" or \"<NAME\"... but ideally\n+         * we would actually see the XML declaration\n+         */\n+        if (!acc.hasMoreBytes()) {\n+            return MatchStrength.INCONCLUSIVE;\n+        }\n+        byte b = acc.nextByte();\n+        // Very first thing, a UTF-8 BOM? (later improvements: other BOM's, heuristics)\n+        if (b == UTF8_BOM_1) { // yes, looks like UTF-8 BOM\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            if (acc.nextByte() != UTF8_BOM_2) {\n+                return MatchStrength.NO_MATCH;\n+            }\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            if (acc.nextByte() != UTF8_BOM_3) {\n+                return MatchStrength.NO_MATCH;\n+            }\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            b = acc.nextByte();\n+        }\n+        // otherwise: XML declaration?\n+        boolean maybeXmlDecl = (b == BYTE_LT);\n+        if (!maybeXmlDecl) {\n+            int ch = skipSpace(acc, b);\n+            if (ch < 0) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            b = (byte) ch;\n+            // If we did not get an LT, shouldn't be valid XML (minus encoding issues etc)\n+            if (b != BYTE_LT) {\n+                return MatchStrength.NO_MATCH;\n+            }\n+        }\n+        if (!acc.hasMoreBytes()) {\n+            return MatchStrength.INCONCLUSIVE;\n+        }\n+        b = acc.nextByte();\n+        // Couple of choices here\n+        if (b == BYTE_QMARK) { // <?\n+            b = acc.nextByte();\n+            if (b == BYTE_x) {\n+                if (maybeXmlDecl) {\n+                    if (acc.hasMoreBytes() && acc.nextByte() == BYTE_m) {\n+                        if (acc.hasMoreBytes() && acc.nextByte() == BYTE_l) {\n+                            return MatchStrength.FULL_MATCH;\n+                        }\n+                    }\n+                }\n+                // but even with just partial match, we ought to be fine\n+                return MatchStrength.SOLID_MATCH;\n+            }\n+            // Ok to start with some other char too; just not xml declaration\n+            if (validXmlNameStartChar(acc, b)) {\n+                return MatchStrength.SOLID_MATCH;\n+            }\n+        } else if (b == BYTE_EXCL) {\n+            /* must be <!-- comment --> or <!DOCTYPE ...>, since\n+             * <![CDATA[ ]]> can NOT come outside of root\n+             */\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            b = acc.nextByte();\n+            if (b == BYTE_HYPHEN) {\n+                if (!acc.hasMoreBytes()) {\n+                    return MatchStrength.INCONCLUSIVE;\n+                }\n+                if (acc.nextByte() == BYTE_HYPHEN) {\n+                    return MatchStrength.SOLID_MATCH;\n+                }\n+            } else if (b == BYTE_D) {\n+                return tryMatch(acc, \"OCTYPE\", MatchStrength.SOLID_MATCH);\n+            }\n+        } else {\n+            // maybe root element? Just needs to match first char.\n+            if (validXmlNameStartChar(acc, b)) {\n+                return MatchStrength.SOLID_MATCH;\n+            }\n+        }\n+        return MatchStrength.NO_MATCH;\n+    }\n+\n+    private final static boolean validXmlNameStartChar(InputAccessor acc, byte b)\n+        throws IOException\n+    {\n+        /* Can make it actual real XML check in future; for now we do just crude\n+         * check for ASCII range\n+         */\n+        int ch = (int) b & 0xFF;\n+        if (ch >= 'A') { // in theory, colon could be; in practice it should never be valid (wrt namespace)\n+            // This is where we'd check for multi-byte UTF-8 chars (or whatever encoding is in use)...\n+            return true;\n+        }\n+        return false;\n+    }\n+    \n+    private final static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\n+        throws IOException\n+    {\n+        for (int i = 0, len = matchStr.length(); i < len; ++i) {\n+            if (!acc.hasMoreBytes()) {\n+                return MatchStrength.INCONCLUSIVE;\n+            }\n+            if (acc.nextByte() != matchStr.charAt(i)) {\n+                return MatchStrength.NO_MATCH;\n+            }\n+        }\n+        return fullMatchStrength;\n+    }\n+    \n+    private final static int skipSpace(InputAccessor acc, byte b) throws IOException\n+    {\n+        while (true) {\n+            int ch = (int) b & 0xFF;\n+            if (!(ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t')) {\n+                return ch;\n+            }\n+            if (!acc.hasMoreBytes()) {\n+                return -1;\n+            }\n+            b = acc.nextByte();\n+            ch = (int) b & 0xFF;\n+        }\n+    }\n+\n }\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestXMLFormatDetection.java\n+package com.fasterxml.jackson.xml;\n+\n+import java.io.ByteArrayInputStream;\n+\n+import org.codehaus.jackson.*;\n+import org.codehaus.jackson.format.DataFormatDetector;\n+import org.codehaus.jackson.format.DataFormatMatcher;\n+import org.codehaus.jackson.format.MatchStrength;\n+\n+public class TestXMLFormatDetection extends XmlTestBase\n+{\n+    public void testSimpleValidXmlDecl() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"<?xml version='1.0'?><root/>\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.FULL_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleValidRoot() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"<root/>\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleValidDoctype() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"<!DOCTYPE root [ ]>   <root />\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+    \n+    public void testSimpleValidComment() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"  <!-- comment -->  <root></root>\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+\n+    public void testSimpleValidPI() throws Exception\n+    {\n+        XmlFactory f = new XmlFactory();\n+        DataFormatDetector detector = new DataFormatDetector(f);\n+        String XML = \"<?target foo?><root />\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(XML.getBytes(\"UTF-8\")));\n+        assertTrue(matcher.hasMatch());\n+        assertEquals(\"XML\", matcher.getMatchedFormatName());\n+        assertSame(f, matcher.getMatch());\n+        assertEquals(MatchStrength.SOLID_MATCH, matcher.getMatchStrength());\n+        // ensure we could build a parser...\n+        JsonParser jp = matcher.createParserWithMatch();\n+        assertToken(JsonToken.START_OBJECT, jp.nextToken());\n+        jp.close();\n+    }\n+    \n+    public void testSimpleInvalid() throws Exception\n+    {\n+        DataFormatDetector detector = new DataFormatDetector(new XmlFactory());\n+        final String NON_XML = \"{\\\"foo\\\":\\\"bar\\\"}\";\n+        DataFormatMatcher matcher = detector.findFormat(new ByteArrayInputStream(NON_XML.getBytes(\"UTF-8\")));\n+        // should not have match\n+        assertFalse(matcher.hasMatch());\n+        // and thus:\n+        assertEquals(MatchStrength.INCONCLUSIVE, matcher.getMatchStrength());\n+        // also:\n+        assertNull(matcher.createParserWithMatch());\n+    }\n+\n+}", "timestamp": 1298078332, "metainfo": ""}