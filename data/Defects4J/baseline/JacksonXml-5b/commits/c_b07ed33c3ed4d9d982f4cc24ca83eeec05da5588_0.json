{"sha": "b07ed33c3ed4d9d982f4cc24ca83eeec05da5588", "log": "Merge pull request #98 from pgelinas/master  Added unit test for issue #97.", "commit": "\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/unwrapped/TestIssue97.java\n+/*\n+ * Copyright (c) 2002-2014 Nu Echo Inc. All rights reserved.\n+ */\n+\n+package com.fasterxml.jackson.dataformat.xml.unwrapped;\n+\n+import static org.junit.Assert.*;\n+import static org.hamcrest.CoreMatchers.*;\n+\n+import java.util.*;\n+\n+import org.junit.*;\n+import org.junit.runner.*;\n+import org.junit.runners.*;\n+\n+import com.fasterxml.jackson.annotation.*;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo.*;\n+import com.fasterxml.jackson.dataformat.xml.*;\n+import com.fasterxml.jackson.dataformat.xml.annotation.*;\n+\n+/**\n+ * @author Nu Echo Inc.\n+ */\n+@RunWith(JUnit4.class)\n+public class TestIssue97 {\n+\n+    @Test\n+    public void testGood() throws Exception {\n+        XmlMapper mapper = new XmlMapper();\n+        mapper.registerSubtypes(FooGood.class);\n+\n+        String xml = \"<Foo type=\\\"good\\\" data=\\\"dummy\\\"><bar>FOOBAR</bar></Foo>\";\n+        Foo fooRead = mapper.readValue(xml, Foo.class);\n+        assertThat(fooRead, instanceOf(FooGood.class));\n+\n+        xml = \"<Foo data=\\\"dummy\\\" type=\\\"good\\\" ><bar>FOOBAR</bar></Foo>\";\n+        fooRead = mapper.readValue(xml, Foo.class);\n+        assertThat(fooRead, instanceOf(FooGood.class));\n+    }\n+    \n+    @Test\n+    public void testBad() throws Exception {\n+        XmlMapper mapper = new XmlMapper();\n+        mapper.registerSubtypes(FooBad.class);\n+\n+        String xml = \"<Foo type=\\\"bad\\\" data=\\\"dummy\\\"><bar><bar>FOOBAR</bar></bar></Foo>\";\n+        Foo fooRead = mapper.readValue(xml, Foo.class);\n+        assertThat(fooRead, instanceOf(FooBad.class));\n+\n+        // BOOM\n+        xml = \"<Foo data=\\\"dummy\\\" type=\\\"bad\\\"><bar><bar>FOOBAR</bar></bar></Foo>\";\n+        fooRead = mapper.readValue(xml, Foo.class);\n+        assertThat(fooRead, instanceOf(FooBad.class));\n+    }\n+\n+    @JsonTypeInfo(property = \"type\", use = Id.NAME)\n+    public static abstract class Foo {\n+        private String mData;\n+\n+        public void setData(String data) {\n+            mData = data;\n+        }\n+\n+        @JacksonXmlProperty(isAttribute = true)\n+        public String getData() {\n+            return mData;\n+        }\n+    }\n+\n+    @JsonTypeName(\"good\")\n+    public static class FooGood extends Foo {\n+        private String mBar;\n+\n+        public String getBar() {\n+            return mBar;\n+        }\n+\n+        public void setBar(String bar) {\n+            mBar = bar;\n+        }\n+    }\n+\n+    @JsonTypeName(\"bad\")\n+    public static class FooBad extends Foo {\n+        private List<String> mBar;\n+\n+        @JacksonXmlElementWrapper(useWrapping = false)\n+        public List<String> getBar() {\n+            return mBar;\n+        }\n+\n+        public void setBar(List<String> bar) {\n+            mBar = bar;\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanPropertyWriter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanPropertyWriter.java\n         throws Exception\n     {\n         Object value = get(bean);\n-        \n-        /* Hmmh. Does the default null serialization work ok here? For now let's assume\n-         * it does; can change later if not.\n+\n+        /* 13-Feb-2014, tatu: As per [#103], default handling does not really\n+         *   work here. Rather, we need just a wrapping and should NOT call\n+         *   null handler, as it does not know what to do...\n+         *   \n+         *   Question, however, is what should it be serialized as. We have two main\n+         *   choices; equivalent empty List, and \"nothing\" (missing). Let's start with\n+         *   empty List? But producing missing entry is non-trivial...\n          */\n         if (value == null) {\n-            if (_nullSerializer != null) {\n-                jgen.writeFieldName(_name);\n-                _nullSerializer.serialize(null, jgen, prov);\n+            // if (_nullSerializer != null) { ... }\n+\n+            // For Empty List, we'd do this:\n+            /*\n+            @SuppressWarnings(\"resource\")\n+            final ToXmlGenerator xmlGen = (jgen instanceof ToXmlGenerator) ? (ToXmlGenerator) jgen : null;\n+            if (xmlGen != null) {\n+                xmlGen.startWrappedValue(_wrapperQName, _wrappedQName);\n+                xmlGen.finishWrappedValue(_wrapperQName, _wrappedQName);\n             }\n+            */\n+            // but for missing thing, well, just output nothing\n+            \n             return;\n         }\n-        \n+\n         // then find serializer to use\n         JsonSerializer<Object> ser = _serializer;\n         if (ser == null) {\n         }\n         // For non-nulls: simple check for direct cycles\n         if (value == bean) {\n-            _handleSelfReference(bean, ser);\n+            // NOTE: method signature here change 2.3->2.4\n+            if (_handleSelfReference(bean, jgen, prov, ser)) {\n+                return;\n+            }\n         }\n \n+        @SuppressWarnings(\"resource\")\n+        final ToXmlGenerator xmlGen = (jgen instanceof ToXmlGenerator) ? (ToXmlGenerator) jgen : null;\n         // Ok then; addition we want to do is to add wrapper element, and that's what happens here\n         // 19-Aug-2013, tatu: ... except for those nasty 'convertValue()' calls...\n-        @SuppressWarnings(\"resource\")\n-        final ToXmlGenerator xmlGen = (jgen instanceof ToXmlGenerator) ? (ToXmlGenerator) jgen : null;\n         if (xmlGen != null) {\n             xmlGen.startWrappedValue(_wrapperQName, _wrappedQName);\n         }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup.java\n         return this;\n     }\n \n-    public QName findRootName(JavaType rootType, MapperConfig<?> config)\n-    {\n+    public QName findRootName(JavaType rootType, MapperConfig<?> config) {\n         return findRootName(rootType.getRawClass(), config);\n     }\n \n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/TestIssue104.java\n+package com.fasterxml.jackson.dataformat.xml;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.fasterxml.jackson.annotation.JsonIdentityInfo;\n+import com.fasterxml.jackson.annotation.ObjectIdGenerators;\n+\n+/**\n+ * Unit test to showcase issue #104, based on TestObjectIdDeserialization unit test in databind package.\n+ *\n+ */\n+public class TestIssue104 extends XmlTestBase {\n+    // // Classes for external id from property annotations:\n+    \n+    static class IdWrapper\n+    {\n+        @JsonIdentityInfo(generator=ObjectIdGenerators.IntSequenceGenerator.class, property=\"id\")\n+        public ValueNode node;\n+\n+        public IdWrapper() { }\n+        public IdWrapper(int v) {\n+            node = new ValueNode(v);\n+        }\n+    }\n+\n+    static class ValueNode {\n+        public List<Integer> value= new ArrayList<Integer>();\n+        public IdWrapper next;\n+        \n+        public ValueNode() { this(0); }\n+        public ValueNode(int v) { value.add(v); }\n+    }\n+    \n+    private final XmlMapper MAPPER = new XmlMapper();\n+    \n+    // Another test to ensure ordering is not required (i.e. can do front references)\n+    public void testSimpleCollectionDeserWithForwardRefs() throws Exception\n+    {\n+        IdWrapper result = MAPPER.readValue(\"<IdWrapper><node><value><value>7</value></value><next><node>1</node></next><id>1</id></node></IdWrapper>\"\n+                ,IdWrapper.class);\n+        assertEquals(7, (int)result.node.value.get(0));\n+        assertSame(result.node, result.node.next.node);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/XmlTestBase.java\n public abstract class XmlTestBase\n     extends TestCase\n {\n-    /*\n-    /**********************************************************\n-    /* Helper types\n-    /**********************************************************\n-     */\n-\n     /**\n      * Sample class from Jackson tutorial (\"JacksonInFiveMinutes\")\n      */\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/AttributeFailIssue108Test.java\n+package com.fasterxml.jackson.dataformat.xml.failing;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.dataformat.xml.*;\n+import com.fasterxml.jackson.dataformat.xml.annotation.*;\n+\n+public class AttributeFailIssue108Test extends XmlTestBase\n+{\n+    static class Foo {\n+        @JacksonXmlElementWrapper(useWrapping = false)\n+        public List<Bar> firstBar = new ArrayList<Bar>();\n+        @JacksonXmlElementWrapper(useWrapping = false)\n+        public List<Bar> secondBar = new ArrayList<Bar>();\n+    }\n+\n+    static class Bar {\n+        public String value;\n+\n+        @JacksonXmlProperty(isAttribute = true)\n+        public int id;\n+    }\n+\n+    public void testIdsFromAttributes() throws Exception {\n+        XmlMapper xmlMapper = new XmlMapper();\n+        Foo foo = new Foo();\n+        Bar bar1 = new Bar();\n+        bar1.id = 1;\n+        bar1.value = \"FIRST\";\n+        foo.firstBar.add(bar1);\n+        Bar bar2 = new Bar();\n+        bar2.value = \"SECOND\";\n+        bar2.id = 2;\n+        foo.secondBar.add(bar2);\n+        String string = xmlMapper.writeValueAsString(foo);\n+        Foo fooRead = xmlMapper.readValue(string, Foo.class);\n+        assertEquals(foo.secondBar.get(0).id, fooRead.secondBar.get(0).id);\n+    }\n+}\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/TestUnwrappedLists.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/TestUnwrappedLists.java\n \n import java.util.*;\n \n+import com.fasterxml.jackson.annotation.JsonPropertyOrder;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n import com.fasterxml.jackson.dataformat.xml.annotation.*;\n         @JacksonXmlElementWrapper(useWrapping = false)\n         public List<Optional> optional;\n     } \n-    \n+\n+    // For [Issue#101]\n+    @JacksonXmlRootElement(localName = \"root\")    \n+    @JsonPropertyOrder({ \"unwrapped\", \"name\" })\n+    static class Root {\n+        @JacksonXmlProperty(localName = \"unwrapped\")\n+        @JacksonXmlElementWrapper(useWrapping = false)\n+        public List<UnwrappedElement> unwrapped;\n+\n+        public String name;\n+    }\n+\n+     static class UnwrappedElement {\n+        public UnwrappedElement () {}\n+\n+        public UnwrappedElement (String id, String type) {\n+            this.id = id;\n+            this.type = type;\n+        }\n+\n+        @JacksonXmlProperty(isAttribute = true)\n+        public String id;\n+\n+        @JacksonXmlProperty(isAttribute = true)\n+        public String type;\n+    }\n+\n     /*\n     /**********************************************************\n     /* Unit tests\n         assertEquals(\"123-456-7890\", opt.number);\n         assertEquals(\"NOT SET\", opt.type);\n     }\n-}\n+\n+    // [Issue#101]\n+    public void testWithTwoAttributes() throws Exception\n+    {\n+        final String EXP = \"<root>\"\n+                +\"<unwrapped id=\\\"1\\\" type=\\\"string\\\"/>\"\n+                +\"<unwrapped id=\\\"2\\\" type=\\\"string\\\"/>\"\n+                +\"<name>test</name>\"\n+                +\"</root>\";\n+        Root rootOb = new Root();\n+        rootOb.unwrapped = Arrays.asList(\n+                new UnwrappedElement(\"1\", \"string\"),\n+                new UnwrappedElement(\"2\", \"string\")\n+        );\n+        rootOb.name = \"test\";\n+\n+        // First, serialize, which works\n+        String xml = MAPPER.writeValueAsString(rootOb);\n+        assertEquals(EXP, xml);\n+\n+        // then try deserialize\n+        Root result = MAPPER.readValue(xml, Root.class);\n+        assertNotNull(result);\n+        assertEquals(rootOb.name, result.name);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/lists/TestWrappedLists.java\n+package com.fasterxml.jackson.dataformat.xml.lists;\n+\n+import java.util.*;\n+\n+import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n+\n+public class TestWrappedLists extends XmlTestBase\n+{\n+    static class Order  {\n+        @JacksonXmlElementWrapper(localName = \"line_items\")\n+        @JacksonXmlProperty(localName = \"item\")  \n+        private List<ListItem> line_items; // new ArrayList<ListItem>();\n+    }\n+\n+    static class ListItem {\n+        public int id;\n+        \n+        public ListItem(int id) { this.id = id; }\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Unit tests\n+    /**********************************************************\n+     */\n+\n+    private final XmlMapper MAPPER = xmlMapper(true);\n+\n+    /* For [Issue#103]\n+     */\n+    public void testEmptyList() throws Exception\n+    {\n+        String xml = MAPPER.writeValueAsString(new Order());\n+        assertEquals(\"<Order/>\", xml);\n+        // If we expected Empty list, it'd be:\n+//        assertEquals(\"<Order><line_items/></Order>\", xml);\n+    }\n+}", "timestamp": 1395429913, "metainfo": ""}