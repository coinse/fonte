{"sha": "6e8939a2a8b5ed8ac5a40a130d2e79fff9d38abe", "log": "Completed rewrite that now uses module interface for 90% of functionality (yay!) and once again works.", "commit": "\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/JacksonXmlModule.java\n+package com.fasterxml.jackson.xml;\n+\n+import java.util.*;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.Version;\n+import org.codehaus.jackson.map.AnnotationIntrospector;\n+import org.codehaus.jackson.map.JsonSerializer;\n+import org.codehaus.jackson.map.SerializationConfig;\n+import org.codehaus.jackson.map.introspect.AnnotatedMember;\n+import org.codehaus.jackson.map.introspect.BasicBeanDescription;\n+import org.codehaus.jackson.map.module.SimpleModule;\n+import org.codehaus.jackson.map.ser.BeanPropertyWriter;\n+import org.codehaus.jackson.map.ser.BeanSerializer;\n+import org.codehaus.jackson.map.ser.BeanSerializerModifier;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.xml.ser.XmlBeanPropertyWriter;\n+import com.fasterxml.jackson.xml.ser.XmlBeanSerializer;\n+import com.fasterxml.jackson.xml.util.XmlInfo;\n+\n+/**\n+ * Module that implements most functionality needed to support producing and\n+ * consuming XML instead of JSON.\n+ */\n+public class JacksonXmlModule extends SimpleModule\n+{\n+    private final static AnnotationIntrospector XML_ANNOTATION_INTROSPECTOR = new JacksonXmlAnnotationIntrospector();\n+\n+    // !!! TODO: how to externalize version?\n+    private final static Version VERSION = new Version(0, 1, 0, null);\n+    \n+    public JacksonXmlModule()\n+    {\n+        super(\"JackxonXmlModule\", VERSION);\n+    }\n+    \n+    @Override\n+    public void setupModule(SetupContext context)\n+    {\n+        context.addBeanSerializerModifier(new MySerializerModifier());\n+        context.insertAnnotationIntrospector(XML_ANNOTATION_INTROSPECTOR);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method used for figuring out if given raw type is a collection (\"indexed\") type;\n+     * in which case a wrapper element is typically added.\n+     */\n+    private static boolean _isContainerType(JavaType type)\n+    {\n+        if (type.isContainerType()) {\n+            // Just one special case; byte[] will be serialized as base64-encoded String, not real array, so:\n+            if (type.getRawClass() == byte[].class) {\n+                return false;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private static String findNamespaceAnnotation(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                String ns = ((XmlAnnotationIntrospector) intr).findNamespace(prop);\n+                if (ns != null) {\n+                    return ns;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static Boolean findIsAttributeAnnotation(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                Boolean b = ((XmlAnnotationIntrospector) intr).isOutputAsAttribute(prop);\n+                if (b != null) {\n+                    return b;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static QName findWrapperName(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                QName n = ((XmlAnnotationIntrospector) intr).findWrapperElement(prop);\n+                if (n != null) {\n+                    return n;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+    /*\n+    /**********************************************************\n+    /* Helper classes\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * We need a {@link SerializerModifier} to replace default <code>BeanSerializer</code>\n+     * with XML-specific one.\n+     */\n+    protected static class MySerializerModifier extends BeanSerializerModifier\n+    {\n+        /**\n+         * First thing to do is to find annotations regarding XML serialization,\n+         * and wrap collection serializers.\n+         */\n+        public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\n+                BasicBeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n+        {\n+            AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+            for (int i = 0, len = beanProperties.size(); i < len; ++i) {\n+                BeanPropertyWriter bpw = beanProperties.get(i);\n+                final AnnotatedMember member = bpw.getMember();\n+                String ns = findNamespaceAnnotation(intr, member);\n+                Boolean isAttribute = findIsAttributeAnnotation(intr, member);\n+                bpw.setInternalSetting(XmlBeanSerializer.KEY_XML_INFO, new XmlInfo(isAttribute, ns));\n+\n+                // Actually: if we have a Collection type, easiest place to add wrapping would be here...\n+                if (_isContainerType(bpw.getType())) {\n+                    String localName = null, wrapperNs = null;\n+\n+                    QName wrappedName = new QName(ns, bpw.getName());\n+                    QName wrapperName = findWrapperName(intr, member);\n+                    if (wrapperName != null) {\n+                        localName = wrapperName.getLocalPart();\n+                        wrapperNs = wrapperName.getNamespaceURI();\n+                    }\n+                    /* Empty/missing localName means \"use property name as wrapper\"; later on\n+                     * should probably make missing (null) mean \"don't add a wrapper\"\n+                     */\n+                    if (localName == null || localName.length() == 0) {\n+                        wrapperName = wrappedName;\n+                    } else {\n+                        wrapperName = new QName((wrapperNs == null) ? \"\" : wrapperNs, localName);\n+                    }\n+                    beanProperties.set(i, new XmlBeanPropertyWriter(bpw, wrapperName, wrappedName));\n+                }\n+            }\n+            return beanProperties;\n+        }\n+        \n+        public JsonSerializer<?> modifySerializer(SerializationConfig config,\n+                BasicBeanDescription beanDesc, JsonSerializer<?> serializer)\n+        {\n+            /* First things first: we can only handle real BeanSerializers; question\n+             * is, what to do if it's not one: throw exception or bail out?\n+             * For now let's do latter.\n+             */\n+            if (!(serializer instanceof BeanSerializer)) {\n+                return serializer;\n+            }\n+            return new XmlBeanSerializer((BeanSerializer) serializer);\n+        }\n+    }\n+}\n--- a/src/main/java/com/fasterxml/jackson/xml/XmlMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/xml/XmlMapper.java\n \n import com.fasterxml.jackson.xml.deser.FromXmlParser;\n import com.fasterxml.jackson.xml.ser.ToXmlGenerator;\n-import com.fasterxml.jackson.xml.ser.XmlBeanSerializerFactory;\n import com.fasterxml.jackson.xml.ser.XmlSerializerProvider;\n import com.fasterxml.jackson.xml.util.XmlRootNameLookup;\n \n  */\n public class XmlMapper extends ObjectMapper\n {\n-    private final static AnnotationIntrospector XML_ANNOTATION_INTROSPECTOR = new JacksonXmlAnnotationIntrospector();\n-    \n     /*\n     /**********************************************************\n     /* Life-cycle: construction, configuration\n          * deserializer provider fine as is\n          */\n         super(xmlFactory, new XmlSerializerProvider(new XmlRootNameLookup()), null);\n-        \n-        // Bean serializers are somewhat customized as well:\n-        _serializerFactory = new XmlBeanSerializerFactory(null);\n-        // as is introspector\n-        _deserializationConfig.setAnnotationIntrospector(XML_ANNOTATION_INTROSPECTOR);\n-        _serializationConfig.setAnnotationIntrospector(XML_ANNOTATION_INTROSPECTOR);\n+        // but all the rest is done via Module interface!\n+        this.registerModule(new JacksonXmlModule());\n     }\n \n     /**\n--- a/src/main/java/com/fasterxml/jackson/xml/ser/XmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/xml/ser/XmlBeanSerializer.java\n import org.codehaus.jackson.JsonGenerator;\n import org.codehaus.jackson.map.JsonMappingException;\n import org.codehaus.jackson.map.SerializerProvider;\n-import org.codehaus.jackson.map.ser.AnyGetterWriter;\n import org.codehaus.jackson.map.ser.BeanPropertyWriter;\n import org.codehaus.jackson.map.ser.BeanSerializer;\n-import org.codehaus.jackson.type.JavaType;\n \n+import com.fasterxml.jackson.xml.util.XmlInfo;\n \n /**\n  * Specific sub-class of {@link BeanSerializer} needed to take care\n  */\n public class XmlBeanSerializer extends BeanSerializer\n {\n+    /**\n+     * Marker used for storing associated internal data with {@link BeanPropertyWriter}\n+     * instances; to mark instances that are to be written out as attributes.\n+     * Created as separate non-interned String to ensure there are no collisions.\n+     */\n+    public final static String KEY_XML_INFO = new String(\"xmlInfo\");\n+\n     /**\n      * Number of attributes to write; these will have been ordered to be the first\n      * properties to write.\n      * null if no namespace definitions have been assigned\n      */\n     protected final QName[] _xmlNames;\n+\n+    public XmlBeanSerializer(BeanSerializer src)\n+    {\n+        super(src);\n+\n+        // Ok, first: collect namespace information\n+        _xmlNames = new QName[_props.length];\n+        // First, find namespace information\n+        for (int i = 0, len = _props.length; i < len; ++i) {\n+            BeanPropertyWriter bpw = _props[i];\n+            XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+            String ns = null;\n+            if (info != null) {\n+                ns = info.getNamespace();\n+            }\n+            _xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n+        }      \n+        \n+        /* Then make sure attributes are sorted before elements, keep track\n+         * of how many there are altogether\n+         */\n+        int attrCount = 0;\n+        for (BeanPropertyWriter bpw : _props) {\n+            if (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\n+                attrCount = _orderAttributesFirst(_props, _filteredProps);\n+                break;\n+            }\n+        }\n+        _attributeCount = attrCount;\n+    }\n     \n-    public XmlBeanSerializer(JavaType type, BeanPropertyWriter[] props, BeanPropertyWriter[] filteredProps,\n-            AnyGetterWriter anyGetterWriter, Object filterId,\n-            int attrCount, QName[] xmlNames)\n-    {\n-        super(type, props, filteredProps, anyGetterWriter, filterId);\n-        _attributeCount = attrCount;\n-        _xmlNames = xmlNames;\n-    }\n-\n     protected XmlBeanSerializer(XmlBeanSerializer src, BeanPropertyWriter[] filtered)\n     {\n         super(src._handledType, src._props, filtered, src._anyGetterWriter, src._propertyFilterId);\n         } catch (Exception e) {\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             wrapAndThrow(provider, e, bean, name);\n-        } catch (StackOverflowError e) {\n-            /* 04-Sep-2009, tatu: Dealing with this is tricky, since we do not\n-             *   have many stack frames to spare... just one or two; can't\n-             *   make many calls.\n-             */\n+        } catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:\n             JsonMappingException mapE = new JsonMappingException(\"Infinite recursion (StackOverflowError)\");\n             String name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\n             mapE.prependPath(new JsonMappingException.Reference(bean, name));\n         }\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+\n+    protected static boolean _isAttribute(BeanPropertyWriter bpw)\n+    {\n+        XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+        return (info != null) && info.isAttribute();\n+    }\n+\n+    /**\n+     * Method for re-sorting lists of bean properties such that attributes are strictly\n+     * written before elements.\n+     */\n+    protected static int _orderAttributesFirst(BeanPropertyWriter[] properties,\n+            BeanPropertyWriter[] filteredProperties)\n+    {\n+        int attrCount = 0;\n+\n+        for (int i = 0, len = properties.length; i < len; ++i) {\n+            BeanPropertyWriter bpw = properties[i];\n+            \n+            if (!_isAttribute(bpw)) {\n+                continue;\n+            }\n+            // Swap if attribute and there are preceding elements:\n+            if (attrCount < i) {\n+                properties[i] = properties[attrCount];\n+                properties[attrCount] = bpw;\n+                if (filteredProperties != null) {\n+                    BeanPropertyWriter fbpw = filteredProperties[i];\n+                    filteredProperties[i] = filteredProperties[attrCount];\n+                    filteredProperties[attrCount] = fbpw;\n+                }\n+            }\n+            ++attrCount;\n+        }\n+        return attrCount;\n+    }\n+    \n }\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/util/XmlInfo.java\n+package com.fasterxml.jackson.xml.util;\n+\n+/**\n+ * Helper container class used to contain XML specific information\n+ * we need to retain to construct proper bean serializer\n+ */\n+public class XmlInfo\n+{\n+    protected final String _namespace;\n+    protected final boolean _isAttribute;\n+    \n+    public XmlInfo(Boolean isAttribute, String ns)\n+    {\n+        _isAttribute = (isAttribute == null) ? false : isAttribute.booleanValue();\n+        _namespace = (ns == null) ? \"\" : ns;\n+    }\n+\n+    public String getNamespace() { return _namespace; }\n+    public boolean isAttribute() { return _isAttribute; }\n+}", "timestamp": 1294472243, "metainfo": ""}