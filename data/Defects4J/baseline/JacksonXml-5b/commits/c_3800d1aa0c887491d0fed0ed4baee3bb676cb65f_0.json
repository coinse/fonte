{"sha": "3800d1aa0c887491d0fed0ed4baee3bb676cb65f", "log": "Improve serialization a bit by making type id an attribute", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/xml/JacksonXmlModule.java\n+++ b/src/main/java/com/fasterxml/jackson/xml/JacksonXmlModule.java\n package com.fasterxml.jackson.xml;\n-\n-import java.util.*;\n-\n-import javax.xml.namespace.QName;\n \n import org.codehaus.jackson.Version;\n import org.codehaus.jackson.map.AnnotationIntrospector;\n-import org.codehaus.jackson.map.JsonSerializer;\n-import org.codehaus.jackson.map.SerializationConfig;\n-import org.codehaus.jackson.map.introspect.AnnotatedMember;\n-import org.codehaus.jackson.map.introspect.BasicBeanDescription;\n import org.codehaus.jackson.map.module.SimpleModule;\n-import org.codehaus.jackson.map.ser.BeanPropertyWriter;\n-import org.codehaus.jackson.map.ser.BeanSerializer;\n-import org.codehaus.jackson.map.ser.BeanSerializerModifier;\n-import org.codehaus.jackson.type.JavaType;\n \n-import com.fasterxml.jackson.xml.ser.XmlBeanPropertyWriter;\n-import com.fasterxml.jackson.xml.ser.XmlBeanSerializer;\n-import com.fasterxml.jackson.xml.util.XmlInfo;\n+import com.fasterxml.jackson.xml.ser.XmlBeanSerializerModifier;\n \n /**\n  * Module that implements most functionality needed to support producing and\n     @Override\n     public void setupModule(SetupContext context)\n     {\n-        context.addBeanSerializerModifier(new MySerializerModifier());\n+        // Need to modify BeanSerializer that is used\n+        context.addBeanSerializerModifier(new XmlBeanSerializerModifier());\n+        // as well as AnnotationIntrospector\n         context.insertAnnotationIntrospector(XML_ANNOTATION_INTROSPECTOR);\n-    }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper methods\n-    /**********************************************************\n-     */\n-    \n-    /**\n-     * Helper method used for figuring out if given raw type is a collection (\"indexed\") type;\n-     * in which case a wrapper element is typically added.\n-     */\n-    private static boolean _isContainerType(JavaType type)\n-    {\n-        if (type.isContainerType()) {\n-            // Just one special case; byte[] will be serialized as base64-encoded String, not real array, so:\n-            if (type.getRawClass() == byte[].class) {\n-                return false;\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    private static String findNamespaceAnnotation(AnnotationIntrospector ai, AnnotatedMember prop)\n-    {\n-        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n-            if (intr instanceof XmlAnnotationIntrospector) {\n-                String ns = ((XmlAnnotationIntrospector) intr).findNamespace(prop);\n-                if (ns != null) {\n-                    return ns;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private static Boolean findIsAttributeAnnotation(AnnotationIntrospector ai, AnnotatedMember prop)\n-    {\n-        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n-            if (intr instanceof XmlAnnotationIntrospector) {\n-                Boolean b = ((XmlAnnotationIntrospector) intr).isOutputAsAttribute(prop);\n-                if (b != null) {\n-                    return b;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private static QName findWrapperName(AnnotationIntrospector ai, AnnotatedMember prop)\n-    {\n-        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n-            if (intr instanceof XmlAnnotationIntrospector) {\n-                QName n = ((XmlAnnotationIntrospector) intr).findWrapperElement(prop);\n-                if (n != null) {\n-                    return n;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-    \n-    /*\n-    /**********************************************************\n-    /* Helper classes\n-    /**********************************************************\n-     */\n-\n-    /**\n-     * We need a {@link SerializerModifier} to replace default <code>BeanSerializer</code>\n-     * with XML-specific one; mostly to ensure that attribute properties are output\n-     * before element properties.\n-     */\n-    protected static class MySerializerModifier extends BeanSerializerModifier\n-    {\n-        /**\n-         * First thing to do is to find annotations regarding XML serialization,\n-         * and wrap collection serializers.\n-         */\n-        public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\n-                BasicBeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n-        {\n-            AnnotationIntrospector intr = config.getAnnotationIntrospector();\n-            for (int i = 0, len = beanProperties.size(); i < len; ++i) {\n-                BeanPropertyWriter bpw = beanProperties.get(i);\n-                final AnnotatedMember member = bpw.getMember();\n-                String ns = findNamespaceAnnotation(intr, member);\n-                Boolean isAttribute = findIsAttributeAnnotation(intr, member);\n-                bpw.setInternalSetting(XmlBeanSerializer.KEY_XML_INFO, new XmlInfo(isAttribute, ns));\n-\n-                // Actually: if we have a Collection type, easiest place to add wrapping would be here...\n-                if (_isContainerType(bpw.getType())) {\n-                    String localName = null, wrapperNs = null;\n-\n-                    QName wrappedName = new QName(ns, bpw.getName());\n-                    QName wrapperName = findWrapperName(intr, member);\n-                    if (wrapperName != null) {\n-                        localName = wrapperName.getLocalPart();\n-                        wrapperNs = wrapperName.getNamespaceURI();\n-                    }\n-                    /* Empty/missing localName means \"use property name as wrapper\"; later on\n-                     * should probably make missing (null) mean \"don't add a wrapper\"\n-                     */\n-                    if (localName == null || localName.length() == 0) {\n-                        wrapperName = wrappedName;\n-                    } else {\n-                        wrapperName = new QName((wrapperNs == null) ? \"\" : wrapperNs, localName);\n-                    }\n-                    beanProperties.set(i, new XmlBeanPropertyWriter(bpw, wrapperName, wrappedName));\n-                }\n-            }\n-            return beanProperties;\n-        }\n-        \n-        public JsonSerializer<?> modifySerializer(SerializationConfig config,\n-                BasicBeanDescription beanDesc, JsonSerializer<?> serializer)\n-        {\n-            /* First things first: we can only handle real BeanSerializers; question\n-             * is, what to do if it's not one: throw exception or bail out?\n-             * For now let's do latter.\n-             */\n-            if (!(serializer instanceof BeanSerializer)) {\n-                return serializer;\n-            }\n-            return new XmlBeanSerializer((BeanSerializer) serializer);\n-        }\n-    }\n+    }    \n }\n--- a/src/main/java/com/fasterxml/jackson/xml/ser/XmlBeanSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/xml/ser/XmlBeanSerializer.java\n import org.codehaus.jackson.JsonGenerator;\n import org.codehaus.jackson.map.JsonMappingException;\n import org.codehaus.jackson.map.SerializerProvider;\n+import org.codehaus.jackson.map.TypeSerializer;\n import org.codehaus.jackson.map.ser.BeanPropertyWriter;\n import org.codehaus.jackson.map.ser.BeanSerializer;\n \n         return new XmlBeanSerializer(this, filtered);\n     }\n \n+    /*\n+    /**********************************************************\n+    /* Overridden serialization methods\n+    /**********************************************************\n+     */\n+    \n     /**\n      * Main serialization method needs to be overridden to allow XML-specific\n      * extra handling, such as indication of whether to write attributes or\n         }\n     }\n \n+    @Override\n+    public void serializeWithType(Object bean, JsonGenerator jgen, SerializerProvider provider,\n+            TypeSerializer typeSer)\n+        throws IOException, JsonGenerationException\n+    {\n+        // Ok: let's serialize type id as attribute\n+        ToXmlGenerator xgen = (ToXmlGenerator)jgen;\n+        xgen.setNextIsAttribute(true);\n+        super.serializeWithType(bean, jgen, provider, typeSer);\n+        if (_attributeCount == 0) { // if no attributes, need to reset\n+            xgen.setNextIsAttribute(false);\n+        }\n+    }\n+    \n     /*\n     /**********************************************************\n     /* Helper methods\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/xml/ser/XmlBeanSerializerModifier.java\n+package com.fasterxml.jackson.xml.ser;\n+\n+import java.util.List;\n+\n+import javax.xml.namespace.QName;\n+\n+import org.codehaus.jackson.map.AnnotationIntrospector;\n+import org.codehaus.jackson.map.JsonSerializer;\n+import org.codehaus.jackson.map.SerializationConfig;\n+import org.codehaus.jackson.map.introspect.AnnotatedMember;\n+import org.codehaus.jackson.map.introspect.BasicBeanDescription;\n+import org.codehaus.jackson.map.ser.BeanPropertyWriter;\n+import org.codehaus.jackson.map.ser.BeanSerializer;\n+import org.codehaus.jackson.map.ser.BeanSerializerModifier;\n+import org.codehaus.jackson.type.JavaType;\n+\n+import com.fasterxml.jackson.xml.XmlAnnotationIntrospector;\n+import com.fasterxml.jackson.xml.util.XmlInfo;\n+\n+/**\n+ * We need a {@link BeanSerializerModifier} to replace default <code>BeanSerializer</code>\n+ * with XML-specific one; mostly to ensure that attribute properties are output\n+ * before element properties.\n+ */\n+public class XmlBeanSerializerModifier extends BeanSerializerModifier\n+{\n+    /*\n+    /**********************************************************\n+    /* Overridden methods\n+    /**********************************************************\n+     */\n+\n+    /**\n+     * First thing to do is to find annotations regarding XML serialization,\n+     * and wrap collection serializers.\n+     */\n+    @Override\n+    public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\n+            BasicBeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n+    {\n+        AnnotationIntrospector intr = config.getAnnotationIntrospector();\n+        for (int i = 0, len = beanProperties.size(); i < len; ++i) {\n+            BeanPropertyWriter bpw = beanProperties.get(i);\n+            final AnnotatedMember member = bpw.getMember();\n+            String ns = findNamespaceAnnotation(intr, member);\n+            Boolean isAttribute = findIsAttributeAnnotation(intr, member);\n+            bpw.setInternalSetting(XmlBeanSerializer.KEY_XML_INFO, new XmlInfo(isAttribute, ns));\n+\n+            // Actually: if we have a Collection type, easiest place to add wrapping would be here...\n+            if (_isContainerType(bpw.getType())) {\n+                String localName = null, wrapperNs = null;\n+\n+                QName wrappedName = new QName(ns, bpw.getName());\n+                QName wrapperName = findWrapperName(intr, member);\n+                if (wrapperName != null) {\n+                    localName = wrapperName.getLocalPart();\n+                    wrapperNs = wrapperName.getNamespaceURI();\n+                }\n+                /* Empty/missing localName means \"use property name as wrapper\"; later on\n+                 * should probably make missing (null) mean \"don't add a wrapper\"\n+                 */\n+                if (localName == null || localName.length() == 0) {\n+                    wrapperName = wrappedName;\n+                } else {\n+                    wrapperName = new QName((wrapperNs == null) ? \"\" : wrapperNs, localName);\n+                }\n+                beanProperties.set(i, new XmlBeanPropertyWriter(bpw, wrapperName, wrappedName));\n+            }\n+        }\n+        return beanProperties;\n+    }\n+    \n+    @Override\n+    public JsonSerializer<?> modifySerializer(SerializationConfig config,\n+            BasicBeanDescription beanDesc, JsonSerializer<?> serializer)\n+    {\n+        /* First things first: we can only handle real BeanSerializers; question\n+         * is, what to do if it's not one: throw exception or bail out?\n+         * For now let's do latter.\n+         */\n+        if (!(serializer instanceof BeanSerializer)) {\n+            return serializer;\n+        }\n+        return new XmlBeanSerializer((BeanSerializer) serializer);\n+    }\n+\n+    /*\n+    /**********************************************************\n+    /* Helper methods\n+    /**********************************************************\n+     */\n+    \n+    /**\n+     * Helper method used for figuring out if given raw type is a collection (\"indexed\") type;\n+     * in which case a wrapper element is typically added.\n+     */\n+    private static boolean _isContainerType(JavaType type)\n+    {\n+        if (type.isContainerType()) {\n+            // Just one special case; byte[] will be serialized as base64-encoded String, not real array, so:\n+            if (type.getRawClass() == byte[].class) {\n+                return false;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+    \n+    private static String findNamespaceAnnotation(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                String ns = ((XmlAnnotationIntrospector) intr).findNamespace(prop);\n+                if (ns != null) {\n+                    return ns;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static Boolean findIsAttributeAnnotation(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                Boolean b = ((XmlAnnotationIntrospector) intr).isOutputAsAttribute(prop);\n+                if (b != null) {\n+                    return b;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static QName findWrapperName(AnnotationIntrospector ai, AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                QName n = ((XmlAnnotationIntrospector) intr).findWrapperElement(prop);\n+                if (n != null) {\n+                    return n;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+    \n+}\n--- a/src/test/java/com/fasterxml/jackson/xml/TestPolymorphic.java\n+++ b/src/test/java/com/fasterxml/jackson/xml/TestPolymorphic.java\n         public SubTypeWithClassArray() { }\n         public SubTypeWithClassArray(String s) { name = s; }\n     }\n-\n+    \n     /**\n      * If not used as root element, need to use a wrapper\n      */\n          *   to Jackson (since BeanSerializer.serializeWithType() is final; shouldn't be!).\n          *   Need to wait...\n          */\n+        /* 13-Jan-2010, tatu: With Jackson 1.7.1, it is possible to override type information\n+         *   inclusion, which allows use of attribute over element, so:\n+         */\n         final String exp = \n-            //\"<SubTypeWithClassProperty _class=\\\"com.fasterxml.jackson.xml.TestPolymorphic$SubTypeWithClassProperty\\\">\"\n-            \"<SubTypeWithClassProperty><_class>com.fasterxml.jackson.xml.TestPolymorphic$SubTypeWithClassProperty</_class>\"\n+            \"<SubTypeWithClassProperty _class=\\\"com.fasterxml.jackson.xml.TestPolymorphic$SubTypeWithClassProperty\\\">\"\n+            //\"<SubTypeWithClassProperty><_class>com.fasterxml.jackson.xml.TestPolymorphic$SubTypeWithClassProperty</_class>\"\n             +\"<name>Foobar</name></SubTypeWithClassProperty>\"\n                 ;\n-                assertEquals(exp, xml);\n+        assertEquals(exp, xml);\n         \n         Object result = _xmlMapper.readValue(xml, BaseTypeWithClassProperty.class);\n         assertNotNull(result);\n     \n     /* 19-Dec-2010, tatu: Let's hold off these tests, due to issues with inclusions.\n      */\n-    /*\n     // Does not work since array wrapping is not explicitly forced (unlike with collection\n     // property of a bean\n+    /*\n     public void testAsClassArray() throws Exception\n     {\n         String xml = _xmlMapper.writeValueAsString(new SubTypeWithClassArray(\"Foobar\"));\n+\n+System.err.println(\"XML/subtype-array == \"+xml);\n \n         Object result = _xmlMapper.readValue(xml, BaseTypeWithClassArray.class);\n         assertNotNull(result);\n         assertEquals(SubTypeWithClassArray.class, result.getClass());\n         assertEquals(\"Foobar\", ((SubTypeWithClassArray) result).name);\n     }\n+    */\n \n     // Hmmh. Does not yet quite work either, since we do not properly force\n     // array context when writing...\n     public void testAsWrappedClassArray() throws Exception\n     {\n         String xml = _xmlMapper.writeValueAsString(new ClassArrayWrapper(\"Foobar\"));\n-\n+System.err.println(\"XML/wrapper-array == \"+xml);\n+        \n         ClassArrayWrapper result = _xmlMapper.readValue(xml, ClassArrayWrapper.class);\n         assertNotNull(result);\n         assertEquals(SubTypeWithClassArray.class, result.wrapped.getClass());\n         assertEquals(\"Foobar\", ((SubTypeWithClassArray) result.wrapped).name);\n     }\n-        */\n+    /*\n+\n+    */\n         \n     // Only works if NOT an inner class (\"$\" in inner class throws a wrench)...\n     /* 20-Dec-2010, tatu: Idiotic Eclipse-JUNIT tries to run tests on these.", "timestamp": 1294980603, "metainfo": ""}