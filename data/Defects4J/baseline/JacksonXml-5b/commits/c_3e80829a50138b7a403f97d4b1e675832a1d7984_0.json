{"sha": "3e80829a50138b7a403f97d4b1e675832a1d7984", "log": "Merge branch '2.4'", "commit": "\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlAnnotationIntrospector.java\n         }\n         return null;\n     }\n+\n+    @Override\n+    public Boolean isOutputAsCData(Annotated ann) {\n+        JacksonXmlCData prop = ann.getAnnotation(JacksonXmlCData.class);\n+        if (prop != null) {\n+            return prop.value() ? Boolean.TRUE : Boolean.FALSE;\n+        }\n+        return null;\n+    }\n     \n     /*\n     /**********************************************************************\n      * that cleans up type id property name to be a valid xml name.\n      */\n     @Override\n-    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder()\n-    {\n+    protected StdTypeResolverBuilder _constructStdTypeResolverBuilder() {\n         return new XmlTypeResolverBuilder();\n     }\n \n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlModule.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/JacksonXmlModule.java\n     /* Internal methods\n     /**********************************************************************\n      */\n-    \n-    protected AnnotationIntrospector _constructIntrospector()\n-    {\n+\n+    protected AnnotationIntrospector _constructIntrospector() {\n         return new JacksonXmlAnnotationIntrospector(_cfgDefaultUseWrapper);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlAnnotationIntrospector.java\n      * it should be serialized as text, without element wrapper.\n      */\n     public Boolean isOutputAsText(Annotated ann);\n+\n+    /**\n+     * Method used to check whether given annotated element\n+     * (field, method, constructor parameter) has indicator that suggests\n+     * it should be wrapped in a CDATA tag.\n+     */\n+    public Boolean isOutputAsCData(Annotated ann);\n \n     /*\n     /**********************************************************************\n             }\n             return value;\n         }\n+\n+        @Override\n+        public Boolean isOutputAsCData(Annotated ann) {\n+            Boolean value = (_xmlPrimary == null) ? null : _xmlPrimary.isOutputAsCData(ann);\n+            if (value == null && _xmlSecondary != null) {\n+                value = _xmlSecondary.isOutputAsCData(ann);\n+            }\n+            return value;\n+        }\n     }\n \n     /*\n         public Boolean isOutputAsText(Annotated ann) {\n             return _intr.isOutputAsText(ann);\n         }\n-        \n+\n+        @Override\n+        public Boolean isOutputAsCData(Annotated ann) {\n+            //There is no CData annotation in JAXB\n+            return false;\n+        }\n+\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlFactory.java\n */\n public class XmlFactory extends JsonFactory\n {\n-    private static final long serialVersionUID = -2793875812715996133L;\n+    // For 2.5:\n+    private static final long serialVersionUID = 1897624416641000209L;\n \n     /**\n      * Name used to identify XML format\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlMapper.java\n  */\n public class XmlMapper extends ObjectMapper\n {\n-    private static final long serialVersionUID = -724333029147285918L;\n+    // as of 2.5\n+    private static final long serialVersionUID = -1212805483143619605L;\n \n     protected final static JacksonXmlModule DEFAULT_XML_MODULE = new JacksonXmlModule();\n     \n      * \n      * @since 2.1\n      */\n-    protected void setXMLTextElementName(String name)\n-    {\n+    protected void setXMLTextElementName(String name) {\n         ((XmlFactory) _jsonFactory).setXMLTextElementName(name);\n     }\n \n     protected PrettyPrinter _defaultPrettyPrinter() {\n         return new DefaultXmlPrettyPrinter();\n     }\n-\n-    /*\n-    /**********************************************************\n-    /* Helper methods\n-    /**********************************************************\n-     */\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/XmlPrettyPrinter.java\n     public void writeEndElement(XMLStreamWriter2 sw, int nrOfEntries) throws XMLStreamException;\n \n     public void writeLeafElement(XMLStreamWriter2 sw,\n-    \t\tString nsURI, String localName, String text)\n+    \t\tString nsURI, String localName, String text, boolean isCData)\n         throws XMLStreamException;\n \n     public void writeLeafElement(XMLStreamWriter2 sw,\n     \t\tString nsURI, String localName,\n-    \t\tchar[] buffer, int offset, int len)\n+    \t\tchar[] buffer, int offset, int len, boolean isCData)\n         throws XMLStreamException;\n     \n     public void writeLeafElement(XMLStreamWriter2 sw,\n--- /dev/null\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/annotation/JacksonXmlCData.java\n+package com.fasterxml.jackson.dataformat.xml.annotation;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Adding this annotation will result in value of the property to be serialized\n+ * within a CData tag.  Only use on String properties and String collections.\n+ */\n+@Target({ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER })\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface JacksonXmlCData\n+{\n+    /**\n+     * Whether the property text should always be within a CData block\n+     * when serialized.\n+     */\n+    public boolean value() default true;\n+}\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlReadContext.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/XmlReadContext.java\n  * state data we need.\n  *<p>\n  * Almost same as standard <code>JsonReaderContext</code>, but\n- * cut'n pasted since the impl is final for performance reasons;\n- * this class is one of hot spots in profiling.\n+ * custom version needed to be able to keep track of names\n+ * of properties that need wrapping; this is needed to\n+ * support wrapped/unwrapped Collection/array values.\n  */\n public final class XmlReadContext\n     extends JsonStreamContext\n     \n     // // // Factory methods\n \n-    public static XmlReadContext createRootContext(int lineNr, int colNr)\n-    {\n+    public static XmlReadContext createRootContext(int lineNr, int colNr) {\n         return new XmlReadContext(null, TYPE_ROOT, lineNr, colNr);\n     }\n \n-    public static XmlReadContext createRootContext()\n-    {\n+    public static XmlReadContext createRootContext() {\n         return new XmlReadContext(null, TYPE_ROOT, 1, 0);\n     }\n     \n         throw new UnsupportedOperationException();\n     }\n \n-    public void setCurrentName(String name)\n-    {\n+    public void setCurrentName(String name) {\n         _currentName = name;\n     }\n \n      * @return Location pointing to the point where the context\n      *   start marker was found\n      */\n-    public final JsonLocation getStartLocation(Object srcRef)\n-    {\n-        /* We don't keep track of offsets at this level (only\n-         * reader does)\n-         */\n+    public final JsonLocation getStartLocation(Object srcRef) {\n+        // We don't keep track of offsets at this level (only reader does)\n         long totalChars = -1L;\n \n         return new JsonLocation(srcRef, totalChars, _lineNr, _columnNr);\n         return _namesToWrap;\n     }\n \n-    protected void convertToArray()\n-    {\n+    protected void convertToArray() {\n         _type = TYPE_ARRAY;\n     }\n     \n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/jaxb/XmlJaxbAnnotationIntrospector.java\n     @Override\n     public Boolean isOutputAsText(Annotated ann) {\n         return super.isOutputAsText(ann);\n+    }\n+\n+    @Override\n+    public Boolean isOutputAsCData(Annotated ann) {\n+        //There is no CData annotation in JAXB\n+        return false;\n     }\n     \n     /*\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator.java\n      * once.\n      */\n     protected boolean _nextIsUnwrapped = false;\n+\n+    /**\n+     * Marker flag used to indicate that the next write of a (property)\n+     * value should be as CData\n+     */\n+    protected boolean _nextIsCData = false;\n     \n     /**\n      * To support proper serialization of arrays it is necessary to keep\n     {\n         _nextIsUnwrapped = isUnwrapped;\n     }\n+\n+    public void setNextIsCData(boolean isCData)\n+    {\n+        _nextIsCData = isCData;\n+    }\n     \n     public final void setNextName(QName name)\n     {\n                 // [Issue#56] Should figure out how to prevent indentation for end element\n                 //   but for now, let's just make sure structure is correct\n                 //if (_xmlPrettyPrinter != null) { ... }\n-                _xmlWriter.writeCharacters(text);\n+                if(_nextIsCData) {\n+                    _xmlWriter.writeCData(text);\n+                } else {\n+                    _xmlWriter.writeCharacters(text);\n+                }\n             } else if (_xmlPrettyPrinter != null) {\n                 _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                         _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n-                        text);\n+                        text, _nextIsCData);\n             } else {\n                 _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeCharacters(text);\n+                if(_nextIsCData) {\n+                    _xmlWriter.writeCData(text);\n+                } else {\n+                    _xmlWriter.writeCharacters(text);\n+                }\n                 _xmlWriter.writeEndElement();\n             } \n         } catch (XMLStreamException e) {\n                 _xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), new String(text, offset, len));\n             } else if (checkNextIsUnwrapped()) {\n             \t// should we consider pretty-printing or not?\n-                _xmlWriter.writeCharacters(text, offset, len);\n+                if(_nextIsCData) {\n+                    _xmlWriter.writeCData(text, offset, len);\n+                } else {\n+                    _xmlWriter.writeCharacters(text, offset, len);\n+                }\n             } else if (_xmlPrettyPrinter != null) {\n                 _xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n                         _nextName.getNamespaceURI(), _nextName.getLocalPart(),\n-                        text, offset, len);\n+                        text, offset, len, _nextIsCData);\n             } else {\n                 _xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n-                _xmlWriter.writeCharacters(text, offset, len);\n+                if(_nextIsCData) {\n+                    _xmlWriter.writeCData(text, offset, len);\n+                } else {\n+                    _xmlWriter.writeCharacters(text, offset, len);\n+                }\n                 _xmlWriter.writeEndElement();\n             }\n         } catch (XMLStreamException e) {\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerBase.java\n                 xgen.setNextName(xmlNames[i]);\n                 BeanPropertyWriter prop = props[i];\n                 if (prop != null) { // can have nulls in filtered list\n+                    if(_isCData(prop)) {\n+                        xgen.setNextIsCData(true);\n+                    }\n+\n                     prop.serializeAsField(bean, xgen, provider);\n+\n+                    if(_isCData(prop)) {\n+                        xgen.setNextIsCData(false);\n+                    }\n                 }\n                 // Reset to avoid next value being written as unwrapped, \n                 // for example when property is suppressed\n         return (info != null) && info.isAttribute();\n     }\n \n+    protected static boolean _isCData(BeanPropertyWriter bpw)\n+    {\n+        XmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\n+        return (info != null) && info.isCData();\n+    }\n+\n     /**\n      * Method for re-sorting lists of bean properties such that attributes are strictly\n      * written before elements.\n                 continue;\n             }\n             \n-            // Move attribute a few places done as necessary\n+            // Move attribute a few places down as necessary\n             int moveBy = i - attrCount;\n             if (moveBy > 0) {\n                 System.arraycopy(properties, attrCount, properties, attrCount + 1, moveBy);\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlBeanSerializerModifier.java\n             String ns = AnnotationUtil.findNamespaceAnnotation(intr, member);\n             Boolean isAttribute = AnnotationUtil.findIsAttributeAnnotation(intr, member);\n             Boolean isText = AnnotationUtil.findIsTextAnnotation(intr, member);\n+            Boolean isCData = AnnotationUtil.findIsCDataAnnotation(intr, member);\n             bpw.setInternalSetting(XmlBeanSerializerBase.KEY_XML_INFO,\n-            \t\tnew XmlInfo(isAttribute, ns, isText));\n+            \t\tnew XmlInfo(isAttribute, ns, isText, isCData));\n \n             // Actually: if we have a Collection type, easiest place to add wrapping would be here...\n             //  or: let's also allow wrapping of \"untyped\" (Object): assuming it is a dynamically\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\n  */\n public class XmlSerializerProvider extends DefaultSerializerProvider\n {\n-    private static final long serialVersionUID = -141838337907252911L;\n+    // As of 2.5\n+    private static final long serialVersionUID = -4138605166320336475L;\n \n     /**\n      * If all we get to serialize is a null, there's no way to figure out\n \n     @Override\n     public DefaultSerializerProvider createInstance(SerializationConfig config,\n-            SerializerFactory jsf)\n-    {\n+            SerializerFactory jsf) {\n         return new XmlSerializerProvider(this, config, jsf);\n     }\n     \n     @SuppressWarnings(\"resource\")\n     @Override\n     public void serializeValue(JsonGenerator jgen, Object value)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         if (value == null) {\n             _serializeXmlNull(jgen);\n     @SuppressWarnings(\"resource\")\n     @Override\n     public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType)\n-        throws IOException, JsonProcessingException\n+        throws IOException\n     {\n         if (value == null) {\n             _serializeXmlNull(jgen);\n     @SuppressWarnings(\"resource\")\n     @Override\n     public void serializeValue(JsonGenerator jgen, Object value, JavaType rootType,\n-            JsonSerializer<Object> ser)\n-        throws IOException, JsonGenerationException\n+            JsonSerializer<Object> ser) throws IOException\n     {\n         if (value == null) {\n             _serializeXmlNull(jgen);\n         }\n     }\n \n-    protected void _serializeXmlNull(JsonGenerator jgen)\n-            throws IOException, JsonProcessingException\n+    protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         if (jgen instanceof ToXmlGenerator)\n         _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n         super.serializeValue(jgen, null);\n     }\n     \n-    protected void _startRootArray(ToXmlGenerator xgen, QName rootName)\n-        throws IOException, JsonProcessingException\n+    protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n     {\n         xgen.writeStartObject();\n         // Could repeat root name, but what's the point? How to customize?\n         xgen.writeFieldName(\"item\");\n     }    \n \n-    protected void _initWithRootName(ToXmlGenerator xgen, QName rootName)\n-            throws IOException, JsonProcessingException\n+    protected void _initWithRootName(ToXmlGenerator xgen, QName rootName) throws IOException\n     {\n         /* 28-Nov-2012, tatu: We should only initialize the root\n          *  name if no name has been set, as per [Issue#42],\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/AnnotationUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/AnnotationUtil.java\n         }\n         return null;\n     }\n+\n+    public static Boolean findIsCDataAnnotation(AnnotationIntrospector ai,\n+                                               AnnotatedMember prop)\n+    {\n+        for (AnnotationIntrospector intr : ai.allIntrospectors()) {\n+            if (intr instanceof XmlAnnotationIntrospector) {\n+                Boolean b = ((XmlAnnotationIntrospector) intr).isOutputAsCData(prop);\n+                if (b != null) {\n+                    return b;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/DefaultXmlPrettyPrinter.java\n     \n     @Override\n     public void writeLeafElement(XMLStreamWriter2 sw,\n-    \t\tString nsURI, String localName, String text)\n+    \t\tString nsURI, String localName, String text, boolean isCData)\n   \t\tthrows XMLStreamException\n     {\n         if (!_objectIndenter.isInline()) {\n             _objectIndenter.writeIndentation(sw, _nesting);\n         }\n         sw.writeStartElement(nsURI, localName);\n-        sw.writeCharacters(text);\n+        if(isCData) {\n+            sw.writeCData(text);\n+        } else {\n+            sw.writeCharacters(text);\n+        }\n         sw.writeEndElement();\n         _justHadStartElement = false;\n     }\n     @Override\n     public void writeLeafElement(XMLStreamWriter2 sw,\n     \t\tString nsURI, String localName,\n-    \t\tchar[] buffer, int offset, int len)\n+    \t\tchar[] buffer, int offset, int len, boolean isCData)\n         throws XMLStreamException\n     {\n         if (!_objectIndenter.isInline()) {\n             _objectIndenter.writeIndentation(sw, _nesting);\n         }\n         sw.writeStartElement(nsURI, localName);\n-        sw.writeCharacters(buffer, offset, len);\n+        if(isCData) {\n+            sw.writeCData(buffer, offset, len);\n+        } else {\n+            sw.writeCharacters(buffer, offset, len);\n+        }\n         sw.writeEndElement();\n         _justHadStartElement = false;\n     }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/TypeUtil.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/TypeUtil.java\n             Class<?> cls = type.getRawClass();\n             // One special case; byte[] will be serialized as base64-encoded String, not real array, so:\n             // (actually, ditto for char[]; thought to be a String)\n-            if (cls == byte[].class || cls == byte[].class) {\n+            if (cls == byte[].class || cls == char[].class) {\n                 return false;\n             }\n             // issue#5: also, should not add wrapping for Maps\n \n     public static boolean isIndexedType(Class<?> cls)\n     {\n-        return (cls.isArray() && cls != byte[].class) || Collection.class.isAssignableFrom(cls);\n+        return (cls.isArray() && cls != byte[].class && cls != char[].class)\n+                || Collection.class.isAssignableFrom(cls);\n     }\n }\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlInfo.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/util/XmlInfo.java\n     protected final String _namespace;\n     protected final boolean _isAttribute;\n     protected final boolean _isText;\n+    protected final boolean _isCData;\n     \n-    public XmlInfo(Boolean isAttribute, String ns, Boolean isText)\n+    public XmlInfo(Boolean isAttribute, String ns, Boolean isText, Boolean isCData)\n     {\n         _isAttribute = (isAttribute == null) ? false : isAttribute.booleanValue();\n         _namespace = (ns == null) ? \"\" : ns;\n         _isText = (isText == null) ? false : isText.booleanValue();\n+        _isCData = (isCData == null) ? false : isCData.booleanValue();\n     }\n \n     public String getNamespace() { return _namespace; }\n     public boolean isAttribute() { return _isAttribute; }\n     public boolean isText() { return _isText; }\n+    public boolean isCData() { return _isCData; }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedDeserIssue86.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/failing/TestUnwrappedDeserIssue86.java\n import java.util.Arrays;\n import java.util.List;\n \n-import junit.framework.Assert;\n-\n import org.junit.Test;\n \n import com.fasterxml.jackson.annotation.JsonInclude.Include;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n+import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlElementWrapper;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n \n-public class TestUnwrappedDeserIssue86\n+public class TestUnwrappedDeserIssue86 extends XmlTestBase\n {\n     @JacksonXmlRootElement(localName = \"test\")\n     public static class Issue86 {\n             \"</test>\" +\n         \"</test>\";\n \n-    final Issue86 before = new Issue86(\n-        \"0\",\n-        Arrays.asList(\n-            new Issue86(\n-                \"0.1\",\n+    final Issue86 before = new Issue86(\"0\",\n+        Arrays.asList(new Issue86(\"0.1\",\n+                Arrays.asList(new Issue86(\"0.1.1\", null))),\n+            new Issue86(\"0.2\", null),\n+            new Issue86(\"0.3\",\n                 Arrays.asList(\n-                    new Issue86(\n-                        \"0.1.1\",\n-                        null))),\n-            new Issue86(\n-                \"0.2\",\n-                null),\n-            new Issue86(\n-                \"0.3\",\n-                Arrays.asList(\n-                    new Issue86(\n-                        \"0.3.1\",\n-                        null)))));\n+                    new Issue86(\"0.3.1\", null)))));\n \n     final XmlMapper mapper = new XmlMapper();\n     mapper.setSerializationInclusion(Include.NON_NULL);\n \n     final String xml = mapper.writeValueAsString(before);\n-    Assert.assertEquals(source, xml);\n+    assertEquals(source, xml);\n \n     final Issue86 after = mapper.readValue(xml, Issue86.class);\n-    Assert.assertEquals(before, after);\n+    assertEquals(before, after);\n   }\n }\n--- a/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestSerialization.java\n+++ b/src/test/java/com/fasterxml/jackson/dataformat/xml/ser/TestSerialization.java\n import com.fasterxml.jackson.dataformat.xml.JacksonXmlModule;\n import com.fasterxml.jackson.dataformat.xml.XmlMapper;\n import com.fasterxml.jackson.dataformat.xml.XmlTestBase;\n+import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlCData;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;\n import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;\n \n     static class NsRootBean\n     {\n         public String value = \"abc\";\n+    }\n+\n+    static class CDataStringBean\n+    {\n+        @JacksonXmlCData\n+        public String value = \"<some<data\\\"\";\n+    }\n+\n+    static class CDataStringArrayBean\n+    {\n+        @JacksonXmlCData\n+        public String[] value = {\"<some<data\\\"\", \"abc\"};\n     }\n \n     static class CustomSerializer extends StdScalarSerializer<String>\n \n         assertEquals(Integer.valueOf(456), result.get(\"b\"));\n     }\n+\n+    public void testCDataString() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new CDataStringBean());\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<CDataStringBean><value><![CDATA[<some<data\\\"]]></value></CDataStringBean>\", xml);\n+    }\n+\n+    public void testCDataStringArray() throws IOException\n+    {\n+        String xml = _xmlMapper.writeValueAsString(new CDataStringArrayBean());\n+        xml = removeSjsxpNamespace(xml);\n+        assertEquals(\"<CDataStringArrayBean><value><value><![CDATA[<some<data\\\"]]></value><value><![CDATA[abc]]></value></value></CDataStringArrayBean>\", xml);\n+    }\n     \n     // for [Issue#41]\n     public void testCustomSerializer() throws Exception", "timestamp": 1415841191, "metainfo": ""}