{"sha": "433d2f180058b8b73e1951c6cfbb986714e68b0f", "log": "Allow an alternate parser to be supplied for core use cases.", "commit": "\n--- a/src/main/java/org/jsoup/Connection.java\n+++ b/src/main/java/org/jsoup/Connection.java\n package org.jsoup;\n \n import org.jsoup.nodes.Document;\n+import org.jsoup.parser.Parser;\n \n import java.net.URL;\n import java.util.Map;\n     public Connection cookies(Map<String, String> cookies);\n \n     /**\n+     * Provide an alternate parser to use when parsing the response to a Document.\n+     * @param parser alternate parser\n+     * @return this Connection, for chaining\n+     */\n+    public Connection parser(Parser parser);\n+\n+    /**\n      * Execute the request as a GET, and parse the result.\n      * @return parsed Document\n      * @throws IOException on error\n         public Document parse() throws IOException;\n \n         /**\n+         * Specify the parser to use when parsing the document.\n+         * @param parser parser to use.\n+         */\n+        public void parser(Parser parser);\n+\n+        /**\n          * Get the body of the response as a plain string.\n          * @return body\n          */\n--- a/src/main/java/org/jsoup/Jsoup.java\n+++ b/src/main/java/org/jsoup/Jsoup.java\n      */\n     public static Document parse(String html, String baseUri) {\n         return Parser.parse(html, baseUri);\n+    }\n+\n+    /**\n+     Parse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML\n+     (non-HTML) parser.\n+\n+     @param html    HTML to parse\n+     @param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur\n+     before the HTML declares a {@code <base href>} tag.\n+     @param parser alternate {@link Parser#xmlParser() parser} to use.\n+     @return sane HTML\n+     */\n+    public static Document parse(String html, String baseUri, Parser parser) {\n+        return parser.parseInput(html, baseUri);\n     }\n \n     /**\n     }\n \n     /**\n+     Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML\n+     (non-HTML) parser.\n+\n+     @param in          input stream to read. Make sure to close it after parsing.\n+     @param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if\n+     present, or fall back to {@code UTF-8} (which is often safe to do).\n+     @param baseUri     The URL where the HTML was retrieved from, to resolve relative links against.\n+     @param parser alternate {@link Parser#xmlParser() parser} to use.\n+     @return sane HTML\n+\n+     @throws IOException if the file could not be found, or read, or if the charsetName is invalid.\n+     */\n+    public static Document parse(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n+        return DataUtil.load(in, charsetName, baseUri, parser);\n+    }\n+\n+    /**\n      Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.\n \n      @param bodyHtml body HTML fragment\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n package org.jsoup.helper;\n \n-import org.jsoup.Jsoup;\n import org.jsoup.nodes.Document;\n import org.jsoup.nodes.Element;\n+import org.jsoup.parser.Parser;\n \n import java.io.*;\n import java.nio.ByteBuffer;\n         try {\n             inStream = new FileInputStream(in);\n             ByteBuffer byteData = readToByteBuffer(inStream);\n-            return parseByteData(byteData, charsetName, baseUri);\n+            return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n         } finally {\n             if (inStream != null)\n                 inStream.close();\n      */\n     public static Document load(InputStream in, String charsetName, String baseUri) throws IOException {\n         ByteBuffer byteData = readToByteBuffer(in);\n-        return parseByteData(byteData, charsetName, baseUri);\n+        return parseByteData(byteData, charsetName, baseUri, Parser.htmlParser());\n+    }\n+\n+    /**\n+     * Parses a Document from an input steam, using the provided Parser.\n+     * @param in input stream to parse. You will need to close it.\n+     * @param charsetName character set of input\n+     * @param baseUri base URI of document, to resolve relative links against\n+     * @param parser alternate {@link Parser#xmlParser() parser} to use.\n+     * @return Document\n+     * @throws IOException on IO error\n+     */\n+    public static Document load(InputStream in, String charsetName, String baseUri, Parser parser) throws IOException {\n+        ByteBuffer byteData = readToByteBuffer(in);\n+        return parseByteData(byteData, charsetName, baseUri, parser);\n     }\n \n     // reads bytes first into a buffer, then decodes with the appropriate charset. done this way to support\n     // switching the chartset midstream when a meta http-equiv tag defines the charset.\n-    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri) {\n+    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {\n         String docData;\n         Document doc = null;\n         if (charsetName == null) { // determine from meta. safe parse as UTF-8\n             // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n-            doc = Jsoup.parse(docData, baseUri);\n+            doc = parser.parseInput(docData, baseUri);\n             Element meta = doc.select(\"meta[http-equiv=content-type], meta[charset]\").first();\n             if (meta != null) { // if not found, will keep utf-8 as best attempt\n                 String foundCharset = meta.hasAttr(\"http-equiv\") ? getCharsetFromContentType(meta.attr(\"content\")) : meta.attr(\"charset\");\n             docData = Charset.forName(charsetName).decode(byteData).toString();\n         }\n         if (doc == null) {\n-            doc = Jsoup.parse(docData, baseUri);\n+            doc = parser.parseInput(docData, baseUri);\n             doc.outputSettings().charset(charsetName);\n         }\n         return doc;\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n \n import org.jsoup.Connection;\n import org.jsoup.nodes.Document;\n+import org.jsoup.parser.Parser;\n import org.jsoup.parser.TokenQueue;\n \n import java.io.*;\n         for (Map.Entry<String, String> entry : cookies.entrySet()) {\n             req.cookie(entry.getKey(), entry.getValue());\n         }\n+        return this;\n+    }\n+\n+    public Connection parser(Parser parser) {\n+        res.parser(parser);\n         return this;\n     }\n \n \n     public static class Response extends Base<Connection.Response> implements Connection.Response {\n         private static final int MAX_REDIRECTS = 20;\n+        private Parser parser = Parser.htmlParser();\n         private int statusCode;\n         private String statusMessage;\n         private ByteBuffer byteData;\n                     throw new IOException(String.format(\"Too many redirects occurred trying to load URL %s\", previousResponse.url()));\n             }\n         }\n-\n+        \n         static Response execute(Connection.Request req) throws IOException {\n             return execute(req, null);\n         }\n             if (!req.ignoreContentType() && (contentType == null || !(contentType.startsWith(\"text/\") || contentType.startsWith(\"application/xml\") || contentType.startsWith(\"application/xhtml+xml\"))))\n                 throw new IOException(String.format(\"Unhandled content type \\\"%s\\\" on URL %s. Must be text/*, application/xml, or application/xhtml+xml\",\n                     contentType, url.toString()));\n-            Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm());\n+            Document doc = DataUtil.parseByteData(byteData, charset, url.toExternalForm(), parser);\n             byteData.rewind();\n             charset = doc.outputSettings().charset().name(); // update charset from meta-equiv, possibly\n             return doc;\n+        }\n+\n+        public void parser(Parser parser) {\n+            Validate.notNull(parser);\n+            this.parser = parser;\n         }\n \n         public String body() {\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n     HtmlTreeBuilder() {}\n \n     @Override\n-    Document parse(String input, String baseUri) {\n+    Document parse(String input, String baseUri, boolean trackErrors) {\n         state = HtmlTreeBuilderState.Initial;\n-        return super.parse(input, baseUri);\n-    }\n-\n-    List<Node> parseFragment(String inputFragment, Element context, String baseUri) {\n+        return super.parse(input, baseUri, trackErrors);\n+    }\n+\n+    List<Node> parseFragment(String inputFragment, Element context, String baseUri, boolean trackErrors) {\n         // context may be null\n-        initialiseParse(inputFragment, baseUri);\n+        initialiseParse(inputFragment, baseUri, trackErrors);\n         contextElement = context;\n         fragmentParsing = true;\n         Element root = null;\n     }\n \n     @Override\n-    boolean process(Token token) {\n+    protected boolean process(Token token) {\n         currentToken = token;\n         return this.state.process(token, this);\n     }\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n  * in {@link org.jsoup.Jsoup}.\n  */\n public class Parser {\n+    private TreeBuilder treeBuilder;\n+    private boolean trackErrors = false;\n+    private List<ParseError> errors;\n+\n+    /**\n+     * Create a new Parser, using the specified TreeBuilder\n+     * @param treeBuilder TreeBuilder to use to parse input into Documents.\n+     */\n+    public Parser(TreeBuilder treeBuilder) {\n+        this.treeBuilder = treeBuilder;\n+    }\n+    \n+    public Document parseInput(String html, String baseUri) {\n+        Document doc = treeBuilder.parse(html, baseUri, trackErrors);\n+        errors = treeBuilder.getErrors();\n+        return doc;\n+    }\n+\n+    // gets & sets\n+    /**\n+     * Get the TreeBuilder currently in use.\n+     * @return current TreeBuilder.\n+     */\n+    public TreeBuilder getTreeBuilder() {\n+        return treeBuilder;\n+    }\n+\n+    /**\n+     * Update the TreeBuilder used when parsing content.\n+     * @param treeBuilder current TreeBuilder\n+     */\n+    public void setTreeBuilder(TreeBuilder treeBuilder) {\n+        this.treeBuilder = treeBuilder;\n+    }\n+\n+    /**\n+     * Check if parse error tracking is enabled.\n+     * @return current track error state.\n+     */\n+    public boolean isTrackErrors() {\n+        return trackErrors;\n+    }\n+\n+    /**\n+     * Enable or disable parse error tracking for the next parse/\n+     * @param trackErrors on/off\n+     */\n+    public void setTrackErrors(boolean trackErrors) {\n+        this.trackErrors = trackErrors;\n+    }\n+\n+    /**\n+     * Retrieve the parse errors, if any, from the last parse.\n+     * @return list of parse errors, if error tracking was enabled and errors occurred.\n+     */\n+    public List<ParseError> getErrors() {\n+        return errors;\n+    }\n+\n+    // static parse functions below\n     /**\n      * Parse HTML into a Document.\n      *\n      */\n     public static Document parse(String html, String baseUri) {\n         TreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parse(html, baseUri);\n+        return treeBuilder.parse(html, baseUri, false);\n     }\n \n     /**\n      */\n     public static List<Node> parseFragment(String fragmentHtml, Element context, String baseUri) {\n         HtmlTreeBuilder treeBuilder = new HtmlTreeBuilder();\n-        return treeBuilder.parseFragment(fragmentHtml, context, baseUri);\n+        return treeBuilder.parseFragment(fragmentHtml, context, baseUri, false);\n     }\n \n     /**\n     public static Document parseBodyFragmentRelaxed(String bodyHtml, String baseUri) {\n         return parse(bodyHtml, baseUri);\n     }\n+    \n+    // builders\n+\n+    /**\n+     * Create a new HTML parser. This parser treats input as HTML5, and enforces the creation of a normalised document,\n+     * based on a knowledge of the semantics of the incoming tags.\n+     * @return a new HTML parser.\n+     */\n+    public static Parser htmlParser() {\n+        return new Parser(new HtmlTreeBuilder());\n+    }\n+\n+    /**\n+     * Create a new XML parser. This parser assumes no knowledge of the incoming tags and does not treat it as HTML,\n+     * rather creates a simple tree directly from the input.\n+     * @return a new simple XML parser.\n+     */\n+    public static Parser xmlParser() {\n+        return new Parser(new XmlTreeBuilder());\n+    }\n }\n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n     protected String baseUri; // current base uri, for creating new elements\n     protected Token currentToken; // currentToken is used only for error tracking.\n     protected boolean trackErrors = false;\n-    protected List<ParseError> errors = new ArrayList<ParseError>();\n+    protected List<ParseError> errors;\n \n-    protected void initialiseParse(String input, String baseUri) {\n+    protected void initialiseParse(String input, String baseUri, boolean trackErrors) {\n         doc = new Document(baseUri);\n         reader = new CharacterReader(input);\n         tokeniser = new Tokeniser(reader);\n         stack = new DescendableLinkedList<Element>();\n         this.baseUri = baseUri;\n+        errors = new ArrayList<ParseError>();\n+        this.trackErrors = trackErrors;\n     }\n \n     Document parse(String input, String baseUri) {\n-        initialiseParse(input, baseUri);\n+        return parse(input, baseUri, false);\n+    }\n+\n+    Document parse(String input, String baseUri, boolean trackErrors) {\n+        initialiseParse(input, baseUri, trackErrors);\n         runParser();\n         return doc;\n+    }\n+    \n+    List<ParseError> getErrors() {\n+        return errors;\n     }\n \n     protected void runParser() {\n         }\n     }\n \n-    abstract boolean process(Token token);\n+    protected abstract boolean process(Token token);\n \n-    Element currentElement() {\n+    protected Element currentElement() {\n         return stack.getLast();\n     }\n }\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n  */\n public class XmlTreeBuilder extends TreeBuilder {\n     @Override\n-    protected void initialiseParse(String input, String baseUri) {\n-        super.initialiseParse(input, baseUri);\n+    protected void initialiseParse(String input, String baseUri, boolean trackErrors) {\n+        super.initialiseParse(input, baseUri, trackErrors);\n         stack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\n     }\n \n     @Override\n-    boolean process(Token token) {\n+    protected boolean process(Token token) {\n         // start tag, end tag, doctype, comment, character, eof\n         switch (token.type) {\n             case StartTag:", "timestamp": 1330404953, "metainfo": ""}