{"sha": "8e524450bbaf0eb3210f0f0d2fff3cc4d54cb0a7", "log": "Optimized character reference searches", "commit": "\n--- a/src/main/java/org/jsoup/parser/Tokeniser.java\n+++ b/src/main/java/org/jsoup/parser/Tokeniser.java\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.Entities;\n \n+import java.util.Arrays;\n \n /**\n  * Readers the input stream into tokens.\n  */\n class Tokeniser {\n     static final char replacementChar = '\\uFFFD'; // replaces null character\n+    private static final char[] notCharRefCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '<', '&'};\n+\n+    static {\n+        Arrays.sort(notCharRefCharsSorted);\n+    }\n \n     private CharacterReader reader; // html input\n     private ParseErrorList errors; // errors found while tokenising\n             return null;\n         if (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\n             return null;\n-        if (reader.matchesAny('\\t', '\\n', '\\r', '\\f', ' ', '<', '&'))\n+        if (reader.matchesAnySorted(notCharRefCharsSorted))\n             return null;\n \n         reader.mark();\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n package org.jsoup.parser;\n+\n+import java.util.Arrays;\n \n /**\n  * States and transition activations for the Tokeniser.\n                     t.emit(new Token.EOF());\n                     break;\n                 default:\n-                    String data = r.consumeToAny('&', '<', nullChar);\n+                    String data = r.consumeData();\n                     t.emit(data);\n                     break;\n             }\n         // from < or </ in data, will have start or end tag pending\n         void read(Tokeniser t, CharacterReader r) {\n             // previous TagOpen state did NOT consume, will have a letter char in current\n-            String tagName = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar).toLowerCase();\n+            //String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\n+            String tagName = r.consumeTagName().toLowerCase();\n             t.tagPending.appendTagName(tagName);\n \n             switch (r.consume()) {\n     AttributeName {\n         // from before attribute name\n         void read(Tokeniser t, CharacterReader r) {\n-            String name = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<');\n+            String name = r.consumeToAnySorted(attributeNameCharsSorted);\n             t.tagPending.appendAttributeName(name.toLowerCase());\n \n             char c = r.consume();\n     },\n     AttributeValue_doubleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAny('\"', '&', nullChar);\n+            String value = r.consumeToAnySorted(attributeDoubleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n \n     },\n     AttributeValue_singleQuoted {\n         void read(Tokeniser t, CharacterReader r) {\n-            String value = r.consumeToAny('\\'', '&', nullChar);\n+            String value = r.consumeToAnySorted(attributeSingleValueCharsSorted);\n             if (value.length() > 0)\n                 t.tagPending.appendAttributeValue(value);\n \n \n     abstract void read(Tokeniser t, CharacterReader r);\n \n-    private static final char nullChar = '\\u0000';\n+    static final char nullChar = '\\u0000';\n+    private static final char[] attributeSingleValueCharsSorted = new char[]{'\\'', '&', nullChar};\n+    private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar};\n+    private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'};\n+\n     private static final char replacementChar = Tokeniser.replacementChar;\n     private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n     private static final char eof = CharacterReader.EOF;\n+\n+    static {\n+        Arrays.sort(attributeSingleValueCharsSorted);\n+        Arrays.sort(attributeDoubleValueCharsSorted);\n+        Arrays.sort(attributeNameCharsSorted);\n+    }\n \n     /**\n      * Handles RawtextEndTagName, ScriptDataEndTagName, and ScriptDataEscapedEndTagName. Same body impl, just\n      * different else exit transitions.\n      */\n-    private static final void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n+    private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n         if (r.matchesLetter()) {\n             String name = r.consumeLetterSequence();\n             t.tagPending.appendTagName(name.toLowerCase());\n         }\n     }\n \n-    private static final void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n+    private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n         if (r.matchesLetter()) {\n             String name = r.consumeLetterSequence();\n             t.dataBuffer.append(name.toLowerCase());", "timestamp": 1414363885, "metainfo": ""}