{"sha": "cf3676c534e92052acf870c71e2fa8fb9c060fe6", "log": "Upgraded the selector query parser to allow nested selectors like 'div:has(p:has(span))'", "commit": "\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n     }\n \n     /**\n+     * Pulls a balanced string off the queue. E.g. if queue is \"(one (two) three) four\", (,) will return \"one (two) three\",\n+     * and leave \" four\" on the queue\n+     * @param open opener\n+     * @param close closer\n+     * @return data matched from the queue\n+     */\n+    public String chompBalanced(Character open, Character close) {\n+        StringBuilder accum = new StringBuilder();\n+        int depth = 0;\n+        int i = 0;\n+        do {\n+            if (queue.isEmpty()) break;\n+            Character c = consume();\n+            if (c.equals(open))\n+                depth++;\n+            else if (c.equals(close))\n+                depth--;\n+\n+            if (depth > 0 && i > 0)\n+                accum.append(c); // dont include the outer match pair in the return\n+            i++;\n+        } while (depth > 0);\n+        return accum.toString();\n+    }\n+\n+    /**\n      * Pulls the next run of whitespace characters of the queue.\n      */\n     public boolean consumeWhitespace() {\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n             return indexGreaterThan();\n         } else if (tq.matchChomp(\":eq(\")) {\n             return indexEquals();\n-        } else if (tq.matchChomp(\":has(\")) {\n+        } else if (tq.matches(\":has(\")) {\n             return has();\n         } else if (tq.matchChomp(\":contains(\")) {\n             return contains();\n         } else { // unhandled\n-            throw new SelectorParseException(\"Could not parse query \" + query);\n+            throw new SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n         }\n     }\n     \n                 return root.getElementsByAttributeValueContaining(key, tq.chompTo(\"]\"));\n             \n             else\n-                throw new SelectorParseException(\"Could not parse attribute query \" + query);\n+                throw new SelectorParseException(\"Could not parse attribute query '%s': unexpected token at '%s'\", query, tq.remainder());\n         }\n     }\n \n \n     // pseudo selector :has(el)\n     private Elements has() {\n-        String subQuery = tq.chompTo(\")\");\n+        tq.consume(\":has\");\n+        String subQuery = tq.chompBalanced('(',')');\n         Validate.notEmpty(subQuery, \":has(el) subselect must not be empty\");\n \n         return filterForParentsOfDescendants(elements, select(subQuery, elements));\n     }\n     \n     // pseudo selector :contains(text)\n+    // todo: allow escaped ) in there. probably do a balanced match, for convenience of caller\n     private Elements contains() {\n         String searchText = tq.chompTo(\")\");\n         Validate.notEmpty(searchText, \":contains(text) query must not be empty\");\n     }\n \n     public static class SelectorParseException extends IllegalStateException {\n-        public SelectorParseException(String s) {\n-            super(s);\n+        public SelectorParseException(String msg, Object... params) {\n+            super(String.format(msg, params));\n         }\n     }\n }\n--- /dev/null\n+++ b/src/test/java/org/jsoup/parser/TokenQueueTest.java\n+package org.jsoup.parser;\n+\n+import org.junit.Test;\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Token queue tests.\n+ */\n+public class TokenQueueTest {\n+    @Test public void chompBalanced() {\n+        TokenQueue tq = new TokenQueue(\":contains(one (two) three) four\");\n+        String pre = tq.consumeTo(\"(\");\n+        String guts = tq.chompBalanced('(', ')');\n+        String remainder = tq.remainder();\n+\n+        assertEquals(\":contains\", pre);\n+        assertEquals(\"one (two) three\", guts);\n+        assertEquals(\" four\", remainder);\n+    }\n+\n+    @Test public void chompBalancedMatchesAsMuchAsPossible() {\n+        TokenQueue tq = new TokenQueue(\"unbalanced(something(or another\");\n+        tq.consumeTo(\"(\");\n+        String match = tq.chompBalanced('(', ')');\n+        assertEquals(\"something(or another\", match);\n+    }\n+}\n--- a/src/test/java/org/jsoup/select/SelectorTest.java\n+++ b/src/test/java/org/jsoup/select/SelectorTest.java\n         assertEquals(\"1\", divs3.get(1).id());\n         assertEquals(\"2\", divs3.get(2).id());\n     }\n+\n+    @Test public void testNestedHas() {\n+        Document doc = Jsoup.parse(\"<div><p><span>One</span></p></div> <div><p>Two</p></div>\");\n+        Elements divs = doc.select(\"div:has(p:has(span))\");\n+        assertEquals(1, divs.size());\n+        assertEquals(\"One\", divs.first().text());\n+    }\n     \n     @Test public void testPseudoContains() {\n         Document doc = Jsoup.parse(\"<div><p>The Rain.</p> <p class=light>The <i>rain</i>.</p> <p>Rain, the.</p></div>\");", "timestamp": 1309605114, "metainfo": ""}