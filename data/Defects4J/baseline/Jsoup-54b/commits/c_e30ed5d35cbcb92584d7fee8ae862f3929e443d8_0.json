{"sha": "e30ed5d35cbcb92584d7fee8ae862f3929e443d8", "log": "Fix Java 1.5 compatibility", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/jsoup/helper/DescendableLinkedList.java\n+package org.jsoup.helper;\n+\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+\n+\n+/**\n+ * Provides a descending iterator and other 1.6 methods to allow support on the 1.5 JRE.\n+ */\n+public class DescendableLinkedList<E> extends LinkedList<E> {\n+\n+    /**\n+     * Create a new DescendableLinkedList.\n+     */\n+    public DescendableLinkedList() {\n+        super();\n+    }\n+\n+    /**\n+     * Add a new element to the start of the list.\n+     * @param e element to add\n+     */\n+    public void push(E e) {\n+        addFirst(e);\n+    }\n+\n+    /**\n+     * Look at the last element, if there is one.\n+     * @return the last element, or null\n+     */\n+    public E peekLast() {\n+        return size() == 0 ? null : getLast();\n+    }\n+\n+    /**\n+     * Remove and return the last element, if there is one\n+     * @return the last element, or null\n+     */\n+    public E pollLast() {\n+        return size() == 0 ? null : removeLast();\n+    }\n+\n+    /**\n+     * Get an iterator that starts and the end of the list and works towards the start.\n+     * @return an iterator that starts and the end of the list and works towards the start.\n+     */\n+    public Iterator<E> descendingIterator() {\n+        return new DescendingIterator<E>(size());\n+    }\n+\n+    private class DescendingIterator<E> implements Iterator<E> {\n+        private final ListIterator<E> iter;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private DescendingIterator(int index) {\n+            iter = (ListIterator<E>) listIterator(index);\n+        }\n+\n+        public boolean hasNext() {\n+            return iter.hasPrevious();\n+        }\n+\n+        public E next() {\n+            return iter.previous();\n+        }\n+\n+        public void remove() {\n+            iter.remove();\n+        }\n+    }\n+}\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n         }\n \n         String name() {\n-            Validate.isFalse(tagName.isEmpty());\n+            Validate.isFalse(tagName.length() == 0);\n             return tagName;\n         }\n \n--- a/src/main/java/org/jsoup/parser/TreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilder.java\n package org.jsoup.parser;\n \n+import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.helper.Validate;\n import org.jsoup.nodes.*;\n     private TreeBuilderState state; // the current state\n     private TreeBuilderState originalState; // original / marked state\n     private Document doc; // current doc we are building into\n-    private LinkedList<Element> stack; // the stack of open elements\n+    private DescendableLinkedList<Element> stack; // the stack of open elements\n \n     private String baseUri; // current base uri, for creating new elements\n     private Token currentToken; // currentToken is used only for error tracking.\n     private Element headElement; // the current head element\n     private Element formElement; // the current form element\n     private Element contextElement; // fragment parse context -- could be null even if fragment parsing\n-    private LinkedList<Element> formattingElements = new LinkedList<Element>(); // active (open) formatting elements\n+    private DescendableLinkedList<Element> formattingElements = new DescendableLinkedList<Element>(); // active (open) formatting elements\n     private List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); // chars in table to be shifted out\n \n     private boolean framesetOk = true; // if ok to go into frameset\n         doc = new Document(baseUri);\n         reader = new CharacterReader(input);\n         tokeniser = new Tokeniser(reader);\n-        stack = new LinkedList<Element>();\n+        stack = new DescendableLinkedList<Element>();\n         this.baseUri = baseUri;\n     }\n \n         stack.add(element);\n     }\n \n-    LinkedList<Element> getStack() {\n+    DescendableLinkedList<Element> getStack() {\n         return stack;\n     }\n \n         return isElementInQueue(stack, el);\n     }\n \n-    private boolean isElementInQueue(LinkedList<Element> queue, Element element) {\n+    private boolean isElementInQueue(DescendableLinkedList<Element> queue, Element element) {\n         Iterator<Element> it = queue.descendingIterator();\n         while (it.hasNext()) {\n             Element next = it.next();\n--- a/src/main/java/org/jsoup/parser/TreeBuilderState.java\n+++ b/src/main/java/org/jsoup/parser/TreeBuilderState.java\n package org.jsoup.parser;\n \n+import org.jsoup.helper.DescendableLinkedList;\n import org.jsoup.helper.StringUtil;\n import org.jsoup.nodes.*;\n \n \n         boolean anyOtherEndTag(Token t, TreeBuilder tb) {\n             String name = t.asEndTag().name();\n-            LinkedList<Element> stack = tb.getStack();\n+            DescendableLinkedList<Element> stack = tb.getStack();\n             Iterator<Element> it = stack.descendingIterator();\n             while (it.hasNext()) {\n                 Element node = it.next();", "timestamp": 1309605130, "metainfo": ""}