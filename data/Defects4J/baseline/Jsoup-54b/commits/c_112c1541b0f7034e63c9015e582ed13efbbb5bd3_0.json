{"sha": "112c1541b0f7034e63c9015e582ed13efbbb5bd3", "log": "removing char boxing", "commit": "\n--- a/src/main/java/org/jsoup/parser/Parser.java\n+++ b/src/main/java/org/jsoup/parser/Parser.java\n     private void parseTextNode() {\n         TextNode textNode;\n         // special case: handle string like \"hello < there\". first char will be \"<\", because of matchStartTag\n-        if (tq.peek().equals('<')) {\n+        if (tq.peek() =='<') {\n             tq.advance();\n             textNode = new TextNode(\"<\", baseUri);\n         } else {\n--- a/src/main/java/org/jsoup/parser/TokenQueue.java\n+++ b/src/main/java/org/jsoup/parser/TokenQueue.java\n \n     /**\n      * Retrieves but does not remove the first character from the queue.\n-     * @return First character, or null if empty.\n-     */\n-    public Character peek() {\n-        return isEmpty() ? null : queue.charAt(pos);\n+     * @return First character, or 0 if empty.\n+     */\n+    public char peek() {\n+        return isEmpty() ? 0 : queue.charAt(pos);\n     }\n \n     /**\n      * Consume one character off queue.\n      * @return first character on queue.\n      */\n-    public Character consume() {\n-        Character c = queue.charAt(pos);\n+    public char consume() {\n+        char c = queue.charAt(pos);\n         pos++;\n         return c;\n     }\n--- a/src/main/java/org/jsoup/select/Selector.java\n+++ b/src/main/java/org/jsoup/select/Selector.java\n         \n         if (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\n             elements.add(root);\n-            combinator(tq.consume().toString());\n+            combinator(tq.consume());\n         } else if (tq.matches(\":has(\")) {\n             elements.addAll(root.getAllElements());\n         } else {\n                     elements.addAll(select(subQuery, root));\n                 }\n             } else if (tq.matchesAny(combinators)) {\n-                combinator(tq.consume().toString());\n+                combinator(tq.consume());\n             } else if (seenWhite) {\n-                combinator(\" \");\n+                combinator(' ');\n             } else { // E.class, E#id, E[attr] etc. AND\n                 Elements candidates = findElements(); // take next el, #. etc off queue\n                 intersectElements(filterForSelf(elements, candidates));\n         return new Elements(elements);\n     }\n     \n-    private void combinator(String combinator) {\n+    private void combinator(char combinator) {\n         tq.consumeWhitespace();\n         String subQuery = tq.consumeToAny(combinators); // support multi > childs\n         \n         Elements output;\n-        if (combinator.equals(\">\"))\n+        if (combinator == '>')\n             output = filterForChildren(elements, select(subQuery, elements));\n-        else if (combinator.equals(\" \"))\n+        else if (combinator == ' ')\n             output = filterForDescendants(elements, select(subQuery, elements));\n-        else if (combinator.equals(\"+\"))\n+        else if (combinator == '+')\n             output = filterForAdjacentSiblings(elements, select(subQuery, root));\n-        else if (combinator.equals(\"~\"))\n+        else if (combinator == '~')\n             output = filterForGeneralSiblings(elements, select(subQuery, root));\n         else\n             throw new IllegalStateException(\"Unknown combinator: \" + combinator);", "timestamp": 1309605124, "metainfo": ""}