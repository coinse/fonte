{"sha": "1166ca605bcc035654771f1ddc1092d86f2ec1e8", "log": "No functional changes are contained in this commit: reformatted Java code to fix several formatting inconsistencies (between classes and within the same class); sorry for the big commit, but I have preferred to isolate into one commit all the formatting changes.  ", "commit": "\n--- a/src/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/java/org/apache/commons/csv/CSVParser.java\n  *\n  * Because CSV appears in many different dialects, the parser supports many\n  * configuration settings by allowing the specification of a {@link CSVStrategy}.\n- * \n+ *\n  * <p>Parsing of a csv-string having tabs as separators,\n  * '\"' as an optional value encapsulator, and comments starting with '#':</p>\n  * <pre>\n- *  String[][] data = \n+ *  String[][] data =\n  *   (new CSVParser(new StringReader(\"a\\tb\\nc\\td\"), new CSVStrategy('\\t','\"','#'))).getAllValues();\n  * </pre>\n- * \n+ *\n  * <p>Parsing of a csv-string in Excel CSV format</p>\n  * <pre>\n  *  String[][] data =\n  *   (new CSVParser(new StringReader(\"a;b\\nc;d\"), CSVStrategy.EXCEL_STRATEGY)).getAllValues();\n  * </pre>\n- * \n+ *\n  * <p>\n  * Internal parser state is completely covered by the strategy\n  * and the reader-state.</p>\n- * \n- * <p>see <a href=\"package-summary.html\">package documentation</a> \n+ *\n+ * <p>see <a href=\"package-summary.html\">package documentation</a>\n  * for more details</p>\n  */\n public class CSVParser {\n \n-  /** length of the initial token (content-)buffer */\n-  private static final int INITIAL_TOKEN_LENGTH = 50;\n-  \n-  // the token types\n-  /** Token has no valid content, i.e. is in its initialized state. */\n-  protected static final int TT_INVALID = -1;\n-  /** Token with content, at beginning or in the middle of a line. */\n-  protected static final int TT_TOKEN = 0;\n-  /** Token (which can have content) when end of file is reached. */\n-  protected static final int TT_EOF = 1;\n-  /** Token with content when end of a line is reached. */\n-  protected static final int TT_EORECORD = 2;\n-\n-  /** Immutable empty String array. */\n-  private static final String[] EMPTY_STRING_ARRAY = new String[0];\n-   \n-  // the input stream\n-  private final ExtendedBufferedReader in;\n-\n-  private final CSVStrategy strategy;\n-  \n-  // the following objects are shared to reduce garbage \n-  /** A record buffer for getLine(). Grows as necessary and is reused. */\n-  private final ArrayList record = new ArrayList();\n-  private final Token reusableToken = new Token();\n-  private final CharBuffer wsBuf = new CharBuffer();\n-  private final CharBuffer code = new CharBuffer(4);\n-\n-  \n-  /**\n-   * Token is an internal token representation.\n-   * \n-   * It is used as contract between the lexer and the parser. \n-   */\n-  static class Token {\n-    /** Token type, see TT_xxx constants. */\n-    int type = TT_INVALID;\n-    /** The content buffer. */\n-    CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);\n-    /** Token ready flag: indicates a valid token with content (ready for the parser). */\n-    boolean isReady;\n-    \n-    Token reset() {\n-        content.clear();\n-        type = TT_INVALID;\n-        isReady = false;\n-        return this;\n-    }\n-  }\n-  \n-  // ======================================================\n-  //  the constructor\n-  // ======================================================\n-  \n-  /**\n-   * Default strategy for the parser follows the default {@link CSVStrategy}.\n-   * \n-   * @param input an InputStream containing \"csv-formatted\" stream\n-   * @deprecated use {@link #CSVParser(Reader)}.\n-   */\n-  public CSVParser(InputStream input) {\n-    this(new InputStreamReader(input));\n-  }\n-  \n-  /**\n-   * CSV parser using the default {@link CSVStrategy}.\n-   * \n-   * @param input a Reader containing \"csv-formatted\" input\n-   */\n-  public CSVParser(Reader input) {\n-    this(input, (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone());\n-  }\n-  \n-  /**\n-   * Customized value delimiter parser.\n-   * \n-   * The parser follows the default {@link CSVStrategy}\n-   * except for the delimiter setting.\n-   * \n-   * @param input a Reader based on \"csv-formatted\" input\n-   * @param delimiter a Char used for value separation\n-   * @deprecated use {@link #CSVParser(Reader,CSVStrategy)}.\n-   */\n-  public CSVParser(Reader input, char delimiter) {\n-    this(input, delimiter, '\"', CSVStrategy.COMMENTS_DISABLED);\n-  }\n-  \n-  /**\n-   * Customized csv parser.\n-   * \n-   * The parser parses according to the given CSV dialect settings.\n-   * Leading whitespaces are truncated, unicode escapes are\n-   * not interpreted and empty lines are ignored.\n-   * \n-   * @param input a Reader based on \"csv-formatted\" input\n-   * @param delimiter a Char used for value separation\n-   * @param encapsulator a Char used as value encapsulation marker\n-   * @param commentStart a Char used for comment identification\n-   * @deprecated use {@link #CSVParser(Reader,CSVStrategy)}.\n-   */\n-  public CSVParser(Reader input, char delimiter, char encapsulator, char commentStart) {\n-    this(input, new CSVStrategy(delimiter, encapsulator, commentStart));\n-  }\n-\n-  /**\n-   * Customized CSV parser using the given {@link CSVStrategy}\n-   *\n-   * @param input a Reader containing \"csv-formatted\" input\n-   * @param strategy the CSVStrategy used for CSV parsing\n-   */\n-  public CSVParser(Reader input, CSVStrategy strategy) {\n-    this.in = new ExtendedBufferedReader(input);\n-    this.strategy = strategy;\n-  }\n-  \n-  // ======================================================\n-  //  the parser\n-  // ======================================================\n-  \n-  /**\n-   * Parses the CSV according to the given strategy\n-   * and returns the content as an array of records\n-   * (whereas records are arrays of single values).\n-   * <p>\n-   * The returned content starts at the current parse-position in\n-   * the stream.\n-   * \n-   * @return matrix of records x values ('null' when end of file)\n-   * @throws IOException on parse error or input read-failure\n-   */\n-  public String[][] getAllValues() throws IOException {\n-    ArrayList records = new ArrayList();\n-    String[] values;\n-    String[][] ret = null;\n-    while ((values = getLine()) != null)  {\n-      records.add(values);\n-    }\n-    if (records.size() > 0) {\n-      ret = new String[records.size()][];\n-      records.toArray(ret);\n-    }\n-    return ret;\n-  }\n-  \n-  /**\n-   * Parses the CSV according to the given strategy\n-   * and returns the next csv-value as string.\n-   * \n-   * @return next value in the input stream ('null' when end of file)\n-   * @throws IOException on parse error or input read-failure\n-   */\n-  public String nextValue() throws IOException {\n-    Token tkn = nextToken();\n-    String ret = null;\n-    switch (tkn.type) {\n-      case TT_TOKEN:\n-      case TT_EORECORD: \n-        ret = tkn.content.toString();\n-        break;\n-      case TT_EOF:\n-        ret = null;\n-        break;\n-      case TT_INVALID:\n-      default:\n-        // error no token available (or error)\n-        throw new IOException(\n-          \"(line \" + getLineNumber() \n-          + \") invalid parse sequence\");\n-        // unreachable: break;\n-    }\n-    return ret;\n-  }\n-  \n-  /**\n-   * Parses from the current point in the stream til\n-   * the end of the current line.\n-   * \n-   * @return array of values til end of line \n-   *        ('null' when end of file has been reached)\n-   * @throws IOException on parse error or input read-failure\n-   */\n-  public String[] getLine() throws IOException {\n-    String[] ret = EMPTY_STRING_ARRAY;\n-    record.clear();\n-    while (true) {\n-        reusableToken.reset();\n-        nextToken(reusableToken);\n-        switch (reusableToken.type) {\n+    /**\n+     * length of the initial token (content-)buffer\n+     */\n+    private static final int INITIAL_TOKEN_LENGTH = 50;\n+\n+    // the token types\n+    /**\n+     * Token has no valid content, i.e. is in its initialized state.\n+     */\n+    protected static final int TT_INVALID = -1;\n+    /**\n+     * Token with content, at beginning or in the middle of a line.\n+     */\n+    protected static final int TT_TOKEN = 0;\n+    /**\n+     * Token (which can have content) when end of file is reached.\n+     */\n+    protected static final int TT_EOF = 1;\n+    /**\n+     * Token with content when end of a line is reached.\n+     */\n+    protected static final int TT_EORECORD = 2;\n+\n+    /**\n+     * Immutable empty String array.\n+     */\n+    private static final String[] EMPTY_STRING_ARRAY = new String[0];\n+\n+    // the input stream\n+    private final ExtendedBufferedReader in;\n+\n+    private final CSVStrategy strategy;\n+\n+    // the following objects are shared to reduce garbage\n+    /**\n+     * A record buffer for getLine(). Grows as necessary and is reused.\n+     */\n+    private final ArrayList record = new ArrayList();\n+    private final Token reusableToken = new Token();\n+    private final CharBuffer wsBuf = new CharBuffer();\n+    private final CharBuffer code = new CharBuffer(4);\n+\n+\n+    /**\n+     * Token is an internal token representation.\n+     * <p/>\n+     * It is used as contract between the lexer and the parser.\n+     */\n+    static class Token {\n+        /**\n+         * Token type, see TT_xxx constants.\n+         */\n+        int type = TT_INVALID;\n+        /**\n+         * The content buffer.\n+         */\n+        CharBuffer content = new CharBuffer(INITIAL_TOKEN_LENGTH);\n+        /**\n+         * Token ready flag: indicates a valid token with content (ready for the parser).\n+         */\n+        boolean isReady;\n+\n+        Token reset() {\n+            content.clear();\n+            type = TT_INVALID;\n+            isReady = false;\n+            return this;\n+        }\n+    }\n+\n+    // ======================================================\n+    //  the constructor\n+    // ======================================================\n+\n+    /**\n+     * Default strategy for the parser follows the default {@link CSVStrategy}.\n+     *\n+     * @param input an InputStream containing \"csv-formatted\" stream\n+     * @deprecated use {@link #CSVParser(Reader)}.\n+     */\n+    public CSVParser(InputStream input) {\n+        this(new InputStreamReader(input));\n+    }\n+\n+    /**\n+     * CSV parser using the default {@link CSVStrategy}.\n+     *\n+     * @param input a Reader containing \"csv-formatted\" input\n+     */\n+    public CSVParser(Reader input) {\n+        this(input, (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone());\n+    }\n+\n+    /**\n+     * Customized value delimiter parser.\n+     * <p/>\n+     * The parser follows the default {@link CSVStrategy}\n+     * except for the delimiter setting.\n+     *\n+     * @param input     a Reader based on \"csv-formatted\" input\n+     * @param delimiter a Char used for value separation\n+     * @deprecated use {@link #CSVParser(Reader, CSVStrategy)}.\n+     */\n+    public CSVParser(Reader input, char delimiter) {\n+        this(input, delimiter, '\"', CSVStrategy.COMMENTS_DISABLED);\n+    }\n+\n+    /**\n+     * Customized csv parser.\n+     * <p/>\n+     * The parser parses according to the given CSV dialect settings.\n+     * Leading whitespaces are truncated, unicode escapes are\n+     * not interpreted and empty lines are ignored.\n+     *\n+     * @param input        a Reader based on \"csv-formatted\" input\n+     * @param delimiter    a Char used for value separation\n+     * @param encapsulator a Char used as value encapsulation marker\n+     * @param commentStart a Char used for comment identification\n+     * @deprecated use {@link #CSVParser(Reader, CSVStrategy)}.\n+     */\n+    public CSVParser(Reader input, char delimiter, char encapsulator, char commentStart) {\n+        this(input, new CSVStrategy(delimiter, encapsulator, commentStart));\n+    }\n+\n+    /**\n+     * Customized CSV parser using the given {@link CSVStrategy}\n+     *\n+     * @param input    a Reader containing \"csv-formatted\" input\n+     * @param strategy the CSVStrategy used for CSV parsing\n+     */\n+    public CSVParser(Reader input, CSVStrategy strategy) {\n+        this.in = new ExtendedBufferedReader(input);\n+        this.strategy = strategy;\n+    }\n+\n+    // ======================================================\n+    //  the parser\n+    // ======================================================\n+\n+    /**\n+     * Parses the CSV according to the given strategy\n+     * and returns the content as an array of records\n+     * (whereas records are arrays of single values).\n+     * <p/>\n+     * The returned content starts at the current parse-position in\n+     * the stream.\n+     *\n+     * @return matrix of records x values ('null' when end of file)\n+     * @throws IOException on parse error or input read-failure\n+     */\n+    public String[][] getAllValues() throws IOException {\n+        ArrayList records = new ArrayList();\n+        String[] values;\n+        String[][] ret = null;\n+        while ((values = getLine()) != null) {\n+            records.add(values);\n+        }\n+        if (records.size() > 0) {\n+            ret = new String[records.size()][];\n+            records.toArray(ret);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Parses the CSV according to the given strategy\n+     * and returns the next csv-value as string.\n+     *\n+     * @return next value in the input stream ('null' when end of file)\n+     * @throws IOException on parse error or input read-failure\n+     */\n+    public String nextValue() throws IOException {\n+        Token tkn = nextToken();\n+        String ret = null;\n+        switch (tkn.type) {\n             case TT_TOKEN:\n-                record.add(reusableToken.content.toString());\n-                break;\n             case TT_EORECORD:\n-                record.add(reusableToken.content.toString());\n+                ret = tkn.content.toString();\n                 break;\n             case TT_EOF:\n-                if (reusableToken.isReady) {\n-                    record.add(reusableToken.content.toString());\n-                } else {\n-                    ret = null;\n-                }\n+                ret = null;\n                 break;\n             case TT_INVALID:\n             default:\n-                // error: throw IOException\n-                throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n-            // unreachable: break;\n-        }\n-        if (reusableToken.type != TT_TOKEN) {\n-            break;\n-        }\n-    }\n-    if (!record.isEmpty()) {\n-      ret = (String[]) record.toArray(new String[record.size()]);\n-    }\n-    return ret;\n-  }\n-  \n-  /**\n-   * Returns the current line number in the input stream.\n-   * \n-   * ATTENTION: in case your csv has multiline-values the returned\n-   *            number does not correspond to the record-number\n-   * \n-   * @return  current line number\n-   */\n-  public int getLineNumber() {\n-    return in.getLineNumber();  \n-  }\n-  \n-  // ======================================================\n-  //  the lexer(s)\n-  // ======================================================\n- \n-  /**\n-   * Convenience method for <code>nextToken(null)</code>.\n-   */\n-  protected Token nextToken() throws IOException {\n-      return nextToken(new Token());\n-  }\n-  \n- /**\n-   * Returns the next token.\n-   * \n-   * A token corresponds to a term, a record change or an\n-   * end-of-file indicator.\n-   * \n-   * @param tkn an existing Token object to reuse. The caller is responsible to initialize the\n-   * Token.\n-   * @return the next token found\n-   * @throws IOException on stream access error\n-   */\n-  protected Token nextToken(Token tkn) throws IOException {\n-    wsBuf.clear(); // reuse\n-    \n-    // get the last read char (required for empty line detection)\n-    int lastChar = in.readAgain();\n-    \n-    //  read the next char and set eol\n-    /* note: unfortunately isEndOfLine may consumes a character silently.\n-     *       this has no effect outside of the method. so a simple workaround\n-     *       is to call 'readAgain' on the stream...\n-     *       uh: might using objects instead of base-types (jdk1.5 autoboxing!)\n-     */\n-    int c = in.read();\n-    boolean eol = isEndOfLine(c);\n-    c = in.readAgain();\n-     \n-    //  empty line detection: eol AND (last char was EOL or beginning)\n-    while (strategy.getIgnoreEmptyLines() && eol \n-      && (lastChar == '\\n' \n-      || lastChar == '\\r' \n-      || lastChar == ExtendedBufferedReader.UNDEFINED) \n-      && !isEndOfFile(lastChar)) {\n-      // go on char ahead ...\n-      lastChar = c;\n-      c = in.read();\n-      eol = isEndOfLine(c);\n-      c = in.readAgain();\n-      // reached end of file without any content (empty line at the end)\n-      if (isEndOfFile(c)) {\n-        tkn.type = TT_EOF;\n+                // error no token available (or error)\n+                throw new IOException(\n+                        \"(line \" + getLineNumber()\n+                                + \") invalid parse sequence\");\n+                // unreachable: break;\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Parses from the current point in the stream til\n+     * the end of the current line.\n+     *\n+     * @return array of values til end of line\n+     *         ('null' when end of file has been reached)\n+     * @throws IOException on parse error or input read-failure\n+     */\n+    public String[] getLine() throws IOException {\n+        String[] ret = EMPTY_STRING_ARRAY;\n+        record.clear();\n+        while (true) {\n+            reusableToken.reset();\n+            nextToken(reusableToken);\n+            switch (reusableToken.type) {\n+                case TT_TOKEN:\n+                    record.add(reusableToken.content.toString());\n+                    break;\n+                case TT_EORECORD:\n+                    record.add(reusableToken.content.toString());\n+                    break;\n+                case TT_EOF:\n+                    if (reusableToken.isReady) {\n+                        record.add(reusableToken.content.toString());\n+                    } else {\n+                        ret = null;\n+                    }\n+                    break;\n+                case TT_INVALID:\n+                default:\n+                    // error: throw IOException\n+                    throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n+                    // unreachable: break;\n+            }\n+            if (reusableToken.type != TT_TOKEN) {\n+                break;\n+            }\n+        }\n+        if (!record.isEmpty()) {\n+            ret = (String[]) record.toArray(new String[record.size()]);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns the current line number in the input stream.\n+     * <p/>\n+     * ATTENTION: in case your csv has multiline-values the returned\n+     * number does not correspond to the record-number\n+     *\n+     * @return current line number\n+     */\n+    public int getLineNumber() {\n+        return in.getLineNumber();\n+    }\n+\n+    // ======================================================\n+    //  the lexer(s)\n+    // ======================================================\n+\n+    /**\n+     * Convenience method for <code>nextToken(null)</code>.\n+     */\n+    protected Token nextToken() throws IOException {\n+        return nextToken(new Token());\n+    }\n+\n+    /**\n+     * Returns the next token.\n+     * <p/>\n+     * A token corresponds to a term, a record change or an\n+     * end-of-file indicator.\n+     *\n+     * @param tkn an existing Token object to reuse. The caller is responsible to initialize the\n+     *            Token.\n+     * @return the next token found\n+     * @throws IOException on stream access error\n+     */\n+    protected Token nextToken(Token tkn) throws IOException {\n+        wsBuf.clear(); // reuse\n+\n+        // get the last read char (required for empty line detection)\n+        int lastChar = in.readAgain();\n+\n+        //  read the next char and set eol\n+        /* note: unfortunately isEndOfLine may consumes a character silently.\n+        *       this has no effect outside of the method. so a simple workaround\n+        *       is to call 'readAgain' on the stream...\n+        *       uh: might using objects instead of base-types (jdk1.5 autoboxing!)\n+        */\n+        int c = in.read();\n+        boolean eol = isEndOfLine(c);\n+        c = in.readAgain();\n+\n+        //  empty line detection: eol AND (last char was EOL or beginning)\n+        while (strategy.getIgnoreEmptyLines() && eol\n+                && (lastChar == '\\n'\n+                || lastChar == '\\r'\n+                || lastChar == ExtendedBufferedReader.UNDEFINED)\n+                && !isEndOfFile(lastChar)) {\n+            // go on char ahead ...\n+            lastChar = c;\n+            c = in.read();\n+            eol = isEndOfLine(c);\n+            c = in.readAgain();\n+            // reached end of file without any content (empty line at the end)\n+            if (isEndOfFile(c)) {\n+                tkn.type = TT_EOF;\n+                return tkn;\n+            }\n+        }\n+\n+        // did we reach eof during the last iteration already ? TT_EOF\n+        if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {\n+            tkn.type = TT_EOF;\n+            return tkn;\n+        }\n+\n+        //  important: make sure a new char gets consumed in each iteration\n+        while (!tkn.isReady && tkn.type != TT_EOF) {\n+            // ignore whitespaces at beginning of a token\n+            while (strategy.getIgnoreLeadingWhitespaces() && isWhitespace(c) && !eol) {\n+                wsBuf.append((char) c);\n+                c = in.read();\n+                eol = isEndOfLine(c);\n+            }\n+            // ok, start of token reached: comment, encapsulated, or token\n+            if (c == strategy.getCommentStart()) {\n+                // ignore everything till end of line and continue (incr linecount)\n+                in.readLine();\n+                tkn = nextToken(tkn.reset());\n+            } else if (c == strategy.getDelimiter()) {\n+                // empty token return TT_TOKEN(\"\")\n+                tkn.type = TT_TOKEN;\n+                tkn.isReady = true;\n+            } else if (eol) {\n+                // empty token return TT_EORECORD(\"\")\n+                //noop: tkn.content.append(\"\");\n+                tkn.type = TT_EORECORD;\n+                tkn.isReady = true;\n+            } else if (c == strategy.getEncapsulator()) {\n+                // consume encapsulated token\n+                encapsulatedTokenLexer(tkn, c);\n+            } else if (isEndOfFile(c)) {\n+                // end of file return TT_EOF()\n+                //noop: tkn.content.append(\"\");\n+                tkn.type = TT_EOF;\n+                tkn.isReady = true;\n+            } else {\n+                // next token must be a simple token\n+                // add removed blanks when not ignoring whitespace chars...\n+                if (!strategy.getIgnoreLeadingWhitespaces()) {\n+                    tkn.content.append(wsBuf);\n+                }\n+                simpleTokenLexer(tkn, c);\n+            }\n+        }\n         return tkn;\n-      }\n-    }\n-\n-    // did we reach eof during the last iteration already ? TT_EOF\n-    if (isEndOfFile(lastChar) || (lastChar != strategy.getDelimiter() && isEndOfFile(c))) {\n-      tkn.type = TT_EOF;\n-      return tkn;\n-    } \n-    \n-    //  important: make sure a new char gets consumed in each iteration\n-    while (!tkn.isReady && tkn.type != TT_EOF) {\n-      // ignore whitespaces at beginning of a token\n-      while (strategy.getIgnoreLeadingWhitespaces() && isWhitespace(c) && !eol) {\n-        wsBuf.append((char) c);\n+    }\n+\n+    /**\n+     * A simple token lexer\n+     * <p/>\n+     * Simple token are tokens which are not surrounded by encapsulators.\n+     * A simple token might contain escaped delimiters (as \\, or \\;). The\n+     * token is finished when one of the following conditions become true:\n+     * <ul>\n+     * <li>end of line has been reached (TT_EORECORD)</li>\n+     * <li>end of stream has been reached (TT_EOF)</li>\n+     * <li>an unescaped delimiter has been reached (TT_TOKEN)</li>\n+     * </ul>\n+     *\n+     * @param tkn the current token\n+     * @param c   the current character\n+     * @return the filled token\n+     * @throws IOException on stream access error\n+     */\n+    private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n+        for (; ;) {\n+            if (isEndOfLine(c)) {\n+                // end of record\n+                tkn.type = TT_EORECORD;\n+                tkn.isReady = true;\n+                break;\n+            } else if (isEndOfFile(c)) {\n+                // end of file\n+                tkn.type = TT_EOF;\n+                tkn.isReady = true;\n+                break;\n+            } else if (c == strategy.getDelimiter()) {\n+                // end of token\n+                tkn.type = TT_TOKEN;\n+                tkn.isReady = true;\n+                break;\n+            } else if (c == '\\\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {\n+                // interpret unicode escaped chars (like \\u0070 -> p)\n+                tkn.content.append((char) unicodeEscapeLexer(c));\n+            } else if (c == strategy.getEscape()) {\n+                tkn.content.append((char) readEscape(c));\n+            } else {\n+                tkn.content.append((char) c);\n+            }\n+\n+            c = in.read();\n+        }\n+\n+        if (strategy.getIgnoreTrailingWhitespaces()) {\n+            tkn.content.trimTrailingWhitespace();\n+        }\n+\n+        return tkn;\n+    }\n+\n+\n+    /**\n+     * An encapsulated token lexer\n+     * <p/>\n+     * Encapsulated tokens are surrounded by the given encapsulating-string.\n+     * The encapsulator itself might be included in the token using a\n+     * doubling syntax (as \"\", '') or using escaping (as in \\\", \\').\n+     * Whitespaces before and after an encapsulated token are ignored.\n+     *\n+     * @param tkn the current token\n+     * @param c   the current character\n+     * @return a valid token object\n+     * @throws IOException on invalid state\n+     */\n+    private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {\n+        // save current line\n+        int startLineNumber = getLineNumber();\n+        // ignore the given delimiter\n+        // assert c == delimiter;\n+        for (; ;) {\n+            c = in.read();\n+\n+            if (c == '\\\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {\n+                tkn.content.append((char) unicodeEscapeLexer(c));\n+            } else if (c == strategy.getEscape()) {\n+                tkn.content.append((char) readEscape(c));\n+            } else if (c == strategy.getEncapsulator()) {\n+                if (in.lookAhead() == strategy.getEncapsulator()) {\n+                    // double or escaped encapsulator -> add single encapsulator to token\n+                    c = in.read();\n+                    tkn.content.append((char) c);\n+                } else {\n+                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n+                    for (; ;) {\n+                        c = in.read();\n+                        if (c == strategy.getDelimiter()) {\n+                            tkn.type = TT_TOKEN;\n+                            tkn.isReady = true;\n+                            return tkn;\n+                        } else if (isEndOfFile(c)) {\n+                            tkn.type = TT_EOF;\n+                            tkn.isReady = true;\n+                            return tkn;\n+                        } else if (isEndOfLine(c)) {\n+                            // ok eo token reached\n+                            tkn.type = TT_EORECORD;\n+                            tkn.isReady = true;\n+                            return tkn;\n+                        } else if (!isWhitespace(c)) {\n+                            // error invalid char between token and next delimiter\n+                            throw new IOException(\n+                                    \"(line \" + getLineNumber()\n+                                            + \") invalid char between encapsulated token end delimiter\"\n+                            );\n+                        }\n+                    }\n+                }\n+            } else if (isEndOfFile(c)) {\n+                // error condition (end of file before end of token)\n+                throw new IOException(\n+                        \"(startline \" + startLineNumber + \")\"\n+                                + \"eof reached before encapsulated token finished\"\n+                );\n+            } else {\n+                // consume character\n+                tkn.content.append((char) c);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Decodes Unicode escapes.\n+     * <p/>\n+     * Interpretation of \"\\\\uXXXX\" escape sequences\n+     * where XXXX is a hex-number.\n+     *\n+     * @param c current char which is discarded because it's the \"\\\\\" of \"\\\\uXXXX\"\n+     * @return the decoded character\n+     * @throws IOException on wrong unicode escape sequence or read error\n+     */\n+    protected int unicodeEscapeLexer(int c) throws IOException {\n+        int ret = 0;\n+        // ignore 'u' (assume c==\\ now) and read 4 hex digits\n         c = in.read();\n-        eol = isEndOfLine(c);\n-      }\n-      // ok, start of token reached: comment, encapsulated, or token\n-      if (c == strategy.getCommentStart()) {\n-        // ignore everything till end of line and continue (incr linecount)\n-        in.readLine();\n-        tkn = nextToken(tkn.reset());\n-      } else if (c == strategy.getDelimiter()) {\n-        // empty token return TT_TOKEN(\"\")\n-        tkn.type = TT_TOKEN;\n-        tkn.isReady = true;\n-      } else if (eol) {\n-        // empty token return TT_EORECORD(\"\")\n-        //noop: tkn.content.append(\"\");\n-        tkn.type = TT_EORECORD;\n-        tkn.isReady = true;\n-      } else if (c == strategy.getEncapsulator()) {\n-        // consume encapsulated token\n-        encapsulatedTokenLexer(tkn, c);\n-      } else if (isEndOfFile(c)) {\n-        // end of file return TT_EOF()\n-        //noop: tkn.content.append(\"\");\n-        tkn.type = TT_EOF;\n-        tkn.isReady = true;\n-      } else {\n-        // next token must be a simple token\n-        // add removed blanks when not ignoring whitespace chars...\n-        if (!strategy.getIgnoreLeadingWhitespaces()) {\n-          tkn.content.append(wsBuf);\n-        }\n-        simpleTokenLexer(tkn, c);\n-      }\n-    }\n-    return tkn;  \n-  }\n-  \n-  /**\n-   * A simple token lexer\n-   * \n-   * Simple token are tokens which are not surrounded by encapsulators.\n-   * A simple token might contain escaped delimiters (as \\, or \\;). The\n-   * token is finished when one of the following conditions become true:\n-   * <ul>\n-   *   <li>end of line has been reached (TT_EORECORD)</li>\n-   *   <li>end of stream has been reached (TT_EOF)</li>\n-   *   <li>an unescaped delimiter has been reached (TT_TOKEN)</li>\n-   * </ul>\n-   *  \n-   * @param tkn  the current token\n-   * @param c    the current character\n-   * @return the filled token\n-   * \n-   * @throws IOException on stream access error\n-   */\n-  private Token simpleTokenLexer(Token tkn, int c) throws IOException {\n-    for (;;) {\n-      if (isEndOfLine(c)) {\n-        // end of record\n-        tkn.type = TT_EORECORD;\n-        tkn.isReady = true;\n-        break;\n-      } else if (isEndOfFile(c)) {\n-        // end of file\n-        tkn.type = TT_EOF;\n-        tkn.isReady = true;\n-        break;\n-      } else if (c == strategy.getDelimiter()) {\n-        // end of token\n-        tkn.type = TT_TOKEN;\n-        tkn.isReady = true;\n-        break;\n-      } else if (c == '\\\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead() == 'u') {\n-        // interpret unicode escaped chars (like \\u0070 -> p)\n-        tkn.content.append((char) unicodeEscapeLexer(c));\n-      } else if (c == strategy.getEscape()) {\n-        tkn.content.append((char)readEscape(c));\n-      } else {\n-        tkn.content.append((char) c);\n-      }\n-      \n-      c = in.read();\n-    }\n-\n-    if (strategy.getIgnoreTrailingWhitespaces()) {\n-      tkn.content.trimTrailingWhitespace();\n-    }\n-\n-    return tkn;\n-  }\n-  \n-  \n-  /**\n-   * An encapsulated token lexer\n-   * \n-   * Encapsulated tokens are surrounded by the given encapsulating-string.\n-   * The encapsulator itself might be included in the token using a\n-   * doubling syntax (as \"\", '') or using escaping (as in \\\", \\').\n-   * Whitespaces before and after an encapsulated token are ignored.\n-   * \n-   * @param tkn    the current token\n-   * @param c      the current character\n-   * @return a valid token object\n-   * @throws IOException on invalid state\n-   */\n-  private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {\n-    // save current line\n-    int startLineNumber = getLineNumber();\n-    // ignore the given delimiter\n-    // assert c == delimiter;\n-    for (;;) {\n-      c = in.read();\n-\n-      if (c == '\\\\' && strategy.getUnicodeEscapeInterpretation() && in.lookAhead()=='u') {\n-        tkn.content.append((char) unicodeEscapeLexer(c));\n-      } else if (c == strategy.getEscape()) {\n-        tkn.content.append((char)readEscape(c));\n-      } else if (c == strategy.getEncapsulator()) {\n-        if (in.lookAhead() == strategy.getEncapsulator()) {\n-          // double or escaped encapsulator -> add single encapsulator to token\n-          c = in.read();\n-          tkn.content.append((char) c);\n-        } else {\n-          // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n-          for (;;) {\n-            c = in.read();\n-            if (c == strategy.getDelimiter()) {\n-              tkn.type = TT_TOKEN;\n-              tkn.isReady = true;\n-              return tkn;\n-            } else if (isEndOfFile(c)) {\n-              tkn.type = TT_EOF;\n-              tkn.isReady = true;\n-              return tkn;\n-            } else if (isEndOfLine(c)) {\n-              // ok eo token reached\n-              tkn.type = TT_EORECORD;\n-              tkn.isReady = true;\n-              return tkn;\n-            } else if (!isWhitespace(c)) {\n-              // error invalid char between token and next delimiter\n-              throw new IOException(\n-                      \"(line \" + getLineNumber()\n-                              + \") invalid char between encapsulated token end delimiter\"\n-              );\n-            }\n-          }\n-        }\n-      } else if (isEndOfFile(c)) {\n-        // error condition (end of file before end of token)\n-        throw new IOException(\n-                \"(startline \" + startLineNumber + \")\"\n-                        + \"eof reached before encapsulated token finished\"\n-        );\n-      } else {\n-        // consume character\n-        tkn.content.append((char) c);\n-      }\n-    }\n-  }\n-  \n-  \n-  /**\n-   * Decodes Unicode escapes.\n-   * \n-   * Interpretation of \"\\\\uXXXX\" escape sequences\n-   * where XXXX is a hex-number.\n-   * @param c current char which is discarded because it's the \"\\\\\" of \"\\\\uXXXX\"\n-   * @return the decoded character\n-   * @throws IOException on wrong unicode escape sequence or read error\n-   */\n-  protected int unicodeEscapeLexer(int c) throws IOException {\n-    int ret = 0;\n-    // ignore 'u' (assume c==\\ now) and read 4 hex digits\n-    c = in.read();\n-    code.clear();\n-    try {\n-      for (int i = 0; i < 4; i++) {\n-        c  = in.read();\n-        if (isEndOfFile(c) || isEndOfLine(c)) {\n-          throw new NumberFormatException(\"number too short\");\n-        }\n-        code.append((char) c);\n-      }\n-      ret = Integer.parseInt(code.toString(), 16);\n-    } catch (NumberFormatException e) {\n-      throw new IOException(\n-        \"(line \" + getLineNumber() + \") Wrong unicode escape sequence found '\" \n-        + code.toString() + \"'\" + e.toString());\n-    }\n-    return ret;\n-  }\n-\n-  private int readEscape(int c) throws IOException {\n-    // assume c is the escape char (normally a backslash)\n-    c = in.read();\n-    int out;\n-    switch (c) {\n-      case 'r': out='\\r'; break;\n-      case 'n': out='\\n'; break;\n-      case 't': out='\\t'; break;\n-      case 'b': out='\\b'; break;\n-      case 'f': out='\\f'; break;\n-      default : out=c;\n-    }\n-    return out;\n-  }\n-  \n-  // ======================================================\n-  //  strategies\n-  // ======================================================\n-  \n-  /**\n-   * Obtain the specified CSV Strategy.  This should not be modified.\n-   * \n-   * @return strategy currently being used\n-   */\n-  public CSVStrategy getStrategy() {\n-    return this.strategy;\n-  }\n-  \n-  // ======================================================\n-  //  Character class checker\n-  // ======================================================\n-  \n-  /**\n-   * @return true if the given char is a whitespace character\n-   */\n-  private boolean isWhitespace(int c) {\n-    return Character.isWhitespace((char) c) && (c != strategy.getDelimiter());\n-  }\n-  \n-  /**\n-   * Greedy - accepts \\n, \\r and \\r\\n \n-   * This checker consumes silently the second control-character...\n-   * \n-   * @return true if the given character is a line-terminator\n-   */\n-  private boolean isEndOfLine(int c) throws IOException {\n-    // check if we have \\r\\n...\n-    if (c == '\\r') {\n-      if (in.lookAhead() == '\\n') {\n-        // note: does not change c outside of this method !!\n+        code.clear();\n+        try {\n+            for (int i = 0; i < 4; i++) {\n+                c = in.read();\n+                if (isEndOfFile(c) || isEndOfLine(c)) {\n+                    throw new NumberFormatException(\"number too short\");\n+                }\n+                code.append((char) c);\n+            }\n+            ret = Integer.parseInt(code.toString(), 16);\n+        } catch (NumberFormatException e) {\n+            throw new IOException(\n+                    \"(line \" + getLineNumber() + \") Wrong unicode escape sequence found '\"\n+                            + code.toString() + \"'\" + e.toString());\n+        }\n+        return ret;\n+    }\n+\n+    private int readEscape(int c) throws IOException {\n+        // assume c is the escape char (normally a backslash)\n         c = in.read();\n-      }\n-    }\n-    return (c == '\\n' || c == '\\r');\n-  }\n-  \n-  /**\n-   * @return true if the given character indicates end of file\n-   */\n-  private boolean isEndOfFile(int c) {\n-    return c == ExtendedBufferedReader.END_OF_STREAM;\n-  }\n+        int out;\n+        switch (c) {\n+            case 'r':\n+                out = '\\r';\n+                break;\n+            case 'n':\n+                out = '\\n';\n+                break;\n+            case 't':\n+                out = '\\t';\n+                break;\n+            case 'b':\n+                out = '\\b';\n+                break;\n+            case 'f':\n+                out = '\\f';\n+                break;\n+            default:\n+                out = c;\n+        }\n+        return out;\n+    }\n+\n+    // ======================================================\n+    //  strategies\n+    // ======================================================\n+\n+    /**\n+     * Obtain the specified CSV Strategy.  This should not be modified.\n+     *\n+     * @return strategy currently being used\n+     */\n+    public CSVStrategy getStrategy() {\n+        return this.strategy;\n+    }\n+\n+    // ======================================================\n+    //  Character class checker\n+    // ======================================================\n+\n+    /**\n+     * @return true if the given char is a whitespace character\n+     */\n+    private boolean isWhitespace(int c) {\n+        return Character.isWhitespace((char) c) && (c != strategy.getDelimiter());\n+    }\n+\n+    /**\n+     * Greedy - accepts \\n, \\r and \\r\\n\n+     * This checker consumes silently the second control-character...\n+     *\n+     * @return true if the given character is a line-terminator\n+     */\n+    private boolean isEndOfLine(int c) throws IOException {\n+        // check if we have \\r\\n...\n+        if (c == '\\r') {\n+            if (in.lookAhead() == '\\n') {\n+                // note: does not change c outside of this method !!\n+                c = in.read();\n+            }\n+        }\n+        return (c == '\\n' || c == '\\r');\n+    }\n+\n+    /**\n+     * @return true if the given character indicates end of file\n+     */\n+    private boolean isEndOfFile(int c) {\n+        return c == ExtendedBufferedReader.END_OF_STREAM;\n+    }\n }\n--- a/src/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/java/org/apache/commons/csv/CSVPrinter.java\n  */\n public class CSVPrinter {\n \n-  /** The place that the values get written. */\n-  protected final Writer out;\n-  protected final CSVStrategy strategy;\n-\n-  /** True if we just began a new line. */\n-  protected boolean newLine = true;\n-\n-  protected char[] buf = new char[0];  // temporary buffer\n-\n-  /**\n-   * Create a printer that will print values to the given\n-   * stream following the CSVStrategy.\n-   *\n-   * Currently, only a pure encapsulation strategy or a pure escaping strategy\n-   * is supported.  Hybrid strategies (encapsulation and escaping with a different character) are not supported.\n-   *\n-   * @param out stream to which to print.\n-   * @param strategy describes the CSV variation.\n-   */\n-  public CSVPrinter(Writer out, CSVStrategy strategy) {\n-    this.out = out;\n-    this.strategy = strategy==null ? CSVStrategy.DEFAULT_STRATEGY : strategy;\n-  }\n-  \n-  // ======================================================\n-  //  printing implementation\n-  // ======================================================\n-\n-  /**\n-   * Output a blank line\n-   */\n-  public void println() throws IOException {\n-    out.write(strategy.getPrinterNewline());\n-    newLine = true;\n-  }\n-\n-  public void flush() throws IOException {\n-    out.flush();\n-  }\n-\n-\n-  /**\n-   * Print a single line of comma separated values.\n-   * The values will be quoted if needed.  Quotes and\n-   * newLine characters will be escaped.\n-   *\n-   * @param values values to be outputted.\n-   */\n-  public void println(String[] values) throws IOException {\n-    for (int i = 0; i < values.length; i++) {\n-      print(values[i]);\n-    }\n-    println();\n-  }\n-\n-\n-  /**\n-   * Put a comment among the comma separated values.\n-   * Comments will always begin on a new line and occupy a\n-   * least one full line. The character specified to star\n-   * comments and a space will be inserted at the beginning of\n-   * each new line in the comment.\n-   *\n-   * @param comment the comment to output\n-   */\n-  public void printlnComment(String comment) throws IOException {\n-    if(this.strategy.isCommentingDisabled()) {\n-        return;\n-    }\n-    if (!newLine) {\n-      println();\n-    }\n-    out.write(this.strategy.getCommentStart());\n-    out.write(' ');\n-    for (int i = 0; i < comment.length(); i++) {\n-      char c = comment.charAt(i);\n-      switch (c) {\n-        case '\\r' :\n-          if (i + 1 < comment.length() && comment.charAt(i + 1) == '\\n') {\n-            i++;\n-          }\n-          // break intentionally excluded.\n-        case '\\n' :\n-          println();\n-          out.write(this.strategy.getCommentStart());\n-          out.write(' ');\n-          break;\n-        default :\n-          out.write(c);\n-          break;\n-      }\n-    }\n-    println();\n-  }\n-\n-\n-  public void print(char[] value, int offset, int len, boolean checkForEscape) throws IOException {\n-    if (!checkForEscape) {\n-      printSep();\n-      out.write(value, offset, len);\n-      return;\n-    }\n-\n-    if (strategy.getEncapsulator() != CSVStrategy.ENCAPSULATOR_DISABLED) {\n-      printAndEncapsulate(value, offset, len);\n-    } else if (strategy.getEscape() != CSVStrategy.ESCAPE_DISABLED) {\n-      printAndEscape(value, offset, len);\n-    } else {\n-      printSep();\n-      out.write(value, offset, len);\n-    }\n-  }\n-\n-  void printSep() throws IOException {\n-    if (newLine) {\n-      newLine = false;\n-    } else {\n-      out.write(this.strategy.getDelimiter());\n-    }\n-  }\n-\n-  void printAndEscape(char[] value, int offset, int len) throws IOException {\n-    int start = offset;\n-    int pos = offset;\n-    int end = offset + len;\n-\n-    printSep();\n-\n-    char delim = this.strategy.getDelimiter();\n-    char escape = this.strategy.getEscape();\n-\n-    while (pos < end) {\n-      char c = value[pos];\n-      if (c == '\\r' || c=='\\n' || c==delim || c==escape) {\n-        // write out segment up until this char\n-        int l = pos-start;\n-        if (l>0) {\n-          out.write(value, start, l);\n-        }\n-        if (c=='\\n') c='n';\n-        else if (c=='\\r') c='r';\n-\n-        out.write(escape);\n-        out.write(c);\n-\n-        start = pos+1; // start on the current char after this one\n-      }\n-\n-      pos++;\n-    }\n-\n-    // write last segment\n-    int l = pos-start;\n-    if (l>0) {\n-      out.write(value, start, l);      \n-    }\n-  }\n-\n-  void printAndEncapsulate(char[] value, int offset, int len) throws IOException {\n-    boolean first = newLine;  // is this the first value on this line?\n-    boolean quote = false;\n-    int start = offset;\n-    int pos = offset;\n-    int end = offset + len;\n-\n-    printSep();    \n-\n-    char delim = this.strategy.getDelimiter();\n-    char encapsulator = this.strategy.getEncapsulator();\n-\n-    if (len <= 0) {\n-      // always quote an empty token that is the first\n-      // on the line, as it may be the only thing on the\n-      // line. If it were not quoted in that case,\n-      // an empty line has no tokens.\n-      if (first) {\n-        quote = true;\n-      }\n-    } else {\n-      char c = value[pos];\n-\n-      // Hmmm, where did this rule come from?\n-      if (first\n-          && (c < '0'\n-          || (c > '9' && c < 'A')\n-          || (c > 'Z' && c < 'a')\n-          || (c > 'z'))) {\n-        quote = true;\n-      // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n-      } else if (c <= '#') {\n-        // Some other chars at the start of a value caused the parser to fail, so for now\n-        // encapsulate if we start in anything less than '#'.  We are being conservative\n-        // by including the default comment char too.\n-        quote = true;\n-      } else {\n+    /**\n+     * The place that the values get written.\n+     */\n+    protected final Writer out;\n+    protected final CSVStrategy strategy;\n+\n+    /**\n+     * True if we just began a new line.\n+     */\n+    protected boolean newLine = true;\n+\n+    protected char[] buf = new char[0];  // temporary buffer\n+\n+    /**\n+     * Create a printer that will print values to the given\n+     * stream following the CSVStrategy.\n+     * <p/>\n+     * Currently, only a pure encapsulation strategy or a pure escaping strategy\n+     * is supported.  Hybrid strategies (encapsulation and escaping with a different character) are not supported.\n+     *\n+     * @param out      stream to which to print.\n+     * @param strategy describes the CSV variation.\n+     */\n+    public CSVPrinter(Writer out, CSVStrategy strategy) {\n+        this.out = out;\n+        this.strategy = strategy == null ? CSVStrategy.DEFAULT_STRATEGY : strategy;\n+    }\n+\n+    // ======================================================\n+    //  printing implementation\n+    // ======================================================\n+\n+    /**\n+     * Output a blank line\n+     */\n+    public void println() throws IOException {\n+        out.write(strategy.getPrinterNewline());\n+        newLine = true;\n+    }\n+\n+    public void flush() throws IOException {\n+        out.flush();\n+    }\n+\n+\n+    /**\n+     * Print a single line of comma separated values.\n+     * The values will be quoted if needed.  Quotes and\n+     * newLine characters will be escaped.\n+     *\n+     * @param values values to be outputted.\n+     */\n+    public void println(String[] values) throws IOException {\n+        for (int i = 0; i < values.length; i++) {\n+            print(values[i]);\n+        }\n+        println();\n+    }\n+\n+\n+    /**\n+     * Put a comment among the comma separated values.\n+     * Comments will always begin on a new line and occupy a\n+     * least one full line. The character specified to star\n+     * comments and a space will be inserted at the beginning of\n+     * each new line in the comment.\n+     *\n+     * @param comment the comment to output\n+     */\n+    public void printlnComment(String comment) throws IOException {\n+        if (this.strategy.isCommentingDisabled()) {\n+            return;\n+        }\n+        if (!newLine) {\n+            println();\n+        }\n+        out.write(this.strategy.getCommentStart());\n+        out.write(' ');\n+        for (int i = 0; i < comment.length(); i++) {\n+            char c = comment.charAt(i);\n+            switch (c) {\n+                case '\\r':\n+                    if (i + 1 < comment.length() && comment.charAt(i + 1) == '\\n') {\n+                        i++;\n+                    }\n+                    // break intentionally excluded.\n+                case '\\n':\n+                    println();\n+                    out.write(this.strategy.getCommentStart());\n+                    out.write(' ');\n+                    break;\n+                default:\n+                    out.write(c);\n+                    break;\n+            }\n+        }\n+        println();\n+    }\n+\n+\n+    public void print(char[] value, int offset, int len, boolean checkForEscape) throws IOException {\n+        if (!checkForEscape) {\n+            printSep();\n+            out.write(value, offset, len);\n+            return;\n+        }\n+\n+        if (strategy.getEncapsulator() != CSVStrategy.ENCAPSULATOR_DISABLED) {\n+            printAndEncapsulate(value, offset, len);\n+        } else if (strategy.getEscape() != CSVStrategy.ESCAPE_DISABLED) {\n+            printAndEscape(value, offset, len);\n+        } else {\n+            printSep();\n+            out.write(value, offset, len);\n+        }\n+    }\n+\n+    void printSep() throws IOException {\n+        if (newLine) {\n+            newLine = false;\n+        } else {\n+            out.write(this.strategy.getDelimiter());\n+        }\n+    }\n+\n+    void printAndEscape(char[] value, int offset, int len) throws IOException {\n+        int start = offset;\n+        int pos = offset;\n+        int end = offset + len;\n+\n+        printSep();\n+\n+        char delim = this.strategy.getDelimiter();\n+        char escape = this.strategy.getEscape();\n+\n         while (pos < end) {\n-          c = value[pos];\n-          if (c=='\\n' || c=='\\r' || c==encapsulator || c==delim) {\n-            quote = true;\n-            break;\n-          }\n-          pos++;\n+            char c = value[pos];\n+            if (c == '\\r' || c == '\\n' || c == delim || c == escape) {\n+                // write out segment up until this char\n+                int l = pos - start;\n+                if (l > 0) {\n+                    out.write(value, start, l);\n+                }\n+                if (c == '\\n') {\n+                    c = 'n';\n+                } else if (c == '\\r') {\n+                    c = 'r';\n+                }\n+\n+                out.write(escape);\n+                out.write(c);\n+\n+                start = pos + 1; // start on the current char after this one\n+            }\n+\n+            pos++;\n+        }\n+\n+        // write last segment\n+        int l = pos - start;\n+        if (l > 0) {\n+            out.write(value, start, l);\n+        }\n+    }\n+\n+    void printAndEncapsulate(char[] value, int offset, int len) throws IOException {\n+        boolean first = newLine;  // is this the first value on this line?\n+        boolean quote = false;\n+        int start = offset;\n+        int pos = offset;\n+        int end = offset + len;\n+\n+        printSep();\n+\n+        char delim = this.strategy.getDelimiter();\n+        char encapsulator = this.strategy.getEncapsulator();\n+\n+        if (len <= 0) {\n+            // always quote an empty token that is the first\n+            // on the line, as it may be the only thing on the\n+            // line. If it were not quoted in that case,\n+            // an empty line has no tokens.\n+            if (first) {\n+                quote = true;\n+            }\n+        } else {\n+            char c = value[pos];\n+\n+            // Hmmm, where did this rule come from?\n+            if (first\n+                    && (c < '0'\n+                    || (c > '9' && c < 'A')\n+                    || (c > 'Z' && c < 'a')\n+                    || (c > 'z'))) {\n+                quote = true;\n+                // } else if (c == ' ' || c == '\\f' || c == '\\t') {\n+            } else if (c <= '#') {\n+                // Some other chars at the start of a value caused the parser to fail, so for now\n+                // encapsulate if we start in anything less than '#'.  We are being conservative\n+                // by including the default comment char too.\n+                quote = true;\n+            } else {\n+                while (pos < end) {\n+                    c = value[pos];\n+                    if (c == '\\n' || c == '\\r' || c == encapsulator || c == delim) {\n+                        quote = true;\n+                        break;\n+                    }\n+                    pos++;\n+                }\n+\n+                if (!quote) {\n+                    pos = end - 1;\n+                    c = value[pos];\n+                    // if (c == ' ' || c == '\\f' || c == '\\t') {\n+                    // Some other chars at the end caused the parser to fail, so for now\n+                    // encapsulate if we end in anything less than ' '\n+                    if (c <= ' ') {\n+                        quote = true;\n+                    }\n+                }\n+            }\n         }\n \n         if (!quote) {\n-          pos = end-1;\n-          c = value[pos];\n-          // if (c == ' ' || c == '\\f' || c == '\\t') {\n-          // Some other chars at the end caused the parser to fail, so for now\n-          // encapsulate if we end in anything less than ' '\n-          if (c <= ' ') {\n-            quote = true;\n-          }\n-        }\n-      }\n-    }\n-\n-    if (!quote) {\n-      // no encapsulation needed - write out the original value\n-      out.write(value, offset, len);\n-      return;\n-    }\n-\n-    // we hit something that needed encapsulation\n-    out.write(encapsulator);\n-\n-    // Pick up where we left off: pos should be positioned on the first character that caused\n-    // the need for encapsulation.\n-    while (pos<end) {\n-      char c = value[pos];\n-      if (c==encapsulator) {\n-        // write out the chunk up until this point\n-\n-        // add 1 to the length to write out the encapsulator also\n-        out.write(value, start, pos-start+1);\n-        // put the next starting position on the encapsulator so we will\n-        // write it out again with the next string (effectively doubling it)\n-        start = pos;\n-      }\n-      pos++;\n-    }\n-\n-    // write the last segment\n-    out.write(value, start, pos-start);\n-    out.write(encapsulator);    \n-  }\n-\n-  /**\n-   * Print the string as the next value on the line. The value\n-   * will be escaped or encapsulated as needed if checkForEscape==true\n-   *\n-   * @param value value to be outputted.\n-   */\n-  public void print(String value, boolean checkForEscape) throws IOException {\n-    if (!checkForEscape) {\n-      // write directly from string\n-      printSep();\n-      out.write(value);\n-      return;\n-    }\n-\n-    if (buf.length < value.length()) {\n-      buf = new char[value.length()];\n-    }\n-\n-    value.getChars(0, value.length(), buf, 0);\n-    print(buf, 0, value.length(), checkForEscape);\n-  }\n-\n-  /**\n-   * Print the string as the next value on the line. The value\n-   * will be escaped or encapsulated as needed.\n-   *\n-   * @param value value to be outputted.\n-   */\n-  public void print(String value) throws IOException {\n-    print(value, true);   \n-  }\n+            // no encapsulation needed - write out the original value\n+            out.write(value, offset, len);\n+            return;\n+        }\n+\n+        // we hit something that needed encapsulation\n+        out.write(encapsulator);\n+\n+        // Pick up where we left off: pos should be positioned on the first character that caused\n+        // the need for encapsulation.\n+        while (pos < end) {\n+            char c = value[pos];\n+            if (c == encapsulator) {\n+                // write out the chunk up until this point\n+\n+                // add 1 to the length to write out the encapsulator also\n+                out.write(value, start, pos - start + 1);\n+                // put the next starting position on the encapsulator so we will\n+                // write it out again with the next string (effectively doubling it)\n+                start = pos;\n+            }\n+            pos++;\n+        }\n+\n+        // write the last segment\n+        out.write(value, start, pos - start);\n+        out.write(encapsulator);\n+    }\n+\n+    /**\n+     * Print the string as the next value on the line. The value\n+     * will be escaped or encapsulated as needed if checkForEscape==true\n+     *\n+     * @param value value to be outputted.\n+     */\n+    public void print(String value, boolean checkForEscape) throws IOException {\n+        if (!checkForEscape) {\n+            // write directly from string\n+            printSep();\n+            out.write(value);\n+            return;\n+        }\n+\n+        if (buf.length < value.length()) {\n+            buf = new char[value.length()];\n+        }\n+\n+        value.getChars(0, value.length(), buf, 0);\n+        print(buf, 0, value.length(), checkForEscape);\n+    }\n+\n+    /**\n+     * Print the string as the next value on the line. The value\n+     * will be escaped or encapsulated as needed.\n+     *\n+     * @param value value to be outputted.\n+     */\n+    public void print(String value) throws IOException {\n+        print(value, true);\n+    }\n }\n--- a/src/java/org/apache/commons/csv/CSVStrategy.java\n+++ b/src/java/org/apache/commons/csv/CSVStrategy.java\n \n /**\n  * CSVStrategy\n- * \n+ *\n  * Represents the strategy for a CSV.\n  */\n public class CSVStrategy implements Cloneable, Serializable {\n     // an EOF signal (-1), and because \\ufffe in UTF-16 would be\n     // encoded as two chars (using surrogates) and thus there should never\n     // be a collision with a real text char.\n-    public static char COMMENTS_DISABLED       = (char)-2;\n-    public static char ESCAPE_DISABLED         = (char)-2;\n-    public static char ENCAPSULATOR_DISABLED   = (char)-2;\n+    public static char COMMENTS_DISABLED = (char) -2;\n+    public static char ESCAPE_DISABLED = (char) -2;\n+    public static char ENCAPSULATOR_DISABLED = (char) -2;\n \n-    public static CSVStrategy DEFAULT_STRATEGY = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true, \n-                                                                 true, false, true);\n-    public static CSVStrategy EXCEL_STRATEGY   = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, false, \n-                                                                 false, false, false);\n-    public static CSVStrategy TDF_STRATEGY     = new CSVStrategy('\\t', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true, \n-                                                                 true, false, true);\n+    public static CSVStrategy DEFAULT_STRATEGY = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true,\n+            true, false, true);\n+    public static CSVStrategy EXCEL_STRATEGY = new CSVStrategy(',', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, false,\n+            false, false, false);\n+    public static CSVStrategy TDF_STRATEGY = new CSVStrategy('\\t', '\"', COMMENTS_DISABLED, ESCAPE_DISABLED, true,\n+            true, false, true);\n \n \n     public CSVStrategy(char delimiter, char encapsulator, char commentStart) {\n         this(delimiter, encapsulator, commentStart, true, false, true);\n     }\n-  \n+\n     /**\n      * Customized CSV strategy setter.\n      *\n-     * @param delimiter a Char used for value separation\n-     * @param encapsulator a Char used as value encapsulation marker\n-     * @param commentStart a Char used for comment identification\n-     * @param escape a Char used to escape special characters in values\n-     * @param ignoreLeadingWhitespace TRUE when leading whitespaces should be\n-     *                                ignored\n+     * @param delimiter                a Char used for value separation\n+     * @param encapsulator             a Char used as value encapsulation marker\n+     * @param commentStart             a Char used for comment identification\n+     * @param escape                   a Char used to escape special characters in values\n+     * @param ignoreLeadingWhitespace  TRUE when leading whitespaces should be\n+     *                                 ignored\n      * @param ignoreTrailingWhitespace TRUE when trailing whitespaces should be\n-     *                                ignored\n-     * @param interpretUnicodeEscapes TRUE when unicode escapes should be\n-     *                                interpreted\n-     * @param ignoreEmptyLines TRUE when the parser should skip emtpy lines\n+     *                                 ignored\n+     * @param interpretUnicodeEscapes  TRUE when unicode escapes should be\n+     *                                 interpreted\n+     * @param ignoreEmptyLines         TRUE when the parser should skip emtpy lines\n      */\n     public CSVStrategy(\n-        char delimiter, \n-        char encapsulator, \n-        char commentStart,\n-        char escape,\n-        boolean ignoreLeadingWhitespace, \n-        boolean ignoreTrailingWhitespace, \n-        boolean interpretUnicodeEscapes,\n-        boolean ignoreEmptyLines) \n-    {\n+            char delimiter,\n+            char encapsulator,\n+            char commentStart,\n+            char escape,\n+            boolean ignoreLeadingWhitespace,\n+            boolean ignoreTrailingWhitespace,\n+            boolean interpretUnicodeEscapes,\n+            boolean ignoreEmptyLines) {\n         setDelimiter(delimiter);\n         setEncapsulator(encapsulator);\n         setCommentStart(commentStart);\n         setIgnoreEmptyLines(ignoreEmptyLines);\n     }\n \n-    /** @deprecated */\n+    /**\n+     * @deprecated\n+     */\n     public CSVStrategy(\n-        char delimiter,\n-        char encapsulator,\n-        char commentStart,\n-        boolean ignoreLeadingWhitespace,\n-        boolean interpretUnicodeEscapes,\n-        boolean ignoreEmptyLines)\n-    {\n-        this(delimiter, encapsulator, commentStart, CSVStrategy.ESCAPE_DISABLED, ignoreLeadingWhitespace, \n-             true, interpretUnicodeEscapes, ignoreEmptyLines);\n+            char delimiter,\n+            char encapsulator,\n+            char commentStart,\n+            boolean ignoreLeadingWhitespace,\n+            boolean interpretUnicodeEscapes,\n+            boolean ignoreEmptyLines) {\n+        this(delimiter, encapsulator, commentStart, CSVStrategy.ESCAPE_DISABLED, ignoreLeadingWhitespace,\n+                true, interpretUnicodeEscapes, ignoreEmptyLines);\n     }\n \n-    public void setDelimiter(char delimiter) { this.delimiter = delimiter; }\n-    public char getDelimiter() { return this.delimiter; }\n+    public void setDelimiter(char delimiter) {\n+        this.delimiter = delimiter;\n+    }\n \n-    public void setEncapsulator(char encapsulator) { this.encapsulator = encapsulator; }\n-    public char getEncapsulator() { return this.encapsulator; }\n+    public char getDelimiter() {\n+        return this.delimiter;\n+    }\n \n-    public void setCommentStart(char commentStart) { this.commentStart = commentStart; }\n-    public char getCommentStart() { return this.commentStart; }\n-    public boolean isCommentingDisabled() { return this.commentStart == COMMENTS_DISABLED; }\n+    public void setEncapsulator(char encapsulator) {\n+        this.encapsulator = encapsulator;\n+    }\n \n-    public void setEscape(char escape) { this.escape = escape; }\n-    public char getEscape() { return this.escape; }\n+    public char getEncapsulator() {\n+        return this.encapsulator;\n+    }\n \n-    public void setIgnoreLeadingWhitespaces(boolean ignoreLeadingWhitespaces) { \n-        this.ignoreLeadingWhitespaces = ignoreLeadingWhitespaces; \n+    public void setCommentStart(char commentStart) {\n+        this.commentStart = commentStart;\n     }\n-    public boolean getIgnoreLeadingWhitespaces() { return this.ignoreLeadingWhitespaces; }\n \n-    public void setIgnoreTrailingWhitespaces(boolean ignoreTrailingWhitespaces) { \n-        this.ignoreTrailingWhitespaces = ignoreTrailingWhitespaces; \n+    public char getCommentStart() {\n+        return this.commentStart;\n     }\n-    public boolean getIgnoreTrailingWhitespaces() { return this.ignoreTrailingWhitespaces; }\n \n-    public void setUnicodeEscapeInterpretation(boolean interpretUnicodeEscapes) { \n-        this.interpretUnicodeEscapes = interpretUnicodeEscapes; \n+    public boolean isCommentingDisabled() {\n+        return this.commentStart == COMMENTS_DISABLED;\n     }\n-    public boolean getUnicodeEscapeInterpretation() { return this.interpretUnicodeEscapes; }\n \n-    public void setIgnoreEmptyLines(boolean ignoreEmptyLines) { this.ignoreEmptyLines = ignoreEmptyLines; }\n-    public boolean getIgnoreEmptyLines() { return this.ignoreEmptyLines; }\n+    public void setEscape(char escape) {\n+        this.escape = escape;\n+    }\n+\n+    public char getEscape() {\n+        return this.escape;\n+    }\n+\n+    public void setIgnoreLeadingWhitespaces(boolean ignoreLeadingWhitespaces) {\n+        this.ignoreLeadingWhitespaces = ignoreLeadingWhitespaces;\n+    }\n+\n+    public boolean getIgnoreLeadingWhitespaces() {\n+        return this.ignoreLeadingWhitespaces;\n+    }\n+\n+    public void setIgnoreTrailingWhitespaces(boolean ignoreTrailingWhitespaces) {\n+        this.ignoreTrailingWhitespaces = ignoreTrailingWhitespaces;\n+    }\n+\n+    public boolean getIgnoreTrailingWhitespaces() {\n+        return this.ignoreTrailingWhitespaces;\n+    }\n+\n+    public void setUnicodeEscapeInterpretation(boolean interpretUnicodeEscapes) {\n+        this.interpretUnicodeEscapes = interpretUnicodeEscapes;\n+    }\n+\n+    public boolean getUnicodeEscapeInterpretation() {\n+        return this.interpretUnicodeEscapes;\n+    }\n+\n+    public void setIgnoreEmptyLines(boolean ignoreEmptyLines) {\n+        this.ignoreEmptyLines = ignoreEmptyLines;\n+    }\n+\n+    public boolean getIgnoreEmptyLines() {\n+        return this.ignoreEmptyLines;\n+    }\n \n     public void setPrinterNewline(String newline) {\n-      this.printerNewline = newline;\n+        this.printerNewline = newline;\n     }\n+\n     public String getPrinterNewline() {\n-      return this.printerNewline;\n+        return this.printerNewline;\n     }\n \n     public Object clone() {\n-      try {\n-        return super.clone();\n-      } catch (CloneNotSupportedException e) {\n-        throw new RuntimeException(e);  // impossible\n-      }\n+        try {\n+            return super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            throw new RuntimeException(e);  // impossible\n+        }\n     }\n }\n--- a/src/java/org/apache/commons/csv/CSVUtils.java\n+++ b/src/java/org/apache/commons/csv/CSVUtils.java\n \n     /**\n      * <p><code>CSVUtils</code> instances should NOT be constructed in\n-     * standard programming. \n+     * standard programming.\n      *\n      * <p>This constructor is public to permit tools that require a JavaBean\n      * instance to operate.</p>\n      */\n     public CSVUtils() {\n     }\n-  \n+\n     /**\n      * Converts an array of string values into a single CSV line. All\n      * <code>null</code> values are converted to the string <code>\"null\"</code>,\n      *\n      * @param values the value array\n      * @return the CSV string, will be an empty string if the length of the\n-     * value array is 0\n+     *         value array is 0\n      */\n     public static String printLine(String[] values, CSVStrategy strategy) {\n         // set up a CSVUtils\n         StringWriter stringWriter = new StringWriter();\n         CSVPrinter csvPrinter = new CSVPrinter(stringWriter, strategy);\n-  \n+\n         // check for null values an \"null\" as strings and convert them\n         // into the strings \"null\" and \"\\\"null\\\"\"\n         for (int i = 0; i < values.length; i++) {\n                 values[i] = \"\\\"null\\\"\";\n             }\n         }\n-  \n+\n         // convert to CSV\n         try {\n-          csvPrinter.println(values);\n+            csvPrinter.println(values);\n         } catch (IOException e) {\n-          // should not happen with StringWriter\n+            // should not happen with StringWriter\n         }\n         // as the resulting string has \\r\\n at the end, we will trim that away\n         return stringWriter.toString().trim();\n     }\n-  \n-  // ======================================================\n-  //  static parsers\n-  // ======================================================\n-  \n-  /**\n-   * Parses the given String according to the default {@link CSVStrategy}.\n-   * \n-   * @param s CSV String to be parsed.\n-   * @return parsed String matrix (which is never null)\n-   * @throws IOException in case of error\n-   */\n-  public static String[][] parse(String s) throws IOException {\n-    if (s == null) {\n-      throw new IllegalArgumentException(\"Null argument not allowed.\");\n+\n+    // ======================================================\n+    //  static parsers\n+    // ======================================================\n+\n+    /**\n+     * Parses the given String according to the default {@link CSVStrategy}.\n+     *\n+     * @param s CSV String to be parsed.\n+     * @return parsed String matrix (which is never null)\n+     * @throws IOException in case of error\n+     */\n+    public static String[][] parse(String s) throws IOException {\n+        if (s == null) {\n+            throw new IllegalArgumentException(\"Null argument not allowed.\");\n+        }\n+        String[][] result = (new CSVParser(new StringReader(s))).getAllValues();\n+        if (result == null) {\n+            // since CSVStrategy ignores empty lines an empty array is returned\n+            // (i.e. not \"result = new String[][] {{\"\"}};\")\n+            result = EMPTY_DOUBLE_STRING_ARRAY;\n+        }\n+        return result;\n     }\n-    String[][] result = (new CSVParser(new StringReader(s))).getAllValues();\n-    if (result == null) {\n-      // since CSVStrategy ignores empty lines an empty array is returned\n-      // (i.e. not \"result = new String[][] {{\"\"}};\")\n-      result = EMPTY_DOUBLE_STRING_ARRAY;\n+\n+    /**\n+     * Parses the first line only according to the default {@link CSVStrategy}.\n+     *\n+     * Parsing empty string will be handled as valid records containing zero\n+     * elements, so the following property holds: parseLine(\"\").length == 0.\n+     *\n+     * @param s CSV String to be parsed.\n+     * @return parsed String vector (which is never null)\n+     * @throws IOException in case of error\n+     */\n+    public static String[] parseLine(String s) throws IOException {\n+        if (s == null) {\n+            throw new IllegalArgumentException(\"Null argument not allowed.\");\n+        }\n+        // uh,jh: make sure that parseLine(\"\").length == 0\n+        if (s.length() == 0) {\n+            return EMPTY_STRING_ARRAY;\n+        }\n+        return (new CSVParser(new StringReader(s))).getLine();\n     }\n-    return result;\n-  }\n-  \n-  /**\n-   * Parses the first line only according to the default {@link CSVStrategy}.\n-   * \n-   * Parsing empty string will be handled as valid records containing zero\n-   * elements, so the following property holds: parseLine(\"\").length == 0.\n-   * \n-   * @param s CSV String to be parsed.\n-   * @return parsed String vector (which is never null)\n-   * @throws IOException in case of error\n-   */\n-  public static String[] parseLine(String s) throws IOException {\n-    if (s == null) {\n-      throw new IllegalArgumentException(\"Null argument not allowed.\");\n-    }\n-    // uh,jh: make sure that parseLine(\"\").length == 0\n-    if (s.length() == 0) {\n-      return EMPTY_STRING_ARRAY;\n-    }\n-    return (new CSVParser(new StringReader(s))).getLine();\n-  }\n-  \n+\n }\n--- a/src/java/org/apache/commons/csv/CharBuffer.java\n+++ b/src/java/org/apache/commons/csv/CharBuffer.java\n package org.apache.commons.csv;\n \n /**\n- * A simple StringBuffer replacement that aims to \n+ * A simple StringBuffer replacement that aims to\n  * reduce copying as much as possible. The buffer\n  * grows as necessary.\n  * This class is not thread safe.\n- * \n+ *\n  * @author Ortwin Gl\ufffdck\n  */\n public class CharBuffer {\n     private char[] c;\n \n     /**\n-     * Actually used number of characters in the array. \n+     * Actually used number of characters in the array.\n      * It is also the index at which\n-     * a new character will be inserted into <code>c</code>. \n-     */ \n+     * a new character will be inserted into <code>c</code>.\n+     */\n     private int length;\n-    \n+\n     /**\n      * Creates a new CharBuffer with an initial capacity of 32 characters.\n      */\n     public CharBuffer() {\n         this(32);\n     }\n-    \n-    /**\n-     * Creates a new CharBuffer with an initial capacity \n+\n+    /**\n+     * Creates a new CharBuffer with an initial capacity\n      * of <code>length</code> characters.\n      */\n     public CharBuffer(final int length) {\n         }\n         this.c = new char[length];\n     }\n-    \n+\n     /**\n      * Empties the buffer. The capacity still remains the same, so no memory is freed.\n      */\n     public void clear() {\n         length = 0;\n     }\n-    \n+\n     /**\n      * Returns the number of characters in the buffer.\n+     *\n      * @return the number of characters\n      */\n     public int length() {\n \n     /**\n      * Returns the current capacity of the buffer.\n+     *\n      * @return the maximum number of characters that can be stored in this buffer without\n-     * resizing it.\n+     *         resizing it.\n      */\n     public int capacity() {\n         return c.length;\n     }\n \n-    \n+\n     /**\n      * Appends the contents of <code>cb</code> to the end of this CharBuffer.\n+     *\n      * @param cb the CharBuffer to append or null\n      */\n     public void append(final CharBuffer cb) {\n         System.arraycopy(cb.c, 0, c, length, cb.length);\n         length += cb.length;\n     }\n-    \n+\n     /**\n      * Appends <code>s</code> to the end of this CharBuffer.\n      * This method involves copying the new data once!\n+     *\n      * @param s the String to append or null\n      */\n     public void append(final String s) {\n         }\n         append(s.toCharArray());\n     }\n-    \n+\n     /**\n      * Appends <code>sb</code> to the end of this CharBuffer.\n      * This method involves copying the new data once!\n+     *\n      * @param sb the StringBuffer to append or null\n      */\n     public void append(final StringBuffer sb) {\n         sb.getChars(0, sb.length(), c, length);\n         length += sb.length();\n     }\n-    \n+\n     /**\n      * Appends <code>data</code> to the end of this CharBuffer.\n      * This method involves copying the new data once!\n+     *\n      * @param data the char[] to append or null\n      */\n     public void append(final char[] data) {\n         System.arraycopy(data, 0, c, length, data.length);\n         length += data.length;\n     }\n-    \n+\n     /**\n      * Appends a single character to the end of this CharBuffer.\n      * This method involves copying the new data once!\n+     *\n      * @param data the char to append\n      */\n     public void append(final char data) {\n         c[length] = data;\n         length++;\n     }\n-    \n+\n     /**\n      * Shrinks the capacity of the buffer to the current length if necessary.\n      * This method involves copying the data once!\n         c = newc;\n     }\n \n-   /**\n-    * Removes trailing whitespace.\n-    */\n+    /**\n+     * Removes trailing whitespace.\n+     */\n     public void trimTrailingWhitespace() {\n-      while (length>0 && Character.isWhitespace(c[length-1])) {\n-        length--;\n-      }\n+        while (length > 0 && Character.isWhitespace(c[length - 1])) {\n+            length--;\n+        }\n     }\n \n     /**\n      * modifying it.\n      * This method allows to avoid copying if the caller knows the exact capacity\n      * before.\n+     *\n      * @return\n      */\n     public char[] getCharacters() {\n         return chars;\n     }\n \n-   /**\n-    * Returns the character at the specified position.\n-    */\n+    /**\n+     * Returns the character at the specified position.\n+     */\n     public char charAt(int pos) {\n-      return c[pos];\n-   }\n+        return c[pos];\n+    }\n \n     /**\n      * Converts the contents of the buffer into a StringBuffer.\n      * This method involves copying the new data once!\n+     *\n      * @return\n      */\n     public StringBuffer toStringBuffer() {\n         sb.append(c, 0, length);\n         return sb;\n     }\n-    \n+\n     /**\n      * Converts the contents of the buffer into a StringBuffer.\n      * This method involves copying the new data once!\n+     *\n      * @return\n      */\n     public String toString() {\n         return new String(c, 0, length);\n     }\n-    \n+\n     /**\n      * Copies the data into a new array of at least <code>capacity</code> size.\n+     *\n      * @param capacity\n      */\n     public void provideCapacity(final int capacity) {\n         if (c.length >= capacity) {\n             return;\n         }\n-        int newcapacity = ((capacity*3)>>1) + 1;\n+        int newcapacity = ((capacity * 3) >> 1) + 1;\n         char[] newc = new char[newcapacity];\n         System.arraycopy(c, 0, newc, 0, length);\n         c = newc;\n--- a/src/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/java/org/apache/commons/csv/ExtendedBufferedReader.java\n /**\n  * ExtendedBufferedReader\n  *\n- * A special reader decorater which supports more\n+ * A special reader decorator which supports more\n  * sophisticated access to the underlying reader object.\n- * \n+ *\n  * In particular the reader supports a look-ahead option,\n  * which allows you to see the next char returned by\n  * next().\n- * \n  */\n-class ExtendedBufferedReader extends BufferedReader  {\n-\n-  \n-  /** the end of stream symbol */\n-  public static final int END_OF_STREAM = -1;\n-  /** undefined state for the lookahead char */\n-  public static final int UNDEFINED = -2;\n-  \n-  /** the lookahead chars */\n-  private int lookaheadChar = UNDEFINED;\n-  /** the last char returned */\n-  private int lastChar = UNDEFINED;\n-  /** the line counter */\n-  private int lineCounter = 0;\n-  private CharBuffer line = new CharBuffer();\n-  \n-  /**\n-   * Created extended buffered reader using default buffer-size\n-   *\n-   */\n-  public ExtendedBufferedReader(Reader r) {\n-    super(r);\n-    /* note uh: do not fetch the first char here,\n-     *          because this might block the method!\n-     */\n-  }\n-    \n-  /**\n-   * Create extended buffered reader using the given buffer-size\n-   */\n-  public ExtendedBufferedReader(Reader r, int bufSize) {\n-    super(r, bufSize);\n-    /* note uh: do not fetch the first char here,\n-     *          because this might block the method!\n-     */\n-  }\n-  \n-  /**\n-   * Reads the next char from the input stream.\n-   * @return the next char or END_OF_STREAM if end of stream has been reached.\n-   */\n-  public int read() throws IOException {\n-    // initalize the lookahead\n-    if (lookaheadChar == UNDEFINED) {\n-      lookaheadChar = super.read();\n-    }\n-    lastChar = lookaheadChar;\n-    if (super.ready()) {\n-      lookaheadChar = super.read();\n-    } else {\n-      lookaheadChar = UNDEFINED;\n-    }\n-    if (lastChar == '\\n') {\n-      lineCounter++;\n-    } \n-    return lastChar;\n-  }\n-  \n-  /**\n-   * Returns the last read character again.\n-   * \n-   * @return the last read char or UNDEFINED\n-   */\n-  public int readAgain() {\n-    return lastChar;  \n-  }\n-  \n-  /**\n-   * Non-blocking reading of len chars into buffer buf starting\n-   * at bufferposition off.\n-   * \n-   * performs an iteratative read on the underlying stream\n-   * as long as the following conditions hold:\n-   *   - less than len chars have been read\n-   *   - end of stream has not been reached\n-   *   - next read is not blocking\n-   * \n-   * @return nof chars actually read or END_OF_STREAM\n-   */\n-  public int read(char[] buf, int off, int len) throws IOException {\n-    // do not claim if len == 0\n-    if (len == 0) {\n-      return 0;\n-    } \n-    \n-    // init lookahead, but do not block !!\n-    if (lookaheadChar == UNDEFINED) {\n-        if (ready()) {\n-         lookaheadChar = super.read();\n+class ExtendedBufferedReader extends BufferedReader {\n+\n+\n+    /**\n+     * the end of stream symbol\n+     */\n+    public static final int END_OF_STREAM = -1;\n+    /**\n+     * undefined state for the lookahead char\n+     */\n+    public static final int UNDEFINED = -2;\n+\n+    /**\n+     * the lookahead chars\n+     */\n+    private int lookaheadChar = UNDEFINED;\n+    /**\n+     * the last char returned\n+     */\n+    private int lastChar = UNDEFINED;\n+    /**\n+     * the line counter\n+     */\n+    private int lineCounter = 0;\n+    private CharBuffer line = new CharBuffer();\n+\n+    /**\n+     * Created extended buffered reader using default buffer-size\n+     */\n+    public ExtendedBufferedReader(Reader r) {\n+        super(r);\n+        /* note uh: do not fetch the first char here,\n+        *          because this might block the method!\n+        */\n+    }\n+\n+    /**\n+     * Create extended buffered reader using the given buffer-size\n+     */\n+    public ExtendedBufferedReader(Reader r, int bufSize) {\n+        super(r, bufSize);\n+        /* note uh: do not fetch the first char here,\n+        *          because this might block the method!\n+        */\n+    }\n+\n+    /**\n+     * Reads the next char from the input stream.\n+     *\n+     * @return the next char or END_OF_STREAM if end of stream has been reached.\n+     */\n+    public int read() throws IOException {\n+        // initialize the lookahead\n+        if (lookaheadChar == UNDEFINED) {\n+            lookaheadChar = super.read();\n+        }\n+        lastChar = lookaheadChar;\n+        if (super.ready()) {\n+            lookaheadChar = super.read();\n         } else {\n-          return -1;\n-        }\n-    }\n-    // 'first read of underlying stream'\n-    if (lookaheadChar == -1) {\n-      return -1;\n-    }\n-    // continue until the lookaheadChar would block\n-    int cOff = off;\n-    while (len > 0 && ready()) {\n-      if (lookaheadChar == -1) {\n-        // eof stream reached, do not continue\n+            lookaheadChar = UNDEFINED;\n+        }\n+        if (lastChar == '\\n') {\n+            lineCounter++;\n+        }\n+        return lastChar;\n+    }\n+\n+    /**\n+     * Returns the last read character again.\n+     *\n+     * @return the last read char or UNDEFINED\n+     */\n+    public int readAgain() {\n+        return lastChar;\n+    }\n+\n+    /**\n+     * Non-blocking reading of len chars into buffer buf starting\n+     * at bufferposition off.\n+     * <p/>\n+     * performs an iterative read on the underlying stream\n+     * as long as the following conditions hold:\n+     * - less than len chars have been read\n+     * - end of stream has not been reached\n+     * - next read is not blocking\n+     *\n+     * @return nof chars actually read or END_OF_STREAM\n+     */\n+    public int read(char[] buf, int off, int len) throws IOException {\n+        // do not claim if len == 0\n+        if (len == 0) {\n+            return 0;\n+        }\n+\n+        // init lookahead, but do not block !!\n+        if (lookaheadChar == UNDEFINED) {\n+            if (ready()) {\n+                lookaheadChar = super.read();\n+            } else {\n+                return -1;\n+            }\n+        }\n+        // 'first read of underlying stream'\n+        if (lookaheadChar == -1) {\n+            return -1;\n+        }\n+        // continue until the lookaheadChar would block\n+        int cOff = off;\n+        while (len > 0 && ready()) {\n+            if (lookaheadChar == -1) {\n+                // eof stream reached, do not continue\n+                return cOff - off;\n+            } else {\n+                buf[cOff++] = (char) lookaheadChar;\n+                if (lookaheadChar == '\\n') {\n+                    lineCounter++;\n+                }\n+                lastChar = lookaheadChar;\n+                lookaheadChar = super.read();\n+                len--;\n+            }\n+        }\n         return cOff - off;\n-      } else {\n-        buf[cOff++] = (char) lookaheadChar;\n-        if (lookaheadChar == '\\n') {\n-          lineCounter++;\n-        } \n+    }\n+\n+    /**\n+     * @return A String containing the contents of the line, not\n+     *         including any line-termination characters, or null\n+     *         if the end of the stream has been reached\n+     */\n+    public String readLine() throws IOException {\n+\n+        if (lookaheadChar == UNDEFINED) {\n+            lookaheadChar = super.read();\n+        }\n+\n+        line.clear(); //reuse\n+\n+        // return null if end of stream has been reached\n+        if (lookaheadChar == END_OF_STREAM) {\n+            return null;\n+        }\n+        // do we have a line termination already\n+        char laChar = (char) lookaheadChar;\n+        if (laChar == '\\n' || laChar == '\\r') {\n+            lastChar = lookaheadChar;\n+            lookaheadChar = super.read();\n+            // ignore '\\r\\n' as well\n+            if ((char) lookaheadChar == '\\n') {\n+                lastChar = lookaheadChar;\n+                lookaheadChar = super.read();\n+            }\n+            lineCounter++;\n+            return line.toString();\n+        }\n+\n+        // create the rest-of-line return and update the lookahead\n+        line.append(laChar);\n+        String restOfLine = super.readLine(); // TODO involves copying\n         lastChar = lookaheadChar;\n         lookaheadChar = super.read();\n-        len--;\n-      }\n-    }\n-    return cOff - off;\n-  }\n- \n- /**\n-  * @return A String containing the contents of the line, not \n-  *         including any line-termination characters, or null \n-  *         if the end of the stream has been reached\n-  */\n-  public String readLine() throws IOException {\n-    \n-    if (lookaheadChar == UNDEFINED) {\n-      lookaheadChar = super.read(); \n-    }\n-    \n-    line.clear(); //reuse\n-    \n-    // return null if end of stream has been reached\n-    if (lookaheadChar == END_OF_STREAM) {\n-      return null;\n-    }\n-    // do we have a line termination already\n-    char laChar = (char) lookaheadChar;\n-    if (laChar == '\\n' || laChar == '\\r') {\n-      lastChar = lookaheadChar;\n-      lookaheadChar = super.read();\n-      // ignore '\\r\\n' as well\n-      if ((char) lookaheadChar == '\\n') {\n-        lastChar = lookaheadChar;\n-        lookaheadChar = super.read();\n-      }\n-      lineCounter++;\n-      return line.toString();\n-    }\n-    \n-    // create the rest-of-line return and update the lookahead\n-    line.append(laChar);\n-    String restOfLine = super.readLine(); // TODO involves copying\n-    lastChar = lookaheadChar;\n-    lookaheadChar = super.read();\n-    if (restOfLine != null) {\n-      line.append(restOfLine);\n-    }\n-    lineCounter++;\n-    return line.toString();\n-  }\n-  \n-  /**\n-   * Unsupported\n-   */\n-  public long skip(long n) throws IllegalArgumentException, IOException  {\n-    throw new UnsupportedOperationException(\"CSV has no reason to implement this\");\n-  }\n-  \n-  /**\n-   * Returns the next char in the stream without consuming it.\n-   * \n-   * Remember the next char read by read(..) will always be\n-   * identical to lookAhead().\n-   * \n-   * @return the next char (without consuming it) or END_OF_STREAM\n-   */\n-  public int lookAhead() throws IOException {\n-    if (lookaheadChar == UNDEFINED) {\n-      lookaheadChar = super.read();\n-    }\n-    return lookaheadChar;\n-  }\n-  \n-  \n-  /**\n-   * Returns the nof line read\n-   * \n-   * @return the current-line-number (or -1)\n-   */ \n-  public int getLineNumber() {\n-    if (lineCounter > -1) {\n-      return lineCounter;\n-    } else {\n-      return -1;\n-    }\n-  }\n-\n-  /**\n-   * Unsupported\n-   */\n-  public boolean markSupported() {\n-    throw new UnsupportedOperationException(\"CSV has no reason to implement this\");\n-  }\n-  \n+        if (restOfLine != null) {\n+            line.append(restOfLine);\n+        }\n+        lineCounter++;\n+        return line.toString();\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public long skip(long n) throws IllegalArgumentException, IOException {\n+        throw new UnsupportedOperationException(\"CSV has no reason to implement this\");\n+    }\n+\n+    /**\n+     * Returns the next char in the stream without consuming it.\n+     *\n+     * Remember the next char read by read(..) will always be\n+     * identical to lookAhead().\n+     *\n+     * @return the next char (without consuming it) or END_OF_STREAM\n+     */\n+    public int lookAhead() throws IOException {\n+        if (lookaheadChar == UNDEFINED) {\n+            lookaheadChar = super.read();\n+        }\n+        return lookaheadChar;\n+    }\n+\n+\n+    /**\n+     * Returns the nof line read\n+     *\n+     * @return the current-line-number (or -1)\n+     */\n+    public int getLineNumber() {\n+        if (lineCounter > -1) {\n+            return lineCounter;\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n+    /**\n+     * Unsupported\n+     */\n+    public boolean markSupported() {\n+        throw new UnsupportedOperationException(\"CSV has no reason to implement this\");\n+    }\n+\n }\n--- a/src/java/org/apache/commons/csv/writer/CSVConfig.java\n+++ b/src/java/org/apache/commons/csv/writer/CSVConfig.java\n  */\n public class CSVConfig {\n \n-    /** specifies if it is a fixed width csv file **/\n+    /**\n+     * specifies if it is a fixed width csv file *\n+     */\n     private boolean fixedWidth;\n-    /** list of fields **/\n+    /**\n+     * list of fields *\n+     */\n     private List fields;\n \n-    /** Do no do any filling **/\n+    /**\n+     * Do no do any filling *\n+     */\n     public static final int FILLNONE = 0;\n-    /** Fill content the the left. Mainly usable together with fixedWidth **/\n+    /**\n+     * Fill content the the left. Mainly usable together with fixedWidth *\n+     */\n     public static final int FILLLEFT = 1;\n-    /** Fill content to the right. Mainly usable together with fixedWidth **/\n+    /**\n+     * Fill content to the right. Mainly usable together with fixedWidth *\n+     */\n     public static final int FILLRIGHT = 2;\n-    \n-    /** The fill pattern */\n+\n+    /**\n+     * The fill pattern\n+     */\n     private int fill;\n-    /** The fill char. Defaults to a space */\n+    /**\n+     * The fill char. Defaults to a space\n+     */\n     private char fillChar = ' ';\n-    /** The seperator character. Defaults to , */\n+    /**\n+     * The seperator character. Defaults to ,\n+     */\n     private char delimiter = ',';\n-    /** The row separator. Defaults to \\n */\n+    /**\n+     * The row separator. Defaults to \\n\n+     */\n     private String rowDelimiter = \"\\n\";\n-    /** Should we ignore the delimiter. Defaults to false */\n+    /**\n+     * Should we ignore the delimiter. Defaults to false\n+     */\n     private boolean ignoreDelimiter = false;\n-    /** the value delimiter. Defaults to \" */\n+    /**\n+     * the value delimiter. Defaults to \"\n+     */\n     private char valueDelimiter = '\"';\n-    /** Should we ignore the value delimiter. Defaults to true */\n+    /**\n+     * Should we ignore the value delimiter. Defaults to true\n+     */\n     private boolean ignoreValueDelimiter = true;\n-    /** Specifies if we want to use a field header */\n+    /**\n+     * Specifies if we want to use a field header\n+     */\n     private boolean fieldHeader = false;\n-    /** Specifies if the end of the line needs to be trimmed */\n+    /**\n+     * Specifies if the end of the line needs to be trimmed\n+     */\n     private boolean endTrimmed = false;\n-    /**\n-     * \n+\n+    /**\n+     *\n      */\n     public CSVConfig() {\n         super();\n     }\n-    \n+\n     /**\n      * @return if the CSV file is fixedWidth\n      */\n     public boolean isFixedWidth() {\n         return fixedWidth;\n     }\n-    \n+\n     /**\n      * Specify if the CSV file is fixed width.\n      * Defaults to false\n+     *\n      * @param fixedWidth the fixedwidth\n      */\n     public void setFixedWidth(boolean fixedWidth) {\n         this.fixedWidth = fixedWidth;\n     }\n-    \n+\n     public void addField(CSVField field) {\n         if (fields == null) {\n             fields = new ArrayList();\n         }\n         fields.add(field);\n     }\n-    \n+\n     /**\n      * Set the fields that should be used by the writer.\n      * This will overwrite currently added fields completely!\n+     *\n      * @param csvFields the csvfields array. If null it will do nothing\n      */\n     public void setFields(CSVField[] csvFields) {\n         }\n         fields = new ArrayList(Arrays.asList(csvFields));\n     }\n-    \n+\n     /**\n      * Set the fields that should be used by the writer\n+     *\n      * @param csvField a collection with fields. If null it will do nothing\n      */\n     public void setFields(Collection csvField) {\n         }\n         return csvFields;\n     }\n-    \n+\n     public CSVField getField(String name) {\n         if (fields == null || name == null) {\n             return null;\n         }\n-        for(int i = 0; i < fields.size(); i++) {\n+        for (int i = 0; i < fields.size(); i++) {\n             CSVField field = (CSVField) fields.get(i);\n             if (name.equals(field.getName())) {\n                 return field;\n     /**\n      * Set the fill pattern. Defaults to {@link #FILLNONE}\n      * <br/>Other options are : {@link #FILLLEFT} and {@link #FILLRIGHT}\n+     *\n      * @param fill the fill pattern.\n      */\n     public void setFill(int fill) {\n     }\n \n     /**\n-     * \n      * @return the fillchar. Defaults to a space.\n      */\n     public char getFillChar() {\n \n     /**\n      * Set the fill char\n+     *\n      * @param fillChar the fill char\n      */\n     public void setFillChar(char fillChar) {\n \n     /**\n      * Set the delimiter to use\n+     *\n      * @param delimiter the delimiter character.\n      */\n     public void setDelimiter(char delimiter) {\n \n     /**\n      * Set the rowDelimiter to use\n+     *\n      * @param rowDelimiter the row delimiter character.\n      */\n     public void setRowDelimiter(String rowDelimiter) {\n     }\n \n     /**\n-     * Specify if the writer should ignore the delimiter. \n+     * Specify if the writer should ignore the delimiter.\n+     *\n      * @param ignoreDelimiter defaults to false.\n      */\n     public void setIgnoreDelimiter(boolean ignoreDelimiter) {\n \n     /**\n      * Set the value delimiter to use\n+     *\n      * @param valueDelimiter the value delimiter character.\n      */\n     public void setValueDelimiter(char valueDelimiter) {\n     }\n \n     /**\n-     * Specify if the writer should ignore the value delimiter. \n+     * Specify if the writer should ignore the value delimiter.\n+     *\n      * @param ignoreValueDelimiter defaults to false.\n      */\n     public void setIgnoreValueDelimiter(boolean ignoreValueDelimiter) {\n     public boolean isFieldHeader() {\n         return fieldHeader;\n     }\n+\n     /**\n      * Specify if you want to use a field header.\n+     *\n      * @param fieldHeader true or false.\n      */\n     public void setFieldHeader(boolean fieldHeader) {\n         this.fieldHeader = fieldHeader;\n     }\n-    \n+\n     /**\n      * TODO..\n+     *\n      * @see java.lang.Object#equals(java.lang.Object)\n      */\n     public boolean equals(Object obj) {\n     /**\n      * Creates a config based on a stream. It tries to guess<br/>\n      * NOTE : The stream will be closed.\n-     * @param inputStream the inputstream. \n-     * @return the guessed config. \n+     *\n+     * @param inputStream the inputstream.\n+     * @return the guessed config.\n      */\n     public static CSVConfig guessConfig(InputStream inputStream) {\n         return null;\n \n     /**\n      * Specify if the end of the line needs to be trimmed. Defaults to false.\n+     *\n      * @param endTrimmed\n      */\n     public void setEndTrimmed(boolean endTrimmed) {\n         this.endTrimmed = endTrimmed;\n     }\n \n-    \n+\n }\n--- a/src/java/org/apache/commons/csv/writer/CSVConfigGuesser.java\n+++ b/src/java/org/apache/commons/csv/writer/CSVConfigGuesser.java\n  */\n public class CSVConfigGuesser {\n \n-    /** The stream to read */\n+    /**\n+     * The stream to read\n+     */\n     private InputStream in;\n-    /** \n+    /**\n      * if the file has a field header (need this info, to be able to guess better)\n      * Defaults to false\n      */\n     private boolean hasFieldHeader = false;\n-    /** The found config */\n+    /**\n+     * The found config\n+     */\n     protected CSVConfig config;\n-    \n+\n     /**\n-     * \n+     *\n      */\n     public CSVConfigGuesser() {\n         this.config = new CSVConfig();\n     }\n-    \n+\n     /**\n      * @param in the inputstream to guess from\n      */\n         this();\n         setInputStream(in);\n     }\n-    \n+\n     public void setInputStream(InputStream in) {\n         this.in = in;\n     }\n-    \n+\n     /**\n      * Allow override.\n+     *\n      * @return the inputstream that was set.\n      */\n     protected InputStream getInputStream() {\n         return in;\n     }\n-    \n+\n     /**\n-     * Guess the config based on the first 10 (or less when less available) \n+     * Guess the config based on the first 10 (or less when less available)\n      * records of a CSV file.\n-     * \n+     *\n      * @return the guessed config.\n      */\n     public CSVConfig guess() {\n             String[] lines = new String[10];\n             String line = null;\n             int counter = 0;\n-            while ( (line = bIn.readLine()) != null && counter <= 10) {\n+            while ((line = bIn.readLine()) != null && counter <= 10) {\n                 lines[counter] = line;\n                 counter++;\n             }\n                 lines = newLines;\n             }\n             analyseLines(lines);\n-        } catch(Exception e) {\n+        } catch (Exception e) {\n             e.printStackTrace();\n         } finally {\n             if (in != null) {\n                 try {\n                     in.close();\n-                } catch(Exception e) {\n+                } catch (Exception e) {\n                     // ignore exception.\n                 }\n             }\n         config = null;\n         return conf;\n     }\n-    \n+\n     protected void analyseLines(String[] lines) {\n         guessFixedWidth(lines);\n         guessFieldSeperator(lines);\n     }\n-    \n+\n     /**\n      * Guess if this file is fixedwidth.\n      * Just basing the fact on all lines being of the same length\n+     *\n      * @param lines\n      */\n     protected void guessFixedWidth(String[] lines) {\n             }\n         }\n     }\n-        \n+\n \n     protected void guessFieldSeperator(String[] lines) {\n         if (config.isFixedWidth()) {\n         for (int i = 0; i < lines.length; i++) {\n         }\n     }\n-    \n+\n     protected void guessFixedWidthSeperator(String[] lines) {\n         // keep track of the fieldlength\n         int previousMatch = -1;\n                 if (last != lines[j].charAt(i)) {\n                     charMatches = false;\n                     break;\n-                } \n+                }\n             }\n             if (charMatches) {\n                 if (previousMatch == -1) {\n                     previousMatch = 0;\n                 }\n                 CSVField field = new CSVField();\n-                field.setName(\"field\"+config.getFields().length+1);\n-                field.setSize((i-previousMatch));\n+                field.setName(\"field\" + config.getFields().length + 1);\n+                field.setSize((i - previousMatch));\n                 config.addField(field);\n             }\n         }\n     }\n+\n     /**\n-     * \n      * @return if the field uses a field header. Defaults to false.\n      */\n     public boolean hasFieldHeader() {\n \n     /**\n      * Specify if the CSV file has a field header\n+     *\n      * @param hasFieldHeader true or false\n      */\n     public void setHasFieldHeader(boolean hasFieldHeader) {\n         this.hasFieldHeader = hasFieldHeader;\n     }\n-    \n- \n+\n+\n }\n--- a/src/java/org/apache/commons/csv/writer/CSVField.java\n+++ b/src/java/org/apache/commons/csv/writer/CSVField.java\n \n \n /**\n- * \n  * @author Martin van den Bemt\n  * @version $Id: $\n  */\n     private boolean overrideFill;\n \n     /**\n-     * \n+     *\n      */\n     public CSVField() {\n     }\n     public String getName() {\n         return name;\n     }\n-    \n+\n     /**\n      * Set the name of the field\n+     *\n      * @param name the name\n      */\n     public void setName(String name) {\n     }\n \n     /**\n-     * \n      * @return the size of the field\n      */\n     public int getSize() {\n     /**\n      * Set the size of the field.\n      * The size will be ignored when fixedwidth is set to false in the CSVConfig\n+     *\n      * @param size the size of the field.\n      */\n     public void setSize(int size) {\n \n     /**\n      * Sets overrideFill to true.\n+     *\n      * @param fill the file pattern\n      */\n     public void setFill(int fill) {\n         overrideFill = true;\n         this.fill = fill;\n     }\n-    \n+\n     /**\n      * Does this field override fill ?\n-     * \n+     *\n      * @return\n      */\n     public boolean overrideFill() {\n--- a/src/java/org/apache/commons/csv/writer/CSVWriter.java\n+++ b/src/java/org/apache/commons/csv/writer/CSVWriter.java\n  */\n public class CSVWriter {\n \n-    /** The CSV config **/\n+    /**\n+     * The CSV config *\n+     */\n     private CSVConfig config;\n-    /** The writer **/\n+    /**\n+     * The writer *\n+     */\n     private Writer writer;\n+\n     /**\n-     * \n+     *\n      */\n     public CSVWriter() {\n     }\n-    \n+\n     public CSVWriter(CSVConfig config) {\n         setConfig(config);\n     }\n                     value = writeValue(fields[i], value);\n                     sb.append(value);\n                 }\n-                if (!config.isDelimiterIgnored() && fields.length != (i+1)) {\n+                if (!config.isDelimiterIgnored() && fields.length != (i + 1)) {\n                     sb.append(config.getDelimiter());\n                 }\n             }\n             if (config.isEndTrimmed()) {\n-                for (int i = sb.length()-1; i >= 0; i--) {\n+                for (int i = sb.length() - 1; i >= 0; i--) {\n                     System.out.println(\"i : \" + i);\n                     if (Character.isWhitespace(sb.charAt(i))) {\n                         sb.deleteCharAt(i);\n             sb.append(config.getRowDelimiter());\n             String line = sb.toString();\n             writer.write(line);\n-        } catch(Exception e) {\n+        } catch (Exception e) {\n             e.printStackTrace();\n         }\n     }\n-    \n+\n     protected String writeValue(CSVField field, String value) throws Exception {\n         if (config.isFixedWidth()) {\n             if (value.length() < field.getSize()) {\n         }\n         if (!config.isValueDelimiterIgnored()) {\n             // add the value delimiter..\n-            value = config.getValueDelimiter()+value+config.getValueDelimiter();\n+            value = config.getValueDelimiter() + value + config.getValueDelimiter();\n         }\n         return value;\n     }\n-    \n+\n     /**\n      * @return the CVSConfig or null if not present\n      */\n \n     /**\n      * Set the CSVConfig\n+     *\n      * @param config the CVSConfig\n      */\n     public void setConfig(CSVConfig config) {\n         this.config = config;\n     }\n-    \n+\n     /**\n      * Set the writer to write the CSV file to.\n+     *\n      * @param writer the writer.\n      */\n     public void setWriter(Writer writer) {\n--- a/src/test/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/org/apache/commons/csv/CSVParserTest.java\n  * CSVParserTest\n  *\n  * The test are organized in three different sections:\n- * The 'setter/getter' section, the lexer section and finally the parser \n- * section. In case a test fails, you should follow a top-down approach for \n+ * The 'setter/getter' section, the lexer section and finally the parser\n+ * section. In case a test fails, you should follow a top-down approach for\n  * fixing a potential bug (its likely that the parser itself fails if the lexer\n  * has problems...).\n  */\n public class CSVParserTest extends TestCase {\n-  \n-  /**\n-   * TestCSVParser.\n-   */\n-  class TestCSVParser extends CSVParser {\n+\n     /**\n-     * Test parser to investigate the type of the internal Token.\n-     * @param in a Reader\n+     * TestCSVParser.\n      */\n-    TestCSVParser(Reader in) {\n-      super(in);\n-    }\n-\n-    TestCSVParser(Reader in, CSVStrategy strategy) {\n-      super(in, strategy);\n-    }\n-    /**\n-     * Calls super.nextToken() and prints out a String representation of token\n-     * type and content.\n-     * @return String representation of token type and content\n-     * @throws IOException like {@link CSVParser#nextToken()}\n-     */\n-    public String testNextToken() throws IOException {\n-      Token t = super.nextToken();\n-      return Integer.toString(t.type) + \";\" + t.content + \";\";\n-    }\n-  }\n-  \n-  // ======================================================\n-  //   lexer tests\n-  // ======================================================\n-  \n-  // Single line (without comment)\n-  public void testNextToken1() throws IOException {\n-    String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n-    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-    assertEquals(CSVParser.TT_TOKEN + \";abc;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";def;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";hijk;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";lmnop;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";qrst;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";uv;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";wxy;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";z;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());  \n-  }\n-  \n-  // multiline including comments (and empty lines)\n-  public void testNextToken2() throws IOException {\n-    /*   file:   1,2,3,\n-     *           a,b x,c\n-     *\n-     *           # this is a comment \n-     *           d,e,\n-     * \n-     */\n-    String code = \"1,2,3,\\na,b x,c\\n#foo\\n\\nd,e,\\n\\n\";\n-    CSVStrategy strategy = (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone();\n-    // strategy.setIgnoreEmptyLines(false);\n-    strategy.setCommentStart('#');\n-\n-    TestCSVParser parser = new TestCSVParser(new StringReader(code), strategy);\n-\n-\n-    assertEquals(CSVParser.TT_TOKEN + \";1;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";2;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";3;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";b x;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EORECORD + \";c;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";d;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";e;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());    \n-    assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());    \n-    \n-  }\n- \n-  // simple token with escaping\n-  public void testNextToken3() throws IOException {\n-    /* file: a,\\,,b\n-     *       \\,,\n-     */\n-    String code = \"a,\\\\,,b\\n\\\\,,\";\n-    CSVStrategy strategy = (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone();\n-    strategy.setCommentStart('#');\n-    TestCSVParser parser = new TestCSVParser(new StringReader(code), strategy);\n-\n-    assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-    // an unquoted single backslash is not an escape char\n-    assertEquals(CSVParser.TT_TOKEN + \";\\\\;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-    // an unquoted single backslash is not an escape char\n-    assertEquals(CSVParser.TT_TOKEN + \";\\\\;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());\n-  }\n-  \n-  // encapsulator tokenizer (sinle line)\n-  public void testNextToken4() throws IOException {\n-    /* file:  a,\"foo\",b\n-     *        a,   \" foo\",b\n-     *        a,\"foo \"   ,b     // whitespace after closing encapsulator\n-     *        a,  \" foo \" ,b\n-     */ \n-     String code = \n-      \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n-     TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-     assertEquals(CSVParser.TT_TOKEN + \";foo;\", parser.testNextToken());\n-     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-     assertEquals(CSVParser.TT_TOKEN + \"; foo;\", parser.testNextToken());\n-     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-     assertEquals(CSVParser.TT_TOKEN + \";foo ;\", parser.testNextToken());\n-     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-     assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-     assertEquals(CSVParser.TT_TOKEN + \"; foo ;\", parser.testNextToken());\n+    class TestCSVParser extends CSVParser {\n+        /**\n+         * Test parser to investigate the type of the internal Token.\n+         *\n+         * @param in a Reader\n+         */\n+        TestCSVParser(Reader in) {\n+            super(in);\n+        }\n+\n+        TestCSVParser(Reader in, CSVStrategy strategy) {\n+            super(in, strategy);\n+        }\n+\n+        /**\n+         * Calls super.nextToken() and prints out a String representation of token\n+         * type and content.\n+         *\n+         * @return String representation of token type and content\n+         * @throws IOException like {@link CSVParser#nextToken()}\n+         */\n+        public String testNextToken() throws IOException {\n+            Token t = super.nextToken();\n+            return Integer.toString(t.type) + \";\" + t.content + \";\";\n+        }\n+    }\n+\n+    // ======================================================\n+    //   lexer tests\n+    // ======================================================\n+\n+    // Single line (without comment)\n+    public void testNextToken1() throws IOException {\n+        String code = \"abc,def, hijk,  lmnop,   qrst,uv ,wxy   ,z , ,\";\n+        TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+        assertEquals(CSVParser.TT_TOKEN + \";abc;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";def;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";hijk;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";lmnop;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";qrst;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";uv;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";wxy;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";z;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());\n+    }\n+\n+    // multiline including comments (and empty lines)\n+    public void testNextToken2() throws IOException {\n+        /*   file:   1,2,3,\n+        *           a,b x,c\n+        *\n+        *           # this is a comment\n+        *           d,e,\n+        *\n+        */\n+        String code = \"1,2,3,\\na,b x,c\\n#foo\\n\\nd,e,\\n\\n\";\n+        CSVStrategy strategy = (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone();\n+        // strategy.setIgnoreEmptyLines(false);\n+        strategy.setCommentStart('#');\n+\n+        TestCSVParser parser = new TestCSVParser(new StringReader(code), strategy);\n+\n+\n+        assertEquals(CSVParser.TT_TOKEN + \";1;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";2;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";3;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";b x;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EORECORD + \";c;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";d;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";e;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EORECORD + \";;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());\n+\n+    }\n+\n+    // simple token with escaping\n+    public void testNextToken3() throws IOException {\n+        /* file: a,\\,,b\n+        *       \\,,\n+        */\n+        String code = \"a,\\\\,,b\\n\\\\,,\";\n+        CSVStrategy strategy = (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone();\n+        strategy.setCommentStart('#');\n+        TestCSVParser parser = new TestCSVParser(new StringReader(code), strategy);\n+\n+        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+        // an unquoted single backslash is not an escape char\n+        assertEquals(CSVParser.TT_TOKEN + \";\\\\;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n+        // an unquoted single backslash is not an escape char\n+        assertEquals(CSVParser.TT_TOKEN + \";\\\\;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EOF + \";;\", parser.testNextToken());\n+    }\n+\n+    // encapsulator tokenizer (sinle line)\n+    public void testNextToken4() throws IOException {\n+        /* file:  a,\"foo\",b\n+        *        a,   \" foo\",b\n+        *        a,\"foo \"   ,b     // whitespace after closing encapsulator\n+        *        a,  \" foo \" ,b\n+        */\n+        String code =\n+                \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n+        TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";foo;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \"; foo;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";foo ;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \"; foo ;\", parser.testNextToken());\n //     assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-     assertEquals(CSVParser.TT_EOF + \";b;\", parser.testNextToken());    \n-  }\n-  \n-  // encapsulator tokenizer (multi line, delimiter in string)\n-  public void testNextToken5() throws IOException {   \n-    String code = \n-      \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n-    TestCSVParser parser = new TestCSVParser(new StringReader(code));\n-    assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_TOKEN + \";foo\\n;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n-    assertEquals(CSVParser.TT_EORECORD + \";foo\\n  baar ,,,;\",\n-        parser.testNextToken());\n-    assertEquals(CSVParser.TT_EOF + \";\\n\\t \\n;\", parser.testNextToken());\n-\n-  }\n-  \n-  // change delimiters, comment, encapsulater\n-  public void testNextToken6() throws IOException {\n-    /* file: a;'b and \\' more\n-     *       '\n-     *       !comment;;;;\n-     *       ;;\n-     */\n-    String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n-    TestCSVParser parser = new TestCSVParser(new StringReader(code), new CSVStrategy(';', '\\'', '!'));\n-    assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n-    assertEquals(\n-      CSVParser.TT_EORECORD + \";b and ' more\\n;\", \n-      parser.testNextToken());\n-  }\n-  \n-  \n-  // ======================================================\n-  //   parser tests\n-  // ======================================================\n-  \n-  String code = \n-    \"a,b,c,d\\n\"\n-    + \" a , b , 1 2 \\n\"\n-    + \"\\\"foo baar\\\", b,\\n\"\n-   // + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n-      + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\"\\\"\\\",d,e\\n\";   // changed to use standard CSV escaping\n-  String[][] res = {\n-    {\"a\", \"b\", \"c\", \"d\"},\n-    {\"a\", \"b\", \"1 2\"}, \n-    {\"foo baar\", \"b\", \"\"}, \n-    {\"foo\\n,,\\n\\\",,\\n\\\"\", \"d\", \"e\"}\n-  };\n-  public void testGetLine() throws IOException {\n-    CSVParser parser = new CSVParser(new StringReader(code));\n-    String[] tmp = null;\n-    for (int i = 0; i < res.length; i++) {\n-      tmp = parser.getLine();\n-      assertTrue(Arrays.equals(res[i], tmp));\n-    }\n-    tmp = parser.getLine();\n-    assertTrue(tmp == null);\n-  }\n-  \n-  public void testNextValue() throws IOException {\n-    CSVParser parser = new CSVParser(new StringReader(code));\n-    String tmp = null;\n-    for (int i = 0; i < res.length; i++) {\n-      for (int j = 0; j < res[i].length; j++) {\n+        assertEquals(CSVParser.TT_EOF + \";b;\", parser.testNextToken());\n+    }\n+\n+    // encapsulator tokenizer (multi line, delimiter in string)\n+    public void testNextToken5() throws IOException {\n+        String code =\n+                \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n+        TestCSVParser parser = new TestCSVParser(new StringReader(code));\n+        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";foo\\n;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EORECORD + \";b;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EORECORD + \";foo\\n  baar ,,,;\",\n+                parser.testNextToken());\n+        assertEquals(CSVParser.TT_EOF + \";\\n\\t \\n;\", parser.testNextToken());\n+\n+    }\n+\n+    // change delimiters, comment, encapsulater\n+    public void testNextToken6() throws IOException {\n+        /* file: a;'b and \\' more\n+        *       '\n+        *       !comment;;;;\n+        *       ;;\n+        */\n+        String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n+        TestCSVParser parser = new TestCSVParser(new StringReader(code), new CSVStrategy(';', '\\'', '!'));\n+        assertEquals(CSVParser.TT_TOKEN + \";a;\", parser.testNextToken());\n+        assertEquals(\n+                CSVParser.TT_EORECORD + \";b and ' more\\n;\",\n+                parser.testNextToken());\n+    }\n+\n+\n+    // ======================================================\n+    //   parser tests\n+    // ======================================================\n+\n+    String code =\n+            \"a,b,c,d\\n\"\n+                    + \" a , b , 1 2 \\n\"\n+                    + \"\\\"foo baar\\\", b,\\n\"\n+                    // + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\\\\\"\\\",d,e\\n\";\n+                    + \"   \\\"foo\\n,,\\n\\\"\\\",,\\n\\\"\\\"\\\",d,e\\n\";   // changed to use standard CSV escaping\n+    String[][] res = {\n+            {\"a\", \"b\", \"c\", \"d\"},\n+            {\"a\", \"b\", \"1 2\"},\n+            {\"foo baar\", \"b\", \"\"},\n+            {\"foo\\n,,\\n\\\",,\\n\\\"\", \"d\", \"e\"}\n+    };\n+\n+    public void testGetLine() throws IOException {\n+        CSVParser parser = new CSVParser(new StringReader(code));\n+        String[] tmp = null;\n+        for (int i = 0; i < res.length; i++) {\n+            tmp = parser.getLine();\n+            assertTrue(Arrays.equals(res[i], tmp));\n+        }\n+        tmp = parser.getLine();\n+        assertTrue(tmp == null);\n+    }\n+\n+    public void testNextValue() throws IOException {\n+        CSVParser parser = new CSVParser(new StringReader(code));\n+        String tmp = null;\n+        for (int i = 0; i < res.length; i++) {\n+            for (int j = 0; j < res[i].length; j++) {\n+                tmp = parser.nextValue();\n+                assertEquals(res[i][j], tmp);\n+            }\n+        }\n         tmp = parser.nextValue();\n-        assertEquals(res[i][j], tmp);\n-      }\n-    }\n-    tmp = parser.nextValue();\n-    assertTrue(tmp == null);    \n-  }\n-  \n-  public void testGetAllValues() throws IOException {\n-    CSVParser parser = new CSVParser(new StringReader(code));\n-    String[][] tmp = parser.getAllValues();\n-    assertEquals(res.length, tmp.length);\n-    assertTrue(tmp.length > 0);\n-    for (int i = 0; i < res.length; i++) {\n-      assertTrue(Arrays.equals(res[i], tmp[i])); \n-    }\n-  }\n-  \n-  public void testExcelStrategy1() throws IOException {\n-    String code = \n-      \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\"\n-      + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\n-    String[][] res = {\n-      {\"value1\", \"value2\", \"value3\", \"value4\"},\n-      {\"a\", \"b\", \"c\", \"d\"},\n-      {\"  x\", \"\", \"\", \"\"},\n-      {\"\"},\n-      {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"}\n-    };\n-    CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n-    String[][] tmp = parser.getAllValues();\n-    assertEquals(res.length, tmp.length);\n-    assertTrue(tmp.length > 0);\n-    for (int i = 0; i < res.length; i++) {\n-      assertTrue(Arrays.equals(res[i], tmp[i])); \n-    }\n-  }\n-  \n-  public void testExcelStrategy2() throws Exception {\n-    String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\n-    String[][] res = {\n-      {\"foo\", \"baar\"},\n-      {\"\"},\n-      {\"hello\", \"\"},\n-      {\"\"},\n-      {\"world\", \"\"}\n-    };\n-    CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n-    String[][] tmp = parser.getAllValues();\n-    assertEquals(res.length, tmp.length);\n-    assertTrue(tmp.length > 0);\n-    for (int i = 0; i < res.length; i++) {\n-      assertTrue(Arrays.equals(res[i], tmp[i])); \n-    }\n-  }\n-  \n-  public void testEndOfFileBehaviourExcel() throws Exception {\n-    String[] codes = {\n-        \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n-        \"hello,\\r\\n\\r\\nworld,\",\n-        \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n-        \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n-        \"hello,\\r\\n\\r\\nworld,\\n\",\n-        \"hello,\\r\\n\\r\\nworld,\",\n-        \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n-        \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n-        };\n-    String[][] res = {\n-      {\"hello\", \"\"},\n-      {\"\"},  // ExcelStrategy does not ignore empty lines\n-      {\"world\", \"\"}\n-    };\n-    String code;\n-    for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n-      code = codes[codeIndex];\n-      CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n-      String[][] tmp = parser.getAllValues();\n-      assertEquals(res.length, tmp.length);\n-      assertTrue(tmp.length > 0);\n-      for (int i = 0; i < res.length; i++) {\n-        assertTrue(Arrays.equals(res[i], tmp[i]));\n-      }\n-    }\n-  }\n-  \n-  public void testEndOfFileBehaviorCSV() throws Exception {\n-    String[] codes = {\n-        \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n-        \"hello,\\r\\n\\r\\nworld,\",\n-        \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n-        \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n-        \"hello,\\r\\n\\r\\nworld,\\n\",\n-        \"hello,\\r\\n\\r\\nworld,\",\n-        \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n-        \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n-        };\n-    String[][] res = {\n-      {\"hello\", \"\"},  // CSV Strategy ignores empty lines\n-      {\"world\", \"\"}\n-    };\n-    String code;\n-    for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n-      code = codes[codeIndex];\n-      CSVParser parser = new CSVParser(new StringReader(code));\n-      String[][] tmp = parser.getAllValues();\n-      assertEquals(res.length, tmp.length);\n-      assertTrue(tmp.length > 0);\n-      for (int i = 0; i < res.length; i++) {\n-        assertTrue(Arrays.equals(res[i], tmp[i]));\n-      }\n-    }\n-  }\n-  \n-  public void testEmptyLineBehaviourExcel() throws Exception {\n-    String[] codes = {\n-        \"hello,\\r\\n\\r\\n\\r\\n\",\n-        \"hello,\\n\\n\\n\",\n-        \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n-        \"hello,\\\"\\\"\\n\\n\\n\"\n-        };\n-    String[][] res = {\n-      {\"hello\", \"\"},\n-      {\"\"},  // ExcelStrategy does not ignore empty lines\n-      {\"\"}\n-    };\n-    String code;\n-    for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n-      code = codes[codeIndex];\n-      CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n-      String[][] tmp = parser.getAllValues();\n-      assertEquals(res.length, tmp.length);\n-      assertTrue(tmp.length > 0);\n-      for (int i = 0; i < res.length; i++) {\n-        assertTrue(Arrays.equals(res[i], tmp[i]));\n-      }\n-    }\n-  }\n-  \n-  public void testEmptyLineBehaviourCSV() throws Exception {\n-    String[] codes = {\n-        \"hello,\\r\\n\\r\\n\\r\\n\",\n-        \"hello,\\n\\n\\n\",\n-        \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n-        \"hello,\\\"\\\"\\n\\n\\n\"\n-        };\n-    String[][] res = {\n-      {\"hello\", \"\"}  // CSV Strategy ignores empty lines\n-    };\n-    String code;\n-    for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n-      code = codes[codeIndex];\n-      CSVParser parser = new CSVParser(new StringReader(code));\n-      String[][] tmp = parser.getAllValues();\n-      assertEquals(res.length, tmp.length);\n-      assertTrue(tmp.length > 0);\n-      for (int i = 0; i < res.length; i++) {\n-        assertTrue(Arrays.equals(res[i], tmp[i]));\n-      }\n-    }\n-  }\n-  \n-  public void OLDtestBackslashEscaping() throws IOException {\n-    String code =\n-      \"one,two,three\\n\"\n-      + \"on\\\\\\\"e,two\\n\"\n-      + \"on\\\"e,two\\n\"\n-      + \"one,\\\"tw\\\\\\\"o\\\"\\n\"\n-      + \"one,\\\"t\\\\,wo\\\"\\n\"\n-      + \"one,two,\\\"th,ree\\\"\\n\"\n-      + \"\\\"a\\\\\\\\\\\"\\n\"\n-      + \"a\\\\,b\\n\"\n-      + \"\\\"a\\\\\\\\,b\\\"\";\n-    String[][] res = {\n-        { \"one\", \"two\", \"three\" },\n-        { \"on\\\\\\\"e\", \"two\" },\n-        { \"on\\\"e\", \"two\" },\n-        { \"one\", \"tw\\\"o\" },\n-        { \"one\", \"t\\\\,wo\" },  // backslash in quotes only escapes a delimiter (\",\")\n-        { \"one\", \"two\", \"th,ree\" },\n-        { \"a\\\\\\\\\" },     // backslash in quotes only escapes a delimiter (\",\")\n-        { \"a\\\\\", \"b\" },  // a backslash must be returnd \n-        { \"a\\\\\\\\,b\" }    // backslash in quotes only escapes a delimiter (\",\")\n-      };\n-    CSVParser parser = new CSVParser(new StringReader(code));\n-    String[][] tmp = parser.getAllValues();\n-    assertEquals(res.length, tmp.length);\n-    assertTrue(tmp.length > 0);\n-    for (int i = 0; i < res.length; i++) {\n-      assertTrue(Arrays.equals(res[i], tmp[i])); \n-    }\n-  }\n-  \n-  public void testBackslashEscaping() throws IOException {\n-\n-    // To avoid confusion over the need for escaping chars in java code,\n-    // We will test with a forward slash as the escape char, and a single\n-    // quote as the encapsulator.\n-\n-    String code =\n-      \"one,two,three\\n\" // 0\n-      + \"'',''\\n\"       // 1) empty encapsulators\n-      + \"/',/'\\n\"       // 2) single encapsulators\n-      + \"'/'','/''\\n\"   // 3) single encapsulators encapsulated via escape\n-      + \"'''',''''\\n\"   // 4) single encapsulators encapsulated via doubling\n-      + \"/,,/,\\n\"       // 5) separator escaped\n-      + \"//,//\\n\"       // 6) escape escaped\n-      + \"'//','//'\\n\"   // 7) escape escaped in encapsulation\n-      + \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\"     // don't eat spaces\n-      + \"9,   /\\n   \\n\"  // escaped newline\n-      + \"\";\n-    String[][] res = {\n-        { \"one\", \"two\", \"three\" }, // 0\n-        { \"\", \"\" },                // 1\n-        { \"'\", \"'\" },              // 2\n-        { \"'\", \"'\" },              // 3\n-        { \"'\", \"'\" },              // 4\n-        { \",\", \",\" },              // 5\n-        { \"/\", \"/\" },              // 6\n-        { \"/\", \"/\" },              // 7\n-        { \"   8   \", \"   \\\"quoted \\\"\\\" \\\" / string\\\"   \" },\n-        { \"9\", \"   \\n   \" },\n-      };\n-\n-\n-    CSVStrategy strategy = new CSVStrategy(',','\\'',CSVStrategy.COMMENTS_DISABLED,'/',false,false,true,true);\n-\n-    CSVParser parser = new CSVParser(new StringReader(code), strategy);\n-    String[][] tmp = parser.getAllValues();\n-    assertTrue(tmp.length > 0);\n-    for (int i = 0; i < res.length; i++) {\n-      assertTrue(Arrays.equals(res[i], tmp[i]));\n-    }\n-  }\n-\n-  public void testBackslashEscaping2() throws IOException {\n-\n-    // To avoid confusion over the need for escaping chars in java code,\n-    // We will test with a forward slash as the escape char, and a single\n-    // quote as the encapsulator.\n-\n-    String code = \"\"\n-      + \" , , \\n\"           // 1)\n-      + \" \\t ,  , \\n\"       // 2)\n-      + \" // , /, , /,\\n\"   // 3)\n-      + \"\";\n-    String[][] res = {\n-        { \" \", \" \", \" \" },         // 1\n-        { \" \\t \", \"  \", \" \" },         // 2\n-        { \" / \", \" , \", \" ,\" },         //3\n-      };\n-\n-\n-    CSVStrategy strategy = new CSVStrategy(',',CSVStrategy.ENCAPSULATOR_DISABLED,CSVStrategy.COMMENTS_DISABLED,'/',false,false,true,true);\n-\n-    CSVParser parser = new CSVParser(new StringReader(code), strategy);\n-    String[][] tmp = parser.getAllValues();\n-    assertTrue(tmp.length > 0);\n-\n-    if (!CSVPrinterTest.equals(res, tmp)) {\n-      assertTrue(false);\n-    }\n-\n-  }\n-\n-\n-  public void testDefaultStrategy() throws IOException {\n-\n-    String code = \"\"\n-        + \"a,b\\n\"            // 1)\n-        + \"\\\"\\n\\\",\\\" \\\"\\n\"   // 2)\n-        + \"\\\"\\\",#\\n\"   // 2)\n-        ;\n-    String[][] res = {\n-        { \"a\", \"b\" },\n-        { \"\\n\", \" \" },\n-        { \"\", \"#\" },\n-    };\n-\n-    CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY;\n-    assertEquals(CSVStrategy.COMMENTS_DISABLED, strategy.getCommentStart());\n-\n-    CSVParser parser = new CSVParser(new StringReader(code), strategy);\n-    String[][] tmp = parser.getAllValues();\n-    assertTrue(tmp.length > 0);\n-\n-    if (!CSVPrinterTest.equals(res, tmp)) {\n-      assertTrue(false);\n-    }\n-\n-    String[][] res_comments = {\n-        { \"a\", \"b\" },\n-        { \"\\n\", \" \" },\n-        { \"\"},\n-    };\n-\n-    strategy = new CSVStrategy(',','\"','#');\n-    parser = new CSVParser(new StringReader(code), strategy);\n-    tmp = parser.getAllValues();\n-\n-    if (!CSVPrinterTest.equals(res_comments, tmp)) {\n-      assertTrue(false);\n-    }\n-  }\n+        assertTrue(tmp == null);\n+    }\n+\n+    public void testGetAllValues() throws IOException {\n+        CSVParser parser = new CSVParser(new StringReader(code));\n+        String[][] tmp = parser.getAllValues();\n+        assertEquals(res.length, tmp.length);\n+        assertTrue(tmp.length > 0);\n+        for (int i = 0; i < res.length; i++) {\n+            assertTrue(Arrays.equals(res[i], tmp[i]));\n+        }\n+    }\n+\n+    public void testExcelStrategy1() throws IOException {\n+        String code =\n+                \"value1,value2,value3,value4\\r\\na,b,c,d\\r\\n  x,,,\"\n+                        + \"\\r\\n\\r\\n\\\"\\\"\\\"hello\\\"\\\"\\\",\\\"  \\\"\\\"world\\\"\\\"\\\",\\\"abc\\ndef\\\",\\r\\n\";\n+        String[][] res = {\n+                {\"value1\", \"value2\", \"value3\", \"value4\"},\n+                {\"a\", \"b\", \"c\", \"d\"},\n+                {\"  x\", \"\", \"\", \"\"},\n+                {\"\"},\n+                {\"\\\"hello\\\"\", \"  \\\"world\\\"\", \"abc\\ndef\", \"\"}\n+        };\n+        CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n+        String[][] tmp = parser.getAllValues();\n+        assertEquals(res.length, tmp.length);\n+        assertTrue(tmp.length > 0);\n+        for (int i = 0; i < res.length; i++) {\n+            assertTrue(Arrays.equals(res[i], tmp[i]));\n+        }\n+    }\n+\n+    public void testExcelStrategy2() throws Exception {\n+        String code = \"foo,baar\\r\\n\\r\\nhello,\\r\\n\\r\\nworld,\\r\\n\";\n+        String[][] res = {\n+                {\"foo\", \"baar\"},\n+                {\"\"},\n+                {\"hello\", \"\"},\n+                {\"\"},\n+                {\"world\", \"\"}\n+        };\n+        CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n+        String[][] tmp = parser.getAllValues();\n+        assertEquals(res.length, tmp.length);\n+        assertTrue(tmp.length > 0);\n+        for (int i = 0; i < res.length; i++) {\n+            assertTrue(Arrays.equals(res[i], tmp[i]));\n+        }\n+    }\n+\n+    public void testEndOfFileBehaviourExcel() throws Exception {\n+        String[] codes = {\n+                \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n+                \"hello,\\r\\n\\r\\nworld,\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n+        };\n+        String[][] res = {\n+                {\"hello\", \"\"},\n+                {\"\"},  // ExcelStrategy does not ignore empty lines\n+                {\"world\", \"\"}\n+        };\n+        String code;\n+        for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n+            code = codes[codeIndex];\n+            CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n+            String[][] tmp = parser.getAllValues();\n+            assertEquals(res.length, tmp.length);\n+            assertTrue(tmp.length > 0);\n+            for (int i = 0; i < res.length; i++) {\n+                assertTrue(Arrays.equals(res[i], tmp[i]));\n+            }\n+        }\n+    }\n+\n+    public void testEndOfFileBehaviorCSV() throws Exception {\n+        String[] codes = {\n+                \"hello,\\r\\n\\r\\nworld,\\r\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\r\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\",\n+                \"hello,\\r\\n\\r\\nworld,\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\\n\",\n+                \"hello,\\r\\n\\r\\nworld,\\\"\\\"\"\n+        };\n+        String[][] res = {\n+                {\"hello\", \"\"},  // CSV Strategy ignores empty lines\n+                {\"world\", \"\"}\n+        };\n+        String code;\n+        for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n+            code = codes[codeIndex];\n+            CSVParser parser = new CSVParser(new StringReader(code));\n+            String[][] tmp = parser.getAllValues();\n+            assertEquals(res.length, tmp.length);\n+            assertTrue(tmp.length > 0);\n+            for (int i = 0; i < res.length; i++) {\n+                assertTrue(Arrays.equals(res[i], tmp[i]));\n+            }\n+        }\n+    }\n+\n+    public void testEmptyLineBehaviourExcel() throws Exception {\n+        String[] codes = {\n+                \"hello,\\r\\n\\r\\n\\r\\n\",\n+                \"hello,\\n\\n\\n\",\n+                \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n+                \"hello,\\\"\\\"\\n\\n\\n\"\n+        };\n+        String[][] res = {\n+                {\"hello\", \"\"},\n+                {\"\"},  // ExcelStrategy does not ignore empty lines\n+                {\"\"}\n+        };\n+        String code;\n+        for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n+            code = codes[codeIndex];\n+            CSVParser parser = new CSVParser(new StringReader(code), CSVStrategy.EXCEL_STRATEGY);\n+            String[][] tmp = parser.getAllValues();\n+            assertEquals(res.length, tmp.length);\n+            assertTrue(tmp.length > 0);\n+            for (int i = 0; i < res.length; i++) {\n+                assertTrue(Arrays.equals(res[i], tmp[i]));\n+            }\n+        }\n+    }\n+\n+    public void testEmptyLineBehaviourCSV() throws Exception {\n+        String[] codes = {\n+                \"hello,\\r\\n\\r\\n\\r\\n\",\n+                \"hello,\\n\\n\\n\",\n+                \"hello,\\\"\\\"\\r\\n\\r\\n\\r\\n\",\n+                \"hello,\\\"\\\"\\n\\n\\n\"\n+        };\n+        String[][] res = {\n+                {\"hello\", \"\"}  // CSV Strategy ignores empty lines\n+        };\n+        String code;\n+        for (int codeIndex = 0; codeIndex < codes.length; codeIndex++) {\n+            code = codes[codeIndex];\n+            CSVParser parser = new CSVParser(new StringReader(code));\n+            String[][] tmp = parser.getAllValues();\n+            assertEquals(res.length, tmp.length);\n+            assertTrue(tmp.length > 0);\n+            for (int i = 0; i < res.length; i++) {\n+                assertTrue(Arrays.equals(res[i], tmp[i]));\n+            }\n+        }\n+    }\n+\n+    public void OLDtestBackslashEscaping() throws IOException {\n+        String code =\n+                \"one,two,three\\n\"\n+                        + \"on\\\\\\\"e,two\\n\"\n+                        + \"on\\\"e,two\\n\"\n+                        + \"one,\\\"tw\\\\\\\"o\\\"\\n\"\n+                        + \"one,\\\"t\\\\,wo\\\"\\n\"\n+                        + \"one,two,\\\"th,ree\\\"\\n\"\n+                        + \"\\\"a\\\\\\\\\\\"\\n\"\n+                        + \"a\\\\,b\\n\"\n+                        + \"\\\"a\\\\\\\\,b\\\"\";\n+        String[][] res = {\n+                {\"one\", \"two\", \"three\"},\n+                {\"on\\\\\\\"e\", \"two\"},\n+                {\"on\\\"e\", \"two\"},\n+                {\"one\", \"tw\\\"o\"},\n+                {\"one\", \"t\\\\,wo\"},  // backslash in quotes only escapes a delimiter (\",\")\n+                {\"one\", \"two\", \"th,ree\"},\n+                {\"a\\\\\\\\\"},     // backslash in quotes only escapes a delimiter (\",\")\n+                {\"a\\\\\", \"b\"},  // a backslash must be returnd\n+                {\"a\\\\\\\\,b\"}    // backslash in quotes only escapes a delimiter (\",\")\n+        };\n+        CSVParser parser = new CSVParser(new StringReader(code));\n+        String[][] tmp = parser.getAllValues();\n+        assertEquals(res.length, tmp.length);\n+        assertTrue(tmp.length > 0);\n+        for (int i = 0; i < res.length; i++) {\n+            assertTrue(Arrays.equals(res[i], tmp[i]));\n+        }\n+    }\n+\n+    public void testBackslashEscaping() throws IOException {\n+\n+        // To avoid confusion over the need for escaping chars in java code,\n+        // We will test with a forward slash as the escape char, and a single\n+        // quote as the encapsulator.\n+\n+        String code =\n+                \"one,two,three\\n\" // 0\n+                        + \"'',''\\n\"       // 1) empty encapsulators\n+                        + \"/',/'\\n\"       // 2) single encapsulators\n+                        + \"'/'','/''\\n\"   // 3) single encapsulators encapsulated via escape\n+                        + \"'''',''''\\n\"   // 4) single encapsulators encapsulated via doubling\n+                        + \"/,,/,\\n\"       // 5) separator escaped\n+                        + \"//,//\\n\"       // 6) escape escaped\n+                        + \"'//','//'\\n\"   // 7) escape escaped in encapsulation\n+                        + \"   8   ,   \\\"quoted \\\"\\\" /\\\" // string\\\"   \\n\"     // don't eat spaces\n+                        + \"9,   /\\n   \\n\"  // escaped newline\n+                        + \"\";\n+        String[][] res = {\n+                {\"one\", \"two\", \"three\"}, // 0\n+                {\"\", \"\"},                // 1\n+                {\"'\", \"'\"},              // 2\n+                {\"'\", \"'\"},              // 3\n+                {\"'\", \"'\"},              // 4\n+                {\",\", \",\"},              // 5\n+                {\"/\", \"/\"},              // 6\n+                {\"/\", \"/\"},              // 7\n+                {\"   8   \", \"   \\\"quoted \\\"\\\" \\\" / string\\\"   \"},\n+                {\"9\", \"   \\n   \"},\n+        };\n+\n+\n+        CSVStrategy strategy = new CSVStrategy(',', '\\'', CSVStrategy.COMMENTS_DISABLED, '/', false, false, true, true);\n+\n+        CSVParser parser = new CSVParser(new StringReader(code), strategy);\n+        String[][] tmp = parser.getAllValues();\n+        assertTrue(tmp.length > 0);\n+        for (int i = 0; i < res.length; i++) {\n+            assertTrue(Arrays.equals(res[i], tmp[i]));\n+        }\n+    }\n+\n+    public void testBackslashEscaping2() throws IOException {\n+\n+        // To avoid confusion over the need for escaping chars in java code,\n+        // We will test with a forward slash as the escape char, and a single\n+        // quote as the encapsulator.\n+\n+        String code = \"\"\n+                + \" , , \\n\"           // 1)\n+                + \" \\t ,  , \\n\"       // 2)\n+                + \" // , /, , /,\\n\"   // 3)\n+                + \"\";\n+        String[][] res = {\n+                {\" \", \" \", \" \"},         // 1\n+                {\" \\t \", \"  \", \" \"},         // 2\n+                {\" / \", \" , \", \" ,\"},         //3\n+        };\n+\n+\n+        CSVStrategy strategy = new CSVStrategy(',', CSVStrategy.ENCAPSULATOR_DISABLED, CSVStrategy.COMMENTS_DISABLED, '/', false, false, true, true);\n+\n+        CSVParser parser = new CSVParser(new StringReader(code), strategy);\n+        String[][] tmp = parser.getAllValues();\n+        assertTrue(tmp.length > 0);\n+\n+        if (!CSVPrinterTest.equals(res, tmp)) {\n+            assertTrue(false);\n+        }\n+\n+    }\n+\n+\n+    public void testDefaultStrategy() throws IOException {\n+\n+        String code = \"\"\n+                + \"a,b\\n\"            // 1)\n+                + \"\\\"\\n\\\",\\\" \\\"\\n\"   // 2)\n+                + \"\\\"\\\",#\\n\"   // 2)\n+                ;\n+        String[][] res = {\n+                {\"a\", \"b\"},\n+                {\"\\n\", \" \"},\n+                {\"\", \"#\"},\n+        };\n+\n+        CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY;\n+        assertEquals(CSVStrategy.COMMENTS_DISABLED, strategy.getCommentStart());\n+\n+        CSVParser parser = new CSVParser(new StringReader(code), strategy);\n+        String[][] tmp = parser.getAllValues();\n+        assertTrue(tmp.length > 0);\n+\n+        if (!CSVPrinterTest.equals(res, tmp)) {\n+            assertTrue(false);\n+        }\n+\n+        String[][] res_comments = {\n+                {\"a\", \"b\"},\n+                {\"\\n\", \" \"},\n+                {\"\"},\n+        };\n+\n+        strategy = new CSVStrategy(',', '\"', '#');\n+        parser = new CSVParser(new StringReader(code), strategy);\n+        tmp = parser.getAllValues();\n+\n+        if (!CSVPrinterTest.equals(res_comments, tmp)) {\n+            assertTrue(false);\n+        }\n+    }\n \n \n     public void testUnicodeEscape() throws IOException {\n-      String code = \"abc,\\\\u0070\\\\u0075\\\\u0062\\\\u006C\\\\u0069\\\\u0063\";\n-      CSVParser parser = new CSVParser(new StringReader(code));\n-      parser.getStrategy().setUnicodeEscapeInterpretation(true);\n-      String[] data = parser.getLine();\n-      assertEquals(2, data.length);\n-      assertEquals(\"abc\", data[0]);\n-      assertEquals(\"public\", data[1]);\n-    }\n-    \n+        String code = \"abc,\\\\u0070\\\\u0075\\\\u0062\\\\u006C\\\\u0069\\\\u0063\";\n+        CSVParser parser = new CSVParser(new StringReader(code));\n+        parser.getStrategy().setUnicodeEscapeInterpretation(true);\n+        String[] data = parser.getLine();\n+        assertEquals(2, data.length);\n+        assertEquals(\"abc\", data[0]);\n+        assertEquals(\"public\", data[1]);\n+    }\n+\n     public void testCarriageReturnLineFeedEndings() throws IOException {\n-     String code = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n-     CSVParser parser = new CSVParser(new StringReader(code));\n-     String[][] data = parser.getAllValues();\n-     assertEquals(4, data.length);\n+        String code = \"foo\\r\\nbaar,\\r\\nhello,world\\r\\n,kanu\";\n+        CSVParser parser = new CSVParser(new StringReader(code));\n+        String[][] data = parser.getAllValues();\n+        assertEquals(4, data.length);\n     }\n \n     public void testCarriageReturnEndings() throws IOException {\n-     String code = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n-     CSVParser parser = new CSVParser(new StringReader(code));\n-     String[][] data = parser.getAllValues();\n-     assertEquals(4, data.length);\n+        String code = \"foo\\rbaar,\\rhello,world\\r,kanu\";\n+        CSVParser parser = new CSVParser(new StringReader(code));\n+        String[][] data = parser.getAllValues();\n+        assertEquals(4, data.length);\n     }\n \n     public void testLineFeedEndings() throws IOException {\n-     String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n-     CSVParser parser = new CSVParser(new StringReader(code));\n-     String[][] data = parser.getAllValues();\n-     assertEquals(4, data.length);\n+        String code = \"foo\\nbaar,\\nhello,world\\n,kanu\";\n+        CSVParser parser = new CSVParser(new StringReader(code));\n+        String[][] data = parser.getAllValues();\n+        assertEquals(4, data.length);\n     }\n \n     public void testIgnoreEmptyLines() throws IOException {\n-      String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n-      //String code = \"world\\r\\n\\n\";\n-      //String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n-      CSVParser parser = new CSVParser(new StringReader(code));\n-      String[][] data = parser.getAllValues();\n-      assertEquals(3, data.length);\n-    }\n-    \n+        String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n+        //String code = \"world\\r\\n\\n\";\n+        //String code = \"foo;baar\\r\\n\\r\\nhello;\\r\\n\\r\\nworld;\\r\\n\";\n+        CSVParser parser = new CSVParser(new StringReader(code));\n+        String[][] data = parser.getAllValues();\n+        assertEquals(3, data.length);\n+    }\n+\n     public void testLineTokenConsistency() throws IOException {\n-      String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n-      CSVParser parser = new CSVParser(new StringReader(code));\n-      String[][] data = parser.getAllValues();\n-      parser = new CSVParser(new StringReader(code));\n-      CSVParser parser1 = new CSVParser(new StringReader(code));\n-      for (int i = 0; i < data.length; i++) {\n-        assertTrue(Arrays.equals(parser1.getLine(), data[i]));\n-        for (int j = 0; j < data[i].length; j++) {\n-          assertEquals(parser.nextValue(), data[i][j]);\n-        }\n-      }\n+        String code = \"\\nfoo,baar\\n\\r\\n,\\n\\n,world\\r\\n\\n\";\n+        CSVParser parser = new CSVParser(new StringReader(code));\n+        String[][] data = parser.getAllValues();\n+        parser = new CSVParser(new StringReader(code));\n+        CSVParser parser1 = new CSVParser(new StringReader(code));\n+        for (int i = 0; i < data.length; i++) {\n+            assertTrue(Arrays.equals(parser1.getLine(), data[i]));\n+            for (int j = 0; j < data[i].length; j++) {\n+                assertEquals(parser.nextValue(), data[i][j]);\n+            }\n+        }\n     }\n \n     // From SANDBOX-153\n-     public void testDelimiterIsWhitespace() throws IOException {\n-         String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n-         TestCSVParser parser = new TestCSVParser(new StringReader(code), CSVStrategy.TDF_STRATEGY);\n-         assertEquals(CSVParser.TT_TOKEN + \";one;\", parser.testNextToken());\n-         assertEquals(CSVParser.TT_TOKEN + \";two;\", parser.testNextToken());\n-         assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n-         assertEquals(CSVParser.TT_TOKEN + \";four;\", parser.testNextToken());\n-         assertEquals(CSVParser.TT_TOKEN + \";five;\", parser.testNextToken());\n-         assertEquals(CSVParser.TT_EOF + \";six;\", parser.testNextToken());\n-     }\n+    public void testDelimiterIsWhitespace() throws IOException {\n+        String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n+        TestCSVParser parser = new TestCSVParser(new StringReader(code), CSVStrategy.TDF_STRATEGY);\n+        assertEquals(CSVParser.TT_TOKEN + \";one;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";two;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";four;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_TOKEN + \";five;\", parser.testNextToken());\n+        assertEquals(CSVParser.TT_EOF + \";six;\", parser.testNextToken());\n+    }\n }\n--- a/src/test/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/org/apache/commons/csv/CSVPrinterTest.java\n  * CSVPrinterTest\n  */\n public class CSVPrinterTest extends TestCase {\n-  \n-  String lineSeparator = \"\\n\";\n-\n-  public void testPrinter1() throws IOException {\n-    StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n-    String[] line1 = {\"a\", \"b\"};\n-    printer.println(line1);\n-    assertEquals(\"a,b\" + lineSeparator, sw.toString());\n-  }\n-\n-  public void testPrinter2() throws IOException {\n-    StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n-    String[] line1 = {\"a,b\", \"b\"};\n-    printer.println(line1);\n-    assertEquals(\"\\\"a,b\\\",b\" + lineSeparator, sw.toString());\n-  }\n-\n-  public void testPrinter3() throws IOException {\n-    StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n-    String[] line1 = {\"a, b\", \"b \"};\n-    printer.println(line1);\n-    assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + lineSeparator, sw.toString());\n-  }\n-\n-  public void testPrinter4() throws IOException {\n-    StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n-    String[] line1 = {\"a\", \"b\\\"c\"};\n-    printer.println(line1);\n-    assertEquals(\"a,\\\"b\\\"\\\"c\\\"\" + lineSeparator, sw.toString());\n-  }\n-\n-  public void testPrinter5() throws IOException {\n-    StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n-    String[] line1 = {\"a\", \"b\\nc\"};\n-    printer.println(line1);\n-    assertEquals(\"a,\\\"b\\nc\\\"\" + lineSeparator, sw.toString());\n-  }\n-\n-  public void testPrinter6() throws IOException {\n-    StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n-    String[] line1 = {\"a\", \"b\\r\\nc\"};\n-    printer.println(line1);\n-    assertEquals(\"a,\\\"b\\r\\nc\\\"\" + lineSeparator, sw.toString());\n-  }\n-\n-  public void testPrinter7() throws IOException {\n-    StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n-    String[] line1 = {\"a\", \"b\\\\c\"};\n-    printer.println(line1);\n-    assertEquals(\"a,b\\\\c\" + lineSeparator, sw.toString());\n-  }\n-\n-  public void testExcelPrinter1() throws IOException {\n-    StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.EXCEL_STRATEGY);\n-    String[] line1 = {\"a\", \"b\"};\n-    printer.println(line1);\n-    assertEquals(\"a,b\" + lineSeparator, sw.toString());\n-  }\n-\n-  public void testExcelPrinter2() throws IOException {\n-    StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.EXCEL_STRATEGY);\n-    String[] line1 = {\"a,b\", \"b\"};\n-    printer.println(line1);\n-    assertEquals(\"\\\"a,b\\\",b\" + lineSeparator, sw.toString());\n-  }\n-\n-\n-  \n-  public void testRandom() throws Exception {\n-    int iter=10000;\n-    strategy = CSVStrategy.DEFAULT_STRATEGY;\n-    doRandom(iter);\n-    strategy = CSVStrategy.EXCEL_STRATEGY;\n-    doRandom(iter);\n-\n-    // Strategy for MySQL\n-    strategy = new CSVStrategy('\\t', CSVStrategy.ENCAPSULATOR_DISABLED, CSVStrategy.COMMENTS_DISABLED,'\\\\',false, false, false, false);\n-    doRandom(iter);\n-  }\n-\n-  Random r = new Random();\n-  CSVStrategy strategy;\n-\n-  public void doRandom(int iter) throws Exception {\n-    for (int i=0; i<iter; i++) {\n-      doOneRandom();\n-    }\n-  }\n-\n-  public void doOneRandom() throws Exception {\n-    int nLines = r.nextInt(4)+1;\n-    int nCol = r.nextInt(3)+1;\n-    // nLines=1;nCol=2;\n-    String[][] lines = new String[nLines][];\n-    for (int i=0; i<nLines; i++) {\n-      String[] line = new String[nCol];\n-      lines[i] = line;\n-      for (int j=0; j<nCol; j++) {\n-        line[j] = randStr();\n-      }\n-    }\n-\n-    StringWriter sw = new StringWriter();\n-    CSVPrinter printer = new CSVPrinter(sw, strategy);\n-\n-    for (int i=0; i<nLines; i++) {\n-      // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));      \n-      printer.println(lines[i]);\n-    }\n-\n-    printer.flush();\n-    String result = sw.toString();\n-    // System.out.println(\"### :\" + printable(result));\n-\n-    StringReader reader = new StringReader(result);\n-\n-    CSVParser parser = new CSVParser(reader, strategy);\n-    String[][] parseResult = parser.getAllValues();\n-\n-    if (!equals(lines, parseResult)) {\n-      System.out.println(\"Printer output :\" + printable(result));\n-      assertTrue(false);\n-    }\n-  }\n-\n-  public static boolean equals(String[][] a, String[][] b) {\n-    if (a.length != b.length) {\n-      return false;\n-    }\n-    for (int i=0; i<a.length; i++) {\n-      String[] linea = a[i];\n-      String[] lineb = b[i];\n-      if (linea.length != lineb.length) {\n-        return false;\n-      }\n-      for (int j=0; j<linea.length; j++) {\n-        String aval = linea[j];\n-        String bval = lineb[j];\n-        if (!aval.equals(bval)) {\n-          System.out.println(\"expected  :\" + printable(aval));\n-          System.out.println(\"got       :\" + printable(bval));\n-          return false;\n-        }\n-      }\n-    }\n-    return true;\n-  }\n-\n-  public static String printable(String s) {\n-    StringBuffer sb = new StringBuffer();\n-    for (int i=0; i<s.length(); i++) {\n-      char ch = s.charAt(i);\n-      if (ch<=' ' || ch>=128) {\n-        sb.append(\"(\" + (int)ch + \")\");\n-      } else {\n-        sb.append(ch);\n-      }\n-    }\n-    return sb.toString();\n-  }\n-\n-  public String randStr() {\n-    int sz = r.nextInt(20);\n-    // sz = r.nextInt(3);\n-    char[] buf = new char[sz];\n-    for (int i=0; i<sz; i++) {\n-      // stick in special chars with greater frequency\n-      char ch;\n-      int what = r.nextInt(20);\n-      switch (what) {\n-        case 0: ch = '\\r'; break;\n-        case 1: ch = '\\n'; break;\n-        case 2: ch = '\\t'; break;\n-        case 3: ch = '\\f'; break;\n-        case 4: ch = ' ';  break;\n-        case 5: ch = ',';  break;\n-        case 6: ch = '\"';  break;\n-        case 7: ch = '\\''; break;\n-        case 8: ch = '\\\\'; break;\n-        default: ch = (char)r.nextInt(300); break;\n-        // default: ch = 'a'; break;\n-      }\n-      buf[i] = ch;\n-    }\n-    return new String(buf);\n-  }\n+\n+    String lineSeparator = \"\\n\";\n+\n+    public void testPrinter1() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        String[] line1 = {\"a\", \"b\"};\n+        printer.println(line1);\n+        assertEquals(\"a,b\" + lineSeparator, sw.toString());\n+    }\n+\n+    public void testPrinter2() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        String[] line1 = {\"a,b\", \"b\"};\n+        printer.println(line1);\n+        assertEquals(\"\\\"a,b\\\",b\" + lineSeparator, sw.toString());\n+    }\n+\n+    public void testPrinter3() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        String[] line1 = {\"a, b\", \"b \"};\n+        printer.println(line1);\n+        assertEquals(\"\\\"a, b\\\",\\\"b \\\"\" + lineSeparator, sw.toString());\n+    }\n+\n+    public void testPrinter4() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        String[] line1 = {\"a\", \"b\\\"c\"};\n+        printer.println(line1);\n+        assertEquals(\"a,\\\"b\\\"\\\"c\\\"\" + lineSeparator, sw.toString());\n+    }\n+\n+    public void testPrinter5() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        String[] line1 = {\"a\", \"b\\nc\"};\n+        printer.println(line1);\n+        assertEquals(\"a,\\\"b\\nc\\\"\" + lineSeparator, sw.toString());\n+    }\n+\n+    public void testPrinter6() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        String[] line1 = {\"a\", \"b\\r\\nc\"};\n+        printer.println(line1);\n+        assertEquals(\"a,\\\"b\\r\\nc\\\"\" + lineSeparator, sw.toString());\n+    }\n+\n+    public void testPrinter7() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.DEFAULT_STRATEGY);\n+        String[] line1 = {\"a\", \"b\\\\c\"};\n+        printer.println(line1);\n+        assertEquals(\"a,b\\\\c\" + lineSeparator, sw.toString());\n+    }\n+\n+    public void testExcelPrinter1() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.EXCEL_STRATEGY);\n+        String[] line1 = {\"a\", \"b\"};\n+        printer.println(line1);\n+        assertEquals(\"a,b\" + lineSeparator, sw.toString());\n+    }\n+\n+    public void testExcelPrinter2() throws IOException {\n+        StringWriter sw = new StringWriter();\n+        CSVPrinter printer = new CSVPrinter(sw, CSVStrategy.EXCEL_STRATEGY);\n+        String[] line1 = {\"a,b\", \"b\"};\n+        printer.println(line1);\n+        assertEquals(\"\\\"a,b\\\",b\" + lineSeparator, sw.toString());\n+    }\n+\n+\n+    public void testRandom() throws Exception {\n+        int iter = 10000;\n+        strategy = CSVStrategy.DEFAULT_STRATEGY;\n+        doRandom(iter);\n+        strategy = CSVStrategy.EXCEL_STRATEGY;\n+        doRandom(iter);\n+\n+        // Strategy for MySQL\n+        strategy = new CSVStrategy('\\t', CSVStrategy.ENCAPSULATOR_DISABLED, CSVStrategy.COMMENTS_DISABLED, '\\\\', false, false, false, false);\n+        doRandom(iter);\n+    }\n+\n+    Random r = new Random();\n+    CSVStrategy strategy;\n+\n+    public void doRandom(int iter) throws Exception {\n+        for (int i = 0; i < iter; i++) {\n+            doOneRandom();\n+        }\n+    }\n+\n+    public void doOneRandom() throws Exception {\n+        int nLines = r.nextInt(4) + 1;\n+        int nCol = r.nextInt(3) + 1;\n+        // nLines=1;nCol=2;\n+        String[][] lines = new String[nLines][];\n+        for (int i = 0; i < nLines; i++) {\n+            String[] line = new String[nCol];\n+            lines[i] = line;\n+            for (int j = 0; j < nCol; j++) {\n+                line[j] = randStr();\n+            }\n+        }\n+\n+        StringWriter sw = new StringWriter();\n+        CSVPrinter printer = new CSVPrinter(sw, strategy);\n+\n+        for (int i = 0; i < nLines; i++) {\n+            // for (int j=0; j<lines[i].length; j++) System.out.println(\"### VALUE=:\" + printable(lines[i][j]));\n+            printer.println(lines[i]);\n+        }\n+\n+        printer.flush();\n+        String result = sw.toString();\n+        // System.out.println(\"### :\" + printable(result));\n+\n+        StringReader reader = new StringReader(result);\n+\n+        CSVParser parser = new CSVParser(reader, strategy);\n+        String[][] parseResult = parser.getAllValues();\n+\n+        if (!equals(lines, parseResult)) {\n+            System.out.println(\"Printer output :\" + printable(result));\n+            assertTrue(false);\n+        }\n+    }\n+\n+    public static boolean equals(String[][] a, String[][] b) {\n+        if (a.length != b.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < a.length; i++) {\n+            String[] linea = a[i];\n+            String[] lineb = b[i];\n+            if (linea.length != lineb.length) {\n+                return false;\n+            }\n+            for (int j = 0; j < linea.length; j++) {\n+                String aval = linea[j];\n+                String bval = lineb[j];\n+                if (!aval.equals(bval)) {\n+                    System.out.println(\"expected  :\" + printable(aval));\n+                    System.out.println(\"got       :\" + printable(bval));\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public static String printable(String s) {\n+        StringBuffer sb = new StringBuffer();\n+        for (int i = 0; i < s.length(); i++) {\n+            char ch = s.charAt(i);\n+            if (ch <= ' ' || ch >= 128) {\n+                sb.append(\"(\" + (int) ch + \")\");\n+            } else {\n+                sb.append(ch);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    public String randStr() {\n+        int sz = r.nextInt(20);\n+        // sz = r.nextInt(3);\n+        char[] buf = new char[sz];\n+        for (int i = 0; i < sz; i++) {\n+            // stick in special chars with greater frequency\n+            char ch;\n+            int what = r.nextInt(20);\n+            switch (what) {\n+                case 0:\n+                    ch = '\\r';\n+                    break;\n+                case 1:\n+                    ch = '\\n';\n+                    break;\n+                case 2:\n+                    ch = '\\t';\n+                    break;\n+                case 3:\n+                    ch = '\\f';\n+                    break;\n+                case 4:\n+                    ch = ' ';\n+                    break;\n+                case 5:\n+                    ch = ',';\n+                    break;\n+                case 6:\n+                    ch = '\"';\n+                    break;\n+                case 7:\n+                    ch = '\\'';\n+                    break;\n+                case 8:\n+                    ch = '\\\\';\n+                    break;\n+                default:\n+                    ch = (char) r.nextInt(300);\n+                    break;\n+                // default: ch = 'a'; break;\n+            }\n+            buf[i] = ch;\n+        }\n+        return new String(buf);\n+    }\n \n }\n--- a/src/test/org/apache/commons/csv/CSVStrategyTest.java\n+++ b/src/test/org/apache/commons/csv/CSVStrategyTest.java\n  * CSVStrategyTest\n  *\n  * The test are organized in three different sections:\n- * The 'setter/getter' section, the lexer section and finally the strategy \n- * section. In case a test fails, you should follow a top-down approach for \n+ * The 'setter/getter' section, the lexer section and finally the strategy\n+ * section. In case a test fails, you should follow a top-down approach for\n  * fixing a potential bug (its likely that the strategy itself fails if the lexer\n  * has problems...).\n  */\n public class CSVStrategyTest extends TestCase {\n \n-  // ======================================================\n-  //   getters / setters\n-  // ======================================================\n-  public void testGetSetCommentStart() {\n-    CSVStrategy strategy = (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone();\n-    strategy.setCommentStart('#');\n-    assertEquals(strategy.getCommentStart(), '#');\n-    strategy.setCommentStart('!');\n-    assertEquals(strategy.getCommentStart(), '!');\n-  }\n+    // ======================================================\n+    //   getters / setters\n+    // ======================================================\n+    public void testGetSetCommentStart() {\n+        CSVStrategy strategy = (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone();\n+        strategy.setCommentStart('#');\n+        assertEquals(strategy.getCommentStart(), '#');\n+        strategy.setCommentStart('!');\n+        assertEquals(strategy.getCommentStart(), '!');\n+    }\n \n-  public void testGetSetEncapsulator() {\n-    CSVStrategy strategy = (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone();\n-    strategy.setEncapsulator('\"');\n-    assertEquals(strategy.getEncapsulator(), '\"');\n-    strategy.setEncapsulator('\\'');\n-    assertEquals(strategy.getEncapsulator(), '\\'');\n-  }\n+    public void testGetSetEncapsulator() {\n+        CSVStrategy strategy = (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone();\n+        strategy.setEncapsulator('\"');\n+        assertEquals(strategy.getEncapsulator(), '\"');\n+        strategy.setEncapsulator('\\'');\n+        assertEquals(strategy.getEncapsulator(), '\\'');\n+    }\n \n-  public void testGetSetDelimiter() {\n-    CSVStrategy strategy = (CSVStrategy)CSVStrategy.DEFAULT_STRATEGY.clone();\n-    strategy.setDelimiter(';');\n-    assertEquals(strategy.getDelimiter(), ';');\n-    strategy.setDelimiter(',');\n-    assertEquals(strategy.getDelimiter(), ',');\n-    strategy.setDelimiter('\\t');\n-    assertEquals(strategy.getDelimiter(), '\\t');\n-  }\n+    public void testGetSetDelimiter() {\n+        CSVStrategy strategy = (CSVStrategy) CSVStrategy.DEFAULT_STRATEGY.clone();\n+        strategy.setDelimiter(';');\n+        assertEquals(strategy.getDelimiter(), ';');\n+        strategy.setDelimiter(',');\n+        assertEquals(strategy.getDelimiter(), ',');\n+        strategy.setDelimiter('\\t');\n+        assertEquals(strategy.getDelimiter(), '\\t');\n+    }\n \n-  public void testSetCSVStrategy() {\n-    CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY;\n-    // default settings\n-    assertEquals(strategy.getDelimiter(), ',');\n-    assertEquals(strategy.getEncapsulator(), '\"');\n-    assertEquals(strategy.getCommentStart(), CSVStrategy.COMMENTS_DISABLED);\n-    assertEquals(true,  strategy.getIgnoreLeadingWhitespaces());\n-    assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n-    assertEquals(true,  strategy.getIgnoreEmptyLines());\n-    // explicit csv settings\n-    assertEquals(strategy.getDelimiter(), ',');\n-    assertEquals(strategy.getEncapsulator(), '\"');\n-    assertEquals(strategy.getCommentStart(), CSVStrategy.COMMENTS_DISABLED);\n-    assertEquals(true,  strategy.getIgnoreLeadingWhitespaces());\n-    assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n-    assertEquals(true,  strategy.getIgnoreEmptyLines());\n-  }\n-  \n-  public void testSetExcelStrategy() {\n-    CSVStrategy strategy = CSVStrategy.EXCEL_STRATEGY;\n-    assertEquals(strategy.getDelimiter(), ',');\n-    assertEquals(strategy.getEncapsulator(), '\"');\n-    assertEquals(strategy.getCommentStart(), CSVStrategy.COMMENTS_DISABLED);\n-    assertEquals(false,  strategy.getIgnoreLeadingWhitespaces());\n-    assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n-    assertEquals(false, strategy.getIgnoreEmptyLines());\n-  }\n-  \n+    public void testSetCSVStrategy() {\n+        CSVStrategy strategy = CSVStrategy.DEFAULT_STRATEGY;\n+        // default settings\n+        assertEquals(strategy.getDelimiter(), ',');\n+        assertEquals(strategy.getEncapsulator(), '\"');\n+        assertEquals(strategy.getCommentStart(), CSVStrategy.COMMENTS_DISABLED);\n+        assertEquals(true, strategy.getIgnoreLeadingWhitespaces());\n+        assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n+        assertEquals(true, strategy.getIgnoreEmptyLines());\n+        // explicit csv settings\n+        assertEquals(strategy.getDelimiter(), ',');\n+        assertEquals(strategy.getEncapsulator(), '\"');\n+        assertEquals(strategy.getCommentStart(), CSVStrategy.COMMENTS_DISABLED);\n+        assertEquals(true, strategy.getIgnoreLeadingWhitespaces());\n+        assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n+        assertEquals(true, strategy.getIgnoreEmptyLines());\n+    }\n+\n+    public void testSetExcelStrategy() {\n+        CSVStrategy strategy = CSVStrategy.EXCEL_STRATEGY;\n+        assertEquals(strategy.getDelimiter(), ',');\n+        assertEquals(strategy.getEncapsulator(), '\"');\n+        assertEquals(strategy.getCommentStart(), CSVStrategy.COMMENTS_DISABLED);\n+        assertEquals(false, strategy.getIgnoreLeadingWhitespaces());\n+        assertEquals(false, strategy.getUnicodeEscapeInterpretation());\n+        assertEquals(false, strategy.getIgnoreEmptyLines());\n+    }\n+\n } \n--- a/src/test/org/apache/commons/csv/CSVUtilsTest.java\n+++ b/src/test/org/apache/commons/csv/CSVUtilsTest.java\n  * CSVUtilsTest\n  */\n public class CSVUtilsTest extends TestCase {\n-  \n-  // ======================================================\n-  //   static parser tests\n-  // ======================================================\n-  public void testParse1() throws IOException {\n-      String[][] data = CSVUtils.parse(\"abc\\ndef\");\n-      assertEquals(2, data.length);\n-      assertEquals(1, data[0].length);\n-      assertEquals(1, data[1].length);\n-      assertEquals(\"abc\", data[0][0]);\n-      assertEquals(\"def\", data[1][0]);\n+\n+    // ======================================================\n+    //   static parser tests\n+    // ======================================================\n+    public void testParse1() throws IOException {\n+        String[][] data = CSVUtils.parse(\"abc\\ndef\");\n+        assertEquals(2, data.length);\n+        assertEquals(1, data[0].length);\n+        assertEquals(1, data[1].length);\n+        assertEquals(\"abc\", data[0][0]);\n+        assertEquals(\"def\", data[1][0]);\n     }\n \n     public void testParse2() throws IOException {\n-      String[][] data = CSVUtils.parse(\"abc,def,\\\"ghi,jkl\\\"\\ndef\");\n-      assertEquals(2, data.length);\n-      assertEquals(3, data[0].length);\n-      assertEquals(1, data[1].length);\n-      assertEquals(\"abc\", data[0][0]);\n-      assertEquals(\"def\", data[0][1]);\n-      assertEquals(\"ghi,jkl\", data[0][2]);\n-      assertEquals(\"def\", data[1][0]);\n+        String[][] data = CSVUtils.parse(\"abc,def,\\\"ghi,jkl\\\"\\ndef\");\n+        assertEquals(2, data.length);\n+        assertEquals(3, data[0].length);\n+        assertEquals(1, data[1].length);\n+        assertEquals(\"abc\", data[0][0]);\n+        assertEquals(\"def\", data[0][1]);\n+        assertEquals(\"ghi,jkl\", data[0][2]);\n+        assertEquals(\"def\", data[1][0]);\n     }\n \n     public void testParse3() throws IOException {\n-      String[][] data = CSVUtils.parse(\"abc,\\\"def\\nghi\\\"\\njkl\");\n-      assertEquals(2, data.length);\n-      assertEquals(2, data[0].length);\n-      assertEquals(1, data[1].length);\n-      assertEquals(\"abc\", data[0][0]);\n-      assertEquals(\"def\\nghi\", data[0][1]);\n-      assertEquals(\"jkl\", data[1][0]);\n+        String[][] data = CSVUtils.parse(\"abc,\\\"def\\nghi\\\"\\njkl\");\n+        assertEquals(2, data.length);\n+        assertEquals(2, data[0].length);\n+        assertEquals(1, data[1].length);\n+        assertEquals(\"abc\", data[0][0]);\n+        assertEquals(\"def\\nghi\", data[0][1]);\n+        assertEquals(\"jkl\", data[1][0]);\n     }\n \n     public void testParse4() throws IOException {\n-      String[][] data = CSVUtils.parse(\"abc,\\\"def\\\\\\\\nghi\\\"\\njkl\");\n-      assertEquals(2, data.length);\n-      assertEquals(2, data[0].length);\n-      assertEquals(1, data[1].length);\n-      assertEquals(\"abc\", data[0][0]);\n-      // an escape char in quotes only escapes a delimiter, not itself\n-      assertEquals(\"def\\\\\\\\nghi\", data[0][1]);\n-      assertEquals(\"jkl\", data[1][0]);\n+        String[][] data = CSVUtils.parse(\"abc,\\\"def\\\\\\\\nghi\\\"\\njkl\");\n+        assertEquals(2, data.length);\n+        assertEquals(2, data[0].length);\n+        assertEquals(1, data[1].length);\n+        assertEquals(\"abc\", data[0][0]);\n+        // an escape char in quotes only escapes a delimiter, not itself\n+        assertEquals(\"def\\\\\\\\nghi\", data[0][1]);\n+        assertEquals(\"jkl\", data[1][0]);\n     }\n \n     public void testParse5() throws IOException {\n-      String[][] data = CSVUtils.parse(\"abc,def\\\\nghi\\njkl\");\n-      assertEquals(2, data.length);\n-      assertEquals(2, data[0].length);\n-      assertEquals(1, data[1].length);\n-      assertEquals(\"abc\", data[0][0]);\n-      assertEquals(\"def\\\\nghi\", data[0][1]);\n-      assertEquals(\"jkl\", data[1][0]);\n+        String[][] data = CSVUtils.parse(\"abc,def\\\\nghi\\njkl\");\n+        assertEquals(2, data.length);\n+        assertEquals(2, data[0].length);\n+        assertEquals(1, data[1].length);\n+        assertEquals(\"abc\", data[0][0]);\n+        assertEquals(\"def\\\\nghi\", data[0][1]);\n+        assertEquals(\"jkl\", data[1][0]);\n     }\n-    \n+\n     public void testParse6() throws IOException {\n-      String[][] data = CSVUtils.parse(\"\");\n-      // default strategy is CSV, which ignores empty lines\n-      assertEquals(0, data.length);\n+        String[][] data = CSVUtils.parse(\"\");\n+        // default strategy is CSV, which ignores empty lines\n+        assertEquals(0, data.length);\n     }\n-    \n+\n     public void testParse7() throws IOException {\n-      boolean io = false;\n-      try {\n-        CSVUtils.parse(null);\n-      } catch (IllegalArgumentException e) {\n-        io = true;\n-      }\n-      assertTrue(io);\n+        boolean io = false;\n+        try {\n+            CSVUtils.parse(null);\n+        } catch (IllegalArgumentException e) {\n+            io = true;\n+        }\n+        assertTrue(io);\n     }\n-    \n+\n     public void testParseLine1() throws IOException {\n-      String[] data = CSVUtils.parseLine(\"abc,def,ghi\");\n-      assertEquals(3, data.length);\n-      assertEquals(\"abc\", data[0]);\n-      assertEquals(\"def\", data[1]);\n-      assertEquals(\"ghi\", data[2]);\n+        String[] data = CSVUtils.parseLine(\"abc,def,ghi\");\n+        assertEquals(3, data.length);\n+        assertEquals(\"abc\", data[0]);\n+        assertEquals(\"def\", data[1]);\n+        assertEquals(\"ghi\", data[2]);\n     }\n \n     public void testParseLine2() throws IOException {\n-      String[] data = CSVUtils.parseLine(\"abc,def,ghi\\n\");\n-      assertEquals(3, data.length);\n-      assertEquals(\"abc\", data[0]);\n-      assertEquals(\"def\", data[1]);\n-      assertEquals(\"ghi\", data[2]);\n+        String[] data = CSVUtils.parseLine(\"abc,def,ghi\\n\");\n+        assertEquals(3, data.length);\n+        assertEquals(\"abc\", data[0]);\n+        assertEquals(\"def\", data[1]);\n+        assertEquals(\"ghi\", data[2]);\n     }\n \n     public void testParseLine3() throws IOException {\n-      String[] data = CSVUtils.parseLine(\"abc,\\\"def,ghi\\\"\");\n-      assertEquals(2, data.length);\n-      assertEquals(\"abc\", data[0]);\n-      assertEquals(\"def,ghi\", data[1]);\n+        String[] data = CSVUtils.parseLine(\"abc,\\\"def,ghi\\\"\");\n+        assertEquals(2, data.length);\n+        assertEquals(\"abc\", data[0]);\n+        assertEquals(\"def,ghi\", data[1]);\n     }\n \n     public void testParseLine4() throws IOException {\n-      String[] data = CSVUtils.parseLine(\"abc,\\\"def\\nghi\\\"\");\n-      assertEquals(2, data.length);\n-      assertEquals(\"abc\", data[0]);\n-      assertEquals(\"def\\nghi\", data[1]);\n+        String[] data = CSVUtils.parseLine(\"abc,\\\"def\\nghi\\\"\");\n+        assertEquals(2, data.length);\n+        assertEquals(\"abc\", data[0]);\n+        assertEquals(\"def\\nghi\", data[1]);\n     }\n-    \n+\n     public void testParseLine5() throws IOException {\n-      String[] data = CSVUtils.parseLine(\"\");\n-      assertEquals(0, data.length);\n-      // assertEquals(\"\", data[0]);\n+        String[] data = CSVUtils.parseLine(\"\");\n+        assertEquals(0, data.length);\n+        // assertEquals(\"\", data[0]);\n     }\n-    \n+\n     public void testParseLine6() throws IOException {\n-      boolean io = false;\n-      try {\n-        CSVUtils.parseLine(null);\n-      } catch (IllegalArgumentException e) {\n-        io = true;\n-      }\n-      assertTrue(io);\n+        boolean io = false;\n+        try {\n+            CSVUtils.parseLine(null);\n+        } catch (IllegalArgumentException e) {\n+            io = true;\n+        }\n+        assertTrue(io);\n     }\n-    \n+\n     public void testParseLine7() throws IOException {\n-      String[] res = CSVUtils.parseLine(\"\");\n-      assertNotNull(res);\n-      assertEquals(0, res.length);  \n+        String[] res = CSVUtils.parseLine(\"\");\n+        assertNotNull(res);\n+        assertEquals(0, res.length);\n     }\n-      \n+\n }\n--- a/src/test/org/apache/commons/csv/CharBufferTest.java\n+++ b/src/test/org/apache/commons/csv/CharBufferTest.java\n import junit.framework.TestCase;\n \n /**\n- * \n  * @author Ortwin Glck\n  */\n public class CharBufferTest extends TestCase {\n         try {\n             cb = new CharBuffer(0);\n             fail(\"Should not be possible\");\n-        } catch(IllegalArgumentException e) {\n+        } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         cb = new CharBuffer(128);\n         assertEquals(0, cb.length());\n     }\n-    \n+\n     public void testAppendChar() {\n         CharBuffer cb = new CharBuffer(1);\n         String expected = \"\";\n             assertEquals(expected.length(), cb.length());\n         }\n     }\n-    \n+\n     public void testAppendCharArray() {\n         CharBuffer cb = new CharBuffer(1);\n         char[] abcd = \"abcd\".toCharArray();\n         String expected = \"\";\n-        for (int i=0; i<10; i++) {\n+        for (int i = 0; i < 10; i++) {\n             cb.append(abcd);\n             expected += \"abcd\";\n             assertEquals(expected, cb.toString());\n-            assertEquals(4*(i+1), cb.length());\n+            assertEquals(4 * (i + 1), cb.length());\n         }\n     }\n-    \n+\n     public void testAppendString() {\n         CharBuffer cb = new CharBuffer(1);\n         String abcd = \"abcd\";\n         String expected = \"\";\n-        for (int i=0; i<10; i++) {\n+        for (int i = 0; i < 10; i++) {\n             cb.append(abcd);\n             expected += abcd;\n             assertEquals(expected, cb.toString());\n-            assertEquals(4*(i+1), cb.length());\n+            assertEquals(4 * (i + 1), cb.length());\n         }\n     }\n-    \n+\n     public void testAppendStringBuffer() {\n         CharBuffer cb = new CharBuffer(1);\n         StringBuffer abcd = new StringBuffer(\"abcd\");\n         String expected = \"\";\n-        for (int i=0; i<10; i++) {\n+        for (int i = 0; i < 10; i++) {\n             cb.append(abcd);\n             expected += \"abcd\";\n             assertEquals(expected, cb.toString());\n-            assertEquals(4*(i+1), cb.length());\n+            assertEquals(4 * (i + 1), cb.length());\n         }\n     }\n-    \n+\n     public void testAppendCharBuffer() {\n         CharBuffer cb = new CharBuffer(1);\n         CharBuffer abcd = new CharBuffer(17);\n         abcd.append(\"abcd\");\n         String expected = \"\";\n-        for (int i=0; i<10; i++) {\n+        for (int i = 0; i < 10; i++) {\n             cb.append(abcd);\n             expected += \"abcd\";\n             assertEquals(expected, cb.toString());\n-            assertEquals(4*(i+1), cb.length());\n+            assertEquals(4 * (i + 1), cb.length());\n         }\n     }\n-    \n+\n     public void testShrink() {\n         String data = \"123456789012345678901234567890\";\n-        \n+\n         CharBuffer cb = new CharBuffer(data.length() + 100);\n         assertEquals(data.length() + 100, cb.capacity());\n         cb.append(data);\n         assertEquals(data.length(), cb.length());\n         assertEquals(data, cb.toString());\n     }\n-    \n+\n     //-- the following test cases have been adapted from the HttpComponents project\n     //-- written by Oleg Kalnichevski\n-    \n+\n     public void testSimpleAppend() throws Exception {\n         CharBuffer buffer = new CharBuffer(16);\n-        assertEquals(16, buffer.capacity()); \n+        assertEquals(16, buffer.capacity());\n         assertEquals(0, buffer.length());\n         char[] b1 = buffer.getCharacters();\n         assertNotNull(b1);\n         assertEquals(0, b1.length);\n         assertEquals(0, buffer.length());\n-        \n-        char[] tmp = new char[] { '1', '2', '3', '4'};\n+\n+        char[] tmp = new char[]{'1', '2', '3', '4'};\n         buffer.append(tmp);\n-        assertEquals(16, buffer.capacity()); \n+        assertEquals(16, buffer.capacity());\n         assertEquals(4, buffer.length());\n-        \n+\n         char[] b2 = buffer.getCharacters();\n         assertNotNull(b2);\n         assertEquals(4, b2.length);\n             assertEquals(tmp[i], b2[i]);\n         }\n         assertEquals(\"1234\", buffer.toString());\n-        \n+\n         buffer.clear();\n-        assertEquals(16, buffer.capacity()); \n+        assertEquals(16, buffer.capacity());\n         assertEquals(0, buffer.length());\n     }\n-    \n+\n     public void testAppendString2() throws Exception {\n         CharBuffer buffer = new CharBuffer(8);\n         buffer.append(\"stuff\");\n         buffer.append(\" and more stuff\");\n         assertEquals(\"stuff and more stuff\", buffer.toString());\n     }\n-    \n+\n     public void testAppendNull() throws Exception {\n         CharBuffer buffer = new CharBuffer(8);\n-        \n-        buffer.append((StringBuffer)null);\n-        assertEquals(\"\", buffer.toString());\n-        \n-        buffer.append((String)null);\n+\n+        buffer.append((StringBuffer) null);\n         assertEquals(\"\", buffer.toString());\n \n-        buffer.append((CharBuffer)null);\n+        buffer.append((String) null);\n         assertEquals(\"\", buffer.toString());\n \n-        buffer.append((char[])null);\n+        buffer.append((CharBuffer) null);\n+        assertEquals(\"\", buffer.toString());\n+\n+        buffer.append((char[]) null);\n         assertEquals(\"\", buffer.toString());\n     }\n-    \n+\n     public void testAppendCharArrayBuffer() throws Exception {\n         CharBuffer buffer1 = new CharBuffer(8);\n         buffer1.append(\" and more stuff\");\n         buffer2.append(buffer1);\n         assertEquals(\"stuff and more stuff\", buffer2.toString());\n     }\n-    \n+\n     public void testAppendSingleChar() throws Exception {\n         CharBuffer buffer = new CharBuffer(4);\n         buffer.append('1');\n         buffer.append('6');\n         assertEquals(\"123456\", buffer.toString());\n     }\n-    \n+\n     public void testProvideCapacity() throws Exception {\n         CharBuffer buffer = new CharBuffer(4);\n         buffer.provideCapacity(2);\n--- a/src/test/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n+++ b/src/test/org/apache/commons/csv/ExtendedBufferedReaderTest.java\n \n /**\n  * ExtendedBufferedReaderTest\n- *\n  */\n public class ExtendedBufferedReaderTest extends TestCase {\n \n-  // ======================================================\n-  //   the test cases\n-  // ======================================================\n- \n-  public void testConstructors() {\n-    ExtendedBufferedReader br = new ExtendedBufferedReader(new StringReader(\"\"));\n-    br = new ExtendedBufferedReader(new StringReader(\"\"), 10); \n-  }\n-  \n-  public void testReadLookahead1() throws Exception {\n-   \n-    assertEquals(ExtendedBufferedReader.END_OF_STREAM, getEBR(\"\").read());\n-    ExtendedBufferedReader br = getEBR(\"1\\n2\\r3\\n\");\n-    assertEquals('1', br.lookAhead());\n-    assertEquals(ExtendedBufferedReader.UNDEFINED, br.readAgain());\n-    assertEquals('1', br.read());\n-    assertEquals('1', br.readAgain());\n+    // ======================================================\n+    //   the test cases\n+    // ======================================================\n \n-    assertEquals(0, br.getLineNumber());\n-    assertEquals('\\n', br.lookAhead());\n-    assertEquals(0, br.getLineNumber());\n-    assertEquals('1', br.readAgain());    \n-    assertEquals('\\n', br.read());\n-    assertEquals(1, br.getLineNumber());\n-    assertEquals('\\n', br.readAgain());\n-    assertEquals(1, br.getLineNumber());\n-    \n-    assertEquals('2', br.lookAhead());\n-    assertEquals(1, br.getLineNumber());\n-    assertEquals('\\n', br.readAgain());\n-    assertEquals(1, br.getLineNumber());\n-    assertEquals('2', br.read());\n-    assertEquals('2', br.readAgain());\n-    \n-    assertEquals('\\r', br.lookAhead());\n-    assertEquals('2', br.readAgain());\n-    assertEquals('\\r', br.read());\n-    assertEquals('\\r', br.readAgain());\n-    \n-    assertEquals('3', br.lookAhead());\n-    assertEquals('\\r', br.readAgain());\n-    assertEquals('3', br.read());\n-    assertEquals('3', br.readAgain());\n-    \n-    assertEquals('\\n', br.lookAhead());\n-    assertEquals(1, br.getLineNumber());\n-    assertEquals('3', br.readAgain());\n-    assertEquals('\\n', br.read());\n-    assertEquals(2, br.getLineNumber());\n-    assertEquals('\\n', br.readAgain());\n-    assertEquals(2, br.getLineNumber());\n-    \n-    assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.lookAhead());\n-    assertEquals('\\n', br.readAgain());\n-    assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.read());\n-    assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.readAgain());\n-    assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.read());\n-    assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.lookAhead());\n- \n-  }\n-  \n+    public void testConstructors() {\n+        ExtendedBufferedReader br = new ExtendedBufferedReader(new StringReader(\"\"));\n+        br = new ExtendedBufferedReader(new StringReader(\"\"), 10);\n+    }\n \n-  public void testReadLookahead2() throws Exception {\n-    char[] ref = new char[5];\n-    char[] res = new char[5];  \n-    \n-    ExtendedBufferedReader br = getEBR(\"\");\n-    assertEquals(0, br.read(res, 0, 0));\n-    assertTrue(Arrays.equals(res, ref)); \n-    \n-    br = getEBR(\"abcdefg\");\n-    ref[0] = 'a';\n-    ref[1] = 'b';\n-    ref[2] = 'c';\n-    assertEquals(3, br.read(res, 0, 3));\n-    assertTrue(Arrays.equals(res, ref));\n-    assertEquals('c', br.readAgain());\n-    \n-    assertEquals('d', br.lookAhead());\n-    ref[4] = 'd';\n-    assertEquals(1, br.read(res, 4, 1));\n-    assertTrue(Arrays.equals(res, ref));\n-    assertEquals('d', br.readAgain());\n- \n-  }\n-  \n-  public void testReadLine() throws Exception {\n-    ExtendedBufferedReader br = getEBR(\"\");\n-    assertTrue(br.readLine() == null);\n-    \n-    br = getEBR(\"\\n\");\n-    assertTrue(br.readLine().equals(\"\"));\n-    assertTrue(br.readLine() == null);\n-    \n-    br = getEBR(\"foo\\n\\nhello\");\n-    assertEquals(0, br.getLineNumber());\n-    assertTrue(br.readLine().equals(\"foo\"));\n-    assertEquals(1, br.getLineNumber());\n-    assertTrue(br.readLine().equals(\"\"));\n-    assertEquals(2, br.getLineNumber());\n-    assertTrue(br.readLine().equals(\"hello\"));\n-    assertEquals(3, br.getLineNumber());\n-    assertTrue(br.readLine() == null);\n-    assertEquals(3, br.getLineNumber());\n-    \n-    br = getEBR(\"foo\\n\\nhello\");\n-    assertEquals('f', br.read());\n-    assertEquals('o', br.lookAhead());\n-    assertTrue(br.readLine().equals(\"oo\"));\n-    assertEquals(1, br.getLineNumber());\n-    assertEquals('\\n', br.lookAhead());\n-    assertTrue(br.readLine().equals(\"\"));\n-    assertEquals(2, br.getLineNumber());\n-    assertEquals('h', br.lookAhead());\n-    assertTrue(br.readLine().equals(\"hello\"));\n-    assertTrue(br.readLine() == null);\n-    assertEquals(3, br.getLineNumber());\n-    \n- \n-    br = getEBR(\"foo\\rbaar\\r\\nfoo\");\n-    assertTrue(br.readLine().equals(\"foo\"));\n-    assertEquals('b', br.lookAhead());\n-    assertTrue(br.readLine().equals(\"baar\"));\n-    assertEquals('f', br.lookAhead());\n-    assertTrue(br.readLine().equals(\"foo\"));\n-    assertTrue(br.readLine() == null);\n-  }\n-  \n-  private ExtendedBufferedReader getEBR(String s) {\n-    return new ExtendedBufferedReader(new StringReader(s));\n-  }\n+    public void testReadLookahead1() throws Exception {\n+\n+        assertEquals(ExtendedBufferedReader.END_OF_STREAM, getEBR(\"\").read());\n+        ExtendedBufferedReader br = getEBR(\"1\\n2\\r3\\n\");\n+        assertEquals('1', br.lookAhead());\n+        assertEquals(ExtendedBufferedReader.UNDEFINED, br.readAgain());\n+        assertEquals('1', br.read());\n+        assertEquals('1', br.readAgain());\n+\n+        assertEquals(0, br.getLineNumber());\n+        assertEquals('\\n', br.lookAhead());\n+        assertEquals(0, br.getLineNumber());\n+        assertEquals('1', br.readAgain());\n+        assertEquals('\\n', br.read());\n+        assertEquals(1, br.getLineNumber());\n+        assertEquals('\\n', br.readAgain());\n+        assertEquals(1, br.getLineNumber());\n+\n+        assertEquals('2', br.lookAhead());\n+        assertEquals(1, br.getLineNumber());\n+        assertEquals('\\n', br.readAgain());\n+        assertEquals(1, br.getLineNumber());\n+        assertEquals('2', br.read());\n+        assertEquals('2', br.readAgain());\n+\n+        assertEquals('\\r', br.lookAhead());\n+        assertEquals('2', br.readAgain());\n+        assertEquals('\\r', br.read());\n+        assertEquals('\\r', br.readAgain());\n+\n+        assertEquals('3', br.lookAhead());\n+        assertEquals('\\r', br.readAgain());\n+        assertEquals('3', br.read());\n+        assertEquals('3', br.readAgain());\n+\n+        assertEquals('\\n', br.lookAhead());\n+        assertEquals(1, br.getLineNumber());\n+        assertEquals('3', br.readAgain());\n+        assertEquals('\\n', br.read());\n+        assertEquals(2, br.getLineNumber());\n+        assertEquals('\\n', br.readAgain());\n+        assertEquals(2, br.getLineNumber());\n+\n+        assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.lookAhead());\n+        assertEquals('\\n', br.readAgain());\n+        assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.read());\n+        assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.readAgain());\n+        assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.read());\n+        assertEquals(ExtendedBufferedReader.END_OF_STREAM, br.lookAhead());\n+\n+    }\n+\n+\n+    public void testReadLookahead2() throws Exception {\n+        char[] ref = new char[5];\n+        char[] res = new char[5];\n+\n+        ExtendedBufferedReader br = getEBR(\"\");\n+        assertEquals(0, br.read(res, 0, 0));\n+        assertTrue(Arrays.equals(res, ref));\n+\n+        br = getEBR(\"abcdefg\");\n+        ref[0] = 'a';\n+        ref[1] = 'b';\n+        ref[2] = 'c';\n+        assertEquals(3, br.read(res, 0, 3));\n+        assertTrue(Arrays.equals(res, ref));\n+        assertEquals('c', br.readAgain());\n+\n+        assertEquals('d', br.lookAhead());\n+        ref[4] = 'd';\n+        assertEquals(1, br.read(res, 4, 1));\n+        assertTrue(Arrays.equals(res, ref));\n+        assertEquals('d', br.readAgain());\n+\n+    }\n+\n+    public void testReadLine() throws Exception {\n+        ExtendedBufferedReader br = getEBR(\"\");\n+        assertTrue(br.readLine() == null);\n+\n+        br = getEBR(\"\\n\");\n+        assertTrue(br.readLine().equals(\"\"));\n+        assertTrue(br.readLine() == null);\n+\n+        br = getEBR(\"foo\\n\\nhello\");\n+        assertEquals(0, br.getLineNumber());\n+        assertTrue(br.readLine().equals(\"foo\"));\n+        assertEquals(1, br.getLineNumber());\n+        assertTrue(br.readLine().equals(\"\"));\n+        assertEquals(2, br.getLineNumber());\n+        assertTrue(br.readLine().equals(\"hello\"));\n+        assertEquals(3, br.getLineNumber());\n+        assertTrue(br.readLine() == null);\n+        assertEquals(3, br.getLineNumber());\n+\n+        br = getEBR(\"foo\\n\\nhello\");\n+        assertEquals('f', br.read());\n+        assertEquals('o', br.lookAhead());\n+        assertTrue(br.readLine().equals(\"oo\"));\n+        assertEquals(1, br.getLineNumber());\n+        assertEquals('\\n', br.lookAhead());\n+        assertTrue(br.readLine().equals(\"\"));\n+        assertEquals(2, br.getLineNumber());\n+        assertEquals('h', br.lookAhead());\n+        assertTrue(br.readLine().equals(\"hello\"));\n+        assertTrue(br.readLine() == null);\n+        assertEquals(3, br.getLineNumber());\n+\n+\n+        br = getEBR(\"foo\\rbaar\\r\\nfoo\");\n+        assertTrue(br.readLine().equals(\"foo\"));\n+        assertEquals('b', br.lookAhead());\n+        assertTrue(br.readLine().equals(\"baar\"));\n+        assertEquals('f', br.lookAhead());\n+        assertTrue(br.readLine().equals(\"foo\"));\n+        assertTrue(br.readLine() == null);\n+    }\n+\n+    private ExtendedBufferedReader getEBR(String s) {\n+        return new ExtendedBufferedReader(new StringReader(s));\n+    }\n }\n--- a/src/test/org/apache/commons/csv/writer/CSVConfigGuesserTest.java\n+++ b/src/test/org/apache/commons/csv/writer/CSVConfigGuesserTest.java\n         guesser.setHasFieldHeader(true);\n         assertEquals(true, guesser.hasFieldHeader());\n     }\n+\n     /**\n      * Test a format like\n-     *  1234 ; abcd ; 1234 ;\n-     *\n+     * 1234 ; abcd ; 1234 ;\n      */\n     public void testConfigGuess1() {\n         CSVConfig expected = new CSVConfig();\n         assertEquals(expected.getFields().length, guessed.getFields().length);\n         assertEquals(expected.getFields()[0].getSize(), guessed.getFields()[0].getSize());\n     }\n+\n     /**\n      * Test a format like\n-     *  1234,123123,12312312,213123\n-     *  1,2,3,4\n-     *\n+     * 1234,123123,12312312,213123\n+     * 1,2,3,4\n      */\n     public void testConfigGuess2() {\n         CSVConfig expected = new CSVConfig();\n--- a/src/test/org/apache/commons/csv/writer/CSVConfigTest.java\n+++ b/src/test/org/apache/commons/csv/writer/CSVConfigTest.java\n  * @version $Id: $\n  */\n public class CSVConfigTest extends TestCase {\n-    \n+\n \n     public void testFixedWith() {\n         CSVConfig config = new CSVConfig();\n         config.setFixedWidth(true);\n         assertEquals(true, config.isFixedWidth());\n     }\n-    \n+\n     public void testFields() {\n         CSVConfig config = new CSVConfig();\n         assertEquals(0, config.getFields().length);\n-        config.setFields((CSVField[])null);\n+        config.setFields((CSVField[]) null);\n         assertEquals(0, config.getFields().length);\n-        config.setFields((Collection)null);\n+        config.setFields((Collection) null);\n         assertEquals(0, config.getFields().length);\n         CSVField field = new CSVField();\n         field.setName(\"field1\");\n         assertEquals(null, config.getField(\"field11\"));\n         assertEquals(field, config.getField(\"field1\"));\n     }\n-    \n+\n     public void testFill() {\n         CSVConfig config = new CSVConfig();\n         assertEquals(CSVConfig.FILLNONE, config.getFill());\n         config.setFillChar('m');\n         assertEquals('m', config.getFillChar());\n     }\n-    \n+\n     public void testDelimiter() {\n         CSVConfig config = new CSVConfig();\n         assertEquals(',', config.getDelimiter());\n         config.setIgnoreDelimiter(true);\n         assertEquals(true, config.isDelimiterIgnored());\n     }\n-    \n+\n     public void testValueDelimiter() {\n         CSVConfig config = new CSVConfig();\n         assertEquals('\"', config.getValueDelimiter());\n         config.setIgnoreValueDelimiter(false);\n         assertEquals(false, config.isValueDelimiterIgnored());\n     }\n-    \n+\n     public void testFieldHeader() {\n         CSVConfig config = new CSVConfig();\n         assertEquals(false, config.isFieldHeader());\n         config.setFieldHeader(true);\n         assertEquals(true, config.isFieldHeader());\n     }\n-    \n+\n     public void testTrimEnd() {\n         CSVConfig config = new CSVConfig();\n         assertEquals(false, config.isEndTrimmed());\n--- a/src/test/org/apache/commons/csv/writer/CSVFieldTest.java\n+++ b/src/test/org/apache/commons/csv/writer/CSVFieldTest.java\n import junit.framework.TestCase;\n \n /**\n- * \n  * @author Martin van den Bemt\n  * @version $Id: $\n  */\n         assertEquals(\"name\", field.getName());\n         assertEquals(10, field.getSize());\n     }\n-    \n+\n     public void testFill() {\n         CSVField field = new CSVField();\n         assertEquals(CSVConfig.FILLNONE, field.getFill());\n--- a/src/test/org/apache/commons/csv/writer/CSVWriterTest.java\n+++ b/src/test/org/apache/commons/csv/writer/CSVWriterTest.java\n \n /**\n  * The testcase for the csv writer.\n- * \n+ *\n  * @author Martin van den Bemt\n  * @version $Id: $\n  */\n public class CSVWriterTest extends TestCase {\n \n     private Map map;\n-    \n+\n     protected void setUp() throws Exception {\n         super.setUp();\n-        \n+\n         map = new HashMap();\n         map.put(\"field1\", \"12345\");\n         map.put(\"field2\", \"1234\");", "timestamp": 1296549960, "metainfo": ""}