{"sha": "c7576ccdedbf82cbe4bda1ae699eccf90b70bbb9", "log": "Rename method from \"is\" prefix to \"read\" prefix because it is not just a test method, it may actually consume input.  ", "commit": "\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1.java\n         *       is to call 'readAgain' on the stream...\n         */\n         int c = in.read();\n-        boolean eol = isEndOfLine(c);\n+        boolean eol = readEndOfLine(c);\n         c = in.getLastChar();\n \n         //  empty line detection: eol AND (last char was EOL or beginning)\n                 // go on char ahead ...\n                 lastChar = c;\n                 c = in.read();\n-                eol = isEndOfLine(c);\n+                eol = readEndOfLine(c);\n                 c = in.getLastChar();\n                 // reached end of file without any content (empty line at the end)\n                 if (isEndOfFile(c)) {\n                 while (isWhitespace(c) && !eol) {\n                     wsBuf.append((char) c);\n                     c = in.read();\n-                    eol = isEndOfLine(c);\n+                    eol = readEndOfLine(c);\n                 }\n             }\n \n      */\n     private Token simpleTokenLexer(final Token tkn, int c) throws IOException {\n         while (true) {\n-            if (isEndOfLine(c)) {\n+            if (readEndOfLine(c)) {\n                 // end of record\n                 tkn.type = EORECORD;\n                 tkn.isReady = true;\n                             tkn.type = EOF;\n                             tkn.isReady = true;\n                             return tkn;\n-                        } else if (isEndOfLine(c)) {\n+                        } else if (readEndOfLine(c)) {\n                             // ok eo token reached\n                             tkn.type = EORECORD;\n                             tkn.isReady = true;\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1306663.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1306663.java\n         *       this has no effect outside of the method. so a simple workaround\n         *       is to call 'readAgain' on the stream...\n         */\n-        boolean eol = isEndOfLine(c);\n+        boolean eol = readEndOfLine(c);\n         c = in.getLastChar();\n \n         //  empty line detection: eol AND (last char was EOL or beginning)\n                 // go on char ahead ...\n                 lastChar = c;\n                 c = in.read();\n-                eol = isEndOfLine(c);\n+                eol = readEndOfLine(c);\n                 c = in.getLastChar();\n                 // reached end of file without any content (empty line at the end)\n                 if (isEndOfFile(c)) {\n             if (ignoreSurroundingSpaces) {\n                 while (isWhitespace(c) && !eol) {\n                     c = in.read();\n-                    eol = isEndOfLine(c);\n+                    eol = readEndOfLine(c);\n                 }\n             }\n \n     private Token simpleTokenLexer(final Token tkn, int c) throws IOException {\n         // Faster to use while(true)+break than while(tkn.type == INVALID)\n         while (true) {\n-            if (isEndOfLine(c)) {\n+            if (readEndOfLine(c)) {\n                 tkn.type = EORECORD;\n                 break;\n             } else if (isEndOfFile(c)) {\n                             tkn.type = EOF;\n                             tkn.isReady = true; // There is data at EOF\n                             return tkn;\n-                        } else if (isEndOfLine(c)) {\n+                        } else if (readEndOfLine(c)) {\n                             // ok eo token reached\n                             tkn.type = EORECORD;\n                             return tkn;\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1306667.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1306667.java\n         *       this has no effect outside of the method. so a simple workaround\n         *       is to call 'readAgain' on the stream...\n         */\n-        boolean eol = isEndOfLine(c);\n+        boolean eol = readEndOfLine(c);\n         c = in.getLastChar();\n \n         //  empty line detection: eol AND (last char was EOL or beginning)\n                 // go on char ahead ...\n                 lastChar = c;\n                 c = in.read();\n-                eol = isEndOfLine(c);\n+                eol = readEndOfLine(c);\n                 c = in.getLastChar();\n                 // reached end of file without any content (empty line at the end)\n                 if (isEndOfFile(c)) {\n             if (ignoreSurroundingSpaces) {\n                 while (isWhitespace(c) && !eol) {\n                     c = in.read();\n-                    eol = isEndOfLine(c);\n+                    eol = readEndOfLine(c);\n                 }\n             }\n \n     private Token simpleTokenLexer(final Token tkn, int c) throws IOException {\n         // Faster to use while(true)+break than while(tkn.type == INVALID)\n         while (true) {\n-            if (isEndOfLine(c)) {\n+            if (readEndOfLine(c)) {\n                 tkn.type = EORECORD;\n                 break;\n             } else if (isEndOfFile(c)) {\n                             tkn.type = EOF;\n                             tkn.isReady = true; // There is data at EOF\n                             return tkn;\n-                        } else if (isEndOfLine(c)) {\n+                        } else if (readEndOfLine(c)) {\n                             // ok eo token reached\n                             tkn.type = EORECORD;\n                             return tkn;", "timestamp": 1350154629, "metainfo": ""}