{"sha": "09a6e887b891152ebebb3c2df9e0d8a8dcfa3a52", "log": "Use hasContent matcher token type is not relevant (correct token type recognition is tested by other tests methods)  ", "commit": "\n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n import static org.junit.Assert.assertEquals;\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertThat;\n+import static org.apache.commons.csv.TokenMatchers.hasContent;\n \n import java.io.IOException;\n import java.io.StringReader;\n     @Test\n     public void testEscapedCR() throws Exception {\n         final Lexer lexer = getLexer(\"character\\\\\" + CR + \"Escaped\", formatWithEscaping);\n-        assertTokenEquals(EOF, \"character\" + CR + \"Escaped\", lexer.nextToken(new Token()));\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n     }\n \n     @Test\n     public void testEscapedLF() throws Exception {\n         final Lexer lexer = getLexer(\"character\\\\\" + LF + \"Escaped\", formatWithEscaping);\n-        assertTokenEquals(EOF, \"character\" + LF + \"Escaped\", lexer.nextToken(new Token()));\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + LF + \"Escaped\"));\n     }\n \n     @Test\n     public void testEscapedTab() throws Exception {\n         final Lexer lexer = getLexer(\"character\\\\\" + TAB + \"Escaped\", formatWithEscaping);\n-        assertTokenEquals(EOF, \"character\" + TAB + \"Escaped\", lexer.nextToken(new Token()));\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + TAB + \"Escaped\"));\n     }\n \n     @Test\n     public void testEscapeBackspace() throws Exception {\n         final Lexer lexer = getLexer(\"character\\\\\" + BACKSPACE + \"Escaped\", formatWithEscaping);\n-        assertTokenEquals(EOF, \"character\" + BACKSPACE + \"Escaped\", lexer.nextToken(new Token()));\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + BACKSPACE + \"Escaped\"));\n     }\n \n     @Test\n     public void testEscapeFF() throws Exception {\n         final Lexer lexer = getLexer(\"character\\\\\" + FF + \"Escaped\", formatWithEscaping);\n-        assertTokenEquals(EOF, \"character\" + FF + \"Escaped\", lexer.nextToken(new Token()));\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + FF + \"Escaped\"));\n     }\n \n     @Test\n     public void testEscapedMySqlNullValue() throws Exception {\n         // MySQL uses \\N to symbolize null values. We have to restore this\n         final Lexer lexer = getLexer(\"character\\\\\\\\NEscaped\", formatWithEscaping);\n-        assertTokenEquals(EOF, \"character\\\\NEscaped\", lexer.nextToken(new Token()));\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\NEscaped\"));\n     }\n \n     // FIXME this should work after CSV-58 is resolved. Currently the result will be \"characteraEscaped\"\n     @Ignore\n     public void testEscapedCharacter() throws Exception {\n         final Lexer lexer = getLexer(\"character\\\\aEscaped\", formatWithEscaping);\n-        assertTokenEquals(EOF, \"character\\\\aEscaped\", lexer.nextToken(new Token()));\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\aEscaped\"));\n     }\n \n     // FIXME this should work after CSV-58 is resolved. Currently the result will be \"characterCREscaped\"\n     public void testEscapedControlCharacter() throws Exception {\n         // we are explicitly using an escape different from \\ here, because \\r is the character sequence for CR\n         final Lexer lexer = getLexer(\"character!rEscaped\", CSVFormat.newBuilder().withEscape('!').build());\n-        assertTokenEquals(EOF, \"character!rEscaped\", lexer.nextToken(new Token()));\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character!rEscaped\"));\n+    }\n+\n+    @Test\n+    public void testEscapedControlCharacter2() throws Exception {\n+        final Lexer lexer = getLexer(\"character\\\\rEscaped\", CSVFormat.newBuilder().withEscape('\\\\').build());\n+        assertThat(lexer.nextToken(new Token()), hasContent(\"character\"+CR+\"Escaped\"));\n     }\n \n     @Test(expected = IOException.class)", "timestamp": 1364836531, "metainfo": ""}