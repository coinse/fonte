{"sha": "911433707587a42727da375e1ec0e53dc909ac8d", "log": "CSV-70 Improve readability of CSVLexer Remove unnecessary parameters  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVLexer.java\n+++ b/src/main/java/org/apache/commons/csv/CSVLexer.java\n             }\n             \n             // ok, start of token reached: comment, encapsulated, or token\n-            if (isCommentStart(c)) {\n+            if (isCommentStart(c)) { // TODO should only match at start of line\n                 // ignore everything till end of line and continue (incr linecount)\n                 in.readLine();\n                 tkn = nextToken(tkn.reset());\n                 tkn.type = EORECORD;\n             } else if (isEncapsulator(c)) {\n                 // consume encapsulated token\n-                encapsulatedTokenLexer(tkn, c);\n+                encapsulatedTokenLexer(tkn);\n             } else if (isEndOfFile(c)) {\n                 // end of file return EOF()\n                 //noop: tkn.content.append(\"\");\n                 tkn.type = TOKEN;\n                 break;\n             } else if (isEscape(c)) {\n-                tkn.content.append((char) readEscape(c));\n+                tkn.content.append((char) readEscape());\n             } else {\n                 tkn.content.append((char) c);\n             }\n      * Whitespaces before and after an encapsulated token are ignored.\n      *\n      * @param tkn the current token\n-     * @param c   the current character\n      * @return a valid token object\n      * @throws IOException on invalid state\n      */\n-    private Token encapsulatedTokenLexer(Token tkn, int c) throws IOException {\n+    private Token encapsulatedTokenLexer(Token tkn) throws IOException {\n         // save current line\n         int startLineNumber = getLineNumber();\n         // ignore the given delimiter\n         // assert c == delimiter;\n+        int c;\n         while (true) {\n             c = in.read();\n             \n             if (isEscape(c)) {\n-                tkn.content.append((char) readEscape(c));\n+                tkn.content.append((char) readEscape());\n             } else if (isEncapsulator(c)) {\n                 if (isEncapsulator(in.lookAhead())) {\n                     // double or escaped encapsulator -> add single encapsulator to token\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n         return in.getLineNumber();\n     }\n \n-    int readEscape(int c) throws IOException {\n+    int readEscape() throws IOException {\n         // assume c is the escape char (normally a backslash)\n-        c = in.read();\n+        int c = in.read();\n         switch (c) {\n             case 'r':\n                 return '\\r';\n--- a/src/test/java/org/apache/commons/csv/CSVLexer1.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexer1.java\n                 tkn.isReady = true;\n                 break;\n             } else if (c == format.getEscape()) {\n-                tkn.content.append((char) readEscape(c));\n+                tkn.content.append((char) readEscape());\n             } else {\n                 tkn.content.append((char) c);\n             }\n             c = in.read();\n             \n             if (c == format.getEscape()) {\n-                tkn.content.append((char) readEscape(c));\n+                tkn.content.append((char) readEscape());\n             } else if (c == format.getEncapsulator()) {\n                 if (in.lookAhead() == format.getEncapsulator()) {\n                     // double or escaped encapsulator -> add single encapsulator to token", "timestamp": 1332892204, "metainfo": ""}