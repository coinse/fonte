{"sha": "2ec4c994c0458ef893af9bd518849bec21b2dec4", "log": "Renamed CSVParser.getLine() into getRecord() to avoid confusions since a record can span several lines  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     \n     // the following objects are shared to reduce garbage\n     \n-    /** A record buffer for getLine(). Grows as necessary and is reused. */\n+    /** A record buffer for getRecord(). Grows as necessary and is reused. */\n     private final List<String> record = new ArrayList<String>();\n     private final Token reusableToken = new Token();\n \n \n \n     /**\n-     * Parses the CSV according to the given format and returns the content\n+     * Parses the CSV input according to the given format and returns the content\n      * as an array of records (whereas records are arrays of single values).\n      * <p/>\n      * The returned content starts at the current parse-position in the stream.\n      */\n     public String[][] getRecords() throws IOException {\n         List<String[]> records = new ArrayList<String[]>();\n-        String[] values;\n-        String[][] ret = null;\n-        while ((values = getLine()) != null) {\n-            records.add(values);\n-        }\n-        if (records.size() > 0) {\n-            ret = new String[records.size()][];\n-            records.toArray(ret);\n-        }\n-        return ret;\n-    }\n-\n-    /**\n-     * Parses from the current point in the stream til the end of the current line.\n-     *\n-     * @return array of values til end of line ('null' when end of file has been reached)\n+        String[] record;\n+        while ((record = getRecord()) != null) {\n+            records.add(record);\n+        }\n+        \n+        if (!records.isEmpty()) {\n+            return records.toArray(new String[records.size()][]);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Parses the next record from the current point in the stream.\n+     *\n+     * @return the record as an array of values, or <tt>null</tt> if the end of the stream has been reached\n      * @throws IOException on parse error or input read-failure\n      */\n-    String[] getLine() throws IOException {\n-        String[] ret = EMPTY_STRING_ARRAY;\n+    String[] getRecord() throws IOException {\n+        String[] result = EMPTY_STRING_ARRAY;\n         record.clear();\n         while (true) {\n             reusableToken.reset();\n                     if (reusableToken.isReady) {\n                         record.add(reusableToken.content.toString());\n                     } else {\n-                        ret = null;\n+                        result = null;\n                     }\n                     break;\n                 case INVALID:\n-                default:\n                     // error: throw IOException\n                     throw new IOException(\"(line \" + getLineNumber() + \") invalid parse sequence\");\n                     // unreachable: break;\n             }\n         }\n         if (!record.isEmpty()) {\n-            ret = record.toArray(new String[record.size()]);\n-        }\n-        return ret;\n+            result = record.toArray(new String[record.size()]);\n+        }\n+        return result;\n     }\n \n     /**\n             \n             private String[] getNextLine() {\n                 try {\n-                    return getLine();\n+                    return getRecord();\n                 } catch (IOException e) {\n                     throw new RuntimeException(e);\n                 }\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n     public void testGetLine() throws IOException {\n         CSVParser parser = new CSVParser(new StringReader(code));\n         for (String[] re : res) {\n-            assertTrue(Arrays.equals(re, parser.getLine()));\n-        }\n-        \n-        assertTrue(parser.getLine() == null);\n+            assertTrue(Arrays.equals(re, parser.getRecord()));\n+        }\n+        \n+        assertTrue(parser.getRecord() == null);\n     }\n \n     public void testGetRecords() throws IOException {", "timestamp": 1331200791, "metainfo": ""}