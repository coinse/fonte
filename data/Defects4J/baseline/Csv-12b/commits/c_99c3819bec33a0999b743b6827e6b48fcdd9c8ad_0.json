{"sha": "99c3819bec33a0999b743b6827e6b48fcdd9c8ad", "log": "[CSV-121] Exception that the header contains duplicate names when the column names are empty. Added the setting ignoreEmptyHeaders, defaults to false to keep the IAE as the default behavior.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n     private final Character commentStart; // null if commenting is disabled\n     private final Character escape; // null if escaping is disabled\n     private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n+    private boolean ignoreEmptyHeaders;\n     private final boolean ignoreEmptyLines;\n     private final String recordSeparator; // for outputs\n     private final String nullString; // the string to be used for null values\n      * </ul>\n      */\n     public static final CSVFormat DEFAULT = new CSVFormat(COMMA, DOUBLE_QUOTE_CHAR, null, null, null,\n-                                                            false, true, CRLF, null, null, false);\n+                                                            false, true, CRLF, null, null, false, false);\n \n     /**\n      * Comma separated format as defined by <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.\n      * @throws IllegalArgumentException if the delimiter is a line break character\n      */\n     public static CSVFormat newFormat(final char delimiter) {\n-        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false);\n+        return new CSVFormat(delimiter, null, null, null, null, false, false, null, null, null, false, false);\n     }\n \n     /**\n      * @param header\n      *            the header\n      * @param skipHeaderRecord TODO\n+     * @param ignoreEmptyHeaders TODO\n      * @throws IllegalArgumentException if the delimiter is a line break character\n      */\n     private CSVFormat(final char delimiter, final Character quoteChar,\n             final Quote quotePolicy, final Character commentStart,\n             final Character escape, final boolean ignoreSurroundingSpaces,\n             final boolean ignoreEmptyLines, final String recordSeparator,\n-            final String nullString, final String[] header, final boolean skipHeaderRecord) {\n+            final String nullString, final String[] header, final boolean skipHeaderRecord, \n+            final boolean ignoreEmptyHeaders) {\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n         this.commentStart = commentStart;\n         this.escape = escape;\n         this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n+        this.ignoreEmptyHeaders = ignoreEmptyHeaders;\n         this.ignoreEmptyLines = ignoreEmptyLines;\n         this.recordSeparator = recordSeparator;\n         this.nullString = nullString;\n     }\n \n     /**\n+     * Specifies whether empty headers are ignored when parsing the header line.\n+     * \n+     * @return <tt>true</tt> if headers are ignored when parsing the header line, <tt>false</tt> to throw an\n+     *         {@link IllegalArgumentException}..\n+     */\n+    public boolean getIgnoreEmptyHeaders() {\n+        return ignoreEmptyHeaders;\n+    }\n+\n+    /**\n      * Specifies whether empty lines between records are ignored when parsing input.\n      *\n      * @return <tt>true</tt> if empty lines between records are ignored, <tt>false</tt> if they are turned into empty\n             throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, \n+                ignoreEmptyHeaders);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, \n+                ignoreEmptyHeaders);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, \n+                ignoreEmptyHeaders);\n     }\n \n     /**\n      */\n     public CSVFormat withHeader(final String... header) {\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, \n+                ignoreEmptyHeaders);\n+    }\n+\n+    /**\n+     * Sets the empty header behavior of the format.\n+     *\n+     * @param ignoreEmptyHeaders\n+     *            the empty header behavior, <tt>true</tt> to ignore empty headers in the header line,\n+     *            <tt>false</tt> to cause an {@link IllegalArgumentException} to be thrown.\n+     * @return A new CSVFormat that is equal to this but with the specified empty header behavior.\n+     */\n+    public CSVFormat withIgnoreEmptyHeaders(final boolean ignoreEmptyHeaders) {\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+                ignoreSurroundingSpaces, ignoreEmptyHeaders, recordSeparator, nullString, header, skipHeaderRecord, \n+                ignoreEmptyHeaders);\n     }\n \n     /**\n      */\n     public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, \n+                ignoreEmptyHeaders);\n     }\n \n     /**\n      */\n     public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, \n+                ignoreEmptyHeaders);\n     }\n \n     /**\n      */\n     public CSVFormat withNullString(final String nullString) {\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, \n+                ignoreEmptyHeaders);\n     }\n \n     /**\n             throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n         }\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, \n+                ignoreEmptyHeaders);\n     }\n \n     /**\n      */\n     public CSVFormat withQuotePolicy(final Quote quotePolicy) {\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, \n+                ignoreEmptyHeaders);\n     }\n \n     /**\n      */\n     public CSVFormat withRecordSeparator(final String recordSeparator) {\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, \n+                ignoreEmptyHeaders);\n     }\n \n     /**\n      */\n     public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n         return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n-                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord);\n+                ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord, \n+                ignoreEmptyHeaders);\n     }\n }\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n         if (formatHeader != null) {\n             hdrMap = new LinkedHashMap<String, Integer>();\n \n-            String[] header = null;\n+            String[] headerRecord = null;\n             if (formatHeader.length == 0) {\n                 // read the header from the first line of the file\n                 final CSVRecord nextRecord = this.nextRecord();\n                 if (nextRecord != null) {\n-                    header = nextRecord.values();\n+                    headerRecord = nextRecord.values();\n                 }\n             } else {\n                 if (this.format.getSkipHeaderRecord()) {\n                     this.nextRecord();\n                 }\n-                header = formatHeader;\n+                headerRecord = formatHeader;\n             }\n \n             // build the name to index mappings\n-            if (header != null) {\n-                for (int i = 0; i < header.length; i++) {\n-                    if (hdrMap.containsKey(header[i])) {\n-                        throw new IllegalArgumentException(\"The header contains duplicate names: \" +\n-                                Arrays.toString(header));\n+            if (headerRecord != null) {\n+                for (int i = 0; i < headerRecord.length; i++) {\n+                    final String header = headerRecord[i];\n+                    final boolean containsHeader = hdrMap.containsKey(header);\n+                    final boolean emptyHeader = header.trim().isEmpty();\n+                    if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n+                        throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header\n+                                + \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n-                    hdrMap.put(header[i], Integer.valueOf(i));\n+                    hdrMap.put(header, Integer.valueOf(i));\n                 }\n             }\n         }\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n-    public void testDuplicateHeaderEntries() throws Exception {\n+    public void testDuplicateHeaders() throws Exception {\n         CSVParser.parse(\"a,b,a\\n1,2,3\\nx,y,z\", CSVFormat.DEFAULT.withHeader(new String[]{}));\n     }\n \n     }\n \n     @Test\n+    public void testHeadersMissing() throws Exception {\n+        final Reader in = new StringReader(\"a,,c,,d\\n1,2,3,4\\nx,y,z,zz\");\n+        CSVFormat.DEFAULT.withHeader().withIgnoreEmptyHeaders(true).parse(in).iterator();\n+    }\n+\n+    @Test\n     public void testHeaderComment() throws Exception {\n         final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n ", "timestamp": 1402587504, "metainfo": ""}