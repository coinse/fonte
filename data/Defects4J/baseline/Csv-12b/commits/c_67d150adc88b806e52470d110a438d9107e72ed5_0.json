{"sha": "67d150adc88b806e52470d110a438d9107e72ed5", "log": "Restore commentMarker property which was overridden during refactoring  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n     private final char delimiter;\n     private final Character quoteCharacter; // null if quoting is disabled\n     private final QuoteMode quoteMode;\n-    private final Character commentStartCharacter; // null if commenting is disabled\n+    private final Character commentMarker; // null if commenting is disabled\n     private final Character escapeCharacter; // null if escaping is disabled\n     private final boolean ignoreSurroundingSpaces; // Should leading/trailing spaces be ignored around values?\n     private final boolean allowMissingColumnNames;\n         this.delimiter = delimiter;\n         this.quoteCharacter = quoteChar;\n         this.quoteMode = quoteMode;\n-        this.commentStartCharacter = commentStart;\n+        this.commentMarker = commentStart;\n         this.escapeCharacter = escape;\n         this.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\n         this.allowMissingColumnNames = allowMissingColumnNames;\n         } else if (!quoteCharacter.equals(other.quoteCharacter)) {\n             return false;\n         }\n-        if (commentStartCharacter == null) {\n-            if (other.commentStartCharacter != null) {\n+        if (commentMarker == null) {\n+            if (other.commentMarker != null) {\n                 return false;\n             }\n-        } else if (!commentStartCharacter.equals(other.commentStartCharacter)) {\n+        } else if (!commentMarker.equals(other.commentMarker)) {\n             return false;\n         }\n         if (escapeCharacter == null) {\n      *\n      * @return the comment start marker, may be {@code null}\n      */\n-    public Character getCommentStartCharacter() {\n-        return commentStartCharacter;\n+    public Character getCommentMarker() {\n+        return commentMarker;\n     }\n \n     /**\n         result = prime * result + delimiter;\n         result = prime * result + ((quoteMode == null) ? 0 : quoteMode.hashCode());\n         result = prime * result + ((quoteCharacter == null) ? 0 : quoteCharacter.hashCode());\n-        result = prime * result + ((commentStartCharacter == null) ? 0 : commentStartCharacter.hashCode());\n+        result = prime * result + ((commentMarker == null) ? 0 : commentMarker.hashCode());\n         result = prime * result + ((escapeCharacter == null) ? 0 : escapeCharacter.hashCode());\n         result = prime * result + ((nullString == null) ? 0 : nullString.hashCode());\n         result = prime * result + (ignoreSurroundingSpaces ? 1231 : 1237);\n      *\n      * @return {@code true} is comments are supported, {@code false} otherwise\n      */\n-    public boolean isCommentStartCharacterSet() {\n-        return commentStartCharacter != null;\n+    public boolean isCommentMarkerSet() {\n+        return commentMarker != null;\n     }\n \n     /**\n             sb.append(' ');\n             sb.append(\"QuoteChar=<\").append(quoteCharacter).append('>');\n         }\n-        if (isCommentStartCharacterSet()) {\n+        if (isCommentMarkerSet()) {\n             sb.append(' ');\n-            sb.append(\"CommentStart=<\").append(commentStartCharacter).append('>');\n+            sb.append(\"CommentStart=<\").append(commentMarker).append('>');\n         }\n         if (isNullStringSet()) {\n             sb.append(' ');\n                     \"The escape character and the delimiter cannot be the same ('\" + escapeCharacter + \"')\");\n         }\n \n-        if (commentStartCharacter != null && delimiter == commentStartCharacter.charValue()) {\n+        if (commentMarker != null && delimiter == commentMarker.charValue()) {\n             throw new IllegalArgumentException(\n-                    \"The comment start character and the delimiter cannot be the same ('\" + commentStartCharacter + \"')\");\n-        }\n-\n-        if (quoteCharacter != null && quoteCharacter.equals(commentStartCharacter)) {\n+                    \"The comment start character and the delimiter cannot be the same ('\" + commentMarker + \"')\");\n+        }\n+\n+        if (quoteCharacter != null && quoteCharacter.equals(commentMarker)) {\n             throw new IllegalArgumentException(\n-                    \"The comment start character and the quoteChar cannot be the same ('\" + commentStartCharacter + \"')\");\n-        }\n-\n-        if (escapeCharacter != null && escapeCharacter.equals(commentStartCharacter)) {\n+                    \"The comment start character and the quoteChar cannot be the same ('\" + commentMarker + \"')\");\n+        }\n+\n+        if (escapeCharacter != null && escapeCharacter.equals(commentMarker)) {\n             throw new IllegalArgumentException(\n-                    \"The comment start and the escape character cannot be the same ('\" + commentStartCharacter + \"')\");\n+                    \"The comment start and the escape character cannot be the same ('\" + commentMarker + \"')\");\n         }\n \n         if (escapeCharacter == null && quoteMode == QuoteMode.NONE) {\n         if (isLineBreak(delimiter)) {\n             throw new IllegalArgumentException(\"The delimiter cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n         if (isLineBreak(escape)) {\n             throw new IllegalArgumentException(\"The escape character cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escape,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @see #withSkipHeaderRecord(boolean)\n      */\n     public CSVFormat withHeader(final String... header) {\n-        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @return A new CSVFormat that is equal to this but with the specified missing column names behavior.\n      */\n     public CSVFormat withAllowMissingColumnNames(final boolean allowMissingColumnNames) {\n-        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @return A new CSVFormat that is equal to this but with the specified empty line skipping behavior.\n      */\n     public CSVFormat withIgnoreEmptyLines(final boolean ignoreEmptyLines) {\n-        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @return A new CSVFormat that is equal to this but with the specified trimming behavior.\n      */\n     public CSVFormat withIgnoreSurroundingSpaces(final boolean ignoreSurroundingSpaces) {\n-        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @return A new CSVFormat that is equal to this but with the specified null conversion string.\n      */\n     public CSVFormat withNullString(final String nullString) {\n-        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n         if (isLineBreak(quoteChar)) {\n             throw new IllegalArgumentException(\"The quoteChar cannot be a line break\");\n         }\n-        return new CSVFormat(delimiter, quoteChar, quoteMode, commentStartCharacter, escapeCharacter,\n+        return new CSVFormat(delimiter, quoteChar, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @return A new CSVFormat that is equal to this but with the specified quote policy\n      */\n     public CSVFormat withQuoteMode(final QuoteMode quoteModePolicy) {\n-        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentStartCharacter, escapeCharacter,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteModePolicy, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      *              if recordSeparator is none of CR, LF or CRLF\n      */\n     public CSVFormat withRecordSeparator(final String recordSeparator) {\n-        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n      * @see #withHeader(String...)\n      */\n     public CSVFormat withSkipHeaderRecord(final boolean skipHeaderRecord) {\n-        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentStartCharacter, escapeCharacter,\n+        return new CSVFormat(delimiter, quoteCharacter, quoteMode, commentMarker, escapeCharacter,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 allowMissingColumnNames);\n     }\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n      *             If an I/O error occurs\n      */\n     public void printComment(final String comment) throws IOException {\n-        if (!format.isCommentStartCharacterSet()) {\n+        if (!format.isCommentMarkerSet()) {\n             return;\n         }\n         if (!newRecord) {\n             println();\n         }\n-        out.append(format.getCommentStartCharacter().charValue());\n+        out.append(format.getCommentMarker().charValue());\n         out.append(SP);\n         for (int i = 0; i < comment.length(); i++) {\n             final char c = comment.charAt(i);\n                 //$FALL-THROUGH$ break intentionally excluded.\n             case LF:\n                 println();\n-                out.append(format.getCommentStartCharacter().charValue());\n+                out.append(format.getCommentMarker().charValue());\n                 out.append(SP);\n                 break;\n             default:\n--- a/src/main/java/org/apache/commons/csv/Lexer.java\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n         this.delimiter = format.getDelimiter();\n         this.escape = mapNullToDisabled(format.getEscapeCharacter());\n         this.quoteChar = mapNullToDisabled(format.getQuoteCharacter());\n-        this.commentStart = mapNullToDisabled(format.getCommentStartCharacter());\n+        this.commentStart = mapNullToDisabled(format.getCommentMarker());\n         this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n         this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n     }\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n \n     @Test\n     public void testRFC4180() {\n-        assertEquals(null, RFC4180.getCommentStartCharacter());\n+        assertEquals(null, RFC4180.getCommentMarker());\n         assertEquals(',', RFC4180.getDelimiter());\n         assertEquals(null, RFC4180.getEscapeCharacter());\n         assertFalse(RFC4180.getIgnoreEmptyLines());\n         assertNotNull(format);\n         assertEquals(\"delimiter\", CSVFormat.DEFAULT.getDelimiter(), format.getDelimiter());\n         assertEquals(\"encapsulator\", CSVFormat.DEFAULT.getQuoteCharacter(), format.getQuoteCharacter());\n-        assertEquals(\"comment start\", CSVFormat.DEFAULT.getCommentStartCharacter(), format.getCommentStartCharacter());\n+        assertEquals(\"comment start\", CSVFormat.DEFAULT.getCommentMarker(), format.getCommentMarker());\n         assertEquals(\"record separator\", CSVFormat.DEFAULT.getRecordSeparator(), format.getRecordSeparator());\n         assertEquals(\"escape\", CSVFormat.DEFAULT.getEscapeCharacter(), format.getEscapeCharacter());\n         assertEquals(\"trim\", CSVFormat.DEFAULT.getIgnoreSurroundingSpaces(), format.getIgnoreSurroundingSpaces());\n     @Test\n     public void testWithCommentStart() throws Exception {\n         final CSVFormat formatWithCommentStart = CSVFormat.DEFAULT.withCommentMarker('#');\n-        assertEquals( Character.valueOf('#'), formatWithCommentStart.getCommentStartCharacter());\n+        assertEquals( Character.valueOf('#'), formatWithCommentStart.getCommentMarker());\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n         };\n \n         CSVFormat format = CSVFormat.DEFAULT;\n-        assertFalse(format.isCommentStartCharacterSet());\n+        assertFalse(format.isCommentMarkerSet());\n \n         CSVParser parser = CSVParser.parse(code, format);\n         List<CSVRecord> records = parser.getRecords();", "timestamp": 1405971760, "metainfo": ""}