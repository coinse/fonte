{"sha": "516b82b4712da79bcefbeeb06b8a59f17aa99976", "log": "Made all public methods in CharBuffer and ExtendedBufferedReader package private  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CharBuffer.java\n+++ b/src/main/java/org/apache/commons/csv/CharBuffer.java\n     /**\n      * Creates a new CharBuffer with an initial capacity of 32 characters.\n      */\n-    public CharBuffer() {\n+    CharBuffer() {\n         this(32);\n     }\n \n      * Creates a new CharBuffer with an initial capacity\n      * of <code>length</code> characters.\n      */\n-    public CharBuffer(final int length) {\n+    CharBuffer(final int length) {\n         if (length == 0) {\n             throw new IllegalArgumentException(\"Can't create an empty CharBuffer\");\n         }\n     /**\n      * Empties the buffer. The capacity still remains the same, so no memory is freed.\n      */\n-    public void clear() {\n+    void clear() {\n         length = 0;\n     }\n \n      *\n      * @return the number of characters\n      */\n-    public int length() {\n+    int length() {\n         return length;\n     }\n \n      *\n      * @return the maximum number of characters that can be stored in this buffer without resizing it.\n      */\n-    public int capacity() {\n+    int capacity() {\n         return c.length;\n     }\n \n      *\n      * @param cb the CharBuffer to append or null\n      */\n-    public void append(final CharBuffer cb) {\n+    void append(final CharBuffer cb) {\n         if (cb == null) {\n             return;\n         }\n      *\n      * @param s the String to append or null\n      */\n-    public void append(final String s) {\n+    void append(final String s) {\n         if (s == null) {\n             return;\n         }\n      *\n      * @param data the char[] to append or null\n      */\n-    public void append(final char[] data) {\n+    void append(final char[] data) {\n         if (data == null) {\n             return;\n         }\n      *\n      * @param data the char to append\n      */\n-    public void append(final char data) {\n+    void append(final char data) {\n         provideCapacity(length + 1);\n         c[length] = data;\n         length++;\n      * Shrinks the capacity of the buffer to the current length if necessary.\n      * This method involves copying the data once!\n      */\n-    public void shrink() {\n+    void shrink() {\n         if (c.length == length) {\n             return;\n         }\n     /**\n      * Removes trailing whitespace.\n      */\n-    public void trimTrailingWhitespace() {\n+    void trimTrailingWhitespace() {\n         while (length > 0 && Character.isWhitespace(c[length - 1])) {\n             length--;\n         }\n      *\n      * @return\n      */\n-    public char[] getCharacters() {\n+    char[] getCharacters() {\n         if (c.length == length) {\n             return c;\n         }\n     /**\n      * Returns the character at the specified position.\n      */\n-    public char charAt(int pos) {\n+    char charAt(int pos) {\n         return c[pos];\n     }\n \n      *\n      * @param capacity\n      */\n-    public void provideCapacity(final int capacity) {\n+    void provideCapacity(final int capacity) {\n         if (c.length >= capacity) {\n             return;\n         }\n--- a/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n+++ b/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\n class ExtendedBufferedReader extends BufferedReader {\n \n     /** The end of stream symbol */\n-    public static final int END_OF_STREAM = -1;\n+    static final int END_OF_STREAM = -1;\n \n     /** Undefined state for the lookahead char */\n-    public static final int UNDEFINED = -2;\n+    static final int UNDEFINED = -2;\n \n     /** The lookahead chars */\n     private int lookaheadChar = UNDEFINED;\n     /**\n      * Created extended buffered reader using default buffer-size\n      */\n-    public ExtendedBufferedReader(Reader r) {\n+    ExtendedBufferedReader(Reader r) {\n         super(r);\n         /* note uh: do not fetch the first char here,\n         *          because this might block the method!\n      *\n      * @return the last read char or UNDEFINED\n      */\n-    public int readAgain() {\n+    int readAgain() {\n         return lastChar;\n     }\n \n      *\n      * @return the next char (without consuming it) or END_OF_STREAM\n      */\n-    public int lookAhead() throws IOException {\n+    int lookAhead() throws IOException {\n         if (lookaheadChar == UNDEFINED) {\n             lookaheadChar = super.read();\n         }\n      *\n      * @return the current-line-number (or -1)\n      */\n-    public int getLineNumber() {\n-        if (lineCounter > -1) {\n-            return lineCounter;\n-        } else {\n-            return -1;\n-        }\n+    int getLineNumber() {\n+        return lineCounter > -1 ? lineCounter : -1;\n     }\n \n     /**", "timestamp": 1331067644, "metainfo": ""}