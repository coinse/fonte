{"sha": "00d0def6953d414af6ecf36a9584c5453ee39c29", "log": "Replaced the unicode escaping code from the parser with a class implementing java.io.Reader  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     private final List<String> record = new ArrayList<String>();\n     private final Token reusableToken = new Token();\n     private final CharBuffer wsBuf = new CharBuffer();\n-    private final CharBuffer code = new CharBuffer(4);\n-\n \n     /**\n      * Token is an internal token representation.\n      * @param format the CSVFormat used for CSV parsing\n      */\n     public CSVParser(Reader input, CSVFormat format) {\n+        if (format.isUnicodeEscapesInterpreted()) {\n+            input = new UnicodeUnescapeReader(input);\n+        }\n+        \n         this.in = new ExtendedBufferedReader(input);\n         this.format = format;\n     }\n                 tkn.type = TOKEN;\n                 tkn.isReady = true;\n                 break;\n-            } else if (c == '\\\\' && format.isUnicodeEscapesInterpreted() && in.lookAhead() == 'u') {\n-                // interpret unicode escaped chars (like \\u0070 -> p)\n-                tkn.content.append((char) unicodeEscapeLexer(c));\n             } else if (c == format.getEscape()) {\n                 tkn.content.append((char) readEscape(c));\n             } else {\n         // assert c == delimiter;\n         for (; ;) {\n             c = in.read();\n-\n-            if (c == '\\\\' && format.isUnicodeEscapesInterpreted() && in.lookAhead() == 'u') {\n-                tkn.content.append((char) unicodeEscapeLexer(c));\n-            } else if (c == format.getEscape()) {\n+            \n+            if (c == format.getEscape()) {\n                 tkn.content.append((char) readEscape(c));\n             } else if (c == format.getEncapsulator()) {\n                 if (in.lookAhead() == format.getEncapsulator()) {\n         }\n     }\n \n-\n-    /**\n-     * Decodes Unicode escapes.\n-     * <p/>\n-     * Interpretation of \"\\\\uXXXX\" escape sequences where XXXX is a hex-number.\n-     *\n-     * @param c current char which is discarded because it's the \"\\\\\" of \"\\\\uXXXX\"\n-     * @return the decoded character\n-     * @throws IOException on wrong unicode escape sequence or read error\n-     */\n-    private int unicodeEscapeLexer(int c) throws IOException {\n-        int ret = 0;\n-        // ignore 'u' (assume c==\\ now) and read 4 hex digits\n-        c = in.read();\n-        code.clear();\n-        try {\n-            for (int i = 0; i < 4; i++) {\n-                c = in.read();\n-                if (isEndOfFile(c) || isEndOfLine(c)) {\n-                    throw new NumberFormatException(\"number too short\");\n-                }\n-                code.append((char) c);\n-            }\n-            ret = Integer.parseInt(code.toString(), 16);\n-        } catch (NumberFormatException e) {\n-            throw new IOException(\n-                    \"(line \" + getLineNumber() + \") Wrong unicode escape sequence found '\"\n-                            + code.toString() + \"'\" + e.toString());\n-        }\n-        return ret;\n-    }\n-\n     private int readEscape(int c) throws IOException {\n         // assume c is the escape char (normally a backslash)\n         c = in.read();\n-        int out;\n         switch (c) {\n             case 'r':\n-                out = '\\r';\n-                break;\n+                return '\\r';\n             case 'n':\n-                out = '\\n';\n-                break;\n+                return '\\n';\n             case 't':\n-                out = '\\t';\n-                break;\n+                return '\\t';\n             case 'b':\n-                out = '\\b';\n-                break;\n+                return '\\b';\n             case 'f':\n-                out = '\\f';\n-                break;\n+                return '\\f';\n             default:\n-                out = c;\n-        }\n-        return out;\n+                return c;\n+        }\n     }\n \n     /**\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/csv/UnicodeUnescapeReader.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import java.io.IOException;\n+import java.io.PushbackReader;\n+import java.io.Reader;\n+\n+/**\n+ * Reader transforming unicode escape sequences (i.e \\u0065) in the provided\n+ * stream into the corresponding unicode character.\n+ * \n+ * @author Emmanuel Bourg\n+ * @version $Revision$, $Date$\n+ */\n+class UnicodeUnescapeReader extends Reader {\n+    private PushbackReader reader;\n+\n+    /** The buffer used to read unicode escape sequences. */\n+    private final char[] sequence = new char[5];\n+\n+    UnicodeUnescapeReader(Reader reader) {\n+        this.reader = new PushbackReader(reader, sequence.length);\n+    }\n+\n+    public int read(char[] cbuf, int off, int len) throws IOException {\n+        int count = 0;\n+        for (int i = 0; i < len; i++) {\n+            int c = reader.read();\n+            \n+            if (c == -1) {\n+                return count == 0 ? -1 : count;\n+            }\n+            \n+            if (c == '\\\\') {\n+                int l = reader.read(sequence);\n+                if (l == sequence.length \n+                        && 'u' == sequence[0]\n+                        && isHexadecimal(sequence[1])\n+                        && isHexadecimal(sequence[2])\n+                        && isHexadecimal(sequence[3])\n+                        && isHexadecimal(sequence[4])) {\n+                    // unicode escape found\n+                    c = Integer.parseInt(new String(sequence, 1, 4), 16);\n+                    \n+                } else if (l > 0) {\n+                    // put the characters back in the stream\n+                    reader.unread(sequence, 0, l);\n+                }\n+            }\n+\n+            cbuf[off + i] = (char) c;\n+            count++;\n+        }\n+        \n+        return count;\n+    }\n+    \n+    private boolean isHexadecimal(char c) {\n+        return ('0' <= c && c <= '9') || ('a' <= c && c <= 'f') || ('A' <= c && c <= 'F');\n+    }\n+\n+    public void close() throws IOException {\n+        if (reader != null) {\n+            reader.close();\n+        }\n+    }\n+}", "timestamp": 1331135892, "metainfo": ""}