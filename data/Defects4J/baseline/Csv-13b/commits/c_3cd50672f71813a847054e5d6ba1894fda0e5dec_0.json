{"sha": "3cd50672f71813a847054e5d6ba1894fda0e5dec", "log": "CSV-117 Validate format parameters in constructor  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n             this.header = header.clone();\n         }\n         this.skipHeaderRecord = skipHeaderRecord;\n+        validate();\n     }\n \n     @Override\n     }\n \n     /**\n-     * Verifies the consistency of the parameters and throws an IllegalStateException if necessary.\n-     *\n-     * @throws IllegalStateException\n-     */\n-    void validate() throws IllegalStateException {\n+     * Verifies the consistency of the parameters and throws an IllegalArgumentException if necessary.\n+     *\n+     * @throws IllegalArgumentException\n+     */\n+    private void validate() throws IllegalArgumentException {\n         if (quoteChar != null && delimiter == quoteChar.charValue()) {\n-            throw new IllegalStateException(\n+            throw new IllegalArgumentException(\n                     \"The quoteChar character and the delimiter cannot be the same ('\" + quoteChar + \"')\");\n         }\n \n         if (escape != null && delimiter == escape.charValue()) {\n-            throw new IllegalStateException(\n+            throw new IllegalArgumentException(\n                     \"The escape character and the delimiter cannot be the same ('\" + escape + \"')\");\n         }\n \n         if (commentStart != null && delimiter == commentStart.charValue()) {\n-            throw new IllegalStateException(\n+            throw new IllegalArgumentException(\n                     \"The comment start character and the delimiter cannot be the same ('\" + commentStart + \"')\");\n         }\n \n         if (quoteChar != null && quoteChar.equals(commentStart)) {\n-            throw new IllegalStateException(\n+            throw new IllegalArgumentException(\n                     \"The comment start character and the quoteChar cannot be the same ('\" + commentStart + \"')\");\n         }\n \n         if (escape != null && escape.equals(commentStart)) {\n-            throw new IllegalStateException(\n+            throw new IllegalArgumentException(\n                     \"The comment start and the escape character cannot be the same ('\" + commentStart + \"')\");\n         }\n \n         if (escape == null && quotePolicy == Quote.NONE) {\n-            throw new IllegalStateException(\"No quotes mode set but no escape character is set\");\n+            throw new IllegalArgumentException(\"No quotes mode set but no escape character is set\");\n         }\n \n     }\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n         Assertions.notNull(reader, \"reader\");\n         Assertions.notNull(format, \"format\");\n \n-        format.validate();\n         this.format = format;\n         this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n         this.headerMap = this.initializeHeader();\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n \n         this.out = out;\n         this.format = format;\n-        this.format.validate();\n         // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n         // It seems a pain to have to track whether the header has already been printed or not.\n         if (format.getHeader() != null) {\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n         return format.withDelimiter(format.getDelimiter());\n     }\n \n-    @Test(expected = IllegalStateException.class)\n+    @Test(expected = IllegalArgumentException.class)\n     public void testDelimiterSameAsCommentStartThrowsException() {\n-        CSVFormat.DEFAULT.withDelimiter('!').withCommentStart('!').validate();\n-    }\n-\n-    @Test(expected = IllegalStateException.class)\n+        CSVFormat.DEFAULT.withDelimiter('!').withCommentStart('!');\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n     public void testDelimiterSameAsEscapeThrowsException() {\n-        CSVFormat.DEFAULT.withDelimiter('!').withEscape('!').validate();\n+        CSVFormat.DEFAULT.withDelimiter('!').withEscape('!');\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testDuplicateHeaderElements() {\n-        CSVFormat.DEFAULT.withHeader(\"A\", \"A\").validate();\n+        CSVFormat.DEFAULT.withHeader(\"A\", \"A\");\n     }\n \n     @Test\n         assertNotEquals(right, left);\n     }\n \n-    @Test(expected = IllegalStateException.class)\n+    @Test(expected = IllegalArgumentException.class)\n     public void testEscapeSameAsCommentStartThrowsException() {\n-        CSVFormat.DEFAULT.withEscape('!').withCommentStart('!').validate();\n-    }\n-\n-    @Test(expected = IllegalStateException.class)\n+        CSVFormat.DEFAULT.withEscape('!').withCommentStart('!');\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n     public void testEscapeSameAsCommentStartThrowsExceptionForWrapperType() {\n         // Cannot assume that callers won't use different Character objects\n-        CSVFormat.DEFAULT.withEscape(new Character('!')).withCommentStart(new Character('!')).validate();\n+        CSVFormat.DEFAULT.withEscape(new Character('!')).withCommentStart(new Character('!'));\n     }\n \n     @Test\n         assertFalse(formatStr.endsWith(\"null\"));\n     }\n \n-    @Test(expected = IllegalStateException.class)\n+    @Test(expected = IllegalArgumentException.class)\n     public void testQuoteCharSameAsCommentStartThrowsException() {\n-        CSVFormat.DEFAULT.withQuoteChar('!').withCommentStart('!').validate();\n-    }\n-\n-    @Test(expected = IllegalStateException.class)\n+        CSVFormat.DEFAULT.withQuoteChar('!').withCommentStart('!');\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n     public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType() {\n         // Cannot assume that callers won't use different Character objects\n-        CSVFormat.DEFAULT.withQuoteChar(new Character('!')).withCommentStart('!').validate();\n-    }\n-\n-    @Test(expected = IllegalStateException.class)\n+        CSVFormat.DEFAULT.withQuoteChar(new Character('!')).withCommentStart('!');\n+    }\n+\n+    @Test//(expected = IllegalArgumentException.class)\n     public void testQuoteCharSameAsDelimiterThrowsException() {\n-        CSVFormat.DEFAULT.withQuoteChar('!').withDelimiter('!').validate();\n-    }\n-\n-    @Test(expected = IllegalStateException.class)\n+        CSVFormat.DEFAULT.withQuoteChar('!').withDelimiter('!');\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n     public void testQuotePolicyNoneWithoutEscapeThrowsException() {\n-        CSVFormat.newFormat('!').withQuotePolicy(Quote.NONE).validate();\n+        CSVFormat.newFormat('!').withQuotePolicy(Quote.NONE);\n     }\n \n     @Test\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testWithCommentStartCRThrowsException() {\n-        CSVFormat.DEFAULT.withCommentStart(CR).validate();\n+        CSVFormat.DEFAULT.withCommentStart(CR);\n     }\n \n     @Test\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testWithDelimiterLFThrowsException() {\n-        CSVFormat.DEFAULT.withDelimiter(LF).validate();\n+        CSVFormat.DEFAULT.withDelimiter(LF);\n     }\n \n     @Test\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testWithEscapeCRThrowsExceptions() {\n-        CSVFormat.DEFAULT.withEscape(CR).validate();\n+        CSVFormat.DEFAULT.withEscape(CR);\n     }\n \n     @Test\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testWithQuoteLFThrowsException() {\n-        CSVFormat.DEFAULT.withQuoteChar(LF).validate();\n+        CSVFormat.DEFAULT.withQuoteChar(LF);\n     }\n \n     @Test", "timestamp": 1403198902, "metainfo": ""}