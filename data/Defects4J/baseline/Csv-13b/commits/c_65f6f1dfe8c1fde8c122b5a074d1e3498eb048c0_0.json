{"sha": "65f6f1dfe8c1fde8c122b5a074d1e3498eb048c0", "log": "Package private classes are not prefixed with \"CSV\": CSVLexer -> Lexer.  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n     private final CSVFormat format;\n     private final Map<String, Integer> headerMap;\n \n-    private final CSVLexer lexer;\n+    private final Lexer lexer;\n \n     /** A record buffer for getRecord(). Grows as necessary and is reused. */\n     private final List<String> record = new ArrayList<String>();\n     public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\n         format.validate();\n         this.format = format;\n-        this.lexer = new CSVLexer(format, new ExtendedBufferedReader(reader));\n+        this.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\n         this.headerMap = this.initializeHeader();\n     }\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/csv/Lexer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.csv;\n+\n+import static org.apache.commons.csv.Constants.BACKSPACE;\n+import static org.apache.commons.csv.Constants.CR;\n+import static org.apache.commons.csv.Constants.END_OF_STREAM;\n+import static org.apache.commons.csv.Constants.FF;\n+import static org.apache.commons.csv.Constants.LF;\n+import static org.apache.commons.csv.Constants.TAB;\n+import static org.apache.commons.csv.Constants.UNDEFINED;\n+import static org.apache.commons.csv.Token.Type.COMMENT;\n+import static org.apache.commons.csv.Token.Type.EOF;\n+import static org.apache.commons.csv.Token.Type.EORECORD;\n+import static org.apache.commons.csv.Token.Type.INVALID;\n+import static org.apache.commons.csv.Token.Type.TOKEN;\n+\n+import java.io.IOException;\n+\n+/**\n+ *\n+ *\n+ * @version $Id$\n+ */\n+final class Lexer {\n+\n+    /**\n+     * Constant char to use for disabling comments, escapes and encapsulation. The value -2 is used because it\n+     * won't be confused with an EOF signal (-1), and because the Unicode value {@code FFFE} would be encoded as two\n+     * chars (using surrogates) and thus there should never be a collision with a real text char.\n+     */\n+    private static final char DISABLED = '\\ufffe';\n+\n+    private final char delimiter;\n+    private final char escape;\n+    private final char quoteChar;\n+    private final char commmentStart;\n+\n+    private final boolean ignoreSurroundingSpaces;\n+    private final boolean ignoreEmptyLines;\n+\n+    /** The input stream */\n+    private final ExtendedBufferedReader in;\n+\n+    /** INTERNAL API. but ctor needs to be called dynamically by PerformanceTest class */\n+    Lexer(final CSVFormat format, final ExtendedBufferedReader in) {\n+        this.in = in;\n+        this.delimiter = format.getDelimiter();\n+        this.escape = mapNullToDisabled(format.getEscape());\n+        this.quoteChar = mapNullToDisabled(format.getQuoteChar());\n+        this.commmentStart = mapNullToDisabled(format.getCommentStart());\n+        this.ignoreSurroundingSpaces = format.getIgnoreSurroundingSpaces();\n+        this.ignoreEmptyLines = format.getIgnoreEmptyLines();\n+    }\n+\n+    /**\n+     * Returns the next token.\n+     * <p/>\n+     * A token corresponds to a term, a record change or an end-of-file indicator.\n+     *\n+     * @param token\n+     *            an existing Token object to reuse. The caller is responsible to initialize the Token.\n+     * @return the next token found\n+     * @throws java.io.IOException\n+     *             on stream access error\n+     */\n+    Token nextToken(final Token token) throws IOException {\n+\n+        // get the last read char (required for empty line detection)\n+        int lastChar = in.getLastChar();\n+\n+        // read the next char and set eol\n+        int c = in.read();\n+        /*\n+         * Note: The following call will swallow LF if c == CR. But we don't need to know if the last char was CR or LF\n+         * - they are equivalent here.\n+         */\n+        boolean eol = readEndOfLine(c);\n+\n+        // empty line detection: eol AND (last char was EOL or beginning)\n+        if (ignoreEmptyLines) {\n+            while (eol && isStartOfLine(lastChar)) {\n+                // go on char ahead ...\n+                lastChar = c;\n+                c = in.read();\n+                eol = readEndOfLine(c);\n+                // reached end of file without any content (empty line at the end)\n+                if (isEndOfFile(c)) {\n+                    token.type = EOF;\n+                    // don't set token.isReady here because no content\n+                    return token;\n+                }\n+            }\n+        }\n+\n+        // did we reach eof during the last iteration already ? EOF\n+        if (isEndOfFile(lastChar) || (!isDelimiter(lastChar) && isEndOfFile(c))) {\n+            token.type = EOF;\n+            // don't set token.isReady here because no content\n+            return token;\n+        }\n+\n+        if (isStartOfLine(lastChar) && isCommentStart(c)) {\n+            final String line = in.readLine();\n+            if (line == null) {\n+                token.type = EOF;\n+                // don't set token.isReady here because no content\n+                return token;\n+            }\n+            final String comment = line.trim();\n+            token.content.append(comment);\n+            token.type = COMMENT;\n+            return token;\n+        }\n+\n+        // important: make sure a new char gets consumed in each iteration\n+        while (token.type == INVALID) {\n+            // ignore whitespaces at beginning of a token\n+            if (ignoreSurroundingSpaces) {\n+                while (isWhitespace(c) && !eol) {\n+                    c = in.read();\n+                    eol = readEndOfLine(c);\n+                }\n+            }\n+\n+            // ok, start of token reached: encapsulated, or token\n+            if (isDelimiter(c)) {\n+                // empty token return TOKEN(\"\")\n+                token.type = TOKEN;\n+            } else if (eol) {\n+                // empty token return EORECORD(\"\")\n+                // noop: token.content.append(\"\");\n+                token.type = EORECORD;\n+            } else if (isQuoteChar(c)) {\n+                // consume encapsulated token\n+                parseEncapsulatedToken(token);\n+            } else if (isEndOfFile(c)) {\n+                // end of file return EOF()\n+                // noop: token.content.append(\"\");\n+                token.type = EOF;\n+                token.isReady = true; // there is data at EOF\n+            } else {\n+                // next token must be a simple token\n+                // add removed blanks when not ignoring whitespace chars...\n+                parseSimpleToken(token, c);\n+            }\n+        }\n+        return token;\n+    }\n+\n+    /**\n+     * Parses a simple token.\n+     * <p/>\n+     * Simple token are tokens which are not surrounded by encapsulators. A simple token might contain escaped\n+     * delimiters (as \\, or \\;). The token is finished when one of the following conditions become true:\n+     * <ul>\n+     * <li>end of line has been reached (EORECORD)</li>\n+     * <li>end of stream has been reached (EOF)</li>\n+     * <li>an unescaped delimiter has been reached (TOKEN)</li>\n+     * </ul>\n+     *\n+     * @param token\n+     *            the current token\n+     * @param ch\n+     *            the current character\n+     * @return the filled token\n+     * @throws IOException\n+     *             on stream access error\n+     */\n+    private Token parseSimpleToken(final Token token, int ch) throws IOException {\n+        // Faster to use while(true)+break than while(token.type == INVALID)\n+        while (true) {\n+            if (readEndOfLine(ch)) {\n+                token.type = EORECORD;\n+                break;\n+            } else if (isEndOfFile(ch)) {\n+                token.type = EOF;\n+                token.isReady = true; // There is data at EOF\n+                break;\n+            } else if (isDelimiter(ch)) {\n+                token.type = TOKEN;\n+                break;\n+            } else if (isEscape(ch)) {\n+                final int unescaped = readEscape();\n+                if (unescaped == Constants.END_OF_STREAM) { // unexpected char after escape\n+                    token.content.append((char) ch).append((char) in.getLastChar());\n+                } else {\n+                    token.content.append((char) unescaped);\n+                }\n+                ch = in.read(); // continue\n+            } else {\n+                token.content.append((char) ch);\n+                ch = in.read(); // continue\n+            }\n+        }\n+\n+        if (ignoreSurroundingSpaces) {\n+            trimTrailingSpaces(token.content);\n+        }\n+\n+        return token;\n+    }\n+\n+    /**\n+     * Parses an encapsulated token.\n+     * <p/>\n+     * Encapsulated tokens are surrounded by the given encapsulating-string. The encapsulator itself might be included\n+     * in the token using a doubling syntax (as \"\", '') or using escaping (as in \\\", \\'). Whitespaces before and after\n+     * an encapsulated token are ignored. The token is finished when one of the following conditions become true:\n+     * <ul>\n+     * <li>an unescaped encapsulator has been reached, and is followed by optional whitespace then:</li>\n+     * <ul>\n+     * <li>delimiter (TOKEN)</li>\n+     * <li>end of line (EORECORD)</li>\n+     * </ul>\n+     * <li>end of stream has been reached (EOF)</li> </ul>\n+     *\n+     * @param token\n+     *            the current token\n+     * @return a valid token object\n+     * @throws IOException\n+     *             on invalid state: EOF before closing encapsulator or invalid character before delimiter or EOL\n+     */\n+    private Token parseEncapsulatedToken(final Token token) throws IOException {\n+        // save current line number in case needed for IOE\n+        final long startLineNumber = getCurrentLineNumber();\n+        int c;\n+        while (true) {\n+            c = in.read();\n+\n+            if (isEscape(c)) {\n+                final int unescaped = readEscape();\n+                if (unescaped == Constants.END_OF_STREAM) { // unexpected char after escape\n+                    token.content.append((char) c).append((char) in.getLastChar());\n+                } else {\n+                    token.content.append((char) unescaped);\n+                }\n+            } else if (isQuoteChar(c)) {\n+                if (isQuoteChar(in.lookAhead())) {\n+                    // double or escaped encapsulator -> add single encapsulator to token\n+                    c = in.read();\n+                    token.content.append((char) c);\n+                } else {\n+                    // token finish mark (encapsulator) reached: ignore whitespace till delimiter\n+                    while (true) {\n+                        c = in.read();\n+                        if (isDelimiter(c)) {\n+                            token.type = TOKEN;\n+                            return token;\n+                        } else if (isEndOfFile(c)) {\n+                            token.type = EOF;\n+                            token.isReady = true; // There is data at EOF\n+                            return token;\n+                        } else if (readEndOfLine(c)) {\n+                            token.type = EORECORD;\n+                            return token;\n+                        } else if (!isWhitespace(c)) {\n+                            // error invalid char between token and next delimiter\n+                            throw new IOException(\"(line \" + getCurrentLineNumber() +\n+                                    \") invalid char between encapsulated token and delimiter\");\n+                        }\n+                    }\n+                }\n+            } else if (isEndOfFile(c)) {\n+                // error condition (end of file before end of token)\n+                throw new IOException(\"(startline \" + startLineNumber +\n+                        \") EOF reached before encapsulated token finished\");\n+            } else {\n+                // consume character\n+                token.content.append((char) c);\n+            }\n+        }\n+    }\n+\n+    private final char mapNullToDisabled(final Character c) {\n+        return c == null ? DISABLED : c.charValue();\n+    }\n+\n+    /**\n+     * Returns the current line number\n+     *\n+     * @return the current line number\n+     */\n+    long getCurrentLineNumber() {\n+        return in.getCurrentLineNumber();\n+    }\n+\n+    // TODO escape handling needs more work\n+    /**\n+     * Handle an escape sequence.\n+     * The current character must be the escape character.\n+     * On return, the next character is available by calling {@link ExtendedBufferedReader#getLastChar()}\n+     * on the input stream.\n+     *\n+     * @return the unescaped character (as an int) or {@link END_OF_STREAM} if char following the escape is invalid.\n+     * @throws IOException if there is a problem reading the stream or the end of stream is detected:\n+     * the escape character is not allowed at end of strem\n+     */\n+    int readEscape() throws IOException {\n+        // the escape char has just been read (normally a backslash)\n+        final int ch = in.read();\n+        switch (ch) {\n+        case 'r':\n+            return CR;\n+        case 'n':\n+            return LF;\n+        case 't':\n+            return TAB;\n+        case 'b':\n+            return BACKSPACE;\n+        case 'f':\n+            return FF;\n+        case CR:\n+        case LF:\n+        case FF: // TODO is this correct?\n+        case TAB: // TODO is this correct? Do tabs need to be escaped?\n+        case BACKSPACE: // TODO is this correct?\n+            return ch;\n+        case END_OF_STREAM:\n+            throw new IOException(\"EOF whilst processing escape sequence\");\n+        default:\n+            // Now check for meta-characters\n+            if (isMetaChar(ch)) {\n+                return ch;\n+            }\n+            // indicate unexpected char - available from in.getLastChar()\n+            return END_OF_STREAM;\n+        }\n+    }\n+\n+    void trimTrailingSpaces(final StringBuilder buffer) {\n+        int length = buffer.length();\n+        while (length > 0 && Character.isWhitespace(buffer.charAt(length - 1))) {\n+            length = length - 1;\n+        }\n+        if (length != buffer.length()) {\n+            buffer.setLength(length);\n+        }\n+    }\n+\n+    /**\n+     * Greedily accepts \\n, \\r and \\r\\n This checker consumes silently the second control-character...\n+     *\n+     * @return true if the given or next character is a line-terminator\n+     */\n+    boolean readEndOfLine(int ch) throws IOException {\n+        // check if we have \\r\\n...\n+        if (ch == CR && in.lookAhead() == LF) {\n+            // note: does not change ch outside of this method!\n+            ch = in.read();\n+        }\n+        return ch == LF || ch == CR;\n+    }\n+\n+    boolean isClosed() {\n+        return in.isClosed();\n+    }\n+\n+    /**\n+     * @return true if the given char is a whitespace character\n+     */\n+    boolean isWhitespace(final int ch) {\n+        return !isDelimiter(ch) && Character.isWhitespace((char) ch);\n+    }\n+\n+    /**\n+     * Checks if the current character represents the start of a line: a CR, LF or is at the start of the file.\n+     *\n+     * @param ch the character to check\n+     * @return true if the character is at the start of a line.\n+     */\n+    boolean isStartOfLine(final int ch) {\n+        return ch == LF || ch == CR || ch == UNDEFINED;\n+    }\n+\n+    /**\n+     * @return true if the given character indicates end of file\n+     */\n+    boolean isEndOfFile(final int ch) {\n+        return ch == END_OF_STREAM;\n+    }\n+\n+    boolean isDelimiter(final int ch) {\n+        return ch == delimiter;\n+    }\n+\n+    boolean isEscape(final int ch) {\n+        return ch == escape;\n+    }\n+\n+    boolean isQuoteChar(final int ch) {\n+        return ch == quoteChar;\n+    }\n+\n+    boolean isCommentStart(final int ch) {\n+        return ch == commmentStart;\n+    }\n+\n+    private boolean isMetaChar(final int ch) {\n+        return ch == delimiter ||\n+               ch == escape ||\n+               ch == quoteChar ||\n+               ch == commmentStart;\n+    }\n+\n+    /**\n+     * Closes resources.\n+     *\n+     * @throws IOException\n+     *             If an I/O error occurs\n+     */\n+    void close() throws IOException {\n+        in.close();\n+    }\n+}\n--- a/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVLexerTest.java\n         formatWithEscaping = CSVFormat.DEFAULT.withEscape('\\\\');\n     }\n \n-    private CSVLexer getLexer(final String input, final CSVFormat format) {\n-        return new CSVLexer(format, new ExtendedBufferedReader(new StringReader(input)));\n+    private Lexer getLexer(final String input, final CSVFormat format) {\n+        return new Lexer(format, new ExtendedBufferedReader(new StringReader(input)));\n     }\n \n     @Test\n     public void testSurroundingSpacesAreDeleted() throws IOException {\n         final String code = \"noSpaces,  leadingSpaces,trailingSpaces  ,  surroundingSpaces  ,  ,,\";\n-        final CSVLexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noSpaces\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingSpaces\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingSpaces\"));\n     @Test\n     public void testSurroundingTabsAreDeleted() throws IOException {\n         final String code = \"noTabs,\\tleadingTab,trailingTab\\t,\\tsurroundingTabs\\t,\\t\\t,,\";\n-        final CSVLexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"noTabs\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"leadingTab\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"trailingTab\"));\n                 \"\\n\"+\n                 \"\\n\";\n         final CSVFormat format = CSVFormat.DEFAULT.withIgnoreEmptyLines(true);\n-        final CSVLexer parser = getLexer(code, format);\n+        final Lexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n                 \"# penultimate comment\\n\"+\n                 \"# Final comment\\n\";\n         final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n-        final CSVLexer parser = getLexer(code, format);\n+        final Lexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"line\"));\n         final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#').withIgnoreEmptyLines(false);\n         assertFalse(\"Should not ignore empty lines\", format.getIgnoreEmptyLines());\n \n-        final CSVLexer parser = getLexer(code, format);\n+        final Lexer parser = getLexer(code, format);\n \n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"1\"));\n         final String code = \"a,\\\\,,b\\\\\\n\\\\,,\";\n         final CSVFormat format = CSVFormat.DEFAULT;\n         assertFalse(format.isEscaping());\n-        final CSVLexer parser = getLexer(code, format);\n+        final Lexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         // an unquoted single backslash is not an escape char\n         final String code = \"a,\\\\,,b\\\\\\\\\\n\\\\,,\\\\\\nc,d\\\\\\r\\ne\";\n         final CSVFormat format = formatWithEscaping.withIgnoreEmptyLines(false);\n         assertTrue(format.isEscaping());\n-        final CSVLexer parser = getLexer(code, format);\n+        final Lexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \",\"));\n         *        a,  \" foo \" ,b\n         */\n         final String code = \"a,\\\"foo\\\",b\\na,   \\\" foo\\\",b\\na,\\\"foo \\\"  ,b\\na,  \\\" foo \\\"  ,b\";\n-        final CSVLexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT.withIgnoreSurroundingSpaces(true));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo\"));\n         assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n     @Test\n     public void testNextToken5() throws IOException {\n         final String code = \"a,\\\"foo\\n\\\",b\\n\\\"foo\\n  baar ,,,\\\"\\n\\\"\\n\\t \\n\\\"\";\n-        final CSVLexer parser = getLexer(code, CSVFormat.DEFAULT);\n+        final Lexer parser = getLexer(code, CSVFormat.DEFAULT);\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"foo\\n\"));\n         assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b\"));\n         */\n         final String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n         final CSVFormat format = CSVFormat.DEFAULT.withQuoteChar('\\'').withCommentStart('!').withDelimiter(';');\n-        final CSVLexer parser = getLexer(code, format);\n+        final Lexer parser = getLexer(code, format);\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b and ' more\\n\"));\n     }\n     @Test\n     public void testDelimiterIsWhitespace() throws IOException {\n         final String code = \"one\\ttwo\\t\\tfour \\t five\\t six\";\n-        final CSVLexer parser = getLexer(code, CSVFormat.TDF);\n+        final Lexer parser = getLexer(code, CSVFormat.TDF);\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"one\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"two\"));\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"\"));\n \n     @Test\n     public void testEscapedCR() throws Exception {\n-        final CSVLexer lexer = getLexer(\"character\\\\\" + CR + \"Escaped\", formatWithEscaping);\n+        final Lexer lexer = getLexer(\"character\\\\\" + CR + \"Escaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n     }\n \n     @Test\n     public void testCR() throws Exception {\n-        final CSVLexer lexer = getLexer(\"character\" + CR + \"NotEscaped\", formatWithEscaping);\n+        final Lexer lexer = getLexer(\"character\" + CR + \"NotEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\"));\n         assertThat(lexer.nextToken(new Token()), hasContent(\"NotEscaped\"));\n     }\n \n     @Test\n     public void testEscapedLF() throws Exception {\n-        final CSVLexer lexer = getLexer(\"character\\\\\" + LF + \"Escaped\", formatWithEscaping);\n+        final Lexer lexer = getLexer(\"character\\\\\" + LF + \"Escaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + LF + \"Escaped\"));\n     }\n \n     @Test\n     public void testLF() throws Exception {\n-        final CSVLexer lexer = getLexer(\"character\" + LF + \"NotEscaped\", formatWithEscaping);\n+        final Lexer lexer = getLexer(\"character\" + LF + \"NotEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\"));\n         assertThat(lexer.nextToken(new Token()), hasContent(\"NotEscaped\"));\n     }\n \n     @Test // TODO is this correct? Do we expect <esc>TAB to be unescaped?\n     public void testEscapedTab() throws Exception {\n-        final CSVLexer lexer = getLexer(\"character\\\\\" + TAB + \"Escaped\", formatWithEscaping);\n+        final Lexer lexer = getLexer(\"character\\\\\" + TAB + \"Escaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + TAB + \"Escaped\"));\n     }\n \n     @Test\n     public void testTab() throws Exception {\n-        final CSVLexer lexer = getLexer(\"character\" + TAB + \"NotEscaped\", formatWithEscaping);\n+        final Lexer lexer = getLexer(\"character\" + TAB + \"NotEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + TAB + \"NotEscaped\"));\n     }\n \n     @Test // TODO is this correct? Do we expect <esc>BACKSPACE to be unescaped?\n     public void testEscapedBackspace() throws Exception {\n-        final CSVLexer lexer = getLexer(\"character\\\\\" + BACKSPACE + \"Escaped\", formatWithEscaping);\n+        final Lexer lexer = getLexer(\"character\\\\\" + BACKSPACE + \"Escaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + BACKSPACE + \"Escaped\"));\n     }\n \n     @Test\n     public void testBackspace() throws Exception {\n-        final CSVLexer lexer = getLexer(\"character\" + BACKSPACE + \"NotEscaped\", formatWithEscaping);\n+        final Lexer lexer = getLexer(\"character\" + BACKSPACE + \"NotEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + BACKSPACE + \"NotEscaped\"));\n     }\n \n     @Test // TODO is this correct? Do we expect <esc>FF to be unescaped?\n     public void testEscapedFF() throws Exception {\n-        final CSVLexer lexer = getLexer(\"character\\\\\" + FF + \"Escaped\", formatWithEscaping);\n+        final Lexer lexer = getLexer(\"character\\\\\" + FF + \"Escaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + FF + \"Escaped\"));\n     }\n \n     @Test\n     public void testFF() throws Exception {\n-        final CSVLexer lexer = getLexer(\"character\" + FF + \"NotEscaped\", formatWithEscaping);\n+        final Lexer lexer = getLexer(\"character\" + FF + \"NotEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + FF + \"NotEscaped\"));\n     }\n \n     @Test\n     public void testEscapedMySqlNullValue() throws Exception {\n         // MySQL uses \\N to symbolize null values. We have to restore this\n-        final CSVLexer lexer = getLexer(\"character\\\\NEscaped\", formatWithEscaping);\n+        final Lexer lexer = getLexer(\"character\\\\NEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\NEscaped\"));\n     }\n \n     @Test\n     public void testEscapedCharacter() throws Exception {\n-        final CSVLexer lexer = getLexer(\"character\\\\aEscaped\", formatWithEscaping);\n+        final Lexer lexer = getLexer(\"character\\\\aEscaped\", formatWithEscaping);\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\\\\aEscaped\"));\n     }\n \n     @Test\n     public void testEscapedControlCharacter() throws Exception {\n         // we are explicitly using an escape different from \\ here\n-        final CSVLexer lexer = getLexer(\"character!rEscaped\", CSVFormat.DEFAULT.withEscape('!'));\n+        final Lexer lexer = getLexer(\"character!rEscaped\", CSVFormat.DEFAULT.withEscape('!'));\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n     }\n \n     @Test\n     public void testEscapedControlCharacter2() throws Exception {\n-        final CSVLexer lexer = getLexer(\"character\\\\rEscaped\", CSVFormat.DEFAULT.withEscape('\\\\'));\n+        final Lexer lexer = getLexer(\"character\\\\rEscaped\", CSVFormat.DEFAULT.withEscape('\\\\'));\n         assertThat(lexer.nextToken(new Token()), hasContent(\"character\" + CR + \"Escaped\"));\n     }\n \n     @Test(expected = IOException.class)\n     public void testEscapingAtEOF() throws Exception {\n         final String code = \"escaping at EOF is evil\\\\\";\n-        final CSVLexer lexer = getLexer(code, formatWithEscaping);\n+        final Lexer lexer = getLexer(code, formatWithEscaping);\n \n         lexer.nextToken(new Token());\n     }\n--- a/src/test/java/org/apache/commons/csv/PerformanceTest.java\n+++ b/src/test/java/org/apache/commons/csv/PerformanceTest.java\n    }\n \n \n-   private static Constructor<CSVLexer> getLexerCtor(final String clazz) throws Exception {\n+   private static Constructor<Lexer> getLexerCtor(final String clazz) throws Exception {\n        @SuppressWarnings(\"unchecked\")\n-       final Class<CSVLexer> lexer = (Class<CSVLexer>) Class.forName(\"org.apache.commons.csv.\" + clazz);\n+       final Class<Lexer> lexer = (Class<Lexer>) Class.forName(\"org.apache.commons.csv.\" + clazz);\n        return lexer.getConstructor(new Class<?>[]{CSVFormat.class, ExtendedBufferedReader.class});\n    }\n \n        String dynamic = \"\";\n        for (int i = 0; i < max; i++) {\n            final ExtendedBufferedReader input = new ExtendedBufferedReader(getReader());\n-           CSVLexer lexer = null;\n+           Lexer lexer = null;\n            if (test.startsWith(\"CSVLexer\")) {\n                dynamic=\"!\";\n                lexer = getLexerCtor(test).newInstance(new Object[]{format, input});\n            } else {\n-               lexer = new CSVLexer(format, input);\n+               lexer = new Lexer(format, input);\n            }\n            int count = 0;\n            int fields = 0;", "timestamp": 1375905626, "metainfo": ""}