{"sha": "040c2606eb7e2cfe60e4bbcbf2928f1e971ce4b4", "log": "Rename withCommentStart to withCommentMarker to avoid confusion because there is no corresponding withCommentStop method  ", "commit": "\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n      *\n      * Note that the comment start character is only recognized at the start of a line.\n      *\n-     * @param commentStart\n+     * @param commentMarker\n      *            the comment start marker\n      * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n      * @throws IllegalArgumentException\n      *             thrown if the specified character is a line break\n      */\n-    public CSVFormat withCommentStart(final char commentStart) {\n-        return withCommentStart(Character.valueOf(commentStart));\n+    public CSVFormat withCommentMarker(final char commentMarker) {\n+        return withCommentMarker(Character.valueOf(commentMarker));\n     }\n \n     /**\n      *\n      * Note that the comment start character is only recognized at the start of a line.\n      *\n-     * @param commentStart\n+     * @param commentMarker\n      *            the comment start marker, use {@code null} to disable\n      * @return A new CSVFormat that is equal to this one but with the specified character as the comment start marker\n      * @throws IllegalArgumentException\n      *             thrown if the specified character is a line break\n      */\n-    public CSVFormat withCommentStart(final Character commentStart) {\n-        if (isLineBreak(commentStart)) {\n-            throw new IllegalArgumentException(\"The comment start character cannot be a line break\");\n-        }\n-        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n+    public CSVFormat withCommentMarker(final Character commentMarker) {\n+        if (isLineBreak(commentMarker)) {\n+            throw new IllegalArgumentException(\"The comment start marker character cannot be a line break\");\n+        }\n+        return new CSVFormat(delimiter, quoteChar, quotePolicy, commentMarker, escape,\n                 ignoreSurroundingSpaces, ignoreEmptyLines, recordSeparator, nullString, header, skipHeaderRecord,\n                 ignoreEmptyHeaders);\n     }\n--- a/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFileParserTest.java\n             } else if (\"IgnoreSpaces\".equalsIgnoreCase(option_parts[0])) {\n                 format = format.withIgnoreSurroundingSpaces(Boolean.parseBoolean(option_parts[1]));\n             } else if (\"CommentStart\".equalsIgnoreCase(option_parts[0])) {\n-                format = format.withCommentStart(option_parts[1].charAt(0));\n+                format = format.withCommentMarker(option_parts[1].charAt(0));\n             } else if (\"CheckComments\".equalsIgnoreCase(option_parts[0])) {\n                 checkComments = true;\n             } else {\n             } else if (\"IgnoreSpaces\".equalsIgnoreCase(option_parts[0])) {\n                 format = format.withIgnoreSurroundingSpaces(Boolean.parseBoolean(option_parts[1]));\n             } else if (\"CommentStart\".equalsIgnoreCase(option_parts[0])) {\n-                format = format.withCommentStart(option_parts[1].charAt(0));\n+                format = format.withCommentMarker(option_parts[1].charAt(0));\n             } else if (\"CheckComments\".equalsIgnoreCase(option_parts[0])) {\n                 checkComments = true;\n             } else {\n--- a/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVFormatTest.java\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testDelimiterSameAsCommentStartThrowsException() {\n-        CSVFormat.DEFAULT.withDelimiter('!').withCommentStart('!');\n+        CSVFormat.DEFAULT.withDelimiter('!').withCommentMarker('!');\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testEqualsCommentStart() {\n         final CSVFormat right = CSVFormat.newFormat('\\'')\n                 .withQuoteChar('\"')\n-                .withCommentStart('#')\n-                .withQuotePolicy(Quote.ALL);\n-        final CSVFormat left = right\n-                .withCommentStart('!');\n+                .withCommentMarker('#')\n+                .withQuotePolicy(Quote.ALL);\n+        final CSVFormat left = right\n+                .withCommentMarker('!');\n \n         assertNotEquals(right, left);\n     }\n     public void testEqualsEscape() {\n         final CSVFormat right = CSVFormat.newFormat('\\'')\n                 .withQuoteChar('\"')\n-                .withCommentStart('#')\n+                .withCommentMarker('#')\n                 .withEscape('+')\n                 .withQuotePolicy(Quote.ALL);\n         final CSVFormat left = right\n     public void testEqualsHeader() {\n         final CSVFormat right = CSVFormat.newFormat('\\'')\n                 .withRecordSeparator(CR)\n-                .withCommentStart('#')\n+                .withCommentMarker('#')\n                 .withEscape('+')\n                 .withHeader(\"One\", \"Two\", \"Three\")\n                 .withIgnoreEmptyLines(true)\n     @Test\n     public void testEqualsIgnoreEmptyLines() {\n         final CSVFormat right = CSVFormat.newFormat('\\'')\n-                .withCommentStart('#')\n+                .withCommentMarker('#')\n                 .withEscape('+')\n                 .withIgnoreEmptyLines(true)\n                 .withIgnoreSurroundingSpaces(true)\n     @Test\n     public void testEqualsIgnoreSurroundingSpaces() {\n         final CSVFormat right = CSVFormat.newFormat('\\'')\n-                .withCommentStart('#')\n+                .withCommentMarker('#')\n                 .withEscape('+')\n                 .withIgnoreSurroundingSpaces(true)\n                 .withQuoteChar('\"')\n     public void testEqualsRecordSeparator() {\n         final CSVFormat right = CSVFormat.newFormat('\\'')\n                 .withRecordSeparator(CR)\n-                .withCommentStart('#')\n+                .withCommentMarker('#')\n                 .withEscape('+')\n                 .withIgnoreEmptyLines(true)\n                 .withIgnoreSurroundingSpaces(true)\n     public void testEqualsNullString() {\n         final CSVFormat right = CSVFormat.newFormat('\\'')\n                 .withRecordSeparator(CR)\n-                .withCommentStart('#')\n+                .withCommentMarker('#')\n                 .withEscape('+')\n                 .withIgnoreEmptyLines(true)\n                 .withIgnoreSurroundingSpaces(true)\n     public void testEqualsSkipHeaderRecord() {\n         final CSVFormat right = CSVFormat.newFormat('\\'')\n                 .withRecordSeparator(CR)\n-                .withCommentStart('#')\n+                .withCommentMarker('#')\n                 .withEscape('+')\n                 .withIgnoreEmptyLines(true)\n                 .withIgnoreSurroundingSpaces(true)\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testEscapeSameAsCommentStartThrowsException() {\n-        CSVFormat.DEFAULT.withEscape('!').withCommentStart('!');\n+        CSVFormat.DEFAULT.withEscape('!').withCommentMarker('!');\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testEscapeSameAsCommentStartThrowsExceptionForWrapperType() {\n         // Cannot assume that callers won't use different Character objects\n-        CSVFormat.DEFAULT.withEscape(new Character('!')).withCommentStart(new Character('!'));\n+        CSVFormat.DEFAULT.withEscape(new Character('!')).withCommentMarker(new Character('!'));\n     }\n \n     @Test\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testQuoteCharSameAsCommentStartThrowsException() {\n-        CSVFormat.DEFAULT.withQuoteChar('!').withCommentStart('!');\n+        CSVFormat.DEFAULT.withQuoteChar('!').withCommentMarker('!');\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testQuoteCharSameAsCommentStartThrowsExceptionForWrapperType() {\n         // Cannot assume that callers won't use different Character objects\n-        CSVFormat.DEFAULT.withQuoteChar(new Character('!')).withCommentStart('!');\n+        CSVFormat.DEFAULT.withQuoteChar(new Character('!')).withCommentMarker('!');\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n \n     @Test\n     public void testWithCommentStart() throws Exception {\n-        final CSVFormat formatWithCommentStart = CSVFormat.DEFAULT.withCommentStart('#');\n+        final CSVFormat formatWithCommentStart = CSVFormat.DEFAULT.withCommentMarker('#');\n         assertEquals( Character.valueOf('#'), formatWithCommentStart.getCommentStart());\n     }\n \n     @Test(expected = IllegalArgumentException.class)\n     public void testWithCommentStartCRThrowsException() {\n-        CSVFormat.DEFAULT.withCommentStart(CR);\n+        CSVFormat.DEFAULT.withCommentMarker(CR);\n     }\n \n     @Test\n--- a/src/test/java/org/apache/commons/csv/CSVParserTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVParserTest.java\n     @Test(expected = NoSuchElementException.class)\n     public void testClose() throws Exception {\n         final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n-        final CSVParser parser = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in);\n+        final CSVParser parser = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in);\n         final Iterator<CSVRecord> records = parser.iterator();\n         assertTrue(records.hasNext());\n         parser.close();\n                 {\"\\n\", \" \", \"#\"},\n         };\n \n-        format = CSVFormat.DEFAULT.withCommentStart('#');\n+        format = CSVFormat.DEFAULT.withCommentMarker('#');\n         parser.close();\n         parser = CSVParser.parse(code, format);\n         records = parser.getRecords();\n     public void testHeaderComment() throws Exception {\n         final Reader in = new StringReader(\"# comment\\na,b,c\\n1,2,3\\nx,y,z\");\n \n-        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentStart('#').withHeader().parse(in).iterator();\n+        final Iterator<CSVRecord> records = CSVFormat.DEFAULT.withCommentMarker('#').withHeader().parse(in).iterator();\n \n         for (int i = 0; i < 2; i++) {\n             assertTrue(records.hasNext());\n--- a/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n+++ b/src/test/java/org/apache/commons/csv/CSVPrinterTest.java\n     @Test\n     public void testMultiLineComment() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'));\n         printer.printComment(\"This is a comment\\non multiple lines\");\n \n         assertEquals(\"# This is a comment\" + recordSeparator + \"# on multiple lines\" + recordSeparator, sw.toString());\n     @Test\n     public void testSingleLineComment() throws IOException {\n         final StringWriter sw = new StringWriter();\n-        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentStart('#'));\n+        final CSVPrinter printer = new CSVPrinter(sw, CSVFormat.DEFAULT.withCommentMarker('#'));\n         printer.printComment(\"This is a comment\");\n \n         assertEquals(\"# This is a comment\" + recordSeparator, sw.toString());\n--- a/src/test/java/org/apache/commons/csv/LexerTest.java\n+++ b/src/test/java/org/apache/commons/csv/LexerTest.java\n                 \"third,line,#no-comment\\n\"+\n                 \"# penultimate comment\\n\"+\n                 \"# Final comment\\n\";\n-        final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#');\n+        final CSVFormat format = CSVFormat.DEFAULT.withCommentMarker('#');\n         final Lexer parser = getLexer(code, format);\n \n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"first\"));\n                 \"\\n\"+                      // 6b\n                 \"\\n\"+                      // 6c\n                 \"# Final comment\\n\";       // 7\n-        final CSVFormat format = CSVFormat.DEFAULT.withCommentStart('#').withIgnoreEmptyLines(false);\n+        final CSVFormat format = CSVFormat.DEFAULT.withCommentMarker('#').withIgnoreEmptyLines(false);\n         assertFalse(\"Should not ignore empty lines\", format.isIgnoringEmptyLines());\n \n         final Lexer parser = getLexer(code, format);\n         *       ;;\n         */\n         final String code = \"a;'b and '' more\\n'\\n!comment;;;;\\n;;\";\n-        final CSVFormat format = CSVFormat.DEFAULT.withQuoteChar('\\'').withCommentStart('!').withDelimiter(';');\n+        final CSVFormat format = CSVFormat.DEFAULT.withQuoteChar('\\'').withCommentMarker('!').withDelimiter(';');\n         final Lexer parser = getLexer(code, format);\n         assertThat(parser.nextToken(new Token()), matches(TOKEN, \"a\"));\n         assertThat(parser.nextToken(new Token()), matches(EORECORD, \"b and ' more\\n\"));", "timestamp": 1405366496, "metainfo": ""}